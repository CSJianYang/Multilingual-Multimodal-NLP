[
    {
        "title": "Non-overlapping Intervals",
        "question_content": "Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n&nbsp;\nExample 1:\n\nInput: intervals = [[1,2],[2,3],[3,4],[1,3]]\nOutput: 1\nExplanation: [1,3] can be removed and the rest of the intervals are non-overlapping.\n\nExample 2:\n\nInput: intervals = [[1,2],[1,2],[1,2]]\nOutput: 2\nExplanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.\n\nExample 3:\n\nInput: intervals = [[1,2],[2,3]]\nOutput: 0\nExplanation: You don't need to remove any of the intervals since they're already non-overlapping.\n\n&nbsp;\nConstraints:\n\n\t1 <= intervals.length <= 105\n\tintervals[i].length == 2\n\t-5 * 104 <= starti < endi <= 5 * 104",
        "solutions": [
            {
                "id": 91713,
                "title": "java-least-is-most",
                "content": "Actually, the problem is the same as \"Given a collection of intervals, find the maximum number of intervals that are non-overlapping.\" (the classic Greedy problem: [Interval Scheduling](https://en.wikipedia.org/wiki/Interval_scheduling#Interval_Scheduling_Maximization)). With the solution to that problem, guess how do we get the minimum number of intervals to remove? : )\\n\\nSorting Interval.end in ascending order is O(nlogn), then traverse intervals array to get the maximum number of non-overlapping intervals is O(n). Total is O(nlogn).\\n\\n```\\n    public int eraseOverlapIntervals(Interval[] intervals) {\\n        if (intervals.length == 0)  return 0;\\n\\n        Arrays.sort(intervals, new myComparator());\\n        int end = intervals[0].end;\\n        int count = 1;        \\n\\n        for (int i = 1; i < intervals.length; i++) {\\n            if (intervals[i].start >= end) {\\n                end = intervals[i].end;\\n                count++;\\n            }\\n        }\\n        return intervals.length - count;\\n    }\\n    \\n    class myComparator implements Comparator<Interval> {\\n        public int compare(Interval a, Interval b) {\\n            return a.end - b.end;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int eraseOverlapIntervals(Interval[] intervals) {\\n        if (intervals.length == 0)  return 0;\\n\\n        Arrays.sort(intervals, new myComparator());\\n        int end = intervals[0].end;\\n        int count = 1;        \\n\\n        for (int i = 1; i < intervals.length; i++) {\\n            if (intervals[i].start >= end) {\\n                end = intervals[i].end;\\n                count++;\\n            }\\n        }\\n        return intervals.length - count;\\n    }\\n    \\n    class myComparator implements Comparator<Interval> {\\n        public int compare(Interval a, Interval b) {\\n            return a.end - b.end;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 276056,
                "title": "python-greedy-interval-scheduling",
                "content": "A classic greedy case: interval scheduling problem.\\n\\n The heuristic is: always pick the interval with the earliest end time. Then you can get the maximal number of non-overlapping intervals. (or minimal number to remove).\\n This is because, the interval with the earliest end time produces the maximal capacity to hold rest intervals. \\n E.g. Suppose current earliest end time of the rest intervals is ```x```. Then available time slot left for other intervals is ```[x:]```. If we choose another interval with end time ```y```, then available time slot would be ```[y:]```. Since ```x \\u2264 y```, there is no way ```[y:]``` can hold more intervals then ```[x:]```. Thus, the heuristic holds.\\n \\n Therefore, we can sort interval by ending time and key track of current earliest end time. Once next interval\\'s start time is earlier than current end time, then we have to remove one interval. Otherwise, we update earliest end time.\\n```\\ndef eraseOverlapIntervals(intervals):\\n\\tend, cnt = float(\\'-inf\\'), 0\\n\\tfor s, e in sorted(intervals, key=lambda x: x[1]):\\n\\t\\tif s >= end: \\n\\t\\t\\tend = e\\n\\t\\telse: \\n\\t\\t\\tcnt += 1\\n\\treturn cnt\\n```\\nTime complexity is O(NlogN) as sort overwhelms greedy search.",
                "solutionTags": [],
                "code": "```x```\n```[x:]```\n```y```\n```[y:]```\n```x \\u2264 y```\n```[y:]```\n```[x:]```\n```\\ndef eraseOverlapIntervals(intervals):\\n\\tend, cnt = float(\\'-inf\\'), 0\\n\\tfor s, e in sorted(intervals, key=lambda x: x[1]):\\n\\t\\tif s >= end: \\n\\t\\t\\tend = e\\n\\t\\telse: \\n\\t\\t\\tcnt += 1\\n\\treturn cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 792726,
                "title": "c-simple-o-nlogn-solution-with-explanation",
                "content": "we have to sort the intervals on the basis of their end points,\\nthen use a greedy approach to find the answer.\\n\\n\\tbool comp(vector<int> &a,vector<int> &b) {\\n\\t\\treturn a[1]<b[1];\\n\\t}\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n\\t\\t\\tint ans=-1;      \\n\\t\\t\\tif(intervals.size()==0) return 0;       \\n\\t\\t\\tsort(intervals.begin(),intervals.end(),comp);      //custom comperator is used.\\n\\t\\t\\tvector<int> prev= intervals[0];\\n\\n\\t\\t\\tfor(vector<int> i: intervals) {\\n\\t\\t\\t\\tif(prev[1]>i[0]) {\\n\\t\\t\\t\\t\\tans++;                //we dont update previous, because i[1] will be grater then prev[1]\\n\\t\\t\\t\\t}else prev=i;           // we want the end point to be minimum\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;                 //ans was initially made -1 because our prev and intervals[0] will always match\\n\\t\\t}\\n\\t};\\n\\t\\n-------------------upvote if you like it :) -------------------------\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n\\t\\t\\tint ans=-1;      \\n\\t\\t\\tif(intervals.size()==0) return 0;       \\n\\t\\t\\tsort(intervals.begin(),intervals.end(),comp);      //custom comperator is used.\\n\\t\\t\\tvector<int> prev= intervals[0];\\n\\n\\t\\t\\tfor(vector<int> i: intervals) {\\n\\t\\t\\t\\tif(prev[1]>i[0]) {\\n\\t\\t\\t\\t\\tans++;                //we dont update previous, because i[1] will be grater then prev[1]\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 481758,
                "title": "easy-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        if (intervals == null || intervals.length == 0) return 0;\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\\n        int prevEnd = intervals[0][1];\\n        int count = 0;\\n        for (int i = 1; i < intervals.length; i++) {\\n            if (prevEnd > intervals[i][0]) {\\n                count++;\\n                prevEnd = Math.min(intervals[i][1], prevEnd);\\n            } else {\\n                prevEnd = intervals[i][1];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nPretty straightforward. Logic is that we sort by the first element in the intervals, then when we encounter an overlap, we increase the count, and decide to remove the interval with the larger end date. In code, this translates to setting the \"prevEnd\" (the end time of the most recent non-deleted interval) to Math.min(current interval that we have encountered the conflict with, current prevEnd).",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        if (intervals == null || intervals.length == 0) return 0;\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\\n        int prevEnd = intervals[0][1];\\n        int count = 0;\\n        for (int i = 1; i < intervals.length; i++) {\\n            if (prevEnd > intervals[i][0]) {\\n                count++;\\n                prevEnd = Math.min(intervals[i][1], prevEnd);\\n            } else {\\n                prevEnd = intervals[i][1];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91721,
                "title": "short-ruby-and-python",
                "content": "Which interval would be the best **first** (leftmost) interval to keep? One that ends first, as it leaves the most room for the rest. So take one with smallest `end`, remove all the bad ones overlapping it, and repeat (taking the one with smallest `end` of the remaining ones). For the overlap test, just keep track of the current end, initialized with negative infinity.\\n\\n## Ruby\\nTake out intervals as described above, so what's left is the bad overlapping ones, so just return their number.\\n```\\ndef erase_overlap_intervals(intervals)\\n  end_ = -1.0 / 0\\n  intervals.sort_by(&:end).reject { |i|\\n    end_ = i.end if i.start >= end_\\n  }.size\\nend\\n```\\nAlternatively, `i.start >= end_ and end_ = i.end` works, too.\\n\\n## Python\\n\\n    def eraseOverlapIntervals(self, intervals):\\n        end = float('-inf')\\n        erased = 0\\n        for i in sorted(intervals, key=lambda i: i.end):\\n            if i.start >= end:\\n                end = i.end\\n            else:\\n                erased += 1\\n        return erased",
                "solutionTags": [],
                "code": "```\\ndef erase_overlap_intervals(intervals)\\n  end_ = -1.0 / 0\\n  intervals.sort_by(&:end).reject { |i|\\n    end_ = i.end if i.start >= end_\\n  }.size\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3785409,
                "title": "beat-s-100-c-java-python-beginner-friendly",
                "content": "# Intuition:\\n1. Minimum number of intervals to remove .\\n2. Which is nothing but maximum number of intervals we can should keep.\\n3. Then it comes under Maximum Meeting we can attend.\\n\\n<details>\\n<summary><strong>In Detail</strong></summary>\\n\\n1. Removing minimum number of intervals is the same as KEEPING maximum number of intervals.\\n\\n2. Now, if you look at it as scheduling maximum number of meetings in a room, then you should get it.\\nFor those unfamiliar with the Meeting scheduling problem, it is similar to this problem here, but each interval [start,end] represents the start and end time of a meeting. As there is only one room and we can have only one meeting at a time, we want to find maximum number of meetings we can schedule (in other words reject minimum number of meetings).\\n\\n3. Again we sort by end times. Why? Because regardless of when a meeting starts, a meeting that ends first leaves more time for other meetings to take place. We do not want a meeting that starts early and ends late, what we really care about is when the meeting ends and how much time it leaves for the other meetings. So, sort by endtimes, remove all overlapping meetings to get maximum meetings or reject minimum meetings. Same logic applies here in this problem.\\n</details>\\n\\n# Explanation:\\nImagine we have a set of meetings, where each meeting is represented by an interval [start_time, end_time]. The goal is to find the maximum number of non-overlapping meetings we can attend.\\n\\n1. **Sorting by end times (`cmp` function):**\\nThe function first sorts the intervals based on their end times in ascending order using the custom comparator `cmp`. This sorting is crucial because it allows us to prioritize intervals that finish early, giving us more opportunities to accommodate additional meetings later on.\\n\\n2. **Initializing variables:**\\nThe function initializes two variables, `prev` and `count`. The `prev` variable is used to keep track of the index of the last processed interval, and `count` is used to store the number of non-overlapping meetings found so far. We start `count` with 1 because the first interval is considered non-overlapping with itself.\\n\\n3. **Greedy approach:**\\nThe function uses a greedy approach to find the maximum number of non-overlapping meetings. It iterates through the sorted intervals starting from the second interval (index 1) because we\\'ve already counted the first interval as non-overlapping. For each interval at index `i`, it checks if the start time of the current interval (`intervals[i][0]`) is greater than or equal to the end time of the previous interval (`intervals[prev][1]`). If this condition is true, it means the current interval does not overlap with the previous one, and we can safely attend this meeting. In that case, we update `prev` to the current index `i` and increment `count` to reflect that we have attended one more meeting.\\n\\n4. **Return result:**\\nFinally, the function returns the number of intervals that need to be removed to make the remaining intervals non-overlapping. Since we want to maximize the number of meetings we can attend, this value is calculated as `n - count`, where `n` is the total number of intervals.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end(), cmp);\\n\\n        int prev = 0;\\n        int count = 1;\\n\\n        for(int i = 1; i < n; i++){\\n            if(intervals[i][0] >= intervals[prev][1]){\\n                prev = i;\\n                count++;\\n            }\\n        }\\n        return n - count;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        int n = intervals.length;\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1]));\\n\\n        int prev = 0;\\n        int count = 1;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (intervals[i][0] >= intervals[prev][1]) {\\n                prev = i;\\n                count++;\\n            }\\n        }\\n        return n - count;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: x[1])\\n        n = len(intervals)\\n\\n        prev = 0\\n        count = 1\\n\\n        for i in range(1, n):\\n            if intervals[i][0] >= intervals[prev][1]:\\n                prev = i\\n                count += 1\\n\\n        return n - count\\n```\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end(), cmp);\\n\\n        int prev = 0;\\n        int count = 1;\\n\\n        for(int i = 1; i < n; i++){\\n            if(intervals[i][0] >= intervals[prev][1]){\\n                prev = i;\\n                count++;\\n            }\\n        }\\n        return n - count;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        int n = intervals.length;\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1]));\\n\\n        int prev = 0;\\n        int count = 1;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (intervals[i][0] >= intervals[prev][1]) {\\n                prev = i;\\n                count++;\\n            }\\n        }\\n        return n - count;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: x[1])\\n        n = len(intervals)\\n\\n        prev = 0\\n        count = 1\\n\\n        for i in range(1, n):\\n            if intervals[i][0] >= intervals[prev][1]:\\n                prev = i\\n                count += 1\\n\\n        return n - count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793070,
                "title": "python-o-n-log-n-sort-ends-with-proof-explained",
                "content": "How you can handle this problem if you see it first time? If number of segments is small, we can try to check all possible options. However in this problem number of segments can be quite big and it is not going to work. Next options are dp or greedy approaches, that we need to check, and let us try to use greedy approach. Let us try to build the longest set of non-overlapping intevals. There are different options how we can try to choose greedy strategy:\\n\\n1. The first one strategy, which is not going to work is to sort segments by its starts, but we have counterexample here: `[1,100], [2,3], [3,4]`: we will choose only first segment, however we can choose two of them.\\n2. Another strategy is to sort segments by its ends? Why it is going to work? Let us prove it by mathematical induction: we have segments `s_1, ... , s_n` with sorted ends and we can choose `k` out of these `n` segments, such that they not overlap. We add `s_{n+1}` segment, such that its end is greater or equal than the end of `s_n`. How many segments we can choose out of our new `n+1` segments? It can not be more that `k+1`, because we can choose at most `k` out of first `n`. Also, we can choose `k+1` only in the case, when we take the last segment. When we can take the last segment? Only if it is not intersecting with segment number `n`! Because if it is intersection with some previous segment, it **must** intersect with segment number `n`: intersection of `s_{n+1}` with `s_i` means that start of `s_{n+1}` is more that end of `s_i`. and the bigger `i`, the bigger the end of `s_i`. So we always can use greedy strategy.\\n\\n**Complexity**: time complexity is `O(n log n)`, for sort all segments and space complexity is `O(n)` if we count that we use space for sorted intervals.\\n\\n```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals):\\n        intervals.sort(key = lambda x: x[1])\\n        n, count = len(intervals), 1\\n        if n == 0: return 0\\n        curr = intervals[0]\\n        \\n        for i in range(n):\\n            if curr[1] <= intervals[i][0]:\\n                count += 1\\n                curr = intervals[i]\\n                \\n        return n - count   \\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals):\\n        intervals.sort(key = lambda x: x[1])\\n        n, count = len(intervals), 1\\n        if n == 0: return 0\\n        curr = intervals[0]\\n        \\n        for i in range(n):\\n            if curr[1] <= intervals[i][0]:\\n                count += 1\\n                curr = intervals[i]\\n                \\n        return n - count   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 91700,
                "title": "concise-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<Interval>& intervals) {\\n        auto comp = [](const Interval& i1, const Interval& i2){ return i1.start < i2.start; };\\n        sort(intervals.begin(), intervals.end(), comp);\\n        int res = 0, pre = 0;\\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (intervals[i].start < intervals[pre].end) {\\n                res++;\\n                if (intervals[i].end < intervals[pre].end) pre = i;\\n            }\\n            else pre = i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<Interval>& intervals) {\\n        auto comp = [](const Interval& i1, const Interval& i2){ return i1.start < i2.start; };\\n        sort(intervals.begin(), intervals.end(), comp);\\n        int res = 0, pre = 0;\\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (intervals[i].start < intervals[pre].end) {\\n                res++;\\n                if (intervals[i].end < intervals[pre].end) pre = i;\\n            }\\n            else pre = i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91768,
                "title": "python-greedy-solution-with-explanation",
                "content": "Sort the intervals by their start time. If two intervals overlap, the interval with larger end time will be removed so as to have as little impact on subsequent intervals as possible.\\n```\\ndef eraseOverlapIntervals(self, intervals):\\n        \"\"\"\\n        :type intervals: List[Interval]\\n        :rtype: int\\n        \"\"\"\\n        if not intervals: return 0\\n        intervals.sort(key=lambda x: x.start)  # sort on start time\\n        currEnd, cnt = intervals[0].end, 0\\n        for x in intervals[1:]:\\n            if x.start < currEnd:  # find overlapping interval\\n                cnt += 1\\n                currEnd = min(currEnd, x.end)  # erase the one with larger end time\\n            else:\\n                currEnd = x.end   # update end time\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\ndef eraseOverlapIntervals(self, intervals):\\n        \"\"\"\\n        :type intervals: List[Interval]\\n        :rtype: int\\n        \"\"\"\\n        if not intervals: return 0\\n        intervals.sort(key=lambda x: x.start)  # sort on start time\\n        currEnd, cnt = intervals[0].end, 0\\n        for x in intervals[1:]:\\n            if x.start < currEnd:  # find overlapping interval\\n                cnt += 1\\n                currEnd = min(currEnd, x.end)  # erase the one with larger end time\\n            else:\\n                currEnd = x.end   # update end time\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1157602,
                "title": "easy-c-solution-with-drawing",
                "content": "```\\n// Case 1:-\\n// ------------------   -----------------\\n// |   Interval 1   |   |   Interval 2  |\\n// ------------------   -----------------\\n\\n//Case 2:-\\n// ------------------\\n// |   Interval 1   |\\n// ------------------\\n//            ------------------\\n//            |    Interval 2  |\\n//            ------------------\\n\\n//Case 3:-\\n//  --------------------\\n//  |    Interval 1    |\\n//  --------------------\\n//     --------------\\n//     | Interval 2 |\\n//     --------------\\n\\nclass Solution \\n{\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>&v) \\n    {\\n        sort(v.begin(),v.end());\\n        int count=0,l=0,r=1,n=v.size();\\n        while(r<n)\\n        {\\n            if(v[l][1]<=v[r][0]) // Non-overlapping case(Case 1)\\n            {\\n                l=r;\\n                r++;\\n            }\\n            else if(v[l][1]<=v[r][1])  // Case 2\\n            {\\n                count++;\\n                r++;\\n            }\\n            else if(v[l][1]>v[r][1])   // Case 3\\n            {\\n                count++;\\n                l=r;\\n                r++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n// Case 1:-\\n// ------------------   -----------------\\n// |   Interval 1   |   |   Interval 2  |\\n// ------------------   -----------------\\n\\n//Case 2:-\\n// ------------------\\n// |   Interval 1   |\\n// ------------------\\n//            ------------------\\n//            |    Interval 2  |\\n//            ------------------\\n\\n//Case 3:-\\n//  --------------------\\n//  |    Interval 1    |\\n//  --------------------\\n//     --------------\\n//     | Interval 2 |\\n//     --------------\\n\\nclass Solution \\n{\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>&v) \\n    {\\n        sort(v.begin(),v.end());\\n        int count=0,l=0,r=1,n=v.size();\\n        while(r<n)\\n        {\\n            if(v[l][1]<=v[r][0]) // Non-overlapping case(Case 1)\\n            {\\n                l=r;\\n                r++;\\n            }\\n            else if(v[l][1]<=v[r][1])  // Case 2\\n            {\\n                count++;\\n                r++;\\n            }\\n            else if(v[l][1]>v[r][1])   // Case 3\\n            {\\n                count++;\\n                l=r;\\n                r++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 622135,
                "title": "two-simple-python-solutions-with-explanation",
                "content": "# Solution 1: sort by starting time\\n\\nLogic:\\n1. Attend the one with smaller start time first\\n2. (Greedy) Remove the one with bigger end time if overlapping occurs (because it will always incur more overlappings in the remaining array with asceding order of start time)\\n\\nExample:\\n```\\n[[1,10], [2,3], [3,4], [5,6]]\\n```\\nFirst, we attend ```[1,10]```\\nNext, ```[2,3]``` overlaps with ```[1,10]``` as 3 < 10. Here, we are going to remove ```[1,10]``` as it would definitely produce more overlappings as we continue the iteration.\\nThirdly, attend ```[3,4]```\\nLast, attend ```[5,6]```\\n\\nCode:\\n```python\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()\\n        prev = float(\"-inf\")\\n        ans = 0\\n        for i in intervals:\\n            if i[0] >= prev:\\n                prev = i[1]\\n            else:\\n                ans += 1\\n                prev = min(prev, i[1])\\n        return ans\\n```\\n# Solution 2: sort by ending time\\nIf we think more clearly, the first solution can be improved slightly (save a line of code) by sorting the intervals with end time. Why? Becuase the greedy nature remains true even if we the remaining array is not sorted by start time. Meanwhile, if we sort them by end time and if overlap occurs, the interval that comes later must be the one to remove as it has larger end time. Take a look at the following example.\\n\\nExample:\\n### 1) sort by start time\\nExtra procedure: after comparing [1,10] and [2,3], we have to choose which one to remove by comparing the end time\\n```\\n[[1,10], [2,3], [3,4], [5,6]]\\n```\\n\\n### 2) sort by end time\\nSaved procedure: after comparing [5, 6] and [1,10], we immediately can remove the later one which is [1,10] as it must produce more overlaps in the following, i.e. with [6,11] and [9,12]\\n```\\n[[2,3], [3,4], [5,6], [1,10], [6, 11], [9, 12]]\\n```\\n\\nCode:\\n```python\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x:x[1])\\n        prev = float(\"-inf\")\\n        ans = 0\\n        for i in intervals:\\n            if i[0] >= prev:\\n                prev = i[1]\\n            else:\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n[[1,10], [2,3], [3,4], [5,6]]\\n```\n```[1,10]```\n```[2,3]```\n```[1,10]```\n```[1,10]```\n```[3,4]```\n```[5,6]```\n```python\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()\\n        prev = float(\"-inf\")\\n        ans = 0\\n        for i in intervals:\\n            if i[0] >= prev:\\n                prev = i[1]\\n            else:\\n                ans += 1\\n                prev = min(prev, i[1])\\n        return ans\\n```\n```\\n[[1,10], [2,3], [3,4], [5,6]]\\n```\n```\\n[[2,3], [3,4], [5,6], [1,10], [6, 11], [9, 12]]\\n```\n```python\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x:x[1])\\n        prev = float(\"-inf\")\\n        ans = 0\\n        for i in intervals:\\n            if i[0] >= prev:\\n                prev = i[1]\\n            else:\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 510140,
                "title": "java-solution-easy-to-understand-not-most-efficient",
                "content": "This is my first time posting a solution. I found my solution easy to understand, although it is not the most efficient.\\nPlease feel free to give me feedback, and I hope this solution helps out some people who are having a hard time understanding the problem.\\n\\n```\\n/* \\n    Results from this solution:\\n        - Runtime: 3 ms, faster than 66.65% of Java online submissions for Non-overlapping Intervals.\\n        - Memory Usage: 42.7 MB, less than 6.25% of Java online submissions for Non-overlapping Intervals.\\n*/\\n\\nclass Solution {\\n    \\n    /*\\n    This problem is very similar to the interval scheduling problem. In the interval scheduling problem you\\n    are given a list of time meetings (intervals with start and end times) and you have to find the maximum\\n    number of meetings you can attend. The solution for this problem involves using a greedy solution. In this\\n    greedy solution you sort the input by their ending times and only attend meetings where the current start time\\n    is >= the end time of the previous meeting we attend. In this problem we can do the same thing: \\n        - First sort the given input by the 2nd value in each interval\\n        - Starting at the second interval check for the invalid condition where the current interval\\'s first value\\n          is < the previous valid interval\\'s second value.\\n            - If we find an invalid interval then we increase the number of invalid intervals to remove by 1.\\n            - This requires the program to keep track of the previous valid interval\\'s end time.\\n        - Return the number of invalid intervals removed.\\n            \\n    */\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        // Checking for invalid input:\\n        if(intervals.length == 0 || intervals == null)\\n            return 0;\\n        \\n        // Sort by the second number in each interval:\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1]));\\n        int removed = 0;\\n        // The second value of the last valid interval.\\n        int prevEnd = intervals[0][1]; \\n        \\n        // We need to traverse the sorted intervals, counting the number of invalid intervals, and\\n        // updating the prevEnd value when you find a valid interval.\\n        for(int i = 1;  i < intervals.length; i++){\\n            // We have an invalid interval if the  current start time is < prevEnd;\\n            if(intervals[i][0] < prevEnd)\\n                removed++;\\n            else{\\n                prevEnd = intervals[i][1];\\n            }\\n        }\\n        \\n        // Return the number of intervals removed:\\n        return removed;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n/* \\n    Results from this solution:\\n        - Runtime: 3 ms, faster than 66.65% of Java online submissions for Non-overlapping Intervals.\\n        - Memory Usage: 42.7 MB, less than 6.25% of Java online submissions for Non-overlapping Intervals.\\n*/\\n\\nclass Solution {\\n    \\n    /*\\n    This problem is very similar to the interval scheduling problem. In the interval scheduling problem you\\n    are given a list of time meetings (intervals with start and end times) and you have to find the maximum\\n    number of meetings you can attend. The solution for this problem involves using a greedy solution. In this\\n    greedy solution you sort the input by their ending times and only attend meetings where the current start time\\n    is >= the end time of the previous meeting we attend. In this problem we can do the same thing: \\n        - First sort the given input by the 2nd value in each interval\\n        - Starting at the second interval check for the invalid condition where the current interval\\'s first value\\n          is < the previous valid interval\\'s second value.\\n            - If we find an invalid interval then we increase the number of invalid intervals to remove by 1.\\n            - This requires the program to keep track of the previous valid interval\\'s end time.\\n        - Return the number of invalid intervals removed.\\n            \\n    */\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        // Checking for invalid input:\\n        if(intervals.length == 0 || intervals == null)\\n            return 0;\\n        \\n        // Sort by the second number in each interval:\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1]));\\n        int removed = 0;\\n        // The second value of the last valid interval.\\n        int prevEnd = intervals[0][1]; \\n        \\n        // We need to traverse the sorted intervals, counting the number of invalid intervals, and\\n        // updating the prevEnd value when you find a valid interval.\\n        for(int i = 1;  i < intervals.length; i++){\\n            // We have an invalid interval if the  current start time is < prevEnd;\\n            if(intervals[i][0] < prevEnd)\\n                removed++;\\n            else{\\n                prevEnd = intervals[i][1];\\n            }\\n        }\\n        \\n        // Return the number of intervals removed:\\n        return removed;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466539,
                "title": "explanation-for-all-such-intervals-problems",
                "content": "\\nLeetcode questions based on \"intervals\": C++ Solutions and explanations\\n## **[56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)**\\nSimple sorting and merging. We keep updating p until there is an overlap and then push it to the final array.\\n```\\n    \\nvector<vector<int>> merge(vector<vector<int>>& v) {\\n\\t\\tint n = v.size();\\n\\t\\tsort(v.begin(),v.end());\\n\\t\\tvector<vector<int>> ans;\\n\\t\\tvector<int> p = v[0];\\n\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tif(p[1] >= v[i][0])\\n\\t\\t\\t\\tp = {min(p[0],v[i][0]), max(p[1],v[i][1])};\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.push_back(p);\\n\\t\\t\\t\\tp = v[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans.push_back(p);\\n\\t\\treturn ans;\\n}\\n```\\n\\n\\n## **[435. Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)**\\n\\nwe have to sort the intervals on the basis of thier end points,\\nthen use a greeady approach to find the answer.\\n\\nIf p is ending after the start of current element, we eliminate the current element but not the element contained in p because the elements are sorted according to their end points and p will have a lesser end point than the current element. So we eliminate current element to reduce the probability of overlapping with next element.\\n\\n```\\nbool comp(vector<int> a, vector<int> b)\\n{\\n    if(a[1] == b[1]) return a[0]<b[0];\\n    return a[1]<b[1];\\n}\\n\\nint eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(),comp);\\n        int n = intervals.size();\\n        int ans = 0;\\n        vector<int> p = intervals[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(p[1] > intervals[i][0])\\n                ans++;\\n            else\\n                p = intervals[i];\\n        }\\n        return ans;\\n    }\\n```\\n\\nWhy do we sort on the basis of end points, not on start points.\\n\\n- suppose you have cases like :  (1,8), (2,3), (3,4), (5,9)\\n- if you sort in the basis of start points you will end up considering (1,8) and deleting rest which collide with (1,8).\\n- For a greedy approach you will want the point with lower end point to be considered.\\n- But, We can sort on the basis of start point also, just a little tweak in the algorithm will work out that way. In case of overlap, remove the interval having the farther end point.\\n\\n```\\nint eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        int n = intervals.size();\\n        int ans = 0;\\n        int p= intervals[0][1];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(p > intervals[i][0])\\n            {\\n                ans++;\\n                p = min(p, intervals[i][1]);\\n            }\\n            else\\n                p = intervals[i][1];\\n        }\\n        return ans;\\n    }\\n```\\n\\n## **[452. Minimum Number of Arrows to Burst Balloons](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/)**\\n\\nVery similar to **435. Non-overlapping Intervals** but we have to return the number of remaining intervals.(n-ans).\\n\\n```\\nint findMinArrowShots(vector<vector<int>>& points) {\\n\\t\\tint n = points.size();\\n\\t\\tsort(points.begin(),points.end());\\n\\t\\tint p = points[0][1];\\n\\t\\tint ans = 0;   \\n\\t\\t for(int i=1;i<n;i++)\\n\\t\\t    {\\n\\t\\t        if(p >= points[i][0])\\n\\t\\t        {\\n\\t\\t            ans++;\\n\\t\\t            p = min(p, points[i][1]);\\n\\t\\t        }\\n\\t\\t        else\\n\\t\\t            p = points[i][1];\\n\\t\\t    }\\n\\t\\t\\n    return n-ans;\\n}\\n```\\n\\n## **[Meeting rooms II](https://leetcode.com/problems/meeting-rooms-ii)**\\nHere we are using a priority queue so that we can keep track of the earliest ending meeting. If the start of current meeting isn\\'t greater or equal to the end value of top element in the priority queue, we need an extra room to accommodate the meeting and hence we push the element into the priority queue. Otherwise, we pop the top element and push the current element(i.e., we re-use the room). Eventually, the size of priority queue turns out to be our answer.\\n```jsx\\nstruct comp {\\n    bool operator()(vector<int> p1, vector<int> p2)\\n    {\\n        return p1[1] > p2[1];\\n    }\\n};\\n\\nint Solution::solve(vector<vector<int> > &v) {\\n   \\n        int n = v.size();\\n        if(n==0) return 0;\\n        sort(v.begin(),v.end());\\n        priority_queue<vector<int>, vector<vector<int>>, comp> pq;\\n        pq.push(v[0]);\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<int> temp = pq.top();\\n            int x = temp[1];\\n            if(v[i][0] < x)\\n            {\\n                pq.push(v[i]);\\n            }\\n            else\\n            {\\n                pq.pop();\\n                pq.push(v[i]);\\n            }\\n        }\\n        return pq.size();\\n    \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    \\nvector<vector<int>> merge(vector<vector<int>>& v) {\\n\\t\\tint n = v.size();\\n\\t\\tsort(v.begin(),v.end());\\n\\t\\tvector<vector<int>> ans;\\n\\t\\tvector<int> p = v[0];\\n\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tif(p[1] >= v[i][0])\\n\\t\\t\\t\\tp = {min(p[0],v[i][0]), max(p[1],v[i][1])};\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.push_back(p);\\n\\t\\t\\t\\tp = v[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans.push_back(p);\\n\\t\\treturn ans;\\n}\\n```\n```\\nbool comp(vector<int> a, vector<int> b)\\n{\\n    if(a[1] == b[1]) return a[0]<b[0];\\n    return a[1]<b[1];\\n}\\n\\nint eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(),comp);\\n        int n = intervals.size();\\n        int ans = 0;\\n        vector<int> p = intervals[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(p[1] > intervals[i][0])\\n                ans++;\\n            else\\n                p = intervals[i];\\n        }\\n        return ans;\\n    }\\n```\n```\\nint eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        int n = intervals.size();\\n        int ans = 0;\\n        int p= intervals[0][1];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(p > intervals[i][0])\\n            {\\n                ans++;\\n                p = min(p, intervals[i][1]);\\n            }\\n            else\\n                p = intervals[i][1];\\n        }\\n        return ans;\\n    }\\n```\n```\\nint findMinArrowShots(vector<vector<int>>& points) {\\n\\t\\tint n = points.size();\\n\\t\\tsort(points.begin(),points.end());\\n\\t\\tint p = points[0][1];\\n\\t\\tint ans = 0;   \\n\\t\\t for(int i=1;i<n;i++)\\n\\t\\t    {\\n\\t\\t        if(p >= points[i][0])\\n\\t\\t        {\\n\\t\\t            ans++;\\n\\t\\t            p = min(p, points[i][1]);\\n\\t\\t        }\\n\\t\\t        else\\n\\t\\t            p = points[i][1];\\n\\t\\t    }\\n\\t\\t\\n    return n-ans;\\n}\\n```\n```jsx\\nstruct comp {\\n    bool operator()(vector<int> p1, vector<int> p2)\\n    {\\n        return p1[1] > p2[1];\\n    }\\n};\\n\\nint Solution::solve(vector<vector<int> > &v) {\\n   \\n        int n = v.size();\\n        if(n==0) return 0;\\n        sort(v.begin(),v.end());\\n        priority_queue<vector<int>, vector<vector<int>>, comp> pq;\\n        pq.push(v[0]);\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<int> temp = pq.top();\\n            int x = temp[1];\\n            if(v[i][0] < x)\\n            {\\n                pq.push(v[i]);\\n            }\\n            else\\n            {\\n                pq.pop();\\n                pq.push(v[i]);\\n            }\\n        }\\n        return pq.size();\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3785257,
                "title": "fast-solution-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif we sort according to end time we can do max activity.\\n\\nFor detailed explanation you can refer to my youtube channel (hindi Language)\\nhttps://youtu.be/Uuq0eJKwMzk\\n or link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\nThe code starts by defining a static comparison function called `compare`. This function takes in two intervals represented as vectors, `v1` and `v2`. The comparison is based on the end points of the intervals, specifically `v1[1]` and `v2[1]`, which represent the second element (end point) of each interval. The function returns `true` if the end point of `v1` is less than the end point of `v2`, indicating that `v1` should come before `v2` in the sorted order.\\n\\nThe `eraseOverlapIntervals` function takes in a 2D vector `intervals` representing a set of intervals. It aims to find the minimum number of intervals that need to be removed to eliminate all overlaps.\\n\\nThe code proceeds as follows:\\n\\n1. The intervals are sorted using the `compare` function as the comparison criterion. This sorts the intervals in ascending order based on their end points. By sorting the intervals, we can easily identify overlaps during iteration.\\n\\n2. Two variables, `prev` and `res`, are initialized to 0. The `prev` variable keeps track of the index of the interval with the latest end point that has been considered. The `res` variable will store the count of overlapping intervals.\\n\\n3. The code then iterates over the sorted intervals, starting from index 1 (as the first interval is already considered as the initial `prev`).\\n\\n4. For each interval at index `i`, the code checks if the end point of the previous interval (at index `prev`) is greater than the start point of the current interval (at index `i`). If this condition is true, it means there is an overlap between the two intervals.\\n\\n5. If an overlap is detected, the code increments the `res` variable to count the overlap. This means that at least one interval needs to be removed to eliminate the overlap.\\n\\n6. Otherwise, if there is no overlap, the `prev` variable is updated to `i`. This indicates that the current interval will be considered as the next non-overlapping interval.\\n\\n7. After iterating through all the intervals, the function returns the count of overlapping intervals (`res`), which represents the minimum number of intervals that need to be removed to eliminate all overlaps.\\n\\nThe code follows a greedy approach, where at each step, it makes the locally optimal choice to maximize the number of non-overlapping intervals. By sorting the intervals based on their end points and iterating through them, the code effectively identifies overlaps and counts them. The result is the minimum number of intervals that need to be removed to eliminate all overlaps.\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>&v1,vector<int>&v2){\\n        return v1[1]<v2[1];\\n        \\n    }\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),compare);\\n        int prev=0;\\n        int res=0;\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[prev][1]>intervals[i][0])\\n                res++;\\n            else{\\n                prev=i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nimport java.util.Arrays;\\nimport java.util.Comparator;\\n\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, Comparator.comparingInt(a -> a[1]));\\n        int prev = 0;\\n        int count = 0;\\n        \\n        for (int i = 1; i < intervals.length; i++) {\\n            if (intervals[prev][1] > intervals[i][0]) {\\n                count++;\\n            } else {\\n                prev = i;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: x[1])\\n        prev = 0\\n        count = 0\\n        \\n        for i in range(1, len(intervals)):\\n            if intervals[prev][1] > intervals[i][0]:\\n                count += 1\\n            else:\\n                prev = i\\n        \\n        return count\\n\\n```\\n![upvote-this-you.jpg](https://assets.leetcode.com/users/images/8d0ce986-8acb-46d1-af28-a2cba2ad0cd0_1689727935.9981775.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>&v1,vector<int>&v2){\\n        return v1[1]<v2[1];\\n        \\n    }\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),compare);\\n        int prev=0;\\n        int res=0;\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[prev][1]>intervals[i][0])\\n                res++;\\n            else{\\n                prev=i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```Java []\\nimport java.util.Arrays;\\nimport java.util.Comparator;\\n\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, Comparator.comparingInt(a -> a[1]));\\n        int prev = 0;\\n        int count = 0;\\n        \\n        for (int i = 1; i < intervals.length; i++) {\\n            if (intervals[prev][1] > intervals[i][0]) {\\n                count++;\\n            } else {\\n                prev = i;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: x[1])\\n        prev = 0\\n        count = 0\\n        \\n        for i in range(1, len(intervals)):\\n            if intervals[prev][1] > intervals[i][0]:\\n                count += 1\\n            else:\\n                prev = i\\n        \\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282743,
                "title": "java-updated-solution-based-on-the-top-voted-post",
                "content": "It seems the question has changed the input argument from `Internal[]` to `int[][] intervals`. \\nHere is the updated solution based on the highest vote solution. \\nTotal complexity: O(nlogn)\\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        if(intervals == null || intervals.length == 0) return 0; \\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\\n        \\n        int end = intervals[0][1]; \\n        int count = 1; \\n        \\n        for(int i = 1; i < intervals.length; i++){\\n            if(intervals[i][0] >= end){\\n                end = intervals[i][1]; \\n                count++; \\n            }\\n        }\\n        \\n        return intervals.length - count; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        if(intervals == null || intervals.length == 0) return 0; \\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\\n        \\n        int end = intervals[0][1]; \\n        int count = 1; \\n        \\n        for(int i = 1; i < intervals.length; i++){\\n            if(intervals[i][0] >= end){\\n                end = intervals[i][1]; \\n                count++; \\n            }\\n        }\\n        \\n        return intervals.length - count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785480,
                "title": "python3-c-java-greedy-sorting-and-dp-easy-and-understand",
                "content": "1. `intervals = sorted(intervals, key = lambda x:x[1])`: This line sorts the intervals list of lists based on the second element of each `interval`. It uses the `sorted` function with a custom sorting key specified by the lambda function `lambda x: x[1]`, which means sorting based on the second element of the sublists (i.e., the end point of each interval). The sorting is done in ascending order.\\n\\n2. `remove = 0`: This variable `remove` is used to keep track of the number of intervals that need to be removed to make the remaining intervals non-overlapping. We initialize it to 0.\\n\\n3. `end = -100000`: This variable `end` is initialized with negative infinity. It will be used to keep track of the end point of the current non-overlapping interval.\\n\\n4. `for i in intervals:`: This is a for-loop that iterates over each interval `i` in the sorted `intervals` list.\\n\\n5. `if i[0] >= end:`: This condition checks if the start of the current interval is greater than or equal to the `end`, meaning that it does not overlap with the previous interval. If this condition is true, we update the `end` to be the end point of the current interval, making it the new non-overlapping interval.\\n\\n6. `else:`: If the `if` condition is not true, it means the current interval overlaps with the previous interval. In this case, we increment the `remove` counter as we need to remove this overlapping interval to make the remaining intervals non-overlapping.\\n\\n7. `return remove`: Finally, the function returns the `remove` variable, which represents the minimum number of intervals that need to be removed to make all remaining intervals non-overlapping.\\n\\nIn summary, the given code uses a greedy approach to find the minimum number of intervals that need to be removed. It first sorts the intervals based on their end points and then iterates through the sorted intervals, updating the end point of the non-overlapping interval whenever a non-overlapping interval is found. It increments the `remove` counter whenever an overlapping interval is encountered. The final value of `remove` is returned as the result. This algorithm works because sorting the intervals by their end points allows us to greedily select non-overlapping intervals in a way that minimizes the number of removed intervals.\\n\\nExplanation from chatgpt. The solution is from me \\uD83D\\uDE07.\\n# C++\\n```\\nclass Solution{\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](const auto& a, const auto& b) {\\n            return a[1] < b[1];\\n        });\\n\\n        int remove = 0;\\n        int end =-100000;\\n        for (const auto& interval : intervals) {\\n            if (interval[0] >= end) {\\n                end = interval[1];\\n            } else {\\n                remove++;\\n            }\\n        }\\n\\n        return remove;\\n    }\\n};\\n```\\n# Python3\\n```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals = sorted(intervals, key = lambda x:x[1])\\n        remove = 0\\n        end = -100000\\n        for i in intervals:\\n            if i[0] >= end:\\n                end = i[1]\\n            else:\\n                remove += 1\\n        return remove\\n        \\n```\\n# Java\\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                return a[1] - b[1];\\n            }\\n        });\\n\\n        int remove = 0;\\n        int end = -100000;\\n        for (int[] interval : intervals) {\\n            if (interval[0] >= end) {\\n                end = interval[1];\\n            } else {\\n                remove++;\\n            }\\n        }\\n\\n        return remove;\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/2e8406f3-dd08-44bf-8b74-b4c1e3d63cb1_1685761147.083231.png)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](const auto& a, const auto& b) {\\n            return a[1] < b[1];\\n        });\\n\\n        int remove = 0;\\n        int end =-100000;\\n        for (const auto& interval : intervals) {\\n            if (interval[0] >= end) {\\n                end = interval[1];\\n            } else {\\n                remove++;\\n            }\\n        }\\n\\n        return remove;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals = sorted(intervals, key = lambda x:x[1])\\n        remove = 0\\n        end = -100000\\n        for i in intervals:\\n            if i[0] >= end:\\n                end = i[1]\\n            else:\\n                remove += 1\\n        return remove\\n        \\n```\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                return a[1] - b[1];\\n            }\\n        });\\n\\n        int remove = 0;\\n        int end = -100000;\\n        for (int[] interval : intervals) {\\n            if (interval[0] >= end) {\\n                end = interval[1];\\n            } else {\\n                remove++;\\n            }\\n        }\\n\\n        return remove;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785290,
                "title": "easy-non-overlapping-intervals-solution-greedy-approach-beats-98-45",
                "content": "\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```java []\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b)->a[1]-b[1]);\\n        int end = intervals[0][1];\\n        int count = intervals.length-1;\\n        for(int i=1; i < intervals.length; i++){\\n            if( intervals[i][0]>=end ){\\n                end = intervals[i][1];\\n                count--;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int>& a, vector<int>& b) {\\n            return a[1] < b[1];\\n        });\\n        int end = intervals[0][1];\\n        int count = intervals.size() - 1;\\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (intervals[i][0] >= end) {\\n                end = intervals[i][1];\\n                count--;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda interval: interval[1])\\n        end = intervals[0][1]\\n        count = len(intervals) - 1\\n        for i in range(1, len(intervals)):\\n            if intervals[i][0] >= end:\\n                end = intervals[i][1]\\n                count -= 1\\n        return count\\n\\n```\\n```C []\\nint eraseOverlapIntervals(int** intervals, int intervalsSize, int* intervalsColSize) {\\n    int end = intervals[0][1];\\n    int count = intervalsSize - 1;\\n    for (int i = 1; i < intervalsSize; i++) {\\n        if (intervals[i][0] >= end) {\\n            end = intervals[i][1];\\n            count--;\\n        }\\n    }\\n    return count;\\n}\\n```\\n> Feel free to comment, in case if you have any doubt.\\n**Happy Coding!**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Greedy"
                ],
                "code": "```java []\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b)->a[1]-b[1]);\\n        int end = intervals[0][1];\\n        int count = intervals.length-1;\\n        for(int i=1; i < intervals.length; i++){\\n            if( intervals[i][0]>=end ){\\n                end = intervals[i][1];\\n                count--;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int>& a, vector<int>& b) {\\n            return a[1] < b[1];\\n        });\\n        int end = intervals[0][1];\\n        int count = intervals.size() - 1;\\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (intervals[i][0] >= end) {\\n                end = intervals[i][1];\\n                count--;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda interval: interval[1])\\n        end = intervals[0][1]\\n        count = len(intervals) - 1\\n        for i in range(1, len(intervals)):\\n            if intervals[i][0] >= end:\\n                end = intervals[i][1]\\n                count -= 1\\n        return count\\n\\n```\n```C []\\nint eraseOverlapIntervals(int** intervals, int intervalsSize, int* intervalsColSize) {\\n    int end = intervals[0][1];\\n    int count = intervalsSize - 1;\\n    for (int i = 1; i < intervalsSize; i++) {\\n        if (intervals[i][0] >= end) {\\n            end = intervals[i][1];\\n            count--;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91769,
                "title": "c-greedy-with-comments-sharing-my-thought-process-variation-of-activity-selection-problem",
                "content": "I treated this as a variation of classic Greedy problem of [Activity-Selection](https://en.wikipedia.org/wiki/Activity_selection_problem). First I determine the maximum number of non-overlapping activities. When I subtract the number with size of the input, I get the number of activities I need to remove.\\n\\n    int eraseOverlapIntervals(vector<Interval>& intervals) {\\n        \\n        int n = intervals.size();\\n        if(n <= 1) {return 0;}\\n\\n        // Sort intervals based on earliest 'end' time - Greedy\\n        sort(intervals.begin(), intervals.end(), [] (Interval &a, Interval &b) {return a.end < b.end;});\\n        \\n        int finishTime = intervals[0].end;\\n        int len = 1;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(intervals[i].start >= finishTime) // This activity is compatible with our list.\\n            {\\n                len++;\\n                finishTime = intervals[i].end;\\n            }\\n        }\\n        \\n        return n - len;\\n    }",
                "solutionTags": [],
                "code": "I treated this as a variation of classic Greedy problem of [Activity-Selection](https://en.wikipedia.org/wiki/Activity_selection_problem). First I determine the maximum number of non-overlapping activities. When I subtract the number with size of the input, I get the number of activities I need to remove.\\n\\n    int eraseOverlapIntervals(vector<Interval>& intervals) {\\n        \\n        int n = intervals.size();\\n        if(n <= 1) {return 0;}\\n\\n        // Sort intervals based on earliest 'end' time - Greedy\\n        sort(intervals.begin(), intervals.end(), [] (Interval &a, Interval &b) {return a.end < b.end;});\\n        \\n        int finishTime = intervals[0].end;\\n        int len = 1;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(intervals[i].start >= finishTime) // This activity is compatible with our list.\\n            {\\n                len++;\\n                finishTime = intervals[i].end;\\n            }\\n        }\\n        \\n        return n - len;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 91771,
                "title": "java-solution-with-clear-explain",
                "content": "First we sort the array by below rules\\n- `1) sort by end, smaller end in front`\\n- `2) if end is same, sort by start, bigger start in front`\\n\\nThen, visited array by end. If we visited next closest end interval, access the bigger start priority.\\n\\n```\\n/**\\n     * 16 / 16 test cases passed\\n     * Status: Accepted\\n     * Runtime: 9 - 10 ms\\n     *\\n     * @param intervals\\n     * @return\\n     */\\npublic int eraseOverlapIntervals(Interval[] intervals) {\\n        Arrays.sort(intervals, new Comparator<Interval>() {\\n            @Override\\n            public int compare(Interval o1, Interval o2) {\\n                if (o1.end != o2.end) return o1.end - o2.end;  //first sort by end\\n                return o2.start - o1.start;  //second sort by start\\n            }\\n        });\\n\\n        int end = Integer.MIN_VALUE;\\n        int count = 0;\\n        for (Interval interval : intervals) {\\n            if (interval.start >= end) end = interval.end;\\n            else count++;\\n        }\\n\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n     * 16 / 16 test cases passed\\n     * Status: Accepted\\n     * Runtime: 9 - 10 ms\\n     *\\n     * @param intervals\\n     * @return\\n     */\\npublic int eraseOverlapIntervals(Interval[] intervals) {\\n        Arrays.sort(intervals, new Comparator<Interval>() {\\n            @Override\\n            public int compare(Interval o1, Interval o2) {\\n                if (o1.end != o2.end) return o1.end - o2.end;  //first sort by end\\n                return o2.start - o1.start;  //second sort by start\\n            }\\n        });\\n\\n        int end = Integer.MIN_VALUE;\\n        int count = 0;\\n        for (Interval interval : intervals) {\\n            if (interval.start >= end) end = interval.end;\\n            else count++;\\n        }\\n\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 736509,
                "title": "javascript-clean-5-liner-greedy-approach",
                "content": "Time Complexity: O(N LogN);\\nSpace Complexity: O(1);\\n```\\nvar eraseOverlapIntervals = function(intervals) {\\n\\t// sort by earliest finish time\\n    intervals.sort((a, b) => a[1] - b[1]);\\n    let prev = intervals[0], remove = 0;\\n    \\n    for(let i = 1; i < intervals.length; i++) {\\n        if(intervals[i][0] < prev[1]) remove++;\\n        else prev = intervals[i];\\n    }\\n    return remove;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nvar eraseOverlapIntervals = function(intervals) {\\n\\t// sort by earliest finish time\\n    intervals.sort((a, b) => a[1] - b[1]);\\n    let prev = intervals[0], remove = 0;\\n    \\n    for(let i = 1; i < intervals.length; i++) {\\n        if(intervals[i][0] < prev[1]) remove++;\\n        else prev = intervals[i];\\n    }\\n    return remove;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1489142,
                "title": "python-dp-find-the-maximum-non-overlapping-intervals-o-n-diff-greedy-with-picture",
                "content": "**\\u2714\\uFE0F Solution 1: DP Find the Maximum Non-overlapping Intervals**\\n- Firstly, we need to convert values into zero-based range, for example: convert `[[-10, -5], [10, 20]]` into `[[0, 15], [20, 30]]`.\\n- Then use DP to solve it.\\n- Let `dp[i]` `(where 0 <= i <= DIFF)` denote the maximum number of non-overlapping intervals which end at `i`.\\n- To calculate `dp[i]` we have 2 choices:\\n\\t- Don\\'t pick any intervals: `dp[i] = dp[i-1]`\\n\\t- Pick intervals which end at `i`:\\n\\t\\t- for `s` in `intervalsEndAt[i]`: `dp[i] = max(dp[i], dp[s] + 1)`\\n- Then `dp[-1]` is maximum number of non-overlapping intervals in the whole our intervals.\\n- Then the minimum number of intervals you need to remove is `len(intervals) - dp[-1]`.\\n```python\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        lower = upper = intervals[0][0]\\n        for s, e in intervals:\\n            lower = min(lower, s)\\n            upper = max(upper, e)\\n\\n        # Convert into [0...upper-lower]\\n        for i, [s, e] in enumerate(intervals):\\n            intervals[i] = [s - lower, e - lower]\\n\\n        DIFF = upper - lower\\n        dp = [0] * (DIFF + 1)\\n        intervalsEndAt = defaultdict(list)\\n        for s, e in intervals:\\n            intervalsEndAt[e].append(s)\\n\\n        for i in range(1, DIFF + 1):\\n            dp[i] = dp[i - 1]\\n            for s in intervalsEndAt[i]:\\n                dp[i] = max(dp[i], dp[s] + 1)\\n\\n        return len(intervals) - dp[-1]\\n```\\nComplexity:\\n- Time: `O(N + DIFF)`, where `N <= 10^5` is number of intervals, `DIFF = MAX - MIN`, `MAX <= 5*10^4` is the maximum value between values of intervals, `MIN >= -5*10^4` is the minimum value between values of intervals\\n- Space: `O(N + DIFF))`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: DP Find the Maximum Non-overlapping Intervals (Compression)**\\n- If the range of values is big, for example: `-10^9 <= start < end <= 10^9`, we can\\'t convert into zero base by **Solution 1**. We can compress our interval values while keeping the relative compartion order between values.\\n- Then use DP to solve it.\\n- Let `dp[i]` is the maximum number of non-overlapping intervals which end at `i`.\\n- To calculate `dp[i]` we have 2 choices:\\n\\t- Don\\'t pick any intervals: `dp[i] = dp[i-1]`\\n\\t- Pick intervals which end at `i`:\\n\\t\\t- for `s` in `intervalsEndAt[i]`: `dp[i] = max(dp[i], dp[s] + 1)`\\n- Then `dp[-1]` is maximum number of non-overlapping intervals in the whole our intervals.\\n- Then the minimum number of intervals you need to remove is `len(intervals) - dp[-1]`.\\n```python\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        def compress(intervals):\\n            myset = set()\\n            for s, e in intervals:\\n                myset.add(s)\\n                myset.add(e)\\n\\n            uniqueSorted = sorted(myset)\\n            for i, (s, e) in enumerate(intervals):\\n                newS = bisect_left(uniqueSorted, s)\\n                newE = bisect_left(uniqueSorted, e)\\n                intervals[i] = [newS, newE]\\n            return len(uniqueSorted)\\n\\n        nUnique = compress(intervals)\\n        dp = [0] * nUnique\\n        intervalsEndAt = defaultdict(list)\\n        for s, e in intervals:\\n            intervalsEndAt[e].append(s)\\n\\n        for i in range(1, nUnique):\\n            dp[i] = dp[i - 1]\\n            for s in intervalsEndAt[i]:\\n                dp[i] = max(dp[i], dp[s] + 1)\\n\\n        return len(intervals) - dp[-1]\\n```\\nComplexity:\\n- Time: `O(NlogN)`, where `N <= 10^5` is number of intervals.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Greedy - Sort intervals in increasing order by starting point**\\n- Sort intervals in increasing order by starting point.\\n- Let `cntValidIntervals` keep count of number of non-overlapping intervals.\\n- Iterate in sorted intervals:\\n\\t- If two intervals are overlapping, we will choose the interval that has the shorter end point.\\n\\t- Else if not overlapping, we pick that interval, increase `cntValidIntervals` by one.\\n\\n![image](https://assets.leetcode.com/users/images/b62d7bef-c4a5-4004-9664-c5e804cf00cc_1632763147.8296814.png)\\n\\n```python\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()\\n        \\n        cntValidIntervals = 1\\n        n = len(intervals)\\n        lastEnd = intervals[0][1]\\n        for i in range(1, n):\\n            s, e = intervals[i]\\n            if s >= lastEnd:\\n                cntValidIntervals += 1\\n                lastEnd = e\\n            else:\\n                lastEnd = min(lastEnd, e)  # Choose the interval that has the shorter end point.\\n        \\n        return n - cntValidIntervals\\n```\\nComplexity:\\n- Time: `O(NlogN)`, where `N <= 10^5` is number of intervals.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        lower = upper = intervals[0][0]\\n        for s, e in intervals:\\n            lower = min(lower, s)\\n            upper = max(upper, e)\\n\\n        # Convert into [0...upper-lower]\\n        for i, [s, e] in enumerate(intervals):\\n            intervals[i] = [s - lower, e - lower]\\n\\n        DIFF = upper - lower\\n        dp = [0] * (DIFF + 1)\\n        intervalsEndAt = defaultdict(list)\\n        for s, e in intervals:\\n            intervalsEndAt[e].append(s)\\n\\n        for i in range(1, DIFF + 1):\\n            dp[i] = dp[i - 1]\\n            for s in intervalsEndAt[i]:\\n                dp[i] = max(dp[i], dp[s] + 1)\\n\\n        return len(intervals) - dp[-1]\\n```\n```python\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        def compress(intervals):\\n            myset = set()\\n            for s, e in intervals:\\n                myset.add(s)\\n                myset.add(e)\\n\\n            uniqueSorted = sorted(myset)\\n            for i, (s, e) in enumerate(intervals):\\n                newS = bisect_left(uniqueSorted, s)\\n                newE = bisect_left(uniqueSorted, e)\\n                intervals[i] = [newS, newE]\\n            return len(uniqueSorted)\\n\\n        nUnique = compress(intervals)\\n        dp = [0] * nUnique\\n        intervalsEndAt = defaultdict(list)\\n        for s, e in intervals:\\n            intervalsEndAt[e].append(s)\\n\\n        for i in range(1, nUnique):\\n            dp[i] = dp[i - 1]\\n            for s in intervalsEndAt[i]:\\n                dp[i] = max(dp[i], dp[s] + 1)\\n\\n        return len(intervals) - dp[-1]\\n```\n```python\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()\\n        \\n        cntValidIntervals = 1\\n        n = len(intervals)\\n        lastEnd = intervals[0][1]\\n        for i in range(1, n):\\n            s, e = intervals[i]\\n            if s >= lastEnd:\\n                cntValidIntervals += 1\\n                lastEnd = e\\n            else:\\n                lastEnd = min(lastEnd, e)  # Choose the interval that has the shorter end point.\\n        \\n        return n - cntValidIntervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 792805,
                "title": "python-sorting-o-nlogn-solution-w-explanation-beats-94",
                "content": "**Thought process**: \\nThis problem asks us to find the minimum # of intervals to remove to maintain zero overlap, in other words, we want to find the maximum # of intervals to keep while having no overlap. \\n\\nSo how do we check overlaps? We could compare every pair of intervals, but that alone would be `O(n^2)`; so is it really necessary to check *every* pair of intervals? And we realize that if the array was sorted, the problem is simplified a lot because the potential overlapping intervals would be adjacent to one another.\\n\\nFor example consider the sorted array:\\n[[1,2],[1,3],[2,3],[3,4]]\\nStart from the beginning, \\n1. [[1,2], [1,3]]-> it\\'s obvious these two overlap; would there be any reason to keep [1,3] instead of [1,2]? No. Because it will only decrease the number of intervals we can fit without causing overlaps. So we keep [1,2], aka the interval with the **smaller** ending. \\n2. [[1,2], [2,3]]-> No overlap here, we can keep both. now the \"most recent interval\" is [2,3]\\n3. [[2,3],[3,4]] -> No overlap here, we can keep both. now the  \"most recent interval\" is [3,4]\\n4. We can fit 3 intervals without overlap, so we return len(s)-3=4-3=1\\n\\n**Generalized algorithm**: \\nsort the array and keep track of the last interval\\'s ending point as end\\nif end > next interval\\'s beginning, keep the interval that ends earlier\\nif end <= next interval\\'s beginning or we reach the end, increment the interval count\\n\\n**Code**:\\n```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        if not intervals:\\n            return 0\\n        intervals.sort()\\n        lastIntervalEnd = intervals[0][0] #edit: removed -1 per @jca88\\'s comment\\n        maxNonoverlapIntervals = 0\\n        for interval in intervals:\\n            if lastIntervalEnd > interval[0]:\\n                lastIntervalEnd = min(lastIntervalEnd, interval[1])\\n            else:\\n                maxNonoverlapIntervals += 1\\n                lastIntervalEnd = interval[1]        \\n        return len(intervals) - maxNonoverlapIntervals\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        if not intervals:\\n            return 0\\n        intervals.sort()\\n        lastIntervalEnd = intervals[0][0] #edit: removed -1 per @jca88\\'s comment\\n        maxNonoverlapIntervals = 0\\n        for interval in intervals:\\n            if lastIntervalEnd > interval[0]:\\n                lastIntervalEnd = min(lastIntervalEnd, interval[1])\\n            else:\\n                maxNonoverlapIntervals += 1\\n                lastIntervalEnd = interval[1]        \\n        return len(intervals) - maxNonoverlapIntervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91772,
                "title": "simple-solution",
                "content": "1. Order intervals by start point.\\n2. Record the end of the last valid interval.\\n3. For each interval, if is start point is >= the end of the last valid interval, increment the count of valid intervals, and move the end point to the end of the current interval. Otherwise just set the new end point to the minimum between the two overlapping intervals.\\n4. Return the difference between the number of intervals in the input array and the number of valid intervals you found in the previous way.\\n\\nHere is my implementation:\\n```\\npublic int eraseOverlapIntervals(Interval[] intervals) {\\n\\tif(intervals==null || intervals.length==0) return 0;\\n\\tArrays.sort(intervals, new Comparator<Interval>() {\\n\\t\\tpublic int compare(Interval i1, Interval i2) {\\n\\t\\t\\treturn i1.start-i2.start;\\n\\t\\t}\\n\\t});\\n\\tint count=1;\\n\\tint lastEnd = intervals[0].end;\\n\\tfor(int i=1;i<intervals.length;i++) {\\n\\t\\tInterval currentInterval = intervals[i];\\n\\t\\tif(currentInterval.start>=lastEnd) {\\n\\t\\t\\tcount++;\\n\\t\\t\\tlastEnd=currentInterval.end;\\n\\t\\t} else {\\n\\t\\t\\tlastEnd=Math.min(currentInterval.end,lastEnd);\\n\\t\\t}\\n\\t}\\n\\treturn intervals.length-count;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\npublic int eraseOverlapIntervals(Interval[] intervals) {\\n\\tif(intervals==null || intervals.length==0) return 0;\\n\\tArrays.sort(intervals, new Comparator<Interval>() {\\n\\t\\tpublic int compare(Interval i1, Interval i2) {\\n\\t\\t\\treturn i1.start-i2.start;\\n\\t\\t}\\n\\t});\\n\\tint count=1;\\n\\tint lastEnd = intervals[0].end;\\n\\tfor(int i=1;i<intervals.length;i++) {\\n\\t\\tInterval currentInterval = intervals[i];\\n\\t\\tif(currentInterval.start>=lastEnd) {\\n\\t\\t\\tcount++;\\n\\t\\t\\tlastEnd=currentInterval.end;\\n\\t\\t} else {\\n\\t\\t\\tlastEnd=Math.min(currentInterval.end,lastEnd);\\n\\t\\t}\\n\\t}\\n\\treturn intervals.length-count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1520653,
                "title": "c-sorting",
                "content": "We can take the **greedy** approach to this problem and **sort** the intervals by their start times. We keep track of the end time for the previous interval and compare it to the current interval\\'s start time. If they overlap (the current\\'s start time is less than the previous\\'s end time), then we \"erase\" the interval with the higher end time. If they don\\'t overlap, then just replace the previous\\'s end time with the current\\'s end time. **Time complexity** is **O(nlog(n))** because of sorting and **Space complexity** is **O(1)**.\\n```cpp\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        int erased_intervals = 0;\\n        int previous_end = intervals[0][1];\\n        for (int i = 1; i < intervals.size(); ++i) {\\n            if (intervals[i][0] < previous_end) {\\n                erased_intervals++;\\n                previous_end = min(previous_end, intervals[i][1]);\\n            } else {\\n                previous_end = intervals[i][1];\\n            }\\n        }\\n        return erased_intervals;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        int erased_intervals = 0;\\n        int previous_end = intervals[0][1];\\n        for (int i = 1; i < intervals.size(); ++i) {\\n            if (intervals[i][0] < previous_end) {\\n                erased_intervals++;\\n                previous_end = min(previous_end, intervals[i][1]);\\n            } else {\\n                previous_end = intervals[i][1];\\n            }\\n        }\\n        return erased_intervals;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793763,
                "title": "python-clean-code-with-concise-explanation",
                "content": "Sorting the intervals in ascending order w.r.t. the lower bounds. This requires O(nlogn). After sorting, there are only three situations we need to consider iteratively:\\n1. The next interval is *contained* in the previous interval. One of them has to be removed, hence increment `result` by 1. Since the next interval has a lower upper bound, change `prev` to new upper bound value, i.e. remove the previous interval.\\n2. The next interval *intersects* with the previous interval. One of them has to be removed, hence increment `result` by 1. Since the next interval has a higher upper bound, don\\'t change the value of `prev`, i.e. remove the next interval.\\n3. The next interval *does not overlap* with the previous interval. Simple, just update `prev` to the new value.\\n\\n```\\ndef eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n    intervals.sort()\\n    result, prev = 0, -sys.maxsize\\n    for l, r in intervals:\\n        if l < prev:\\n            result += 1\\n            if r > prev:\\n                continue\\n        prev = r\\n    return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n    intervals.sort()\\n    result, prev = 0, -sys.maxsize\\n    for l, r in intervals:\\n        if l < prev:\\n            result += 1\\n            if r > prev:\\n                continue\\n        prev = r\\n    return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 173784,
                "title": "python-solution",
                "content": "Basically the same as 646. Maximum Length of Pair Chain. Difference is that there we need to count the maximum number of disjoint pairs of intervals and here we need to count the minimum number of intervals removed to get disjoint pairs of intervals. The two numbers add up to the total number of intervals. Hence solving one problem immediately gives the answer to the other one.\\n\\nFirst sort by the end points of the intervals and then count the maximum number of disjoint intervals. The number of interals removed is given by the difference between `len(intervals)` and the number above.\\n```\\nclass Solution(object):\\n    def eraseOverlapIntervals(self, intervals):\\n        \"\"\"\\n        :type intervals: List[Interval]\\n        :rtype: int\\n        \"\"\"\\n        if not intervals:\\n            return 0\\n        intervals = sorted(intervals, key = lambda x: x.end)\\n        curr = -float(\\'inf\\')\\n        count = 0\\n        for i in range(len(intervals)):\\n            if intervals[i].start >= curr:\\n                curr = intervals[i].end\\n                count += 1\\n        return len(intervals) - count\\n```\\nSame algorithm, directly counting the number of intervals removed.\\n```\\nclass Solution(object):\\n    def eraseOverlapIntervals(self, intervals):\\n        \"\"\"\\n        :type intervals: List[Interval]\\n        :rtype: int\\n        \"\"\"\\n        if not intervals:\\n            return 0\\n        intervals = sorted(intervals, key = lambda x: x.end)\\n        curr = -float(\\'inf\\')\\n        count = 0\\n        for i in range(len(intervals)):\\n            if intervals[i].start < curr:\\n                count += 1\\n            else:\\n                curr = intervals[i].end\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def eraseOverlapIntervals(self, intervals):\\n        \"\"\"\\n        :type intervals: List[Interval]\\n        :rtype: int\\n        \"\"\"\\n        if not intervals:\\n            return 0\\n        intervals = sorted(intervals, key = lambda x: x.end)\\n        curr = -float(\\'inf\\')\\n        count = 0\\n        for i in range(len(intervals)):\\n            if intervals[i].start >= curr:\\n                curr = intervals[i].end\\n                count += 1\\n        return len(intervals) - count\\n```\n```\\nclass Solution(object):\\n    def eraseOverlapIntervals(self, intervals):\\n        \"\"\"\\n        :type intervals: List[Interval]\\n        :rtype: int\\n        \"\"\"\\n        if not intervals:\\n            return 0\\n        intervals = sorted(intervals, key = lambda x: x.end)\\n        curr = -float(\\'inf\\')\\n        count = 0\\n        for i in range(len(intervals)):\\n            if intervals[i].start < curr:\\n                count += 1\\n            else:\\n                curr = intervals[i].end\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785519,
                "title": "intuition-video-solution-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/bMgIYLGw8gI\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b) -> (a[1] - b[1]));\\n        int ans = 0;\\n        int endTime = -60000;\\n        for (int i = 0;i<intervals.length;i++) {\\n            if(intervals[i][0]<endTime) ans++;\\n            else endTime = intervals[i][1];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[1] < b[1];\\n        });\\n        \\n        int ans = 0;\\n        int endTime = -60000;\\n        for (int i = 0; i < intervals.size(); i++) {\\n            if (intervals[i][0] < endTime) {\\n                ans++;\\n            } else {\\n                endTime = intervals[i][1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: x[1])        \\n        ans = 0\\n        endTime = -60000\\n        for interval in intervals:\\n            if interval[0] < endTime:\\n                ans += 1\\n            else:\\n                endTime = interval[1]  \\n        return ans\\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b) -> (a[1] - b[1]));\\n        int ans = 0;\\n        int endTime = -60000;\\n        for (int i = 0;i<intervals.length;i++) {\\n            if(intervals[i][0]<endTime) ans++;\\n            else endTime = intervals[i][1];\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[1] < b[1];\\n        });\\n        \\n        int ans = 0;\\n        int endTime = -60000;\\n        for (int i = 0; i < intervals.size(); i++) {\\n            if (intervals[i][0] < endTime) {\\n                ans++;\\n            } else {\\n                endTime = intervals[i][1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: x[1])        \\n        ans = 0\\n        endTime = -60000\\n        for interval in intervals:\\n            if interval[0] < endTime:\\n                ans += 1\\n            else:\\n                endTime = interval[1]  \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785345,
                "title": "c-faster-than-90-explained-greedy-sorting-clean-concise-code",
                "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\n\\nWe are asked to get the number of intervals to be removed , such that there are no overlapping intervals. What makes and interval overlapping?, and how can we get the count of all overlapping intervals.\\n         We can clearly say that two intervals are overlapping when they share some common part, and to get the count of overlapping we can simply see which intervals are sharing common parts, For that clearly we will require to sort the array,(as if overlapping occurs it occurs between two adjacent intevals).But 1 thig to be noted here is, **We dont have to get the count of overlapping intervals, we have to get the count of those minimum itervals to be removed such that all the remaining range becomes non overlapping**. Now we will think of something Greedy, Like to remove that interval which is overlapping with most intervals. So we can say that if, points[index][1] > points[index+1][0],(closing of a previous interval > opening of the next interval), they we will have an overlap.\\n\\n\\n## APPROACH\\n\\n1. Sort the Array in Non Decreasing order\\n2. Choose r as the closing of First Interval\\n3. if(r>opening interval), there is an overlap, and we will increase our count, and take minimum of both\\n4. else we will update r \\n5. return cnt\\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int eraseOverlapIntervals(vector<vector<int>>&points) {\\n\\n        sort(points.begin(),points.end());\\n\\n        int  r = points[0][1], cnt = 0;\\n\\n        for(int i = 1; i < points.size(); ++i)\\n        {\\n            if(r > points[i][0])\\n            {\\n                r = min(r, points[i][1]);\\n                cnt++; \\n            }\\n\\n            else r = points[i][1];\\n                    \\n        }\\n         return cnt; \\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int eraseOverlapIntervals(vector<vector<int>>&points) {\\n\\n        sort(points.begin(),points.end());\\n\\n        int  r = points[0][1], cnt = 0;\\n\\n        for(int i = 1; i < points.size(); ++i)\\n        {\\n            if(r > points[i][0])\\n            {\\n                r = min(r, points[i][1]);\\n                cnt++; \\n            }\\n\\n            else r = points[i][1];\\n                    \\n        }\\n         return cnt; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793040,
                "title": "java-beats-99",
                "content": "```\\nclass Solution {\\n\\tpublic int eraseOverlapIntervals(int[][] intervals) {\\n\\n\\t\\tint count = 0;\\n\\t\\tif (intervals.length == 0) {\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\n\\t\\tArrays.sort(intervals, (a,b) -> (a[0] - b[0]));\\n\\t\\tcount = 0;\\n\\t\\tint end = intervals[0][1];\\n\\n\\t\\tfor (int i = 1; i < intervals.length; i++) {\\n\\t\\t\\tif(end > intervals[i][0]) {\\n\\t\\t\\t\\tend = Math.min(end, intervals[i][1]);\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tend = intervals[i][1];\\n\\t\\t\\t}\\t\\t\\n        }\\n\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int eraseOverlapIntervals(int[][] intervals) {\\n\\n\\t\\tint count = 0;\\n\\t\\tif (intervals.length == 0) {\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\n\\t\\tArrays.sort(intervals, (a,b) -> (a[0] - b[0]));\\n\\t\\tcount = 0;\\n\\t\\tint end = intervals[0][1];\\n\\n\\t\\tfor (int i = 1; i < intervals.length; i++) {\\n\\t\\t\\tif(end > intervals[i][0]) {\\n\\t\\t\\t\\tend = Math.min(end, intervals[i][1]);\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tend = intervals[i][1];\\n\\t\\t\\t}\\t\\t\\n        }\\n\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794491,
                "title": "c-solution-with-explanation",
                "content": "**Please upvote if you find it useful**\\n\\nFirst sort the intervals according to the value of the first element.\\nNow, we have three cases:-\\n\\n1. The interval is not overlapping with the previous interval. In this case, we don\\'t have to delete any interval.\\n\\t![image](https://assets.leetcode.com/users/images/add72478-987a-45a2-be5a-8b7d46d95727_1597559484.8855276.png)\\n 2. The interval is overlapping with the previous interval and is completely within it. In this, it is always better to delete the previous interval.\\n\\n\\t![image](https://assets.leetcode.com/users/images/9dcf85d7-f987-4b2e-b97a-c2fdf22f0bdc_1597559546.3445346.png)\\n\\n\\n3. The interval is overlapping but the end element is outside the previous interval. In this it is always better to delete the current interval.\\n![image](https://assets.leetcode.com/users/images/528a01df-82ff-43c4-8c86-2d184686aaa9_1597559806.6753595.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n        int prev = 0;\\n        int ans = 0;\\n        for(int i=1;i<n;i++) {\\n            if(intervals[i][0] < intervals[prev][1] and intervals[i][1] <= intervals[prev][1]) {\\n                ans++;\\n                prev = i;\\n            }\\n            else if(intervals[i][0] < intervals[prev][1] and intervals[i][1] > intervals[prev][1]) {\\n                ans++;\\n            }\\n            else {\\n                prev = i;\\n            }\\n        }\\n        return ans;\\n    } \\n};\\n```\\n\\nP.S:- Sorry for the bad figure. :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n        int prev = 0;\\n        int ans = 0;\\n        for(int i=1;i<n;i++) {\\n            if(intervals[i][0] < intervals[prev][1] and intervals[i][1] <= intervals[prev][1]) {\\n                ans++;\\n                prev = i;\\n            }\\n            else if(intervals[i][0] < intervals[prev][1] and intervals[i][1] > intervals[prev][1]) {\\n                ans++;\\n            }\\n            else {\\n                prev = i;\\n            }\\n        }\\n        return ans;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249206,
                "title": "c-easy-solution-91-faster-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        //first sort the intervals\\n        sort(intervals.begin(),intervals.end());\\n        \\n        //find the overlapping intervals and greeedily remove a interval\\n        int count=0;\\n        int i=0;\\n        int j=1;\\n        //we use to pointers to compare two intervals\\n        int n=intervals.size();\\n        while(j<n){\\n            //compare i and j\\n            if(intervals[i][1]<=intervals[j][0])\\n            {\\n                //if i and j intervals are not overlapping\\n                i=j;\\n                j++;\\n            }\\n            else if(intervals[i][1]>=intervals[j][1])\\n            {\\n                //if j interval is completely overlapped in i\\n                //and i interval size is greater than j\\n                //it is better to reemove i  interval\\n                count+=1;\\n                i=j;\\n                j++;\\n            }\\n            else if(intervals[i][1]>intervals[j][0])\\n            {\\n                //if j interval is overlapping only some portion of i\\n                //it is better to remove j\\n                count+=1;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Please upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        //first sort the intervals\\n        sort(intervals.begin(),intervals.end());\\n        \\n        //find the overlapping intervals and greeedily remove a interval\\n        int count=0;\\n        int i=0;\\n        int j=1;\\n        //we use to pointers to compare two intervals\\n        int n=intervals.size();\\n        while(j<n){\\n            //compare i and j\\n            if(intervals[i][1]<=intervals[j][0])\\n            {\\n                //if i and j intervals are not overlapping\\n                i=j;\\n                j++;\\n            }\\n            else if(intervals[i][1]>=intervals[j][1])\\n            {\\n                //if j interval is completely overlapped in i\\n                //and i interval size is greater than j\\n                //it is better to reemove i  interval\\n                count+=1;\\n                i=j;\\n                j++;\\n            }\\n            else if(intervals[i][1]>intervals[j][0])\\n            {\\n                //if j interval is overlapping only some portion of i\\n                //it is better to remove j\\n                count+=1;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 586430,
                "title": "c-short-solution",
                "content": "```\\npublic int EraseOverlapIntervals(int[][] intervals) {\\n    if (intervals.Length == 0) return 0;\\n    Array.Sort(intervals, (x, y) => x[1].CompareTo(y[1]));\\n    int result = 0;\\n    int end = intervals[0][1];\\n    for (int i = 1; i < intervals.Length; i++)\\n        if (intervals[i][0] >= end)\\n            end = intervals[i][1];\\n        else\\n            result++;\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int EraseOverlapIntervals(int[][] intervals) {\\n    if (intervals.Length == 0) return 0;\\n    Array.Sort(intervals, (x, y) => x[1].CompareTo(y[1]));\\n    int result = 0;\\n    int end = intervals[0][1];\\n    for (int i = 1; i < intervals.Length; i++)\\n        if (intervals[i][0] >= end)\\n            end = intervals[i][1];\\n        else\\n            result++;\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3785996,
                "title": "simple-knapsack-dp-binary-search-easy-solution",
                "content": "# Intuition\\nSort the interval and take the next nearest eligible interval for every index, so can use DP.\\n\\n# Approach\\nSimple Knapsack DP + Binary Search\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code - ( Memoization + Linear Search ) - TLE\\n```\\nclass Solution {\\nprivate:\\n    int n;\\n    vector<pair<int,int>> inter;\\n    // finds max index which can be taken\\n    int solve(vector<int> &dp, int i){\\n        // base case\\n        if(i>=n) return 0;\\n        // memoization case\\n        if(dp[i]!=-1)   return dp[i];\\n        // calling recursion\\n        // op1 is to take\\n        int j;\\n        for(j=i+1;j<n and inter[j].first<inter[i].second;j++){} // getting next eligible index\\n        int op1 = 1 + solve(dp,j);\\n        // op2 is to not take\\n        int op2 = solve(dp,i+1);\\n        return dp[i]=max(op1,op2);\\n    }\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals){\\n        n=intervals.size();\\n        for(auto i: intervals)\\n            inter.push_back({i[0],i[1]});\\n        sort(inter.begin(),inter.end());\\n        // using recursion and memoization\\n        vector<int> dp(n,-1);\\n        return n - solve(dp,0);\\n    }\\n};\\n```\\n\\n# Code - ( Tabulation + Linear Search ) - TLE\\n```\\nclass Solution{\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals){\\n        // precomputation\\n        int n,j;\\n        vector<pair<int,int>> inter;\\n        n=intervals.size();\\n        for(auto i: intervals)\\n            inter.push_back({i[0],i[1]});\\n        sort(inter.begin(),inter.end());\\n        // tabulation\\n        vector<int> dp(n+1,0);\\n        for(int i=n-1;i>=0;i--){\\n            for(j=i+1;j<n and inter[j].first<inter[i].second;j++){}\\n            dp[i]=max(1+dp[j],dp[i+1]);\\n        }\\n        return n-dp[0];\\n    }\\n};\\n```\\n\\n# Code - ( Tabulation + Binary Search ) - Passed\\n```\\nclass Solution{\\nprivate:\\n    int n;\\n    vector<pair<int,int>> inter;\\n    // searches for nearest next interval using binary search\\n    // invariants:\\n    // inter[l].first<inter[i].second\\n    // inter[r].first>=inter[i].second\\n    int searchNextMin(int i){\\n        int l=i, r=n;\\n        while(r>l+1){\\n            int m=(l+r)/2;\\n            if(inter[m].first<inter[i].second)\\n                l=m;\\n            else\\n                r=m;\\n        }\\n        return r;\\n    }\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals){\\n        // precomputation\\n        n=intervals.size();\\n        for(auto i: intervals)\\n            inter.push_back({i[0],i[1]});\\n        sort(inter.begin(),inter.end());\\n        // tabulation\\n        vector<int> dp(n+1,0);\\n        for(int i=n-1;i>=0;i--){\\n            int j=searchNextMin(i);\\n            dp[i]=max(1+dp[j],dp[i+1]);\\n        }\\n        return n-dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int n;\\n    vector<pair<int,int>> inter;\\n    // finds max index which can be taken\\n    int solve(vector<int> &dp, int i){\\n        // base case\\n        if(i>=n) return 0;\\n        // memoization case\\n        if(dp[i]!=-1)   return dp[i];\\n        // calling recursion\\n        // op1 is to take\\n        int j;\\n        for(j=i+1;j<n and inter[j].first<inter[i].second;j++){} // getting next eligible index\\n        int op1 = 1 + solve(dp,j);\\n        // op2 is to not take\\n        int op2 = solve(dp,i+1);\\n        return dp[i]=max(op1,op2);\\n    }\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals){\\n        n=intervals.size();\\n        for(auto i: intervals)\\n            inter.push_back({i[0],i[1]});\\n        sort(inter.begin(),inter.end());\\n        // using recursion and memoization\\n        vector<int> dp(n,-1);\\n        return n - solve(dp,0);\\n    }\\n};\\n```\n```\\nclass Solution{\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals){\\n        // precomputation\\n        int n,j;\\n        vector<pair<int,int>> inter;\\n        n=intervals.size();\\n        for(auto i: intervals)\\n            inter.push_back({i[0],i[1]});\\n        sort(inter.begin(),inter.end());\\n        // tabulation\\n        vector<int> dp(n+1,0);\\n        for(int i=n-1;i>=0;i--){\\n            for(j=i+1;j<n and inter[j].first<inter[i].second;j++){}\\n            dp[i]=max(1+dp[j],dp[i+1]);\\n        }\\n        return n-dp[0];\\n    }\\n};\\n```\n```\\nclass Solution{\\nprivate:\\n    int n;\\n    vector<pair<int,int>> inter;\\n    // searches for nearest next interval using binary search\\n    // invariants:\\n    // inter[l].first<inter[i].second\\n    // inter[r].first>=inter[i].second\\n    int searchNextMin(int i){\\n        int l=i, r=n;\\n        while(r>l+1){\\n            int m=(l+r)/2;\\n            if(inter[m].first<inter[i].second)\\n                l=m;\\n            else\\n                r=m;\\n        }\\n        return r;\\n    }\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals){\\n        // precomputation\\n        n=intervals.size();\\n        for(auto i: intervals)\\n            inter.push_back({i[0],i[1]});\\n        sort(inter.begin(),inter.end());\\n        // tabulation\\n        vector<int> dp(n+1,0);\\n        for(int i=n-1;i>=0;i--){\\n            int j=searchNextMin(i);\\n            dp[i]=max(1+dp[j],dp[i+1]);\\n        }\\n        return n-dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785811,
                "title": "c-o-nlogn-greedy-custom-comparator-sorting",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:**\\n* sort by min. end time as this will prioritize intervals that finishes first, so that we have more number of non-overlapping intervals.\\n* keep track of latest interval \\'end time\\' and consider next valid interval with start > previous end time\\n* by this we have count of max. non overlapping intervals, so our ans = total - non overlapping.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // sort by min. end time\\n    static bool compare(vector<int> &a, vector<int> &b){\\n        if(a[1]==b[1]) return a[0]<b[0];\\n        return a[1]<b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& a) {\\n        sort(a.begin(),a.end(),compare);\\n        int n=a.size();\\n        \\n        int c=1; // cout of non overlapping intervals\\n        int e=a[0][1];\\n        \\n        for(int i=1;i<n;i++){\\n            if(a[i][0] >= e){\\n                c++;\\n                e=max(e,a[i][1]);\\n            }\\n        } \\n\\t\\t\\n        return n-c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // sort by min. end time\\n    static bool compare(vector<int> &a, vector<int> &b){\\n        if(a[1]==b[1]) return a[0]<b[0];\\n        return a[1]<b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& a) {\\n        sort(a.begin(),a.end(),compare);\\n        int n=a.size();\\n        \\n        int c=1; // cout of non overlapping intervals\\n        int e=a[0][1];\\n        \\n        for(int i=1;i<n;i++){\\n            if(a[i][0] >= e){\\n                c++;\\n                e=max(e,a[i][1]);\\n            }\\n        } \\n\\t\\t\\n        return n-c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3271752,
                "title": "435-space-96-99-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe idea of this solution is to sort the intervals by their end time, and then iterate over them while keeping track of the current end time and the count of non-overlapping intervals. We start by initializing the end time to be the end time of the first interval (since it has the smallest end time), and the count of non-overlapping intervals to be 1 (since we always keep the first interval). Then, we iterate over the rest of the intervals and check if they overlap with the previous interval. If they don\\'t overlap, we update the end time and increment the count of non-overlapping intervals. If they overlap, we discard the current interval (because the previous interval has a smaller end time and a higher priority). Finally, the number of intervals to remove is the difference between the total number of intervals and the count of non-overlapping intervals.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        # Sort intervals by their end time\\n        intervals.sort(key=lambda x: x[1])\\n        \\n        # Initialize variables\\n        end = intervals[0][1]\\n        count = 1\\n        \\n        # Iterate over the rest of the intervals\\n        for i in range(1, len(intervals)):\\n            # If the start time of the current interval is greater than or equal to the end time of the previous interval, they don\\'t overlap\\n            if intervals[i][0] >= end:\\n                # Update end time to be the end time of the current interval\\n                end = intervals[i][1]\\n                # Increment the count of non-overlapping intervals\\n                count += 1\\n            # If they overlap, discard the current interval\\n            # (we don\\'t need to update end time or count)\\n            # because the previous interval has a smaller end time and a higher priority\\n            else:\\n                continue\\n        \\n        # The number of intervals to remove is the difference between the total number of intervals and the count of non-overlapping intervals\\n        return len(intervals) - count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        # Sort intervals by their end time\\n        intervals.sort(key=lambda x: x[1])\\n        \\n        # Initialize variables\\n        end = intervals[0][1]\\n        count = 1\\n        \\n        # Iterate over the rest of the intervals\\n        for i in range(1, len(intervals)):\\n            # If the start time of the current interval is greater than or equal to the end time of the previous interval, they don\\'t overlap\\n            if intervals[i][0] >= end:\\n                # Update end time to be the end time of the current interval\\n                end = intervals[i][1]\\n                # Increment the count of non-overlapping intervals\\n                count += 1\\n            # If they overlap, discard the current interval\\n            # (we don\\'t need to update end time or count)\\n            # because the previous interval has a smaller end time and a higher priority\\n            else:\\n                continue\\n        \\n        # The number of intervals to remove is the difference between the total number of intervals and the count of non-overlapping intervals\\n        return len(intervals) - count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843676,
                "title": "go-clean-solution-185ms-100",
                "content": "Hello Gophers!\\n\\n## [Problem: Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)\\n\\nGiven an array of intervals `intervals` where `intervals[i] = [starti, endi]`,  \\nreturn *the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping*.\\n\\nExample 1:  \\n```\\nInput: intervals = [[1,2],[2,3],[3,4],[1,3]]\\nOutput: 1\\nExplanation: [1,3] can be removed and the rest of the intervals are non-overlapping.\\n```\\n\\nExample 2:  \\n```\\nInput: intervals = [[1,2],[1,2],[1,2]]\\nOutput: 2\\nExplanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.\\n```\\n\\nExample 3:  \\n```\\nInput: intervals = [[1,2],[2,3]]\\nOutput: 0\\nExplanation: You don\\'t need to remove any of the intervals since they\\'re already non-overlapping.\\n ```\\n\\nConstraints:  \\n- `1 <= intervals.length <= 105`\\n- `intervals[i].length == 2`\\n- `-5 * 104 <= starti < endi <= 5 * 104`\\n\\n\\n\\n## Definitions\\n\\nAn interval `[x, y]` is \"overlapping\" with the interval `[a, b]` if `x` <= `b` && `y` >= `a` (or `y` >= `a` && `x` >= `b`):\\n\\n```\\n|-----------|           |          |-----------|\\nx           y           |          x           y \\n     |-----------|      |     |-----------| \\n     a           b      |     a           b \\n```\\n\\nAn interval `[x, y]` is \"completely overlapping\" with the interval `[a, b]` if `x` <= `a` && `y` >= `b`:\\n\\n```\\n|----------------|\\nx                y\\n     |-----|\\n     a     b\\n```\\n\\n\\n## Solution\\n\\n[crickey180\\'s solution](https://leetcode.com/problems/non-overlapping-intervals/discuss/91713/Java%3A-Least-is-Most) in Go:  \\n> Actually, the problem is the same as \"Given a collection of intervals, find the maximum number of intervals that are non-overlapping.\" (the classic Greedy problem: Interval Scheduling). With the solution to that problem, guess how do we get the minimum number of intervals to remove? : )\\n\\n### Code\\n\\n```go\\n// Time: O(nlogn + n) = O(nlogn)\\n// Space: O(1)\\nfunc eraseOverlapIntervals(intervals [][]int) int {\\n    if len(intervals) <= 1 {\\n        return 0\\n    }\\n    \\n    // Time: O(nlogn)\\n    sortIntervals(intervals)\\n    \\n    // Time: O(n)\\n    nbNonOverlappingIntervals := numberOfNonOverlappingIntervals(intervals)\\n\\n    return len(intervals) - nbNonOverlappingIntervals\\n}\\n\\n// Time: O(n)\\n// Space: O(1)\\nfunc numberOfNonOverlappingIntervals(intervals [][]int) int {\\n    currentInterval := intervals[0]\\n    var nbNonOverlappingIntervals int = 1\\n\\n    // Time: O(n)\\n    for _, interval := range intervals[1:] {\\n        if interval[0] >= currentInterval[1] {\\n            currentInterval = interval\\n            nbNonOverlappingIntervals++\\n        }\\n    }\\n\\n    return nbNonOverlappingIntervals\\n}\\n\\n// Time: O(nlogn)\\n// Space: O(1)\\nfunc sortIntervals(intervals [][]int) {\\n    // Time: O(nlogn)\\n    sort.Slice(intervals, func(i, j int) bool {\\n        return intervals[i][1] < intervals[j][1]\\n    })\\n}\\n```\\n\\n### Explanation\\n\\nLet\\'s start by considering the intervals according to their end times. Consider the two intervals with the earliest end times. Let\\'s say the earlier end time is `n` and the later one is `m`. We have `n < m`.\\n\\nIf we can only choose to keep one interval, should we choose the one ending at `n` or ending at `m`? To avoid overlap, We should always greedily choose the interval with an earlier end time `n`.\\n\\nWe usually sort the intervals with the first value of the intervals (`x` and `a`) first and if they are equals, we check the second value (`y` and `b`):\\n\\n```go\\nfunc sortIntervals(intervals [][]int) {\\n    sort.Slice(intervals, func(i, j int) bool {\\n        if intervals[i][0] == intervals[j][0] {\\n            return intervals[i][1] <= intervals[j][1]\\n        }\\n        return intervals[i][0] <= intervals[j][0]\\n    })\\n}\\n```\\n\\nBut for this one, because we want the \"interval with an earlier end time\", we sort with the last value of the intervals (`y` and `b`):\\n\\n```go\\nfunc sortIntervals(intervals [][]int) {\\n    // Time: O(nlogn)\\n    sort.Slice(intervals, func(i, j int) bool {\\n        return intervals[i][1] < intervals[j][1]\\n    })\\n}\\n```\\n\\nWhen we have the meetings sorted by their \"end time\", we can iterate on them.\\n\\n*Source: https://en.wikipedia.org/wiki/Interval_scheduling*\\n\\n\\n## Similar Questions\\n\\n1. [[Medium] 56. Merge Intervals](https://leetcode.com/problems/merge-intervals/discuss/1805268/Go-Clean-Code-with-explanation-and-visual-(10ms-100))\\n2. [[Easy] 495. Teemo Attacking](https://leetcode.com/problems/teemo-attacking/discuss/1805603/Go-Clean-code-with-comments-(30ms-98))\\n3. [[Medium] 57. Insert Interval](https://leetcode.com/problems/insert-interval/discuss/1807161/Go-Clean-Code-with-visual-(1ms-100)) \\n4. [[Medium] 986. Interval List Intersections](https://leetcode.com/problems/interval-list-intersections/discuss/1823039/Go-Clean-Code-with-explanation-and-visual-(10ms-100))\\n5. [[Easy] 252. Meeting Rooms](https://leetcode.com/problems/meeting-rooms/discuss/1512776/Go-Meeting-Rooms-Clean-solution) \\n6. [[Medium] 253. Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/discuss/1826838/Go-Multiple-Solutions-(0ms-100))\\n7. [[Medium] 435. Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/discuss/1843676/Go-Clean-solution-(185ms-100)) **(this problem)**\\n8. [[Medium] 763. Partition Labels](https://leetcode.com/problems/partition-labels/discuss/2027004/Go-Merge-and-Sort-Intervals-0ms-(100))\\n9. [[Medium] Single-Threaded CPU](https://leetcode.com/problems/single-threaded-cpu/)\\n10. [[Hard] 759. Employee Free Time](https://leetcode.com/problems/employee-free-time/)\\n\\nI hope it helped! :)",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nInput: intervals = [[1,2],[2,3],[3,4],[1,3]]\\nOutput: 1\\nExplanation: [1,3] can be removed and the rest of the intervals are non-overlapping.\\n```\n```\\nInput: intervals = [[1,2],[1,2],[1,2]]\\nOutput: 2\\nExplanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.\\n```\n```\\nInput: intervals = [[1,2],[2,3]]\\nOutput: 0\\nExplanation: You don\\'t need to remove any of the intervals since they\\'re already non-overlapping.\\n ```\n```\\n|-----------|           |          |-----------|\\nx           y           |          x           y \\n     |-----------|      |     |-----------| \\n     a           b      |     a           b \\n```\n```\\n|----------------|\\nx                y\\n     |-----|\\n     a     b\\n```\n```go\\n// Time: O(nlogn + n) = O(nlogn)\\n// Space: O(1)\\nfunc eraseOverlapIntervals(intervals [][]int) int {\\n    if len(intervals) <= 1 {\\n        return 0\\n    }\\n    \\n    // Time: O(nlogn)\\n    sortIntervals(intervals)\\n    \\n    // Time: O(n)\\n    nbNonOverlappingIntervals := numberOfNonOverlappingIntervals(intervals)\\n\\n    return len(intervals) - nbNonOverlappingIntervals\\n}\\n\\n// Time: O(n)\\n// Space: O(1)\\nfunc numberOfNonOverlappingIntervals(intervals [][]int) int {\\n    currentInterval := intervals[0]\\n    var nbNonOverlappingIntervals int = 1\\n\\n    // Time: O(n)\\n    for _, interval := range intervals[1:] {\\n        if interval[0] >= currentInterval[1] {\\n            currentInterval = interval\\n            nbNonOverlappingIntervals++\\n        }\\n    }\\n\\n    return nbNonOverlappingIntervals\\n}\\n\\n// Time: O(nlogn)\\n// Space: O(1)\\nfunc sortIntervals(intervals [][]int) {\\n    // Time: O(nlogn)\\n    sort.Slice(intervals, func(i, j int) bool {\\n        return intervals[i][1] < intervals[j][1]\\n    })\\n}\\n```\n```go\\nfunc sortIntervals(intervals [][]int) {\\n    sort.Slice(intervals, func(i, j int) bool {\\n        if intervals[i][0] == intervals[j][0] {\\n            return intervals[i][1] <= intervals[j][1]\\n        }\\n        return intervals[i][0] <= intervals[j][0]\\n    })\\n}\\n```\n```go\\nfunc sortIntervals(intervals [][]int) {\\n    // Time: O(nlogn)\\n    sort.Slice(intervals, func(i, j int) bool {\\n        return intervals[i][1] < intervals[j][1]\\n    })\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3002095,
                "title": "c-simple-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a, vector<int> &b){\\n        return a[1]<b[1];\\n    }\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),cmp);\\n        int count=0;\\n        int lastInterval=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<lastInterval){\\n                count++;\\n            }\\n            else{\\n                lastInterval=intervals[i][1];\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a, vector<int> &b){\\n        return a[1]<b[1];\\n    }\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),cmp);\\n        int count=0;\\n        int lastInterval=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<lastInterval){\\n                count++;\\n            }\\n            else{\\n                lastInterval=intervals[i][1];\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014306,
                "title": "python-greedy",
                "content": "Credits to neetcode for the excellent explanation here: https://www.youtube.com/watch?v=nONCGxWoUfM\\n\\nIntuition:\\n* What\\'s the most straightforward way we can think of to minimize the number of removals of overlapping intervals? By removing the overlapping interval with the longer end.\\n\\n```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals = sorted(intervals)\\n        last_end = intervals[0][1]\\n        remove = 0\\n        \\n        for i in range(1, len(intervals)):\\n            # found overlap\\n            if intervals[i][0] < last_end:\\n                remove += 1\\n                # remove the interval with the longer end\\n                last_end = min(intervals[i][1], last_end)\\n            else:\\n                last_end = intervals[i][1]\\n            \\n        return remove\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals = sorted(intervals)\\n        last_end = intervals[0][1]\\n        remove = 0\\n        \\n        for i in range(1, len(intervals)):\\n            # found overlap\\n            if intervals[i][0] < last_end:\\n                remove += 1\\n                # remove the interval with the longer end\\n                last_end = min(intervals[i][1], last_end)\\n            else:\\n                last_end = intervals[i][1]\\n            \\n        return remove\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724318,
                "title": "o-nlogn-stepwise-explanation-of-intuition",
                "content": "Step 1 - sort the array on the basis of 0 th index of each interval\\n  so that be don\\'t have to bother about the START of the interval , as they are already sorted\\n\\nStep 2- Iterate all the intervals and we be having a variable[prevEnd] which store the previous least possible end , which means that if\\nwe are having 2 overlapping intervals then we will choose that interval to be in non-overlapping interval set which has the small\\nEND of interval. WHY ?? because it will benefit us in finding the maximum possible non overlapping intervals, if the end is small\\nthen the chances of overlapping is less as compare to when end is comparatively large . ARGEE ??? \\n\\nnow, \\n--------> if we found the start of i th interval lesser than prevEnd , then it means overlapping occurs and we suppose to choose that interval which \\n     has least END. Also increase the counter.\\n--------> if we found the start of i th interval larger than prevEnd , then just simple update the prevEnd as the END of i th interval only, because in\\n     this case this will be the prevEnd , no doubt.\\n\\nUnderstand the explanation by @ramkishoresj , thanks for the solution.\\nhttps://leetcode.com/problems/non-overlapping-intervals/discuss/481758/Easy-to-Understand-Java-Solution\\n\\n\\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals,(a,b)->Integer.compare(a[0],b[0]));\\n        int count=0;\\n        int prevEnd=intervals[0][1];\\n        for(int i=1;i<intervals.length;i++){\\n            int start=intervals[i][0];\\n            if(start<prevEnd){\\n                prevEnd=Math.min(prevEnd,intervals[i][1]);\\n                count++;\\n            }else{\\n                prevEnd=intervals[i][1];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals,(a,b)->Integer.compare(a[0],b[0]));\\n        int count=0;\\n        int prevEnd=intervals[0][1];\\n        for(int i=1;i<intervals.length;i++){\\n            int start=intervals[i][0];\\n            if(start<prevEnd){\\n                prevEnd=Math.min(prevEnd,intervals[i][1]);\\n                count++;\\n            }else{\\n                prevEnd=intervals[i][1];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1608272,
                "title": "c-simple-and-efficient-solution-intution",
                "content": "Its a simple modification of famous Activity Selection Problem which can be solved using greedy algo \\nSimple intution is to first sort the given input according to the end if at any interval end time of that interval is greater than the start time of the next interval than that would mean that we need to remove the next interval.\\n```\\nclass Solution {\\npublic:\\n    static bool myComp(pair<int,int> a,pair<int,int> b)\\n    {\\n        return (a.second<b.second);\\n    }\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int ans=0;\\n        vector<pair<int,int>> arr;\\n        for(auto it : intervals)\\n        {\\n            arr.push_back({it[0],it[1]});\\n        }\\n        sort(arr.begin(),arr.end(),myComp);\\n        int prev=0;\\n        for(int i=1;i<arr.size();i++)\\n        {\\n            if(arr[prev].second>arr[i].first){\\n                ans++;\\n            }\\n            else{\\n                prev=i;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If You Understood Pls Upvote Gives Motivation \\uD83D\\uDE03**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool myComp(pair<int,int> a,pair<int,int> b)\\n    {\\n        return (a.second<b.second);\\n    }\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int ans=0;\\n        vector<pair<int,int>> arr;\\n        for(auto it : intervals)\\n        {\\n            arr.push_back({it[0],it[1]});\\n        }\\n        sort(arr.begin(),arr.end(),myComp);\\n        int prev=0;\\n        for(int i=1;i<arr.size();i++)\\n        {\\n            if(arr[prev].second>arr[i].first){\\n                ans++;\\n            }\\n            else{\\n                prev=i;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91745,
                "title": "java-o-n-2-using-dp-accepted",
                "content": "```java\\npublic class Solution {\\n    class myComparator implements Comparator<Interval> {\\n        public int compare(Interval a, Interval b) {\\n            return a.start - b.start;\\n        }\\n    }\\n    public boolean isOverlapping(Interval i, Interval j) {\\n        return i.end > j.start;\\n    }\\n    public int eraseOverlapIntervals(Interval[] intervals) {\\n        if (intervals.length == 0) {\\n            return 0;\\n        }\\n        Arrays.sort(intervals, new myComparator());\\n        int dp[] = new int[intervals.length];\\n        dp[0] = 1;\\n        int ans = 1;\\n        for (int i = 1; i < dp.length; i++) {\\n            int max = 0;\\n            for (int j = i - 1; j >= 0; j--) {\\n                if (!isOverlapping(intervals[j], intervals[i])) {\\n                    max = Math.max(dp[j], max);\\n                }\\n            }\\n            dp[i] = max + 1;\\n            ans = Math.max(ans, dp[i]);\\n\\n        }\\n        return intervals.length - ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    class myComparator implements Comparator<Interval> {\\n        public int compare(Interval a, Interval b) {\\n            return a.start - b.start;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3786202,
                "title": "intuition-and-approach-with-real-life-example-explained-beginner-friendly",
                "content": "# Intuition\\nImagine you have a busy schedule with several appointments (intervals) throughout the day. Some of these appointments may overlap with each other. To make your day as productive as possible, you want to find the minimum number of appointments you need to reschedule or cancel to ensure that there are no overlapping intervals.\\n\\n# Approach\\nTo solve this problem, we can use a greedy approach. The idea is to keep track of the end time of the last scheduled appointment. While iterating through the list of appointments, we can check if the current appointment overlaps with the last scheduled one. If there is an overlap, we need to decide which appointment to keep and which one to remove to minimize overlaps.\\n\\nTo minimize overlaps, we can follow these rules:\\n\\n1. If the current appointment ends before or exactly at the end time of the last scheduled appointment, we have an overlap. In this case, we should keep the appointment that ends earlier, as it will free up the schedule sooner.\\n2. If the current appointment ends after the end time of the last scheduled appointment, there is no overlap, and we can simply update the end time to the current appointment\\'s end time.\\nBy following these rules, we will be able to keep the maximum number of non-overlapping appointments, making our day as productive as possible.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is O(nlogn)+O(n), where n is the number of appointments. We need to sort and then traverse the list of appointments once to find the minimum number of overlapping intervals.\\n\\n- Space complexity:\\nThe space complexity is O(1) as we are not using any additional data structures that grow with the size of the input. We only need a few variables to keep track of the end time and the count of overlapping intervals.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        int toBeRemoved = 0; // Initialize a variable to count the number of intervals to be removed\\n        Arrays.sort(intervals, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return o1[0] - o2[0]; // Sort the intervals based on their start points\\n            }\\n        });\\n\\n        int end = intervals[0][1]; // Initialize the end time of the first interval\\n\\n        // Iterate through the remaining intervals (starting from the second one)\\n        for (int i = 1; i < intervals.length; i++) {\\n            int[] interval = intervals[i];\\n            if (interval[0] < end) {\\n                // If the current interval\\'s start time is less than the end time of the last interval,\\n                // it means there is an overlap between the intervals.\\n                toBeRemoved++; // Increment the count of intervals to be removed\\n\\n                // Greedily choose the interval with the smaller end time to keep (to minimize overlaps)\\n                end = Math.min(end, interval[1]);\\n            } else {\\n                // If there is no overlap, update the end time to the current interval\\'s end time.\\n                end = interval[1];\\n            }\\n        }\\n\\n        return toBeRemoved; // Return the total number of intervals to be removed\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        int toBeRemoved = 0; // Initialize a variable to count the number of intervals to be removed\\n        Arrays.sort(intervals, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return o1[0] - o2[0]; // Sort the intervals based on their start points\\n            }\\n        });\\n\\n        int end = intervals[0][1]; // Initialize the end time of the first interval\\n\\n        // Iterate through the remaining intervals (starting from the second one)\\n        for (int i = 1; i < intervals.length; i++) {\\n            int[] interval = intervals[i];\\n            if (interval[0] < end) {\\n                // If the current interval\\'s start time is less than the end time of the last interval,\\n                // it means there is an overlap between the intervals.\\n                toBeRemoved++; // Increment the count of intervals to be removed\\n\\n                // Greedily choose the interval with the smaller end time to keep (to minimize overlaps)\\n                end = Math.min(end, interval[1]);\\n            } else {\\n                // If there is no overlap, update the end time to the current interval\\'s end time.\\n                end = interval[1];\\n            }\\n        }\\n\\n        return toBeRemoved; // Return the total number of intervals to be removed\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785372,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Intuition\\nThe algorithm sorts intervals based on their end points, then iterates through them, counting overlapping intervals, and returns the count.\\n\\n# Solution Video\\n\\nhttps://youtu.be/gJjmZ6VpXRk\\n\\n# *** Please upvote and subscribe to my channel from here. I have 226 videos as of July 19th***\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python code. Other might be different a bit.\\n\\n\\n1. Initialize a variable \"res\" to keep track of the count of overlapping intervals. Set it to 0 initially.\\n\\n2. Sort the intervals in ascending order based on their end points using the `sort` method and a lambda function as the key for sorting.\\n\\n3. Initialize a variable \"prev_end\" to store the end point of the first interval (since the intervals are sorted).\\n\\n4. Iterate through the sorted intervals starting from the second one (index 1).\\n\\n5. Check if the end point of the previous interval (stored in \"prev_end\") is greater than the start point of the current interval (intervals[i][0]).\\n   - If true, it means there is an overlap between the previous interval and the current one. Increment the \"res\" variable to count the overlapping interval.\\n\\n6. If there is no overlap (i.e., the end point of the previous interval is not greater than the start point of the current interval), update \"prev_end\" to the end point of the current interval.\\n\\n7. After processing all intervals, return the count of overlapping intervals (\"res\") as the final result.\\n\\n# Complexity\\n- Time complexity: O(n log n) \\nThe main operations in this code are sorting the intervals and iterating through the sorted intervals. Sorting the intervals takes O(n log n) time complexity, where n is the number of intervals. The subsequent loop iterates through the sorted intervals once, which takes O(n) time complexity. Therefore, the overall time complexity of this code is O(n log n).\\n\\n- Space complexity: O(1)\\nThe space complexity of this code is O(1). The additional space used is constant and does not depend on the size of the input. The sorting operation is performed in-place, and the variables \"res\" and \"prev_end\" require constant space to store their values during the computation. The input list \"intervals\" is not modified, and the returned integer value does not consume any extra space.\\n\\n```python []\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        res = 0\\n\\n        intervals.sort(key=lambda x: x[1])\\n        prev_end = intervals[0][1]\\n\\n        for i in range(1, len(intervals)):\\n            if prev_end > intervals[i][0]:\\n                res += 1\\n            else:\\n                prev_end = intervals[i][1]\\n        \\n        return res\\n```\\n```javascript []\\n/**\\n * @param {number[][]} intervals\\n * @return {number}\\n */\\nvar eraseOverlapIntervals = function(intervals) {\\n    let res = 0;\\n    intervals.sort((a, b) => a[1] - b[1]);\\n    let prev_end = intervals[0][1];\\n\\n    for (let i = 1; i < intervals.length; i++) {\\n        if (prev_end > intervals[i][0]) {\\n            res++;\\n        } else {\\n            prev_end = intervals[i][1];\\n        }\\n    }\\n\\n    return res;    \\n};\\n```\\n```java []\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        int res = 0;\\n\\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\\n        int prev_end = intervals[0][1];\\n\\n        for (int i = 1; i < intervals.length; i++) {\\n            if (prev_end > intervals[i][0]) {\\n                res++;\\n            } else {\\n                prev_end = intervals[i][1];\\n            }\\n        }\\n\\n        return res;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int res = 0;\\n\\n        sort(intervals.begin(), intervals.end(), [](const auto& a, const auto& b) {\\n            return a[1] < b[1];\\n        });\\n        int prev_end = intervals[0][1];\\n\\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (prev_end > intervals[i][0]) {\\n                res++;\\n            } else {\\n                prev_end = intervals[i][1];\\n            }\\n        }\\n\\n        return res;        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        res = 0\\n\\n        intervals.sort(key=lambda x: x[1])\\n        prev_end = intervals[0][1]\\n\\n        for i in range(1, len(intervals)):\\n            if prev_end > intervals[i][0]:\\n                res += 1\\n            else:\\n                prev_end = intervals[i][1]\\n        \\n        return res\\n```\n```javascript []\\n/**\\n * @param {number[][]} intervals\\n * @return {number}\\n */\\nvar eraseOverlapIntervals = function(intervals) {\\n    let res = 0;\\n    intervals.sort((a, b) => a[1] - b[1]);\\n    let prev_end = intervals[0][1];\\n\\n    for (let i = 1; i < intervals.length; i++) {\\n        if (prev_end > intervals[i][0]) {\\n            res++;\\n        } else {\\n            prev_end = intervals[i][1];\\n        }\\n    }\\n\\n    return res;    \\n};\\n```\n```java []\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        int res = 0;\\n\\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\\n        int prev_end = intervals[0][1];\\n\\n        for (int i = 1; i < intervals.length; i++) {\\n            if (prev_end > intervals[i][0]) {\\n                res++;\\n            } else {\\n                prev_end = intervals[i][1];\\n            }\\n        }\\n\\n        return res;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int res = 0;\\n\\n        sort(intervals.begin(), intervals.end(), [](const auto& a, const auto& b) {\\n            return a[1] < b[1];\\n        });\\n        int prev_end = intervals[0][1];\\n\\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (prev_end > intervals[i][0]) {\\n                res++;\\n            } else {\\n                prev_end = intervals[i][1];\\n            }\\n        }\\n\\n        return res;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1558684,
                "title": "python-simple-greeedy-approach",
                "content": "Overlap condition => when previous end is larger than current start\\nchoosing interval to remove => one with shorter timespan => one that ends first => minimum end time\\n```\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()\\n        cnt = 0\\n        prevEnd = -math.inf\\n        for currStart,currEnd in intervals:\\n            if prevEnd > currStart: # overlapping condition\\n                cnt +=1 # removed one interval\\n                prevEnd = min(prevEnd,currEnd) # interval with longer interval is removed => consider interval with min end time\\n            else:\\n                prevEnd = currEnd\\n        return cnt\\n```\\nLike if you find it useful",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()\\n        cnt = 0\\n        prevEnd = -math.inf\\n        for currStart,currEnd in intervals:\\n            if prevEnd > currStart: # overlapping condition\\n                cnt +=1 # removed one interval\\n                prevEnd = min(prevEnd,currEnd) # interval with longer interval is removed => consider interval with min end time\\n            else:\\n                prevEnd = currEnd\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 902132,
                "title": "simple-two-pointer-sliding-window-o-n-logn-solution",
                "content": "The idea is to sort the intervals by their start times and then traverse the array from behind. If  the end time at `interval[i-1]` is greater than the start time at `interval[i]` we have found overlap. So we move to check `interval[i]` with `interval[i-2]` endtime and so on till we get to an interval `j` where the there is no overlap. Then we let `i = j`. \\n\\n**Reasoning**\\nWe traverse from the right of the list becuase whenever we meet an interval at `j` which doesn\\'t overlap with our current interval `i`, there can be no more overlaping intervals beyond `j` and the overlaps between `i` and `j` is minimum. \\n\\n**Here is the code for the approaach in Javascript:**\\n```\\nvar eraseOverlapIntervals = function(intervals) {\\n    intervals.sort((a,b) => a[0]-b[0])\\n    let n = intervals.length\\n    let res = 0\\n    let i = n-1\\n    while(i>0){\\n        let j = i-1\\n        while(j>=0 && intervals[j][1] > intervals[i][0]){\\n            res++\\n            j--\\n        }\\n        i = j\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar eraseOverlapIntervals = function(intervals) {\\n    intervals.sort((a,b) => a[0]-b[0])\\n    let n = intervals.length\\n    let res = 0\\n    let i = n-1\\n    while(i>0){\\n        let j = i-1\\n        while(j>=0 && intervals[j][1] > intervals[i][0]){\\n            res++\\n            j--\\n        }\\n        i = j\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 793323,
                "title": "c-simple-sort-based-solution-explained-35-time-15-space",
                "content": "Pretty poor performance, although I suspect the tests were enhanced later, since I can\\'t see how come people would be using so much less memory than my own solution.\\n\\nAnyway, tricky problem if you do not know the secret in advance: you need to sort the intervals in order to parse them properly - and this might be intuitive -, but you need to sort them by ending time, since with the ending time we are going to work first and foremost.\\n\\nTo sort I created the helper function `compOp` and used it in the `sort` call, which should be self-explanatory.\\n\\nI then initialise `lmt` with the lowest value at hand (the beginning of the first interval) and then proceed with a loop through all the intervals: when I find something that began before the limit, I know I have to remove it, or it will overlap, thus I increase `res`.\\n\\nWhen I encounter an interval with which instead does not start with before `lmt` (as it would incidentally also be the case with the first number, and you might rewrite the loop to start from the second element if you wish so), then we update `lmt` to the new ending time of this interval.\\n\\nOnce we are done counting, we return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compOp(vector<int> a, vector<int> b){\\n        return a[1] < b[1];\\n    }\\n    int eraseOverlapIntervals(vector<vector<int>>& v) {\\n        if (!v.size()) return 0;\\n        // sorting intervals by end time\\n        sort(begin(v), end(v), compOp);\\n        // initialising variable for the loop\\n        int res = 0, lmt = v[0][0];\\n        for (auto e: v) {\\n            // if the interval finishes before lmt, we increase the counter\\n            if (e[0] < lmt) {\\n                res++;\\n            } else {\\n                // otherwise we update lmt\\n                lmt = e[1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    static bool compOp(vector<int> a, vector<int> b){\\n        return a[1] < b[1];\\n    }\\n    int eraseOverlapIntervals(vector<vector<int>>& v) {\\n        if (!v.size()) return 0;\\n        // sorting intervals by end time\\n        sort(begin(v), end(v), compOp);\\n        // initialising variable for the loop\\n        int res = 0, lmt = v[0][0];\\n        for (auto e: v) {\\n            // if the interval finishes before lmt, we increase the counter\\n            if (e[0] < lmt) {\\n                res++;\\n            } else {\\n                // otherwise we update lmt\\n                lmt = e[1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793109,
                "title": "simple-python-solution",
                "content": "Time O(nlogn) #due to sorting\\nspace O(1)\\n```\\n\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        \\n        if not intervals:\\n            return 0\\n\\t\\t\\t\\n        remove=0\\n        intervals=sorted(intervals, key=lambda x:x[1]) #sort based on end\\n        startP=intervals[0][0]\\n        endP=intervals[0][1]\\n        \\n        for i in range(1,len(intervals)):\\n            \\n            startN=intervals[i][0]\\n            endN=intervals[i][1]\\n            \\n            if  startN<endP:\\n                remove+=1\\n            else: #if the interval is not remove, we set a new StartPrev and new endPrev\\n                startP=startN\\n                endP=endN\\n                \\n        return remove        \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        \\n        if not intervals:\\n            return 0\\n\\t\\t\\t\\n        remove=0\\n        intervals=sorted(intervals, key=lambda x:x[1]) #sort based on end\\n        startP=intervals[0][0]\\n        endP=intervals[0][1]\\n        \\n        for i in range(1,len(intervals)):\\n            \\n            startN=intervals[i][0]\\n            endN=intervals[i][1]\\n            \\n            if  startN<endP:\\n                remove+=1\\n            else: #if the interval is not remove, we set a new StartPrev and new endPrev\\n                startP=startN\\n                endP=endN\\n                \\n        return remove        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 334377,
                "title": "javascript-es6",
                "content": "JavaScript solution using ES6 syntax and built in array method\\n```\\n// Sort by the end. Given [ a ] [ b ] remove b, if b[0] < a[1]\\nconst eraseOverlapIntervals = (intervals) => {\\n\\tintervals.sort((a,b) => return a[1] - b[1]); // ascending order wrt the end\\n\\tlet pre = null;\\n\\tlet counter = 0;\\n\\tintervals.forEach((item) => {\\n\\t\\tif (!pre) pre = item;\\n\\t\\telse {\\n\\t\\t\\tif (pre[1] > item[0]) counter++;\\n\\t\\t\\telse pre = item;\\n\\t\\t}\\n\\t}\\n\\treturn counter;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Sort by the end. Given [ a ] [ b ] remove b, if b[0] < a[1]\\nconst eraseOverlapIntervals = (intervals) => {\\n\\tintervals.sort((a,b) => return a[1] - b[1]); // ascending order wrt the end\\n\\tlet pre = null;\\n\\tlet counter = 0;\\n\\tintervals.forEach((item) => {\\n\\t\\tif (!pre) pre = item;\\n\\t\\telse {\\n\\t\\t\\tif (pre[1] > item[0]) counter++;\\n\\t\\t\\telse pre = item;\\n\\t\\t}\\n\\t}\\n\\treturn counter;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 192615,
                "title": "java-beats-100-greedy-intuition",
                "content": "The intution here comes into play when we choose which interval to delete. If 2 intervals are overlapping always delete the interval with bigger end value. That way we ensure the upcoming intervals have lesser chance of overlapping with previous intervals and thus can gurantee lesser deletions. \\nSorting of intervals is needed prior to applying greedy solution\\n\\n```\\npublic int eraseOverlapIntervals(Interval[] intervals) {\\n        if(intervals == null || intervals.length == 0) return 0;\\n        Arrays.sort(intervals, new IntervalComparator());\\n        Interval prev = intervals[0];\\n        Interval curr = null;\\n        int toRemove = 0;\\n        for(int i=1;i<intervals.length;i++) {\\n            curr = intervals[i];\\n            if(overlapping(prev, curr)) {\\n                toRemove++;\\n                if(prev.end >= curr.end) {\\n                    prev = curr;\\n                }\\n            }else{\\n                prev = curr;\\n            }\\n        }\\n        return toRemove;\\n    }\\n    \\n    private boolean overlapping(Interval i1, Interval i2) {\\n        if(i1.end <= i2.start) return false;\\n        return true;\\n    }\\n    \\n    static class IntervalComparator implements Comparator<Interval> {\\n        \\n        public int compare(Interval i1, Interval i2) {\\n            if(i1.start == i2.start) return Integer.compare(i1.end, i2.end);\\n            return Integer.compare(i1.start, i2.start);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int eraseOverlapIntervals(Interval[] intervals) {\\n        if(intervals == null || intervals.length == 0) return 0;\\n        Arrays.sort(intervals, new IntervalComparator());\\n        Interval prev = intervals[0];\\n        Interval curr = null;\\n        int toRemove = 0;\\n        for(int i=1;i<intervals.length;i++) {\\n            curr = intervals[i];\\n            if(overlapping(prev, curr)) {\\n                toRemove++;\\n                if(prev.end >= curr.end) {\\n                    prev = curr;\\n                }\\n            }else{\\n                prev = curr;\\n            }\\n        }\\n        return toRemove;\\n    }\\n    \\n    private boolean overlapping(Interval i1, Interval i2) {\\n        if(i1.end <= i2.start) return false;\\n        return true;\\n    }\\n    \\n    static class IntervalComparator implements Comparator<Interval> {\\n        \\n        public int compare(Interval i1, Interval i2) {\\n            if(i1.start == i2.start) return Integer.compare(i1.end, i2.end);\\n            return Integer.compare(i1.start, i2.start);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788536,
                "title": "easy-clean-code-c",
                "content": "\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        // sort on the basis of second ele\\n        sort(intervals.begin(), intervals.end(), [](const auto& a, const auto& b){\\n            return a[1] < b[1];\\n        }); \\n        int remove =0;\\n        int end = INT_MIN;\\n        for(const auto &interval : intervals){\\n            if(interval[0] >= end)\\n                end = interval[1];\\n            else \\n                remove++;\\n        }\\n        return remove;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        // sort on the basis of second ele\\n        sort(intervals.begin(), intervals.end(), [](const auto& a, const auto& b){\\n            return a[1] < b[1];\\n        }); \\n        int remove =0;\\n        int end = INT_MIN;\\n        for(const auto &interval : intervals){\\n            if(interval[0] >= end)\\n                end = interval[1];\\n            else \\n                remove++;\\n        }\\n        return remove;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006811,
                "title": "simple-c-sorting-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust sort the array by end points (we can also do the start no problem then we have to do that way) and then check if prev end is greater than incoming start it means they will be overlaping so cnt++ and if not then change prev to next end point .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJsut look at the code . \\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& arr) {\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end(),[](vector<int>&a,vector<int>&b){\\n            return a[1]<b[1];\\n        });\\n        int pref=arr[0][1],cnt=0;\\n        for(int i=0;i<n-1;i++){\\n           if(pref>arr[i+1][0]){\\n               cnt++;\\n           }\\n           else pref=arr[i+1][1];\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& arr) {\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end(),[](vector<int>&a,vector<int>&b){\\n            return a[1]<b[1];\\n        });\\n        int pref=arr[0][1],cnt=0;\\n        for(int i=0;i<n-1;i++){\\n           if(pref>arr[i+1][0]){\\n               cnt++;\\n           }\\n           else pref=arr[i+1][1];\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958075,
                "title": "c-using-sort-and-iteration-o-nlogn-solution-with-explanation",
                "content": "# Approach\\nThe code begins by sorting the intervals by their start time in ascending order. This is done to ensure that the intervals are processed in the correct order.\\n\\nNext, the code initialises a counter count to 0 and a variable end to the end time of the first interval.\\n\\nThe code then iterates through the intervals, starting from the second interval. For each interval, it checks if the start time is less than the end time of the previous interval. If it is, this means that the interval overlaps with the previous interval, so the code increments the count counter and updates the end time to the minimum of the current end time and the end time of the current interval. This ensures that the interval with the earliest end time is selected.\\n\\nIf the start time of the current interval is greater than or equal to the end time of the previous interval, this means that the interval does not overlap with the previous interval, so the code updates the end time to the end time of the current interval.\\n\\nFinally, the code returns the count counter, which is the number of intervals that need to be removed to make the rest of the intervals non-overlapping.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Auxilary Space:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if (intervals.size() == 0) return 0;\\n\\n        sort(intervals.begin(), intervals.end());\\n \\n        int count = 0;\\n\\n        int end = intervals[0][1];\\n\\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (intervals[i][0] < end) {\\n                count++;\\n                // Pick the interval with lowest end.\\n                if (intervals[i][1] < end) {\\n                    end = intervals[i][1];\\n                }\\n            } else {\\n                end = intervals[i][1];\\n            }\\n        }      \\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if (intervals.size() == 0) return 0;\\n\\n        sort(intervals.begin(), intervals.end());\\n \\n        int count = 0;\\n\\n        int end = intervals[0][1];\\n\\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (intervals[i][0] < end) {\\n                count++;\\n                // Pick the interval with lowest end.\\n                if (intervals[i][1] < end) {\\n                    end = intervals[i][1];\\n                }\\n            } else {\\n                end = intervals[i][1];\\n            }\\n        }      \\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347094,
                "title": "c-sorting-start-points-o-nlogn-with-explanation",
                "content": "```\\n\\tint eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size()==1) return 0;\\n        \\n        int ans = 0;\\n        sort(intervals.begin(),intervals.end()); //Sorting according to start points\\n        \\n        int prevEnd = intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]>=prevEnd){   // Non-Overlapping so just update prev \\n                prevEnd = intervals[i][1];\\n            }\\n            else{ // Overlapping case : 1 interval has to be removed so remove the one with less end point as it will have less chances of overlapping with further intervals\\n                ans ++;\\n                if(intervals[i][1]<prevEnd){    \\n                    prevEnd = intervals[i][1];  // Removal taken care by just updating prev End point to one which is smaller in their 2 possible cases\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tint eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size()==1) return 0;\\n        \\n        int ans = 0;\\n        sort(intervals.begin(),intervals.end()); //Sorting according to start points\\n        \\n        int prevEnd = intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]>=prevEnd){   // Non-Overlapping so just update prev \\n                prevEnd = intervals[i][1];\\n            }\\n            else{ // Overlapping case : 1 interval has to be removed so remove the one with less end point as it will have less chances of overlapping with further intervals\\n                ans ++;\\n                if(intervals[i][1]<prevEnd){    \\n                    prevEnd = intervals[i][1];  // Removal taken care by just updating prev End point to one which is smaller in their 2 possible cases\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1967332,
                "title": "java-without-sorting-tc-o-n-10ms-faster-than-99-91",
                "content": "The first solution is sorting the end time. Whenever a conflict happens,  remove count++, otherwise update previous end time. \\nTC: O(nlogn)\\nSC: O(n) merge sort for object array\\n```\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\\n        int result = 0;\\n        int prev = intervals[0][1];\\n        for (int i = 1; i < intervals.length; i++) {\\n            // if current start smaller than previous end,\\n            // remove current\\n            if (intervals[i][0] < prev) {\\n                result++;\\n            } else {\\n                prev = intervals[i][1];\\n            }    \\n        }\\n        return result;\\n    }\\n```\\nThe second solution:\\n We want to count final intervals without overlapping x, then erased count = total - x.\\n Building a map, key is end time, value is start time, if any value has been set, only store the larger start.\\n  \\nWhen loop through map, remember prev end time. if current start time larger than prev end time, x++, and reset prev end time to current end time\\nTC: O(n)\\nSC: O(n)\\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        for (int[] arr: intervals) {\\n            min = Math.min(min, arr[0]);\\n            max = Math.max(max, arr[1]);\\n        }\\n        int[] map = new int[max + 1 - min];\\n        Arrays.fill(map, -1);\\n        for (int[] arr: intervals) {\\n            int index = arr[1] - min;\\n            if (map[index] == -1) {\\n                map[index] = arr[0] - min;\\n            } else if (map[index] < arr[0] - min) {\\n                map[index] = arr[0] - min;\\n            }\\n        }\\n        int nonOverlapCount = 0;\\n        int preEnd = -1;\\n        for (int i = 0; i < map.length; i++) {\\n            if (map[i] == -1) continue;\\n            if (preEnd == -1) {\\n                nonOverlapCount++;\\n                preEnd = i;\\n            } else {\\n                if (preEnd <= map[i]) {\\n                    nonOverlapCount++;  \\n                    preEnd = i;                  \\n                } // otherwise, use previous node              \\n            }\\n        }\\n        return intervals.length - nonOverlapCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\\n        int result = 0;\\n        int prev = intervals[0][1];\\n        for (int i = 1; i < intervals.length; i++) {\\n            // if current start smaller than previous end,\\n            // remove current\\n            if (intervals[i][0] < prev) {\\n                result++;\\n            } else {\\n                prev = intervals[i][1];\\n            }    \\n        }\\n        return result;\\n    }\\n```\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        for (int[] arr: intervals) {\\n            min = Math.min(min, arr[0]);\\n            max = Math.max(max, arr[1]);\\n        }\\n        int[] map = new int[max + 1 - min];\\n        Arrays.fill(map, -1);\\n        for (int[] arr: intervals) {\\n            int index = arr[1] - min;\\n            if (map[index] == -1) {\\n                map[index] = arr[0] - min;\\n            } else if (map[index] < arr[0] - min) {\\n                map[index] = arr[0] - min;\\n            }\\n        }\\n        int nonOverlapCount = 0;\\n        int preEnd = -1;\\n        for (int i = 0; i < map.length; i++) {\\n            if (map[i] == -1) continue;\\n            if (preEnd == -1) {\\n                nonOverlapCount++;\\n                preEnd = i;\\n            } else {\\n                if (preEnd <= map[i]) {\\n                    nonOverlapCount++;  \\n                    preEnd = i;                  \\n                } // otherwise, use previous node              \\n            }\\n        }\\n        return intervals.length - nonOverlapCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656735,
                "title": "java-greedy-o-nlogn",
                "content": "This Question prerequisite is \"452. Minimum Number of Arrows to Burst Balloons\"\\nWe have first find pair which will not merge then subteact it from total No of elements present in the intervals array\\n```\\nclass Solution {\\n    \\n    class Intervals{\\n        int start;\\n        int end;\\n        \\n        Intervals(int s,int f){\\n            this.start=s;\\n            this.end=f;\\n        }\\n    }\\n    \\n     class myComparator implements Comparator<Intervals> {\\n        public int compare(Intervals a, Intervals b) {\\n            return a.end - b.end;\\n        }\\n    }\\n    \\n    \\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        \\n        Intervals [] arr=new Intervals[intervals.length];\\n        \\n        for(int i =0;i<arr.length;i++){\\n            arr[i]=new Intervals(intervals[i][0],intervals[i][1]);\\n            \\n        }\\n         Arrays.sort(arr, new myComparator());\\n        \\n        \\n//         we are by default including the first activity\\n        \\n        ArrayList<ArrayList<Integer>> list =new ArrayList<>();\\n        \\n        ArrayList<Integer> list2=new ArrayList<>();\\n                list2.add(arr[0].start);\\n                list2.add(arr[0].end);\\n        list.add(list2);\\n        \\n        int prev=0; \\n        \\n        for(int curr =0;curr<arr.length;curr++){\\n          \\n            if(arr[curr].start>=arr[prev].end){\\n                ArrayList<Integer> list1=new ArrayList<>();\\n                list1.add(arr[curr].start);\\n                list1.add(arr[curr].end);\\n                list.add(list1);\\n                prev=curr;\\n            }\\n            \\n        }\\n        \\n        \\n        System.out.println(list);\\n        \\n        return arr.length-list.size();\\n\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class Intervals{\\n        int start;\\n        int end;\\n        \\n        Intervals(int s,int f){\\n            this.start=s;\\n            this.end=f;\\n        }\\n    }\\n    \\n     class myComparator implements Comparator<Intervals> {\\n        public int compare(Intervals a, Intervals b) {\\n            return a.end - b.end;\\n        }\\n    }\\n    \\n    \\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        \\n        Intervals [] arr=new Intervals[intervals.length];\\n        \\n        for(int i =0;i<arr.length;i++){\\n            arr[i]=new Intervals(intervals[i][0],intervals[i][1]);\\n            \\n        }\\n         Arrays.sort(arr, new myComparator());\\n        \\n        \\n//         we are by default including the first activity\\n        \\n        ArrayList<ArrayList<Integer>> list =new ArrayList<>();\\n        \\n        ArrayList<Integer> list2=new ArrayList<>();\\n                list2.add(arr[0].start);\\n                list2.add(arr[0].end);\\n        list.add(list2);\\n        \\n        int prev=0; \\n        \\n        for(int curr =0;curr<arr.length;curr++){\\n          \\n            if(arr[curr].start>=arr[prev].end){\\n                ArrayList<Integer> list1=new ArrayList<>();\\n                list1.add(arr[curr].start);\\n                list1.add(arr[curr].end);\\n                list.add(list1);\\n                prev=curr;\\n            }\\n            \\n        }\\n        \\n        \\n        System.out.println(list);\\n        \\n        return arr.length-list.size();\\n\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364669,
                "title": "c-o-nlogn-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        int i = 1;\\n        int c = 0;\\n        while(i<intervals.size()){\\n            if(intervals[i][0]<intervals[i-1][1]){\\n                intervals[i][1] = min(intervals[i-1][1], intervals[i][1]);\\n                c++;\\n            }\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        int i = 1;\\n        int c = 0;\\n        while(i<intervals.size()){\\n            if(intervals[i][0]<intervals[i-1][1]){\\n                intervals[i][1] = min(intervals[i-1][1], intervals[i][1]);\\n                c++;\\n            }\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317644,
                "title": "dp-35-ms-o-n-log-n-not-as-optimal-as-greedy-just-for-learning-c",
                "content": "**Note:  Although Time Complexity here is same as greedy (nlogn) ,This Is Just For Learning. Greedy is always better than DP if possible.**\\n\\ndp[i] contains minimum removals required to make array **from i to end** non overlapping.\\nTherefore dp[n-1]is set to 0, and then we try to find answer for further i\\'s.\\n\\nFor each  **interval at index i**   in sorted list , we try to find out minimum removals.\\n\\nCase1: interval at **i does not overlap** any other interval **from i+1 to end** => **dp[i]=dp[i+1]**\\nCase 2: **i overlaps** at least one from i+1 to end We consider **two ways to go ahead for Case 2** :\\n\\t\\t\\t\\n* Either  We remove interval at i and resolve overlap from i+1 => **dp[i]=1+dp[i+1]**\\n*  OR we assume that the final answer after removals will contain given interval at i and remove all intervals overlapping with i , let us assume that index after removal of overlapping intervals is ind => **dp[i]=ind-i+dp[ind+1]**\\n\\n*Note: I have used binary search (set) to find value of ```ind ``` *\\n\\nWe Choose minimum of both the ways in Case 2.\\n\\n**Finally answer is dp[0].**\\n```\\n#define mp make_pair\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        \\n        vector<int> dp(intervals.size()+1,0);\\n        int n=intervals.size();\\n        set<pair<int,int>> sp;\\n        sp.insert(mp(intervals.back()[0],n-1));\\n        for(int i=n-2;i>=0;i--){\\n            \\n            \\n            auto it=sp.lower_bound(mp(intervals[i][1],-1));\\n            sp.insert(mp(intervals[i][0],i));\\n            if(it==sp.begin()){dp[i]=dp[i+1];continue;}\\n            \\n            it--;\\n            int ind=(*it).second;\\n            dp[i]=min(1+dp[i+1],ind-i+dp[ind+1]);\\n            \\n            \\n        }\\n    \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```ind ```\n```\\n#define mp make_pair\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        \\n        vector<int> dp(intervals.size()+1,0);\\n        int n=intervals.size();\\n        set<pair<int,int>> sp;\\n        sp.insert(mp(intervals.back()[0],n-1));\\n        for(int i=n-2;i>=0;i--){\\n            \\n            \\n            auto it=sp.lower_bound(mp(intervals[i][1],-1));\\n            sp.insert(mp(intervals[i][0],i));\\n            if(it==sp.begin()){dp[i]=dp[i+1];continue;}\\n            \\n            it--;\\n            int ind=(*it).second;\\n            dp[i]=min(1+dp[i+1],ind-i+dp[ind+1]);\\n            \\n            \\n        }\\n    \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109359,
                "title": "this-question-is-just-another-classic-longest-increasing-subsequence",
                "content": "In a interview, when encountering a unfamiliar question, I think it is risky to directly seek for any greedy solution. You may need to spend sometime to prove your assumption and more importantly you may go to a wrong direction.\\n\\nI think it is pretty safe to come up with a DP solution since all greedy solution is somehow based on a DP solution and it is still impressive to the interviewer. In addition, if you still have no clue how to come up with a Greedy solution, I think it is acceptable to ask for some tips based on your DP solution.\\n\\nRegarding this question, if you think in DP, you will eventually realize it is a \"Longest Increasing Subsequence\" in camouflage.\\n\\nWe can easily transform the question to \"Find the longest non-overlapping interval\". Then use the total count of the intervals minus the \"longest non-overlapping interval\" to get the final answer.\\n\\n\\n**If you are not familiar with Longest Increasing Subsequence(LIS) problem, I strongly urge you to practice. It is the fundamental of the DP problems and there are so many questions are just variation of its concept.**\\n\\n```\\nclass Solution {\\npublic:\\n    int offset;\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if (intervals.size() == 0 || intervals[0].size() == 0) {\\n            return 0;\\n        }\\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& left, const vector<int>& right) {\\n            if (left[0] == right[0]) {\\n                return left[1] < right[1];\\n            }\\n            return left[0] < right[0];\\n        });\\n        vector<int> memo(intervals.size(), -1);\\n        return intervals.size() - dp(intervals, 0, memo);\\n    }\\n\\n    int dp(vector<vector<int>>& intervals, int idx, vector<int>& memo) {\\n        if (memo[idx] != -1) {\\n            return memo[idx];\\n        }\\n        auto& cur = intervals[idx];\\n        int max = 1;\\n        for (int i = idx + 1; i < intervals.size(); i++) {\\n            if (intervals[i][0] >= cur[1]) {\\n                max = std::max(max, 1 + dp(intervals, i, memo));\\n            }\\n        }\\n        return memo[idx] = max;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int offset;\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if (intervals.size() == 0 || intervals[0].size() == 0) {\\n            return 0;\\n        }\\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& left, const vector<int>& right) {\\n            if (left[0] == right[0]) {\\n                return left[1] < right[1];\\n            }\\n            return left[0] < right[0];\\n        });\\n        vector<int> memo(intervals.size(), -1);\\n        return intervals.size() - dp(intervals, 0, memo);\\n    }\\n\\n    int dp(vector<vector<int>>& intervals, int idx, vector<int>& memo) {\\n        if (memo[idx] != -1) {\\n            return memo[idx];\\n        }\\n        auto& cur = intervals[idx];\\n        int max = 1;\\n        for (int i = idx + 1; i < intervals.size(); i++) {\\n            if (intervals[i][0] >= cur[1]) {\\n                max = std::max(max, 1 + dp(intervals, i, memo));\\n            }\\n        }\\n        return memo[idx] = max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 792796,
                "title": "java-simple-solution-sort-based-on-end-time",
                "content": "The idea is to include many short non-overlapping interval and skip the bigger interval which contains multiple short intervals. To do this, sort the intervals based on end time and if end times are same, pick the one with smaller interval length i.e, bigger start time. After sorting, the rest of the code is intuitive.\\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        int n = intervals.length;\\n        if (n < 2) return 0;\\n        Arrays.sort(intervals, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] a, int[] b) {\\n                if (a[1] != b[1])\\n                    return a[1] - b[1];\\n                return b[0] - a[0];\\n            }\\n        });\\n        \\n        int res = 0, p = 0;\\n        for (int i = 1; i < n; i++) {\\n            int[] prev = intervals[p];\\n            int[] curr = intervals[i];\\n\\t\\t\\t/* Skip the non-overlapping interval */\\n            if (prev[1] <= curr[0])\\n                p = i;\\n            else\\n                res++;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        int n = intervals.length;\\n        if (n < 2) return 0;\\n        Arrays.sort(intervals, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] a, int[] b) {\\n                if (a[1] != b[1])\\n                    return a[1] - b[1];\\n                return b[0] - a[0];\\n            }\\n        });\\n        \\n        int res = 0, p = 0;\\n        for (int i = 1; i < n; i++) {\\n            int[] prev = intervals[p];\\n            int[] curr = intervals[i];\\n\\t\\t\\t/* Skip the non-overlapping interval */\\n            if (prev[1] <= curr[0])\\n                p = i;\\n            else\\n                res++;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162447,
                "title": "can-we-use-dp-java",
                "content": "Not competing for speed, I know greed is the optimized solution. Just want to provide another angle of thinking about this problem. Minimum number of interval to remove to make non-overlapping intervals is the same as maximum number of interval to retain. \\nThis is very similar to LeetCode 300 Longest Increase Subsequence.\\nIf `intervals[i].start >= intervals[j].end`\\nWe have `DP[i] = DP[j] + 1` where `i` range from `0` to `intervals.length` and `j` from `0` to `i - 1`\\n\\nThe following code also got AC\\n```\\n\\nclass Solution {\\n    public int eraseOverlapIntervals(Interval[] intervals) {\\n        \\n        if (intervals.length == 0) {\\n            return 0;\\n        }\\n        int len = intervals.length;\\n        \\n        Arrays.sort(intervals, new Comparator<Interval>() {\\n            public int compare(Interval a, Interval b) {\\n                if (a.start != b.start) {\\n                    return a.start - b.start;\\n                }\\n                return a.end - b.end;\\n            }\\n        });\\n        \\n        int[] dp = new int[len];\\n        for (int i = 0; i < len; i++) {\\n            dp[i] = 1;\\n        }\\n        \\n        int res = 1;\\n        for (int i = 1; i < len; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (intervals[i].start >= intervals[j].end) {\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n                }\\n            }\\n            res = Math.max(res, dp[i]);\\n        }\\n        \\n        return len - res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int eraseOverlapIntervals(Interval[] intervals) {\\n        \\n        if (intervals.length == 0) {\\n            return 0;\\n        }\\n        int len = intervals.length;\\n        \\n        Arrays.sort(intervals, new Comparator<Interval>() {\\n            public int compare(Interval a, Interval b) {\\n                if (a.start != b.start) {\\n                    return a.start - b.start;\\n                }\\n                return a.end - b.end;\\n            }\\n        });\\n        \\n        int[] dp = new int[len];\\n        for (int i = 0; i < len; i++) {\\n            dp[i] = 1;\\n        }\\n        \\n        int res = 1;\\n        for (int i = 1; i < len; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (intervals[i].start >= intervals[j].end) {\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n                }\\n            }\\n            res = Math.max(res, dp[i]);\\n        }\\n        \\n        return len - res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788721,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int eraseOverlapIntervals(vector<vector<int>>&points) {\\n\\n        sort(points.begin(),points.end());\\n\\n        int  r = points[0][1], cnt = 0;\\n\\n        for(int i = 1; i < points.size(); ++i)\\n        {\\n            if(r > points[i][0])\\n            {\\n                r = min(r, points[i][1]);\\n                cnt++; \\n            }\\n\\n            else r = points[i][1];\\n                    \\n        }\\n         return cnt; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int eraseOverlapIntervals(vector<vector<int>>&points) {\\n\\n        sort(points.begin(),points.end());\\n\\n        int  r = points[0][1], cnt = 0;\\n\\n        for(int i = 1; i < points.size(); ++i)\\n        {\\n            if(r > points[i][0])\\n            {\\n                r = min(r, points[i][1]);\\n                cnt++; \\n            }\\n\\n            else r = points[i][1];\\n                    \\n        }\\n         return cnt; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787745,
                "title": "c-short-solution-with-short-explanation",
                "content": "# Intuition\\n-> OBSERVE: the whole sequence is about the `last` allowed element in the rangegree.\\n-> If `first` of current element is less than the `last` of previously taken element, simply choose the element which has the least `last`.\\n-> Else choose the current element and update the `last`.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int count = 1;\\n        int prev=intervals[0][1];\\n        for(int i = 1; i<intervals.size(); i++){\\n            if(intervals[i][0]<prev){\\n                prev=min(prev,intervals[i][1]);\\n            }\\n            else{\\n                count++;\\n                prev=intervals[i][1];\\n            }\\n        }\\n        return intervals.size()-count;\\n    }\\n};\\n```\\n\\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int count = 1;\\n        int prev=intervals[0][1];\\n        for(int i = 1; i<intervals.size(); i++){\\n            if(intervals[i][0]<prev){\\n                prev=min(prev,intervals[i][1]);\\n            }\\n            else{\\n                count++;\\n                prev=intervals[i][1];\\n            }\\n        }\\n        return intervals.size()-count;\\n    }\\n};\\n```\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787008,
                "title": "non-overlapping-intervals-priority-queue-java",
                "content": "Hi,\\n\\n**Intution**: My idea is to use a priority queue to sort the given array based on the end time. We can iterate through the sorted list and check whether the end time of the previous element is greater than the start time of the next one. If it is, we will have to remove that element and proceed; otherwise, we have to update the end time accordingly.\\n\\n**Steps:**\\n1. Create a priority queue that sorts based on the end time.\\n2. Iterate through the given array and sort it in the priority queue.\\n3. Declare two variables, endtime and result, where endtime is initially set to a negative maximum value and result is set to zero.\\n4. While iterating through the priority queue, check if the start time of the current element is greater than the endtime variable. If it is, increment the result; otherwise, update the endtime variable with the current element\\'s end time.\\n\\n\\nHappy learning! If you have made it this far, please consider giving an upvote and spreading positive vibes.\\n\\nHere is the code:\\n\\n```\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a,b) ->(a[1]-b[1]));\\n        for(int[] one: intervals){\\n            pq.add(one);\\n        }\\n        int end=Integer.MIN_VALUE, res=0;\\n        while(!pq.isEmpty()){\\n            int[] temp = pq.poll();\\n            if(temp[0]>=end){\\n                end=temp[1];\\n            } else\\n                res++;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi,\\n\\n**Intution**: My idea is to use a priority queue to sort the given array based on the end time. We can iterate through the sorted list and check whether the end time of the previous element is greater than the start time of the next one. If it is, we will have to remove that element and proceed; otherwise, we have to update the end time accordingly.\\n\\n**Steps:**\\n1. Create a priority queue that sorts based on the end time.\\n2. Iterate through the given array and sort it in the priority queue.\\n3. Declare two variables, endtime and result, where endtime is initially set to a negative maximum value and result is set to zero.\\n4. While iterating through the priority queue, check if the start time of the current element is greater than the endtime variable. If it is, increment the result; otherwise, update the endtime variable with the current element\\'s end time.\\n\\n\\nHappy learning! If you have made it this far, please consider giving an upvote and spreading positive vibes.\\n\\nHere is the code:\\n\\n```\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a,b) ->(a[1]-b[1]));\\n        for(int[] one: intervals){\\n            pq.add(one);\\n        }\\n        int end=Integer.MIN_VALUE, res=0;\\n        while(!pq.isEmpty()){\\n            int[] temp = pq.poll();\\n            if(temp[0]>=end){\\n                end=temp[1];\\n            } else\\n                res++;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3785970,
                "title": "c-solution-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCompare end time of previous interval with starting of the next interval.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst sort the array (by starting time) then compare the end time of previous interval with starting of the next interval and to handle -ve cases take the minimum of end time of both intervals. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$(nlogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int ans=0;\\n        int prev=nums[0][1];\\n        // for(auto it:nums) cout<<\"[\"<<it[0]<<\",\"<<it[1]<<\"]\";\\n        for(int i=1;i<n;i++){\\n            if(prev>nums[i][0]){\\n                ans++;\\n                prev=min(prev,nums[i][1]);\\n            }\\n            else prev=nums[i][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int ans=0;\\n        int prev=nums[0][1];\\n        // for(auto it:nums) cout<<\"[\"<<it[0]<<\",\"<<it[1]<<\"]\";\\n        for(int i=1;i<n;i++){\\n            if(prev>nums[i][0]){\\n                ans++;\\n                prev=min(prev,nums[i][1]);\\n            }\\n            else prev=nums[i][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3785838,
                "title": "easy-c-sorting-greedy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n\\n        int curr_end = intervals[0][1];\\n        int cnt = 0;\\n        for(int i=1; i<n; i++){\\n            if(intervals[i][0] < curr_end){\\n                cnt++;\\n                curr_end = min(curr_end, intervals[i][1]);\\n            }else {\\n                curr_end = intervals[i][1];\\n            }\\n        } \\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n\\n        int curr_end = intervals[0][1];\\n        int cnt = 0;\\n        for(int i=1; i<n; i++){\\n            if(intervals[i][0] < curr_end){\\n                cnt++;\\n                curr_end = min(curr_end, intervals[i][1]);\\n            }else {\\n                curr_end = intervals[i][1];\\n            }\\n        } \\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785581,
                "title": "c-solution-for-non-overlapping-intervals-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to sort the intervals based on their end points. By doing so, we can ensure that intervals with smaller end points come first in the sorted list.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code starts by checking if the number of intervals is less than or equal to 1, in which case no removal is needed, so the function returns 0.\\n\\nNext, the intervals are sorted based on their end points in ascending order using the Array.Sort method. This allows us to consider intervals with smaller end points first.\\n\\nThe code then initializes a count variable to keep track of the number of intervals that need to be removed. It also initializes an end variable to store the end point of the first interval.\\n\\nThe implementation iterates through the sorted intervals starting from the second interval. For each interval, if its start point is less than the current end value, it means there is an overlap with the previous interval, so the count is incremented. Otherwise, if there is no overlap, the end variable is updated to the end point of the current interval.\\n\\nFinally, the function returns the count, which represents the minimum number of intervals that need to be removed to make the rest of the intervals non-overlapping.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n log n), where n is the number of intervals. This is because we first sort the intervals, which takes O(n log n) time. Then, we iterate through the sorted intervals once, which takes O(n) time. Therefore, the dominant factor is the sorting operation.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) because we only use a constant amount of extra space for variables, regardless of the size of the input.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int EraseOverlapIntervals(int[][] intervals) {\\n        if (intervals.Length <= 1)\\n        return 0;\\n    \\n        // Sort the intervals based on their end points in ascending order\\n        Array.Sort(intervals, (a, b) => a[1].CompareTo(b[1]));\\n        \\n        int count = 0;\\n        int end = intervals[0][1];\\n        \\n        // Iterate through the sorted intervals\\n        for (int i = 1; i < intervals.Length; i++) {\\n            // If the current interval overlaps with the previous one, increment count\\n            // and update the end point to the minimum end point\\n            if (intervals[i][0] < end) {\\n                count++;\\n            } else {\\n                end = intervals[i][1];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int EraseOverlapIntervals(int[][] intervals) {\\n        if (intervals.Length <= 1)\\n        return 0;\\n    \\n        // Sort the intervals based on their end points in ascending order\\n        Array.Sort(intervals, (a, b) => a[1].CompareTo(b[1]));\\n        \\n        int count = 0;\\n        int end = intervals[0][1];\\n        \\n        // Iterate through the sorted intervals\\n        for (int i = 1; i < intervals.Length; i++) {\\n            // If the current interval overlaps with the previous one, increment count\\n            // and update the end point to the minimum end point\\n            if (intervals[i][0] < end) {\\n                count++;\\n            } else {\\n                end = intervals[i][1];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785408,
                "title": "c-why-this-solution-not-working-binary-search-dp",
                "content": "if I\\'m adding **dp[i]=max(1,dp[i-1])** at place of <------------------>, its working fine, but not able to understand the exact  reason \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // sort by min. end time\\n    static bool compare(vector<int> &a, vector<int> &b){\\n        if(a[1]==b[1]) return a[0]<b[0];\\n        return a[1]<b[1];\\n    }\\n    \\n    // non-overlapping interval\\n    int search(vector<vector<int>> &a, int idx){\\n        int l=0, r=idx-1;\\n        \\n        while(l<r){\\n            int m=l+(r-l+1)/2;\\n            if(a[m][1]<=a[idx][0]){\\n                l=m;\\n            }else{\\n                r=m-1;\\n            }\\n        }\\n        return (a[l][1]<=a[idx][0] ? l:-1);\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& a) {\\n        sort(a.begin(),a.end(),compare);\\n        int n=a.size();\\n        \\n        vector<int> dp(n,1); // longest non-overlapping subsequence\\n        \\n        int ans=1;\\n        for(int i=1;i<n;i++){\\n\\t\\t\\t<------------------>\\n            int idx=search(a,i);\\n            \\n            if(idx!=-1) dp[i]=max(dp[i],1+dp[idx]);\\n            ans=max(ans,dp[i]);\\n        } \\n        return n-ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // sort by min. end time\\n    static bool compare(vector<int> &a, vector<int> &b){\\n        if(a[1]==b[1]) return a[0]<b[0];\\n        return a[1]<b[1];\\n    }\\n    \\n    // non-overlapping interval\\n    int search(vector<vector<int>> &a, int idx){\\n        int l=0, r=idx-1;\\n        \\n        while(l<r){\\n            int m=l+(r-l+1)/2;\\n            if(a[m][1]<=a[idx][0]){\\n                l=m;\\n            }else{\\n                r=m-1;\\n            }\\n        }\\n        return (a[l][1]<=a[idx][0] ? l:-1);\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& a) {\\n        sort(a.begin(),a.end(),compare);\\n        int n=a.size();\\n        \\n        vector<int> dp(n,1); // longest non-overlapping subsequence\\n        \\n        int ans=1;\\n        for(int i=1;i<n;i++){\\n\\t\\t\\t<------------------>\\n            int idx=search(a,i);\\n            \\n            if(idx!=-1) dp[i]=max(dp[i],1+dp[idx]);\\n            ans=max(ans,dp[i]);\\n        } \\n        return n-ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785349,
                "title": "c-greedy-approach-faster-than-90-of-solution-clean-and-concise",
                "content": "**CONNECT WITH ME ON LINKEDIN : https://www.linkedin.com/in/kunal-shaw-/**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is straight forward and is as follows in some points :\\n(Same as maximum number of elements to take so the sequence remain non-overlapping)\\n->Sort the interval array\\n->Store inter[0][0] in start variable and inter[0][1] in end variable.\\n->Now iterate through the loop and greadily count maximum number of non-overlapping intervals\\n->So n-cnt is the required counts to remove from the array such that it become non overlapping. \\n# Complexity\\n- Time complexity:O(NLogN)\\n\\n- Space complexity: O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& inter) {\\n        int n=inter.size();\\n        sort(inter.begin(),inter.end());\\n        int cnt=1;\\n        int o=inter[0][0];\\n        int c=inter[0][1];\\n        for(int i=1;i<n;i++){\\n            if(c>inter[i][0]){\\n                c=min(c,inter[i][1]);\\n            }\\n            else{\\n                cnt++;\\n                o=inter[i][0];\\n                c=inter[i][1];\\n            }\\n        }\\n        return n-cnt;\\n    }\\n};\\n```\\n![memer-cat.jpg](https://assets.leetcode.com/users/images/dfc2018d-01d8-43da-9889-af2896179f15_1675779280.3429081.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& inter) {\\n        int n=inter.size();\\n        sort(inter.begin(),inter.end());\\n        int cnt=1;\\n        int o=inter[0][0];\\n        int c=inter[0][1];\\n        for(int i=1;i<n;i++){\\n            if(c>inter[i][0]){\\n                c=min(c,inter[i][1]);\\n            }\\n            else{\\n                cnt++;\\n                o=inter[i][0];\\n                c=inter[i][1];\\n            }\\n        }\\n        return n-cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717584,
                "title": "better-greedy-approach-clean-best-solution",
                "content": "**Simplest solution using greedy approach**\\n*1. first sort the intervals  based on their finishing points*\\n*2. traverse the array , if you find any starting point less than the previous end point then cnt it as overlapping interval*\\n*otherwise update the end point with the latest finish point*\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp(const vector<int>& a,const vector<int>& b){\\n          return a[1]<b[1];\\n      }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        \\n        int cnt=0,n=intervals.size();\\n        sort(intervals.begin(),intervals.end(),cmp);\\n        \\n        int end=intervals[0][1];\\n        \\n        for(int i=1;i<n;i++){\\n            if(intervals[i][0] <end) cnt++;\\n            else end=intervals[i][1];\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```\\n\\nThank you !! \\nplz upvote if you find helpfull :)",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp(const vector<int>& a,const vector<int>& b){\\n          return a[1]<b[1];\\n      }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        \\n        int cnt=0,n=intervals.size();\\n        sort(intervals.begin(),intervals.end(),cmp);\\n        \\n        int end=intervals[0][1];\\n        \\n        for(int i=1;i<n;i++){\\n            if(intervals[i][0] <end) cnt++;\\n            else end=intervals[i][1];\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378764,
                "title": "best-o-nlogn-solution",
                "content": "# Approach\\nGreedy and Sorting\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool static comp(vector <int>& a, vector <int>& b) {\\n        return a[1] < b[1];\\n    }\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort (intervals.begin(), intervals.end(), comp);\\n        int end = intervals[0][1];\\n        int minRemove = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (intervals[i][0] < end)\\n                minRemove++;\\n            else\\n                end = intervals[i][1];    \\n        }\\n        return minRemove;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static comp(vector <int>& a, vector <int>& b) {\\n        return a[1] < b[1];\\n    }\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort (intervals.begin(), intervals.end(), comp);\\n        int end = intervals[0][1];\\n        int minRemove = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (intervals[i][0] < end)\\n                minRemove++;\\n            else\\n                end = intervals[i][1];    \\n        }\\n        return minRemove;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360213,
                "title": "activity-selection-greedy-approach-easy-java-solution",
                "content": "# Intuition\\nFirst check the valid Intervals. And then subtract it from total number to get invalid intervals\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSo first array is not null so there will be always one solution. Now sort the 2nd column of this array to apply greedy approach.\\nto sort 2nd column lets use Comparator.\\n```\\nArrays.sort(nums, Comparator.comparingDouble(o -> o[1]));\\n```\\n```o[1]``` denotes 2nd column to be sorted.\\nnow check for valid intervals. if ```nextStart >= prevLast``` then it is valid.\\nSo, we are incrementing count and assign prevLast to newLast. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums, Comparator.comparingDouble(o -> o[1]));\\n        int last = nums[0][1];\\n        int count = 1;\\n        for(int i = 1; i < n; i++){\\n            if(nums[i][0] >= last){\\n                count++;\\n                last = nums[i][1];\\n            }\\n        }\\n        return n - count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nArrays.sort(nums, Comparator.comparingDouble(o -> o[1]));\\n```\n```o[1]```\n```nextStart >= prevLast```\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums, Comparator.comparingDouble(o -> o[1]));\\n        int last = nums[0][1];\\n        int count = 1;\\n        for(int i = 1; i < n; i++){\\n            if(nums[i][0] >= last){\\n                count++;\\n                last = nums[i][1];\\n            }\\n        }\\n        return n - count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204441,
                "title": "simple-c-greedy-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a,vector<int> &b){\\n        if(a[1]==b[1]){\\n            return a[0]>b[0];\\n        }\\n        return a[1]<b[1];\\n    }\\n    int eraseOverlapIntervals(vector<vector<int>>& v) {\\n        sort(v.begin(),v.end(),cmp);\\n        // for(auto &i: v){\\n        //     cout<<i[0]<<\" \"<<i[1]<<endl;\\n        // }\\n        int ans = 0,e = v[0][1];\\n        for(int i = 1; i < v.size(); i++){\\n            // cout<<v[i][0]<<\" \"<<e<<endl;\\n            if(v[i][0]<e){\\n                ans++;\\n            }else\\n            e = v[i][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a,vector<int> &b){\\n        if(a[1]==b[1]){\\n            return a[0]>b[0];\\n        }\\n        return a[1]<b[1];\\n    }\\n    int eraseOverlapIntervals(vector<vector<int>>& v) {\\n        sort(v.begin(),v.end(),cmp);\\n        // for(auto &i: v){\\n        //     cout<<i[0]<<\" \"<<i[1]<<endl;\\n        // }\\n        int ans = 0,e = v[0][1];\\n        for(int i = 1; i < v.size(); i++){\\n            // cout<<v[i][0]<<\" \"<<e<<endl;\\n            if(v[i][0]<e){\\n                ans++;\\n            }else\\n            e = v[i][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3023884,
                "title": "java-best-solution-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals,(a,b)->(a[1]-b[1]));\\n\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n\\n        int count=0;\\n        for(int i=1;i<intervals.length;i++){\\n            if(intervals[i][0]<end){\\n                count++;\\n            }\\n            else{\\n                start=intervals[i][0];\\n                end=intervals[i][1];\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals,(a,b)->(a[1]-b[1]));\\n\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n\\n        int count=0;\\n        for(int i=1;i<intervals.length;i++){\\n            if(intervals[i][0]<end){\\n                count++;\\n            }\\n            else{\\n                start=intervals[i][0];\\n                end=intervals[i][1];\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730719,
                "title": "python-greedy-solution",
                "content": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        count = 0 \\n        intervals.sort()\\n        # keep the interval that has the shorter end since longer end will overlap with other intervals\\n        for i in range(len(intervals) - 1):\\n            if intervals[i + 1][0] < intervals[i][1]:\\n                count += 1\\n                intervals[i + 1][1] = min(intervals[i + 1][1],intervals[i][1])\\n        \\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        count = 0 \\n        intervals.sort()\\n        # keep the interval that has the shorter end since longer end will overlap with other intervals\\n        for i in range(len(intervals) - 1):\\n            if intervals[i + 1][0] < intervals[i][1]:\\n                count += 1\\n                intervals[i + 1][1] = min(intervals[i + 1][1],intervals[i][1])\\n        \\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681130,
                "title": "maintain-interval-t-c-o-n-logn-explained",
                "content": "**PLS UPVOTE IF you like the SOLUTION:)**\\n**IDEA:-**\\n* So, first we sort the array  such that the intervals are in increasing order and if the start intervals are equal then the one whose end interval is less should come first.\\n* Now, you take two variables start and end which you used to compare whether the upcoming intervals are overlapping or not and initialise this variables with the first interval of intervals.\\n* Now when you get a new interval you check if intervals[i][0] <end which signifies it overlaps thus you increase your count. \\n* **NOTE:-** **FOR getting minm count** you also check one more thing that if the **intervals[i][1]<end** also if its is you update start and end.\\n* This is done because there might be some intervals which overlap if you have not updated the start and end thus would have given more count.\\n* IF the intervals[i][0] is not less than end you simply update start and end.\\n\\n     **T.C:-** O(NlogN)            \\n\\t **S.C:-** O(1)\\n\\n```\\nbool cmp(vector<int>&v1,vector<int>&v2){\\n    if(v1[0]==v2[0]){\\n        return v1[1]<v2[1];\\n    }\\n    return v1[0]<v2[0];\\n}\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),cmp);\\n        int count=0;\\n        int start=intervals.at(0).at(0);\\n        int end=intervals.at(0).at(1);\\n        for(int i{1};i<intervals.size();++i){\\n            if(intervals.at(i).at(0)<end){\\n                count++;\\n                if(intervals.at(i).at(1)<end){\\n                    start=intervals.at(i).at(0);\\n                    end=intervals.at(i).at(1);    \\n                }\\n            }else{\\n                start=intervals.at(i).at(0);\\n                end=intervals.at(i).at(1);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nbool cmp(vector<int>&v1,vector<int>&v2){\\n    if(v1[0]==v2[0]){\\n        return v1[1]<v2[1];\\n    }\\n    return v1[0]<v2[0];\\n}\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),cmp);\\n        int count=0;\\n        int start=intervals.at(0).at(0);\\n        int end=intervals.at(0).at(1);\\n        for(int i{1};i<intervals.size();++i){\\n            if(intervals.at(i).at(0)<end){\\n                count++;\\n                if(intervals.at(i).at(1)<end){\\n                    start=intervals.at(i).at(0);\\n                    end=intervals.at(i).at(1);    \\n                }\\n            }else{\\n                start=intervals.at(i).at(0);\\n                end=intervals.at(i).at(1);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191214,
                "title": "java-12-lines-easier-than-top-solution",
                "content": "Just sort and keep track of the end. If the interval lie inside the prev interval, i.e. if its first element is lesser than the end. Then increment ans and update the end to the minimum of two. Otherwise, the interval is outside so update the end. \\nTip: try drawing it on pen and paper for the following edge case and the give example: \\n`[[0,2],[1,3],[2,4],[3,5],[4,6]]`\\n```java\\npublic int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b)->a[0]-b[0]);\\n        int end = intervals[0][1], ans = 0;\\n        for (int i=1; i<intervals.length; i++) {\\n            if (intervals[i][0]<end) {\\n                ans++;\\n                end = Math.min(end, intervals[i][1]);\\n            }\\n            else \\n                end = intervals[i][1];\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```java\\npublic int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b)->a[0]-b[0]);\\n        int end = intervals[0][1], ans = 0;\\n        for (int i=1; i<intervals.length; i++) {\\n            if (intervals[i][0]<end) {\\n                ans++;\\n                end = Math.min(end, intervals[i][1]);\\n            }\\n            else \\n                end = intervals[i][1];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1864408,
                "title": "simple-java-solution-with-comments-of-each-step",
                "content": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        \\n        // A variable to count the minimum number of elements we need to remove\\n        int count = 0;\\n        \\n        // Sort the 2D array according to the last element of each row\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1]));\\n        \\n        // The first row\\n        int[] previous = intervals[0];\\n        \\n        // Loop in the 2D array starting from the second row\\n        for(int i=1; i<intervals.length; i++) {\\n            \\n            // the ith row of the 2D array\\n            int[] current = intervals[i];\\n            \\n            // if the last element of the (i-1)th row is bigger than the first element in the (i)th row increment the counter\\n            // and continue with the loop (because we don\\'t need the (i-1)th row to change)\\n            if(previous[1] > current[0]) {\\n                \\n                count++;\\n                continue;\\n            }\\n            \\n            // if the last element of the (i-1)th row is less than or equal to the first element in the (i)th row we need to change the \\n            // (i-1)th row to the (i)th row and the (i)th row will be changed to the next row of the 2D array in the start of the loop\\n            previous = current;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        \\n        // A variable to count the minimum number of elements we need to remove\\n        int count = 0;\\n        \\n        // Sort the 2D array according to the last element of each row\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1]));\\n        \\n        // The first row\\n        int[] previous = intervals[0];\\n        \\n        // Loop in the 2D array starting from the second row\\n        for(int i=1; i<intervals.length; i++) {\\n            \\n            // the ith row of the 2D array\\n            int[] current = intervals[i];\\n            \\n            // if the last element of the (i-1)th row is bigger than the first element in the (i)th row increment the counter\\n            // and continue with the loop (because we don\\'t need the (i-1)th row to change)\\n            if(previous[1] > current[0]) {\\n                \\n                count++;\\n                continue;\\n            }\\n            \\n            // if the last element of the (i-1)th row is less than or equal to the first element in the (i)th row we need to change the \\n            // (i-1)th row to the (i)th row and the (i)th row will be changed to the next row of the 2D array in the start of the loop\\n            previous = current;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618904,
                "title": "readable-c-easy-solution-with-explanation",
                "content": "```\\n// logic is to sort by the second value\\n// and initialize start and end value to values of first subarray\\n// now check if is there any subarray which have start value less\\n// than our end value if yes than do count++ otherwise update the\\n// start and end values.\\n// ex - [[1,2],[1,4],[4,5]]  sorted on basis of sencond value  \\n// s=1 ,e=2 now array[1][0]=1 which is less than e \\n// do count++ no change in s and e\\n// now arr[2][0] =  4 which is not < than e =2 so update s and e\\n// s=4, e=5\\n\\n static bool comparator(vector<int>&a,vector<int>&b)\\n    {\\n        return a[1]<b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& nums) \\n    {\\n        sort(nums.begin(),nums.end(),comparator);\\n        \\n        int count =0;\\n        \\n        int s = nums[0][0];\\n        int e = nums[0][1];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i][0]<e)\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                s=nums[i][0];\\n                e=nums[i][1];\\n            }\\n               \\n        }\\n        return count;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// logic is to sort by the second value\\n// and initialize start and end value to values of first subarray\\n// now check if is there any subarray which have start value less\\n// than our end value if yes than do count++ otherwise update the\\n// start and end values.\\n// ex - [[1,2],[1,4],[4,5]]  sorted on basis of sencond value  \\n// s=1 ,e=2 now array[1][0]=1 which is less than e \\n// do count++ no change in s and e\\n// now arr[2][0] =  4 which is not < than e =2 so update s and e\\n// s=4, e=5\\n\\n static bool comparator(vector<int>&a,vector<int>&b)\\n    {\\n        return a[1]<b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& nums) \\n    {\\n        sort(nums.begin(),nums.end(),comparator);\\n        \\n        int count =0;\\n        \\n        int s = nums[0][0];\\n        int e = nums[0][1];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i][0]<e)\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                s=nums[i][0];\\n                e=nums[i][1];\\n            }\\n               \\n        }\\n        return count;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1507393,
                "title": "java-greedy-intuition-easy-to-understand",
                "content": "**Approach:**\\nSort the intervals based on start time and then look for overlapping intervals. If overlap found then consider the interval which has the shortest end time, as the larger end time might overlap with more intervals.\\n\\n**Code:**\\n\\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\\n        \\n        int count = 0;        \\n        int[] prev = intervals[0];\\n        for(int i=1; i < intervals.length; i++){\\n            if(prev[1] > intervals[i][0]){\\n                prev[1] = Math.min(prev[1], intervals[i][1]);\\n                count++;\\n            } else \\n                prev = intervals[i];\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\\n        \\n        int count = 0;        \\n        int[] prev = intervals[0];\\n        for(int i=1; i < intervals.length; i++){\\n            if(prev[1] > intervals[i][0]){\\n                prev[1] = Math.min(prev[1], intervals[i][1]);\\n                count++;\\n            } else \\n                prev = intervals[i];\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383252,
                "title": "java-solution-with-hints-explanation",
                "content": "First of all, this problem is not as difficult as it looks. So I will encourage you to give it another shot with the hints below:\\n\\nHint#1: If you haven\\'t solved interval problems (merge intervals, identify overlap, meeting rooms, etc) before, solve this question: Given a list of intervals, identify if there is an overlap between any two intervals. \\nBy solving this problem, you will appreciate why it\\'s important to sort the intervals based on the start of a interval. \\n\\nHint#2: If case of overlapping intervals, bigger the end of the interval, higher the chance that it will overlap with rest of the intervals. So keeping the interval with smaller end will lead to the answer. \\n\\nTry to solve the question with the help of above two hints. If you still can\\'t, chill! Checkout the solution below and make sure you understand it. I am sure you will be able to solve similar problems in future once you nail this down. \\n\\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n\\t    // According to the constrains, intervals.length >= 1\\n        if(intervals.length < 2) {\\n            return 0;\\n        }\\n        \\n\\t\\t// In intervals problems (eg, overlapping intervals, meeting rooms, etc), \\n\\t\\t//it\\'s absolutely necessary that we sort the array on the starting point of the interval.\\n        Arrays.sort(intervals,(a,b)->{\\n            return a[0]-b[0];\\n        });\\n        \\n        int count  = 0;\\n\\t\\t\\n\\t\\t//Note that we don\\'t have to maintain a list of previously seen intervals.\\n\\t\\t//We are only interested in the END of the previous interval\\n        int prevEnd = intervals[0][1];\\n        \\n        for(int i = 1; i < intervals.length; i++) {\\n            if(intervals[i][0] < prevEnd) {          //if current interval start is less than prev interval end => overlap!\\n                count++;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//This line is the crux of this problem. If you can come up with this line,\\n\\t\\t\\t\\t//the rest of the algo is easy to understand.\\n                prevEnd = Math.min(prevEnd, intervals[i][1]);\\n            } else {\\n                prevEnd = intervals[i][1];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n\\nPosting this solution out of frustration. I don\\'t see any post that explains the solution in a simple manner. If you find this solution helpful, please upvote so that the post can help more people like us!\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n\\t    // According to the constrains, intervals.length >= 1\\n        if(intervals.length < 2) {\\n            return 0;\\n        }\\n        \\n\\t\\t// In intervals problems (eg, overlapping intervals, meeting rooms, etc), \\n\\t\\t//it\\'s absolutely necessary that we sort the array on the starting point of the interval.\\n        Arrays.sort(intervals,(a,b)->{\\n            return a[0]-b[0];\\n        });\\n        \\n        int count  = 0;\\n\\t\\t\\n\\t\\t//Note that we don\\'t have to maintain a list of previously seen intervals.\\n\\t\\t//We are only interested in the END of the previous interval\\n        int prevEnd = intervals[0][1];\\n        \\n        for(int i = 1; i < intervals.length; i++) {\\n            if(intervals[i][0] < prevEnd) {          //if current interval start is less than prev interval end => overlap!\\n                count++;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//This line is the crux of this problem. If you can come up with this line,\\n\\t\\t\\t\\t//the rest of the algo is easy to understand.\\n                prevEnd = Math.min(prevEnd, intervals[i][1]);\\n            } else {\\n                prevEnd = intervals[i][1];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217272,
                "title": "javascript-easy-solution",
                "content": "```\\nvar eraseOverlapIntervals = function(intervals) {\\n    intervals.sort((a,b)=>{\\n        return a[1] - b[1]\\n    })\\n    let count = 0;\\n    let prev = 0;\\n    for (let i = 1; i < intervals.length; i++) {\\n        if (intervals[i][0] < intervals[prev][1]) {\\n            count++;\\n        } else {\\n            prev = i;\\n        }\\n    }\\n    return count;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar eraseOverlapIntervals = function(intervals) {\\n    intervals.sort((a,b)=>{\\n        return a[1] - b[1]\\n    })\\n    let count = 0;\\n    let prev = 0;\\n    for (let i = 1; i < intervals.length; i++) {\\n        if (intervals[i][0] < intervals[prev][1]) {\\n            count++;\\n        } else {\\n            prev = i;\\n        }\\n    }\\n    return count;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 828771,
                "title": "java-easy-to-understand",
                "content": "**Greedy Appraoch: **\\n\\n1. Sort the intervals by ending time\\n2. As long as the next interval starttime is after previous interval end time, continue\\n3. Otherwise increment the counter\\n4. Return counter result\\n\\n```\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        \\n        if (intervals == null || intervals.length == 0) return 0;\\n        \\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\\n        int endTime = intervals[0][1], result = 0;\\n        for(int index=1; index < intervals.length; index++){\\n            //As long as next interval is after previous, continue\\n            if (intervals[index][0] >= endTime ){\\n                endTime = intervals[index][1];\\n                continue;\\n            }\\n            //otherwise we need to remove the current interval\\n            result++;\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "**Greedy Appraoch: **\\n\\n1. Sort the intervals by ending time\\n2. As long as the next interval starttime is after previous interval end time, continue\\n3. Otherwise increment the counter\\n4. Return counter result\\n\\n```\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        \\n        if (intervals == null || intervals.length == 0) return 0;\\n        \\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\\n        int endTime = intervals[0][1], result = 0;\\n        for(int index=1; index < intervals.length; index++){\\n            //As long as next interval is after previous, continue\\n            if (intervals[index][0] >= endTime ){\\n                endTime = intervals[index][1];\\n                continue;\\n            }\\n            //otherwise we need to remove the current interval\\n            result++;\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 810866,
                "title": "easy-java-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        int count = 0;\\n        if(intervals.length == 0 || intervals[0].length == 0)\\n            return count;\\n        Arrays.sort(intervals,(a,b)->a[1]-b[1]);//sort based on end val\\n        int prevEnd = intervals[0][1];\\n        for(int i = 1;i<intervals.length;i++){\\n            if(intervals[i][0] < prevEnd){ //if current start is less than prev end it means it overlaps\\n                count++;   // and need to remove then increament the count\\n            }else{ //if it does not overlap update the prevEnd with current interval end\\n                prevEnd = intervals[i][1]; //intervals[i][1] -- end n intervals[i][0] -- start\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        int count = 0;\\n        if(intervals.length == 0 || intervals[0].length == 0)\\n            return count;\\n        Arrays.sort(intervals,(a,b)->a[1]-b[1]);//sort based on end val\\n        int prevEnd = intervals[0][1];\\n        for(int i = 1;i<intervals.length;i++){\\n            if(intervals[i][0] < prevEnd){ //if current start is less than prev end it means it overlaps\\n                count++;   // and need to remove then increament the count\\n            }else{ //if it does not overlap update the prevEnd with current interval end\\n                prevEnd = intervals[i][1]; //intervals[i][1] -- end n intervals[i][0] -- start\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804368,
                "title": "c-dynamic-programming-solution-o-n-log-n-sorting-binary-search",
                "content": "I know there is a greedy solution here, which is okay - what I want is sharing another dynamic programming solution.\\nIt has the same time complexity in terms of big O notation - O(NlogN), moreover, someone may find it easier to understand and proof.\\n\\nFirstly, we sort the intervals by y coordinate as the greedy solution does, then we process sorted array from left to the right.\\nConsidering the i-th interval, we have a choice:\\n1) Include this interval into the final result and delete preceding intersecting with this ones.\\n2) Delete this interval, keeping the already taken intervals.\\n\\nWe declare DP array which preserves the number of intervals we need to delete to keep intervals arr[0]...arr[i] non-intersecting.\\n\\n`dp[0] = 0` since 1 interval can\\'t intersect.\\n`dp[i] = min(`\\n`dp[first_del - 1] + amount_to_del` - option 1  from above explanation.\\n`dp[i-1]+1` - option 2 from above explanation\\n`)`\\n\\nLet me elaborate on the first option.\\nThe current i-th interval may intersect with some preceding ones in the intervals array.\\nIn that case, we can\\'t simply include it to the result - we need to delete intersecting ones.\\nWe look for the first interval j from the range(0, i) where intervals[j].y > intervals[i].x - this is the first that intersects with intervals[i] and need to be deleted. Apart from it, we need to delete all the intervals j+1, ... i-1.\\nThat amount is `amount_to_del`.\\n`first_del` in the below src reflects the index in the array starting from we need to delete to ensure non-intersection property,\\n\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& arr) {\\n        if (arr.empty()) return 0;\\n        sort(arr.begin(), arr.end(), [](auto& v1, auto& v2){ \\n            return v1[1] < v2[1];\\n        });\\n        \\n        vector<int> dp(arr.size());\\n        for (int i = 1; i < arr.size(); ++i) {\\n            int first_del = lower_bound(arr.begin(), arr.begin()+i, arr[i][0], \\n                [](auto& v, auto& xi) { return v[1] <= xi; }) - arr.begin();\\n            int del_count = i-first_del;\\n            dp[i] = min(dp[i-1]+1, (first_del ? dp[first_del-1] : 0) + del_count);\\n        }\\n        return dp.back();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& arr) {\\n        if (arr.empty()) return 0;\\n        sort(arr.begin(), arr.end(), [](auto& v1, auto& v2){ \\n            return v1[1] < v2[1];\\n        });\\n        \\n        vector<int> dp(arr.size());\\n        for (int i = 1; i < arr.size(); ++i) {\\n            int first_del = lower_bound(arr.begin(), arr.begin()+i, arr[i][0], \\n                [](auto& v, auto& xi) { return v[1] <= xi; }) - arr.begin();\\n            int del_count = i-first_del;\\n            dp[i] = min(dp[i-1]+1, (first_del ? dp[first_del-1] : 0) + del_count);\\n        }\\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793720,
                "title": "python-easy-and-simple-solution-greedy",
                "content": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda a:a[1])\\n        print(intervals)\\n        count = 0\\n        prev = 0\\n        for i in range(1, len(intervals)):\\n            if intervals[prev][1] > intervals[i][0]:\\n                count += 1\\n            else:\\n                prev = i\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda a:a[1])\\n        print(intervals)\\n        count = 0\\n        prev = 0\\n        for i in range(1, len(intervals)):\\n            if intervals[prev][1] > intervals[i][0]:\\n                count += 1\\n            else:\\n                prev = i\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 792788,
                "title": "c-very-easy-4-liner-explained-o-n-logn-o-1",
                "content": "The idea is to sort the intervals by their end. In such a way, we know which interval ends first so any interval which comes after (and overlaps) could also overlap other intervals, so we remove it. If the next interval doesn\\'t overlap, then we update our end. 2 intervals overlap if the end of the former (interval[k][1]) is bigger than the start of the latter (interval[k+1][0]), so we only keep the end of the intervals (I will keep it in \\'r\\')\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int ans = 0, r = INT_MIN;                                                          // Initially we create a dummy interval with end INT_MIN\\n        sort(intervals.begin(), intervals.end(), [](auto x, auto y){return x[1] < y[1];}); // With a lambda function we sort the intervals by their end (interval[1]).\\n        for(auto x: intervals) x[0] >= r ? r = x[1] : ans++;                               // If the start of the current interval is bigger or equal than the end of our last one, we update our end, else we have an overlap so we update our answer.\\n        return ans;                                                                        // return answer\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int ans = 0, r = INT_MIN;                                                          // Initially we create a dummy interval with end INT_MIN\\n        sort(intervals.begin(), intervals.end(), [](auto x, auto y){return x[1] < y[1];}",
                "codeTag": "Java"
            },
            {
                "id": 792725,
                "title": "non-overlapping-intervals-java-o-nlog-n-greedy",
                "content": "1. Sort the array by intervals end time.\\n2. Traverse intervals and store the current end time till now .\\n   i. If you find any interval with start time < current endtime. Remove it\\n   ii.Else set current end time to interval\\'s end time.\\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        if(intervals.length<=1)return 0;\\n        Arrays.sort(intervals, (a,b)->{\\n            if(a[1]==b[1])return a[0]<b[0]?-1:1;\\n            return a[1]<b[1]?-1:1;\\n        });\\n        int count=0,end=intervals[0][1];\\n        for(int i=1;i<intervals.length;i++){\\n            if(intervals[i][0]<end)count++;\\n            else{\\n                end=intervals[i][1];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        if(intervals.length<=1)return 0;\\n        Arrays.sort(intervals, (a,b)->{\\n            if(a[1]==b[1])return a[0]<b[0]?-1:1;\\n            return a[1]<b[1]?-1:1;\\n        });\\n        int count=0,end=intervals[0][1];\\n        for(int i=1;i<intervals.length;i++){\\n            if(intervals[i][0]<end)count++;\\n            else{\\n                end=intervals[i][1];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 665753,
                "title": "python-3-easy-understanding",
                "content": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x:x[1])\\n        i=1\\n        cnt=0\\n        while i<len(intervals) :\\n            if intervals[i][0]<intervals[i-1][1] :\\n                intervals.pop(i)\\n                cnt+=1\\n            else :\\n                i+=1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x:x[1])\\n        i=1\\n        cnt=0\\n        while i<len(intervals) :\\n            if intervals[i][0]<intervals[i-1][1] :\\n                intervals.pop(i)\\n                cnt+=1\\n            else :\\n                i+=1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 256092,
                "title": "python-100-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def eraseOverlapIntervals(self, intervals):\\n        \"\"\"\\n        :type intervals: List[Interval]\\n        :rtype: int\\n        \"\"\"\\n        intervals = sorted(intervals, key=lambda x:x.start)\\n        if len(intervals) < 2:\\n            return 0\\n        end_point = intervals[0].end\\n        remove = 0\\n        for i in range(1,len(intervals)):\\n            if end_point > intervals[i].start:\\n                remove += 1\\n                end_point = min(intervals[i].end,end_point)\\n            else:\\n                end_point = intervals[i].end\\n        return remove\\n",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution(object):\\n    def eraseOverlapIntervals(self, intervals):\\n        \"\"\"\\n        :type intervals: List[Interval]\\n        :rtype: int\\n        \"\"\"\\n        intervals = sorted(intervals, key=lambda x:x.start)\\n        if len(intervals) < 2:\\n            return 0\\n        end_point = intervals[0].end\\n        remove = 0\\n        for i in range(1,len(intervals)):\\n            if end_point > intervals[i].start:\\n                remove += 1\\n                end_point = min(intervals[i].end,end_point)\\n            else:\\n                end_point = intervals[i].end\\n        return remove\\n",
                "codeTag": "Java"
            },
            {
                "id": 91703,
                "title": "simplest-greedy-approach-so-far",
                "content": "Steps:\\n1. Sort intervals by end\\n2. fix end to be end of first interval and until start of next interval is smaller than this end, keep incrementing the count which means remove all those intervals\\n3. once an interval is found with start >= end (end fixed above), update the end with end of this interval\\n\\n```\\nclass Solution(object):\\n    def eraseOverlapIntervals(self, intervals):\\n        \"\"\"\\n        :type intervals: List[Interval]\\n        :rtype: int\\n        \"\"\"\\n        if not intervals: \\n            return 0\\n        intervals = sorted(intervals, key=lambda x: (x.end,x.start))\\n        end = intervals[0].end\\n        j = 1\\n        cnt = 0\\n        \\n        while(j < len(intervals)):\\n            if intervals[j].start < end:\\n                cnt += 1 \\n            else:\\n                end = intervals[j].end\\n            j += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def eraseOverlapIntervals(self, intervals):\\n        \"\"\"\\n        :type intervals: List[Interval]\\n        :rtype: int\\n        \"\"\"\\n        if not intervals: \\n            return 0\\n        intervals = sorted(intervals, key=lambda x: (x.end,x.start))\\n        end = intervals[0].end\\n        j = 1\\n        cnt = 0\\n        \\n        while(j < len(intervals)):\\n            if intervals[j].start < end:\\n                cnt += 1 \\n            else:\\n                end = intervals[j].end\\n            j += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91786,
                "title": "java-o-nlogn-very-easy-solution",
                "content": "1. Sort Intervals by end.\\n2. Count valid intervals (non-overlapping).\\n3. Answer is len - count\\n\\n\\n    public int eraseOverlapIntervals(Interval[] intervals) {\\n        if (intervals == null || intervals.length == 0) return 0;\\n        \\n        Arrays.sort(intervals, new Comparator<Interval>() {\\n            public int compare(Interval o1, Interval o2) {\\n                return o1.end - o2.end;\\n            }\\n        });\\n        \\n        int count = 1;\\n        int last = 0;\\n        for (int i = 1; i < intervals.length; i++) {\\n            if (intervals[last].end <= intervals[i].start) {\\n                count++;\\n                last = i;\\n            }\\n        }\\n        return intervals.length - count;\\n        \\n    }",
                "solutionTags": [],
                "code": "1. Sort Intervals by end.\\n2. Count valid intervals (non-overlapping).\\n3. Answer is len - count\\n\\n\\n    public int eraseOverlapIntervals(Interval[] intervals) {\\n        if (intervals == null || intervals.length == 0) return 0;\\n        \\n        Arrays.sort(intervals, new Comparator<Interval>() {\\n            public int compare(Interval o1, Interval o2) {\\n                return o1.end - o2.end;\\n            }\\n        });\\n        \\n        int count = 1;\\n        int last = 0;\\n        for (int i = 1; i < intervals.length; i++) {\\n            if (intervals[last].end <= intervals[i].start) {\\n                count++;\\n                last = i;\\n            }\\n        }\\n        return intervals.length - count;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3789377,
                "title": "greedy-solution-easily-understandable-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        // sort the array based on starting intervval\\n        <!-- lambda function to sort 2d array based on column 0 -->\\n        Arrays.sort(intervals, (a,b)->Integer.compare(a[0],b[0]));\\n\\n        int count =0;\\n        int left = 0, right =1;\\n        int n = intervals.length;\\n\\n        while(right<n)\\n        {\\n            /* if no overlaping\\n            --------\\n                    --------*/\\n            if(intervals[left][1] <= intervals[right][0] )\\n            {\\n                left = right;\\n                right++;\\n            }\\n            else if(intervals[left][1] <= intervals[right][1] )\\n            {\\n                // collsiion hua\\n                // ------\\n                //     ------\\n                // if left is smaller wrt x, take out y, \\n                right++;\\n                // take out that , so incrase ans\\n                count++;\\n            }\\n            else if( intervals[left][1] > intervals[right][1])\\n            {\\n                // ------------------\\n                //      -------\\n                // take out the left , since its big\\n                left = right;\\n                right++;\\n                count++;\\n            }\\n\\n\\n        }\\n        return count;\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        // sort the array based on starting intervval\\n        <!-- lambda function to sort 2d array based on column 0 -->\\n        Arrays.sort(intervals, (a,b)->Integer.compare(a[0],b[0]));\\n\\n        int count =0;\\n        int left = 0, right =1;\\n        int n = intervals.length;\\n\\n        while(right<n)\\n        {\\n            /* if no overlaping\\n            --------\\n                    --------*/\\n            if(intervals[left][1] <= intervals[right][0] )\\n            {\\n                left = right;\\n                right++;\\n            }\\n            else if(intervals[left][1] <= intervals[right][1] )\\n            {\\n                // collsiion hua\\n                // ------\\n                //     ------\\n                // if left is smaller wrt x, take out y, \\n                right++;\\n                // take out that , so incrase ans\\n                count++;\\n            }\\n            else if( intervals[left][1] > intervals[right][1])\\n            {\\n                // ------------------\\n                //      -------\\n                // take out the left , since its big\\n                left = right;\\n                right++;\\n                count++;\\n            }\\n\\n\\n        }\\n        return count;\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785802,
                "title": "easy-code-with-explanation-beats-95",
                "content": "# Algorithm : \\n- #### *First of all we need to sort the array based on the endtime of the interval.*\\n- #### *Now just traverse on the intervals. Intitially declare a variable named k and initialize it to lowest minimum value possible.*\\n- #### *Declare another variable called \" ans \" to store the count of overlapping intervals.*\\n- #### *if the starttime of an interval is greater than k update the k value to the endtime of that interval else you can increment the value of ans.*\\n- #### *Finally return the ans.*  \\n\\n# Python Code\\n```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        ans = 0\\n        k = float(\\'-inf\\')\\n        intervals.sort(key = lambda x : x[1])\\n        for i in range(len(intervals)):\\n            if intervals[i][0] >= k:\\n                k = intervals[i][1]\\n            else:\\n                ans += 1\\n        return ans\\n\\n```\\n---\\n### *Please don\\'t forget to upvote if you\\'ve liked my explantion.* \\u2B06\\uFE0F\\n---",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        ans = 0\\n        k = float(\\'-inf\\')\\n        intervals.sort(key = lambda x : x[1])\\n        for i in range(len(intervals)):\\n            if intervals[i][0] >= k:\\n                k = intervals[i][1]\\n            else:\\n                ans += 1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785285,
                "title": "simple-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        cnt = 0\\n        inn = sorted(intervals, key=lambda x: x[0], reverse=True)\\n        ans = [inn[0]]\\n        for s, e in inn[1:]:\\n            if ans[-1][0] >= e: \\n                ans.append([s, e])\\n            else: \\n                cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        cnt = 0\\n        inn = sorted(intervals, key=lambda x: x[0], reverse=True)\\n        ans = [inn[0]]\\n        for s, e in inn[1:]:\\n            if ans[-1][0] >= e: \\n                ans.append([s, e])\\n            else: \\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785248,
                "title": "c-python-using-sorting-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSorting: The first step in the code is to sort the intervals based on their start times. By sorting the intervals in ascending order of start times, we ensure that we process intervals from left to right on the number line.\\n\\nOverlapping Interval Handling: As we iterate through the sorted intervals, we check if the current interval overlaps with the previous interval. If there is an overlap, we decide to remove one of the intervals to make them non-overlapping. The greedy choice is to remove the interval that ends later (i.e., has a larger end time) because removing an interval with a larger end time allows more space for other intervals to fit.\\n\\nGreedy Decision: The greedy decision is made based on comparing the start and end times of the current interval with the previous interval. Depending on the overlap situation, we either increment the count of overlapping intervals (num) or update the previous interval (prev) to a new non-overlapping interval.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(n\\\\log (n))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n       // for(auto ab: intervals)\\n        //    cout<<ab[0]<<\",\"<<ab[1]<<endl;\\n\\n        vector<int> prev=intervals[0];\\n        int num=-1;\\n        for(vector<int>& A: intervals){\\n            if (A[0]<prev[1] && A[1]<=prev[1]){\\n                num++;\\n                prev=A;\\n            }\\n            else if(A[0]<prev[1] && A[1]>prev[1])\\n                num++;\\n            else \\n                prev=A;\\n        }\\n        return num;      \\n    }\\n};\\n```\\n# Python Solution\\n```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()\\n        prev=intervals[0]\\n        num=-1\\n        for A in intervals:\\n            if A[0]<prev[1] and A[1]<=prev[1]:\\n                num+=1\\n                prev=A\\n            elif A[0]<prev[1] and A[1]>prev[1]:\\n                num+=1\\n            else:\\n                prev=A\\n        return num\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n       // for(auto ab: intervals)\\n        //    cout<<ab[0]<<\",\"<<ab[1]<<endl;\\n\\n        vector<int> prev=intervals[0];\\n        int num=-1;\\n        for(vector<int>& A: intervals){\\n            if (A[0]<prev[1] && A[1]<=prev[1]){\\n                num++;\\n                prev=A;\\n            }\\n            else if(A[0]<prev[1] && A[1]>prev[1])\\n                num++;\\n            else \\n                prev=A;\\n        }\\n        return num;      \\n    }\\n};\\n```\n```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()\\n        prev=intervals[0]\\n        num=-1\\n        for A in intervals:\\n            if A[0]<prev[1] and A[1]<=prev[1]:\\n                num+=1\\n                prev=A\\n            elif A[0]<prev[1] and A[1]>prev[1]:\\n                num+=1\\n            else:\\n                prev=A\\n        return num\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3560894,
                "title": "c-clean-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int result = 0;\\n\\n        sort(intervals.begin(), intervals.end(), [](const auto& a, const auto& b) {\\n            return a[0] < b[0];\\n        }); \\n\\n        for (int i = 0; i < intervals.size()-1; i++) {\\n            // no overlap\\n            if (intervals[i][1] <= intervals[i+1][0]) continue;\\n            // overlap\\n            intervals[i+1][0] = intervals[i][0];\\n            intervals[i+1][1] = min(intervals[i][1], intervals[i+1][1]);\\n            result++;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int result = 0;\\n\\n        sort(intervals.begin(), intervals.end(), [](const auto& a, const auto& b) {\\n            return a[0] < b[0];\\n        }); \\n\\n        for (int i = 0; i < intervals.size()-1; i++) {\\n            // no overlap\\n            if (intervals[i][1] <= intervals[i+1][0]) continue;\\n            // overlap\\n            intervals[i+1][0] = intervals[i][0];\\n            intervals[i+1][1] = min(intervals[i][1], intervals[i+1][1]);\\n            result++;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478767,
                "title": "with-proper-explanation",
                "content": "# Intuition & Approach\\n    First of all, we formulate our problem as finding out sequece of  \\n    longest non overlapping intervals \\n    Then subtract the result of above problem from the total no. of \\n    intervals\\n    IDEA : sort the intervals vector in increasing order of finishing \\n           time then three types of interval we encounter :\\n    Type 1 - \\n            last_choosen interval         <------------>  \\n            current interval                <------>\\n            Here, replace the last_choosen interval by current interval\\n            since the current interval leaves more time for rest of \\n            intervals.\\n\\n    Type 2 - \\n            last_choosen interval         <------------>  \\n            current interval           <---------->\\n            Avoid current interval since the current interval doesn\\'t  \\n            leave more time for rest of intervals.\\n    Type 3 - \\n            last_choosen interval         <------------>  \\n            current interval     <------>\\n            current interval is compatible with last choosen interval\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N log N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nHope you liked it \\u2764\\uFE0F\\nPlease upvote \\n\\n# Code\\n```\\nclass Solution {\\n    // TC : O(N log N)\\n    // SC : O(1)\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        auto comp = [](vector<int>&a , vector<int>& b){\\n            return a[1]<b[1] || (a[1]==b[1] && a[0]<b[0]);\\n        };\\n        sort(intervals.begin(),intervals.end(),comp);\\n        int n = intervals.size();\\n        int last_choosen=n-1;\\n        int len = 1;\\n        for(int i=n-2;i>=0;i--){\\n            // Type 2 Interval : \\n            if(intervals[i][1]>intervals[last_choosen][0] \\n                && intervals[i][0] <= intervals[last_choosen][0]){\\n                    continue;\\n                }\\n            // Type 1 Interval :\\n            else if(intervals[i][1]<=intervals[last_choosen][1] \\n                && intervals[i][0] > intervals[last_choosen][0]){\\n                    last_choosen = i;\\n                }\\n            // Type 3 Interval\\n            else{\\n                last_choosen = i;\\n                len++;\\n            }\\n        }\\n        return n-len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    // TC : O(N log N)\\n    // SC : O(1)\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        auto comp = [](vector<int>&a , vector<int>& b){\\n            return a[1]<b[1] || (a[1]==b[1] && a[0]<b[0]);\\n        };\\n        sort(intervals.begin(),intervals.end(),comp);\\n        int n = intervals.size();\\n        int last_choosen=n-1;\\n        int len = 1;\\n        for(int i=n-2;i>=0;i--){\\n            // Type 2 Interval : \\n            if(intervals[i][1]>intervals[last_choosen][0] \\n                && intervals[i][0] <= intervals[last_choosen][0]){\\n                    continue;\\n                }\\n            // Type 1 Interval :\\n            else if(intervals[i][1]<=intervals[last_choosen][1] \\n                && intervals[i][0] > intervals[last_choosen][0]){\\n                    last_choosen = i;\\n                }\\n            // Type 3 Interval\\n            else{\\n                last_choosen = i;\\n                len++;\\n            }\\n        }\\n        return n-len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325988,
                "title": "simple-c-greedy-solution-with-sort-and-for-loop",
                "content": "# Intuition\\nWhen there are overlapping intervals, we always want to keep the intervals with the smallest end point so that there is maximum space left for the rest of the intervals.\\n\\n# Approach\\nSort the intervals based on the end time. Then greedily removed the overlapping intervals with bigger end time.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int>& a, vector<int>& b){\\n            return a[1] < b[1];\\n        });\\n\\n        int removed = 0, prev = intervals[0][1];\\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (prev > intervals[i][0]) {\\n                removed++;\\n            } else {\\n                prev = intervals[i][1];\\n            }\\n        }\\n        return removed;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int>& a, vector<int>& b){\\n            return a[1] < b[1];\\n        });\\n\\n        int removed = 0, prev = intervals[0][1];\\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (prev > intervals[i][0]) {\\n                removed++;\\n            } else {\\n                prev = intervals[i][1];\\n            }\\n        }\\n        return removed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000789,
                "title": "python3-solution-beats-98-74-greedy-approach-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x: x[1])\\n        countDeleted, currEnd = 0, intervals[0][1]\\n        for start, end in intervals[1:]:\\n            if (start >= currEnd):\\n                currEnd = end\\n            else:\\n                countDeleted += 1\\n        return countDeleted\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x: x[1])\\n        countDeleted, currEnd = 0, intervals[0][1]\\n        for start, end in intervals[1:]:\\n            if (start >= currEnd):\\n                currEnd = end\\n            else:\\n                countDeleted += 1\\n        return countDeleted\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961511,
                "title": "easy-to-understand-o-nlogn-approach-using-sort",
                "content": "Think of it as the **Maximum Number of Events That Can Be Attended(1353)** question. If we know max number of intervals that are not overlapping then the answer is simply the difference between those that are not overlapping to the total\\n\\n\\n```\\nint eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n    auto comp = [](vector<int> &a, vector<int> &b){return a[0]<b[0];};\\n    sort(intervals.begin(), intervals.end(), comp);\\n    int last = INT_MIN, item=0;\\n    for (int i=0; i<intervals.size(); ++i) {\\n        if (intervals[i][0]>=last) {\\n            last = intervals[i][1];\\n            item++;\\n        }\\n        else last = min(last, intervals[i][1]);\\n    }\\n    return intervals.size() - item;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n    auto comp = [](vector<int> &a, vector<int> &b){return a[0]<b[0];};\\n    sort(intervals.begin(), intervals.end(), comp);\\n    int last = INT_MIN, item=0;\\n    for (int i=0; i<intervals.size(); ++i) {\\n        if (intervals[i][0]>=last) {\\n            last = intervals[i][1];\\n            item++;\\n        }\\n        else last = min(last, intervals[i][1]);\\n    }\\n    return intervals.size() - item;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2827009,
                "title": "c-simple-solution-3-clean-cases-only-explanation",
                "content": "```\\n// class interval{\\n// public:   \\n//     int first;\\n//     int second;\\n// }\\n\\n// CASE 1 :- i.second < j.first [Non-Overlapping intervals, take both intervals]\\n// ------------------   -----------------\\n// |   Interval i   |   |   Interval j  |\\n// ------------------   -----------------\\n\\n\\n// CASE 2 :- i.second <= j.second [Overlapping intervals, take interval \"i\"  and greedly remove right interval \"j\"]\\n// ------------------\\n// |   Interval i   |\\n// ------------------\\n//            ------------------\\n//            |    Interval j  |\\n//            ------------------\\n\\n\\n// CASE 3 :- i.second > j.second [Overlapping intervals, take interval \"j\" and greedly remove left interval \"i\"]\\n//  --------------------\\n//  |    Interval i    |\\n//  --------------------\\n//     --------------\\n//     | Interval j |\\n//     --------------\\n\\n\\n// Best Solution\\nclass Solution {\\npublic:\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>&v) \\n    {\\n        int n=v.size();\\n        sort(v.begin(), v.end()); // sort on the basis of start points\\n        int count=0;\\n        int i=0, j=1;\\n        \\n        while(j<n)\\n        {\\n            if(v[i][1] <= v[j][0]) // Non-overlapping case(Case 1)\\n            {\\n                i=j;\\n                j++;\\n            }\\n            else if(v[i][1] <= v[j][1])  // Case 2\\n            {\\n                count++;\\n                j++;\\n            }\\n            else if(v[i][1] > v[j][1])   // Case 3\\n            {\\n                count++;\\n                i = j;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n***Thanks for Upvoting !***\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n// class interval{\\n// public:   \\n//     int first;\\n//     int second;\\n// }\\n\\n// CASE 1 :- i.second < j.first [Non-Overlapping intervals, take both intervals]\\n// ------------------   -----------------\\n// |   Interval i   |   |   Interval j  |\\n// ------------------   -----------------\\n\\n\\n// CASE 2 :- i.second <= j.second [Overlapping intervals, take interval \"i\"  and greedly remove right interval \"j\"]\\n// ------------------\\n// |   Interval i   |\\n// ------------------\\n//            ------------------\\n//            |    Interval j  |\\n//            ------------------\\n\\n\\n// CASE 3 :- i.second > j.second [Overlapping intervals, take interval \"j\" and greedly remove left interval \"i\"]\\n//  --------------------\\n//  |    Interval i    |\\n//  --------------------\\n//     --------------\\n//     | Interval j |\\n//     --------------\\n\\n\\n// Best Solution\\nclass Solution {\\npublic:\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>&v) \\n    {\\n        int n=v.size();\\n        sort(v.begin(), v.end()); // sort on the basis of start points\\n        int count=0;\\n        int i=0, j=1;\\n        \\n        while(j<n)\\n        {\\n            if(v[i][1] <= v[j][0]) // Non-overlapping case(Case 1)\\n            {\\n                i=j;\\n                j++;\\n            }\\n            else if(v[i][1] <= v[j][1])  // Case 2\\n            {\\n                count++;\\n                j++;\\n            }\\n            else if(v[i][1] > v[j][1])   // Case 3\\n            {\\n                count++;\\n                i = j;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761778,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nbool comp(vector<int> &a,vector<int> &b) {\\n\\treturn a[1]<b[1];\\n}\\nclass Solution {\\npublic:\\n\\tint eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n\\t\\tint ans=-1;      \\n\\t\\tif(intervals.size()==0) return 0;       \\n\\t\\tsort(intervals.begin(),intervals.end(),comp);      \\n\\t\\tvector<int> prev= intervals[0];\\n\\n\\t\\tfor(vector<int> i: intervals) {\\n\\t\\t\\tif(prev[1]>i[0]) {\\n\\t\\t\\t\\tans++;                \\n\\t\\t\\t}else prev=i;         \\n\\t\\t}\\n\\t\\treturn ans;                \\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool comp(vector<int> &a,vector<int> &b) {\\n\\treturn a[1]<b[1];\\n}\\nclass Solution {\\npublic:\\n\\tint eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n\\t\\tint ans=-1;      \\n\\t\\tif(intervals.size()==0) return 0;       \\n\\t\\tsort(intervals.begin(),intervals.end(),comp);      \\n\\t\\tvector<int> prev= intervals[0];\\n\\n\\t\\tfor(vector<int> i: intervals) {\\n\\t\\t\\tif(prev[1]>i[0]) {\\n\\t\\t\\t\\tans++;                \\n\\t\\t\\t}else prev=i;         \\n\\t\\t}\\n\\t\\treturn ans;                \\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700263,
                "title": "c-sort-based-on-start-time-simple-elegant-readable",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals)\\n    {\\n        int res = 0;\\n        sort(intervals.begin(), intervals.end());\\n        \\n        int start = 0, end=1;\\n        int rBorderOfSelectedInterval = intervals[0][end];\\n        for(int i=1; i<intervals.size(); i++)\\n        {\\n            if(intervals[i][start] < rBorderOfSelectedInterval) // overalap\\n            {\\n                res++; // remove interval with max endTime so most num of collisions can be avoided\\n                rBorderOfSelectedInterval = min(rBorderOfSelectedInterval, intervals[i][end]);\\n            }\\n            else\\n            {   // no collision, update endTime\\n                rBorderOfSelectedInterval = intervals[i][end];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals)\\n    {\\n        int res = 0;\\n        sort(intervals.begin(), intervals.end());\\n        \\n        int start = 0, end=1;\\n        int rBorderOfSelectedInterval = intervals[0][end];\\n        for(int i=1; i<intervals.size(); i++)\\n        {\\n            if(intervals[i][start] < rBorderOfSelectedInterval) // overalap\\n            {\\n                res++; // remove interval with max endTime so most num of collisions can be avoided\\n                rBorderOfSelectedInterval = min(rBorderOfSelectedInterval, intervals[i][end]);\\n            }\\n            else\\n            {   // no collision, update endTime\\n                rBorderOfSelectedInterval = intervals[i][end];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626258,
                "title": "python-recursive-approach",
                "content": "We start by sorting the array of intervals, by ascending order of their lower boundaries. Since we\\'re going to work recursively and make multiple calls, we don\\'t want te be sorting the array every time, so we introduce `self.hasBeenSorted` to account for the sorting.\\n\\n**Base case**: if `intervals` has a length of 1, we can be certain that there are no overlapping intervals and can therefore return `0` straight away.\\n\\n**Recursive principle**: we look at the first two elements in `intervals`:\\n* *If they don\\'t overlap*, since `intervals` is sorted, we know for sure that `interval[0]` doesn\\'t overlap with any of the following intervals either. Therefore, it won\\'t have to be removed, meaning **its presence doesn\\'t affect the final result**: the answer (number of intervals to remove) would be the same if the first element wasn\\'t here at all. We can hence recursively call the function on `intervals[:1]` and return the result.\\n* *If they do overlap*, we have a conflict. We know for sure that we\\'ll have to remove at least one of the two conflicting intervals, before recursively calling the function on the modified array `intervals`. Which one should we remove? We\\'re looking for the minimum number of steps before reaching an array of non-overlapping intervals, so we should remove the element which is most susceptible to create further collisions, i.e. the one whose upper boundary is highest. We then return 1 + the result of the recursive call on intervals (which we\\'ve modified by removing 1 element).\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.hasBeenSorted = False\\n    \\n    def eraseOverlapIntervals(self, intervals):\\n        \\n        if not self.hasBeenSorted:\\n            intervals.sort()\\n            self.hasBeenSorted = True\\n        \\n        #Base case\\n\\t\\tif len(intervals) == 1:\\n            return 0\\n\\n        #First element doesn\\'t overlap: it doesn\\'t impact the final result\\n        if intervals[0][1] <= intervals[1][0]:\\n            return self.eraseOverlapIntervals(intervals[1:])\\n        \\n        #First element overlaps: either we remove it, or we remove the next one\\n\\t\\tif intervals[1][1] > intervals[0][1]:\\n\\t\\t\\tintervals.pop(1)\\n\\t\\telse:\\n\\t\\t\\tintervals.pop(0)\\n\\t\\treturn 1 + self.eraseOverlapIntervals(intervals)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.hasBeenSorted = False\\n    \\n    def eraseOverlapIntervals(self, intervals):\\n        \\n        if not self.hasBeenSorted:\\n            intervals.sort()\\n            self.hasBeenSorted = True\\n        \\n        #Base case\\n\\t\\tif len(intervals) == 1:\\n            return 0\\n\\n        #First element doesn\\'t overlap: it doesn\\'t impact the final result\\n        if intervals[0][1] <= intervals[1][0]:\\n            return self.eraseOverlapIntervals(intervals[1:])\\n        \\n        #First element overlaps: either we remove it, or we remove the next one\\n\\t\\tif intervals[1][1] > intervals[0][1]:\\n\\t\\t\\tintervals.pop(1)\\n\\t\\telse:\\n\\t\\t\\tintervals.pop(0)\\n\\t\\treturn 1 + self.eraseOverlapIntervals(intervals)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551535,
                "title": "python-dp-o-n-log-n-not-greedy-and-not-n-2-like-the-solution-given-from-leetcode",
                "content": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()\\n        dp = [0]*len(intervals)\\n        dp[-1] = 1\\n        for i in reversed(range(len(dp)-1)):\\n            indx = bisect_left(intervals,[intervals[i][1],-inf],i,len(dp))\\n            if indx<len(dp):\\n                dp[i] = max(dp[i+1],dp[indx]+1)\\n            else:\\n                dp[i] = max(dp[i+1],1)\\n        return len(intervals)-max(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()\\n        dp = [0]*len(intervals)\\n        dp[-1] = 1\\n        for i in reversed(range(len(dp)-1)):\\n            indx = bisect_left(intervals,[intervals[i][1],-inf],i,len(dp))\\n            if indx<len(dp):\\n                dp[i] = max(dp[i+1],dp[indx]+1)\\n            else:\\n                dp[i] = max(dp[i+1],1)\\n        return len(intervals)-max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477984,
                "title": "best-easiest-solution-in-c-no-dp",
                "content": "## **Please Upvote if u liked my Solution\\uD83D\\uDE42**\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int n = intervals.size(), tmp = intervals[0][1], ans = 0;\\n        for(int i = 1; i < n; i++){\\n            if(tmp > intervals[i][0]){\\n                ans++;\\n                tmp = min(tmp,intervals[i][1]);\\n            }\\n            else\\n                tmp = intervals[i][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int n = intervals.size(), tmp = intervals[0][1], ans = 0;\\n        for(int i = 1; i < n; i++){\\n            if(tmp > intervals[i][0]){\\n                ans++;\\n                tmp = min(tmp,intervals[i][1]);\\n            }\\n            else\\n                tmp = intervals[i][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449628,
                "title": "easy-to-understand-python-solution-97-9-faster",
                "content": "\\n![image](https://assets.leetcode.com/users/images/56959c39-a443-452c-80c0-907ff5e17986_1660922659.1350303.png)\\n\\n\\n...\\nclass Solution:\\n\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x:x[1])  \\n        count = 1\\n        ps,pe = intervals[0]          #previous start and previous finish\\n        for s,e in intervals:\\n            if s<pe:\\n                continue\\n            else:\\n                ps,pe = s , e\\n                count+=1\\n        return len(intervals)-count    \\n\\t\\t...",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "\\n![image](https://assets.leetcode.com/users/images/56959c39-a443-452c-80c0-907ff5e17986_1660922659.1350303.png)\\n\\n\\n...\\nclass Solution:\\n\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x:x[1])  \\n        count = 1\\n        ps,pe = intervals[0]          #previous start and previous finish\\n        for s,e in intervals:\\n            if s<pe:\\n                continue\\n            else:\\n                ps,pe = s , e\\n                count+=1\\n        return len(intervals)-count    \\n\\t\\t...",
                "codeTag": "Java"
            },
            {
                "id": 2165660,
                "title": "c-greedy-solution-activity-selection",
                "content": "**Please do upvote if it helps!!**\\n```\\n  bool mycmp(vector<int>&v1,vector<int>&v2)\\n    {\\n        return v1[1]<v2[1];\\n    }\\nclass Solution {\\n  \\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n         if (intervals.size()==1) return 0;\\n        sort(intervals.begin(),intervals.end(),mycmp);\\n        int prevend=intervals[0][1];\\n        int count=0;\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<prevend)count++;\\n            else{\\n                prevend=intervals[i][1];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\n  bool mycmp(vector<int>&v1,vector<int>&v2)\\n    {\\n        return v1[1]<v2[1];\\n    }\\nclass Solution {\\n  \\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n         if (intervals.size()==1) return 0;\\n        sort(intervals.begin(),intervals.end(),mycmp);\\n        int prevend=intervals[0][1];\\n        int count=0;\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<prevend)count++;\\n            else{\\n                prevend=intervals[i][1];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2103971,
                "title": "runtime-524-ms-faster-than-99-57-o-nlogn-greedy",
                "content": "```\\n// same as busyman problem\\n// sort by the when work done and then check if new work start when old one end if yes then increase the ans\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& in) {\\n        int n = in.size();\\n        vector<pair<int, int>> a;\\n        for(int i=0; i<n; ++i){\\n            a.push_back({in[i][1], in[i][0]});\\n        }\\n        sort(a.begin(), a.end());\\n        int tm=a[0].first,ans=1;\\n        for(int i=1; i<n; ++i){\\n            if(a[i].second>=tm){\\n                ans++;\\n                tm=a[i].first;\\n            }\\n        }\\n        return n-ans;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n// same as busyman problem\\n// sort by the when work done and then check if new work start when old one end if yes then increase the ans\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& in) {\\n        int n = in.size();\\n        vector<pair<int, int>> a;\\n        for(int i=0; i<n; ++i){\\n            a.push_back({in[i][1], in[i][0]});\\n        }\\n        sort(a.begin(), a.end());\\n        int tm=a[0].first,ans=1;\\n        for(int i=1; i<n; ++i){\\n            if(a[i].second>=tm){\\n                ans++;\\n                tm=a[i].first;\\n            }\\n        }\\n        return n-ans;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894394,
                "title": "java-o-nlogn-with-comments",
                "content": "Always pick the interval with the earliest end time. Then you can get the maximal number of non-overlapping intervals. (or minimal number to remove).\\nThis is because, the interval with the earliest end time produces the maximal capacity to hold rest intervals.\\n```\\n    // if we choose the interval that ends earlier, then there is more space for other intervals\\n    public int eraseOverlapIntervals(int[][] arr) {\\n\\t   // sort the intervals in increasing order of their end times\\n        Arrays.sort(arr, (a, b) -> (a[1] == b[1]) ? a[0] - b[0] : a[1] - b[1]);\\n        int end = Integer.MIN_VALUE, cnt = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i][0] >= end)\\n                end = arr[i][1];\\n            else\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n```\\nDon\\'t forget to upvote if it helped!\\nKeep hustling!",
                "solutionTags": [],
                "code": "```\\n    // if we choose the interval that ends earlier, then there is more space for other intervals\\n    public int eraseOverlapIntervals(int[][] arr) {\\n\\t   // sort the intervals in increasing order of their end times\\n        Arrays.sort(arr, (a, b) -> (a[1] == b[1]) ? a[0] - b[0] : a[1] - b[1]);\\n        int end = Integer.MIN_VALUE, cnt = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i][0] >= end)\\n                end = arr[i][1];\\n            else\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1755438,
                "title": "greedy-approach-interval-scheduling-explained",
                "content": "```\\n- Interval Scheduling\\n        - Problem : Given a collection of intervals, find the maximum number of intervals that are non-overlapping.\\n        - Solution : -\\n            - Sort Booking based of finish time(ascending). Name it Set A.\\n            - Set B is one with all non overlapping intervals, initially empty.\\n            - While A is not empty\\n                - pick b from A having smallest finishing time\\n                - Add b to B.\\n                - Remove from A all bookings that overlap with A.\\n```\\n\\nInterval Scheduling Problem provides us with maximum non overlapping intervals. Use that to calculate minimum intervals to remove = arr_length - maximum_intervals\\n\\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        \\n        Arrays.sort(intervals,new Comparator<int[]>(){\\n            public int compare(int[] a,int[] b){\\n                return Integer.compare(a[1],b[1]);\\n            }\\n        });\\n        \\n        int end = intervals[0][1];\\n        int count = 1;\\n        \\n        for(int i = 1;i < intervals.length;i++){\\n            if(intervals[i][0] >= end){\\n                end = intervals[i][1];\\n                count += 1;\\n            }\\n        }\\n        \\n        int minIntervalsToRemove = intervals.length - count;\\n        \\n        return minIntervalsToRemove;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n- Interval Scheduling\\n        - Problem : Given a collection of intervals, find the maximum number of intervals that are non-overlapping.\\n        - Solution : -\\n            - Sort Booking based of finish time(ascending). Name it Set A.\\n            - Set B is one with all non overlapping intervals, initially empty.\\n            - While A is not empty\\n                - pick b from A having smallest finishing time\\n                - Add b to B.\\n                - Remove from A all bookings that overlap with A.\\n```\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        \\n        Arrays.sort(intervals,new Comparator<int[]>(){\\n            public int compare(int[] a,int[] b){\\n                return Integer.compare(a[1],b[1]);\\n            }\\n        });\\n        \\n        int end = intervals[0][1];\\n        int count = 1;\\n        \\n        for(int i = 1;i < intervals.length;i++){\\n            if(intervals[i][0] >= end){\\n                end = intervals[i][1];\\n                count += 1;\\n            }\\n        }\\n        \\n        int minIntervalsToRemove = intervals.length - count;\\n        \\n        return minIntervalsToRemove;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689830,
                "title": "c-sorting",
                "content": "```\\nbool helper(vector<int> &a, vector<int> &b)\\n{\\n    return a[1] < b[1];\\n}\\n\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        \\n        int n = intervals.size(), i = 1, j = 0, ans = 0;\\n        sort(intervals.begin(), intervals.end(), helper);\\n        while(i < n)\\n            intervals[j][1] > intervals[i][0] ? ans++ : j = i, i++;  \\n                     \\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool helper(vector<int> &a, vector<int> &b)\\n{\\n    return a[1] < b[1];\\n}\\n\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        \\n        int n = intervals.size(), i = 1, j = 0, ans = 0;\\n        sort(intervals.begin(), intervals.end(), helper);\\n        while(i < n)\\n            intervals[j][1] > intervals[i][0] ? ans++ : j = i, i++;  \\n                     \\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649010,
                "title": "simple-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n\\t\\t//if there are 0 or 1 element, no intervals are needed to be erased\\n        if(n <= 1) return 0;\\n\\t\\t//sort the intervals according to the start-elements\\n        sort(intervals.begin(),intervals.end());\\n\\t\\t//keep a track of the element that marks the end of the previous interval\\n        int previousEnd = intervals[0][1];\\n\\t\\t//this variable will store the answers\\n        int ans = 0;\\n        for(int i = 1 ; i < n ; i++){\\n\\t\\t//store current interval\\'s start and end points\\n            int currentStart = intervals[i][0];\\n            int currentEnd = intervals[i][1];\\n\\t\\t\\t//if we see that the end of the previous interval exceeds the current start, it means that the interval has overlapped\\n            if(previousEnd > currentStart){\\n                ans++;\\n\\t\\t\\t\\t//the new end of interval will be the minimum of the end of the current interval and the value of previousEnd\\n                previousEnd = min(previousEnd,currentEnd);\\n            }\\n            else{\\n\\t\\t\\t//if there is no overlapping then the end will be same as the end of the current interval\\n                previousEnd = currentEnd;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n\\t\\t//if there are 0 or 1 element, no intervals are needed to be erased\\n        if(n <= 1) return 0;\\n\\t\\t//sort the intervals according to the start-elements\\n        sort(intervals.begin(),intervals.end());\\n\\t\\t//keep a track of the element that marks the end of the previous interval\\n        int previousEnd = intervals[0][1];\\n\\t\\t//this variable will store the answers\\n        int ans = 0;\\n        for(int i = 1 ; i < n ; i++){\\n\\t\\t//store current interval\\'s start and end points\\n            int currentStart = intervals[i][0];\\n            int currentEnd = intervals[i][1];\\n\\t\\t\\t//if we see that the end of the previous interval exceeds the current start, it means that the interval has overlapped\\n            if(previousEnd > currentStart){\\n                ans++;\\n\\t\\t\\t\\t//the new end of interval will be the minimum of the end of the current interval and the value of previousEnd\\n                previousEnd = min(previousEnd,currentEnd);\\n            }\\n            else{\\n\\t\\t\\t//if there is no overlapping then the end will be same as the end of the current interval\\n                previousEnd = currentEnd;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552038,
                "title": "greedy-approach-c",
                "content": "class Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n     \\n        sort(intervals.begin(), intervals.end());\\n        int count = 0;\\n        int end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++)\\n        {\\n           if(intervals[i][0] < end)\\n           {\\n               count++;\\n               end = min(end, intervals[i][1]);\\n           }\\n            else\\n                end = intervals[i][1];\\n        }\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n     \\n        sort(intervals.begin(), intervals.end());\\n        int count = 0;\\n        int end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++)\\n        {\\n           if(intervals[i][0] < end)\\n           {\\n               count++;\\n               end = min(end, intervals[i][1]);\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1338089,
                "title": "python-dp-o-nlogn",
                "content": "There\\'s actually no reason your DP solution has to be `O(n^2)`. You can use binary search in dp just like you can for a greedy algorithm.\\nAlso, note that in this case I iterate from back to front because it allows me to compare my current interval\\'s endpoint to my next interval\\'s start point, which I find more intuitive, but you could just as easily reverse the logic if you prefer to iterate front to back.\\n```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        n = len(intervals)\\n        intervals.sort()\\n        dp = [math.inf] * (n+1)\\n        dp[n] = 0\\n        for i in reversed(range(n)):\\n            tgt = intervals[i][1]\\n            l, r = i+1, n\\n            while l < r:\\n                m = (l+r) // 2\\n                if intervals[m][0] < tgt:\\n                    # intervals[m] cant be used after this, go higher\\n                    l = m+1\\n                else:\\n                    r = m\\n            dp[i] = min(dp[i+1]+1, dp[l]+(l-i-1))\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        n = len(intervals)\\n        intervals.sort()\\n        dp = [math.inf] * (n+1)\\n        dp[n] = 0\\n        for i in reversed(range(n)):\\n            tgt = intervals[i][1]\\n            l, r = i+1, n\\n            while l < r:\\n                m = (l+r) // 2\\n                if intervals[m][0] < tgt:\\n                    # intervals[m] cant be used after this, go higher\\n                    l = m+1\\n                else:\\n                    r = m\\n            dp[i] = min(dp[i+1]+1, dp[l]+(l-i-1))\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283600,
                "title": "c-explained-greedy-dp",
                "content": "```\\n\\n/*\\n\\nHarshit Gupta | 19th June, 2021\\n---------------------------------\\n\\nC++ program for \"Non-overlapping Intervals\"\\nGiven an array of intervals intervals where intervals[i] = [starti, endi], \\n    return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\n\\nExample 1:\\n    Input: intervals = [[1,2],[2,3],[3,4],[1,3]]\\n    Output: 1\\n    Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.\\n\\nExample 2:\\n    Input: intervals = [[1,2],[1,2],[1,2]]\\n    Output: 2\\n    Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.\\n\\nExample 3:\\n    Input: intervals = [[1,2],[2,3]]\\n    Output: 0\\n    Explanation: You don\\'t need to remove any of the intervals since they\\'re already non-overlapping.\\n\\n------\\n\\nSolution: 1. Greedy\\n    2. DP\\n\\nParadigm:\\n---\\n  NOTE: \\n\\n*/\\n\\n\\n\\n/*\\n1. Sort the intervals on start time.\\n2. There can be only 3 cases in a prev interval and the next interval\\n    a. no overlap: we update the prev and nothing is removed\\n    b. total overlap: we choose the smaller one since it can accomodate more intervals now. We update prev and since we do not consider the other interval now, we update removedCount.\\n    c. partial overlap: we choose the prev over current and update the removeCount.\\n    \\n    TC: O(nlogn)\\n    SC: O(1)\\n*/\\n\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() <= 1)\\n            return 0;\\n        \\n        sort(intervals.begin(), intervals.end());\\n        \\n        int n= intervals.size(), prev=0, removeCount=0;\\n        \\n        for(int i=1;i<intervals.size(); i++){\\n            if(intervals[prev][1] > intervals[i][0]){ // overlapping\\n                if(intervals[prev][1] > intervals[i][1]){ // total overlap, move ahead & removeCount++\\n                    prev = i;   \\n                }\\n                removeCount++;    // partial overlap, only removeCount++; (no need to move ahead)\\n            }\\n            else { // no overlap, just move ahead, no change remove count\\n                prev = i;\\n            }\\n        }\\n        return removeCount;\\n    }\\n};\\n\\n/*\\n\\nSolution 1:\\n\\n1. Sort the intervals on start time.\\n2. Create a dp[] array such that dp[i] stores the maximum number of valid intervals that can be included in the final list if  the intervals upto the ith interval only are considered, including itself.\\n3. While finding dp[i+1], we cant consider the valud of dp[i] only because it could be possible that ith or any prev intercal could be overlapping with the i+1th interval.\\n4. We need o consider the max of all dp[j]s such that j<=i and jth interval and ith dont overlap and can basically be taken together in a sense.\\n5. dp[i+1] = max(dp[j]+1) j<=i\\n6. Result = interval.size() - dp[n-1] since those many intervals are not in the consecutive sets of intervals\\n\\nTC: O(n2)\\nSC: O(n)\\n\\n[1,3] [2,5] [4,5] [6,7] [6,8] [7,8]\\n\\n1--2--3--4--5--6--7--8--9\\n-----    ----  ---|---\\n   ----------  -------\\n\\nBy removing below 2,we can get intervals to be non-overlapping.\\n\\n     [1,3] [2,5] [4,5] [6,7] [6,8] [7,8]\\ndp[]   1     1     2     3     3     4\\n\\n\\n*/\\n\\nint eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n    if(intervals.size() <= 1)\\n        return 0;\\n\\n    sort(intervals.begin(), intervals.end());\\n\\n    int n= intervals.size();\\n    vector<int>dp(n,1);\\n\\n    for(int i=1; i<n; i++){\\n        for(int j=i-1; j>=0; j--){\\n            if(intervals[j][1] <= intervals[i][0]){ // non-overlapping\\n                dp[i] = max(dp[i], dp[j]+1);\\n            }\\n        }\\n    }\\n    return n-dp[n-1];\\n}\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n\\n/*\\n\\nHarshit Gupta | 19th June, 2021\\n---------------------------------\\n\\nC++ program for \"Non-overlapping Intervals\"\\nGiven an array of intervals intervals where intervals[i] = [starti, endi], \\n    return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\n\\nExample 1:\\n    Input: intervals = [[1,2],[2,3],[3,4],[1,3]]\\n    Output: 1\\n    Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.\\n\\nExample 2:\\n    Input: intervals = [[1,2],[1,2],[1,2]]\\n    Output: 2\\n    Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.\\n\\nExample 3:\\n    Input: intervals = [[1,2],[2,3]]\\n    Output: 0\\n    Explanation: You don\\'t need to remove any of the intervals since they\\'re already non-overlapping.\\n\\n------\\n\\nSolution: 1. Greedy\\n    2. DP\\n\\nParadigm:\\n---\\n  NOTE: \\n\\n*/\\n\\n\\n\\n/*\\n1. Sort the intervals on start time.\\n2. There can be only 3 cases in a prev interval and the next interval\\n    a. no overlap: we update the prev and nothing is removed\\n    b. total overlap: we choose the smaller one since it can accomodate more intervals now. We update prev and since we do not consider the other interval now, we update removedCount.\\n    c. partial overlap: we choose the prev over current and update the removeCount.\\n    \\n    TC: O(nlogn)\\n    SC: O(1)\\n*/\\n\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() <= 1)\\n            return 0;\\n        \\n        sort(intervals.begin(), intervals.end());\\n        \\n        int n= intervals.size(), prev=0, removeCount=0;\\n        \\n        for(int i=1;i<intervals.size(); i++){\\n            if(intervals[prev][1] > intervals[i][0]){ // overlapping\\n                if(intervals[prev][1] > intervals[i][1]){ // total overlap, move ahead & removeCount++\\n                    prev = i;   \\n                }\\n                removeCount++;    // partial overlap, only removeCount++; (no need to move ahead)\\n            }\\n            else { // no overlap, just move ahead, no change remove count\\n                prev = i;\\n            }\\n        }\\n        return removeCount;\\n    }\\n};\\n\\n/*\\n\\nSolution 1:\\n\\n1. Sort the intervals on start time.\\n2. Create a dp[] array such that dp[i] stores the maximum number of valid intervals that can be included in the final list if  the intervals upto the ith interval only are considered, including itself.\\n3. While finding dp[i+1], we cant consider the valud of dp[i] only because it could be possible that ith or any prev intercal could be overlapping with the i+1th interval.\\n4. We need o consider the max of all dp[j]s such that j<=i and jth interval and ith dont overlap and can basically be taken together in a sense.\\n5. dp[i+1] = max(dp[j]+1) j<=i\\n6. Result = interval.size() - dp[n-1] since those many intervals are not in the consecutive sets of intervals\\n\\nTC: O(n2)\\nSC: O(n)\\n\\n[1,3] [2,5] [4,5] [6,7] [6,8] [7,8]\\n\\n1--2--3--4--5--6--7--8--9\\n-----    ----  ---|---\\n   ----------  -------\\n\\nBy removing below 2,we can get intervals to be non-overlapping.\\n\\n     [1,3] [2,5] [4,5] [6,7] [6,8] [7,8]\\ndp[]   1     1     2     3     3     4\\n\\n\\n*/\\n\\nint eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n    if(intervals.size() <= 1)\\n        return 0;\\n\\n    sort(intervals.begin(), intervals.end());\\n\\n    int n= intervals.size();\\n    vector<int>dp(n,1);\\n\\n    for(int i=1; i<n; i++){\\n        for(int j=i-1; j>=0; j--){\\n            if(intervals[j][1] <= intervals[i][0]){ // non-overlapping\\n                dp[i] = max(dp[i], dp[j]+1);\\n            }\\n        }\\n    }\\n    return n-dp[n-1];\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166397,
                "title": "python-greedy-algorithm",
                "content": "Code below tries to find number of non-overlapping intervals. Then the answer is straightforward: len(intervals) - count of non-overlapping intervals\\n```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x: x[-1])\\n        count = 1\\n        end = intervals[0][-1]\\n        for a, b in intervals:\\n            if a >= end:\\n                end = b\\n                count += 1\\n        return len(intervals) - count\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x: x[-1])\\n        count = 1\\n        end = intervals[0][-1]\\n        for a, b in intervals:\\n            if a >= end:\\n                end = b\\n                count += 1\\n        return len(intervals) - count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807564,
                "title": "c-solution-o-nlog-n",
                "content": "Optimal strategy: Sort by endpoint. Start selection from start of sorted list. If interval is not overlapping any previous interval, it can be selected. Overlap is happening if start of interval is less than \"right\", max endpoint of previous intervals. Else (if overlap occurs) it cannot be chosen, so answer \"notI\" is increased by 1.\\n\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intv) {\\n        sort(intv.begin(), intv.end(), [](auto &v1, auto &v2){\\n            return v1[1] < v2[1];\\n        });\\n        int notI = 0, right = INT_MIN;\\n        for (int i = 0; i < intv.size(); i++){\\n            if (intv[i][0] < right) notI++;\\n            else right = intv[i][1];\\n        }\\n        return notI;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intv) {\\n        sort(intv.begin(), intv.end(), [](auto &v1, auto &v2){\\n            return v1[1] < v2[1];\\n        });\\n        int notI = 0, right = INT_MIN;\\n        for (int i = 0; i < intv.size(); i++){\\n            if (intv[i][0] < right) notI++;\\n            else right = intv[i][1];\\n        }\\n        return notI;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 792807,
                "title": "c-video-explanation",
                "content": "channel link>>>\\nhttps://www.youtube.com/channel/UCkcMtAWv5PO1p6eal7TXoEw/\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int ans = 0, n = intervals.size();\\n        if(n == 0) return 0;\\n        vector<pair<int,int>> interval;\\n        for(int i = 0; i < n; i++)\\n            interval.push_back({intervals[i][0],intervals[i][1]});\\n        \\n        sort(interval.begin(),interval.end());\\n        \\n        int end = interval[0].second;\\n        for(int i = 1; i < n; i++){\\n            if(interval[i].first < end){\\n                ans++;\\n                if(interval[i].second < end)\\n                    end = interval[i].second;\\n            }\\n            else end = interval[i].second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int ans = 0, n = intervals.size();\\n        if(n == 0) return 0;\\n        vector<pair<int,int>> interval;\\n        for(int i = 0; i < n; i++)\\n            interval.push_back({intervals[i][0],intervals[i][1]});\\n        \\n        sort(interval.begin(),interval.end());\\n        \\n        int end = interval[0].second;\\n        for(int i = 1; i < n; i++){\\n            if(interval[i].first < end){\\n                ans++;\\n                if(interval[i].second < end)\\n                    end = interval[i].second;\\n            }\\n            else end = interval[i].second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696715,
                "title": "very-simple-c-solutions-all-four-solutions-compared",
                "content": "```\\n/*\\nAfter thought: Greedy algorithm is faster but not always readily to come up with,\\nmethod 2 is more straightforward with a little bit more performance overhaul\\n\\nMethod 4\\nGreedy Algorithm not most intuitive solution, there is no formal mathmetical proof:\\nwe look at two intervals A, B at a time\\ncase 1: not overlapping, then we take both A and B\\ncase 2: overlap, end point B is before end point of A, then we take B\\ncase 3: overlap, end point B is after end point of A, then we take A\\nT(n) = O(nlgn)\\nS(n) = O(1)\\n*/\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if (intervals.empty()) { return 0; }\\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b)->bool {\\n            return a[0] < b[0];\\n            });\\n        \\n        int len = intervals.size();\\n        int count = 1;//the Max of intervals to keep, must be initially, bc we can always keep at least 1 interval\\n        int j = 0;// the last interval to look at\\n        for(int i = 1; i < len; i++){\\n            if(intervals[j][1] > intervals[i][0]){//if overlap\\n                if(intervals[j][1]  > intervals[i][1]){\\n                    //end point of interval j is after interval i, keep interval i\\n                    j=i;\\n                }else{\\n                    //otherwise, we keep j\\n                }\\n            }\\n            else{//if no overlap\\n                j = i;\\n                count++;\\n            }\\n        }\\n        return len - count;\\n    }\\n};\\n\\n/*\\nMethod 3:\\nDP solution\\nThe idea is to think reversely, instead of computing for minimum intervals to be removed,\\nwe want to compute for max intervals to be kept, and the ans is the length minus that value\\n\\ngiven an array A of intervals, sorted in ascending order based on the starting values\\n\\nlet dp[i] be the max # of intervals that could be kept to have a non-overlapping list \\nfor all interval up to i th interval, And need to Include the i th interval \\nthen:\\n\\ndp[i] = max(dp[j]) + 1, where j < i and i th interval and j th interval are not overlapping\\n\\nfollowing:\\nans must be A.length() - max(dp[i])\\nT(n) = O(nlgn) + O(n^2)\\n\\n\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if (intervals.empty()) { return 0; }\\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b)->bool {\\n            return a[0] < b[0];\\n            });\\n        \\n        int len = intervals.size();\\n        vector<int> dp(len);\\n        dp[0] = 1;//we must be able to keep the first interval\\n        int MaxIntervals = 1;//minum intervals to keep is 1 if all are overlapping\\n        for(int i = 1; i < len; i++){\\n            //Max is # of non-intervals, and its value is zero in the worst case\\n            int Max = 0;\\n            for(int j = i-1; j >= 0; j--){\\n                if(intervals[j][1] <= intervals[i][0]){\\n                    Max = max(Max, dp[j]);\\n                }\\n            }\\n            dp[i] = Max+1;\\n            MaxIntervals = max(MaxIntervals, dp[i]);\\n        }\\n        return len - MaxIntervals;\\n    }\\n};\\n\\n*/\\n\\n\\n/*\\n//Method2: brute force + memoization, pass\\n//the idea is that to look at every interval\\n\\n//Algorithm:\\n//let K be # of intervals to be removed to make non-overlapping interval list\\n\\n//for each current interval C could be removed or not removed\\n//    if removed, we simply remove C by increasing K by 1\\n//    if not removed, we will need to remove any intervals before C and overlapping with C \\n    \\n//T(n) = O(n), bc each interval will be looked or computed only once  \\n//S(n) = O(n), for the recursive stacks\\n//time spent: 36 ms\\n\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if (intervals.empty()) { return 0; }\\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b)->bool {\\n            return a[0] < b[0];\\n            });\\n        unordered_map<int,int> dp;\\n        return find(0, intervals, dp);\\n    }\\n    //return min # of intervals needed to be removed to make list non-overlapping\\n    int find(int cur, vector<vector<int>>& intervals, unordered_map<int,int>& dp) {\\n        int len = intervals.size();\\n\\n        if (cur >= len-1) { return 0; }//no need to remove interval if there is only 1 interval\\n        \\n        if(dp.count(cur)){\\n            return dp.at(cur);\\n        }\\n\\n        //for each current interval, we could remove or not remove\\n        //1 if removal\\n        int removal = find(cur + 1, intervals, dp)+1;\\n\\n        //2 if not removal, then we needed to find next non overlapping interval to skip the overlapping intervals\\n        int index = cur+1;\\n        while (index < len && intervals[cur][1] > intervals[index][0]) {\\n            index++;\\n        }//stop when index is at the next non-overlapping interval\\n        \\n         //(index - cur)-1 is the # of intervals to be skipped or removed in order to keep current interval\\n        int noremoval = find(index, intervals, dp) + (index - cur)-1;\\n\\n\\n        int res = min(removal, noremoval);\\n        dp[cur] = res;\\n        return res;\\n    }\\n};\\n*/\\n\\n\\n/*\\n//Method1: brute force, will cause TLE\\n//the idea is that to look at every interval\\n\\n//Algorithm:\\n//let K be # of intervals to be removed to make non-overlapping interval list\\n\\n//for each current interval C could be removed or not removed\\n//    if removed, we simply remove C by increasing K by 1\\n//    if not removed, we will need to remove any intervals before C and overlapping with C \\n    \\n//T(n) = O(2^n), bc there are 2 choices for each interval: remove and not remove, and there are n intervals  \\n\\n\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if (intervals.empty()) { return 0; }\\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b)->bool {\\n            return a[0] < b[0];\\n            });\\n        return find(0, intervals);\\n    }\\n    //return min # of intervals needed to be removed to make list non-overlapping\\n    int find(int cur, vector<vector<int>>& intervals) {\\n        int len = intervals.size();\\n\\n        if (cur >= len-1) { return 0; }//no need to remove interval if there is only 1 interval\\n\\n        //for each current interval, we could remove or not remove\\n        //1 if removal\\n        int removal = find(cur + 1, intervals)+1;\\n\\n        //2 if not removal, then we needed to find next non overlapping interval to skip the overlapping intervals\\n        int index = cur+1;\\n        while (index < len && intervals[cur][1] > intervals[index][0]) {\\n            index++;\\n        }//stop when index is at the next non-overlapping interval\\n        \\n         //(index - cur)-1 is the # of intervals to be skipped or removed in order to keep current interval\\n        int noremoval = find(index, intervals) + (index - cur)-1;\\n\\n        return min(removal, noremoval);\\n    }\\n};\\n\\n*/",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if (intervals.empty()) { return 0; }",
                "codeTag": "Java"
            },
            {
                "id": 626903,
                "title": "c-easy-consise-with-visual-explanation",
                "content": "For these intervals : \\n  ```\\n  --------------------------------------------------------------\\n         ------------        ---------------     -------\\n```\\nWe know that we should remove the longest one\\nWhy ? Because we want to be safe i.e. to reduce the risk of further overlap\\nwe should remove the one which ends at the last, thats it!\\n\\nSo we sort and for each interval we check whether it is overlapping with the previous interval or not, if it is overlapping,we increase *count*, then we remove the interval which ends later ( update *end* to the shorter interval\\'end and forget about the longer interval ). \\nIf it is not overlapping then we just move on.\\n\\t   \\n```\\nclass Solution {\\npublic:\\n    static bool comp (vector<int>&a,vector<int>&b){\\n        if(a[0]==b[0])\\n            return a[1]<b[1];\\n        return a[0]<b[0];\\n    }\\n    int eraseOverlapIntervals(vector<vector<int>>&v) {\\n        if(v.size()==0)\\n            return 0;\\n        sort(v.begin(),v.end(),comp);\\n        int end=v[0][1];\\n        int count=0;\\n        for(int i=1;i<v.size();i++){\\n            vector<int>& curr = v[i];\\n            if(curr[0]<end){\\n                count++;\\n                end = min(end,curr[1]);\\n            }\\n            else\\n                end = curr[1];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n  --------------------------------------------------------------\\n         ------------        ---------------     -------\\n```\n```\\nclass Solution {\\npublic:\\n    static bool comp (vector<int>&a,vector<int>&b){\\n        if(a[0]==b[0])\\n            return a[1]<b[1];\\n        return a[0]<b[0];\\n    }\\n    int eraseOverlapIntervals(vector<vector<int>>&v) {\\n        if(v.size()==0)\\n            return 0;\\n        sort(v.begin(),v.end(),comp);\\n        int end=v[0][1];\\n        int count=0;\\n        for(int i=1;i<v.size();i++){\\n            vector<int>& curr = v[i];\\n            if(curr[0]<end){\\n                count++;\\n                end = min(end,curr[1]);\\n            }\\n            else\\n                end = curr[1];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 586557,
                "title": "python-solution-sorting-based-on-starting-point",
                "content": "Sort the interval based on starting of each interval.\\nStart to check overlap from the 2nd interval.\\nIf current start is smaller than previous end, then overlap happens. Always keep the interval with smallest end.\\nIf current start is not smaller than previous end, no need to remove any interval, but update the previous end to end of current interval\\nTime: O(nlogn+n), sort and ons pass iteration\\nSpace: O(1)\\n```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        if not intervals or len(intervals) == 1:\\n            return 0\\n        \\n        intervals.sort()\\n        rms = 0\\n        pre_end = intervals[0][1]\\n        for start, end in intervals[1:]:\\n            if start < pre_end:\\n                rms += 1\\n                pre_end = min(end, pre_end)\\n            else:\\n                pre_end = end\\n        return rms\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        if not intervals or len(intervals) == 1:\\n            return 0\\n        \\n        intervals.sort()\\n        rms = 0\\n        pre_end = intervals[0][1]\\n        for start, end in intervals[1:]:\\n            if start < pre_end:\\n                rms += 1\\n                pre_end = min(end, pre_end)\\n            else:\\n                pre_end = end\\n        return rms\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507792,
                "title": "python-3-runtime-64ms-greedy-approach",
                "content": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        if not intervals: return 0\\n        count = 0\\n        intervals.sort()\\n        end = intervals[0][1]\\n        for i in range(1,len(intervals)):\\n            if intervals[i][0]<end:\\n                end = min(end,intervals[i][1])\\n                count+=1\\n            else:\\n                end = intervals[i][1]\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        if not intervals: return 0\\n        count = 0\\n        intervals.sort()\\n        end = intervals[0][1]\\n        for i in range(1,len(intervals)):\\n            if intervals[i][0]<end:\\n                end = min(end,intervals[i][1])\\n                count+=1\\n            else:\\n                end = intervals[i][1]\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 437126,
                "title": "java-2-different-approaches",
                "content": "```\\n// Sort based on ending \\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        int n = intervals.length, count=0;\\n        if(n == 0) return 0; \\n        Arrays.sort(intervals, (a,b) -> a[1]-b[1]);\\n        int[] prev = intervals[0]; \\n        for(int i = 1; i<n; i++) {\\n            if(prev[1] > intervals[i][0]) {\\n                count++; \\n            } else {\\n                prev = intervals[i]; \\n            }\\n        }\\n        return count; \\n    }\\n}\\n\\n// Sort based on start time\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        int n = intervals.length, count=0;\\n        if(n == 0) return 0; \\n        Arrays.sort(intervals, (a,b) -> a[0]-b[0]);\\n        int[] prev = intervals[0];\\n        for(int i = 1; i<n; i++) {\\n            if(prev[1] > intervals[i][0]) {\\n                count++; \\n                prev[1] = Math.min(prev[1], intervals[i][1]); \\n            } else {\\n                prev = intervals[i]; \\n            }\\n        }\\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Sort based on ending \\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        int n = intervals.length, count=0;\\n        if(n == 0) return 0; \\n        Arrays.sort(intervals, (a,b) -> a[1]-b[1]);\\n        int[] prev = intervals[0]; \\n        for(int i = 1; i<n; i++) {\\n            if(prev[1] > intervals[i][0]) {\\n                count++; \\n            } else {\\n                prev = intervals[i]; \\n            }\\n        }\\n        return count; \\n    }\\n}\\n\\n// Sort based on start time\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        int n = intervals.length, count=0;\\n        if(n == 0) return 0; \\n        Arrays.sort(intervals, (a,b) -> a[0]-b[0]);\\n        int[] prev = intervals[0];\\n        for(int i = 1; i<n; i++) {\\n            if(prev[1] > intervals[i][0]) {\\n                count++; \\n                prev[1] = Math.min(prev[1], intervals[i][1]); \\n            } else {\\n                prev = intervals[i]; \\n            }\\n        }\\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 424634,
                "title": "python-greedy-w-optimizations-faster-then-99-5",
                "content": "Simple Greedy Algorithim:\\n\\n1) Sort elements in the interval array by the value of the second element of each interval such that the interval ending soonest is first in the array. \\n2) Traverse the sorted array and for every interval properly fitted increment a counter\\n3) Subtract the counter from the length of array and return that value\\n\\nThis works because by finding the maximum non-overlapping intervals you are also finding the minimum amount of intervals that need to be removed.\\n\\nCode:\\n```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        max_count = len(intervals)\\n        if max_count  <= 1:\\n            return 0\\n        arr = sorted(intervals, key=lambda x: x[1])\\n        counter = 0\\n        last_end = float(\"-inf\")\\n        for elem in arr:\\n            if elem[0] >= last_end:\\n                last_end = elem[1]\\n                counter += 1\\n        return max_count - counter\\n\\n```\\n\\t\\n\\nThis is my first code writeup, please feel fre to leave comments and suggestions.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        max_count = len(intervals)\\n        if max_count  <= 1:\\n            return 0\\n        arr = sorted(intervals, key=lambda x: x[1])\\n        counter = 0\\n        last_end = float(\"-inf\")\\n        for elem in arr:\\n            if elem[0] >= last_end:\\n                last_end = elem[1]\\n                counter += 1\\n        return max_count - counter\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281621,
                "title": "java-two-solutions-explained-sort-by-end-time-and-sort-by-start-time",
                "content": "Approach 1: Sort by End Time and count the number of non overlapping intervals.\\n\\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(Interval[] intervals) {\\n        Arrays.sort(intervals, new intervalSort());\\n        int end = Integer.MIN_VALUE;\\n        int numNonOverlapping = 0;\\n        \\n        for (int index = 0; index < intervals.length; index++)\\n        {\\n            Interval curInterval = intervals[index];\\n            \\n            if (curInterval.start >= end)\\n            {\\n                numNonOverlapping++;\\n                end = curInterval.end;\\n            }\\n        }\\n        \\n        return intervals.length - numNonOverlapping;\\n    }\\n    \\n    private class intervalSort implements Comparator<Interval>\\n    {\\n        public int compare(Interval first, Interval second)\\n        {\\n            return first.end - second.end;\\n        }\\n    }\\n}\\n```\\n\\nApproach 2: If you want to sort by start time, the correctness of the solution depends on the end time that you choose, make sure to choose the minimum of current and next interval (two overlapping intervals).\\n\\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(Interval[] intervals) {\\n        if (intervals.length == 0)\\n        {\\n            return 0;\\n        }\\n        \\n        Arrays.sort(intervals, new intervalSort());\\n        int end = intervals[0].end;\\n        int numOverlapping = 0;\\n        \\n        for (int index = 1; index < intervals.length; index++)\\n        {\\n            Interval curInterval = intervals[index];\\n            \\n            if (curInterval.start < end)\\n            {\\n                numOverlapping++;\\n                end = Math.min(end, curInterval.end);\\n            }\\n            else\\n            {\\n                end = curInterval.end;\\n            }\\n        }\\n        \\n        return numOverlapping;\\n    }\\n    \\n    private class intervalSort implements Comparator<Interval>\\n    {\\n        public int compare(Interval first, Interval second)\\n        {\\n            return first.start - second.start;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(Interval[] intervals) {\\n        Arrays.sort(intervals, new intervalSort());\\n        int end = Integer.MIN_VALUE;\\n        int numNonOverlapping = 0;\\n        \\n        for (int index = 0; index < intervals.length; index++)\\n        {\\n            Interval curInterval = intervals[index];\\n            \\n            if (curInterval.start >= end)\\n            {\\n                numNonOverlapping++;\\n                end = curInterval.end;\\n            }\\n        }\\n        \\n        return intervals.length - numNonOverlapping;\\n    }\\n    \\n    private class intervalSort implements Comparator<Interval>\\n    {\\n        public int compare(Interval first, Interval second)\\n        {\\n            return first.end - second.end;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(Interval[] intervals) {\\n        if (intervals.length == 0)\\n        {\\n            return 0;\\n        }\\n        \\n        Arrays.sort(intervals, new intervalSort());\\n        int end = intervals[0].end;\\n        int numOverlapping = 0;\\n        \\n        for (int index = 1; index < intervals.length; index++)\\n        {\\n            Interval curInterval = intervals[index];\\n            \\n            if (curInterval.start < end)\\n            {\\n                numOverlapping++;\\n                end = Math.min(end, curInterval.end);\\n            }\\n            else\\n            {\\n                end = curInterval.end;\\n            }\\n        }\\n        \\n        return numOverlapping;\\n    }\\n    \\n    private class intervalSort implements Comparator<Interval>\\n    {\\n        public int compare(Interval first, Interval second)\\n        {\\n            return first.start - second.start;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189715,
                "title": "simple-javascript-solution",
                "content": "Solution:\\n1: sort all intervals based on its start point\\n2: when overlapping, delete the one with larger end point\\n```\\nvar eraseOverlapIntervals = function(intervals) {\\n  if(intervals.length===0) return 0;\\n\\n  intervals.sort((a,b) => a.start-b.start);\\n  var count = 0;\\n  var prevEnd = intervals[0].end;\\n  for(var i=1; i<intervals.length; i++) {\\n    var thisStart = intervals[i].start;\\n    var thisEnd = intervals[i].end;\\n    if(thisStart < prevEnd) {\\n      count++;\\n      prevEnd = Math.min(prevEnd, thisEnd); \\n    } else {\\n      prevEnd = thisEnd;\\n    }\\n  }\\n  return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar eraseOverlapIntervals = function(intervals) {\\n  if(intervals.length===0) return 0;\\n\\n  intervals.sort((a,b) => a.start-b.start);\\n  var count = 0;\\n  var prevEnd = intervals[0].end;\\n  for(var i=1; i<intervals.length; i++) {\\n    var thisStart = intervals[i].start;\\n    var thisEnd = intervals[i].end;\\n    if(thisStart < prevEnd) {\\n      count++;\\n      prevEnd = Math.min(prevEnd, thisEnd); \\n    } else {\\n      prevEnd = thisEnd;\\n    }\\n  }\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 158062,
                "title": "javascript-sort-by-start-explains-what-happens-when-overlapping",
                "content": "Sort by start is my intuitive solution, but did not pass the last 2 test cases.\\nneeds to carefully handle the case when interval overlapps, e.g. [[1,5], [2, 3], [4, 5], [3, 4]],  when we have [1, 5] and [2, 3] overlapps, we should discard the one with bigger range, since it\\'s already sorted by start, we discard the one with bigger end.  \\n```\\nvar eraseOverlapIntervals = function(intervals) {\\n    intervals.sort((a, b) => {return a.start != b.start? a.start - b.start : a.end - b.end;});\\n    var count = 0;\\n    if (intervals.length == 0) {\\n        return 0;\\n    }\\n    var pre = intervals[0];\\n    for(var i = 1; i < intervals.length; ++i) {\\n        if (pre.end > intervals[i].start) { \\n            // overlapping, we discard the one with larger end\\n            count++;\\n            pre.end = Math.min(pre.end, intervals[i].end);\\n        } else {\\n            pre =  intervals[i];\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar eraseOverlapIntervals = function(intervals) {\\n    intervals.sort((a, b) => {return a.start != b.start? a.start - b.start : a.end - b.end;});\\n    var count = 0;\\n    if (intervals.length == 0) {\\n        return 0;\\n    }\\n    var pre = intervals[0];\\n    for(var i = 1; i < intervals.length; ++i) {\\n        if (pre.end > intervals[i].start) { \\n            // overlapping, we discard the one with larger end\\n            count++;\\n            pre.end = Math.min(pre.end, intervals[i].end);\\n        } else {\\n            pre =  intervals[i];\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91744,
                "title": "a-concise-template-for-overlapping-interval-problem",
                "content": "Here I provide a concise template that I summarize for the so-called \"Overlapping Interval Problem\", e.g. Minimum Number of Arrows to Burst Balloons, and Non-overlapping Intervals etc. I found these problems share some similarities on their solutions.\\n* Sort intervals/pairs in increasing order of the start position.\\n* Scan the sorted intervals, and maintain an \"active set\" for overlapping intervals. At most times, we do not need to use an explicit set to store them. Instead, we just need to maintain several key parameters, e.g. the number of overlapping intervals (count), the minimum ending point among all overlapping intervals (minEnd). \\n* If the interval that we are currently checking overlaps with the active set, which can be characterized by cur.start < minEnd, we need to renew those key parameters or change some states.\\n* If the current interval does not overlap with the active set, we just drop current active set, record some parameters, and create a new active set that contains the current interval.\\n```\\nint count = 0; // Global parameters that are useful for results.\\nint minEnd = INT_MAX; // Key parameters characterizing the \"active set\" for overlapping intervals, e.g. the minimum ending point among all overlapping intervals.\\nsort(points.begin(), points.end()); // Sorting the intervals/pairs in ascending order of its starting point\\nfor each interval {\\n      if(interval.start > minEnd) { // If the \\n\\t // changing some states, record some information, and start a new active set. \\n\\tminEnd = p.second;\\n      }\\n     else {\\n\\t// renew key parameters of the active set\\n\\tminEnd = min(minEnd, p.second);\\n      } \\n }\\nreturn the result recorded in or calculated from the global information;\\n```\\n\\nFor the problem \"**Non-overlapping Intervals**\", we have\\n```\\nint eraseOverlapIntervals(vector<Interval>& intervals) {\\n        int total = 0, minEnd = INT_MIN, overNb = 1;\\n        sort(intervals.begin(), intervals.end(), [&](Interval& inter1, Interval& inter2) {return inter1.start < inter2.start;});\\n        for(auto& p: intervals) {\\n            if(p.start >= minEnd) {\\n                total += overNb-1;\\n                overNb = 1;\\n                minEnd = p.end;\\n            }\\n            else {\\n                overNb++;\\n                minEnd = min(minEnd, p.end);\\n            }\\n        }\\n        return total + overNb-1;\\n    }\\n```\\n\\nFor example, for the problem Minimum \"**Number of Arrows to Burst Balloons**\", we have\\n* Sort balloons in increasing order of the start position.\\n* Scan the sorted pairs, and maintain a pointer for the minimum end position for current \"active balloons\", whose diameters are overlapping. \\n* When the next balloon starts after all active balloons, shoot an arrow to burst all active balloons, and start to record next active balloons.\\n\\n```\\nint findMinArrowShots(vector<pair<int, int>>& points) {\\n        int count = 0, minEnd = INT_MAX;\\n        sort(points.begin(), points.end());\\n        for(auto& p: points) {\\n            if(p.first > minEnd) {count++; minEnd = p.second;}\\n            else minEnd = min(minEnd, p.second);\\n        }\\n        return count + !points.empty();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint count = 0; // Global parameters that are useful for results.\\nint minEnd = INT_MAX; // Key parameters characterizing the \"active set\" for overlapping intervals, e.g. the minimum ending point among all overlapping intervals.\\nsort(points.begin(), points.end()); // Sorting the intervals/pairs in ascending order of its starting point\\nfor each interval {\\n      if(interval.start > minEnd) { // If the \\n\\t // changing some states, record some information, and start a new active set. \\n\\tminEnd = p.second;\\n      }\\n     else {\\n\\t// renew key parameters of the active set\\n\\tminEnd = min(minEnd, p.second);\\n      } \\n }\\nreturn the result recorded in or calculated from the global information;\\n```\n```\\nint eraseOverlapIntervals(vector<Interval>& intervals) {\\n        int total = 0, minEnd = INT_MIN, overNb = 1;\\n        sort(intervals.begin(), intervals.end(), [&](Interval& inter1, Interval& inter2) {return inter1.start < inter2.start;});\\n        for(auto& p: intervals) {\\n            if(p.start >= minEnd) {\\n                total += overNb-1;\\n                overNb = 1;\\n                minEnd = p.end;\\n            }\\n            else {\\n                overNb++;\\n                minEnd = min(minEnd, p.end);\\n            }\\n        }\\n        return total + overNb-1;\\n    }\\n```\n```\\nint findMinArrowShots(vector<pair<int, int>>& points) {\\n        int count = 0, minEnd = INT_MAX;\\n        sort(points.begin(), points.end());\\n        for(auto& p: points) {\\n            if(p.first > minEnd) {count++; minEnd = p.second;}\\n            else minEnd = min(minEnd, p.second);\\n        }\\n        return count + !points.empty();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91785,
                "title": "python-short-8-lines-greedy-solution-with-explanation",
                "content": "My solution from the contest with minimal cleanup. Iterate through sorted intervals. If two successive intervals overlap then we must eliminate one, so we increase the result. The new lo interval to consider will be the old hi one, unless the old lo and hi overlap partially (the lo only covers part of the high). The lo interval will be changed to the high one if:\\n\\n* The lo & hi intervals don't overlap, so we continue checking the following intervals\\n* The lo interval completely covers the hi one, then the lo is a better candidate to remove\\n\\n```\\ndef eraseOverlapIntervals(self, intervals):\\n    intervals.sort(key=operator.attrgetter('start', 'end'))\\n    res = lo = 0\\n    for hi in range(1, len(intervals)):\\n        if intervals[lo].end > intervals[hi].start:\\n            res += 1\\n        if not intervals[hi].start < intervals[lo].end < intervals[hi].end:\\n            lo = hi\\n    return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef eraseOverlapIntervals(self, intervals):\\n    intervals.sort(key=operator.attrgetter('start', 'end'))\\n    res = lo = 0\\n    for hi in range(1, len(intervals)):\\n        if intervals[lo].end > intervals[hi].start:\\n            res += 1\\n        if not intervals[hi].start < intervals[lo].end < intervals[hi].end:\\n            lo = hi\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4040619,
                "title": "non-overlapping-intervals-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n\\n        int curr_end = intervals[0][1];\\n        int cnt = 0;\\n        for(int i=1; i<n; i++){\\n            if(intervals[i][0] < curr_end){\\n                cnt++;\\n                curr_end = min(curr_end, intervals[i][1]);\\n            }else {\\n                curr_end = intervals[i][1];\\n            }\\n        } \\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n\\n        int curr_end = intervals[0][1];\\n        int cnt = 0;\\n        for(int i=1; i<n; i++){\\n            if(intervals[i][0] < curr_end){\\n                cnt++;\\n                curr_end = min(curr_end, intervals[i][1]);\\n            }else {\\n                curr_end = intervals[i][1];\\n            }\\n        } \\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809409,
                "title": "easy-solution-with-explanation-python-3",
                "content": "# Algorithm\\n- Sort intervals array\\n- create a default pointer for pe for storing end of previous interval \\n- create a variable for storing result\\n- loop over sorted intervals array and check if end >= pe\\n    - if condition is true then update pe pointer with current end\\n    - else update result with +1\\n- return result\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n) [Python uses Timsort and it takes O(n) space in worst case]\\n# Video Explanation\\nhttps://youtu.be/AMbiy_gzVnY\\n\\n# Code\\n```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        \"\"\"\\n        Algo - \\n        - Sort intervals array\\n        - create a default pointer for pe for storing end of previous interval \\n        - create a variable for storing result\\n        - loop over sorted intervals array and check if end >= pe\\n            - if condition is true then update pe pointer with current end\\n            - else update result with +1\\n        - return result\\n        \"\"\"\\n\\n        intervals.sort(key = lambda x: x[1])\\n        pe = -inf\\n        result = 0\\n\\n        for start, end in intervals:\\n            if start >= pe:\\n                pe = end\\n            else:\\n                result += 1\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        \"\"\"\\n        Algo - \\n        - Sort intervals array\\n        - create a default pointer for pe for storing end of previous interval \\n        - create a variable for storing result\\n        - loop over sorted intervals array and check if end >= pe\\n            - if condition is true then update pe pointer with current end\\n            - else update result with +1\\n        - return result\\n        \"\"\"\\n\\n        intervals.sort(key = lambda x: x[1])\\n        pe = -inf\\n        result = 0\\n\\n        for start, end in intervals:\\n            if start >= pe:\\n                pe = end\\n            else:\\n                result += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788788,
                "title": "swift-small-clean-solution",
                "content": "# Complexity\\n- Time complexity: $O(n \\\\cdot \\\\log n)$\\n- Space complexity: $O(n)$\\n\\n# Code\\n```\\nprivate extension Array\\n{\\n    var start: Element { self[0] }\\n    var end: Element { self[1] }\\n}\\nclass Solution\\n{\\n    func eraseOverlapIntervals(_ intervals: [[Int]]) -> Int\\n    {\\n        let minStartIntervals = intervals.sorted { $0.start < $1.start }\\n        var removedCount = 0, currentEnd = Int.min\\n        for interval in minStartIntervals\\n        {\\n            if interval.start >= currentEnd {\\n                currentEnd = interval.end\\n            }\\n            else\\n            {\\n                currentEnd = min(currentEnd, interval.end)\\n                removedCount += 1\\n            }\\n        }\\n        return removedCount\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nprivate extension Array\\n{\\n    var start: Element { self[0] }\\n    var end: Element { self[1] }\\n}\\nclass Solution\\n{\\n    func eraseOverlapIntervals(_ intervals: [[Int]]) -> Int\\n    {\\n        let minStartIntervals = intervals.sorted { $0.start < $1.start }\\n        var removedCount = 0, currentEnd = Int.min\\n        for interval in minStartIntervals\\n        {\\n            if interval.start >= currentEnd {\\n                currentEnd = interval.end\\n            }\\n            else\\n            {\\n                currentEnd = min(currentEnd, interval.end)\\n                removedCount += 1\\n            }\\n        }\\n        return removedCount\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788747,
                "title": "very-easy-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func eraseOverlapIntervals(_ intervals: [[Int]]) -> Int {\\n        var arr = intervals\\n        arr.sort(by: {$0[0] < $1[0]})\\n        var count = 0\\n        // keep track of last range which is valid (witut overlapping)\\n        var lastRange = arr[0]\\n\\n        for (i,range) in arr.enumerated() {\\n            if i == 0 {\\n                continue\\n            }\\n            if lastRange[1] > range[0] {\\n                // erase range which has larger last value\\n                if lastRange[1] > range[1] {\\n                    lastRange = range\\n                }\\n                count += 1\\n            } else {\\n                lastRange = range\\n            }\\n        }\\n        return count\\n    }\\n}\\n\\n[[1,2],[1,3],[2,3],[3,4]]\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func eraseOverlapIntervals(_ intervals: [[Int]]) -> Int {\\n        var arr = intervals\\n        arr.sort(by: {$0[0] < $1[0]})\\n        var count = 0\\n        // keep track of last range which is valid (witut overlapping)\\n        var lastRange = arr[0]\\n\\n        for (i,range) in arr.enumerated() {\\n            if i == 0 {\\n                continue\\n            }\\n            if lastRange[1] > range[0] {\\n                // erase range which has larger last value\\n                if lastRange[1] > range[1] {\\n                    lastRange = range\\n                }\\n                count += 1\\n            } else {\\n                lastRange = range\\n            }\\n        }\\n        return count\\n    }\\n}\\n\\n[[1,2],[1,3],[2,3],[3,4]]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788294,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   static bool compare(vector<int>&v1,vector<int>&v2){\\n       return v1[1]<v2[1];\\n   }\\n\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int ans=0;\\n        sort(intervals.begin(),intervals.end(),compare);\\n        int last=intervals[0][1];\\n        int n=intervals.size();\\n\\n        for(int i=1;i<n;i++){\\n            if(intervals[i][0]<last){\\n             //  last=max(last,intervals[i][1]);\\n               ans++;\\n            }else last=intervals[i][1];\\n        }\\nreturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   static bool compare(vector<int>&v1,vector<int>&v2){\\n       return v1[1]<v2[1];\\n   }\\n\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int ans=0;\\n        sort(intervals.begin(),intervals.end(),compare);\\n        int last=intervals[0][1];\\n        int n=intervals.size();\\n\\n        for(int i=1;i<n;i++){\\n            if(intervals[i][0]<last){\\n             //  last=max(last,intervals[i][1]);\\n               ans++;\\n            }else last=intervals[i][1];\\n        }\\nreturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788241,
                "title": "c-java-easy-and-clean-code-dp-greedy-beats",
                "content": "# Please Upvote if you liked my Solution \\uD83E\\uDD17\\uD83E\\uDD17\\n> **Please do UpVote** it took lot of time to figure out these solutions\\n\\n# Complexity \\n<!-- - Please check the code, as every solution have different complexity -->\\n- Time complexity: $$O(N*logN)$$ where `N = intervals.length`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$ for `Solution 1` and `Solution 2` \\n- Space complexity: $$O(1)$$ for `Solution 3` \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# C++ Code\\n```\\nclass Solution {\\n    int findLowerBound(int x, int s, vector<vector<int>>& is){\\n        int l = s, r = is.size()-1, lb = is.size();\\n        while(l <= r){\\n            int mid = (l+r)/2;\\n            if( is[mid][0] < x ) l = mid+1;\\n            else lb = mid, r = mid-1;\\n        }\\n        return lb;\\n    }\\n\\n    int eraseOverlapIntervalsHelp(int ind, vector<int> &dp, vector<vector<int>>& is){\\n        if( ind == is.size() ) return 0;\\n        if( dp[ind] != -1 ) return dp[ind];\\n\\n        int lb = findLowerBound(is[ind][1], ind+1, is);\\n        int w1 = eraseOverlapIntervalsHelp(lb, dp, is) + (lb - ind - 1); // take current interval\\n        int w2 = eraseOverlapIntervalsHelp(ind+1, dp, is) + 1; // not take current interval\\n        return dp[ind] = min(w1, w2);\\n    }\\n\\n\\npublic:\\n    // Solution 1 - DP Top Down - O(N) space\\n    int eraseOverlapIntervals1(vector<vector<int>>& is) {\\n        sort(is.begin(), is.end(), [](vector<int> &a, vector<int> &b){ \\n            return a[0] < b[0]; \\n        });\\n        int n = is.size();\\n        vector<int> dp(n, -1);\\n        return eraseOverlapIntervalsHelp(0, dp, is);\\n    }\\n\\n\\n    // Solution 2 - Bottom Up - O(N) space\\n    int eraseOverlapIntervals2(vector<vector<int>>& is) {\\n        sort(is.begin(), is.end(), [](vector<int> &a, vector<int> &b){ \\n            return a[0] < b[0]; \\n        });\\n        int n = is.size();\\n        vector<int> dp(n+1, 0);\\n\\n        for(int ind = n-1; ind>=0; ind--){\\n            int lb = findLowerBound(is[ind][1], ind+1, is);\\n            int w1 = dp[lb] + (lb - ind - 1);\\n            int w2 = dp[ind+1] + 1;\\n            dp[ind] = min(w1, w2);\\n        }\\n        return dp[0];\\n    }\\n\\n\\n    // Solution 3 - Greedy - Easy but Tricky - O(1) space \\n    int eraseOverlapIntervals(vector<vector<int>>& is) {\\n        sort(is.begin(), is.end(), [](vector<int> &a, vector<int> &b){ \\n            return a[1] < b[1]; \\n        });\\n        int curEndTime = INT_MIN, ans = 0;\\n\\n        for(int i=0; i<is.size(); i++){\\n            int x = is[i][0], y = is[i][1]; // [x, y]\\n            if( curEndTime <= x ) curEndTime = y; // take [k, x] + [x, y]\\n            else ans++;\\n        }\\n        return ans;    \\n    }\\n\\n};\\n```\\n\\n---\\n\\n# Java Code\\n```\\nclass Solution {\\n    private int findLowerBound(int x, int s, int is[][]){\\n        int l = s, r = is.length - 1, lb = is.length;\\n        while(l <= r){\\n            int mid = (l+r)/2;\\n            if( is[mid][0] < x ) l = mid+1;\\n            else {\\n                lb = mid; \\n                r = mid-1;\\n            }\\n        }\\n        return lb;\\n    }\\n\\n    private int eraseOverlapIntervalsHelp(int ind, int dp[], int is[][]){\\n        if( ind == is.length ) return 0;\\n        if( dp[ind] != -1 ) return dp[ind];\\n\\n        int lb = findLowerBound(is[ind][1], ind+1, is);\\n        int w1 = eraseOverlapIntervalsHelp(lb, dp, is) + (lb - ind - 1); // take current interval\\n        int w2 = eraseOverlapIntervalsHelp(ind+1, dp, is) + 1; // not take current interval\\n        return dp[ind] = Math.min(w1, w2);\\n    }\\n\\n\\n    // Solution 1 - DP Top Down - O(N) space\\n    public int eraseOverlapIntervals1(int[][] is) {\\n        Arrays.sort(is, (a, b)->a[0] - b[0]);\\n        int n = is.length;\\n        int dp[] = new int[n];\\n        Arrays.fill(dp, -1);\\n        return eraseOverlapIntervalsHelp(0, dp, is);\\n    }\\n\\n\\n    // Solution 2 - Bottom Up - O(N) space\\n    public int eraseOverlapIntervals2(int[][] is) {\\n        Arrays.sort(is, (a, b)->a[0] - b[0]);\\n        int n = is.length, dp[] = new int[n+1];\\n\\n        for(int ind = n-1; ind>=0; ind--){\\n            int lb = findLowerBound(is[ind][1], ind+1, is);\\n            int w1 = dp[lb] + (lb - ind - 1);\\n            int w2 = dp[ind+1] + 1;\\n            dp[ind] = Math.min(w1, w2);\\n        }\\n        return dp[0];\\n    }\\n\\n\\n    // Solution 3 - Greedy - Easy but Tricky - O(1) space \\n    int eraseOverlapIntervals(int[][] is) {\\n        Arrays.sort(is, (a, b)->a[1] - b[1]);\\n        int curEndTime = Integer.MIN_VALUE, ans = 0;\\n\\n        for(int i=0; i<is.length; i++){\\n            int x = is[i][0], y = is[i][1]; // [x, y]\\n            if( curEndTime <= x ) curEndTime = y; // take [k, x] + [x, y]\\n            else ans++;\\n        }\\n        return ans;    \\n    }\\n\\n}\\n```\\n\\n![upvote-img.jpg](https://assets.leetcode.com/users/images/d20562b8-5ddb-40b3-8b8a-5d7a0a6f0b57_1684136359.2221565.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    int findLowerBound(int x, int s, vector<vector<int>>& is){\\n        int l = s, r = is.size()-1, lb = is.size();\\n        while(l <= r){\\n            int mid = (l+r)/2;\\n            if( is[mid][0] < x ) l = mid+1;\\n            else lb = mid, r = mid-1;\\n        }\\n        return lb;\\n    }\\n\\n    int eraseOverlapIntervalsHelp(int ind, vector<int> &dp, vector<vector<int>>& is){\\n        if( ind == is.size() ) return 0;\\n        if( dp[ind] != -1 ) return dp[ind];\\n\\n        int lb = findLowerBound(is[ind][1], ind+1, is);\\n        int w1 = eraseOverlapIntervalsHelp(lb, dp, is) + (lb - ind - 1); // take current interval\\n        int w2 = eraseOverlapIntervalsHelp(ind+1, dp, is) + 1; // not take current interval\\n        return dp[ind] = min(w1, w2);\\n    }\\n\\n\\npublic:\\n    // Solution 1 - DP Top Down - O(N) space\\n    int eraseOverlapIntervals1(vector<vector<int>>& is) {\\n        sort(is.begin(), is.end(), [](vector<int> &a, vector<int> &b){ \\n            return a[0] < b[0]; \\n        });\\n        int n = is.size();\\n        vector<int> dp(n, -1);\\n        return eraseOverlapIntervalsHelp(0, dp, is);\\n    }\\n\\n\\n    // Solution 2 - Bottom Up - O(N) space\\n    int eraseOverlapIntervals2(vector<vector<int>>& is) {\\n        sort(is.begin(), is.end(), [](vector<int> &a, vector<int> &b){ \\n            return a[0] < b[0]; \\n        });\\n        int n = is.size();\\n        vector<int> dp(n+1, 0);\\n\\n        for(int ind = n-1; ind>=0; ind--){\\n            int lb = findLowerBound(is[ind][1], ind+1, is);\\n            int w1 = dp[lb] + (lb - ind - 1);\\n            int w2 = dp[ind+1] + 1;\\n            dp[ind] = min(w1, w2);\\n        }\\n        return dp[0];\\n    }\\n\\n\\n    // Solution 3 - Greedy - Easy but Tricky - O(1) space \\n    int eraseOverlapIntervals(vector<vector<int>>& is) {\\n        sort(is.begin(), is.end(), [](vector<int> &a, vector<int> &b){ \\n            return a[1] < b[1]; \\n        });\\n        int curEndTime = INT_MIN, ans = 0;\\n\\n        for(int i=0; i<is.size(); i++){\\n            int x = is[i][0], y = is[i][1]; // [x, y]\\n            if( curEndTime <= x ) curEndTime = y; // take [k, x] + [x, y]\\n            else ans++;\\n        }\\n        return ans;    \\n    }\\n\\n};\\n```\n```\\nclass Solution {\\n    private int findLowerBound(int x, int s, int is[][]){\\n        int l = s, r = is.length - 1, lb = is.length;\\n        while(l <= r){\\n            int mid = (l+r)/2;\\n            if( is[mid][0] < x ) l = mid+1;\\n            else {\\n                lb = mid; \\n                r = mid-1;\\n            }\\n        }\\n        return lb;\\n    }\\n\\n    private int eraseOverlapIntervalsHelp(int ind, int dp[], int is[][]){\\n        if( ind == is.length ) return 0;\\n        if( dp[ind] != -1 ) return dp[ind];\\n\\n        int lb = findLowerBound(is[ind][1], ind+1, is);\\n        int w1 = eraseOverlapIntervalsHelp(lb, dp, is) + (lb - ind - 1); // take current interval\\n        int w2 = eraseOverlapIntervalsHelp(ind+1, dp, is) + 1; // not take current interval\\n        return dp[ind] = Math.min(w1, w2);\\n    }\\n\\n\\n    // Solution 1 - DP Top Down - O(N) space\\n    public int eraseOverlapIntervals1(int[][] is) {\\n        Arrays.sort(is, (a, b)->a[0] - b[0]);\\n        int n = is.length;\\n        int dp[] = new int[n];\\n        Arrays.fill(dp, -1);\\n        return eraseOverlapIntervalsHelp(0, dp, is);\\n    }\\n\\n\\n    // Solution 2 - Bottom Up - O(N) space\\n    public int eraseOverlapIntervals2(int[][] is) {\\n        Arrays.sort(is, (a, b)->a[0] - b[0]);\\n        int n = is.length, dp[] = new int[n+1];\\n\\n        for(int ind = n-1; ind>=0; ind--){\\n            int lb = findLowerBound(is[ind][1], ind+1, is);\\n            int w1 = dp[lb] + (lb - ind - 1);\\n            int w2 = dp[ind+1] + 1;\\n            dp[ind] = Math.min(w1, w2);\\n        }\\n        return dp[0];\\n    }\\n\\n\\n    // Solution 3 - Greedy - Easy but Tricky - O(1) space \\n    int eraseOverlapIntervals(int[][] is) {\\n        Arrays.sort(is, (a, b)->a[1] - b[1]);\\n        int curEndTime = Integer.MIN_VALUE, ans = 0;\\n\\n        for(int i=0; i<is.length; i++){\\n            int x = is[i][0], y = is[i][1]; // [x, y]\\n            if( curEndTime <= x ) curEndTime = y; // take [k, x] + [x, y]\\n            else ans++;\\n        }\\n        return ans;    \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787947,
                "title": "python-easy-explanation",
                "content": "# Intuition\\nTo find the minimum number of intervals we need to remove to make the rest of the intervals non-overlapping, we can follow a greedy approach based on sorting the intervals. \\n\\n# Approach\\nThe function first sorts the intervals based on their end times. It then iterates through the sorted intervals, keeping track of the non-overlapping intervals and updating the `end_time` variable accordingly. The count of non-overlapping intervals is incremented whenever a new non-overlapping interval is found. Finally, the function returns the minimum number of intervals to remove, which is calculated as the total number of intervals minus the count of non-overlapping intervals.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is O(n log n)\\n\\n- Space complexity:\\nThe space complexity is O(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def eraseOverlapIntervals(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not intervals:\\n            return 0\\n        \\n        intervals.sort(key=lambda x: x[1])\\n\\n        count=1\\n        end_time=intervals[0][1]\\n        for i in range(1,len(intervals)):\\n            start_time,curr_end_time=intervals[i]\\n            \\n            if start_time>=end_time:\\n                count+=1\\n                end_time=curr_end_time\\n        \\n        return len(intervals)-count\\n\\n```\\n# **PLEASE DO UPVOTE!!!\\uD83E\\uDD79**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def eraseOverlapIntervals(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not intervals:\\n            return 0\\n        \\n        intervals.sort(key=lambda x: x[1])\\n\\n        count=1\\n        end_time=intervals[0][1]\\n        for i in range(1,len(intervals)):\\n            start_time,curr_end_time=intervals[i]\\n            \\n            if start_time>=end_time:\\n                count+=1\\n                end_time=curr_end_time\\n        \\n        return len(intervals)-count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787841,
                "title": "help-why-this-code-giving-tle-on-submitting-but-not-on-running-same-test-case-case-separately",
                "content": "thought process : sort arr on basis of ending time and find the longest possble Non-overlapping Intervals, then subtract it from total num of interval given.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& arr) {\\n        sort(begin(arr), end(arr),[&](auto a, auto b) {\\n            return a[1]==b[1] ? a[0]<b[0] : a[1]<b[1];\\n        });\\n        \\n        int ans=1, i=0, j=1, ln= arr.size();\\n        \\n        while(j<ln){\\n            while(j<ln && arr[j][0]< arr[i][1])j++;\\n            if(j!= ln) ans++;\\n            \\n            i= j++;\\n        }\\n        \\n        return (ln-ans);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/dbb069a2-4506-41b9-9406-7bdb72e37d86_1689772771.2621236.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& arr) {\\n        sort(begin(arr), end(arr),[&](auto a, auto b) {\\n            return a[1]==b[1] ? a[0]<b[0] : a[1]<b[1];\\n        });\\n        \\n        int ans=1, i=0, j=1, ln= arr.size();\\n        \\n        while(j<ln){\\n            while(j<ln && arr[j][0]< arr[i][1])j++;\\n            if(j!= ln) ans++;\\n            \\n            i= j++;\\n        }\\n        \\n        return (ln-ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786622,
                "title": "cpp-detailed-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n    // Sort intervals based on the first element of each interval\\n    sort(intervals.begin(), intervals.end());\\n\\n    vector<vector<int>> temp; // Stores non-overlapping intervals\\n\\n    for (auto x : intervals) {\\n        if (temp.size() == 0) {\\n            temp.push_back(x);\\n        } else {\\n            // Check if the current interval overlaps with the last interval in temp\\n            if (temp.back()[1] > x[0]) {\\n                // If it overlaps, update the end of the last interval in temp\\n                temp.back()[1] = min(temp.back()[1], x[1]);\\n            } else {\\n                // If it doesn\\'t overlap, add the current interval to temp\\n                temp.push_back(x);\\n            }\\n        }\\n    }\\n\\n    // Return the number of overlapping intervals\\n    return intervals.size() - temp.size();\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n    // Sort intervals based on the first element of each interval\\n    sort(intervals.begin(), intervals.end());\\n\\n    vector<vector<int>> temp; // Stores non-overlapping intervals\\n\\n    for (auto x : intervals) {\\n        if (temp.size() == 0) {\\n            temp.push_back(x);\\n        } else {\\n            // Check if the current interval overlaps with the last interval in temp\\n            if (temp.back()[1] > x[0]) {\\n                // If it overlaps, update the end of the last interval in temp\\n                temp.back()[1] = min(temp.back()[1], x[1]);\\n            } else {\\n                // If it doesn\\'t overlap, add the current interval to temp\\n                temp.push_back(x);\\n            }\\n        }\\n    }\\n\\n    // Return the number of overlapping intervals\\n    return intervals.size() - temp.size();\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786428,
                "title": "super-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int previous=0,n=intervals.size(),ans=0;\\n        for(int current=1;current<n;current++){\\n            if(intervals[current][0]<intervals[previous][1]){\\n                ans++;\\n                 if(intervals[current][1]<=intervals[previous][1]){\\n          previous=current;//[1][5],[3][4]then previous will become[3][4]\\n            }\\n            }else{\\n                previous=current;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->To solve this problem efficiently, we can use a greedy approach. The key observation is that if two intervals overlap, we should remove the interval with the larger end point. By doing so, we are more likely to have space to accommodate other intervals without overlapping.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Sort the intervals based on their start times. This allows us to process intervals in a way that we can easily identify overlaps.\\nInitialize a variable previous to track the index of the previous interval, and ans to keep track of the count of overlapping intervals.\\nLoop through the sorted intervals from the second interval (index 1) to the last interval:\\nIf the current interval\\'s start time is less than the previous interval\\'s end time, it means there is an overlap. Increment ans.\\nUpdate previous to the current index if the current interval\\'s end time is less than or equal to the previous interval\\'s end time. This ensures we are always considering the interval with the smaller end time in case of overlaps.\\nReturn the value of ans as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->Sorting the intervals takes O(N log N) time, where N is the number of intervals.\\nThe loop through the sorted intervals takes O(N) time.\\nThus, the overall time complexity of the solution is O(N log N).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->The space complexity is O(1) as we are using only a few variables to store the results.\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int previous=0,n=intervals.size(),ans=0;\\n        for(int current=1;current<n;current++){\\n            if(intervals[current][0]<intervals[previous][1]){\\n                ans++;\\n                 if(intervals[current][1]<=intervals[previous][1]){\\n          previous=current;//[1][5],[3][4]then previous will become[3][4]\\n            }\\n            }else{\\n                previous=current;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786018,
                "title": "easy-solution-using-greedy-0-nlogn",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int ans=0;\\n        sort(intervals.begin(),intervals.end());\\n        int prev=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<prev){\\n                ans++;\\n                prev=min(prev,intervals[i][1]);\\n            }else\\n                prev=intervals[i][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int ans=0;\\n        sort(intervals.begin(),intervals.end());\\n        int prev=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<prev){\\n                ans++;\\n                prev=min(prev,intervals[i][1]);\\n            }else\\n                prev=intervals[i][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785990,
                "title": "beginner-s-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        int cnt = 0;\\n        int j = 0;\\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (intervals[j][1] > intervals[i][0]) {\\n                cnt++;\\n                if (intervals[j][1] > intervals[i][1]) {\\n                    j = i;\\n                }\\n            } else {\\n                j = i;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        int cnt = 0;\\n        int j = 0;\\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (intervals[j][1] > intervals[i][0]) {\\n                cnt++;\\n                if (intervals[j][1] > intervals[i][1]) {\\n                    j = i;\\n                }\\n            } else {\\n                j = i;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785984,
                "title": "java-easy-2d-matrix-sorting-greedy",
                "content": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals,(a, b) -> Integer.compare(a[1], b[1]));\\n        int clash = 0;\\n        int preEndTime = Integer.MIN_VALUE;\\n        \\n        for (int i = 0; i < intervals.length; i++) {\\n            int start = intervals[i][0];\\n            int end = intervals[i][1];\\n            if ( start>= preEndTime) {\\n                preEndTime = end;\\n            } \\n            else {\\n                clash++;\\n            }\\n        }\\n        \\n        return clash;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals,(a, b) -> Integer.compare(a[1], b[1]));\\n        int clash = 0;\\n        int preEndTime = Integer.MIN_VALUE;\\n        \\n        for (int i = 0; i < intervals.length; i++) {\\n            int start = intervals[i][0];\\n            int end = intervals[i][1];\\n            if ( start>= preEndTime) {\\n                preEndTime = end;\\n            } \\n            else {\\n                clash++;\\n            }\\n        }\\n        \\n        return clash;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785855,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()\\n        ans=0\\n        prevEnd=intervals[0][1]\\n        for start,end in intervals[1:]:\\n            if start>=prevEnd:\\n                prevEnd=end\\n\\n            else:\\n                ans+=1\\n                prevEnd=min(end,prevEnd) \\n\\n        return ans           \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()\\n        ans=0\\n        prevEnd=intervals[0][1]\\n        for start,end in intervals[1:]:\\n            if start>=prevEnd:\\n                prevEnd=end\\n\\n            else:\\n                ans+=1\\n                prevEnd=min(end,prevEnd) \\n\\n        return ans           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785548,
                "title": "beats-99-45-c-using-sorting-and-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConvert the intervals from a 2D vector to a vector of pairs, where each pair represents an interval\\'s start and end points.\\n\\nSort the intervals based on their start points in ascending order.\\n\\nIterate through the sorted intervals and keep track of the current end point.\\n\\nIf the start point of the current interval is greater than or equal to the current end point, increment a counter (c) to count non-overlapping intervals and update the current end point.\\n\\nIf the start point of the current interval is less than the current end point, there is an overlap. Increment a counter (d) to count overlapping intervals. If the end point of the current interval is smaller than the current end point, update the current end point accordingly.\\n\\nAfter processing all intervals, return the value of d, which represents the minimum number of intervals that need to be removed to make the remaining intervals non-overlapping.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<intervals.size();i++){\\n            v.push_back(make_pair(intervals[i][0],intervals[i][1]));\\n        }\\n        int c=0,d=0;\\n         sort(v.begin(),v.end());\\n        int a=v[0].second;\\n        for(int i=1;i<v.size();i++){\\n             if(v[i].first>=a){c++;a=v[i].second;}\\n             else if(a<=v[i].second){\\n                d++;\\n             }\\n             else if(a>v[i].second){\\n                  d++;\\n                  a=v[i].second;\\n             }\\n        }\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<intervals.size();i++){\\n            v.push_back(make_pair(intervals[i][0],intervals[i][1]));\\n        }\\n        int c=0,d=0;\\n         sort(v.begin(),v.end());\\n        int a=v[0].second;\\n        for(int i=1;i<v.size();i++){\\n             if(v[i].first>=a){c++;a=v[i].second;}\\n             else if(a<=v[i].second){\\n                d++;\\n             }\\n             else if(a>v[i].second){\\n                  d++;\\n                  a=v[i].second;\\n             }\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785426,
                "title": "c-easy-sort-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdeally each interval should start only when the previous interval is over so that there is no overlap.\\nSo they should be arranged according to their ending value. \\n\\nFor the test case 1-2,2-3,3-4,1-3\\nIf it is arranged according to its ending value:-\\n1-2,1-3,2-3,3-4\\n\\nNow we can see 1-3 is overlapping with 1-2.\\nSo we need to remove 1 interval.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will sort the intervals according to their ending value and check for the overlapping intervals.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(nlogn) \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(begin(intervals),end(intervals),[](const auto &interval1,const auto &interval2){\\n            return interval1[1]< interval2[1];\\n        }); \\n        //over variable to store the last interval\\'s finishing time\\n        int over=intervals[0][0],ans=0;\\n        for(auto it:intervals) \\n        {\\n            if(it[0]>=over) \\n            {\\n                over=it[1];\\n            } \\n            else \\n            {\\n                ans++;\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(begin(intervals),end(intervals),[](const auto &interval1,const auto &interval2){\\n            return interval1[1]< interval2[1];\\n        }); \\n        //over variable to store the last interval\\'s finishing time\\n        int over=intervals[0][0],ans=0;\\n        for(auto it:intervals) \\n        {\\n            if(it[0]>=over) \\n            {\\n                over=it[1];\\n            } \\n            else \\n            {\\n                ans++;\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768265,
                "title": "easy-solution-using-java-beat-94-37",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\\n        int end = intervals[0][1];\\n        int current = 1;\\n        for(int i = 1; i < intervals.length; i++)\\n        {\\n            if(intervals[i][0] >= end)\\n            {\\n                end = intervals[i][1];\\n                current++;\\n            }\\n        }  \\n        return intervals.length - current;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\\n        int end = intervals[0][1];\\n        int current = 1;\\n        for(int i = 1; i < intervals.length; i++)\\n        {\\n            if(intervals[i][0] >= end)\\n            {\\n                end = intervals[i][1];\\n                current++;\\n            }\\n        }  \\n        return intervals.length - current;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748291,
                "title": "clean-and-easy-code-binary-search-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAs contraints are 10^5 we need some method to find the previous non overlaping interval.We will use binary search for it.So our solution runs in 0(nlogn).For each interval we have two choices-1->Take it and find previous non overlapping interval using binary search.2->Leave it\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlon(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a,vector<int>& b)\\n    {\\n        return a[1]<b[1];\\n    }\\n    int calc(int i,vector<vector<int>>& seg)\\n    {\\n        int l=0;\\n        int r=i-1;\\n        int req_l=seg[i][0];\\n        int ans=-1;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            int m_r=seg[mid][1];\\n            if(m_r<=req_l)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int eraseOverlapIntervals(vector<vector<int>>& seg) {\\n        sort(seg.begin(),seg.end(),cmp);\\n\\n        int n=seg.size();\\n        vector<int> dp(n+1,INT_MAX);\\n        dp[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            //take it \\n            int pre=calc(i,seg);\\n            int left=i-pre-1;\\n            if(pre!=-1)\\n            {\\n                dp[i]=min(dp[i],dp[pre]+left);\\n            }\\n            dp[i]=min(dp[i],dp[i-1]+1);\\n\\n            //leave it\\n        }\\n        return dp[n-1];\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a,vector<int>& b)\\n    {\\n        return a[1]<b[1];\\n    }\\n    int calc(int i,vector<vector<int>>& seg)\\n    {\\n        int l=0;\\n        int r=i-1;\\n        int req_l=seg[i][0];\\n        int ans=-1;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            int m_r=seg[mid][1];\\n            if(m_r<=req_l)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int eraseOverlapIntervals(vector<vector<int>>& seg) {\\n        sort(seg.begin(),seg.end(),cmp);\\n\\n        int n=seg.size();\\n        vector<int> dp(n+1,INT_MAX);\\n        dp[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            //take it \\n            int pre=calc(i,seg);\\n            int left=i-pre-1;\\n            if(pre!=-1)\\n            {\\n                dp[i]=min(dp[i],dp[pre]+left);\\n            }\\n            dp[i]=min(dp[i],dp[i-1]+1);\\n\\n            //leave it\\n        }\\n        return dp[n-1];\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701450,
                "title": "c-cleanest-code-time-o-nlogn-space-o-1",
                "content": "# Intuition\\n-Greedy approach\\n-we are to do minimum merges so that count is minimum\\n\\n# Approach\\n-First sort the array according to the starting index.\\n-Then iterate over the array from index=1;\\n-If the current interval can be merged with the previous interval,\\nincrease the cnt by 1 and replace the ending index of the current interval with the minimum ending index of both the intervals. As we want minimum merges possible as we are solving the problem greedily.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int cnt=0;\\n        sort(intervals.begin(),intervals.end());\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<intervals[i-1][1])\\n                {\\n                    cnt++;\\n                    intervals[i][1]=min(intervals[i-1][1],intervals[i][1]);\\n                }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        int cnt=0;\\n        sort(intervals.begin(),intervals.end());\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<intervals[i-1][1])\\n                {\\n                    cnt++;\\n                    intervals[i][1]=min(intervals[i-1][1],intervals[i][1]);\\n                }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483694,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b)-> a[0]-b[0] );\\n        int[] pre=intervals[0];\\n        int res=0;\\n        for(int i=1;i<intervals.length;i++){\\n            int[] cur=intervals[i];\\n            if(cur[0]<pre[1]){ //overlapping\\n                res++;\\n                if(pre[1]<=cur[1])\\n                    continue;\\n            }\\n            pre=cur;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b)-> a[0]-b[0] );\\n        int[] pre=intervals[0];\\n        int res=0;\\n        for(int i=1;i<intervals.length;i++){\\n            int[] cur=intervals[i];\\n            if(cur[0]<pre[1]){ //overlapping\\n                res++;\\n                if(pre[1]<=cur[1])\\n                    continue;\\n            }\\n            pre=cur;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576818,
                "content": [
                    {
                        "username": "ZimmAgu",
                        "content": "#### Initial Steps\\n* Sort the given intervals based on starting points\\n* While considering the intervals in the ascending order of starting points\\n\\t* we make use of a pointer prev pointer \\n\\t* to keep track of the interval just included in the final list\\n![image](https://assets.leetcode.com/users/images/515fa83b-44c2-4c42-8ef5-d41c7942ec32_1653774876.169032.jpeg)\\n\\n\\n\\n#### Case 1\\n* You don\\'t need to remove any intervals\\n* Continue by simply assigning the *prev* pointer to the later interval\\n* The count of intervals removed remains unchanged\\n\\n\\n#### Case 2\\n* Remove the interval with the later end point \\n* The *prev* pointer is updated to current interval\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Case 3\\n* Remove the interval with the later end point \\n* The *prev* pointer remains unchanged\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Rule of Thumb\\n* Always choose the interval that ends first\\n\\n"
                    },
                    {
                        "username": "Muhammadamin",
                        "content": "[@rohitanjane999](/rohitanjane999)  + "
                    },
                    {
                        "username": "MayuD",
                        "content": "Thank you\nThe second case had got me"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "That was really good...thanks"
                    },
                    {
                        "username": "0x415374",
                        "content": "Pretty intuitive! Unfortunately I was not able to figure this out in a reasonable amount of time."
                    },
                    {
                        "username": "voodooism",
                        "content": "with this explanation the problem becomes easy!\\nthanks!"
                    },
                    {
                        "username": "rohitanjane999",
                        "content": "thanks for explanation...."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "And this marks my 200 days of streak..."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "So i\\'m not alone. [@sarpalmadhav](/sarpalmadhav)[@Ashutosh kumar](/ashurockzz) We started on jan1. Hope we complete our 365 days challenge."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ashu0123](/ashu0123) Congrats! Same here. I too have hit 200. We both started on Jan 1!!\\n"
                    },
                    {
                        "username": "ashu0123",
                        "content": "Looks like you\\'ve used Time travel tickets"
                    },
                    {
                        "username": "oops_moment",
                        "content": "If you\\'ve already cracked this challenging problem, kudos to you! If not, fret not! Let\\'s go step by step to find the perfect solution together! \\uD83D\\uDCAA\\n\\n\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F Problem Analysis:\\nWe\\'re given an array of intervals, and the goal is to find the minimum number of intervals to remove to make the rest non-overlapping. To achieve this, we\\'ll apply the greedy approach.\\n\\n\\u2B50 Greedy Insight:\\nLet\\'s try out a few greedy strategies. Say we select the interval with the smallest start time. Oops! This fails when the interval with the smallest start time also happens to be the longest one, leading to many overlapping intervals that need to be discarded.\\n\\n\\uD83D\\uDCA1 The Winning Greedy Strategy:\\nInstead, let\\'s sort the intervals based on their end times. Why? Imagine two intervals, one ending at x and the other ending at y (where x < y). If we skip the interval ending at x and take the one ending at y, we\\'ll may have to remove at least one interval that starts in the range (x, y). So, we should always sort based on the end time of intervals.\\n\\n\\uD83D\\uDEE0\\uFE0F Implementation:\\n\\n1: Sort the intervals based on their end times in ascending order.\\n\\n2: Initialize a variable \\'answer\\' to keep track of the number of intervals to be removed.\\n\\n3: Consider the first interval as \\'last\\' or the last taken interval.\\n\\n4: Iterate through the intervals, and for each interval:\\n\\n- If the current interval\\'s start time is less than the end time of the \\'last\\' interval, they overlap. Increment \\'answer\\' as we need to remove an interval to avoid overlap.\\n\\n- Otherwise, update \\'last\\' to the current interval.\\n\\n5: Return the final value of answer.\\n\\nNow you can confidently explain this solution to others and spread the joy of problem-solving! Happy coding! \\uD83D\\uDE80"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I don\\'t get why sorting by the end of the range helps.\\nI did\\n```\\nintervals.sort(key=lambda x: x[1])\\n```"
                    },
                    {
                        "username": "jkswapnil99",
                        "content": "Why is greedy solution correct for this problem. How do we know that, of all the ways in which intervals can be deleted the greedy approach is the optimal strategy?\\n\\nI always have trouble proving this for greedy solutions"
                    },
                    {
                        "username": "aLaN09",
                        "content": "[@bparanj](/bparanj) Nicely written"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The \"proof\" does not convince me for at least a two reasons:\\n\\n1) If there is an optimal solution different from ours, why must there an interval `i` with end time larger than ours?\\n2) We have no idea where `x` starts, how do we guarantee adding `x` after removing `i` won\\'t introduce conflicts?\\n\\nSince this is a classic problem - the proof is publicly available - all we needed is to do some search. For example, there is a one liner proof on wikipedia here. https://en.wikipedia.org/wiki/Interval_scheduling#Unweighted"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand your confusion. Proving the correctness of a greedy solution can often be tricky. For this particular problem, we could demonstrate the greedy choice property and optimal substructure, two key characteristics of problems that can be solved using a greedy approach.\\n\\nThe **greedy choice property** means that a local optimum can lead to a global optimum. For this problem, the local optimum is to always select the interval with the earliest end time that doesn\\'t overlap with the current one. This choice leaves as much space as possible for the remaining intervals. If we can prove that making the greedy choice at each step leads to the solution of the overall problem, then we\\'ve shown the greedy choice property.\\n\\nThe **optimal substructure** means that an optimal solution to the problem can be constructed efficiently from optimal solutions to its subproblems. In this problem, once we make the greedy choice of picking the interval with the earliest end time, we\\'re left with a smaller subproblem: finding the optimal solution in the remaining intervals.\\n\\nHere\\'s the intuition for why this greedy strategy works:\\n\\nThe crucial observation is that the interval with the earliest end time is least likely to overlap with other intervals. Hence, keeping this interval in our solution gives us the maximum space to accommodate the remaining intervals, which in turn reduces the number of removals. \\n\\nNow, let\\'s say there\\'s an optimal solution different from ours that keeps an interval `i` with an end time later than the one we chose (let\\'s call our interval `x`). We can replace `i` with `x` in this solution, and it\\'s guaranteed not to create more overlaps because `x` ends earlier than `i`. Therefore, the new solution is still optimal, showing that our greedy choice doesn\\'t lead to a worse solution.\\n\\nThis demonstrates that the greedy choice leads to an optimal solution and that the problem has an optimal substructure, thus validating our greedy solution."
                    },
                    {
                        "username": "abhay3141",
                        "content": "Getting Time limit Exceeded even though all 58/58 case passed. Any help ?"
                    },
                    {
                        "username": "jason3410",
                        "content": "You could just regard it as a regular TLE . It\\'s just a relatively closer one."
                    },
                    {
                        "username": "spookyflame",
                        "content": "[@cqrbala](/cqrbala) ty it worked. Forgot about that lmao"
                    },
                    {
                        "username": "cqrbala",
                        "content": "[@tanisha_daharwal](/tanisha_daharwal) [@Abhay](/abhay3141) Try to pass the vectors in the comparison function by reference (using & in c++). It is much faster as there is no need to make a copy of the vectors to perform the comparison."
                    },
                    {
                        "username": "tanisha_daharwal",
                        "content": "same thing happening with me"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Task failed successfully!"
                    },
                    {
                        "username": "ashu-xx",
                        "content": "[[1,100],[11,22],[1,11],[2,12]] \\nExpect: 2\\n\\nAccording to me expected answer should be 3 because [1,100] cannot be removed and all other 3 intervals are sub-intervals of [1,100].\\n\\nCan someone explain why is expected answer 2?"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "[@Ashutosh Mittal](/ashu-xx) in above case when we consider [1, 100] it will remove 3  other interval. but there a one option remain ie Consider [11,22] and [1, 11] than there is two inverval which are overlapping with these two [1,100] and [2,12] from the two option 3,  2, 2 option minimum so the result should be 2"
                    },
                    {
                        "username": "sasimouni",
                        "content": "[@bparanj](/bparanj)  nice explanation "
                    },
                    {
                        "username": "vermadeepesh248",
                        "content": "question said to remove minimum number of intervals. \\n\\nif we let [1,100] stay then we have to remove remaining three intervals.\\nbut instead if we remove [1,100] and [2,12] then we can let [1,11] and [11,22] stay. In this case we are removing only 2 intervals. so output should be 2."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@ShaliniMishra31](/ShaliniMishra31) [@ShaliniMishra31](/ShaliniMishra31) Your approach is not completely incorrect, but it\\'s not the most optimal one. In your solution, you are trying to represent the intervals on a number line and mark the occupied points. However, this approach has a couple of significant issues:\\n\\n1. It doesn\\'t consider the interval as a whole. Intervals are more than just individual points on a line, and their overlaps can\\'t always be accurately represented by the overlap of individual points.\\n\\n2. It doesn\\'t correctly account for the case when a smaller interval is entirely within a larger one. Your solution may consider the larger interval to be overlapping, even if removing the smaller one would make all intervals non-overlapping.\\n\\n3. Your solution has a time complexity of O(N^2), which is not efficient for large inputs.\\n\\nHere is an optimal solution using the greedy algorithm. It sorts the intervals by their end time and always tries to keep the one that ends earlier. This approach ensures we have more room for the remaining intervals.\\n\\nIn C++, it would look something like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 0) return 0;\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int ans = 0, end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i][0] < end){\\n                ans++;\\n            }\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution, we first sort the intervals by their end time. Then, we iterate over the sorted intervals. For each interval, if its start time is less than the end time of the previous interval, we increment our count (as it\\'s overlapping and needs to be removed). Otherwise, we update our end time to the current interval\\'s end time. This solution has a time complexity of O(N log N), which is more efficient."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected answer is 2 because the optimal solution doesn\\'t necessarily require keeping the interval [1,100]. It seems like you\\'re operating under the assumption that the larger interval has to be kept, but that\\'s not always the case.\\n\\nLet\\'s examine the problem with the given list of intervals:\\n\\n[[1,100],[11,22],[1,11],[2,12]]\\n\\nA key point to remember is that the objective is to minimize the number of removals so as to make the remaining intervals non-overlapping. To achieve this, the optimal strategy involves removing the intervals that cause the most overlaps. In this case, interval [1,100] overlaps with all other intervals, so if we keep it, we\\'d need to remove all other intervals, which is not optimal.\\n\\nInstead, if we remove [1,100], we\\'re left with:\\n\\n[[11,22],[1,11],[2,12]]\\n\\nOut of these, [1,11] and [11,22] don\\'t overlap. However, [2,12] overlaps with both. Thus, we can remove [2,12] to make the remaining intervals non-overlapping. This way, we only need to remove 2 intervals ([1,100] and [2,12]), which is why the expected answer is 2."
                    },
                    {
                        "username": "ShaliniMishra31",
                        "content": "[@cpblnc](/cpblnc) Could you explain again?\nI have the same doubt \n\nHere is my solution:\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        vector <pair<int,int>> vec(100000, {0,0});\n        int ans = 0;\n        for(int i=0;i<intervals.size();i++)\n        {\n            int f = intervals[i][0];\n            int s = intervals[i][1];\n            int dif = s-f;\n            int c = 0;\n            for(int j=f;j<=s;j++)\n            {\n                if(vec[j].second != 1)\n                {\n                    vec[j].first = j;\n                    vec[j].second = 1;\n                }\n                else\n                {\n                    c++;\n                }\n            }\n            if(c > dif)\n            {\n                ans++;\n            }\n        }\n        return(ans);\n    }\n};\n"
                    },
                    {
                        "username": "cpblnc",
                        "content": "Why can\\'t [1,100] be removed? If you remove it and [2,12] as well, you are left with [1,11] and [11,22], which are non overlapping - 2 intervals got removed, as expected."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Sort & Greedy make people happy!"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After I saw this problem, My first thought was to use `Binary Search` with `DP` and solved it."
                    },
                    {
                        "username": "sunny8080",
                        "content": "[@ashish15678](/ashish15678) For every index, find next non-overlapping intervel using `Binary Search`. \\nFor more, just take a look at [My Solution](https://leetcode.com/problems/non-overlapping-intervals/solutions/3788241/c-java-easy-and-clean-code-dp-greedy-beats/)"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@ashish15678](/ashish15678)  u can see my soln, i also did it using DP and Binary Search. \\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/solutions/3789308/dp-binary-search-solution/"
                    },
                    {
                        "username": "ashish15678",
                        "content": "can you please explain more\\n"
                    },
                    {
                        "username": "user4653c",
                        "content": "Labeling this problem as Dynamic Programming is a bit of a nasty move. To solve it, you need to find the right intuition, attempting the DP approach will just make things more confusing"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@Charlemagne5t](/Charlemagne5t) well true it can be difficult, trying joting down all possible scenarios and see if your greedy (or any other) approach works, if it does then try to find a justification for it, sometimes u may pass the question by implementing a approach but can\\'t think of a proof of it, can happen if the proof is mathematically rigorous "
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Agreed. Tried straight forward recursion + caching and got TLE 54/58. What I like about this approach it guarantees the right answer. Greedy is more optimal solution, but how do I prove it in real world problems when I don\\'t have rich test cases sample. I need to improve my knowledge in that field I guess. "
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "It's easy to think that:\\n- If we count the overlapping times with each interval. \\n- Then, for each time we remove the interval with most overlapping interval(let's call it A)\\n- And we update the other intervals' overlapping time which is overlapped with A.\\n- When all interval has zero overlapping times, we get the result.\\n\\nI know how to do it in greedy in O(nlgn) time, but I wonder why this cant work... \\nThis idea failed in the last test case(that with 10k inputs).I can't figure out why... Can someone help me?please...?\\nThanks your time for seeing these. Thank you~"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@nsut_coder](/nsut_coder) It would still not work if we remove all duplicates. Consider the same example, but add small random fractional values to each start and end. No duplicates, but the answer remains the same,"
                    },
                    {
                        "username": "bparanj",
                        "content": "The strategy you described is known as the \"interval graph coloring\" problem and it\\'s not equivalent to the interval scheduling problem we are solving here. You are describing an approach in which we try to color intervals (remove as few as possible) such that no two overlapping intervals share the same color. That is a more complicated problem and is not what we are trying to solve here.\\n\\nYou are trying to remove the interval that has the most overlaps first. This approach does not always lead to the optimal solution. Consider the following example:\\n\\n[[1, 5], [2, 3], [3, 4], [4, 5]]\\n\\nIf we follow your approach, we\\'ll remove [1, 5] first, because it overlaps with the most intervals. But this leads to the need of removing 1 interval, while the optimal solution would be to remove none. If we select [2, 3], [3, 4], [4, 5], we can see that none of these intervals overlap, which leads to the optimal solution of 0 removals.\\n\\nThis shows why the greedy algorithm of always choosing the interval that ends the earliest works: it leaves the most room for the rest of the intervals to not overlap.\\n\\nSo the intuition for the greedy algorithm in this problem is: the sooner an interval ends, the more room we have for the rest of the intervals to fit in without overlapping. It\\'s about looking ahead and trying to leave as much room as possible for the future intervals."
                    },
                    {
                        "username": "nsut_coder",
                        "content": "[@bharathi1121](/bharathi1121) I think, algorithm would work if we remove the duplicate ranges. but how would algorithm decide which interval to remove when all of them are overlapping with same number of intervals. "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "It doesnt work because its not always the largest overlapping interval to be removed first,\\nex: [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]\\nin this example the largest overlapping interval is [2,4] but it is part of the answer."
                    }
                ]
            },
            {
                "id": 1976678,
                "content": [
                    {
                        "username": "ZimmAgu",
                        "content": "#### Initial Steps\\n* Sort the given intervals based on starting points\\n* While considering the intervals in the ascending order of starting points\\n\\t* we make use of a pointer prev pointer \\n\\t* to keep track of the interval just included in the final list\\n![image](https://assets.leetcode.com/users/images/515fa83b-44c2-4c42-8ef5-d41c7942ec32_1653774876.169032.jpeg)\\n\\n\\n\\n#### Case 1\\n* You don\\'t need to remove any intervals\\n* Continue by simply assigning the *prev* pointer to the later interval\\n* The count of intervals removed remains unchanged\\n\\n\\n#### Case 2\\n* Remove the interval with the later end point \\n* The *prev* pointer is updated to current interval\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Case 3\\n* Remove the interval with the later end point \\n* The *prev* pointer remains unchanged\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Rule of Thumb\\n* Always choose the interval that ends first\\n\\n"
                    },
                    {
                        "username": "Muhammadamin",
                        "content": "[@rohitanjane999](/rohitanjane999)  + "
                    },
                    {
                        "username": "MayuD",
                        "content": "Thank you\nThe second case had got me"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "That was really good...thanks"
                    },
                    {
                        "username": "0x415374",
                        "content": "Pretty intuitive! Unfortunately I was not able to figure this out in a reasonable amount of time."
                    },
                    {
                        "username": "voodooism",
                        "content": "with this explanation the problem becomes easy!\\nthanks!"
                    },
                    {
                        "username": "rohitanjane999",
                        "content": "thanks for explanation...."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "And this marks my 200 days of streak..."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "So i\\'m not alone. [@sarpalmadhav](/sarpalmadhav)[@Ashutosh kumar](/ashurockzz) We started on jan1. Hope we complete our 365 days challenge."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ashu0123](/ashu0123) Congrats! Same here. I too have hit 200. We both started on Jan 1!!\\n"
                    },
                    {
                        "username": "ashu0123",
                        "content": "Looks like you\\'ve used Time travel tickets"
                    },
                    {
                        "username": "oops_moment",
                        "content": "If you\\'ve already cracked this challenging problem, kudos to you! If not, fret not! Let\\'s go step by step to find the perfect solution together! \\uD83D\\uDCAA\\n\\n\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F Problem Analysis:\\nWe\\'re given an array of intervals, and the goal is to find the minimum number of intervals to remove to make the rest non-overlapping. To achieve this, we\\'ll apply the greedy approach.\\n\\n\\u2B50 Greedy Insight:\\nLet\\'s try out a few greedy strategies. Say we select the interval with the smallest start time. Oops! This fails when the interval with the smallest start time also happens to be the longest one, leading to many overlapping intervals that need to be discarded.\\n\\n\\uD83D\\uDCA1 The Winning Greedy Strategy:\\nInstead, let\\'s sort the intervals based on their end times. Why? Imagine two intervals, one ending at x and the other ending at y (where x < y). If we skip the interval ending at x and take the one ending at y, we\\'ll may have to remove at least one interval that starts in the range (x, y). So, we should always sort based on the end time of intervals.\\n\\n\\uD83D\\uDEE0\\uFE0F Implementation:\\n\\n1: Sort the intervals based on their end times in ascending order.\\n\\n2: Initialize a variable \\'answer\\' to keep track of the number of intervals to be removed.\\n\\n3: Consider the first interval as \\'last\\' or the last taken interval.\\n\\n4: Iterate through the intervals, and for each interval:\\n\\n- If the current interval\\'s start time is less than the end time of the \\'last\\' interval, they overlap. Increment \\'answer\\' as we need to remove an interval to avoid overlap.\\n\\n- Otherwise, update \\'last\\' to the current interval.\\n\\n5: Return the final value of answer.\\n\\nNow you can confidently explain this solution to others and spread the joy of problem-solving! Happy coding! \\uD83D\\uDE80"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I don\\'t get why sorting by the end of the range helps.\\nI did\\n```\\nintervals.sort(key=lambda x: x[1])\\n```"
                    },
                    {
                        "username": "jkswapnil99",
                        "content": "Why is greedy solution correct for this problem. How do we know that, of all the ways in which intervals can be deleted the greedy approach is the optimal strategy?\\n\\nI always have trouble proving this for greedy solutions"
                    },
                    {
                        "username": "aLaN09",
                        "content": "[@bparanj](/bparanj) Nicely written"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The \"proof\" does not convince me for at least a two reasons:\\n\\n1) If there is an optimal solution different from ours, why must there an interval `i` with end time larger than ours?\\n2) We have no idea where `x` starts, how do we guarantee adding `x` after removing `i` won\\'t introduce conflicts?\\n\\nSince this is a classic problem - the proof is publicly available - all we needed is to do some search. For example, there is a one liner proof on wikipedia here. https://en.wikipedia.org/wiki/Interval_scheduling#Unweighted"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand your confusion. Proving the correctness of a greedy solution can often be tricky. For this particular problem, we could demonstrate the greedy choice property and optimal substructure, two key characteristics of problems that can be solved using a greedy approach.\\n\\nThe **greedy choice property** means that a local optimum can lead to a global optimum. For this problem, the local optimum is to always select the interval with the earliest end time that doesn\\'t overlap with the current one. This choice leaves as much space as possible for the remaining intervals. If we can prove that making the greedy choice at each step leads to the solution of the overall problem, then we\\'ve shown the greedy choice property.\\n\\nThe **optimal substructure** means that an optimal solution to the problem can be constructed efficiently from optimal solutions to its subproblems. In this problem, once we make the greedy choice of picking the interval with the earliest end time, we\\'re left with a smaller subproblem: finding the optimal solution in the remaining intervals.\\n\\nHere\\'s the intuition for why this greedy strategy works:\\n\\nThe crucial observation is that the interval with the earliest end time is least likely to overlap with other intervals. Hence, keeping this interval in our solution gives us the maximum space to accommodate the remaining intervals, which in turn reduces the number of removals. \\n\\nNow, let\\'s say there\\'s an optimal solution different from ours that keeps an interval `i` with an end time later than the one we chose (let\\'s call our interval `x`). We can replace `i` with `x` in this solution, and it\\'s guaranteed not to create more overlaps because `x` ends earlier than `i`. Therefore, the new solution is still optimal, showing that our greedy choice doesn\\'t lead to a worse solution.\\n\\nThis demonstrates that the greedy choice leads to an optimal solution and that the problem has an optimal substructure, thus validating our greedy solution."
                    },
                    {
                        "username": "abhay3141",
                        "content": "Getting Time limit Exceeded even though all 58/58 case passed. Any help ?"
                    },
                    {
                        "username": "jason3410",
                        "content": "You could just regard it as a regular TLE . It\\'s just a relatively closer one."
                    },
                    {
                        "username": "spookyflame",
                        "content": "[@cqrbala](/cqrbala) ty it worked. Forgot about that lmao"
                    },
                    {
                        "username": "cqrbala",
                        "content": "[@tanisha_daharwal](/tanisha_daharwal) [@Abhay](/abhay3141) Try to pass the vectors in the comparison function by reference (using & in c++). It is much faster as there is no need to make a copy of the vectors to perform the comparison."
                    },
                    {
                        "username": "tanisha_daharwal",
                        "content": "same thing happening with me"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Task failed successfully!"
                    },
                    {
                        "username": "ashu-xx",
                        "content": "[[1,100],[11,22],[1,11],[2,12]] \\nExpect: 2\\n\\nAccording to me expected answer should be 3 because [1,100] cannot be removed and all other 3 intervals are sub-intervals of [1,100].\\n\\nCan someone explain why is expected answer 2?"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "[@Ashutosh Mittal](/ashu-xx) in above case when we consider [1, 100] it will remove 3  other interval. but there a one option remain ie Consider [11,22] and [1, 11] than there is two inverval which are overlapping with these two [1,100] and [2,12] from the two option 3,  2, 2 option minimum so the result should be 2"
                    },
                    {
                        "username": "sasimouni",
                        "content": "[@bparanj](/bparanj)  nice explanation "
                    },
                    {
                        "username": "vermadeepesh248",
                        "content": "question said to remove minimum number of intervals. \\n\\nif we let [1,100] stay then we have to remove remaining three intervals.\\nbut instead if we remove [1,100] and [2,12] then we can let [1,11] and [11,22] stay. In this case we are removing only 2 intervals. so output should be 2."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@ShaliniMishra31](/ShaliniMishra31) [@ShaliniMishra31](/ShaliniMishra31) Your approach is not completely incorrect, but it\\'s not the most optimal one. In your solution, you are trying to represent the intervals on a number line and mark the occupied points. However, this approach has a couple of significant issues:\\n\\n1. It doesn\\'t consider the interval as a whole. Intervals are more than just individual points on a line, and their overlaps can\\'t always be accurately represented by the overlap of individual points.\\n\\n2. It doesn\\'t correctly account for the case when a smaller interval is entirely within a larger one. Your solution may consider the larger interval to be overlapping, even if removing the smaller one would make all intervals non-overlapping.\\n\\n3. Your solution has a time complexity of O(N^2), which is not efficient for large inputs.\\n\\nHere is an optimal solution using the greedy algorithm. It sorts the intervals by their end time and always tries to keep the one that ends earlier. This approach ensures we have more room for the remaining intervals.\\n\\nIn C++, it would look something like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 0) return 0;\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int ans = 0, end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i][0] < end){\\n                ans++;\\n            }\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution, we first sort the intervals by their end time. Then, we iterate over the sorted intervals. For each interval, if its start time is less than the end time of the previous interval, we increment our count (as it\\'s overlapping and needs to be removed). Otherwise, we update our end time to the current interval\\'s end time. This solution has a time complexity of O(N log N), which is more efficient."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected answer is 2 because the optimal solution doesn\\'t necessarily require keeping the interval [1,100]. It seems like you\\'re operating under the assumption that the larger interval has to be kept, but that\\'s not always the case.\\n\\nLet\\'s examine the problem with the given list of intervals:\\n\\n[[1,100],[11,22],[1,11],[2,12]]\\n\\nA key point to remember is that the objective is to minimize the number of removals so as to make the remaining intervals non-overlapping. To achieve this, the optimal strategy involves removing the intervals that cause the most overlaps. In this case, interval [1,100] overlaps with all other intervals, so if we keep it, we\\'d need to remove all other intervals, which is not optimal.\\n\\nInstead, if we remove [1,100], we\\'re left with:\\n\\n[[11,22],[1,11],[2,12]]\\n\\nOut of these, [1,11] and [11,22] don\\'t overlap. However, [2,12] overlaps with both. Thus, we can remove [2,12] to make the remaining intervals non-overlapping. This way, we only need to remove 2 intervals ([1,100] and [2,12]), which is why the expected answer is 2."
                    },
                    {
                        "username": "ShaliniMishra31",
                        "content": "[@cpblnc](/cpblnc) Could you explain again?\nI have the same doubt \n\nHere is my solution:\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        vector <pair<int,int>> vec(100000, {0,0});\n        int ans = 0;\n        for(int i=0;i<intervals.size();i++)\n        {\n            int f = intervals[i][0];\n            int s = intervals[i][1];\n            int dif = s-f;\n            int c = 0;\n            for(int j=f;j<=s;j++)\n            {\n                if(vec[j].second != 1)\n                {\n                    vec[j].first = j;\n                    vec[j].second = 1;\n                }\n                else\n                {\n                    c++;\n                }\n            }\n            if(c > dif)\n            {\n                ans++;\n            }\n        }\n        return(ans);\n    }\n};\n"
                    },
                    {
                        "username": "cpblnc",
                        "content": "Why can\\'t [1,100] be removed? If you remove it and [2,12] as well, you are left with [1,11] and [11,22], which are non overlapping - 2 intervals got removed, as expected."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Sort & Greedy make people happy!"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After I saw this problem, My first thought was to use `Binary Search` with `DP` and solved it."
                    },
                    {
                        "username": "sunny8080",
                        "content": "[@ashish15678](/ashish15678) For every index, find next non-overlapping intervel using `Binary Search`. \\nFor more, just take a look at [My Solution](https://leetcode.com/problems/non-overlapping-intervals/solutions/3788241/c-java-easy-and-clean-code-dp-greedy-beats/)"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@ashish15678](/ashish15678)  u can see my soln, i also did it using DP and Binary Search. \\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/solutions/3789308/dp-binary-search-solution/"
                    },
                    {
                        "username": "ashish15678",
                        "content": "can you please explain more\\n"
                    },
                    {
                        "username": "user4653c",
                        "content": "Labeling this problem as Dynamic Programming is a bit of a nasty move. To solve it, you need to find the right intuition, attempting the DP approach will just make things more confusing"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@Charlemagne5t](/Charlemagne5t) well true it can be difficult, trying joting down all possible scenarios and see if your greedy (or any other) approach works, if it does then try to find a justification for it, sometimes u may pass the question by implementing a approach but can\\'t think of a proof of it, can happen if the proof is mathematically rigorous "
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Agreed. Tried straight forward recursion + caching and got TLE 54/58. What I like about this approach it guarantees the right answer. Greedy is more optimal solution, but how do I prove it in real world problems when I don\\'t have rich test cases sample. I need to improve my knowledge in that field I guess. "
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "It's easy to think that:\\n- If we count the overlapping times with each interval. \\n- Then, for each time we remove the interval with most overlapping interval(let's call it A)\\n- And we update the other intervals' overlapping time which is overlapped with A.\\n- When all interval has zero overlapping times, we get the result.\\n\\nI know how to do it in greedy in O(nlgn) time, but I wonder why this cant work... \\nThis idea failed in the last test case(that with 10k inputs).I can't figure out why... Can someone help me?please...?\\nThanks your time for seeing these. Thank you~"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@nsut_coder](/nsut_coder) It would still not work if we remove all duplicates. Consider the same example, but add small random fractional values to each start and end. No duplicates, but the answer remains the same,"
                    },
                    {
                        "username": "bparanj",
                        "content": "The strategy you described is known as the \"interval graph coloring\" problem and it\\'s not equivalent to the interval scheduling problem we are solving here. You are describing an approach in which we try to color intervals (remove as few as possible) such that no two overlapping intervals share the same color. That is a more complicated problem and is not what we are trying to solve here.\\n\\nYou are trying to remove the interval that has the most overlaps first. This approach does not always lead to the optimal solution. Consider the following example:\\n\\n[[1, 5], [2, 3], [3, 4], [4, 5]]\\n\\nIf we follow your approach, we\\'ll remove [1, 5] first, because it overlaps with the most intervals. But this leads to the need of removing 1 interval, while the optimal solution would be to remove none. If we select [2, 3], [3, 4], [4, 5], we can see that none of these intervals overlap, which leads to the optimal solution of 0 removals.\\n\\nThis shows why the greedy algorithm of always choosing the interval that ends the earliest works: it leaves the most room for the rest of the intervals to not overlap.\\n\\nSo the intuition for the greedy algorithm in this problem is: the sooner an interval ends, the more room we have for the rest of the intervals to fit in without overlapping. It\\'s about looking ahead and trying to leave as much room as possible for the future intervals."
                    },
                    {
                        "username": "nsut_coder",
                        "content": "[@bharathi1121](/bharathi1121) I think, algorithm would work if we remove the duplicate ranges. but how would algorithm decide which interval to remove when all of them are overlapping with same number of intervals. "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "It doesnt work because its not always the largest overlapping interval to be removed first,\\nex: [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]\\nin this example the largest overlapping interval is [2,4] but it is part of the answer."
                    }
                ]
            },
            {
                "id": 1976804,
                "content": [
                    {
                        "username": "ZimmAgu",
                        "content": "#### Initial Steps\\n* Sort the given intervals based on starting points\\n* While considering the intervals in the ascending order of starting points\\n\\t* we make use of a pointer prev pointer \\n\\t* to keep track of the interval just included in the final list\\n![image](https://assets.leetcode.com/users/images/515fa83b-44c2-4c42-8ef5-d41c7942ec32_1653774876.169032.jpeg)\\n\\n\\n\\n#### Case 1\\n* You don\\'t need to remove any intervals\\n* Continue by simply assigning the *prev* pointer to the later interval\\n* The count of intervals removed remains unchanged\\n\\n\\n#### Case 2\\n* Remove the interval with the later end point \\n* The *prev* pointer is updated to current interval\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Case 3\\n* Remove the interval with the later end point \\n* The *prev* pointer remains unchanged\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Rule of Thumb\\n* Always choose the interval that ends first\\n\\n"
                    },
                    {
                        "username": "Muhammadamin",
                        "content": "[@rohitanjane999](/rohitanjane999)  + "
                    },
                    {
                        "username": "MayuD",
                        "content": "Thank you\nThe second case had got me"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "That was really good...thanks"
                    },
                    {
                        "username": "0x415374",
                        "content": "Pretty intuitive! Unfortunately I was not able to figure this out in a reasonable amount of time."
                    },
                    {
                        "username": "voodooism",
                        "content": "with this explanation the problem becomes easy!\\nthanks!"
                    },
                    {
                        "username": "rohitanjane999",
                        "content": "thanks for explanation...."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "And this marks my 200 days of streak..."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "So i\\'m not alone. [@sarpalmadhav](/sarpalmadhav)[@Ashutosh kumar](/ashurockzz) We started on jan1. Hope we complete our 365 days challenge."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ashu0123](/ashu0123) Congrats! Same here. I too have hit 200. We both started on Jan 1!!\\n"
                    },
                    {
                        "username": "ashu0123",
                        "content": "Looks like you\\'ve used Time travel tickets"
                    },
                    {
                        "username": "oops_moment",
                        "content": "If you\\'ve already cracked this challenging problem, kudos to you! If not, fret not! Let\\'s go step by step to find the perfect solution together! \\uD83D\\uDCAA\\n\\n\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F Problem Analysis:\\nWe\\'re given an array of intervals, and the goal is to find the minimum number of intervals to remove to make the rest non-overlapping. To achieve this, we\\'ll apply the greedy approach.\\n\\n\\u2B50 Greedy Insight:\\nLet\\'s try out a few greedy strategies. Say we select the interval with the smallest start time. Oops! This fails when the interval with the smallest start time also happens to be the longest one, leading to many overlapping intervals that need to be discarded.\\n\\n\\uD83D\\uDCA1 The Winning Greedy Strategy:\\nInstead, let\\'s sort the intervals based on their end times. Why? Imagine two intervals, one ending at x and the other ending at y (where x < y). If we skip the interval ending at x and take the one ending at y, we\\'ll may have to remove at least one interval that starts in the range (x, y). So, we should always sort based on the end time of intervals.\\n\\n\\uD83D\\uDEE0\\uFE0F Implementation:\\n\\n1: Sort the intervals based on their end times in ascending order.\\n\\n2: Initialize a variable \\'answer\\' to keep track of the number of intervals to be removed.\\n\\n3: Consider the first interval as \\'last\\' or the last taken interval.\\n\\n4: Iterate through the intervals, and for each interval:\\n\\n- If the current interval\\'s start time is less than the end time of the \\'last\\' interval, they overlap. Increment \\'answer\\' as we need to remove an interval to avoid overlap.\\n\\n- Otherwise, update \\'last\\' to the current interval.\\n\\n5: Return the final value of answer.\\n\\nNow you can confidently explain this solution to others and spread the joy of problem-solving! Happy coding! \\uD83D\\uDE80"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I don\\'t get why sorting by the end of the range helps.\\nI did\\n```\\nintervals.sort(key=lambda x: x[1])\\n```"
                    },
                    {
                        "username": "jkswapnil99",
                        "content": "Why is greedy solution correct for this problem. How do we know that, of all the ways in which intervals can be deleted the greedy approach is the optimal strategy?\\n\\nI always have trouble proving this for greedy solutions"
                    },
                    {
                        "username": "aLaN09",
                        "content": "[@bparanj](/bparanj) Nicely written"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The \"proof\" does not convince me for at least a two reasons:\\n\\n1) If there is an optimal solution different from ours, why must there an interval `i` with end time larger than ours?\\n2) We have no idea where `x` starts, how do we guarantee adding `x` after removing `i` won\\'t introduce conflicts?\\n\\nSince this is a classic problem - the proof is publicly available - all we needed is to do some search. For example, there is a one liner proof on wikipedia here. https://en.wikipedia.org/wiki/Interval_scheduling#Unweighted"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand your confusion. Proving the correctness of a greedy solution can often be tricky. For this particular problem, we could demonstrate the greedy choice property and optimal substructure, two key characteristics of problems that can be solved using a greedy approach.\\n\\nThe **greedy choice property** means that a local optimum can lead to a global optimum. For this problem, the local optimum is to always select the interval with the earliest end time that doesn\\'t overlap with the current one. This choice leaves as much space as possible for the remaining intervals. If we can prove that making the greedy choice at each step leads to the solution of the overall problem, then we\\'ve shown the greedy choice property.\\n\\nThe **optimal substructure** means that an optimal solution to the problem can be constructed efficiently from optimal solutions to its subproblems. In this problem, once we make the greedy choice of picking the interval with the earliest end time, we\\'re left with a smaller subproblem: finding the optimal solution in the remaining intervals.\\n\\nHere\\'s the intuition for why this greedy strategy works:\\n\\nThe crucial observation is that the interval with the earliest end time is least likely to overlap with other intervals. Hence, keeping this interval in our solution gives us the maximum space to accommodate the remaining intervals, which in turn reduces the number of removals. \\n\\nNow, let\\'s say there\\'s an optimal solution different from ours that keeps an interval `i` with an end time later than the one we chose (let\\'s call our interval `x`). We can replace `i` with `x` in this solution, and it\\'s guaranteed not to create more overlaps because `x` ends earlier than `i`. Therefore, the new solution is still optimal, showing that our greedy choice doesn\\'t lead to a worse solution.\\n\\nThis demonstrates that the greedy choice leads to an optimal solution and that the problem has an optimal substructure, thus validating our greedy solution."
                    },
                    {
                        "username": "abhay3141",
                        "content": "Getting Time limit Exceeded even though all 58/58 case passed. Any help ?"
                    },
                    {
                        "username": "jason3410",
                        "content": "You could just regard it as a regular TLE . It\\'s just a relatively closer one."
                    },
                    {
                        "username": "spookyflame",
                        "content": "[@cqrbala](/cqrbala) ty it worked. Forgot about that lmao"
                    },
                    {
                        "username": "cqrbala",
                        "content": "[@tanisha_daharwal](/tanisha_daharwal) [@Abhay](/abhay3141) Try to pass the vectors in the comparison function by reference (using & in c++). It is much faster as there is no need to make a copy of the vectors to perform the comparison."
                    },
                    {
                        "username": "tanisha_daharwal",
                        "content": "same thing happening with me"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Task failed successfully!"
                    },
                    {
                        "username": "ashu-xx",
                        "content": "[[1,100],[11,22],[1,11],[2,12]] \\nExpect: 2\\n\\nAccording to me expected answer should be 3 because [1,100] cannot be removed and all other 3 intervals are sub-intervals of [1,100].\\n\\nCan someone explain why is expected answer 2?"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "[@Ashutosh Mittal](/ashu-xx) in above case when we consider [1, 100] it will remove 3  other interval. but there a one option remain ie Consider [11,22] and [1, 11] than there is two inverval which are overlapping with these two [1,100] and [2,12] from the two option 3,  2, 2 option minimum so the result should be 2"
                    },
                    {
                        "username": "sasimouni",
                        "content": "[@bparanj](/bparanj)  nice explanation "
                    },
                    {
                        "username": "vermadeepesh248",
                        "content": "question said to remove minimum number of intervals. \\n\\nif we let [1,100] stay then we have to remove remaining three intervals.\\nbut instead if we remove [1,100] and [2,12] then we can let [1,11] and [11,22] stay. In this case we are removing only 2 intervals. so output should be 2."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@ShaliniMishra31](/ShaliniMishra31) [@ShaliniMishra31](/ShaliniMishra31) Your approach is not completely incorrect, but it\\'s not the most optimal one. In your solution, you are trying to represent the intervals on a number line and mark the occupied points. However, this approach has a couple of significant issues:\\n\\n1. It doesn\\'t consider the interval as a whole. Intervals are more than just individual points on a line, and their overlaps can\\'t always be accurately represented by the overlap of individual points.\\n\\n2. It doesn\\'t correctly account for the case when a smaller interval is entirely within a larger one. Your solution may consider the larger interval to be overlapping, even if removing the smaller one would make all intervals non-overlapping.\\n\\n3. Your solution has a time complexity of O(N^2), which is not efficient for large inputs.\\n\\nHere is an optimal solution using the greedy algorithm. It sorts the intervals by their end time and always tries to keep the one that ends earlier. This approach ensures we have more room for the remaining intervals.\\n\\nIn C++, it would look something like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 0) return 0;\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int ans = 0, end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i][0] < end){\\n                ans++;\\n            }\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution, we first sort the intervals by their end time. Then, we iterate over the sorted intervals. For each interval, if its start time is less than the end time of the previous interval, we increment our count (as it\\'s overlapping and needs to be removed). Otherwise, we update our end time to the current interval\\'s end time. This solution has a time complexity of O(N log N), which is more efficient."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected answer is 2 because the optimal solution doesn\\'t necessarily require keeping the interval [1,100]. It seems like you\\'re operating under the assumption that the larger interval has to be kept, but that\\'s not always the case.\\n\\nLet\\'s examine the problem with the given list of intervals:\\n\\n[[1,100],[11,22],[1,11],[2,12]]\\n\\nA key point to remember is that the objective is to minimize the number of removals so as to make the remaining intervals non-overlapping. To achieve this, the optimal strategy involves removing the intervals that cause the most overlaps. In this case, interval [1,100] overlaps with all other intervals, so if we keep it, we\\'d need to remove all other intervals, which is not optimal.\\n\\nInstead, if we remove [1,100], we\\'re left with:\\n\\n[[11,22],[1,11],[2,12]]\\n\\nOut of these, [1,11] and [11,22] don\\'t overlap. However, [2,12] overlaps with both. Thus, we can remove [2,12] to make the remaining intervals non-overlapping. This way, we only need to remove 2 intervals ([1,100] and [2,12]), which is why the expected answer is 2."
                    },
                    {
                        "username": "ShaliniMishra31",
                        "content": "[@cpblnc](/cpblnc) Could you explain again?\nI have the same doubt \n\nHere is my solution:\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        vector <pair<int,int>> vec(100000, {0,0});\n        int ans = 0;\n        for(int i=0;i<intervals.size();i++)\n        {\n            int f = intervals[i][0];\n            int s = intervals[i][1];\n            int dif = s-f;\n            int c = 0;\n            for(int j=f;j<=s;j++)\n            {\n                if(vec[j].second != 1)\n                {\n                    vec[j].first = j;\n                    vec[j].second = 1;\n                }\n                else\n                {\n                    c++;\n                }\n            }\n            if(c > dif)\n            {\n                ans++;\n            }\n        }\n        return(ans);\n    }\n};\n"
                    },
                    {
                        "username": "cpblnc",
                        "content": "Why can\\'t [1,100] be removed? If you remove it and [2,12] as well, you are left with [1,11] and [11,22], which are non overlapping - 2 intervals got removed, as expected."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Sort & Greedy make people happy!"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After I saw this problem, My first thought was to use `Binary Search` with `DP` and solved it."
                    },
                    {
                        "username": "sunny8080",
                        "content": "[@ashish15678](/ashish15678) For every index, find next non-overlapping intervel using `Binary Search`. \\nFor more, just take a look at [My Solution](https://leetcode.com/problems/non-overlapping-intervals/solutions/3788241/c-java-easy-and-clean-code-dp-greedy-beats/)"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@ashish15678](/ashish15678)  u can see my soln, i also did it using DP and Binary Search. \\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/solutions/3789308/dp-binary-search-solution/"
                    },
                    {
                        "username": "ashish15678",
                        "content": "can you please explain more\\n"
                    },
                    {
                        "username": "user4653c",
                        "content": "Labeling this problem as Dynamic Programming is a bit of a nasty move. To solve it, you need to find the right intuition, attempting the DP approach will just make things more confusing"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@Charlemagne5t](/Charlemagne5t) well true it can be difficult, trying joting down all possible scenarios and see if your greedy (or any other) approach works, if it does then try to find a justification for it, sometimes u may pass the question by implementing a approach but can\\'t think of a proof of it, can happen if the proof is mathematically rigorous "
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Agreed. Tried straight forward recursion + caching and got TLE 54/58. What I like about this approach it guarantees the right answer. Greedy is more optimal solution, but how do I prove it in real world problems when I don\\'t have rich test cases sample. I need to improve my knowledge in that field I guess. "
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "It's easy to think that:\\n- If we count the overlapping times with each interval. \\n- Then, for each time we remove the interval with most overlapping interval(let's call it A)\\n- And we update the other intervals' overlapping time which is overlapped with A.\\n- When all interval has zero overlapping times, we get the result.\\n\\nI know how to do it in greedy in O(nlgn) time, but I wonder why this cant work... \\nThis idea failed in the last test case(that with 10k inputs).I can't figure out why... Can someone help me?please...?\\nThanks your time for seeing these. Thank you~"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@nsut_coder](/nsut_coder) It would still not work if we remove all duplicates. Consider the same example, but add small random fractional values to each start and end. No duplicates, but the answer remains the same,"
                    },
                    {
                        "username": "bparanj",
                        "content": "The strategy you described is known as the \"interval graph coloring\" problem and it\\'s not equivalent to the interval scheduling problem we are solving here. You are describing an approach in which we try to color intervals (remove as few as possible) such that no two overlapping intervals share the same color. That is a more complicated problem and is not what we are trying to solve here.\\n\\nYou are trying to remove the interval that has the most overlaps first. This approach does not always lead to the optimal solution. Consider the following example:\\n\\n[[1, 5], [2, 3], [3, 4], [4, 5]]\\n\\nIf we follow your approach, we\\'ll remove [1, 5] first, because it overlaps with the most intervals. But this leads to the need of removing 1 interval, while the optimal solution would be to remove none. If we select [2, 3], [3, 4], [4, 5], we can see that none of these intervals overlap, which leads to the optimal solution of 0 removals.\\n\\nThis shows why the greedy algorithm of always choosing the interval that ends the earliest works: it leaves the most room for the rest of the intervals to not overlap.\\n\\nSo the intuition for the greedy algorithm in this problem is: the sooner an interval ends, the more room we have for the rest of the intervals to fit in without overlapping. It\\'s about looking ahead and trying to leave as much room as possible for the future intervals."
                    },
                    {
                        "username": "nsut_coder",
                        "content": "[@bharathi1121](/bharathi1121) I think, algorithm would work if we remove the duplicate ranges. but how would algorithm decide which interval to remove when all of them are overlapping with same number of intervals. "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "It doesnt work because its not always the largest overlapping interval to be removed first,\\nex: [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]\\nin this example the largest overlapping interval is [2,4] but it is part of the answer."
                    }
                ]
            },
            {
                "id": 1774241,
                "content": [
                    {
                        "username": "ZimmAgu",
                        "content": "#### Initial Steps\\n* Sort the given intervals based on starting points\\n* While considering the intervals in the ascending order of starting points\\n\\t* we make use of a pointer prev pointer \\n\\t* to keep track of the interval just included in the final list\\n![image](https://assets.leetcode.com/users/images/515fa83b-44c2-4c42-8ef5-d41c7942ec32_1653774876.169032.jpeg)\\n\\n\\n\\n#### Case 1\\n* You don\\'t need to remove any intervals\\n* Continue by simply assigning the *prev* pointer to the later interval\\n* The count of intervals removed remains unchanged\\n\\n\\n#### Case 2\\n* Remove the interval with the later end point \\n* The *prev* pointer is updated to current interval\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Case 3\\n* Remove the interval with the later end point \\n* The *prev* pointer remains unchanged\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Rule of Thumb\\n* Always choose the interval that ends first\\n\\n"
                    },
                    {
                        "username": "Muhammadamin",
                        "content": "[@rohitanjane999](/rohitanjane999)  + "
                    },
                    {
                        "username": "MayuD",
                        "content": "Thank you\nThe second case had got me"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "That was really good...thanks"
                    },
                    {
                        "username": "0x415374",
                        "content": "Pretty intuitive! Unfortunately I was not able to figure this out in a reasonable amount of time."
                    },
                    {
                        "username": "voodooism",
                        "content": "with this explanation the problem becomes easy!\\nthanks!"
                    },
                    {
                        "username": "rohitanjane999",
                        "content": "thanks for explanation...."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "And this marks my 200 days of streak..."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "So i\\'m not alone. [@sarpalmadhav](/sarpalmadhav)[@Ashutosh kumar](/ashurockzz) We started on jan1. Hope we complete our 365 days challenge."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ashu0123](/ashu0123) Congrats! Same here. I too have hit 200. We both started on Jan 1!!\\n"
                    },
                    {
                        "username": "ashu0123",
                        "content": "Looks like you\\'ve used Time travel tickets"
                    },
                    {
                        "username": "oops_moment",
                        "content": "If you\\'ve already cracked this challenging problem, kudos to you! If not, fret not! Let\\'s go step by step to find the perfect solution together! \\uD83D\\uDCAA\\n\\n\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F Problem Analysis:\\nWe\\'re given an array of intervals, and the goal is to find the minimum number of intervals to remove to make the rest non-overlapping. To achieve this, we\\'ll apply the greedy approach.\\n\\n\\u2B50 Greedy Insight:\\nLet\\'s try out a few greedy strategies. Say we select the interval with the smallest start time. Oops! This fails when the interval with the smallest start time also happens to be the longest one, leading to many overlapping intervals that need to be discarded.\\n\\n\\uD83D\\uDCA1 The Winning Greedy Strategy:\\nInstead, let\\'s sort the intervals based on their end times. Why? Imagine two intervals, one ending at x and the other ending at y (where x < y). If we skip the interval ending at x and take the one ending at y, we\\'ll may have to remove at least one interval that starts in the range (x, y). So, we should always sort based on the end time of intervals.\\n\\n\\uD83D\\uDEE0\\uFE0F Implementation:\\n\\n1: Sort the intervals based on their end times in ascending order.\\n\\n2: Initialize a variable \\'answer\\' to keep track of the number of intervals to be removed.\\n\\n3: Consider the first interval as \\'last\\' or the last taken interval.\\n\\n4: Iterate through the intervals, and for each interval:\\n\\n- If the current interval\\'s start time is less than the end time of the \\'last\\' interval, they overlap. Increment \\'answer\\' as we need to remove an interval to avoid overlap.\\n\\n- Otherwise, update \\'last\\' to the current interval.\\n\\n5: Return the final value of answer.\\n\\nNow you can confidently explain this solution to others and spread the joy of problem-solving! Happy coding! \\uD83D\\uDE80"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I don\\'t get why sorting by the end of the range helps.\\nI did\\n```\\nintervals.sort(key=lambda x: x[1])\\n```"
                    },
                    {
                        "username": "jkswapnil99",
                        "content": "Why is greedy solution correct for this problem. How do we know that, of all the ways in which intervals can be deleted the greedy approach is the optimal strategy?\\n\\nI always have trouble proving this for greedy solutions"
                    },
                    {
                        "username": "aLaN09",
                        "content": "[@bparanj](/bparanj) Nicely written"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The \"proof\" does not convince me for at least a two reasons:\\n\\n1) If there is an optimal solution different from ours, why must there an interval `i` with end time larger than ours?\\n2) We have no idea where `x` starts, how do we guarantee adding `x` after removing `i` won\\'t introduce conflicts?\\n\\nSince this is a classic problem - the proof is publicly available - all we needed is to do some search. For example, there is a one liner proof on wikipedia here. https://en.wikipedia.org/wiki/Interval_scheduling#Unweighted"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand your confusion. Proving the correctness of a greedy solution can often be tricky. For this particular problem, we could demonstrate the greedy choice property and optimal substructure, two key characteristics of problems that can be solved using a greedy approach.\\n\\nThe **greedy choice property** means that a local optimum can lead to a global optimum. For this problem, the local optimum is to always select the interval with the earliest end time that doesn\\'t overlap with the current one. This choice leaves as much space as possible for the remaining intervals. If we can prove that making the greedy choice at each step leads to the solution of the overall problem, then we\\'ve shown the greedy choice property.\\n\\nThe **optimal substructure** means that an optimal solution to the problem can be constructed efficiently from optimal solutions to its subproblems. In this problem, once we make the greedy choice of picking the interval with the earliest end time, we\\'re left with a smaller subproblem: finding the optimal solution in the remaining intervals.\\n\\nHere\\'s the intuition for why this greedy strategy works:\\n\\nThe crucial observation is that the interval with the earliest end time is least likely to overlap with other intervals. Hence, keeping this interval in our solution gives us the maximum space to accommodate the remaining intervals, which in turn reduces the number of removals. \\n\\nNow, let\\'s say there\\'s an optimal solution different from ours that keeps an interval `i` with an end time later than the one we chose (let\\'s call our interval `x`). We can replace `i` with `x` in this solution, and it\\'s guaranteed not to create more overlaps because `x` ends earlier than `i`. Therefore, the new solution is still optimal, showing that our greedy choice doesn\\'t lead to a worse solution.\\n\\nThis demonstrates that the greedy choice leads to an optimal solution and that the problem has an optimal substructure, thus validating our greedy solution."
                    },
                    {
                        "username": "abhay3141",
                        "content": "Getting Time limit Exceeded even though all 58/58 case passed. Any help ?"
                    },
                    {
                        "username": "jason3410",
                        "content": "You could just regard it as a regular TLE . It\\'s just a relatively closer one."
                    },
                    {
                        "username": "spookyflame",
                        "content": "[@cqrbala](/cqrbala) ty it worked. Forgot about that lmao"
                    },
                    {
                        "username": "cqrbala",
                        "content": "[@tanisha_daharwal](/tanisha_daharwal) [@Abhay](/abhay3141) Try to pass the vectors in the comparison function by reference (using & in c++). It is much faster as there is no need to make a copy of the vectors to perform the comparison."
                    },
                    {
                        "username": "tanisha_daharwal",
                        "content": "same thing happening with me"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Task failed successfully!"
                    },
                    {
                        "username": "ashu-xx",
                        "content": "[[1,100],[11,22],[1,11],[2,12]] \\nExpect: 2\\n\\nAccording to me expected answer should be 3 because [1,100] cannot be removed and all other 3 intervals are sub-intervals of [1,100].\\n\\nCan someone explain why is expected answer 2?"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "[@Ashutosh Mittal](/ashu-xx) in above case when we consider [1, 100] it will remove 3  other interval. but there a one option remain ie Consider [11,22] and [1, 11] than there is two inverval which are overlapping with these two [1,100] and [2,12] from the two option 3,  2, 2 option minimum so the result should be 2"
                    },
                    {
                        "username": "sasimouni",
                        "content": "[@bparanj](/bparanj)  nice explanation "
                    },
                    {
                        "username": "vermadeepesh248",
                        "content": "question said to remove minimum number of intervals. \\n\\nif we let [1,100] stay then we have to remove remaining three intervals.\\nbut instead if we remove [1,100] and [2,12] then we can let [1,11] and [11,22] stay. In this case we are removing only 2 intervals. so output should be 2."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@ShaliniMishra31](/ShaliniMishra31) [@ShaliniMishra31](/ShaliniMishra31) Your approach is not completely incorrect, but it\\'s not the most optimal one. In your solution, you are trying to represent the intervals on a number line and mark the occupied points. However, this approach has a couple of significant issues:\\n\\n1. It doesn\\'t consider the interval as a whole. Intervals are more than just individual points on a line, and their overlaps can\\'t always be accurately represented by the overlap of individual points.\\n\\n2. It doesn\\'t correctly account for the case when a smaller interval is entirely within a larger one. Your solution may consider the larger interval to be overlapping, even if removing the smaller one would make all intervals non-overlapping.\\n\\n3. Your solution has a time complexity of O(N^2), which is not efficient for large inputs.\\n\\nHere is an optimal solution using the greedy algorithm. It sorts the intervals by their end time and always tries to keep the one that ends earlier. This approach ensures we have more room for the remaining intervals.\\n\\nIn C++, it would look something like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 0) return 0;\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int ans = 0, end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i][0] < end){\\n                ans++;\\n            }\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution, we first sort the intervals by their end time. Then, we iterate over the sorted intervals. For each interval, if its start time is less than the end time of the previous interval, we increment our count (as it\\'s overlapping and needs to be removed). Otherwise, we update our end time to the current interval\\'s end time. This solution has a time complexity of O(N log N), which is more efficient."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected answer is 2 because the optimal solution doesn\\'t necessarily require keeping the interval [1,100]. It seems like you\\'re operating under the assumption that the larger interval has to be kept, but that\\'s not always the case.\\n\\nLet\\'s examine the problem with the given list of intervals:\\n\\n[[1,100],[11,22],[1,11],[2,12]]\\n\\nA key point to remember is that the objective is to minimize the number of removals so as to make the remaining intervals non-overlapping. To achieve this, the optimal strategy involves removing the intervals that cause the most overlaps. In this case, interval [1,100] overlaps with all other intervals, so if we keep it, we\\'d need to remove all other intervals, which is not optimal.\\n\\nInstead, if we remove [1,100], we\\'re left with:\\n\\n[[11,22],[1,11],[2,12]]\\n\\nOut of these, [1,11] and [11,22] don\\'t overlap. However, [2,12] overlaps with both. Thus, we can remove [2,12] to make the remaining intervals non-overlapping. This way, we only need to remove 2 intervals ([1,100] and [2,12]), which is why the expected answer is 2."
                    },
                    {
                        "username": "ShaliniMishra31",
                        "content": "[@cpblnc](/cpblnc) Could you explain again?\nI have the same doubt \n\nHere is my solution:\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        vector <pair<int,int>> vec(100000, {0,0});\n        int ans = 0;\n        for(int i=0;i<intervals.size();i++)\n        {\n            int f = intervals[i][0];\n            int s = intervals[i][1];\n            int dif = s-f;\n            int c = 0;\n            for(int j=f;j<=s;j++)\n            {\n                if(vec[j].second != 1)\n                {\n                    vec[j].first = j;\n                    vec[j].second = 1;\n                }\n                else\n                {\n                    c++;\n                }\n            }\n            if(c > dif)\n            {\n                ans++;\n            }\n        }\n        return(ans);\n    }\n};\n"
                    },
                    {
                        "username": "cpblnc",
                        "content": "Why can\\'t [1,100] be removed? If you remove it and [2,12] as well, you are left with [1,11] and [11,22], which are non overlapping - 2 intervals got removed, as expected."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Sort & Greedy make people happy!"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After I saw this problem, My first thought was to use `Binary Search` with `DP` and solved it."
                    },
                    {
                        "username": "sunny8080",
                        "content": "[@ashish15678](/ashish15678) For every index, find next non-overlapping intervel using `Binary Search`. \\nFor more, just take a look at [My Solution](https://leetcode.com/problems/non-overlapping-intervals/solutions/3788241/c-java-easy-and-clean-code-dp-greedy-beats/)"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@ashish15678](/ashish15678)  u can see my soln, i also did it using DP and Binary Search. \\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/solutions/3789308/dp-binary-search-solution/"
                    },
                    {
                        "username": "ashish15678",
                        "content": "can you please explain more\\n"
                    },
                    {
                        "username": "user4653c",
                        "content": "Labeling this problem as Dynamic Programming is a bit of a nasty move. To solve it, you need to find the right intuition, attempting the DP approach will just make things more confusing"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@Charlemagne5t](/Charlemagne5t) well true it can be difficult, trying joting down all possible scenarios and see if your greedy (or any other) approach works, if it does then try to find a justification for it, sometimes u may pass the question by implementing a approach but can\\'t think of a proof of it, can happen if the proof is mathematically rigorous "
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Agreed. Tried straight forward recursion + caching and got TLE 54/58. What I like about this approach it guarantees the right answer. Greedy is more optimal solution, but how do I prove it in real world problems when I don\\'t have rich test cases sample. I need to improve my knowledge in that field I guess. "
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "It's easy to think that:\\n- If we count the overlapping times with each interval. \\n- Then, for each time we remove the interval with most overlapping interval(let's call it A)\\n- And we update the other intervals' overlapping time which is overlapped with A.\\n- When all interval has zero overlapping times, we get the result.\\n\\nI know how to do it in greedy in O(nlgn) time, but I wonder why this cant work... \\nThis idea failed in the last test case(that with 10k inputs).I can't figure out why... Can someone help me?please...?\\nThanks your time for seeing these. Thank you~"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@nsut_coder](/nsut_coder) It would still not work if we remove all duplicates. Consider the same example, but add small random fractional values to each start and end. No duplicates, but the answer remains the same,"
                    },
                    {
                        "username": "bparanj",
                        "content": "The strategy you described is known as the \"interval graph coloring\" problem and it\\'s not equivalent to the interval scheduling problem we are solving here. You are describing an approach in which we try to color intervals (remove as few as possible) such that no two overlapping intervals share the same color. That is a more complicated problem and is not what we are trying to solve here.\\n\\nYou are trying to remove the interval that has the most overlaps first. This approach does not always lead to the optimal solution. Consider the following example:\\n\\n[[1, 5], [2, 3], [3, 4], [4, 5]]\\n\\nIf we follow your approach, we\\'ll remove [1, 5] first, because it overlaps with the most intervals. But this leads to the need of removing 1 interval, while the optimal solution would be to remove none. If we select [2, 3], [3, 4], [4, 5], we can see that none of these intervals overlap, which leads to the optimal solution of 0 removals.\\n\\nThis shows why the greedy algorithm of always choosing the interval that ends the earliest works: it leaves the most room for the rest of the intervals to not overlap.\\n\\nSo the intuition for the greedy algorithm in this problem is: the sooner an interval ends, the more room we have for the rest of the intervals to fit in without overlapping. It\\'s about looking ahead and trying to leave as much room as possible for the future intervals."
                    },
                    {
                        "username": "nsut_coder",
                        "content": "[@bharathi1121](/bharathi1121) I think, algorithm would work if we remove the duplicate ranges. but how would algorithm decide which interval to remove when all of them are overlapping with same number of intervals. "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "It doesnt work because its not always the largest overlapping interval to be removed first,\\nex: [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]\\nin this example the largest overlapping interval is [2,4] but it is part of the answer."
                    }
                ]
            },
            {
                "id": 1797697,
                "content": [
                    {
                        "username": "ZimmAgu",
                        "content": "#### Initial Steps\\n* Sort the given intervals based on starting points\\n* While considering the intervals in the ascending order of starting points\\n\\t* we make use of a pointer prev pointer \\n\\t* to keep track of the interval just included in the final list\\n![image](https://assets.leetcode.com/users/images/515fa83b-44c2-4c42-8ef5-d41c7942ec32_1653774876.169032.jpeg)\\n\\n\\n\\n#### Case 1\\n* You don\\'t need to remove any intervals\\n* Continue by simply assigning the *prev* pointer to the later interval\\n* The count of intervals removed remains unchanged\\n\\n\\n#### Case 2\\n* Remove the interval with the later end point \\n* The *prev* pointer is updated to current interval\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Case 3\\n* Remove the interval with the later end point \\n* The *prev* pointer remains unchanged\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Rule of Thumb\\n* Always choose the interval that ends first\\n\\n"
                    },
                    {
                        "username": "Muhammadamin",
                        "content": "[@rohitanjane999](/rohitanjane999)  + "
                    },
                    {
                        "username": "MayuD",
                        "content": "Thank you\nThe second case had got me"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "That was really good...thanks"
                    },
                    {
                        "username": "0x415374",
                        "content": "Pretty intuitive! Unfortunately I was not able to figure this out in a reasonable amount of time."
                    },
                    {
                        "username": "voodooism",
                        "content": "with this explanation the problem becomes easy!\\nthanks!"
                    },
                    {
                        "username": "rohitanjane999",
                        "content": "thanks for explanation...."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "And this marks my 200 days of streak..."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "So i\\'m not alone. [@sarpalmadhav](/sarpalmadhav)[@Ashutosh kumar](/ashurockzz) We started on jan1. Hope we complete our 365 days challenge."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ashu0123](/ashu0123) Congrats! Same here. I too have hit 200. We both started on Jan 1!!\\n"
                    },
                    {
                        "username": "ashu0123",
                        "content": "Looks like you\\'ve used Time travel tickets"
                    },
                    {
                        "username": "oops_moment",
                        "content": "If you\\'ve already cracked this challenging problem, kudos to you! If not, fret not! Let\\'s go step by step to find the perfect solution together! \\uD83D\\uDCAA\\n\\n\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F Problem Analysis:\\nWe\\'re given an array of intervals, and the goal is to find the minimum number of intervals to remove to make the rest non-overlapping. To achieve this, we\\'ll apply the greedy approach.\\n\\n\\u2B50 Greedy Insight:\\nLet\\'s try out a few greedy strategies. Say we select the interval with the smallest start time. Oops! This fails when the interval with the smallest start time also happens to be the longest one, leading to many overlapping intervals that need to be discarded.\\n\\n\\uD83D\\uDCA1 The Winning Greedy Strategy:\\nInstead, let\\'s sort the intervals based on their end times. Why? Imagine two intervals, one ending at x and the other ending at y (where x < y). If we skip the interval ending at x and take the one ending at y, we\\'ll may have to remove at least one interval that starts in the range (x, y). So, we should always sort based on the end time of intervals.\\n\\n\\uD83D\\uDEE0\\uFE0F Implementation:\\n\\n1: Sort the intervals based on their end times in ascending order.\\n\\n2: Initialize a variable \\'answer\\' to keep track of the number of intervals to be removed.\\n\\n3: Consider the first interval as \\'last\\' or the last taken interval.\\n\\n4: Iterate through the intervals, and for each interval:\\n\\n- If the current interval\\'s start time is less than the end time of the \\'last\\' interval, they overlap. Increment \\'answer\\' as we need to remove an interval to avoid overlap.\\n\\n- Otherwise, update \\'last\\' to the current interval.\\n\\n5: Return the final value of answer.\\n\\nNow you can confidently explain this solution to others and spread the joy of problem-solving! Happy coding! \\uD83D\\uDE80"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I don\\'t get why sorting by the end of the range helps.\\nI did\\n```\\nintervals.sort(key=lambda x: x[1])\\n```"
                    },
                    {
                        "username": "jkswapnil99",
                        "content": "Why is greedy solution correct for this problem. How do we know that, of all the ways in which intervals can be deleted the greedy approach is the optimal strategy?\\n\\nI always have trouble proving this for greedy solutions"
                    },
                    {
                        "username": "aLaN09",
                        "content": "[@bparanj](/bparanj) Nicely written"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The \"proof\" does not convince me for at least a two reasons:\\n\\n1) If there is an optimal solution different from ours, why must there an interval `i` with end time larger than ours?\\n2) We have no idea where `x` starts, how do we guarantee adding `x` after removing `i` won\\'t introduce conflicts?\\n\\nSince this is a classic problem - the proof is publicly available - all we needed is to do some search. For example, there is a one liner proof on wikipedia here. https://en.wikipedia.org/wiki/Interval_scheduling#Unweighted"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand your confusion. Proving the correctness of a greedy solution can often be tricky. For this particular problem, we could demonstrate the greedy choice property and optimal substructure, two key characteristics of problems that can be solved using a greedy approach.\\n\\nThe **greedy choice property** means that a local optimum can lead to a global optimum. For this problem, the local optimum is to always select the interval with the earliest end time that doesn\\'t overlap with the current one. This choice leaves as much space as possible for the remaining intervals. If we can prove that making the greedy choice at each step leads to the solution of the overall problem, then we\\'ve shown the greedy choice property.\\n\\nThe **optimal substructure** means that an optimal solution to the problem can be constructed efficiently from optimal solutions to its subproblems. In this problem, once we make the greedy choice of picking the interval with the earliest end time, we\\'re left with a smaller subproblem: finding the optimal solution in the remaining intervals.\\n\\nHere\\'s the intuition for why this greedy strategy works:\\n\\nThe crucial observation is that the interval with the earliest end time is least likely to overlap with other intervals. Hence, keeping this interval in our solution gives us the maximum space to accommodate the remaining intervals, which in turn reduces the number of removals. \\n\\nNow, let\\'s say there\\'s an optimal solution different from ours that keeps an interval `i` with an end time later than the one we chose (let\\'s call our interval `x`). We can replace `i` with `x` in this solution, and it\\'s guaranteed not to create more overlaps because `x` ends earlier than `i`. Therefore, the new solution is still optimal, showing that our greedy choice doesn\\'t lead to a worse solution.\\n\\nThis demonstrates that the greedy choice leads to an optimal solution and that the problem has an optimal substructure, thus validating our greedy solution."
                    },
                    {
                        "username": "abhay3141",
                        "content": "Getting Time limit Exceeded even though all 58/58 case passed. Any help ?"
                    },
                    {
                        "username": "jason3410",
                        "content": "You could just regard it as a regular TLE . It\\'s just a relatively closer one."
                    },
                    {
                        "username": "spookyflame",
                        "content": "[@cqrbala](/cqrbala) ty it worked. Forgot about that lmao"
                    },
                    {
                        "username": "cqrbala",
                        "content": "[@tanisha_daharwal](/tanisha_daharwal) [@Abhay](/abhay3141) Try to pass the vectors in the comparison function by reference (using & in c++). It is much faster as there is no need to make a copy of the vectors to perform the comparison."
                    },
                    {
                        "username": "tanisha_daharwal",
                        "content": "same thing happening with me"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Task failed successfully!"
                    },
                    {
                        "username": "ashu-xx",
                        "content": "[[1,100],[11,22],[1,11],[2,12]] \\nExpect: 2\\n\\nAccording to me expected answer should be 3 because [1,100] cannot be removed and all other 3 intervals are sub-intervals of [1,100].\\n\\nCan someone explain why is expected answer 2?"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "[@Ashutosh Mittal](/ashu-xx) in above case when we consider [1, 100] it will remove 3  other interval. but there a one option remain ie Consider [11,22] and [1, 11] than there is two inverval which are overlapping with these two [1,100] and [2,12] from the two option 3,  2, 2 option minimum so the result should be 2"
                    },
                    {
                        "username": "sasimouni",
                        "content": "[@bparanj](/bparanj)  nice explanation "
                    },
                    {
                        "username": "vermadeepesh248",
                        "content": "question said to remove minimum number of intervals. \\n\\nif we let [1,100] stay then we have to remove remaining three intervals.\\nbut instead if we remove [1,100] and [2,12] then we can let [1,11] and [11,22] stay. In this case we are removing only 2 intervals. so output should be 2."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@ShaliniMishra31](/ShaliniMishra31) [@ShaliniMishra31](/ShaliniMishra31) Your approach is not completely incorrect, but it\\'s not the most optimal one. In your solution, you are trying to represent the intervals on a number line and mark the occupied points. However, this approach has a couple of significant issues:\\n\\n1. It doesn\\'t consider the interval as a whole. Intervals are more than just individual points on a line, and their overlaps can\\'t always be accurately represented by the overlap of individual points.\\n\\n2. It doesn\\'t correctly account for the case when a smaller interval is entirely within a larger one. Your solution may consider the larger interval to be overlapping, even if removing the smaller one would make all intervals non-overlapping.\\n\\n3. Your solution has a time complexity of O(N^2), which is not efficient for large inputs.\\n\\nHere is an optimal solution using the greedy algorithm. It sorts the intervals by their end time and always tries to keep the one that ends earlier. This approach ensures we have more room for the remaining intervals.\\n\\nIn C++, it would look something like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 0) return 0;\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int ans = 0, end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i][0] < end){\\n                ans++;\\n            }\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution, we first sort the intervals by their end time. Then, we iterate over the sorted intervals. For each interval, if its start time is less than the end time of the previous interval, we increment our count (as it\\'s overlapping and needs to be removed). Otherwise, we update our end time to the current interval\\'s end time. This solution has a time complexity of O(N log N), which is more efficient."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected answer is 2 because the optimal solution doesn\\'t necessarily require keeping the interval [1,100]. It seems like you\\'re operating under the assumption that the larger interval has to be kept, but that\\'s not always the case.\\n\\nLet\\'s examine the problem with the given list of intervals:\\n\\n[[1,100],[11,22],[1,11],[2,12]]\\n\\nA key point to remember is that the objective is to minimize the number of removals so as to make the remaining intervals non-overlapping. To achieve this, the optimal strategy involves removing the intervals that cause the most overlaps. In this case, interval [1,100] overlaps with all other intervals, so if we keep it, we\\'d need to remove all other intervals, which is not optimal.\\n\\nInstead, if we remove [1,100], we\\'re left with:\\n\\n[[11,22],[1,11],[2,12]]\\n\\nOut of these, [1,11] and [11,22] don\\'t overlap. However, [2,12] overlaps with both. Thus, we can remove [2,12] to make the remaining intervals non-overlapping. This way, we only need to remove 2 intervals ([1,100] and [2,12]), which is why the expected answer is 2."
                    },
                    {
                        "username": "ShaliniMishra31",
                        "content": "[@cpblnc](/cpblnc) Could you explain again?\nI have the same doubt \n\nHere is my solution:\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        vector <pair<int,int>> vec(100000, {0,0});\n        int ans = 0;\n        for(int i=0;i<intervals.size();i++)\n        {\n            int f = intervals[i][0];\n            int s = intervals[i][1];\n            int dif = s-f;\n            int c = 0;\n            for(int j=f;j<=s;j++)\n            {\n                if(vec[j].second != 1)\n                {\n                    vec[j].first = j;\n                    vec[j].second = 1;\n                }\n                else\n                {\n                    c++;\n                }\n            }\n            if(c > dif)\n            {\n                ans++;\n            }\n        }\n        return(ans);\n    }\n};\n"
                    },
                    {
                        "username": "cpblnc",
                        "content": "Why can\\'t [1,100] be removed? If you remove it and [2,12] as well, you are left with [1,11] and [11,22], which are non overlapping - 2 intervals got removed, as expected."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Sort & Greedy make people happy!"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After I saw this problem, My first thought was to use `Binary Search` with `DP` and solved it."
                    },
                    {
                        "username": "sunny8080",
                        "content": "[@ashish15678](/ashish15678) For every index, find next non-overlapping intervel using `Binary Search`. \\nFor more, just take a look at [My Solution](https://leetcode.com/problems/non-overlapping-intervals/solutions/3788241/c-java-easy-and-clean-code-dp-greedy-beats/)"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@ashish15678](/ashish15678)  u can see my soln, i also did it using DP and Binary Search. \\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/solutions/3789308/dp-binary-search-solution/"
                    },
                    {
                        "username": "ashish15678",
                        "content": "can you please explain more\\n"
                    },
                    {
                        "username": "user4653c",
                        "content": "Labeling this problem as Dynamic Programming is a bit of a nasty move. To solve it, you need to find the right intuition, attempting the DP approach will just make things more confusing"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@Charlemagne5t](/Charlemagne5t) well true it can be difficult, trying joting down all possible scenarios and see if your greedy (or any other) approach works, if it does then try to find a justification for it, sometimes u may pass the question by implementing a approach but can\\'t think of a proof of it, can happen if the proof is mathematically rigorous "
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Agreed. Tried straight forward recursion + caching and got TLE 54/58. What I like about this approach it guarantees the right answer. Greedy is more optimal solution, but how do I prove it in real world problems when I don\\'t have rich test cases sample. I need to improve my knowledge in that field I guess. "
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "It's easy to think that:\\n- If we count the overlapping times with each interval. \\n- Then, for each time we remove the interval with most overlapping interval(let's call it A)\\n- And we update the other intervals' overlapping time which is overlapped with A.\\n- When all interval has zero overlapping times, we get the result.\\n\\nI know how to do it in greedy in O(nlgn) time, but I wonder why this cant work... \\nThis idea failed in the last test case(that with 10k inputs).I can't figure out why... Can someone help me?please...?\\nThanks your time for seeing these. Thank you~"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@nsut_coder](/nsut_coder) It would still not work if we remove all duplicates. Consider the same example, but add small random fractional values to each start and end. No duplicates, but the answer remains the same,"
                    },
                    {
                        "username": "bparanj",
                        "content": "The strategy you described is known as the \"interval graph coloring\" problem and it\\'s not equivalent to the interval scheduling problem we are solving here. You are describing an approach in which we try to color intervals (remove as few as possible) such that no two overlapping intervals share the same color. That is a more complicated problem and is not what we are trying to solve here.\\n\\nYou are trying to remove the interval that has the most overlaps first. This approach does not always lead to the optimal solution. Consider the following example:\\n\\n[[1, 5], [2, 3], [3, 4], [4, 5]]\\n\\nIf we follow your approach, we\\'ll remove [1, 5] first, because it overlaps with the most intervals. But this leads to the need of removing 1 interval, while the optimal solution would be to remove none. If we select [2, 3], [3, 4], [4, 5], we can see that none of these intervals overlap, which leads to the optimal solution of 0 removals.\\n\\nThis shows why the greedy algorithm of always choosing the interval that ends the earliest works: it leaves the most room for the rest of the intervals to not overlap.\\n\\nSo the intuition for the greedy algorithm in this problem is: the sooner an interval ends, the more room we have for the rest of the intervals to fit in without overlapping. It\\'s about looking ahead and trying to leave as much room as possible for the future intervals."
                    },
                    {
                        "username": "nsut_coder",
                        "content": "[@bharathi1121](/bharathi1121) I think, algorithm would work if we remove the duplicate ranges. but how would algorithm decide which interval to remove when all of them are overlapping with same number of intervals. "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "It doesnt work because its not always the largest overlapping interval to be removed first,\\nex: [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]\\nin this example the largest overlapping interval is [2,4] but it is part of the answer."
                    }
                ]
            },
            {
                "id": 1573428,
                "content": [
                    {
                        "username": "ZimmAgu",
                        "content": "#### Initial Steps\\n* Sort the given intervals based on starting points\\n* While considering the intervals in the ascending order of starting points\\n\\t* we make use of a pointer prev pointer \\n\\t* to keep track of the interval just included in the final list\\n![image](https://assets.leetcode.com/users/images/515fa83b-44c2-4c42-8ef5-d41c7942ec32_1653774876.169032.jpeg)\\n\\n\\n\\n#### Case 1\\n* You don\\'t need to remove any intervals\\n* Continue by simply assigning the *prev* pointer to the later interval\\n* The count of intervals removed remains unchanged\\n\\n\\n#### Case 2\\n* Remove the interval with the later end point \\n* The *prev* pointer is updated to current interval\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Case 3\\n* Remove the interval with the later end point \\n* The *prev* pointer remains unchanged\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Rule of Thumb\\n* Always choose the interval that ends first\\n\\n"
                    },
                    {
                        "username": "Muhammadamin",
                        "content": "[@rohitanjane999](/rohitanjane999)  + "
                    },
                    {
                        "username": "MayuD",
                        "content": "Thank you\nThe second case had got me"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "That was really good...thanks"
                    },
                    {
                        "username": "0x415374",
                        "content": "Pretty intuitive! Unfortunately I was not able to figure this out in a reasonable amount of time."
                    },
                    {
                        "username": "voodooism",
                        "content": "with this explanation the problem becomes easy!\\nthanks!"
                    },
                    {
                        "username": "rohitanjane999",
                        "content": "thanks for explanation...."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "And this marks my 200 days of streak..."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "So i\\'m not alone. [@sarpalmadhav](/sarpalmadhav)[@Ashutosh kumar](/ashurockzz) We started on jan1. Hope we complete our 365 days challenge."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ashu0123](/ashu0123) Congrats! Same here. I too have hit 200. We both started on Jan 1!!\\n"
                    },
                    {
                        "username": "ashu0123",
                        "content": "Looks like you\\'ve used Time travel tickets"
                    },
                    {
                        "username": "oops_moment",
                        "content": "If you\\'ve already cracked this challenging problem, kudos to you! If not, fret not! Let\\'s go step by step to find the perfect solution together! \\uD83D\\uDCAA\\n\\n\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F Problem Analysis:\\nWe\\'re given an array of intervals, and the goal is to find the minimum number of intervals to remove to make the rest non-overlapping. To achieve this, we\\'ll apply the greedy approach.\\n\\n\\u2B50 Greedy Insight:\\nLet\\'s try out a few greedy strategies. Say we select the interval with the smallest start time. Oops! This fails when the interval with the smallest start time also happens to be the longest one, leading to many overlapping intervals that need to be discarded.\\n\\n\\uD83D\\uDCA1 The Winning Greedy Strategy:\\nInstead, let\\'s sort the intervals based on their end times. Why? Imagine two intervals, one ending at x and the other ending at y (where x < y). If we skip the interval ending at x and take the one ending at y, we\\'ll may have to remove at least one interval that starts in the range (x, y). So, we should always sort based on the end time of intervals.\\n\\n\\uD83D\\uDEE0\\uFE0F Implementation:\\n\\n1: Sort the intervals based on their end times in ascending order.\\n\\n2: Initialize a variable \\'answer\\' to keep track of the number of intervals to be removed.\\n\\n3: Consider the first interval as \\'last\\' or the last taken interval.\\n\\n4: Iterate through the intervals, and for each interval:\\n\\n- If the current interval\\'s start time is less than the end time of the \\'last\\' interval, they overlap. Increment \\'answer\\' as we need to remove an interval to avoid overlap.\\n\\n- Otherwise, update \\'last\\' to the current interval.\\n\\n5: Return the final value of answer.\\n\\nNow you can confidently explain this solution to others and spread the joy of problem-solving! Happy coding! \\uD83D\\uDE80"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I don\\'t get why sorting by the end of the range helps.\\nI did\\n```\\nintervals.sort(key=lambda x: x[1])\\n```"
                    },
                    {
                        "username": "jkswapnil99",
                        "content": "Why is greedy solution correct for this problem. How do we know that, of all the ways in which intervals can be deleted the greedy approach is the optimal strategy?\\n\\nI always have trouble proving this for greedy solutions"
                    },
                    {
                        "username": "aLaN09",
                        "content": "[@bparanj](/bparanj) Nicely written"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The \"proof\" does not convince me for at least a two reasons:\\n\\n1) If there is an optimal solution different from ours, why must there an interval `i` with end time larger than ours?\\n2) We have no idea where `x` starts, how do we guarantee adding `x` after removing `i` won\\'t introduce conflicts?\\n\\nSince this is a classic problem - the proof is publicly available - all we needed is to do some search. For example, there is a one liner proof on wikipedia here. https://en.wikipedia.org/wiki/Interval_scheduling#Unweighted"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand your confusion. Proving the correctness of a greedy solution can often be tricky. For this particular problem, we could demonstrate the greedy choice property and optimal substructure, two key characteristics of problems that can be solved using a greedy approach.\\n\\nThe **greedy choice property** means that a local optimum can lead to a global optimum. For this problem, the local optimum is to always select the interval with the earliest end time that doesn\\'t overlap with the current one. This choice leaves as much space as possible for the remaining intervals. If we can prove that making the greedy choice at each step leads to the solution of the overall problem, then we\\'ve shown the greedy choice property.\\n\\nThe **optimal substructure** means that an optimal solution to the problem can be constructed efficiently from optimal solutions to its subproblems. In this problem, once we make the greedy choice of picking the interval with the earliest end time, we\\'re left with a smaller subproblem: finding the optimal solution in the remaining intervals.\\n\\nHere\\'s the intuition for why this greedy strategy works:\\n\\nThe crucial observation is that the interval with the earliest end time is least likely to overlap with other intervals. Hence, keeping this interval in our solution gives us the maximum space to accommodate the remaining intervals, which in turn reduces the number of removals. \\n\\nNow, let\\'s say there\\'s an optimal solution different from ours that keeps an interval `i` with an end time later than the one we chose (let\\'s call our interval `x`). We can replace `i` with `x` in this solution, and it\\'s guaranteed not to create more overlaps because `x` ends earlier than `i`. Therefore, the new solution is still optimal, showing that our greedy choice doesn\\'t lead to a worse solution.\\n\\nThis demonstrates that the greedy choice leads to an optimal solution and that the problem has an optimal substructure, thus validating our greedy solution."
                    },
                    {
                        "username": "abhay3141",
                        "content": "Getting Time limit Exceeded even though all 58/58 case passed. Any help ?"
                    },
                    {
                        "username": "jason3410",
                        "content": "You could just regard it as a regular TLE . It\\'s just a relatively closer one."
                    },
                    {
                        "username": "spookyflame",
                        "content": "[@cqrbala](/cqrbala) ty it worked. Forgot about that lmao"
                    },
                    {
                        "username": "cqrbala",
                        "content": "[@tanisha_daharwal](/tanisha_daharwal) [@Abhay](/abhay3141) Try to pass the vectors in the comparison function by reference (using & in c++). It is much faster as there is no need to make a copy of the vectors to perform the comparison."
                    },
                    {
                        "username": "tanisha_daharwal",
                        "content": "same thing happening with me"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Task failed successfully!"
                    },
                    {
                        "username": "ashu-xx",
                        "content": "[[1,100],[11,22],[1,11],[2,12]] \\nExpect: 2\\n\\nAccording to me expected answer should be 3 because [1,100] cannot be removed and all other 3 intervals are sub-intervals of [1,100].\\n\\nCan someone explain why is expected answer 2?"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "[@Ashutosh Mittal](/ashu-xx) in above case when we consider [1, 100] it will remove 3  other interval. but there a one option remain ie Consider [11,22] and [1, 11] than there is two inverval which are overlapping with these two [1,100] and [2,12] from the two option 3,  2, 2 option minimum so the result should be 2"
                    },
                    {
                        "username": "sasimouni",
                        "content": "[@bparanj](/bparanj)  nice explanation "
                    },
                    {
                        "username": "vermadeepesh248",
                        "content": "question said to remove minimum number of intervals. \\n\\nif we let [1,100] stay then we have to remove remaining three intervals.\\nbut instead if we remove [1,100] and [2,12] then we can let [1,11] and [11,22] stay. In this case we are removing only 2 intervals. so output should be 2."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@ShaliniMishra31](/ShaliniMishra31) [@ShaliniMishra31](/ShaliniMishra31) Your approach is not completely incorrect, but it\\'s not the most optimal one. In your solution, you are trying to represent the intervals on a number line and mark the occupied points. However, this approach has a couple of significant issues:\\n\\n1. It doesn\\'t consider the interval as a whole. Intervals are more than just individual points on a line, and their overlaps can\\'t always be accurately represented by the overlap of individual points.\\n\\n2. It doesn\\'t correctly account for the case when a smaller interval is entirely within a larger one. Your solution may consider the larger interval to be overlapping, even if removing the smaller one would make all intervals non-overlapping.\\n\\n3. Your solution has a time complexity of O(N^2), which is not efficient for large inputs.\\n\\nHere is an optimal solution using the greedy algorithm. It sorts the intervals by their end time and always tries to keep the one that ends earlier. This approach ensures we have more room for the remaining intervals.\\n\\nIn C++, it would look something like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 0) return 0;\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int ans = 0, end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i][0] < end){\\n                ans++;\\n            }\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution, we first sort the intervals by their end time. Then, we iterate over the sorted intervals. For each interval, if its start time is less than the end time of the previous interval, we increment our count (as it\\'s overlapping and needs to be removed). Otherwise, we update our end time to the current interval\\'s end time. This solution has a time complexity of O(N log N), which is more efficient."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected answer is 2 because the optimal solution doesn\\'t necessarily require keeping the interval [1,100]. It seems like you\\'re operating under the assumption that the larger interval has to be kept, but that\\'s not always the case.\\n\\nLet\\'s examine the problem with the given list of intervals:\\n\\n[[1,100],[11,22],[1,11],[2,12]]\\n\\nA key point to remember is that the objective is to minimize the number of removals so as to make the remaining intervals non-overlapping. To achieve this, the optimal strategy involves removing the intervals that cause the most overlaps. In this case, interval [1,100] overlaps with all other intervals, so if we keep it, we\\'d need to remove all other intervals, which is not optimal.\\n\\nInstead, if we remove [1,100], we\\'re left with:\\n\\n[[11,22],[1,11],[2,12]]\\n\\nOut of these, [1,11] and [11,22] don\\'t overlap. However, [2,12] overlaps with both. Thus, we can remove [2,12] to make the remaining intervals non-overlapping. This way, we only need to remove 2 intervals ([1,100] and [2,12]), which is why the expected answer is 2."
                    },
                    {
                        "username": "ShaliniMishra31",
                        "content": "[@cpblnc](/cpblnc) Could you explain again?\nI have the same doubt \n\nHere is my solution:\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        vector <pair<int,int>> vec(100000, {0,0});\n        int ans = 0;\n        for(int i=0;i<intervals.size();i++)\n        {\n            int f = intervals[i][0];\n            int s = intervals[i][1];\n            int dif = s-f;\n            int c = 0;\n            for(int j=f;j<=s;j++)\n            {\n                if(vec[j].second != 1)\n                {\n                    vec[j].first = j;\n                    vec[j].second = 1;\n                }\n                else\n                {\n                    c++;\n                }\n            }\n            if(c > dif)\n            {\n                ans++;\n            }\n        }\n        return(ans);\n    }\n};\n"
                    },
                    {
                        "username": "cpblnc",
                        "content": "Why can\\'t [1,100] be removed? If you remove it and [2,12] as well, you are left with [1,11] and [11,22], which are non overlapping - 2 intervals got removed, as expected."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Sort & Greedy make people happy!"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After I saw this problem, My first thought was to use `Binary Search` with `DP` and solved it."
                    },
                    {
                        "username": "sunny8080",
                        "content": "[@ashish15678](/ashish15678) For every index, find next non-overlapping intervel using `Binary Search`. \\nFor more, just take a look at [My Solution](https://leetcode.com/problems/non-overlapping-intervals/solutions/3788241/c-java-easy-and-clean-code-dp-greedy-beats/)"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@ashish15678](/ashish15678)  u can see my soln, i also did it using DP and Binary Search. \\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/solutions/3789308/dp-binary-search-solution/"
                    },
                    {
                        "username": "ashish15678",
                        "content": "can you please explain more\\n"
                    },
                    {
                        "username": "user4653c",
                        "content": "Labeling this problem as Dynamic Programming is a bit of a nasty move. To solve it, you need to find the right intuition, attempting the DP approach will just make things more confusing"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@Charlemagne5t](/Charlemagne5t) well true it can be difficult, trying joting down all possible scenarios and see if your greedy (or any other) approach works, if it does then try to find a justification for it, sometimes u may pass the question by implementing a approach but can\\'t think of a proof of it, can happen if the proof is mathematically rigorous "
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Agreed. Tried straight forward recursion + caching and got TLE 54/58. What I like about this approach it guarantees the right answer. Greedy is more optimal solution, but how do I prove it in real world problems when I don\\'t have rich test cases sample. I need to improve my knowledge in that field I guess. "
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "It's easy to think that:\\n- If we count the overlapping times with each interval. \\n- Then, for each time we remove the interval with most overlapping interval(let's call it A)\\n- And we update the other intervals' overlapping time which is overlapped with A.\\n- When all interval has zero overlapping times, we get the result.\\n\\nI know how to do it in greedy in O(nlgn) time, but I wonder why this cant work... \\nThis idea failed in the last test case(that with 10k inputs).I can't figure out why... Can someone help me?please...?\\nThanks your time for seeing these. Thank you~"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@nsut_coder](/nsut_coder) It would still not work if we remove all duplicates. Consider the same example, but add small random fractional values to each start and end. No duplicates, but the answer remains the same,"
                    },
                    {
                        "username": "bparanj",
                        "content": "The strategy you described is known as the \"interval graph coloring\" problem and it\\'s not equivalent to the interval scheduling problem we are solving here. You are describing an approach in which we try to color intervals (remove as few as possible) such that no two overlapping intervals share the same color. That is a more complicated problem and is not what we are trying to solve here.\\n\\nYou are trying to remove the interval that has the most overlaps first. This approach does not always lead to the optimal solution. Consider the following example:\\n\\n[[1, 5], [2, 3], [3, 4], [4, 5]]\\n\\nIf we follow your approach, we\\'ll remove [1, 5] first, because it overlaps with the most intervals. But this leads to the need of removing 1 interval, while the optimal solution would be to remove none. If we select [2, 3], [3, 4], [4, 5], we can see that none of these intervals overlap, which leads to the optimal solution of 0 removals.\\n\\nThis shows why the greedy algorithm of always choosing the interval that ends the earliest works: it leaves the most room for the rest of the intervals to not overlap.\\n\\nSo the intuition for the greedy algorithm in this problem is: the sooner an interval ends, the more room we have for the rest of the intervals to fit in without overlapping. It\\'s about looking ahead and trying to leave as much room as possible for the future intervals."
                    },
                    {
                        "username": "nsut_coder",
                        "content": "[@bharathi1121](/bharathi1121) I think, algorithm would work if we remove the duplicate ranges. but how would algorithm decide which interval to remove when all of them are overlapping with same number of intervals. "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "It doesnt work because its not always the largest overlapping interval to be removed first,\\nex: [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]\\nin this example the largest overlapping interval is [2,4] but it is part of the answer."
                    }
                ]
            },
            {
                "id": 1976350,
                "content": [
                    {
                        "username": "ZimmAgu",
                        "content": "#### Initial Steps\\n* Sort the given intervals based on starting points\\n* While considering the intervals in the ascending order of starting points\\n\\t* we make use of a pointer prev pointer \\n\\t* to keep track of the interval just included in the final list\\n![image](https://assets.leetcode.com/users/images/515fa83b-44c2-4c42-8ef5-d41c7942ec32_1653774876.169032.jpeg)\\n\\n\\n\\n#### Case 1\\n* You don\\'t need to remove any intervals\\n* Continue by simply assigning the *prev* pointer to the later interval\\n* The count of intervals removed remains unchanged\\n\\n\\n#### Case 2\\n* Remove the interval with the later end point \\n* The *prev* pointer is updated to current interval\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Case 3\\n* Remove the interval with the later end point \\n* The *prev* pointer remains unchanged\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Rule of Thumb\\n* Always choose the interval that ends first\\n\\n"
                    },
                    {
                        "username": "Muhammadamin",
                        "content": "[@rohitanjane999](/rohitanjane999)  + "
                    },
                    {
                        "username": "MayuD",
                        "content": "Thank you\nThe second case had got me"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "That was really good...thanks"
                    },
                    {
                        "username": "0x415374",
                        "content": "Pretty intuitive! Unfortunately I was not able to figure this out in a reasonable amount of time."
                    },
                    {
                        "username": "voodooism",
                        "content": "with this explanation the problem becomes easy!\\nthanks!"
                    },
                    {
                        "username": "rohitanjane999",
                        "content": "thanks for explanation...."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "And this marks my 200 days of streak..."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "So i\\'m not alone. [@sarpalmadhav](/sarpalmadhav)[@Ashutosh kumar](/ashurockzz) We started on jan1. Hope we complete our 365 days challenge."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ashu0123](/ashu0123) Congrats! Same here. I too have hit 200. We both started on Jan 1!!\\n"
                    },
                    {
                        "username": "ashu0123",
                        "content": "Looks like you\\'ve used Time travel tickets"
                    },
                    {
                        "username": "oops_moment",
                        "content": "If you\\'ve already cracked this challenging problem, kudos to you! If not, fret not! Let\\'s go step by step to find the perfect solution together! \\uD83D\\uDCAA\\n\\n\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F Problem Analysis:\\nWe\\'re given an array of intervals, and the goal is to find the minimum number of intervals to remove to make the rest non-overlapping. To achieve this, we\\'ll apply the greedy approach.\\n\\n\\u2B50 Greedy Insight:\\nLet\\'s try out a few greedy strategies. Say we select the interval with the smallest start time. Oops! This fails when the interval with the smallest start time also happens to be the longest one, leading to many overlapping intervals that need to be discarded.\\n\\n\\uD83D\\uDCA1 The Winning Greedy Strategy:\\nInstead, let\\'s sort the intervals based on their end times. Why? Imagine two intervals, one ending at x and the other ending at y (where x < y). If we skip the interval ending at x and take the one ending at y, we\\'ll may have to remove at least one interval that starts in the range (x, y). So, we should always sort based on the end time of intervals.\\n\\n\\uD83D\\uDEE0\\uFE0F Implementation:\\n\\n1: Sort the intervals based on their end times in ascending order.\\n\\n2: Initialize a variable \\'answer\\' to keep track of the number of intervals to be removed.\\n\\n3: Consider the first interval as \\'last\\' or the last taken interval.\\n\\n4: Iterate through the intervals, and for each interval:\\n\\n- If the current interval\\'s start time is less than the end time of the \\'last\\' interval, they overlap. Increment \\'answer\\' as we need to remove an interval to avoid overlap.\\n\\n- Otherwise, update \\'last\\' to the current interval.\\n\\n5: Return the final value of answer.\\n\\nNow you can confidently explain this solution to others and spread the joy of problem-solving! Happy coding! \\uD83D\\uDE80"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I don\\'t get why sorting by the end of the range helps.\\nI did\\n```\\nintervals.sort(key=lambda x: x[1])\\n```"
                    },
                    {
                        "username": "jkswapnil99",
                        "content": "Why is greedy solution correct for this problem. How do we know that, of all the ways in which intervals can be deleted the greedy approach is the optimal strategy?\\n\\nI always have trouble proving this for greedy solutions"
                    },
                    {
                        "username": "aLaN09",
                        "content": "[@bparanj](/bparanj) Nicely written"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The \"proof\" does not convince me for at least a two reasons:\\n\\n1) If there is an optimal solution different from ours, why must there an interval `i` with end time larger than ours?\\n2) We have no idea where `x` starts, how do we guarantee adding `x` after removing `i` won\\'t introduce conflicts?\\n\\nSince this is a classic problem - the proof is publicly available - all we needed is to do some search. For example, there is a one liner proof on wikipedia here. https://en.wikipedia.org/wiki/Interval_scheduling#Unweighted"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand your confusion. Proving the correctness of a greedy solution can often be tricky. For this particular problem, we could demonstrate the greedy choice property and optimal substructure, two key characteristics of problems that can be solved using a greedy approach.\\n\\nThe **greedy choice property** means that a local optimum can lead to a global optimum. For this problem, the local optimum is to always select the interval with the earliest end time that doesn\\'t overlap with the current one. This choice leaves as much space as possible for the remaining intervals. If we can prove that making the greedy choice at each step leads to the solution of the overall problem, then we\\'ve shown the greedy choice property.\\n\\nThe **optimal substructure** means that an optimal solution to the problem can be constructed efficiently from optimal solutions to its subproblems. In this problem, once we make the greedy choice of picking the interval with the earliest end time, we\\'re left with a smaller subproblem: finding the optimal solution in the remaining intervals.\\n\\nHere\\'s the intuition for why this greedy strategy works:\\n\\nThe crucial observation is that the interval with the earliest end time is least likely to overlap with other intervals. Hence, keeping this interval in our solution gives us the maximum space to accommodate the remaining intervals, which in turn reduces the number of removals. \\n\\nNow, let\\'s say there\\'s an optimal solution different from ours that keeps an interval `i` with an end time later than the one we chose (let\\'s call our interval `x`). We can replace `i` with `x` in this solution, and it\\'s guaranteed not to create more overlaps because `x` ends earlier than `i`. Therefore, the new solution is still optimal, showing that our greedy choice doesn\\'t lead to a worse solution.\\n\\nThis demonstrates that the greedy choice leads to an optimal solution and that the problem has an optimal substructure, thus validating our greedy solution."
                    },
                    {
                        "username": "abhay3141",
                        "content": "Getting Time limit Exceeded even though all 58/58 case passed. Any help ?"
                    },
                    {
                        "username": "jason3410",
                        "content": "You could just regard it as a regular TLE . It\\'s just a relatively closer one."
                    },
                    {
                        "username": "spookyflame",
                        "content": "[@cqrbala](/cqrbala) ty it worked. Forgot about that lmao"
                    },
                    {
                        "username": "cqrbala",
                        "content": "[@tanisha_daharwal](/tanisha_daharwal) [@Abhay](/abhay3141) Try to pass the vectors in the comparison function by reference (using & in c++). It is much faster as there is no need to make a copy of the vectors to perform the comparison."
                    },
                    {
                        "username": "tanisha_daharwal",
                        "content": "same thing happening with me"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Task failed successfully!"
                    },
                    {
                        "username": "ashu-xx",
                        "content": "[[1,100],[11,22],[1,11],[2,12]] \\nExpect: 2\\n\\nAccording to me expected answer should be 3 because [1,100] cannot be removed and all other 3 intervals are sub-intervals of [1,100].\\n\\nCan someone explain why is expected answer 2?"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "[@Ashutosh Mittal](/ashu-xx) in above case when we consider [1, 100] it will remove 3  other interval. but there a one option remain ie Consider [11,22] and [1, 11] than there is two inverval which are overlapping with these two [1,100] and [2,12] from the two option 3,  2, 2 option minimum so the result should be 2"
                    },
                    {
                        "username": "sasimouni",
                        "content": "[@bparanj](/bparanj)  nice explanation "
                    },
                    {
                        "username": "vermadeepesh248",
                        "content": "question said to remove minimum number of intervals. \\n\\nif we let [1,100] stay then we have to remove remaining three intervals.\\nbut instead if we remove [1,100] and [2,12] then we can let [1,11] and [11,22] stay. In this case we are removing only 2 intervals. so output should be 2."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@ShaliniMishra31](/ShaliniMishra31) [@ShaliniMishra31](/ShaliniMishra31) Your approach is not completely incorrect, but it\\'s not the most optimal one. In your solution, you are trying to represent the intervals on a number line and mark the occupied points. However, this approach has a couple of significant issues:\\n\\n1. It doesn\\'t consider the interval as a whole. Intervals are more than just individual points on a line, and their overlaps can\\'t always be accurately represented by the overlap of individual points.\\n\\n2. It doesn\\'t correctly account for the case when a smaller interval is entirely within a larger one. Your solution may consider the larger interval to be overlapping, even if removing the smaller one would make all intervals non-overlapping.\\n\\n3. Your solution has a time complexity of O(N^2), which is not efficient for large inputs.\\n\\nHere is an optimal solution using the greedy algorithm. It sorts the intervals by their end time and always tries to keep the one that ends earlier. This approach ensures we have more room for the remaining intervals.\\n\\nIn C++, it would look something like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 0) return 0;\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int ans = 0, end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i][0] < end){\\n                ans++;\\n            }\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution, we first sort the intervals by their end time. Then, we iterate over the sorted intervals. For each interval, if its start time is less than the end time of the previous interval, we increment our count (as it\\'s overlapping and needs to be removed). Otherwise, we update our end time to the current interval\\'s end time. This solution has a time complexity of O(N log N), which is more efficient."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected answer is 2 because the optimal solution doesn\\'t necessarily require keeping the interval [1,100]. It seems like you\\'re operating under the assumption that the larger interval has to be kept, but that\\'s not always the case.\\n\\nLet\\'s examine the problem with the given list of intervals:\\n\\n[[1,100],[11,22],[1,11],[2,12]]\\n\\nA key point to remember is that the objective is to minimize the number of removals so as to make the remaining intervals non-overlapping. To achieve this, the optimal strategy involves removing the intervals that cause the most overlaps. In this case, interval [1,100] overlaps with all other intervals, so if we keep it, we\\'d need to remove all other intervals, which is not optimal.\\n\\nInstead, if we remove [1,100], we\\'re left with:\\n\\n[[11,22],[1,11],[2,12]]\\n\\nOut of these, [1,11] and [11,22] don\\'t overlap. However, [2,12] overlaps with both. Thus, we can remove [2,12] to make the remaining intervals non-overlapping. This way, we only need to remove 2 intervals ([1,100] and [2,12]), which is why the expected answer is 2."
                    },
                    {
                        "username": "ShaliniMishra31",
                        "content": "[@cpblnc](/cpblnc) Could you explain again?\nI have the same doubt \n\nHere is my solution:\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        vector <pair<int,int>> vec(100000, {0,0});\n        int ans = 0;\n        for(int i=0;i<intervals.size();i++)\n        {\n            int f = intervals[i][0];\n            int s = intervals[i][1];\n            int dif = s-f;\n            int c = 0;\n            for(int j=f;j<=s;j++)\n            {\n                if(vec[j].second != 1)\n                {\n                    vec[j].first = j;\n                    vec[j].second = 1;\n                }\n                else\n                {\n                    c++;\n                }\n            }\n            if(c > dif)\n            {\n                ans++;\n            }\n        }\n        return(ans);\n    }\n};\n"
                    },
                    {
                        "username": "cpblnc",
                        "content": "Why can\\'t [1,100] be removed? If you remove it and [2,12] as well, you are left with [1,11] and [11,22], which are non overlapping - 2 intervals got removed, as expected."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Sort & Greedy make people happy!"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After I saw this problem, My first thought was to use `Binary Search` with `DP` and solved it."
                    },
                    {
                        "username": "sunny8080",
                        "content": "[@ashish15678](/ashish15678) For every index, find next non-overlapping intervel using `Binary Search`. \\nFor more, just take a look at [My Solution](https://leetcode.com/problems/non-overlapping-intervals/solutions/3788241/c-java-easy-and-clean-code-dp-greedy-beats/)"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@ashish15678](/ashish15678)  u can see my soln, i also did it using DP and Binary Search. \\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/solutions/3789308/dp-binary-search-solution/"
                    },
                    {
                        "username": "ashish15678",
                        "content": "can you please explain more\\n"
                    },
                    {
                        "username": "user4653c",
                        "content": "Labeling this problem as Dynamic Programming is a bit of a nasty move. To solve it, you need to find the right intuition, attempting the DP approach will just make things more confusing"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@Charlemagne5t](/Charlemagne5t) well true it can be difficult, trying joting down all possible scenarios and see if your greedy (or any other) approach works, if it does then try to find a justification for it, sometimes u may pass the question by implementing a approach but can\\'t think of a proof of it, can happen if the proof is mathematically rigorous "
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Agreed. Tried straight forward recursion + caching and got TLE 54/58. What I like about this approach it guarantees the right answer. Greedy is more optimal solution, but how do I prove it in real world problems when I don\\'t have rich test cases sample. I need to improve my knowledge in that field I guess. "
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "It's easy to think that:\\n- If we count the overlapping times with each interval. \\n- Then, for each time we remove the interval with most overlapping interval(let's call it A)\\n- And we update the other intervals' overlapping time which is overlapped with A.\\n- When all interval has zero overlapping times, we get the result.\\n\\nI know how to do it in greedy in O(nlgn) time, but I wonder why this cant work... \\nThis idea failed in the last test case(that with 10k inputs).I can't figure out why... Can someone help me?please...?\\nThanks your time for seeing these. Thank you~"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@nsut_coder](/nsut_coder) It would still not work if we remove all duplicates. Consider the same example, but add small random fractional values to each start and end. No duplicates, but the answer remains the same,"
                    },
                    {
                        "username": "bparanj",
                        "content": "The strategy you described is known as the \"interval graph coloring\" problem and it\\'s not equivalent to the interval scheduling problem we are solving here. You are describing an approach in which we try to color intervals (remove as few as possible) such that no two overlapping intervals share the same color. That is a more complicated problem and is not what we are trying to solve here.\\n\\nYou are trying to remove the interval that has the most overlaps first. This approach does not always lead to the optimal solution. Consider the following example:\\n\\n[[1, 5], [2, 3], [3, 4], [4, 5]]\\n\\nIf we follow your approach, we\\'ll remove [1, 5] first, because it overlaps with the most intervals. But this leads to the need of removing 1 interval, while the optimal solution would be to remove none. If we select [2, 3], [3, 4], [4, 5], we can see that none of these intervals overlap, which leads to the optimal solution of 0 removals.\\n\\nThis shows why the greedy algorithm of always choosing the interval that ends the earliest works: it leaves the most room for the rest of the intervals to not overlap.\\n\\nSo the intuition for the greedy algorithm in this problem is: the sooner an interval ends, the more room we have for the rest of the intervals to fit in without overlapping. It\\'s about looking ahead and trying to leave as much room as possible for the future intervals."
                    },
                    {
                        "username": "nsut_coder",
                        "content": "[@bharathi1121](/bharathi1121) I think, algorithm would work if we remove the duplicate ranges. but how would algorithm decide which interval to remove when all of them are overlapping with same number of intervals. "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "It doesnt work because its not always the largest overlapping interval to be removed first,\\nex: [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]\\nin this example the largest overlapping interval is [2,4] but it is part of the answer."
                    }
                ]
            },
            {
                "id": 1976780,
                "content": [
                    {
                        "username": "ZimmAgu",
                        "content": "#### Initial Steps\\n* Sort the given intervals based on starting points\\n* While considering the intervals in the ascending order of starting points\\n\\t* we make use of a pointer prev pointer \\n\\t* to keep track of the interval just included in the final list\\n![image](https://assets.leetcode.com/users/images/515fa83b-44c2-4c42-8ef5-d41c7942ec32_1653774876.169032.jpeg)\\n\\n\\n\\n#### Case 1\\n* You don\\'t need to remove any intervals\\n* Continue by simply assigning the *prev* pointer to the later interval\\n* The count of intervals removed remains unchanged\\n\\n\\n#### Case 2\\n* Remove the interval with the later end point \\n* The *prev* pointer is updated to current interval\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Case 3\\n* Remove the interval with the later end point \\n* The *prev* pointer remains unchanged\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Rule of Thumb\\n* Always choose the interval that ends first\\n\\n"
                    },
                    {
                        "username": "Muhammadamin",
                        "content": "[@rohitanjane999](/rohitanjane999)  + "
                    },
                    {
                        "username": "MayuD",
                        "content": "Thank you\nThe second case had got me"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "That was really good...thanks"
                    },
                    {
                        "username": "0x415374",
                        "content": "Pretty intuitive! Unfortunately I was not able to figure this out in a reasonable amount of time."
                    },
                    {
                        "username": "voodooism",
                        "content": "with this explanation the problem becomes easy!\\nthanks!"
                    },
                    {
                        "username": "rohitanjane999",
                        "content": "thanks for explanation...."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "And this marks my 200 days of streak..."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "So i\\'m not alone. [@sarpalmadhav](/sarpalmadhav)[@Ashutosh kumar](/ashurockzz) We started on jan1. Hope we complete our 365 days challenge."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ashu0123](/ashu0123) Congrats! Same here. I too have hit 200. We both started on Jan 1!!\\n"
                    },
                    {
                        "username": "ashu0123",
                        "content": "Looks like you\\'ve used Time travel tickets"
                    },
                    {
                        "username": "oops_moment",
                        "content": "If you\\'ve already cracked this challenging problem, kudos to you! If not, fret not! Let\\'s go step by step to find the perfect solution together! \\uD83D\\uDCAA\\n\\n\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F Problem Analysis:\\nWe\\'re given an array of intervals, and the goal is to find the minimum number of intervals to remove to make the rest non-overlapping. To achieve this, we\\'ll apply the greedy approach.\\n\\n\\u2B50 Greedy Insight:\\nLet\\'s try out a few greedy strategies. Say we select the interval with the smallest start time. Oops! This fails when the interval with the smallest start time also happens to be the longest one, leading to many overlapping intervals that need to be discarded.\\n\\n\\uD83D\\uDCA1 The Winning Greedy Strategy:\\nInstead, let\\'s sort the intervals based on their end times. Why? Imagine two intervals, one ending at x and the other ending at y (where x < y). If we skip the interval ending at x and take the one ending at y, we\\'ll may have to remove at least one interval that starts in the range (x, y). So, we should always sort based on the end time of intervals.\\n\\n\\uD83D\\uDEE0\\uFE0F Implementation:\\n\\n1: Sort the intervals based on their end times in ascending order.\\n\\n2: Initialize a variable \\'answer\\' to keep track of the number of intervals to be removed.\\n\\n3: Consider the first interval as \\'last\\' or the last taken interval.\\n\\n4: Iterate through the intervals, and for each interval:\\n\\n- If the current interval\\'s start time is less than the end time of the \\'last\\' interval, they overlap. Increment \\'answer\\' as we need to remove an interval to avoid overlap.\\n\\n- Otherwise, update \\'last\\' to the current interval.\\n\\n5: Return the final value of answer.\\n\\nNow you can confidently explain this solution to others and spread the joy of problem-solving! Happy coding! \\uD83D\\uDE80"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I don\\'t get why sorting by the end of the range helps.\\nI did\\n```\\nintervals.sort(key=lambda x: x[1])\\n```"
                    },
                    {
                        "username": "jkswapnil99",
                        "content": "Why is greedy solution correct for this problem. How do we know that, of all the ways in which intervals can be deleted the greedy approach is the optimal strategy?\\n\\nI always have trouble proving this for greedy solutions"
                    },
                    {
                        "username": "aLaN09",
                        "content": "[@bparanj](/bparanj) Nicely written"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The \"proof\" does not convince me for at least a two reasons:\\n\\n1) If there is an optimal solution different from ours, why must there an interval `i` with end time larger than ours?\\n2) We have no idea where `x` starts, how do we guarantee adding `x` after removing `i` won\\'t introduce conflicts?\\n\\nSince this is a classic problem - the proof is publicly available - all we needed is to do some search. For example, there is a one liner proof on wikipedia here. https://en.wikipedia.org/wiki/Interval_scheduling#Unweighted"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand your confusion. Proving the correctness of a greedy solution can often be tricky. For this particular problem, we could demonstrate the greedy choice property and optimal substructure, two key characteristics of problems that can be solved using a greedy approach.\\n\\nThe **greedy choice property** means that a local optimum can lead to a global optimum. For this problem, the local optimum is to always select the interval with the earliest end time that doesn\\'t overlap with the current one. This choice leaves as much space as possible for the remaining intervals. If we can prove that making the greedy choice at each step leads to the solution of the overall problem, then we\\'ve shown the greedy choice property.\\n\\nThe **optimal substructure** means that an optimal solution to the problem can be constructed efficiently from optimal solutions to its subproblems. In this problem, once we make the greedy choice of picking the interval with the earliest end time, we\\'re left with a smaller subproblem: finding the optimal solution in the remaining intervals.\\n\\nHere\\'s the intuition for why this greedy strategy works:\\n\\nThe crucial observation is that the interval with the earliest end time is least likely to overlap with other intervals. Hence, keeping this interval in our solution gives us the maximum space to accommodate the remaining intervals, which in turn reduces the number of removals. \\n\\nNow, let\\'s say there\\'s an optimal solution different from ours that keeps an interval `i` with an end time later than the one we chose (let\\'s call our interval `x`). We can replace `i` with `x` in this solution, and it\\'s guaranteed not to create more overlaps because `x` ends earlier than `i`. Therefore, the new solution is still optimal, showing that our greedy choice doesn\\'t lead to a worse solution.\\n\\nThis demonstrates that the greedy choice leads to an optimal solution and that the problem has an optimal substructure, thus validating our greedy solution."
                    },
                    {
                        "username": "abhay3141",
                        "content": "Getting Time limit Exceeded even though all 58/58 case passed. Any help ?"
                    },
                    {
                        "username": "jason3410",
                        "content": "You could just regard it as a regular TLE . It\\'s just a relatively closer one."
                    },
                    {
                        "username": "spookyflame",
                        "content": "[@cqrbala](/cqrbala) ty it worked. Forgot about that lmao"
                    },
                    {
                        "username": "cqrbala",
                        "content": "[@tanisha_daharwal](/tanisha_daharwal) [@Abhay](/abhay3141) Try to pass the vectors in the comparison function by reference (using & in c++). It is much faster as there is no need to make a copy of the vectors to perform the comparison."
                    },
                    {
                        "username": "tanisha_daharwal",
                        "content": "same thing happening with me"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Task failed successfully!"
                    },
                    {
                        "username": "ashu-xx",
                        "content": "[[1,100],[11,22],[1,11],[2,12]] \\nExpect: 2\\n\\nAccording to me expected answer should be 3 because [1,100] cannot be removed and all other 3 intervals are sub-intervals of [1,100].\\n\\nCan someone explain why is expected answer 2?"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "[@Ashutosh Mittal](/ashu-xx) in above case when we consider [1, 100] it will remove 3  other interval. but there a one option remain ie Consider [11,22] and [1, 11] than there is two inverval which are overlapping with these two [1,100] and [2,12] from the two option 3,  2, 2 option minimum so the result should be 2"
                    },
                    {
                        "username": "sasimouni",
                        "content": "[@bparanj](/bparanj)  nice explanation "
                    },
                    {
                        "username": "vermadeepesh248",
                        "content": "question said to remove minimum number of intervals. \\n\\nif we let [1,100] stay then we have to remove remaining three intervals.\\nbut instead if we remove [1,100] and [2,12] then we can let [1,11] and [11,22] stay. In this case we are removing only 2 intervals. so output should be 2."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@ShaliniMishra31](/ShaliniMishra31) [@ShaliniMishra31](/ShaliniMishra31) Your approach is not completely incorrect, but it\\'s not the most optimal one. In your solution, you are trying to represent the intervals on a number line and mark the occupied points. However, this approach has a couple of significant issues:\\n\\n1. It doesn\\'t consider the interval as a whole. Intervals are more than just individual points on a line, and their overlaps can\\'t always be accurately represented by the overlap of individual points.\\n\\n2. It doesn\\'t correctly account for the case when a smaller interval is entirely within a larger one. Your solution may consider the larger interval to be overlapping, even if removing the smaller one would make all intervals non-overlapping.\\n\\n3. Your solution has a time complexity of O(N^2), which is not efficient for large inputs.\\n\\nHere is an optimal solution using the greedy algorithm. It sorts the intervals by their end time and always tries to keep the one that ends earlier. This approach ensures we have more room for the remaining intervals.\\n\\nIn C++, it would look something like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 0) return 0;\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int ans = 0, end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i][0] < end){\\n                ans++;\\n            }\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution, we first sort the intervals by their end time. Then, we iterate over the sorted intervals. For each interval, if its start time is less than the end time of the previous interval, we increment our count (as it\\'s overlapping and needs to be removed). Otherwise, we update our end time to the current interval\\'s end time. This solution has a time complexity of O(N log N), which is more efficient."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected answer is 2 because the optimal solution doesn\\'t necessarily require keeping the interval [1,100]. It seems like you\\'re operating under the assumption that the larger interval has to be kept, but that\\'s not always the case.\\n\\nLet\\'s examine the problem with the given list of intervals:\\n\\n[[1,100],[11,22],[1,11],[2,12]]\\n\\nA key point to remember is that the objective is to minimize the number of removals so as to make the remaining intervals non-overlapping. To achieve this, the optimal strategy involves removing the intervals that cause the most overlaps. In this case, interval [1,100] overlaps with all other intervals, so if we keep it, we\\'d need to remove all other intervals, which is not optimal.\\n\\nInstead, if we remove [1,100], we\\'re left with:\\n\\n[[11,22],[1,11],[2,12]]\\n\\nOut of these, [1,11] and [11,22] don\\'t overlap. However, [2,12] overlaps with both. Thus, we can remove [2,12] to make the remaining intervals non-overlapping. This way, we only need to remove 2 intervals ([1,100] and [2,12]), which is why the expected answer is 2."
                    },
                    {
                        "username": "ShaliniMishra31",
                        "content": "[@cpblnc](/cpblnc) Could you explain again?\nI have the same doubt \n\nHere is my solution:\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        vector <pair<int,int>> vec(100000, {0,0});\n        int ans = 0;\n        for(int i=0;i<intervals.size();i++)\n        {\n            int f = intervals[i][0];\n            int s = intervals[i][1];\n            int dif = s-f;\n            int c = 0;\n            for(int j=f;j<=s;j++)\n            {\n                if(vec[j].second != 1)\n                {\n                    vec[j].first = j;\n                    vec[j].second = 1;\n                }\n                else\n                {\n                    c++;\n                }\n            }\n            if(c > dif)\n            {\n                ans++;\n            }\n        }\n        return(ans);\n    }\n};\n"
                    },
                    {
                        "username": "cpblnc",
                        "content": "Why can\\'t [1,100] be removed? If you remove it and [2,12] as well, you are left with [1,11] and [11,22], which are non overlapping - 2 intervals got removed, as expected."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Sort & Greedy make people happy!"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After I saw this problem, My first thought was to use `Binary Search` with `DP` and solved it."
                    },
                    {
                        "username": "sunny8080",
                        "content": "[@ashish15678](/ashish15678) For every index, find next non-overlapping intervel using `Binary Search`. \\nFor more, just take a look at [My Solution](https://leetcode.com/problems/non-overlapping-intervals/solutions/3788241/c-java-easy-and-clean-code-dp-greedy-beats/)"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@ashish15678](/ashish15678)  u can see my soln, i also did it using DP and Binary Search. \\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/solutions/3789308/dp-binary-search-solution/"
                    },
                    {
                        "username": "ashish15678",
                        "content": "can you please explain more\\n"
                    },
                    {
                        "username": "user4653c",
                        "content": "Labeling this problem as Dynamic Programming is a bit of a nasty move. To solve it, you need to find the right intuition, attempting the DP approach will just make things more confusing"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@Charlemagne5t](/Charlemagne5t) well true it can be difficult, trying joting down all possible scenarios and see if your greedy (or any other) approach works, if it does then try to find a justification for it, sometimes u may pass the question by implementing a approach but can\\'t think of a proof of it, can happen if the proof is mathematically rigorous "
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Agreed. Tried straight forward recursion + caching and got TLE 54/58. What I like about this approach it guarantees the right answer. Greedy is more optimal solution, but how do I prove it in real world problems when I don\\'t have rich test cases sample. I need to improve my knowledge in that field I guess. "
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "It's easy to think that:\\n- If we count the overlapping times with each interval. \\n- Then, for each time we remove the interval with most overlapping interval(let's call it A)\\n- And we update the other intervals' overlapping time which is overlapped with A.\\n- When all interval has zero overlapping times, we get the result.\\n\\nI know how to do it in greedy in O(nlgn) time, but I wonder why this cant work... \\nThis idea failed in the last test case(that with 10k inputs).I can't figure out why... Can someone help me?please...?\\nThanks your time for seeing these. Thank you~"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@nsut_coder](/nsut_coder) It would still not work if we remove all duplicates. Consider the same example, but add small random fractional values to each start and end. No duplicates, but the answer remains the same,"
                    },
                    {
                        "username": "bparanj",
                        "content": "The strategy you described is known as the \"interval graph coloring\" problem and it\\'s not equivalent to the interval scheduling problem we are solving here. You are describing an approach in which we try to color intervals (remove as few as possible) such that no two overlapping intervals share the same color. That is a more complicated problem and is not what we are trying to solve here.\\n\\nYou are trying to remove the interval that has the most overlaps first. This approach does not always lead to the optimal solution. Consider the following example:\\n\\n[[1, 5], [2, 3], [3, 4], [4, 5]]\\n\\nIf we follow your approach, we\\'ll remove [1, 5] first, because it overlaps with the most intervals. But this leads to the need of removing 1 interval, while the optimal solution would be to remove none. If we select [2, 3], [3, 4], [4, 5], we can see that none of these intervals overlap, which leads to the optimal solution of 0 removals.\\n\\nThis shows why the greedy algorithm of always choosing the interval that ends the earliest works: it leaves the most room for the rest of the intervals to not overlap.\\n\\nSo the intuition for the greedy algorithm in this problem is: the sooner an interval ends, the more room we have for the rest of the intervals to fit in without overlapping. It\\'s about looking ahead and trying to leave as much room as possible for the future intervals."
                    },
                    {
                        "username": "nsut_coder",
                        "content": "[@bharathi1121](/bharathi1121) I think, algorithm would work if we remove the duplicate ranges. but how would algorithm decide which interval to remove when all of them are overlapping with same number of intervals. "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "It doesnt work because its not always the largest overlapping interval to be removed first,\\nex: [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]\\nin this example the largest overlapping interval is [2,4] but it is part of the answer."
                    }
                ]
            },
            {
                "id": 1920316,
                "content": [
                    {
                        "username": "ZimmAgu",
                        "content": "#### Initial Steps\\n* Sort the given intervals based on starting points\\n* While considering the intervals in the ascending order of starting points\\n\\t* we make use of a pointer prev pointer \\n\\t* to keep track of the interval just included in the final list\\n![image](https://assets.leetcode.com/users/images/515fa83b-44c2-4c42-8ef5-d41c7942ec32_1653774876.169032.jpeg)\\n\\n\\n\\n#### Case 1\\n* You don\\'t need to remove any intervals\\n* Continue by simply assigning the *prev* pointer to the later interval\\n* The count of intervals removed remains unchanged\\n\\n\\n#### Case 2\\n* Remove the interval with the later end point \\n* The *prev* pointer is updated to current interval\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Case 3\\n* Remove the interval with the later end point \\n* The *prev* pointer remains unchanged\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Rule of Thumb\\n* Always choose the interval that ends first\\n\\n"
                    },
                    {
                        "username": "Muhammadamin",
                        "content": "[@rohitanjane999](/rohitanjane999)  + "
                    },
                    {
                        "username": "MayuD",
                        "content": "Thank you\nThe second case had got me"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "That was really good...thanks"
                    },
                    {
                        "username": "0x415374",
                        "content": "Pretty intuitive! Unfortunately I was not able to figure this out in a reasonable amount of time."
                    },
                    {
                        "username": "voodooism",
                        "content": "with this explanation the problem becomes easy!\\nthanks!"
                    },
                    {
                        "username": "rohitanjane999",
                        "content": "thanks for explanation...."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "And this marks my 200 days of streak..."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "So i\\'m not alone. [@sarpalmadhav](/sarpalmadhav)[@Ashutosh kumar](/ashurockzz) We started on jan1. Hope we complete our 365 days challenge."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ashu0123](/ashu0123) Congrats! Same here. I too have hit 200. We both started on Jan 1!!\\n"
                    },
                    {
                        "username": "ashu0123",
                        "content": "Looks like you\\'ve used Time travel tickets"
                    },
                    {
                        "username": "oops_moment",
                        "content": "If you\\'ve already cracked this challenging problem, kudos to you! If not, fret not! Let\\'s go step by step to find the perfect solution together! \\uD83D\\uDCAA\\n\\n\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F Problem Analysis:\\nWe\\'re given an array of intervals, and the goal is to find the minimum number of intervals to remove to make the rest non-overlapping. To achieve this, we\\'ll apply the greedy approach.\\n\\n\\u2B50 Greedy Insight:\\nLet\\'s try out a few greedy strategies. Say we select the interval with the smallest start time. Oops! This fails when the interval with the smallest start time also happens to be the longest one, leading to many overlapping intervals that need to be discarded.\\n\\n\\uD83D\\uDCA1 The Winning Greedy Strategy:\\nInstead, let\\'s sort the intervals based on their end times. Why? Imagine two intervals, one ending at x and the other ending at y (where x < y). If we skip the interval ending at x and take the one ending at y, we\\'ll may have to remove at least one interval that starts in the range (x, y). So, we should always sort based on the end time of intervals.\\n\\n\\uD83D\\uDEE0\\uFE0F Implementation:\\n\\n1: Sort the intervals based on their end times in ascending order.\\n\\n2: Initialize a variable \\'answer\\' to keep track of the number of intervals to be removed.\\n\\n3: Consider the first interval as \\'last\\' or the last taken interval.\\n\\n4: Iterate through the intervals, and for each interval:\\n\\n- If the current interval\\'s start time is less than the end time of the \\'last\\' interval, they overlap. Increment \\'answer\\' as we need to remove an interval to avoid overlap.\\n\\n- Otherwise, update \\'last\\' to the current interval.\\n\\n5: Return the final value of answer.\\n\\nNow you can confidently explain this solution to others and spread the joy of problem-solving! Happy coding! \\uD83D\\uDE80"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I don\\'t get why sorting by the end of the range helps.\\nI did\\n```\\nintervals.sort(key=lambda x: x[1])\\n```"
                    },
                    {
                        "username": "jkswapnil99",
                        "content": "Why is greedy solution correct for this problem. How do we know that, of all the ways in which intervals can be deleted the greedy approach is the optimal strategy?\\n\\nI always have trouble proving this for greedy solutions"
                    },
                    {
                        "username": "aLaN09",
                        "content": "[@bparanj](/bparanj) Nicely written"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The \"proof\" does not convince me for at least a two reasons:\\n\\n1) If there is an optimal solution different from ours, why must there an interval `i` with end time larger than ours?\\n2) We have no idea where `x` starts, how do we guarantee adding `x` after removing `i` won\\'t introduce conflicts?\\n\\nSince this is a classic problem - the proof is publicly available - all we needed is to do some search. For example, there is a one liner proof on wikipedia here. https://en.wikipedia.org/wiki/Interval_scheduling#Unweighted"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand your confusion. Proving the correctness of a greedy solution can often be tricky. For this particular problem, we could demonstrate the greedy choice property and optimal substructure, two key characteristics of problems that can be solved using a greedy approach.\\n\\nThe **greedy choice property** means that a local optimum can lead to a global optimum. For this problem, the local optimum is to always select the interval with the earliest end time that doesn\\'t overlap with the current one. This choice leaves as much space as possible for the remaining intervals. If we can prove that making the greedy choice at each step leads to the solution of the overall problem, then we\\'ve shown the greedy choice property.\\n\\nThe **optimal substructure** means that an optimal solution to the problem can be constructed efficiently from optimal solutions to its subproblems. In this problem, once we make the greedy choice of picking the interval with the earliest end time, we\\'re left with a smaller subproblem: finding the optimal solution in the remaining intervals.\\n\\nHere\\'s the intuition for why this greedy strategy works:\\n\\nThe crucial observation is that the interval with the earliest end time is least likely to overlap with other intervals. Hence, keeping this interval in our solution gives us the maximum space to accommodate the remaining intervals, which in turn reduces the number of removals. \\n\\nNow, let\\'s say there\\'s an optimal solution different from ours that keeps an interval `i` with an end time later than the one we chose (let\\'s call our interval `x`). We can replace `i` with `x` in this solution, and it\\'s guaranteed not to create more overlaps because `x` ends earlier than `i`. Therefore, the new solution is still optimal, showing that our greedy choice doesn\\'t lead to a worse solution.\\n\\nThis demonstrates that the greedy choice leads to an optimal solution and that the problem has an optimal substructure, thus validating our greedy solution."
                    },
                    {
                        "username": "abhay3141",
                        "content": "Getting Time limit Exceeded even though all 58/58 case passed. Any help ?"
                    },
                    {
                        "username": "jason3410",
                        "content": "You could just regard it as a regular TLE . It\\'s just a relatively closer one."
                    },
                    {
                        "username": "spookyflame",
                        "content": "[@cqrbala](/cqrbala) ty it worked. Forgot about that lmao"
                    },
                    {
                        "username": "cqrbala",
                        "content": "[@tanisha_daharwal](/tanisha_daharwal) [@Abhay](/abhay3141) Try to pass the vectors in the comparison function by reference (using & in c++). It is much faster as there is no need to make a copy of the vectors to perform the comparison."
                    },
                    {
                        "username": "tanisha_daharwal",
                        "content": "same thing happening with me"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Task failed successfully!"
                    },
                    {
                        "username": "ashu-xx",
                        "content": "[[1,100],[11,22],[1,11],[2,12]] \\nExpect: 2\\n\\nAccording to me expected answer should be 3 because [1,100] cannot be removed and all other 3 intervals are sub-intervals of [1,100].\\n\\nCan someone explain why is expected answer 2?"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "[@Ashutosh Mittal](/ashu-xx) in above case when we consider [1, 100] it will remove 3  other interval. but there a one option remain ie Consider [11,22] and [1, 11] than there is two inverval which are overlapping with these two [1,100] and [2,12] from the two option 3,  2, 2 option minimum so the result should be 2"
                    },
                    {
                        "username": "sasimouni",
                        "content": "[@bparanj](/bparanj)  nice explanation "
                    },
                    {
                        "username": "vermadeepesh248",
                        "content": "question said to remove minimum number of intervals. \\n\\nif we let [1,100] stay then we have to remove remaining three intervals.\\nbut instead if we remove [1,100] and [2,12] then we can let [1,11] and [11,22] stay. In this case we are removing only 2 intervals. so output should be 2."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@ShaliniMishra31](/ShaliniMishra31) [@ShaliniMishra31](/ShaliniMishra31) Your approach is not completely incorrect, but it\\'s not the most optimal one. In your solution, you are trying to represent the intervals on a number line and mark the occupied points. However, this approach has a couple of significant issues:\\n\\n1. It doesn\\'t consider the interval as a whole. Intervals are more than just individual points on a line, and their overlaps can\\'t always be accurately represented by the overlap of individual points.\\n\\n2. It doesn\\'t correctly account for the case when a smaller interval is entirely within a larger one. Your solution may consider the larger interval to be overlapping, even if removing the smaller one would make all intervals non-overlapping.\\n\\n3. Your solution has a time complexity of O(N^2), which is not efficient for large inputs.\\n\\nHere is an optimal solution using the greedy algorithm. It sorts the intervals by their end time and always tries to keep the one that ends earlier. This approach ensures we have more room for the remaining intervals.\\n\\nIn C++, it would look something like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 0) return 0;\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int ans = 0, end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i][0] < end){\\n                ans++;\\n            }\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution, we first sort the intervals by their end time. Then, we iterate over the sorted intervals. For each interval, if its start time is less than the end time of the previous interval, we increment our count (as it\\'s overlapping and needs to be removed). Otherwise, we update our end time to the current interval\\'s end time. This solution has a time complexity of O(N log N), which is more efficient."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected answer is 2 because the optimal solution doesn\\'t necessarily require keeping the interval [1,100]. It seems like you\\'re operating under the assumption that the larger interval has to be kept, but that\\'s not always the case.\\n\\nLet\\'s examine the problem with the given list of intervals:\\n\\n[[1,100],[11,22],[1,11],[2,12]]\\n\\nA key point to remember is that the objective is to minimize the number of removals so as to make the remaining intervals non-overlapping. To achieve this, the optimal strategy involves removing the intervals that cause the most overlaps. In this case, interval [1,100] overlaps with all other intervals, so if we keep it, we\\'d need to remove all other intervals, which is not optimal.\\n\\nInstead, if we remove [1,100], we\\'re left with:\\n\\n[[11,22],[1,11],[2,12]]\\n\\nOut of these, [1,11] and [11,22] don\\'t overlap. However, [2,12] overlaps with both. Thus, we can remove [2,12] to make the remaining intervals non-overlapping. This way, we only need to remove 2 intervals ([1,100] and [2,12]), which is why the expected answer is 2."
                    },
                    {
                        "username": "ShaliniMishra31",
                        "content": "[@cpblnc](/cpblnc) Could you explain again?\nI have the same doubt \n\nHere is my solution:\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        vector <pair<int,int>> vec(100000, {0,0});\n        int ans = 0;\n        for(int i=0;i<intervals.size();i++)\n        {\n            int f = intervals[i][0];\n            int s = intervals[i][1];\n            int dif = s-f;\n            int c = 0;\n            for(int j=f;j<=s;j++)\n            {\n                if(vec[j].second != 1)\n                {\n                    vec[j].first = j;\n                    vec[j].second = 1;\n                }\n                else\n                {\n                    c++;\n                }\n            }\n            if(c > dif)\n            {\n                ans++;\n            }\n        }\n        return(ans);\n    }\n};\n"
                    },
                    {
                        "username": "cpblnc",
                        "content": "Why can\\'t [1,100] be removed? If you remove it and [2,12] as well, you are left with [1,11] and [11,22], which are non overlapping - 2 intervals got removed, as expected."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Sort & Greedy make people happy!"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After I saw this problem, My first thought was to use `Binary Search` with `DP` and solved it."
                    },
                    {
                        "username": "sunny8080",
                        "content": "[@ashish15678](/ashish15678) For every index, find next non-overlapping intervel using `Binary Search`. \\nFor more, just take a look at [My Solution](https://leetcode.com/problems/non-overlapping-intervals/solutions/3788241/c-java-easy-and-clean-code-dp-greedy-beats/)"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@ashish15678](/ashish15678)  u can see my soln, i also did it using DP and Binary Search. \\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/solutions/3789308/dp-binary-search-solution/"
                    },
                    {
                        "username": "ashish15678",
                        "content": "can you please explain more\\n"
                    },
                    {
                        "username": "user4653c",
                        "content": "Labeling this problem as Dynamic Programming is a bit of a nasty move. To solve it, you need to find the right intuition, attempting the DP approach will just make things more confusing"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@Charlemagne5t](/Charlemagne5t) well true it can be difficult, trying joting down all possible scenarios and see if your greedy (or any other) approach works, if it does then try to find a justification for it, sometimes u may pass the question by implementing a approach but can\\'t think of a proof of it, can happen if the proof is mathematically rigorous "
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Agreed. Tried straight forward recursion + caching and got TLE 54/58. What I like about this approach it guarantees the right answer. Greedy is more optimal solution, but how do I prove it in real world problems when I don\\'t have rich test cases sample. I need to improve my knowledge in that field I guess. "
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "It's easy to think that:\\n- If we count the overlapping times with each interval. \\n- Then, for each time we remove the interval with most overlapping interval(let's call it A)\\n- And we update the other intervals' overlapping time which is overlapped with A.\\n- When all interval has zero overlapping times, we get the result.\\n\\nI know how to do it in greedy in O(nlgn) time, but I wonder why this cant work... \\nThis idea failed in the last test case(that with 10k inputs).I can't figure out why... Can someone help me?please...?\\nThanks your time for seeing these. Thank you~"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@nsut_coder](/nsut_coder) It would still not work if we remove all duplicates. Consider the same example, but add small random fractional values to each start and end. No duplicates, but the answer remains the same,"
                    },
                    {
                        "username": "bparanj",
                        "content": "The strategy you described is known as the \"interval graph coloring\" problem and it\\'s not equivalent to the interval scheduling problem we are solving here. You are describing an approach in which we try to color intervals (remove as few as possible) such that no two overlapping intervals share the same color. That is a more complicated problem and is not what we are trying to solve here.\\n\\nYou are trying to remove the interval that has the most overlaps first. This approach does not always lead to the optimal solution. Consider the following example:\\n\\n[[1, 5], [2, 3], [3, 4], [4, 5]]\\n\\nIf we follow your approach, we\\'ll remove [1, 5] first, because it overlaps with the most intervals. But this leads to the need of removing 1 interval, while the optimal solution would be to remove none. If we select [2, 3], [3, 4], [4, 5], we can see that none of these intervals overlap, which leads to the optimal solution of 0 removals.\\n\\nThis shows why the greedy algorithm of always choosing the interval that ends the earliest works: it leaves the most room for the rest of the intervals to not overlap.\\n\\nSo the intuition for the greedy algorithm in this problem is: the sooner an interval ends, the more room we have for the rest of the intervals to fit in without overlapping. It\\'s about looking ahead and trying to leave as much room as possible for the future intervals."
                    },
                    {
                        "username": "nsut_coder",
                        "content": "[@bharathi1121](/bharathi1121) I think, algorithm would work if we remove the duplicate ranges. but how would algorithm decide which interval to remove when all of them are overlapping with same number of intervals. "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "It doesnt work because its not always the largest overlapping interval to be removed first,\\nex: [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]\\nin this example the largest overlapping interval is [2,4] but it is part of the answer."
                    }
                ]
            },
            {
                "id": 1571704,
                "content": [
                    {
                        "username": "ZimmAgu",
                        "content": "#### Initial Steps\\n* Sort the given intervals based on starting points\\n* While considering the intervals in the ascending order of starting points\\n\\t* we make use of a pointer prev pointer \\n\\t* to keep track of the interval just included in the final list\\n![image](https://assets.leetcode.com/users/images/515fa83b-44c2-4c42-8ef5-d41c7942ec32_1653774876.169032.jpeg)\\n\\n\\n\\n#### Case 1\\n* You don\\'t need to remove any intervals\\n* Continue by simply assigning the *prev* pointer to the later interval\\n* The count of intervals removed remains unchanged\\n\\n\\n#### Case 2\\n* Remove the interval with the later end point \\n* The *prev* pointer is updated to current interval\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Case 3\\n* Remove the interval with the later end point \\n* The *prev* pointer remains unchanged\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Rule of Thumb\\n* Always choose the interval that ends first\\n\\n"
                    },
                    {
                        "username": "Muhammadamin",
                        "content": "[@rohitanjane999](/rohitanjane999)  + "
                    },
                    {
                        "username": "MayuD",
                        "content": "Thank you\nThe second case had got me"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "That was really good...thanks"
                    },
                    {
                        "username": "0x415374",
                        "content": "Pretty intuitive! Unfortunately I was not able to figure this out in a reasonable amount of time."
                    },
                    {
                        "username": "voodooism",
                        "content": "with this explanation the problem becomes easy!\\nthanks!"
                    },
                    {
                        "username": "rohitanjane999",
                        "content": "thanks for explanation...."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "And this marks my 200 days of streak..."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "So i\\'m not alone. [@sarpalmadhav](/sarpalmadhav)[@Ashutosh kumar](/ashurockzz) We started on jan1. Hope we complete our 365 days challenge."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ashu0123](/ashu0123) Congrats! Same here. I too have hit 200. We both started on Jan 1!!\\n"
                    },
                    {
                        "username": "ashu0123",
                        "content": "Looks like you\\'ve used Time travel tickets"
                    },
                    {
                        "username": "oops_moment",
                        "content": "If you\\'ve already cracked this challenging problem, kudos to you! If not, fret not! Let\\'s go step by step to find the perfect solution together! \\uD83D\\uDCAA\\n\\n\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F Problem Analysis:\\nWe\\'re given an array of intervals, and the goal is to find the minimum number of intervals to remove to make the rest non-overlapping. To achieve this, we\\'ll apply the greedy approach.\\n\\n\\u2B50 Greedy Insight:\\nLet\\'s try out a few greedy strategies. Say we select the interval with the smallest start time. Oops! This fails when the interval with the smallest start time also happens to be the longest one, leading to many overlapping intervals that need to be discarded.\\n\\n\\uD83D\\uDCA1 The Winning Greedy Strategy:\\nInstead, let\\'s sort the intervals based on their end times. Why? Imagine two intervals, one ending at x and the other ending at y (where x < y). If we skip the interval ending at x and take the one ending at y, we\\'ll may have to remove at least one interval that starts in the range (x, y). So, we should always sort based on the end time of intervals.\\n\\n\\uD83D\\uDEE0\\uFE0F Implementation:\\n\\n1: Sort the intervals based on their end times in ascending order.\\n\\n2: Initialize a variable \\'answer\\' to keep track of the number of intervals to be removed.\\n\\n3: Consider the first interval as \\'last\\' or the last taken interval.\\n\\n4: Iterate through the intervals, and for each interval:\\n\\n- If the current interval\\'s start time is less than the end time of the \\'last\\' interval, they overlap. Increment \\'answer\\' as we need to remove an interval to avoid overlap.\\n\\n- Otherwise, update \\'last\\' to the current interval.\\n\\n5: Return the final value of answer.\\n\\nNow you can confidently explain this solution to others and spread the joy of problem-solving! Happy coding! \\uD83D\\uDE80"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I don\\'t get why sorting by the end of the range helps.\\nI did\\n```\\nintervals.sort(key=lambda x: x[1])\\n```"
                    },
                    {
                        "username": "jkswapnil99",
                        "content": "Why is greedy solution correct for this problem. How do we know that, of all the ways in which intervals can be deleted the greedy approach is the optimal strategy?\\n\\nI always have trouble proving this for greedy solutions"
                    },
                    {
                        "username": "aLaN09",
                        "content": "[@bparanj](/bparanj) Nicely written"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The \"proof\" does not convince me for at least a two reasons:\\n\\n1) If there is an optimal solution different from ours, why must there an interval `i` with end time larger than ours?\\n2) We have no idea where `x` starts, how do we guarantee adding `x` after removing `i` won\\'t introduce conflicts?\\n\\nSince this is a classic problem - the proof is publicly available - all we needed is to do some search. For example, there is a one liner proof on wikipedia here. https://en.wikipedia.org/wiki/Interval_scheduling#Unweighted"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand your confusion. Proving the correctness of a greedy solution can often be tricky. For this particular problem, we could demonstrate the greedy choice property and optimal substructure, two key characteristics of problems that can be solved using a greedy approach.\\n\\nThe **greedy choice property** means that a local optimum can lead to a global optimum. For this problem, the local optimum is to always select the interval with the earliest end time that doesn\\'t overlap with the current one. This choice leaves as much space as possible for the remaining intervals. If we can prove that making the greedy choice at each step leads to the solution of the overall problem, then we\\'ve shown the greedy choice property.\\n\\nThe **optimal substructure** means that an optimal solution to the problem can be constructed efficiently from optimal solutions to its subproblems. In this problem, once we make the greedy choice of picking the interval with the earliest end time, we\\'re left with a smaller subproblem: finding the optimal solution in the remaining intervals.\\n\\nHere\\'s the intuition for why this greedy strategy works:\\n\\nThe crucial observation is that the interval with the earliest end time is least likely to overlap with other intervals. Hence, keeping this interval in our solution gives us the maximum space to accommodate the remaining intervals, which in turn reduces the number of removals. \\n\\nNow, let\\'s say there\\'s an optimal solution different from ours that keeps an interval `i` with an end time later than the one we chose (let\\'s call our interval `x`). We can replace `i` with `x` in this solution, and it\\'s guaranteed not to create more overlaps because `x` ends earlier than `i`. Therefore, the new solution is still optimal, showing that our greedy choice doesn\\'t lead to a worse solution.\\n\\nThis demonstrates that the greedy choice leads to an optimal solution and that the problem has an optimal substructure, thus validating our greedy solution."
                    },
                    {
                        "username": "abhay3141",
                        "content": "Getting Time limit Exceeded even though all 58/58 case passed. Any help ?"
                    },
                    {
                        "username": "jason3410",
                        "content": "You could just regard it as a regular TLE . It\\'s just a relatively closer one."
                    },
                    {
                        "username": "spookyflame",
                        "content": "[@cqrbala](/cqrbala) ty it worked. Forgot about that lmao"
                    },
                    {
                        "username": "cqrbala",
                        "content": "[@tanisha_daharwal](/tanisha_daharwal) [@Abhay](/abhay3141) Try to pass the vectors in the comparison function by reference (using & in c++). It is much faster as there is no need to make a copy of the vectors to perform the comparison."
                    },
                    {
                        "username": "tanisha_daharwal",
                        "content": "same thing happening with me"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Task failed successfully!"
                    },
                    {
                        "username": "ashu-xx",
                        "content": "[[1,100],[11,22],[1,11],[2,12]] \\nExpect: 2\\n\\nAccording to me expected answer should be 3 because [1,100] cannot be removed and all other 3 intervals are sub-intervals of [1,100].\\n\\nCan someone explain why is expected answer 2?"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "[@Ashutosh Mittal](/ashu-xx) in above case when we consider [1, 100] it will remove 3  other interval. but there a one option remain ie Consider [11,22] and [1, 11] than there is two inverval which are overlapping with these two [1,100] and [2,12] from the two option 3,  2, 2 option minimum so the result should be 2"
                    },
                    {
                        "username": "sasimouni",
                        "content": "[@bparanj](/bparanj)  nice explanation "
                    },
                    {
                        "username": "vermadeepesh248",
                        "content": "question said to remove minimum number of intervals. \\n\\nif we let [1,100] stay then we have to remove remaining three intervals.\\nbut instead if we remove [1,100] and [2,12] then we can let [1,11] and [11,22] stay. In this case we are removing only 2 intervals. so output should be 2."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@ShaliniMishra31](/ShaliniMishra31) [@ShaliniMishra31](/ShaliniMishra31) Your approach is not completely incorrect, but it\\'s not the most optimal one. In your solution, you are trying to represent the intervals on a number line and mark the occupied points. However, this approach has a couple of significant issues:\\n\\n1. It doesn\\'t consider the interval as a whole. Intervals are more than just individual points on a line, and their overlaps can\\'t always be accurately represented by the overlap of individual points.\\n\\n2. It doesn\\'t correctly account for the case when a smaller interval is entirely within a larger one. Your solution may consider the larger interval to be overlapping, even if removing the smaller one would make all intervals non-overlapping.\\n\\n3. Your solution has a time complexity of O(N^2), which is not efficient for large inputs.\\n\\nHere is an optimal solution using the greedy algorithm. It sorts the intervals by their end time and always tries to keep the one that ends earlier. This approach ensures we have more room for the remaining intervals.\\n\\nIn C++, it would look something like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 0) return 0;\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int ans = 0, end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i][0] < end){\\n                ans++;\\n            }\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution, we first sort the intervals by their end time. Then, we iterate over the sorted intervals. For each interval, if its start time is less than the end time of the previous interval, we increment our count (as it\\'s overlapping and needs to be removed). Otherwise, we update our end time to the current interval\\'s end time. This solution has a time complexity of O(N log N), which is more efficient."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected answer is 2 because the optimal solution doesn\\'t necessarily require keeping the interval [1,100]. It seems like you\\'re operating under the assumption that the larger interval has to be kept, but that\\'s not always the case.\\n\\nLet\\'s examine the problem with the given list of intervals:\\n\\n[[1,100],[11,22],[1,11],[2,12]]\\n\\nA key point to remember is that the objective is to minimize the number of removals so as to make the remaining intervals non-overlapping. To achieve this, the optimal strategy involves removing the intervals that cause the most overlaps. In this case, interval [1,100] overlaps with all other intervals, so if we keep it, we\\'d need to remove all other intervals, which is not optimal.\\n\\nInstead, if we remove [1,100], we\\'re left with:\\n\\n[[11,22],[1,11],[2,12]]\\n\\nOut of these, [1,11] and [11,22] don\\'t overlap. However, [2,12] overlaps with both. Thus, we can remove [2,12] to make the remaining intervals non-overlapping. This way, we only need to remove 2 intervals ([1,100] and [2,12]), which is why the expected answer is 2."
                    },
                    {
                        "username": "ShaliniMishra31",
                        "content": "[@cpblnc](/cpblnc) Could you explain again?\nI have the same doubt \n\nHere is my solution:\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        vector <pair<int,int>> vec(100000, {0,0});\n        int ans = 0;\n        for(int i=0;i<intervals.size();i++)\n        {\n            int f = intervals[i][0];\n            int s = intervals[i][1];\n            int dif = s-f;\n            int c = 0;\n            for(int j=f;j<=s;j++)\n            {\n                if(vec[j].second != 1)\n                {\n                    vec[j].first = j;\n                    vec[j].second = 1;\n                }\n                else\n                {\n                    c++;\n                }\n            }\n            if(c > dif)\n            {\n                ans++;\n            }\n        }\n        return(ans);\n    }\n};\n"
                    },
                    {
                        "username": "cpblnc",
                        "content": "Why can\\'t [1,100] be removed? If you remove it and [2,12] as well, you are left with [1,11] and [11,22], which are non overlapping - 2 intervals got removed, as expected."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Sort & Greedy make people happy!"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After I saw this problem, My first thought was to use `Binary Search` with `DP` and solved it."
                    },
                    {
                        "username": "sunny8080",
                        "content": "[@ashish15678](/ashish15678) For every index, find next non-overlapping intervel using `Binary Search`. \\nFor more, just take a look at [My Solution](https://leetcode.com/problems/non-overlapping-intervals/solutions/3788241/c-java-easy-and-clean-code-dp-greedy-beats/)"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@ashish15678](/ashish15678)  u can see my soln, i also did it using DP and Binary Search. \\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/solutions/3789308/dp-binary-search-solution/"
                    },
                    {
                        "username": "ashish15678",
                        "content": "can you please explain more\\n"
                    },
                    {
                        "username": "user4653c",
                        "content": "Labeling this problem as Dynamic Programming is a bit of a nasty move. To solve it, you need to find the right intuition, attempting the DP approach will just make things more confusing"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@Charlemagne5t](/Charlemagne5t) well true it can be difficult, trying joting down all possible scenarios and see if your greedy (or any other) approach works, if it does then try to find a justification for it, sometimes u may pass the question by implementing a approach but can\\'t think of a proof of it, can happen if the proof is mathematically rigorous "
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Agreed. Tried straight forward recursion + caching and got TLE 54/58. What I like about this approach it guarantees the right answer. Greedy is more optimal solution, but how do I prove it in real world problems when I don\\'t have rich test cases sample. I need to improve my knowledge in that field I guess. "
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "It's easy to think that:\\n- If we count the overlapping times with each interval. \\n- Then, for each time we remove the interval with most overlapping interval(let's call it A)\\n- And we update the other intervals' overlapping time which is overlapped with A.\\n- When all interval has zero overlapping times, we get the result.\\n\\nI know how to do it in greedy in O(nlgn) time, but I wonder why this cant work... \\nThis idea failed in the last test case(that with 10k inputs).I can't figure out why... Can someone help me?please...?\\nThanks your time for seeing these. Thank you~"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@nsut_coder](/nsut_coder) It would still not work if we remove all duplicates. Consider the same example, but add small random fractional values to each start and end. No duplicates, but the answer remains the same,"
                    },
                    {
                        "username": "bparanj",
                        "content": "The strategy you described is known as the \"interval graph coloring\" problem and it\\'s not equivalent to the interval scheduling problem we are solving here. You are describing an approach in which we try to color intervals (remove as few as possible) such that no two overlapping intervals share the same color. That is a more complicated problem and is not what we are trying to solve here.\\n\\nYou are trying to remove the interval that has the most overlaps first. This approach does not always lead to the optimal solution. Consider the following example:\\n\\n[[1, 5], [2, 3], [3, 4], [4, 5]]\\n\\nIf we follow your approach, we\\'ll remove [1, 5] first, because it overlaps with the most intervals. But this leads to the need of removing 1 interval, while the optimal solution would be to remove none. If we select [2, 3], [3, 4], [4, 5], we can see that none of these intervals overlap, which leads to the optimal solution of 0 removals.\\n\\nThis shows why the greedy algorithm of always choosing the interval that ends the earliest works: it leaves the most room for the rest of the intervals to not overlap.\\n\\nSo the intuition for the greedy algorithm in this problem is: the sooner an interval ends, the more room we have for the rest of the intervals to fit in without overlapping. It\\'s about looking ahead and trying to leave as much room as possible for the future intervals."
                    },
                    {
                        "username": "nsut_coder",
                        "content": "[@bharathi1121](/bharathi1121) I think, algorithm would work if we remove the duplicate ranges. but how would algorithm decide which interval to remove when all of them are overlapping with same number of intervals. "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "It doesnt work because its not always the largest overlapping interval to be removed first,\\nex: [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]\\nin this example the largest overlapping interval is [2,4] but it is part of the answer."
                    }
                ]
            },
            {
                "id": 1576818,
                "content": [
                    {
                        "username": "ZimmAgu",
                        "content": "#### Initial Steps\\n* Sort the given intervals based on starting points\\n* While considering the intervals in the ascending order of starting points\\n\\t* we make use of a pointer prev pointer \\n\\t* to keep track of the interval just included in the final list\\n![image](https://assets.leetcode.com/users/images/515fa83b-44c2-4c42-8ef5-d41c7942ec32_1653774876.169032.jpeg)\\n\\n\\n\\n#### Case 1\\n* You don\\'t need to remove any intervals\\n* Continue by simply assigning the *prev* pointer to the later interval\\n* The count of intervals removed remains unchanged\\n\\n\\n#### Case 2\\n* Remove the interval with the later end point \\n* The *prev* pointer is updated to current interval\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Case 3\\n* Remove the interval with the later end point \\n* The *prev* pointer remains unchanged\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Rule of Thumb\\n* Always choose the interval that ends first\\n\\n"
                    },
                    {
                        "username": "Muhammadamin",
                        "content": "[@rohitanjane999](/rohitanjane999)  + "
                    },
                    {
                        "username": "MayuD",
                        "content": "Thank you\nThe second case had got me"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "That was really good...thanks"
                    },
                    {
                        "username": "0x415374",
                        "content": "Pretty intuitive! Unfortunately I was not able to figure this out in a reasonable amount of time."
                    },
                    {
                        "username": "voodooism",
                        "content": "with this explanation the problem becomes easy!\\nthanks!"
                    },
                    {
                        "username": "rohitanjane999",
                        "content": "thanks for explanation...."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "And this marks my 200 days of streak..."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "So i\\'m not alone. [@sarpalmadhav](/sarpalmadhav)[@Ashutosh kumar](/ashurockzz) We started on jan1. Hope we complete our 365 days challenge."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ashu0123](/ashu0123) Congrats! Same here. I too have hit 200. We both started on Jan 1!!\\n"
                    },
                    {
                        "username": "ashu0123",
                        "content": "Looks like you\\'ve used Time travel tickets"
                    },
                    {
                        "username": "oops_moment",
                        "content": "If you\\'ve already cracked this challenging problem, kudos to you! If not, fret not! Let\\'s go step by step to find the perfect solution together! \\uD83D\\uDCAA\\n\\n\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F Problem Analysis:\\nWe\\'re given an array of intervals, and the goal is to find the minimum number of intervals to remove to make the rest non-overlapping. To achieve this, we\\'ll apply the greedy approach.\\n\\n\\u2B50 Greedy Insight:\\nLet\\'s try out a few greedy strategies. Say we select the interval with the smallest start time. Oops! This fails when the interval with the smallest start time also happens to be the longest one, leading to many overlapping intervals that need to be discarded.\\n\\n\\uD83D\\uDCA1 The Winning Greedy Strategy:\\nInstead, let\\'s sort the intervals based on their end times. Why? Imagine two intervals, one ending at x and the other ending at y (where x < y). If we skip the interval ending at x and take the one ending at y, we\\'ll may have to remove at least one interval that starts in the range (x, y). So, we should always sort based on the end time of intervals.\\n\\n\\uD83D\\uDEE0\\uFE0F Implementation:\\n\\n1: Sort the intervals based on their end times in ascending order.\\n\\n2: Initialize a variable \\'answer\\' to keep track of the number of intervals to be removed.\\n\\n3: Consider the first interval as \\'last\\' or the last taken interval.\\n\\n4: Iterate through the intervals, and for each interval:\\n\\n- If the current interval\\'s start time is less than the end time of the \\'last\\' interval, they overlap. Increment \\'answer\\' as we need to remove an interval to avoid overlap.\\n\\n- Otherwise, update \\'last\\' to the current interval.\\n\\n5: Return the final value of answer.\\n\\nNow you can confidently explain this solution to others and spread the joy of problem-solving! Happy coding! \\uD83D\\uDE80"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I don\\'t get why sorting by the end of the range helps.\\nI did\\n```\\nintervals.sort(key=lambda x: x[1])\\n```"
                    },
                    {
                        "username": "jkswapnil99",
                        "content": "Why is greedy solution correct for this problem. How do we know that, of all the ways in which intervals can be deleted the greedy approach is the optimal strategy?\\n\\nI always have trouble proving this for greedy solutions"
                    },
                    {
                        "username": "aLaN09",
                        "content": "[@bparanj](/bparanj) Nicely written"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The \"proof\" does not convince me for at least a two reasons:\\n\\n1) If there is an optimal solution different from ours, why must there an interval `i` with end time larger than ours?\\n2) We have no idea where `x` starts, how do we guarantee adding `x` after removing `i` won\\'t introduce conflicts?\\n\\nSince this is a classic problem - the proof is publicly available - all we needed is to do some search. For example, there is a one liner proof on wikipedia here. https://en.wikipedia.org/wiki/Interval_scheduling#Unweighted"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand your confusion. Proving the correctness of a greedy solution can often be tricky. For this particular problem, we could demonstrate the greedy choice property and optimal substructure, two key characteristics of problems that can be solved using a greedy approach.\\n\\nThe **greedy choice property** means that a local optimum can lead to a global optimum. For this problem, the local optimum is to always select the interval with the earliest end time that doesn\\'t overlap with the current one. This choice leaves as much space as possible for the remaining intervals. If we can prove that making the greedy choice at each step leads to the solution of the overall problem, then we\\'ve shown the greedy choice property.\\n\\nThe **optimal substructure** means that an optimal solution to the problem can be constructed efficiently from optimal solutions to its subproblems. In this problem, once we make the greedy choice of picking the interval with the earliest end time, we\\'re left with a smaller subproblem: finding the optimal solution in the remaining intervals.\\n\\nHere\\'s the intuition for why this greedy strategy works:\\n\\nThe crucial observation is that the interval with the earliest end time is least likely to overlap with other intervals. Hence, keeping this interval in our solution gives us the maximum space to accommodate the remaining intervals, which in turn reduces the number of removals. \\n\\nNow, let\\'s say there\\'s an optimal solution different from ours that keeps an interval `i` with an end time later than the one we chose (let\\'s call our interval `x`). We can replace `i` with `x` in this solution, and it\\'s guaranteed not to create more overlaps because `x` ends earlier than `i`. Therefore, the new solution is still optimal, showing that our greedy choice doesn\\'t lead to a worse solution.\\n\\nThis demonstrates that the greedy choice leads to an optimal solution and that the problem has an optimal substructure, thus validating our greedy solution."
                    },
                    {
                        "username": "abhay3141",
                        "content": "Getting Time limit Exceeded even though all 58/58 case passed. Any help ?"
                    },
                    {
                        "username": "jason3410",
                        "content": "You could just regard it as a regular TLE . It\\'s just a relatively closer one."
                    },
                    {
                        "username": "spookyflame",
                        "content": "[@cqrbala](/cqrbala) ty it worked. Forgot about that lmao"
                    },
                    {
                        "username": "cqrbala",
                        "content": "[@tanisha_daharwal](/tanisha_daharwal) [@Abhay](/abhay3141) Try to pass the vectors in the comparison function by reference (using & in c++). It is much faster as there is no need to make a copy of the vectors to perform the comparison."
                    },
                    {
                        "username": "tanisha_daharwal",
                        "content": "same thing happening with me"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Task failed successfully!"
                    },
                    {
                        "username": "ashu-xx",
                        "content": "[[1,100],[11,22],[1,11],[2,12]] \\nExpect: 2\\n\\nAccording to me expected answer should be 3 because [1,100] cannot be removed and all other 3 intervals are sub-intervals of [1,100].\\n\\nCan someone explain why is expected answer 2?"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "[@Ashutosh Mittal](/ashu-xx) in above case when we consider [1, 100] it will remove 3  other interval. but there a one option remain ie Consider [11,22] and [1, 11] than there is two inverval which are overlapping with these two [1,100] and [2,12] from the two option 3,  2, 2 option minimum so the result should be 2"
                    },
                    {
                        "username": "sasimouni",
                        "content": "[@bparanj](/bparanj)  nice explanation "
                    },
                    {
                        "username": "vermadeepesh248",
                        "content": "question said to remove minimum number of intervals. \\n\\nif we let [1,100] stay then we have to remove remaining three intervals.\\nbut instead if we remove [1,100] and [2,12] then we can let [1,11] and [11,22] stay. In this case we are removing only 2 intervals. so output should be 2."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@ShaliniMishra31](/ShaliniMishra31) [@ShaliniMishra31](/ShaliniMishra31) Your approach is not completely incorrect, but it\\'s not the most optimal one. In your solution, you are trying to represent the intervals on a number line and mark the occupied points. However, this approach has a couple of significant issues:\\n\\n1. It doesn\\'t consider the interval as a whole. Intervals are more than just individual points on a line, and their overlaps can\\'t always be accurately represented by the overlap of individual points.\\n\\n2. It doesn\\'t correctly account for the case when a smaller interval is entirely within a larger one. Your solution may consider the larger interval to be overlapping, even if removing the smaller one would make all intervals non-overlapping.\\n\\n3. Your solution has a time complexity of O(N^2), which is not efficient for large inputs.\\n\\nHere is an optimal solution using the greedy algorithm. It sorts the intervals by their end time and always tries to keep the one that ends earlier. This approach ensures we have more room for the remaining intervals.\\n\\nIn C++, it would look something like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 0) return 0;\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int ans = 0, end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i][0] < end){\\n                ans++;\\n            }\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution, we first sort the intervals by their end time. Then, we iterate over the sorted intervals. For each interval, if its start time is less than the end time of the previous interval, we increment our count (as it\\'s overlapping and needs to be removed). Otherwise, we update our end time to the current interval\\'s end time. This solution has a time complexity of O(N log N), which is more efficient."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected answer is 2 because the optimal solution doesn\\'t necessarily require keeping the interval [1,100]. It seems like you\\'re operating under the assumption that the larger interval has to be kept, but that\\'s not always the case.\\n\\nLet\\'s examine the problem with the given list of intervals:\\n\\n[[1,100],[11,22],[1,11],[2,12]]\\n\\nA key point to remember is that the objective is to minimize the number of removals so as to make the remaining intervals non-overlapping. To achieve this, the optimal strategy involves removing the intervals that cause the most overlaps. In this case, interval [1,100] overlaps with all other intervals, so if we keep it, we\\'d need to remove all other intervals, which is not optimal.\\n\\nInstead, if we remove [1,100], we\\'re left with:\\n\\n[[11,22],[1,11],[2,12]]\\n\\nOut of these, [1,11] and [11,22] don\\'t overlap. However, [2,12] overlaps with both. Thus, we can remove [2,12] to make the remaining intervals non-overlapping. This way, we only need to remove 2 intervals ([1,100] and [2,12]), which is why the expected answer is 2."
                    },
                    {
                        "username": "ShaliniMishra31",
                        "content": "[@cpblnc](/cpblnc) Could you explain again?\nI have the same doubt \n\nHere is my solution:\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        vector <pair<int,int>> vec(100000, {0,0});\n        int ans = 0;\n        for(int i=0;i<intervals.size();i++)\n        {\n            int f = intervals[i][0];\n            int s = intervals[i][1];\n            int dif = s-f;\n            int c = 0;\n            for(int j=f;j<=s;j++)\n            {\n                if(vec[j].second != 1)\n                {\n                    vec[j].first = j;\n                    vec[j].second = 1;\n                }\n                else\n                {\n                    c++;\n                }\n            }\n            if(c > dif)\n            {\n                ans++;\n            }\n        }\n        return(ans);\n    }\n};\n"
                    },
                    {
                        "username": "cpblnc",
                        "content": "Why can\\'t [1,100] be removed? If you remove it and [2,12] as well, you are left with [1,11] and [11,22], which are non overlapping - 2 intervals got removed, as expected."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Sort & Greedy make people happy!"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After I saw this problem, My first thought was to use `Binary Search` with `DP` and solved it."
                    },
                    {
                        "username": "sunny8080",
                        "content": "[@ashish15678](/ashish15678) For every index, find next non-overlapping intervel using `Binary Search`. \\nFor more, just take a look at [My Solution](https://leetcode.com/problems/non-overlapping-intervals/solutions/3788241/c-java-easy-and-clean-code-dp-greedy-beats/)"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@ashish15678](/ashish15678)  u can see my soln, i also did it using DP and Binary Search. \\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/solutions/3789308/dp-binary-search-solution/"
                    },
                    {
                        "username": "ashish15678",
                        "content": "can you please explain more\\n"
                    },
                    {
                        "username": "user4653c",
                        "content": "Labeling this problem as Dynamic Programming is a bit of a nasty move. To solve it, you need to find the right intuition, attempting the DP approach will just make things more confusing"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@Charlemagne5t](/Charlemagne5t) well true it can be difficult, trying joting down all possible scenarios and see if your greedy (or any other) approach works, if it does then try to find a justification for it, sometimes u may pass the question by implementing a approach but can\\'t think of a proof of it, can happen if the proof is mathematically rigorous "
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Agreed. Tried straight forward recursion + caching and got TLE 54/58. What I like about this approach it guarantees the right answer. Greedy is more optimal solution, but how do I prove it in real world problems when I don\\'t have rich test cases sample. I need to improve my knowledge in that field I guess. "
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "It's easy to think that:\\n- If we count the overlapping times with each interval. \\n- Then, for each time we remove the interval with most overlapping interval(let's call it A)\\n- And we update the other intervals' overlapping time which is overlapped with A.\\n- When all interval has zero overlapping times, we get the result.\\n\\nI know how to do it in greedy in O(nlgn) time, but I wonder why this cant work... \\nThis idea failed in the last test case(that with 10k inputs).I can't figure out why... Can someone help me?please...?\\nThanks your time for seeing these. Thank you~"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@nsut_coder](/nsut_coder) It would still not work if we remove all duplicates. Consider the same example, but add small random fractional values to each start and end. No duplicates, but the answer remains the same,"
                    },
                    {
                        "username": "bparanj",
                        "content": "The strategy you described is known as the \"interval graph coloring\" problem and it\\'s not equivalent to the interval scheduling problem we are solving here. You are describing an approach in which we try to color intervals (remove as few as possible) such that no two overlapping intervals share the same color. That is a more complicated problem and is not what we are trying to solve here.\\n\\nYou are trying to remove the interval that has the most overlaps first. This approach does not always lead to the optimal solution. Consider the following example:\\n\\n[[1, 5], [2, 3], [3, 4], [4, 5]]\\n\\nIf we follow your approach, we\\'ll remove [1, 5] first, because it overlaps with the most intervals. But this leads to the need of removing 1 interval, while the optimal solution would be to remove none. If we select [2, 3], [3, 4], [4, 5], we can see that none of these intervals overlap, which leads to the optimal solution of 0 removals.\\n\\nThis shows why the greedy algorithm of always choosing the interval that ends the earliest works: it leaves the most room for the rest of the intervals to not overlap.\\n\\nSo the intuition for the greedy algorithm in this problem is: the sooner an interval ends, the more room we have for the rest of the intervals to fit in without overlapping. It\\'s about looking ahead and trying to leave as much room as possible for the future intervals."
                    },
                    {
                        "username": "nsut_coder",
                        "content": "[@bharathi1121](/bharathi1121) I think, algorithm would work if we remove the duplicate ranges. but how would algorithm decide which interval to remove when all of them are overlapping with same number of intervals. "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "It doesnt work because its not always the largest overlapping interval to be removed first,\\nex: [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]\\nin this example the largest overlapping interval is [2,4] but it is part of the answer."
                    }
                ]
            },
            {
                "id": 1976678,
                "content": [
                    {
                        "username": "ZimmAgu",
                        "content": "#### Initial Steps\\n* Sort the given intervals based on starting points\\n* While considering the intervals in the ascending order of starting points\\n\\t* we make use of a pointer prev pointer \\n\\t* to keep track of the interval just included in the final list\\n![image](https://assets.leetcode.com/users/images/515fa83b-44c2-4c42-8ef5-d41c7942ec32_1653774876.169032.jpeg)\\n\\n\\n\\n#### Case 1\\n* You don\\'t need to remove any intervals\\n* Continue by simply assigning the *prev* pointer to the later interval\\n* The count of intervals removed remains unchanged\\n\\n\\n#### Case 2\\n* Remove the interval with the later end point \\n* The *prev* pointer is updated to current interval\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Case 3\\n* Remove the interval with the later end point \\n* The *prev* pointer remains unchanged\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Rule of Thumb\\n* Always choose the interval that ends first\\n\\n"
                    },
                    {
                        "username": "Muhammadamin",
                        "content": "[@rohitanjane999](/rohitanjane999)  + "
                    },
                    {
                        "username": "MayuD",
                        "content": "Thank you\nThe second case had got me"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "That was really good...thanks"
                    },
                    {
                        "username": "0x415374",
                        "content": "Pretty intuitive! Unfortunately I was not able to figure this out in a reasonable amount of time."
                    },
                    {
                        "username": "voodooism",
                        "content": "with this explanation the problem becomes easy!\\nthanks!"
                    },
                    {
                        "username": "rohitanjane999",
                        "content": "thanks for explanation...."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "And this marks my 200 days of streak..."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "So i\\'m not alone. [@sarpalmadhav](/sarpalmadhav)[@Ashutosh kumar](/ashurockzz) We started on jan1. Hope we complete our 365 days challenge."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ashu0123](/ashu0123) Congrats! Same here. I too have hit 200. We both started on Jan 1!!\\n"
                    },
                    {
                        "username": "ashu0123",
                        "content": "Looks like you\\'ve used Time travel tickets"
                    },
                    {
                        "username": "oops_moment",
                        "content": "If you\\'ve already cracked this challenging problem, kudos to you! If not, fret not! Let\\'s go step by step to find the perfect solution together! \\uD83D\\uDCAA\\n\\n\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F Problem Analysis:\\nWe\\'re given an array of intervals, and the goal is to find the minimum number of intervals to remove to make the rest non-overlapping. To achieve this, we\\'ll apply the greedy approach.\\n\\n\\u2B50 Greedy Insight:\\nLet\\'s try out a few greedy strategies. Say we select the interval with the smallest start time. Oops! This fails when the interval with the smallest start time also happens to be the longest one, leading to many overlapping intervals that need to be discarded.\\n\\n\\uD83D\\uDCA1 The Winning Greedy Strategy:\\nInstead, let\\'s sort the intervals based on their end times. Why? Imagine two intervals, one ending at x and the other ending at y (where x < y). If we skip the interval ending at x and take the one ending at y, we\\'ll may have to remove at least one interval that starts in the range (x, y). So, we should always sort based on the end time of intervals.\\n\\n\\uD83D\\uDEE0\\uFE0F Implementation:\\n\\n1: Sort the intervals based on their end times in ascending order.\\n\\n2: Initialize a variable \\'answer\\' to keep track of the number of intervals to be removed.\\n\\n3: Consider the first interval as \\'last\\' or the last taken interval.\\n\\n4: Iterate through the intervals, and for each interval:\\n\\n- If the current interval\\'s start time is less than the end time of the \\'last\\' interval, they overlap. Increment \\'answer\\' as we need to remove an interval to avoid overlap.\\n\\n- Otherwise, update \\'last\\' to the current interval.\\n\\n5: Return the final value of answer.\\n\\nNow you can confidently explain this solution to others and spread the joy of problem-solving! Happy coding! \\uD83D\\uDE80"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I don\\'t get why sorting by the end of the range helps.\\nI did\\n```\\nintervals.sort(key=lambda x: x[1])\\n```"
                    },
                    {
                        "username": "jkswapnil99",
                        "content": "Why is greedy solution correct for this problem. How do we know that, of all the ways in which intervals can be deleted the greedy approach is the optimal strategy?\\n\\nI always have trouble proving this for greedy solutions"
                    },
                    {
                        "username": "aLaN09",
                        "content": "[@bparanj](/bparanj) Nicely written"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The \"proof\" does not convince me for at least a two reasons:\\n\\n1) If there is an optimal solution different from ours, why must there an interval `i` with end time larger than ours?\\n2) We have no idea where `x` starts, how do we guarantee adding `x` after removing `i` won\\'t introduce conflicts?\\n\\nSince this is a classic problem - the proof is publicly available - all we needed is to do some search. For example, there is a one liner proof on wikipedia here. https://en.wikipedia.org/wiki/Interval_scheduling#Unweighted"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand your confusion. Proving the correctness of a greedy solution can often be tricky. For this particular problem, we could demonstrate the greedy choice property and optimal substructure, two key characteristics of problems that can be solved using a greedy approach.\\n\\nThe **greedy choice property** means that a local optimum can lead to a global optimum. For this problem, the local optimum is to always select the interval with the earliest end time that doesn\\'t overlap with the current one. This choice leaves as much space as possible for the remaining intervals. If we can prove that making the greedy choice at each step leads to the solution of the overall problem, then we\\'ve shown the greedy choice property.\\n\\nThe **optimal substructure** means that an optimal solution to the problem can be constructed efficiently from optimal solutions to its subproblems. In this problem, once we make the greedy choice of picking the interval with the earliest end time, we\\'re left with a smaller subproblem: finding the optimal solution in the remaining intervals.\\n\\nHere\\'s the intuition for why this greedy strategy works:\\n\\nThe crucial observation is that the interval with the earliest end time is least likely to overlap with other intervals. Hence, keeping this interval in our solution gives us the maximum space to accommodate the remaining intervals, which in turn reduces the number of removals. \\n\\nNow, let\\'s say there\\'s an optimal solution different from ours that keeps an interval `i` with an end time later than the one we chose (let\\'s call our interval `x`). We can replace `i` with `x` in this solution, and it\\'s guaranteed not to create more overlaps because `x` ends earlier than `i`. Therefore, the new solution is still optimal, showing that our greedy choice doesn\\'t lead to a worse solution.\\n\\nThis demonstrates that the greedy choice leads to an optimal solution and that the problem has an optimal substructure, thus validating our greedy solution."
                    },
                    {
                        "username": "abhay3141",
                        "content": "Getting Time limit Exceeded even though all 58/58 case passed. Any help ?"
                    },
                    {
                        "username": "jason3410",
                        "content": "You could just regard it as a regular TLE . It\\'s just a relatively closer one."
                    },
                    {
                        "username": "spookyflame",
                        "content": "[@cqrbala](/cqrbala) ty it worked. Forgot about that lmao"
                    },
                    {
                        "username": "cqrbala",
                        "content": "[@tanisha_daharwal](/tanisha_daharwal) [@Abhay](/abhay3141) Try to pass the vectors in the comparison function by reference (using & in c++). It is much faster as there is no need to make a copy of the vectors to perform the comparison."
                    },
                    {
                        "username": "tanisha_daharwal",
                        "content": "same thing happening with me"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Task failed successfully!"
                    },
                    {
                        "username": "ashu-xx",
                        "content": "[[1,100],[11,22],[1,11],[2,12]] \\nExpect: 2\\n\\nAccording to me expected answer should be 3 because [1,100] cannot be removed and all other 3 intervals are sub-intervals of [1,100].\\n\\nCan someone explain why is expected answer 2?"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "[@Ashutosh Mittal](/ashu-xx) in above case when we consider [1, 100] it will remove 3  other interval. but there a one option remain ie Consider [11,22] and [1, 11] than there is two inverval which are overlapping with these two [1,100] and [2,12] from the two option 3,  2, 2 option minimum so the result should be 2"
                    },
                    {
                        "username": "sasimouni",
                        "content": "[@bparanj](/bparanj)  nice explanation "
                    },
                    {
                        "username": "vermadeepesh248",
                        "content": "question said to remove minimum number of intervals. \\n\\nif we let [1,100] stay then we have to remove remaining three intervals.\\nbut instead if we remove [1,100] and [2,12] then we can let [1,11] and [11,22] stay. In this case we are removing only 2 intervals. so output should be 2."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@ShaliniMishra31](/ShaliniMishra31) [@ShaliniMishra31](/ShaliniMishra31) Your approach is not completely incorrect, but it\\'s not the most optimal one. In your solution, you are trying to represent the intervals on a number line and mark the occupied points. However, this approach has a couple of significant issues:\\n\\n1. It doesn\\'t consider the interval as a whole. Intervals are more than just individual points on a line, and their overlaps can\\'t always be accurately represented by the overlap of individual points.\\n\\n2. It doesn\\'t correctly account for the case when a smaller interval is entirely within a larger one. Your solution may consider the larger interval to be overlapping, even if removing the smaller one would make all intervals non-overlapping.\\n\\n3. Your solution has a time complexity of O(N^2), which is not efficient for large inputs.\\n\\nHere is an optimal solution using the greedy algorithm. It sorts the intervals by their end time and always tries to keep the one that ends earlier. This approach ensures we have more room for the remaining intervals.\\n\\nIn C++, it would look something like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 0) return 0;\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int ans = 0, end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i][0] < end){\\n                ans++;\\n            }\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution, we first sort the intervals by their end time. Then, we iterate over the sorted intervals. For each interval, if its start time is less than the end time of the previous interval, we increment our count (as it\\'s overlapping and needs to be removed). Otherwise, we update our end time to the current interval\\'s end time. This solution has a time complexity of O(N log N), which is more efficient."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected answer is 2 because the optimal solution doesn\\'t necessarily require keeping the interval [1,100]. It seems like you\\'re operating under the assumption that the larger interval has to be kept, but that\\'s not always the case.\\n\\nLet\\'s examine the problem with the given list of intervals:\\n\\n[[1,100],[11,22],[1,11],[2,12]]\\n\\nA key point to remember is that the objective is to minimize the number of removals so as to make the remaining intervals non-overlapping. To achieve this, the optimal strategy involves removing the intervals that cause the most overlaps. In this case, interval [1,100] overlaps with all other intervals, so if we keep it, we\\'d need to remove all other intervals, which is not optimal.\\n\\nInstead, if we remove [1,100], we\\'re left with:\\n\\n[[11,22],[1,11],[2,12]]\\n\\nOut of these, [1,11] and [11,22] don\\'t overlap. However, [2,12] overlaps with both. Thus, we can remove [2,12] to make the remaining intervals non-overlapping. This way, we only need to remove 2 intervals ([1,100] and [2,12]), which is why the expected answer is 2."
                    },
                    {
                        "username": "ShaliniMishra31",
                        "content": "[@cpblnc](/cpblnc) Could you explain again?\nI have the same doubt \n\nHere is my solution:\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        vector <pair<int,int>> vec(100000, {0,0});\n        int ans = 0;\n        for(int i=0;i<intervals.size();i++)\n        {\n            int f = intervals[i][0];\n            int s = intervals[i][1];\n            int dif = s-f;\n            int c = 0;\n            for(int j=f;j<=s;j++)\n            {\n                if(vec[j].second != 1)\n                {\n                    vec[j].first = j;\n                    vec[j].second = 1;\n                }\n                else\n                {\n                    c++;\n                }\n            }\n            if(c > dif)\n            {\n                ans++;\n            }\n        }\n        return(ans);\n    }\n};\n"
                    },
                    {
                        "username": "cpblnc",
                        "content": "Why can\\'t [1,100] be removed? If you remove it and [2,12] as well, you are left with [1,11] and [11,22], which are non overlapping - 2 intervals got removed, as expected."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Sort & Greedy make people happy!"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After I saw this problem, My first thought was to use `Binary Search` with `DP` and solved it."
                    },
                    {
                        "username": "sunny8080",
                        "content": "[@ashish15678](/ashish15678) For every index, find next non-overlapping intervel using `Binary Search`. \\nFor more, just take a look at [My Solution](https://leetcode.com/problems/non-overlapping-intervals/solutions/3788241/c-java-easy-and-clean-code-dp-greedy-beats/)"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@ashish15678](/ashish15678)  u can see my soln, i also did it using DP and Binary Search. \\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/solutions/3789308/dp-binary-search-solution/"
                    },
                    {
                        "username": "ashish15678",
                        "content": "can you please explain more\\n"
                    },
                    {
                        "username": "user4653c",
                        "content": "Labeling this problem as Dynamic Programming is a bit of a nasty move. To solve it, you need to find the right intuition, attempting the DP approach will just make things more confusing"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@Charlemagne5t](/Charlemagne5t) well true it can be difficult, trying joting down all possible scenarios and see if your greedy (or any other) approach works, if it does then try to find a justification for it, sometimes u may pass the question by implementing a approach but can\\'t think of a proof of it, can happen if the proof is mathematically rigorous "
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Agreed. Tried straight forward recursion + caching and got TLE 54/58. What I like about this approach it guarantees the right answer. Greedy is more optimal solution, but how do I prove it in real world problems when I don\\'t have rich test cases sample. I need to improve my knowledge in that field I guess. "
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "It's easy to think that:\\n- If we count the overlapping times with each interval. \\n- Then, for each time we remove the interval with most overlapping interval(let's call it A)\\n- And we update the other intervals' overlapping time which is overlapped with A.\\n- When all interval has zero overlapping times, we get the result.\\n\\nI know how to do it in greedy in O(nlgn) time, but I wonder why this cant work... \\nThis idea failed in the last test case(that with 10k inputs).I can't figure out why... Can someone help me?please...?\\nThanks your time for seeing these. Thank you~"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@nsut_coder](/nsut_coder) It would still not work if we remove all duplicates. Consider the same example, but add small random fractional values to each start and end. No duplicates, but the answer remains the same,"
                    },
                    {
                        "username": "bparanj",
                        "content": "The strategy you described is known as the \"interval graph coloring\" problem and it\\'s not equivalent to the interval scheduling problem we are solving here. You are describing an approach in which we try to color intervals (remove as few as possible) such that no two overlapping intervals share the same color. That is a more complicated problem and is not what we are trying to solve here.\\n\\nYou are trying to remove the interval that has the most overlaps first. This approach does not always lead to the optimal solution. Consider the following example:\\n\\n[[1, 5], [2, 3], [3, 4], [4, 5]]\\n\\nIf we follow your approach, we\\'ll remove [1, 5] first, because it overlaps with the most intervals. But this leads to the need of removing 1 interval, while the optimal solution would be to remove none. If we select [2, 3], [3, 4], [4, 5], we can see that none of these intervals overlap, which leads to the optimal solution of 0 removals.\\n\\nThis shows why the greedy algorithm of always choosing the interval that ends the earliest works: it leaves the most room for the rest of the intervals to not overlap.\\n\\nSo the intuition for the greedy algorithm in this problem is: the sooner an interval ends, the more room we have for the rest of the intervals to fit in without overlapping. It\\'s about looking ahead and trying to leave as much room as possible for the future intervals."
                    },
                    {
                        "username": "nsut_coder",
                        "content": "[@bharathi1121](/bharathi1121) I think, algorithm would work if we remove the duplicate ranges. but how would algorithm decide which interval to remove when all of them are overlapping with same number of intervals. "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "It doesnt work because its not always the largest overlapping interval to be removed first,\\nex: [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]\\nin this example the largest overlapping interval is [2,4] but it is part of the answer."
                    }
                ]
            },
            {
                "id": 1976804,
                "content": [
                    {
                        "username": "ZimmAgu",
                        "content": "#### Initial Steps\\n* Sort the given intervals based on starting points\\n* While considering the intervals in the ascending order of starting points\\n\\t* we make use of a pointer prev pointer \\n\\t* to keep track of the interval just included in the final list\\n![image](https://assets.leetcode.com/users/images/515fa83b-44c2-4c42-8ef5-d41c7942ec32_1653774876.169032.jpeg)\\n\\n\\n\\n#### Case 1\\n* You don\\'t need to remove any intervals\\n* Continue by simply assigning the *prev* pointer to the later interval\\n* The count of intervals removed remains unchanged\\n\\n\\n#### Case 2\\n* Remove the interval with the later end point \\n* The *prev* pointer is updated to current interval\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Case 3\\n* Remove the interval with the later end point \\n* The *prev* pointer remains unchanged\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Rule of Thumb\\n* Always choose the interval that ends first\\n\\n"
                    },
                    {
                        "username": "Muhammadamin",
                        "content": "[@rohitanjane999](/rohitanjane999)  + "
                    },
                    {
                        "username": "MayuD",
                        "content": "Thank you\nThe second case had got me"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "That was really good...thanks"
                    },
                    {
                        "username": "0x415374",
                        "content": "Pretty intuitive! Unfortunately I was not able to figure this out in a reasonable amount of time."
                    },
                    {
                        "username": "voodooism",
                        "content": "with this explanation the problem becomes easy!\\nthanks!"
                    },
                    {
                        "username": "rohitanjane999",
                        "content": "thanks for explanation...."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "And this marks my 200 days of streak..."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "So i\\'m not alone. [@sarpalmadhav](/sarpalmadhav)[@Ashutosh kumar](/ashurockzz) We started on jan1. Hope we complete our 365 days challenge."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ashu0123](/ashu0123) Congrats! Same here. I too have hit 200. We both started on Jan 1!!\\n"
                    },
                    {
                        "username": "ashu0123",
                        "content": "Looks like you\\'ve used Time travel tickets"
                    },
                    {
                        "username": "oops_moment",
                        "content": "If you\\'ve already cracked this challenging problem, kudos to you! If not, fret not! Let\\'s go step by step to find the perfect solution together! \\uD83D\\uDCAA\\n\\n\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F Problem Analysis:\\nWe\\'re given an array of intervals, and the goal is to find the minimum number of intervals to remove to make the rest non-overlapping. To achieve this, we\\'ll apply the greedy approach.\\n\\n\\u2B50 Greedy Insight:\\nLet\\'s try out a few greedy strategies. Say we select the interval with the smallest start time. Oops! This fails when the interval with the smallest start time also happens to be the longest one, leading to many overlapping intervals that need to be discarded.\\n\\n\\uD83D\\uDCA1 The Winning Greedy Strategy:\\nInstead, let\\'s sort the intervals based on their end times. Why? Imagine two intervals, one ending at x and the other ending at y (where x < y). If we skip the interval ending at x and take the one ending at y, we\\'ll may have to remove at least one interval that starts in the range (x, y). So, we should always sort based on the end time of intervals.\\n\\n\\uD83D\\uDEE0\\uFE0F Implementation:\\n\\n1: Sort the intervals based on their end times in ascending order.\\n\\n2: Initialize a variable \\'answer\\' to keep track of the number of intervals to be removed.\\n\\n3: Consider the first interval as \\'last\\' or the last taken interval.\\n\\n4: Iterate through the intervals, and for each interval:\\n\\n- If the current interval\\'s start time is less than the end time of the \\'last\\' interval, they overlap. Increment \\'answer\\' as we need to remove an interval to avoid overlap.\\n\\n- Otherwise, update \\'last\\' to the current interval.\\n\\n5: Return the final value of answer.\\n\\nNow you can confidently explain this solution to others and spread the joy of problem-solving! Happy coding! \\uD83D\\uDE80"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I don\\'t get why sorting by the end of the range helps.\\nI did\\n```\\nintervals.sort(key=lambda x: x[1])\\n```"
                    },
                    {
                        "username": "jkswapnil99",
                        "content": "Why is greedy solution correct for this problem. How do we know that, of all the ways in which intervals can be deleted the greedy approach is the optimal strategy?\\n\\nI always have trouble proving this for greedy solutions"
                    },
                    {
                        "username": "aLaN09",
                        "content": "[@bparanj](/bparanj) Nicely written"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The \"proof\" does not convince me for at least a two reasons:\\n\\n1) If there is an optimal solution different from ours, why must there an interval `i` with end time larger than ours?\\n2) We have no idea where `x` starts, how do we guarantee adding `x` after removing `i` won\\'t introduce conflicts?\\n\\nSince this is a classic problem - the proof is publicly available - all we needed is to do some search. For example, there is a one liner proof on wikipedia here. https://en.wikipedia.org/wiki/Interval_scheduling#Unweighted"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand your confusion. Proving the correctness of a greedy solution can often be tricky. For this particular problem, we could demonstrate the greedy choice property and optimal substructure, two key characteristics of problems that can be solved using a greedy approach.\\n\\nThe **greedy choice property** means that a local optimum can lead to a global optimum. For this problem, the local optimum is to always select the interval with the earliest end time that doesn\\'t overlap with the current one. This choice leaves as much space as possible for the remaining intervals. If we can prove that making the greedy choice at each step leads to the solution of the overall problem, then we\\'ve shown the greedy choice property.\\n\\nThe **optimal substructure** means that an optimal solution to the problem can be constructed efficiently from optimal solutions to its subproblems. In this problem, once we make the greedy choice of picking the interval with the earliest end time, we\\'re left with a smaller subproblem: finding the optimal solution in the remaining intervals.\\n\\nHere\\'s the intuition for why this greedy strategy works:\\n\\nThe crucial observation is that the interval with the earliest end time is least likely to overlap with other intervals. Hence, keeping this interval in our solution gives us the maximum space to accommodate the remaining intervals, which in turn reduces the number of removals. \\n\\nNow, let\\'s say there\\'s an optimal solution different from ours that keeps an interval `i` with an end time later than the one we chose (let\\'s call our interval `x`). We can replace `i` with `x` in this solution, and it\\'s guaranteed not to create more overlaps because `x` ends earlier than `i`. Therefore, the new solution is still optimal, showing that our greedy choice doesn\\'t lead to a worse solution.\\n\\nThis demonstrates that the greedy choice leads to an optimal solution and that the problem has an optimal substructure, thus validating our greedy solution."
                    },
                    {
                        "username": "abhay3141",
                        "content": "Getting Time limit Exceeded even though all 58/58 case passed. Any help ?"
                    },
                    {
                        "username": "jason3410",
                        "content": "You could just regard it as a regular TLE . It\\'s just a relatively closer one."
                    },
                    {
                        "username": "spookyflame",
                        "content": "[@cqrbala](/cqrbala) ty it worked. Forgot about that lmao"
                    },
                    {
                        "username": "cqrbala",
                        "content": "[@tanisha_daharwal](/tanisha_daharwal) [@Abhay](/abhay3141) Try to pass the vectors in the comparison function by reference (using & in c++). It is much faster as there is no need to make a copy of the vectors to perform the comparison."
                    },
                    {
                        "username": "tanisha_daharwal",
                        "content": "same thing happening with me"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Task failed successfully!"
                    },
                    {
                        "username": "ashu-xx",
                        "content": "[[1,100],[11,22],[1,11],[2,12]] \\nExpect: 2\\n\\nAccording to me expected answer should be 3 because [1,100] cannot be removed and all other 3 intervals are sub-intervals of [1,100].\\n\\nCan someone explain why is expected answer 2?"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "[@Ashutosh Mittal](/ashu-xx) in above case when we consider [1, 100] it will remove 3  other interval. but there a one option remain ie Consider [11,22] and [1, 11] than there is two inverval which are overlapping with these two [1,100] and [2,12] from the two option 3,  2, 2 option minimum so the result should be 2"
                    },
                    {
                        "username": "sasimouni",
                        "content": "[@bparanj](/bparanj)  nice explanation "
                    },
                    {
                        "username": "vermadeepesh248",
                        "content": "question said to remove minimum number of intervals. \\n\\nif we let [1,100] stay then we have to remove remaining three intervals.\\nbut instead if we remove [1,100] and [2,12] then we can let [1,11] and [11,22] stay. In this case we are removing only 2 intervals. so output should be 2."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@ShaliniMishra31](/ShaliniMishra31) [@ShaliniMishra31](/ShaliniMishra31) Your approach is not completely incorrect, but it\\'s not the most optimal one. In your solution, you are trying to represent the intervals on a number line and mark the occupied points. However, this approach has a couple of significant issues:\\n\\n1. It doesn\\'t consider the interval as a whole. Intervals are more than just individual points on a line, and their overlaps can\\'t always be accurately represented by the overlap of individual points.\\n\\n2. It doesn\\'t correctly account for the case when a smaller interval is entirely within a larger one. Your solution may consider the larger interval to be overlapping, even if removing the smaller one would make all intervals non-overlapping.\\n\\n3. Your solution has a time complexity of O(N^2), which is not efficient for large inputs.\\n\\nHere is an optimal solution using the greedy algorithm. It sorts the intervals by their end time and always tries to keep the one that ends earlier. This approach ensures we have more room for the remaining intervals.\\n\\nIn C++, it would look something like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 0) return 0;\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int ans = 0, end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i][0] < end){\\n                ans++;\\n            }\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution, we first sort the intervals by their end time. Then, we iterate over the sorted intervals. For each interval, if its start time is less than the end time of the previous interval, we increment our count (as it\\'s overlapping and needs to be removed). Otherwise, we update our end time to the current interval\\'s end time. This solution has a time complexity of O(N log N), which is more efficient."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected answer is 2 because the optimal solution doesn\\'t necessarily require keeping the interval [1,100]. It seems like you\\'re operating under the assumption that the larger interval has to be kept, but that\\'s not always the case.\\n\\nLet\\'s examine the problem with the given list of intervals:\\n\\n[[1,100],[11,22],[1,11],[2,12]]\\n\\nA key point to remember is that the objective is to minimize the number of removals so as to make the remaining intervals non-overlapping. To achieve this, the optimal strategy involves removing the intervals that cause the most overlaps. In this case, interval [1,100] overlaps with all other intervals, so if we keep it, we\\'d need to remove all other intervals, which is not optimal.\\n\\nInstead, if we remove [1,100], we\\'re left with:\\n\\n[[11,22],[1,11],[2,12]]\\n\\nOut of these, [1,11] and [11,22] don\\'t overlap. However, [2,12] overlaps with both. Thus, we can remove [2,12] to make the remaining intervals non-overlapping. This way, we only need to remove 2 intervals ([1,100] and [2,12]), which is why the expected answer is 2."
                    },
                    {
                        "username": "ShaliniMishra31",
                        "content": "[@cpblnc](/cpblnc) Could you explain again?\nI have the same doubt \n\nHere is my solution:\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        vector <pair<int,int>> vec(100000, {0,0});\n        int ans = 0;\n        for(int i=0;i<intervals.size();i++)\n        {\n            int f = intervals[i][0];\n            int s = intervals[i][1];\n            int dif = s-f;\n            int c = 0;\n            for(int j=f;j<=s;j++)\n            {\n                if(vec[j].second != 1)\n                {\n                    vec[j].first = j;\n                    vec[j].second = 1;\n                }\n                else\n                {\n                    c++;\n                }\n            }\n            if(c > dif)\n            {\n                ans++;\n            }\n        }\n        return(ans);\n    }\n};\n"
                    },
                    {
                        "username": "cpblnc",
                        "content": "Why can\\'t [1,100] be removed? If you remove it and [2,12] as well, you are left with [1,11] and [11,22], which are non overlapping - 2 intervals got removed, as expected."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Sort & Greedy make people happy!"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After I saw this problem, My first thought was to use `Binary Search` with `DP` and solved it."
                    },
                    {
                        "username": "sunny8080",
                        "content": "[@ashish15678](/ashish15678) For every index, find next non-overlapping intervel using `Binary Search`. \\nFor more, just take a look at [My Solution](https://leetcode.com/problems/non-overlapping-intervals/solutions/3788241/c-java-easy-and-clean-code-dp-greedy-beats/)"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@ashish15678](/ashish15678)  u can see my soln, i also did it using DP and Binary Search. \\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/solutions/3789308/dp-binary-search-solution/"
                    },
                    {
                        "username": "ashish15678",
                        "content": "can you please explain more\\n"
                    },
                    {
                        "username": "user4653c",
                        "content": "Labeling this problem as Dynamic Programming is a bit of a nasty move. To solve it, you need to find the right intuition, attempting the DP approach will just make things more confusing"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@Charlemagne5t](/Charlemagne5t) well true it can be difficult, trying joting down all possible scenarios and see if your greedy (or any other) approach works, if it does then try to find a justification for it, sometimes u may pass the question by implementing a approach but can\\'t think of a proof of it, can happen if the proof is mathematically rigorous "
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Agreed. Tried straight forward recursion + caching and got TLE 54/58. What I like about this approach it guarantees the right answer. Greedy is more optimal solution, but how do I prove it in real world problems when I don\\'t have rich test cases sample. I need to improve my knowledge in that field I guess. "
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "It's easy to think that:\\n- If we count the overlapping times with each interval. \\n- Then, for each time we remove the interval with most overlapping interval(let's call it A)\\n- And we update the other intervals' overlapping time which is overlapped with A.\\n- When all interval has zero overlapping times, we get the result.\\n\\nI know how to do it in greedy in O(nlgn) time, but I wonder why this cant work... \\nThis idea failed in the last test case(that with 10k inputs).I can't figure out why... Can someone help me?please...?\\nThanks your time for seeing these. Thank you~"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@nsut_coder](/nsut_coder) It would still not work if we remove all duplicates. Consider the same example, but add small random fractional values to each start and end. No duplicates, but the answer remains the same,"
                    },
                    {
                        "username": "bparanj",
                        "content": "The strategy you described is known as the \"interval graph coloring\" problem and it\\'s not equivalent to the interval scheduling problem we are solving here. You are describing an approach in which we try to color intervals (remove as few as possible) such that no two overlapping intervals share the same color. That is a more complicated problem and is not what we are trying to solve here.\\n\\nYou are trying to remove the interval that has the most overlaps first. This approach does not always lead to the optimal solution. Consider the following example:\\n\\n[[1, 5], [2, 3], [3, 4], [4, 5]]\\n\\nIf we follow your approach, we\\'ll remove [1, 5] first, because it overlaps with the most intervals. But this leads to the need of removing 1 interval, while the optimal solution would be to remove none. If we select [2, 3], [3, 4], [4, 5], we can see that none of these intervals overlap, which leads to the optimal solution of 0 removals.\\n\\nThis shows why the greedy algorithm of always choosing the interval that ends the earliest works: it leaves the most room for the rest of the intervals to not overlap.\\n\\nSo the intuition for the greedy algorithm in this problem is: the sooner an interval ends, the more room we have for the rest of the intervals to fit in without overlapping. It\\'s about looking ahead and trying to leave as much room as possible for the future intervals."
                    },
                    {
                        "username": "nsut_coder",
                        "content": "[@bharathi1121](/bharathi1121) I think, algorithm would work if we remove the duplicate ranges. but how would algorithm decide which interval to remove when all of them are overlapping with same number of intervals. "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "It doesnt work because its not always the largest overlapping interval to be removed first,\\nex: [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]\\nin this example the largest overlapping interval is [2,4] but it is part of the answer."
                    }
                ]
            },
            {
                "id": 1774241,
                "content": [
                    {
                        "username": "ZimmAgu",
                        "content": "#### Initial Steps\\n* Sort the given intervals based on starting points\\n* While considering the intervals in the ascending order of starting points\\n\\t* we make use of a pointer prev pointer \\n\\t* to keep track of the interval just included in the final list\\n![image](https://assets.leetcode.com/users/images/515fa83b-44c2-4c42-8ef5-d41c7942ec32_1653774876.169032.jpeg)\\n\\n\\n\\n#### Case 1\\n* You don\\'t need to remove any intervals\\n* Continue by simply assigning the *prev* pointer to the later interval\\n* The count of intervals removed remains unchanged\\n\\n\\n#### Case 2\\n* Remove the interval with the later end point \\n* The *prev* pointer is updated to current interval\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Case 3\\n* Remove the interval with the later end point \\n* The *prev* pointer remains unchanged\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Rule of Thumb\\n* Always choose the interval that ends first\\n\\n"
                    },
                    {
                        "username": "Muhammadamin",
                        "content": "[@rohitanjane999](/rohitanjane999)  + "
                    },
                    {
                        "username": "MayuD",
                        "content": "Thank you\nThe second case had got me"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "That was really good...thanks"
                    },
                    {
                        "username": "0x415374",
                        "content": "Pretty intuitive! Unfortunately I was not able to figure this out in a reasonable amount of time."
                    },
                    {
                        "username": "voodooism",
                        "content": "with this explanation the problem becomes easy!\\nthanks!"
                    },
                    {
                        "username": "rohitanjane999",
                        "content": "thanks for explanation...."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "And this marks my 200 days of streak..."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "So i\\'m not alone. [@sarpalmadhav](/sarpalmadhav)[@Ashutosh kumar](/ashurockzz) We started on jan1. Hope we complete our 365 days challenge."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ashu0123](/ashu0123) Congrats! Same here. I too have hit 200. We both started on Jan 1!!\\n"
                    },
                    {
                        "username": "ashu0123",
                        "content": "Looks like you\\'ve used Time travel tickets"
                    },
                    {
                        "username": "oops_moment",
                        "content": "If you\\'ve already cracked this challenging problem, kudos to you! If not, fret not! Let\\'s go step by step to find the perfect solution together! \\uD83D\\uDCAA\\n\\n\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F Problem Analysis:\\nWe\\'re given an array of intervals, and the goal is to find the minimum number of intervals to remove to make the rest non-overlapping. To achieve this, we\\'ll apply the greedy approach.\\n\\n\\u2B50 Greedy Insight:\\nLet\\'s try out a few greedy strategies. Say we select the interval with the smallest start time. Oops! This fails when the interval with the smallest start time also happens to be the longest one, leading to many overlapping intervals that need to be discarded.\\n\\n\\uD83D\\uDCA1 The Winning Greedy Strategy:\\nInstead, let\\'s sort the intervals based on their end times. Why? Imagine two intervals, one ending at x and the other ending at y (where x < y). If we skip the interval ending at x and take the one ending at y, we\\'ll may have to remove at least one interval that starts in the range (x, y). So, we should always sort based on the end time of intervals.\\n\\n\\uD83D\\uDEE0\\uFE0F Implementation:\\n\\n1: Sort the intervals based on their end times in ascending order.\\n\\n2: Initialize a variable \\'answer\\' to keep track of the number of intervals to be removed.\\n\\n3: Consider the first interval as \\'last\\' or the last taken interval.\\n\\n4: Iterate through the intervals, and for each interval:\\n\\n- If the current interval\\'s start time is less than the end time of the \\'last\\' interval, they overlap. Increment \\'answer\\' as we need to remove an interval to avoid overlap.\\n\\n- Otherwise, update \\'last\\' to the current interval.\\n\\n5: Return the final value of answer.\\n\\nNow you can confidently explain this solution to others and spread the joy of problem-solving! Happy coding! \\uD83D\\uDE80"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I don\\'t get why sorting by the end of the range helps.\\nI did\\n```\\nintervals.sort(key=lambda x: x[1])\\n```"
                    },
                    {
                        "username": "jkswapnil99",
                        "content": "Why is greedy solution correct for this problem. How do we know that, of all the ways in which intervals can be deleted the greedy approach is the optimal strategy?\\n\\nI always have trouble proving this for greedy solutions"
                    },
                    {
                        "username": "aLaN09",
                        "content": "[@bparanj](/bparanj) Nicely written"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The \"proof\" does not convince me for at least a two reasons:\\n\\n1) If there is an optimal solution different from ours, why must there an interval `i` with end time larger than ours?\\n2) We have no idea where `x` starts, how do we guarantee adding `x` after removing `i` won\\'t introduce conflicts?\\n\\nSince this is a classic problem - the proof is publicly available - all we needed is to do some search. For example, there is a one liner proof on wikipedia here. https://en.wikipedia.org/wiki/Interval_scheduling#Unweighted"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand your confusion. Proving the correctness of a greedy solution can often be tricky. For this particular problem, we could demonstrate the greedy choice property and optimal substructure, two key characteristics of problems that can be solved using a greedy approach.\\n\\nThe **greedy choice property** means that a local optimum can lead to a global optimum. For this problem, the local optimum is to always select the interval with the earliest end time that doesn\\'t overlap with the current one. This choice leaves as much space as possible for the remaining intervals. If we can prove that making the greedy choice at each step leads to the solution of the overall problem, then we\\'ve shown the greedy choice property.\\n\\nThe **optimal substructure** means that an optimal solution to the problem can be constructed efficiently from optimal solutions to its subproblems. In this problem, once we make the greedy choice of picking the interval with the earliest end time, we\\'re left with a smaller subproblem: finding the optimal solution in the remaining intervals.\\n\\nHere\\'s the intuition for why this greedy strategy works:\\n\\nThe crucial observation is that the interval with the earliest end time is least likely to overlap with other intervals. Hence, keeping this interval in our solution gives us the maximum space to accommodate the remaining intervals, which in turn reduces the number of removals. \\n\\nNow, let\\'s say there\\'s an optimal solution different from ours that keeps an interval `i` with an end time later than the one we chose (let\\'s call our interval `x`). We can replace `i` with `x` in this solution, and it\\'s guaranteed not to create more overlaps because `x` ends earlier than `i`. Therefore, the new solution is still optimal, showing that our greedy choice doesn\\'t lead to a worse solution.\\n\\nThis demonstrates that the greedy choice leads to an optimal solution and that the problem has an optimal substructure, thus validating our greedy solution."
                    },
                    {
                        "username": "abhay3141",
                        "content": "Getting Time limit Exceeded even though all 58/58 case passed. Any help ?"
                    },
                    {
                        "username": "jason3410",
                        "content": "You could just regard it as a regular TLE . It\\'s just a relatively closer one."
                    },
                    {
                        "username": "spookyflame",
                        "content": "[@cqrbala](/cqrbala) ty it worked. Forgot about that lmao"
                    },
                    {
                        "username": "cqrbala",
                        "content": "[@tanisha_daharwal](/tanisha_daharwal) [@Abhay](/abhay3141) Try to pass the vectors in the comparison function by reference (using & in c++). It is much faster as there is no need to make a copy of the vectors to perform the comparison."
                    },
                    {
                        "username": "tanisha_daharwal",
                        "content": "same thing happening with me"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Task failed successfully!"
                    },
                    {
                        "username": "ashu-xx",
                        "content": "[[1,100],[11,22],[1,11],[2,12]] \\nExpect: 2\\n\\nAccording to me expected answer should be 3 because [1,100] cannot be removed and all other 3 intervals are sub-intervals of [1,100].\\n\\nCan someone explain why is expected answer 2?"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "[@Ashutosh Mittal](/ashu-xx) in above case when we consider [1, 100] it will remove 3  other interval. but there a one option remain ie Consider [11,22] and [1, 11] than there is two inverval which are overlapping with these two [1,100] and [2,12] from the two option 3,  2, 2 option minimum so the result should be 2"
                    },
                    {
                        "username": "sasimouni",
                        "content": "[@bparanj](/bparanj)  nice explanation "
                    },
                    {
                        "username": "vermadeepesh248",
                        "content": "question said to remove minimum number of intervals. \\n\\nif we let [1,100] stay then we have to remove remaining three intervals.\\nbut instead if we remove [1,100] and [2,12] then we can let [1,11] and [11,22] stay. In this case we are removing only 2 intervals. so output should be 2."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@ShaliniMishra31](/ShaliniMishra31) [@ShaliniMishra31](/ShaliniMishra31) Your approach is not completely incorrect, but it\\'s not the most optimal one. In your solution, you are trying to represent the intervals on a number line and mark the occupied points. However, this approach has a couple of significant issues:\\n\\n1. It doesn\\'t consider the interval as a whole. Intervals are more than just individual points on a line, and their overlaps can\\'t always be accurately represented by the overlap of individual points.\\n\\n2. It doesn\\'t correctly account for the case when a smaller interval is entirely within a larger one. Your solution may consider the larger interval to be overlapping, even if removing the smaller one would make all intervals non-overlapping.\\n\\n3. Your solution has a time complexity of O(N^2), which is not efficient for large inputs.\\n\\nHere is an optimal solution using the greedy algorithm. It sorts the intervals by their end time and always tries to keep the one that ends earlier. This approach ensures we have more room for the remaining intervals.\\n\\nIn C++, it would look something like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 0) return 0;\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int ans = 0, end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i][0] < end){\\n                ans++;\\n            }\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution, we first sort the intervals by their end time. Then, we iterate over the sorted intervals. For each interval, if its start time is less than the end time of the previous interval, we increment our count (as it\\'s overlapping and needs to be removed). Otherwise, we update our end time to the current interval\\'s end time. This solution has a time complexity of O(N log N), which is more efficient."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected answer is 2 because the optimal solution doesn\\'t necessarily require keeping the interval [1,100]. It seems like you\\'re operating under the assumption that the larger interval has to be kept, but that\\'s not always the case.\\n\\nLet\\'s examine the problem with the given list of intervals:\\n\\n[[1,100],[11,22],[1,11],[2,12]]\\n\\nA key point to remember is that the objective is to minimize the number of removals so as to make the remaining intervals non-overlapping. To achieve this, the optimal strategy involves removing the intervals that cause the most overlaps. In this case, interval [1,100] overlaps with all other intervals, so if we keep it, we\\'d need to remove all other intervals, which is not optimal.\\n\\nInstead, if we remove [1,100], we\\'re left with:\\n\\n[[11,22],[1,11],[2,12]]\\n\\nOut of these, [1,11] and [11,22] don\\'t overlap. However, [2,12] overlaps with both. Thus, we can remove [2,12] to make the remaining intervals non-overlapping. This way, we only need to remove 2 intervals ([1,100] and [2,12]), which is why the expected answer is 2."
                    },
                    {
                        "username": "ShaliniMishra31",
                        "content": "[@cpblnc](/cpblnc) Could you explain again?\nI have the same doubt \n\nHere is my solution:\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        vector <pair<int,int>> vec(100000, {0,0});\n        int ans = 0;\n        for(int i=0;i<intervals.size();i++)\n        {\n            int f = intervals[i][0];\n            int s = intervals[i][1];\n            int dif = s-f;\n            int c = 0;\n            for(int j=f;j<=s;j++)\n            {\n                if(vec[j].second != 1)\n                {\n                    vec[j].first = j;\n                    vec[j].second = 1;\n                }\n                else\n                {\n                    c++;\n                }\n            }\n            if(c > dif)\n            {\n                ans++;\n            }\n        }\n        return(ans);\n    }\n};\n"
                    },
                    {
                        "username": "cpblnc",
                        "content": "Why can\\'t [1,100] be removed? If you remove it and [2,12] as well, you are left with [1,11] and [11,22], which are non overlapping - 2 intervals got removed, as expected."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Sort & Greedy make people happy!"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After I saw this problem, My first thought was to use `Binary Search` with `DP` and solved it."
                    },
                    {
                        "username": "sunny8080",
                        "content": "[@ashish15678](/ashish15678) For every index, find next non-overlapping intervel using `Binary Search`. \\nFor more, just take a look at [My Solution](https://leetcode.com/problems/non-overlapping-intervals/solutions/3788241/c-java-easy-and-clean-code-dp-greedy-beats/)"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@ashish15678](/ashish15678)  u can see my soln, i also did it using DP and Binary Search. \\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/solutions/3789308/dp-binary-search-solution/"
                    },
                    {
                        "username": "ashish15678",
                        "content": "can you please explain more\\n"
                    },
                    {
                        "username": "user4653c",
                        "content": "Labeling this problem as Dynamic Programming is a bit of a nasty move. To solve it, you need to find the right intuition, attempting the DP approach will just make things more confusing"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@Charlemagne5t](/Charlemagne5t) well true it can be difficult, trying joting down all possible scenarios and see if your greedy (or any other) approach works, if it does then try to find a justification for it, sometimes u may pass the question by implementing a approach but can\\'t think of a proof of it, can happen if the proof is mathematically rigorous "
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Agreed. Tried straight forward recursion + caching and got TLE 54/58. What I like about this approach it guarantees the right answer. Greedy is more optimal solution, but how do I prove it in real world problems when I don\\'t have rich test cases sample. I need to improve my knowledge in that field I guess. "
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "It's easy to think that:\\n- If we count the overlapping times with each interval. \\n- Then, for each time we remove the interval with most overlapping interval(let's call it A)\\n- And we update the other intervals' overlapping time which is overlapped with A.\\n- When all interval has zero overlapping times, we get the result.\\n\\nI know how to do it in greedy in O(nlgn) time, but I wonder why this cant work... \\nThis idea failed in the last test case(that with 10k inputs).I can't figure out why... Can someone help me?please...?\\nThanks your time for seeing these. Thank you~"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@nsut_coder](/nsut_coder) It would still not work if we remove all duplicates. Consider the same example, but add small random fractional values to each start and end. No duplicates, but the answer remains the same,"
                    },
                    {
                        "username": "bparanj",
                        "content": "The strategy you described is known as the \"interval graph coloring\" problem and it\\'s not equivalent to the interval scheduling problem we are solving here. You are describing an approach in which we try to color intervals (remove as few as possible) such that no two overlapping intervals share the same color. That is a more complicated problem and is not what we are trying to solve here.\\n\\nYou are trying to remove the interval that has the most overlaps first. This approach does not always lead to the optimal solution. Consider the following example:\\n\\n[[1, 5], [2, 3], [3, 4], [4, 5]]\\n\\nIf we follow your approach, we\\'ll remove [1, 5] first, because it overlaps with the most intervals. But this leads to the need of removing 1 interval, while the optimal solution would be to remove none. If we select [2, 3], [3, 4], [4, 5], we can see that none of these intervals overlap, which leads to the optimal solution of 0 removals.\\n\\nThis shows why the greedy algorithm of always choosing the interval that ends the earliest works: it leaves the most room for the rest of the intervals to not overlap.\\n\\nSo the intuition for the greedy algorithm in this problem is: the sooner an interval ends, the more room we have for the rest of the intervals to fit in without overlapping. It\\'s about looking ahead and trying to leave as much room as possible for the future intervals."
                    },
                    {
                        "username": "nsut_coder",
                        "content": "[@bharathi1121](/bharathi1121) I think, algorithm would work if we remove the duplicate ranges. but how would algorithm decide which interval to remove when all of them are overlapping with same number of intervals. "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "It doesnt work because its not always the largest overlapping interval to be removed first,\\nex: [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]\\nin this example the largest overlapping interval is [2,4] but it is part of the answer."
                    }
                ]
            },
            {
                "id": 1797697,
                "content": [
                    {
                        "username": "ZimmAgu",
                        "content": "#### Initial Steps\\n* Sort the given intervals based on starting points\\n* While considering the intervals in the ascending order of starting points\\n\\t* we make use of a pointer prev pointer \\n\\t* to keep track of the interval just included in the final list\\n![image](https://assets.leetcode.com/users/images/515fa83b-44c2-4c42-8ef5-d41c7942ec32_1653774876.169032.jpeg)\\n\\n\\n\\n#### Case 1\\n* You don\\'t need to remove any intervals\\n* Continue by simply assigning the *prev* pointer to the later interval\\n* The count of intervals removed remains unchanged\\n\\n\\n#### Case 2\\n* Remove the interval with the later end point \\n* The *prev* pointer is updated to current interval\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Case 3\\n* Remove the interval with the later end point \\n* The *prev* pointer remains unchanged\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Rule of Thumb\\n* Always choose the interval that ends first\\n\\n"
                    },
                    {
                        "username": "Muhammadamin",
                        "content": "[@rohitanjane999](/rohitanjane999)  + "
                    },
                    {
                        "username": "MayuD",
                        "content": "Thank you\nThe second case had got me"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "That was really good...thanks"
                    },
                    {
                        "username": "0x415374",
                        "content": "Pretty intuitive! Unfortunately I was not able to figure this out in a reasonable amount of time."
                    },
                    {
                        "username": "voodooism",
                        "content": "with this explanation the problem becomes easy!\\nthanks!"
                    },
                    {
                        "username": "rohitanjane999",
                        "content": "thanks for explanation...."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "And this marks my 200 days of streak..."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "So i\\'m not alone. [@sarpalmadhav](/sarpalmadhav)[@Ashutosh kumar](/ashurockzz) We started on jan1. Hope we complete our 365 days challenge."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ashu0123](/ashu0123) Congrats! Same here. I too have hit 200. We both started on Jan 1!!\\n"
                    },
                    {
                        "username": "ashu0123",
                        "content": "Looks like you\\'ve used Time travel tickets"
                    },
                    {
                        "username": "oops_moment",
                        "content": "If you\\'ve already cracked this challenging problem, kudos to you! If not, fret not! Let\\'s go step by step to find the perfect solution together! \\uD83D\\uDCAA\\n\\n\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F Problem Analysis:\\nWe\\'re given an array of intervals, and the goal is to find the minimum number of intervals to remove to make the rest non-overlapping. To achieve this, we\\'ll apply the greedy approach.\\n\\n\\u2B50 Greedy Insight:\\nLet\\'s try out a few greedy strategies. Say we select the interval with the smallest start time. Oops! This fails when the interval with the smallest start time also happens to be the longest one, leading to many overlapping intervals that need to be discarded.\\n\\n\\uD83D\\uDCA1 The Winning Greedy Strategy:\\nInstead, let\\'s sort the intervals based on their end times. Why? Imagine two intervals, one ending at x and the other ending at y (where x < y). If we skip the interval ending at x and take the one ending at y, we\\'ll may have to remove at least one interval that starts in the range (x, y). So, we should always sort based on the end time of intervals.\\n\\n\\uD83D\\uDEE0\\uFE0F Implementation:\\n\\n1: Sort the intervals based on their end times in ascending order.\\n\\n2: Initialize a variable \\'answer\\' to keep track of the number of intervals to be removed.\\n\\n3: Consider the first interval as \\'last\\' or the last taken interval.\\n\\n4: Iterate through the intervals, and for each interval:\\n\\n- If the current interval\\'s start time is less than the end time of the \\'last\\' interval, they overlap. Increment \\'answer\\' as we need to remove an interval to avoid overlap.\\n\\n- Otherwise, update \\'last\\' to the current interval.\\n\\n5: Return the final value of answer.\\n\\nNow you can confidently explain this solution to others and spread the joy of problem-solving! Happy coding! \\uD83D\\uDE80"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I don\\'t get why sorting by the end of the range helps.\\nI did\\n```\\nintervals.sort(key=lambda x: x[1])\\n```"
                    },
                    {
                        "username": "jkswapnil99",
                        "content": "Why is greedy solution correct for this problem. How do we know that, of all the ways in which intervals can be deleted the greedy approach is the optimal strategy?\\n\\nI always have trouble proving this for greedy solutions"
                    },
                    {
                        "username": "aLaN09",
                        "content": "[@bparanj](/bparanj) Nicely written"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The \"proof\" does not convince me for at least a two reasons:\\n\\n1) If there is an optimal solution different from ours, why must there an interval `i` with end time larger than ours?\\n2) We have no idea where `x` starts, how do we guarantee adding `x` after removing `i` won\\'t introduce conflicts?\\n\\nSince this is a classic problem - the proof is publicly available - all we needed is to do some search. For example, there is a one liner proof on wikipedia here. https://en.wikipedia.org/wiki/Interval_scheduling#Unweighted"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand your confusion. Proving the correctness of a greedy solution can often be tricky. For this particular problem, we could demonstrate the greedy choice property and optimal substructure, two key characteristics of problems that can be solved using a greedy approach.\\n\\nThe **greedy choice property** means that a local optimum can lead to a global optimum. For this problem, the local optimum is to always select the interval with the earliest end time that doesn\\'t overlap with the current one. This choice leaves as much space as possible for the remaining intervals. If we can prove that making the greedy choice at each step leads to the solution of the overall problem, then we\\'ve shown the greedy choice property.\\n\\nThe **optimal substructure** means that an optimal solution to the problem can be constructed efficiently from optimal solutions to its subproblems. In this problem, once we make the greedy choice of picking the interval with the earliest end time, we\\'re left with a smaller subproblem: finding the optimal solution in the remaining intervals.\\n\\nHere\\'s the intuition for why this greedy strategy works:\\n\\nThe crucial observation is that the interval with the earliest end time is least likely to overlap with other intervals. Hence, keeping this interval in our solution gives us the maximum space to accommodate the remaining intervals, which in turn reduces the number of removals. \\n\\nNow, let\\'s say there\\'s an optimal solution different from ours that keeps an interval `i` with an end time later than the one we chose (let\\'s call our interval `x`). We can replace `i` with `x` in this solution, and it\\'s guaranteed not to create more overlaps because `x` ends earlier than `i`. Therefore, the new solution is still optimal, showing that our greedy choice doesn\\'t lead to a worse solution.\\n\\nThis demonstrates that the greedy choice leads to an optimal solution and that the problem has an optimal substructure, thus validating our greedy solution."
                    },
                    {
                        "username": "abhay3141",
                        "content": "Getting Time limit Exceeded even though all 58/58 case passed. Any help ?"
                    },
                    {
                        "username": "jason3410",
                        "content": "You could just regard it as a regular TLE . It\\'s just a relatively closer one."
                    },
                    {
                        "username": "spookyflame",
                        "content": "[@cqrbala](/cqrbala) ty it worked. Forgot about that lmao"
                    },
                    {
                        "username": "cqrbala",
                        "content": "[@tanisha_daharwal](/tanisha_daharwal) [@Abhay](/abhay3141) Try to pass the vectors in the comparison function by reference (using & in c++). It is much faster as there is no need to make a copy of the vectors to perform the comparison."
                    },
                    {
                        "username": "tanisha_daharwal",
                        "content": "same thing happening with me"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Task failed successfully!"
                    },
                    {
                        "username": "ashu-xx",
                        "content": "[[1,100],[11,22],[1,11],[2,12]] \\nExpect: 2\\n\\nAccording to me expected answer should be 3 because [1,100] cannot be removed and all other 3 intervals are sub-intervals of [1,100].\\n\\nCan someone explain why is expected answer 2?"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "[@Ashutosh Mittal](/ashu-xx) in above case when we consider [1, 100] it will remove 3  other interval. but there a one option remain ie Consider [11,22] and [1, 11] than there is two inverval which are overlapping with these two [1,100] and [2,12] from the two option 3,  2, 2 option minimum so the result should be 2"
                    },
                    {
                        "username": "sasimouni",
                        "content": "[@bparanj](/bparanj)  nice explanation "
                    },
                    {
                        "username": "vermadeepesh248",
                        "content": "question said to remove minimum number of intervals. \\n\\nif we let [1,100] stay then we have to remove remaining three intervals.\\nbut instead if we remove [1,100] and [2,12] then we can let [1,11] and [11,22] stay. In this case we are removing only 2 intervals. so output should be 2."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@ShaliniMishra31](/ShaliniMishra31) [@ShaliniMishra31](/ShaliniMishra31) Your approach is not completely incorrect, but it\\'s not the most optimal one. In your solution, you are trying to represent the intervals on a number line and mark the occupied points. However, this approach has a couple of significant issues:\\n\\n1. It doesn\\'t consider the interval as a whole. Intervals are more than just individual points on a line, and their overlaps can\\'t always be accurately represented by the overlap of individual points.\\n\\n2. It doesn\\'t correctly account for the case when a smaller interval is entirely within a larger one. Your solution may consider the larger interval to be overlapping, even if removing the smaller one would make all intervals non-overlapping.\\n\\n3. Your solution has a time complexity of O(N^2), which is not efficient for large inputs.\\n\\nHere is an optimal solution using the greedy algorithm. It sorts the intervals by their end time and always tries to keep the one that ends earlier. This approach ensures we have more room for the remaining intervals.\\n\\nIn C++, it would look something like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 0) return 0;\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int ans = 0, end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i][0] < end){\\n                ans++;\\n            }\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution, we first sort the intervals by their end time. Then, we iterate over the sorted intervals. For each interval, if its start time is less than the end time of the previous interval, we increment our count (as it\\'s overlapping and needs to be removed). Otherwise, we update our end time to the current interval\\'s end time. This solution has a time complexity of O(N log N), which is more efficient."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected answer is 2 because the optimal solution doesn\\'t necessarily require keeping the interval [1,100]. It seems like you\\'re operating under the assumption that the larger interval has to be kept, but that\\'s not always the case.\\n\\nLet\\'s examine the problem with the given list of intervals:\\n\\n[[1,100],[11,22],[1,11],[2,12]]\\n\\nA key point to remember is that the objective is to minimize the number of removals so as to make the remaining intervals non-overlapping. To achieve this, the optimal strategy involves removing the intervals that cause the most overlaps. In this case, interval [1,100] overlaps with all other intervals, so if we keep it, we\\'d need to remove all other intervals, which is not optimal.\\n\\nInstead, if we remove [1,100], we\\'re left with:\\n\\n[[11,22],[1,11],[2,12]]\\n\\nOut of these, [1,11] and [11,22] don\\'t overlap. However, [2,12] overlaps with both. Thus, we can remove [2,12] to make the remaining intervals non-overlapping. This way, we only need to remove 2 intervals ([1,100] and [2,12]), which is why the expected answer is 2."
                    },
                    {
                        "username": "ShaliniMishra31",
                        "content": "[@cpblnc](/cpblnc) Could you explain again?\nI have the same doubt \n\nHere is my solution:\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        vector <pair<int,int>> vec(100000, {0,0});\n        int ans = 0;\n        for(int i=0;i<intervals.size();i++)\n        {\n            int f = intervals[i][0];\n            int s = intervals[i][1];\n            int dif = s-f;\n            int c = 0;\n            for(int j=f;j<=s;j++)\n            {\n                if(vec[j].second != 1)\n                {\n                    vec[j].first = j;\n                    vec[j].second = 1;\n                }\n                else\n                {\n                    c++;\n                }\n            }\n            if(c > dif)\n            {\n                ans++;\n            }\n        }\n        return(ans);\n    }\n};\n"
                    },
                    {
                        "username": "cpblnc",
                        "content": "Why can\\'t [1,100] be removed? If you remove it and [2,12] as well, you are left with [1,11] and [11,22], which are non overlapping - 2 intervals got removed, as expected."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Sort & Greedy make people happy!"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After I saw this problem, My first thought was to use `Binary Search` with `DP` and solved it."
                    },
                    {
                        "username": "sunny8080",
                        "content": "[@ashish15678](/ashish15678) For every index, find next non-overlapping intervel using `Binary Search`. \\nFor more, just take a look at [My Solution](https://leetcode.com/problems/non-overlapping-intervals/solutions/3788241/c-java-easy-and-clean-code-dp-greedy-beats/)"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@ashish15678](/ashish15678)  u can see my soln, i also did it using DP and Binary Search. \\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/solutions/3789308/dp-binary-search-solution/"
                    },
                    {
                        "username": "ashish15678",
                        "content": "can you please explain more\\n"
                    },
                    {
                        "username": "user4653c",
                        "content": "Labeling this problem as Dynamic Programming is a bit of a nasty move. To solve it, you need to find the right intuition, attempting the DP approach will just make things more confusing"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@Charlemagne5t](/Charlemagne5t) well true it can be difficult, trying joting down all possible scenarios and see if your greedy (or any other) approach works, if it does then try to find a justification for it, sometimes u may pass the question by implementing a approach but can\\'t think of a proof of it, can happen if the proof is mathematically rigorous "
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Agreed. Tried straight forward recursion + caching and got TLE 54/58. What I like about this approach it guarantees the right answer. Greedy is more optimal solution, but how do I prove it in real world problems when I don\\'t have rich test cases sample. I need to improve my knowledge in that field I guess. "
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "It's easy to think that:\\n- If we count the overlapping times with each interval. \\n- Then, for each time we remove the interval with most overlapping interval(let's call it A)\\n- And we update the other intervals' overlapping time which is overlapped with A.\\n- When all interval has zero overlapping times, we get the result.\\n\\nI know how to do it in greedy in O(nlgn) time, but I wonder why this cant work... \\nThis idea failed in the last test case(that with 10k inputs).I can't figure out why... Can someone help me?please...?\\nThanks your time for seeing these. Thank you~"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@nsut_coder](/nsut_coder) It would still not work if we remove all duplicates. Consider the same example, but add small random fractional values to each start and end. No duplicates, but the answer remains the same,"
                    },
                    {
                        "username": "bparanj",
                        "content": "The strategy you described is known as the \"interval graph coloring\" problem and it\\'s not equivalent to the interval scheduling problem we are solving here. You are describing an approach in which we try to color intervals (remove as few as possible) such that no two overlapping intervals share the same color. That is a more complicated problem and is not what we are trying to solve here.\\n\\nYou are trying to remove the interval that has the most overlaps first. This approach does not always lead to the optimal solution. Consider the following example:\\n\\n[[1, 5], [2, 3], [3, 4], [4, 5]]\\n\\nIf we follow your approach, we\\'ll remove [1, 5] first, because it overlaps with the most intervals. But this leads to the need of removing 1 interval, while the optimal solution would be to remove none. If we select [2, 3], [3, 4], [4, 5], we can see that none of these intervals overlap, which leads to the optimal solution of 0 removals.\\n\\nThis shows why the greedy algorithm of always choosing the interval that ends the earliest works: it leaves the most room for the rest of the intervals to not overlap.\\n\\nSo the intuition for the greedy algorithm in this problem is: the sooner an interval ends, the more room we have for the rest of the intervals to fit in without overlapping. It\\'s about looking ahead and trying to leave as much room as possible for the future intervals."
                    },
                    {
                        "username": "nsut_coder",
                        "content": "[@bharathi1121](/bharathi1121) I think, algorithm would work if we remove the duplicate ranges. but how would algorithm decide which interval to remove when all of them are overlapping with same number of intervals. "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "It doesnt work because its not always the largest overlapping interval to be removed first,\\nex: [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]\\nin this example the largest overlapping interval is [2,4] but it is part of the answer."
                    }
                ]
            },
            {
                "id": 1573428,
                "content": [
                    {
                        "username": "ZimmAgu",
                        "content": "#### Initial Steps\\n* Sort the given intervals based on starting points\\n* While considering the intervals in the ascending order of starting points\\n\\t* we make use of a pointer prev pointer \\n\\t* to keep track of the interval just included in the final list\\n![image](https://assets.leetcode.com/users/images/515fa83b-44c2-4c42-8ef5-d41c7942ec32_1653774876.169032.jpeg)\\n\\n\\n\\n#### Case 1\\n* You don\\'t need to remove any intervals\\n* Continue by simply assigning the *prev* pointer to the later interval\\n* The count of intervals removed remains unchanged\\n\\n\\n#### Case 2\\n* Remove the interval with the later end point \\n* The *prev* pointer is updated to current interval\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Case 3\\n* Remove the interval with the later end point \\n* The *prev* pointer remains unchanged\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Rule of Thumb\\n* Always choose the interval that ends first\\n\\n"
                    },
                    {
                        "username": "Muhammadamin",
                        "content": "[@rohitanjane999](/rohitanjane999)  + "
                    },
                    {
                        "username": "MayuD",
                        "content": "Thank you\nThe second case had got me"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "That was really good...thanks"
                    },
                    {
                        "username": "0x415374",
                        "content": "Pretty intuitive! Unfortunately I was not able to figure this out in a reasonable amount of time."
                    },
                    {
                        "username": "voodooism",
                        "content": "with this explanation the problem becomes easy!\\nthanks!"
                    },
                    {
                        "username": "rohitanjane999",
                        "content": "thanks for explanation...."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "And this marks my 200 days of streak..."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "So i\\'m not alone. [@sarpalmadhav](/sarpalmadhav)[@Ashutosh kumar](/ashurockzz) We started on jan1. Hope we complete our 365 days challenge."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ashu0123](/ashu0123) Congrats! Same here. I too have hit 200. We both started on Jan 1!!\\n"
                    },
                    {
                        "username": "ashu0123",
                        "content": "Looks like you\\'ve used Time travel tickets"
                    },
                    {
                        "username": "oops_moment",
                        "content": "If you\\'ve already cracked this challenging problem, kudos to you! If not, fret not! Let\\'s go step by step to find the perfect solution together! \\uD83D\\uDCAA\\n\\n\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F Problem Analysis:\\nWe\\'re given an array of intervals, and the goal is to find the minimum number of intervals to remove to make the rest non-overlapping. To achieve this, we\\'ll apply the greedy approach.\\n\\n\\u2B50 Greedy Insight:\\nLet\\'s try out a few greedy strategies. Say we select the interval with the smallest start time. Oops! This fails when the interval with the smallest start time also happens to be the longest one, leading to many overlapping intervals that need to be discarded.\\n\\n\\uD83D\\uDCA1 The Winning Greedy Strategy:\\nInstead, let\\'s sort the intervals based on their end times. Why? Imagine two intervals, one ending at x and the other ending at y (where x < y). If we skip the interval ending at x and take the one ending at y, we\\'ll may have to remove at least one interval that starts in the range (x, y). So, we should always sort based on the end time of intervals.\\n\\n\\uD83D\\uDEE0\\uFE0F Implementation:\\n\\n1: Sort the intervals based on their end times in ascending order.\\n\\n2: Initialize a variable \\'answer\\' to keep track of the number of intervals to be removed.\\n\\n3: Consider the first interval as \\'last\\' or the last taken interval.\\n\\n4: Iterate through the intervals, and for each interval:\\n\\n- If the current interval\\'s start time is less than the end time of the \\'last\\' interval, they overlap. Increment \\'answer\\' as we need to remove an interval to avoid overlap.\\n\\n- Otherwise, update \\'last\\' to the current interval.\\n\\n5: Return the final value of answer.\\n\\nNow you can confidently explain this solution to others and spread the joy of problem-solving! Happy coding! \\uD83D\\uDE80"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I don\\'t get why sorting by the end of the range helps.\\nI did\\n```\\nintervals.sort(key=lambda x: x[1])\\n```"
                    },
                    {
                        "username": "jkswapnil99",
                        "content": "Why is greedy solution correct for this problem. How do we know that, of all the ways in which intervals can be deleted the greedy approach is the optimal strategy?\\n\\nI always have trouble proving this for greedy solutions"
                    },
                    {
                        "username": "aLaN09",
                        "content": "[@bparanj](/bparanj) Nicely written"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The \"proof\" does not convince me for at least a two reasons:\\n\\n1) If there is an optimal solution different from ours, why must there an interval `i` with end time larger than ours?\\n2) We have no idea where `x` starts, how do we guarantee adding `x` after removing `i` won\\'t introduce conflicts?\\n\\nSince this is a classic problem - the proof is publicly available - all we needed is to do some search. For example, there is a one liner proof on wikipedia here. https://en.wikipedia.org/wiki/Interval_scheduling#Unweighted"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand your confusion. Proving the correctness of a greedy solution can often be tricky. For this particular problem, we could demonstrate the greedy choice property and optimal substructure, two key characteristics of problems that can be solved using a greedy approach.\\n\\nThe **greedy choice property** means that a local optimum can lead to a global optimum. For this problem, the local optimum is to always select the interval with the earliest end time that doesn\\'t overlap with the current one. This choice leaves as much space as possible for the remaining intervals. If we can prove that making the greedy choice at each step leads to the solution of the overall problem, then we\\'ve shown the greedy choice property.\\n\\nThe **optimal substructure** means that an optimal solution to the problem can be constructed efficiently from optimal solutions to its subproblems. In this problem, once we make the greedy choice of picking the interval with the earliest end time, we\\'re left with a smaller subproblem: finding the optimal solution in the remaining intervals.\\n\\nHere\\'s the intuition for why this greedy strategy works:\\n\\nThe crucial observation is that the interval with the earliest end time is least likely to overlap with other intervals. Hence, keeping this interval in our solution gives us the maximum space to accommodate the remaining intervals, which in turn reduces the number of removals. \\n\\nNow, let\\'s say there\\'s an optimal solution different from ours that keeps an interval `i` with an end time later than the one we chose (let\\'s call our interval `x`). We can replace `i` with `x` in this solution, and it\\'s guaranteed not to create more overlaps because `x` ends earlier than `i`. Therefore, the new solution is still optimal, showing that our greedy choice doesn\\'t lead to a worse solution.\\n\\nThis demonstrates that the greedy choice leads to an optimal solution and that the problem has an optimal substructure, thus validating our greedy solution."
                    },
                    {
                        "username": "abhay3141",
                        "content": "Getting Time limit Exceeded even though all 58/58 case passed. Any help ?"
                    },
                    {
                        "username": "jason3410",
                        "content": "You could just regard it as a regular TLE . It\\'s just a relatively closer one."
                    },
                    {
                        "username": "spookyflame",
                        "content": "[@cqrbala](/cqrbala) ty it worked. Forgot about that lmao"
                    },
                    {
                        "username": "cqrbala",
                        "content": "[@tanisha_daharwal](/tanisha_daharwal) [@Abhay](/abhay3141) Try to pass the vectors in the comparison function by reference (using & in c++). It is much faster as there is no need to make a copy of the vectors to perform the comparison."
                    },
                    {
                        "username": "tanisha_daharwal",
                        "content": "same thing happening with me"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Task failed successfully!"
                    },
                    {
                        "username": "ashu-xx",
                        "content": "[[1,100],[11,22],[1,11],[2,12]] \\nExpect: 2\\n\\nAccording to me expected answer should be 3 because [1,100] cannot be removed and all other 3 intervals are sub-intervals of [1,100].\\n\\nCan someone explain why is expected answer 2?"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "[@Ashutosh Mittal](/ashu-xx) in above case when we consider [1, 100] it will remove 3  other interval. but there a one option remain ie Consider [11,22] and [1, 11] than there is two inverval which are overlapping with these two [1,100] and [2,12] from the two option 3,  2, 2 option minimum so the result should be 2"
                    },
                    {
                        "username": "sasimouni",
                        "content": "[@bparanj](/bparanj)  nice explanation "
                    },
                    {
                        "username": "vermadeepesh248",
                        "content": "question said to remove minimum number of intervals. \\n\\nif we let [1,100] stay then we have to remove remaining three intervals.\\nbut instead if we remove [1,100] and [2,12] then we can let [1,11] and [11,22] stay. In this case we are removing only 2 intervals. so output should be 2."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@ShaliniMishra31](/ShaliniMishra31) [@ShaliniMishra31](/ShaliniMishra31) Your approach is not completely incorrect, but it\\'s not the most optimal one. In your solution, you are trying to represent the intervals on a number line and mark the occupied points. However, this approach has a couple of significant issues:\\n\\n1. It doesn\\'t consider the interval as a whole. Intervals are more than just individual points on a line, and their overlaps can\\'t always be accurately represented by the overlap of individual points.\\n\\n2. It doesn\\'t correctly account for the case when a smaller interval is entirely within a larger one. Your solution may consider the larger interval to be overlapping, even if removing the smaller one would make all intervals non-overlapping.\\n\\n3. Your solution has a time complexity of O(N^2), which is not efficient for large inputs.\\n\\nHere is an optimal solution using the greedy algorithm. It sorts the intervals by their end time and always tries to keep the one that ends earlier. This approach ensures we have more room for the remaining intervals.\\n\\nIn C++, it would look something like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 0) return 0;\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int ans = 0, end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i][0] < end){\\n                ans++;\\n            }\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution, we first sort the intervals by their end time. Then, we iterate over the sorted intervals. For each interval, if its start time is less than the end time of the previous interval, we increment our count (as it\\'s overlapping and needs to be removed). Otherwise, we update our end time to the current interval\\'s end time. This solution has a time complexity of O(N log N), which is more efficient."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected answer is 2 because the optimal solution doesn\\'t necessarily require keeping the interval [1,100]. It seems like you\\'re operating under the assumption that the larger interval has to be kept, but that\\'s not always the case.\\n\\nLet\\'s examine the problem with the given list of intervals:\\n\\n[[1,100],[11,22],[1,11],[2,12]]\\n\\nA key point to remember is that the objective is to minimize the number of removals so as to make the remaining intervals non-overlapping. To achieve this, the optimal strategy involves removing the intervals that cause the most overlaps. In this case, interval [1,100] overlaps with all other intervals, so if we keep it, we\\'d need to remove all other intervals, which is not optimal.\\n\\nInstead, if we remove [1,100], we\\'re left with:\\n\\n[[11,22],[1,11],[2,12]]\\n\\nOut of these, [1,11] and [11,22] don\\'t overlap. However, [2,12] overlaps with both. Thus, we can remove [2,12] to make the remaining intervals non-overlapping. This way, we only need to remove 2 intervals ([1,100] and [2,12]), which is why the expected answer is 2."
                    },
                    {
                        "username": "ShaliniMishra31",
                        "content": "[@cpblnc](/cpblnc) Could you explain again?\nI have the same doubt \n\nHere is my solution:\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        vector <pair<int,int>> vec(100000, {0,0});\n        int ans = 0;\n        for(int i=0;i<intervals.size();i++)\n        {\n            int f = intervals[i][0];\n            int s = intervals[i][1];\n            int dif = s-f;\n            int c = 0;\n            for(int j=f;j<=s;j++)\n            {\n                if(vec[j].second != 1)\n                {\n                    vec[j].first = j;\n                    vec[j].second = 1;\n                }\n                else\n                {\n                    c++;\n                }\n            }\n            if(c > dif)\n            {\n                ans++;\n            }\n        }\n        return(ans);\n    }\n};\n"
                    },
                    {
                        "username": "cpblnc",
                        "content": "Why can\\'t [1,100] be removed? If you remove it and [2,12] as well, you are left with [1,11] and [11,22], which are non overlapping - 2 intervals got removed, as expected."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Sort & Greedy make people happy!"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After I saw this problem, My first thought was to use `Binary Search` with `DP` and solved it."
                    },
                    {
                        "username": "sunny8080",
                        "content": "[@ashish15678](/ashish15678) For every index, find next non-overlapping intervel using `Binary Search`. \\nFor more, just take a look at [My Solution](https://leetcode.com/problems/non-overlapping-intervals/solutions/3788241/c-java-easy-and-clean-code-dp-greedy-beats/)"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@ashish15678](/ashish15678)  u can see my soln, i also did it using DP and Binary Search. \\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/solutions/3789308/dp-binary-search-solution/"
                    },
                    {
                        "username": "ashish15678",
                        "content": "can you please explain more\\n"
                    },
                    {
                        "username": "user4653c",
                        "content": "Labeling this problem as Dynamic Programming is a bit of a nasty move. To solve it, you need to find the right intuition, attempting the DP approach will just make things more confusing"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@Charlemagne5t](/Charlemagne5t) well true it can be difficult, trying joting down all possible scenarios and see if your greedy (or any other) approach works, if it does then try to find a justification for it, sometimes u may pass the question by implementing a approach but can\\'t think of a proof of it, can happen if the proof is mathematically rigorous "
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Agreed. Tried straight forward recursion + caching and got TLE 54/58. What I like about this approach it guarantees the right answer. Greedy is more optimal solution, but how do I prove it in real world problems when I don\\'t have rich test cases sample. I need to improve my knowledge in that field I guess. "
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "It's easy to think that:\\n- If we count the overlapping times with each interval. \\n- Then, for each time we remove the interval with most overlapping interval(let's call it A)\\n- And we update the other intervals' overlapping time which is overlapped with A.\\n- When all interval has zero overlapping times, we get the result.\\n\\nI know how to do it in greedy in O(nlgn) time, but I wonder why this cant work... \\nThis idea failed in the last test case(that with 10k inputs).I can't figure out why... Can someone help me?please...?\\nThanks your time for seeing these. Thank you~"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@nsut_coder](/nsut_coder) It would still not work if we remove all duplicates. Consider the same example, but add small random fractional values to each start and end. No duplicates, but the answer remains the same,"
                    },
                    {
                        "username": "bparanj",
                        "content": "The strategy you described is known as the \"interval graph coloring\" problem and it\\'s not equivalent to the interval scheduling problem we are solving here. You are describing an approach in which we try to color intervals (remove as few as possible) such that no two overlapping intervals share the same color. That is a more complicated problem and is not what we are trying to solve here.\\n\\nYou are trying to remove the interval that has the most overlaps first. This approach does not always lead to the optimal solution. Consider the following example:\\n\\n[[1, 5], [2, 3], [3, 4], [4, 5]]\\n\\nIf we follow your approach, we\\'ll remove [1, 5] first, because it overlaps with the most intervals. But this leads to the need of removing 1 interval, while the optimal solution would be to remove none. If we select [2, 3], [3, 4], [4, 5], we can see that none of these intervals overlap, which leads to the optimal solution of 0 removals.\\n\\nThis shows why the greedy algorithm of always choosing the interval that ends the earliest works: it leaves the most room for the rest of the intervals to not overlap.\\n\\nSo the intuition for the greedy algorithm in this problem is: the sooner an interval ends, the more room we have for the rest of the intervals to fit in without overlapping. It\\'s about looking ahead and trying to leave as much room as possible for the future intervals."
                    },
                    {
                        "username": "nsut_coder",
                        "content": "[@bharathi1121](/bharathi1121) I think, algorithm would work if we remove the duplicate ranges. but how would algorithm decide which interval to remove when all of them are overlapping with same number of intervals. "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "It doesnt work because its not always the largest overlapping interval to be removed first,\\nex: [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]\\nin this example the largest overlapping interval is [2,4] but it is part of the answer."
                    }
                ]
            },
            {
                "id": 1976350,
                "content": [
                    {
                        "username": "ZimmAgu",
                        "content": "#### Initial Steps\\n* Sort the given intervals based on starting points\\n* While considering the intervals in the ascending order of starting points\\n\\t* we make use of a pointer prev pointer \\n\\t* to keep track of the interval just included in the final list\\n![image](https://assets.leetcode.com/users/images/515fa83b-44c2-4c42-8ef5-d41c7942ec32_1653774876.169032.jpeg)\\n\\n\\n\\n#### Case 1\\n* You don\\'t need to remove any intervals\\n* Continue by simply assigning the *prev* pointer to the later interval\\n* The count of intervals removed remains unchanged\\n\\n\\n#### Case 2\\n* Remove the interval with the later end point \\n* The *prev* pointer is updated to current interval\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Case 3\\n* Remove the interval with the later end point \\n* The *prev* pointer remains unchanged\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Rule of Thumb\\n* Always choose the interval that ends first\\n\\n"
                    },
                    {
                        "username": "Muhammadamin",
                        "content": "[@rohitanjane999](/rohitanjane999)  + "
                    },
                    {
                        "username": "MayuD",
                        "content": "Thank you\nThe second case had got me"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "That was really good...thanks"
                    },
                    {
                        "username": "0x415374",
                        "content": "Pretty intuitive! Unfortunately I was not able to figure this out in a reasonable amount of time."
                    },
                    {
                        "username": "voodooism",
                        "content": "with this explanation the problem becomes easy!\\nthanks!"
                    },
                    {
                        "username": "rohitanjane999",
                        "content": "thanks for explanation...."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "And this marks my 200 days of streak..."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "So i\\'m not alone. [@sarpalmadhav](/sarpalmadhav)[@Ashutosh kumar](/ashurockzz) We started on jan1. Hope we complete our 365 days challenge."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ashu0123](/ashu0123) Congrats! Same here. I too have hit 200. We both started on Jan 1!!\\n"
                    },
                    {
                        "username": "ashu0123",
                        "content": "Looks like you\\'ve used Time travel tickets"
                    },
                    {
                        "username": "oops_moment",
                        "content": "If you\\'ve already cracked this challenging problem, kudos to you! If not, fret not! Let\\'s go step by step to find the perfect solution together! \\uD83D\\uDCAA\\n\\n\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F Problem Analysis:\\nWe\\'re given an array of intervals, and the goal is to find the minimum number of intervals to remove to make the rest non-overlapping. To achieve this, we\\'ll apply the greedy approach.\\n\\n\\u2B50 Greedy Insight:\\nLet\\'s try out a few greedy strategies. Say we select the interval with the smallest start time. Oops! This fails when the interval with the smallest start time also happens to be the longest one, leading to many overlapping intervals that need to be discarded.\\n\\n\\uD83D\\uDCA1 The Winning Greedy Strategy:\\nInstead, let\\'s sort the intervals based on their end times. Why? Imagine two intervals, one ending at x and the other ending at y (where x < y). If we skip the interval ending at x and take the one ending at y, we\\'ll may have to remove at least one interval that starts in the range (x, y). So, we should always sort based on the end time of intervals.\\n\\n\\uD83D\\uDEE0\\uFE0F Implementation:\\n\\n1: Sort the intervals based on their end times in ascending order.\\n\\n2: Initialize a variable \\'answer\\' to keep track of the number of intervals to be removed.\\n\\n3: Consider the first interval as \\'last\\' or the last taken interval.\\n\\n4: Iterate through the intervals, and for each interval:\\n\\n- If the current interval\\'s start time is less than the end time of the \\'last\\' interval, they overlap. Increment \\'answer\\' as we need to remove an interval to avoid overlap.\\n\\n- Otherwise, update \\'last\\' to the current interval.\\n\\n5: Return the final value of answer.\\n\\nNow you can confidently explain this solution to others and spread the joy of problem-solving! Happy coding! \\uD83D\\uDE80"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I don\\'t get why sorting by the end of the range helps.\\nI did\\n```\\nintervals.sort(key=lambda x: x[1])\\n```"
                    },
                    {
                        "username": "jkswapnil99",
                        "content": "Why is greedy solution correct for this problem. How do we know that, of all the ways in which intervals can be deleted the greedy approach is the optimal strategy?\\n\\nI always have trouble proving this for greedy solutions"
                    },
                    {
                        "username": "aLaN09",
                        "content": "[@bparanj](/bparanj) Nicely written"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The \"proof\" does not convince me for at least a two reasons:\\n\\n1) If there is an optimal solution different from ours, why must there an interval `i` with end time larger than ours?\\n2) We have no idea where `x` starts, how do we guarantee adding `x` after removing `i` won\\'t introduce conflicts?\\n\\nSince this is a classic problem - the proof is publicly available - all we needed is to do some search. For example, there is a one liner proof on wikipedia here. https://en.wikipedia.org/wiki/Interval_scheduling#Unweighted"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand your confusion. Proving the correctness of a greedy solution can often be tricky. For this particular problem, we could demonstrate the greedy choice property and optimal substructure, two key characteristics of problems that can be solved using a greedy approach.\\n\\nThe **greedy choice property** means that a local optimum can lead to a global optimum. For this problem, the local optimum is to always select the interval with the earliest end time that doesn\\'t overlap with the current one. This choice leaves as much space as possible for the remaining intervals. If we can prove that making the greedy choice at each step leads to the solution of the overall problem, then we\\'ve shown the greedy choice property.\\n\\nThe **optimal substructure** means that an optimal solution to the problem can be constructed efficiently from optimal solutions to its subproblems. In this problem, once we make the greedy choice of picking the interval with the earliest end time, we\\'re left with a smaller subproblem: finding the optimal solution in the remaining intervals.\\n\\nHere\\'s the intuition for why this greedy strategy works:\\n\\nThe crucial observation is that the interval with the earliest end time is least likely to overlap with other intervals. Hence, keeping this interval in our solution gives us the maximum space to accommodate the remaining intervals, which in turn reduces the number of removals. \\n\\nNow, let\\'s say there\\'s an optimal solution different from ours that keeps an interval `i` with an end time later than the one we chose (let\\'s call our interval `x`). We can replace `i` with `x` in this solution, and it\\'s guaranteed not to create more overlaps because `x` ends earlier than `i`. Therefore, the new solution is still optimal, showing that our greedy choice doesn\\'t lead to a worse solution.\\n\\nThis demonstrates that the greedy choice leads to an optimal solution and that the problem has an optimal substructure, thus validating our greedy solution."
                    },
                    {
                        "username": "abhay3141",
                        "content": "Getting Time limit Exceeded even though all 58/58 case passed. Any help ?"
                    },
                    {
                        "username": "jason3410",
                        "content": "You could just regard it as a regular TLE . It\\'s just a relatively closer one."
                    },
                    {
                        "username": "spookyflame",
                        "content": "[@cqrbala](/cqrbala) ty it worked. Forgot about that lmao"
                    },
                    {
                        "username": "cqrbala",
                        "content": "[@tanisha_daharwal](/tanisha_daharwal) [@Abhay](/abhay3141) Try to pass the vectors in the comparison function by reference (using & in c++). It is much faster as there is no need to make a copy of the vectors to perform the comparison."
                    },
                    {
                        "username": "tanisha_daharwal",
                        "content": "same thing happening with me"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Task failed successfully!"
                    },
                    {
                        "username": "ashu-xx",
                        "content": "[[1,100],[11,22],[1,11],[2,12]] \\nExpect: 2\\n\\nAccording to me expected answer should be 3 because [1,100] cannot be removed and all other 3 intervals are sub-intervals of [1,100].\\n\\nCan someone explain why is expected answer 2?"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "[@Ashutosh Mittal](/ashu-xx) in above case when we consider [1, 100] it will remove 3  other interval. but there a one option remain ie Consider [11,22] and [1, 11] than there is two inverval which are overlapping with these two [1,100] and [2,12] from the two option 3,  2, 2 option minimum so the result should be 2"
                    },
                    {
                        "username": "sasimouni",
                        "content": "[@bparanj](/bparanj)  nice explanation "
                    },
                    {
                        "username": "vermadeepesh248",
                        "content": "question said to remove minimum number of intervals. \\n\\nif we let [1,100] stay then we have to remove remaining three intervals.\\nbut instead if we remove [1,100] and [2,12] then we can let [1,11] and [11,22] stay. In this case we are removing only 2 intervals. so output should be 2."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@ShaliniMishra31](/ShaliniMishra31) [@ShaliniMishra31](/ShaliniMishra31) Your approach is not completely incorrect, but it\\'s not the most optimal one. In your solution, you are trying to represent the intervals on a number line and mark the occupied points. However, this approach has a couple of significant issues:\\n\\n1. It doesn\\'t consider the interval as a whole. Intervals are more than just individual points on a line, and their overlaps can\\'t always be accurately represented by the overlap of individual points.\\n\\n2. It doesn\\'t correctly account for the case when a smaller interval is entirely within a larger one. Your solution may consider the larger interval to be overlapping, even if removing the smaller one would make all intervals non-overlapping.\\n\\n3. Your solution has a time complexity of O(N^2), which is not efficient for large inputs.\\n\\nHere is an optimal solution using the greedy algorithm. It sorts the intervals by their end time and always tries to keep the one that ends earlier. This approach ensures we have more room for the remaining intervals.\\n\\nIn C++, it would look something like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 0) return 0;\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int ans = 0, end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i][0] < end){\\n                ans++;\\n            }\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution, we first sort the intervals by their end time. Then, we iterate over the sorted intervals. For each interval, if its start time is less than the end time of the previous interval, we increment our count (as it\\'s overlapping and needs to be removed). Otherwise, we update our end time to the current interval\\'s end time. This solution has a time complexity of O(N log N), which is more efficient."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected answer is 2 because the optimal solution doesn\\'t necessarily require keeping the interval [1,100]. It seems like you\\'re operating under the assumption that the larger interval has to be kept, but that\\'s not always the case.\\n\\nLet\\'s examine the problem with the given list of intervals:\\n\\n[[1,100],[11,22],[1,11],[2,12]]\\n\\nA key point to remember is that the objective is to minimize the number of removals so as to make the remaining intervals non-overlapping. To achieve this, the optimal strategy involves removing the intervals that cause the most overlaps. In this case, interval [1,100] overlaps with all other intervals, so if we keep it, we\\'d need to remove all other intervals, which is not optimal.\\n\\nInstead, if we remove [1,100], we\\'re left with:\\n\\n[[11,22],[1,11],[2,12]]\\n\\nOut of these, [1,11] and [11,22] don\\'t overlap. However, [2,12] overlaps with both. Thus, we can remove [2,12] to make the remaining intervals non-overlapping. This way, we only need to remove 2 intervals ([1,100] and [2,12]), which is why the expected answer is 2."
                    },
                    {
                        "username": "ShaliniMishra31",
                        "content": "[@cpblnc](/cpblnc) Could you explain again?\nI have the same doubt \n\nHere is my solution:\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        vector <pair<int,int>> vec(100000, {0,0});\n        int ans = 0;\n        for(int i=0;i<intervals.size();i++)\n        {\n            int f = intervals[i][0];\n            int s = intervals[i][1];\n            int dif = s-f;\n            int c = 0;\n            for(int j=f;j<=s;j++)\n            {\n                if(vec[j].second != 1)\n                {\n                    vec[j].first = j;\n                    vec[j].second = 1;\n                }\n                else\n                {\n                    c++;\n                }\n            }\n            if(c > dif)\n            {\n                ans++;\n            }\n        }\n        return(ans);\n    }\n};\n"
                    },
                    {
                        "username": "cpblnc",
                        "content": "Why can\\'t [1,100] be removed? If you remove it and [2,12] as well, you are left with [1,11] and [11,22], which are non overlapping - 2 intervals got removed, as expected."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Sort & Greedy make people happy!"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After I saw this problem, My first thought was to use `Binary Search` with `DP` and solved it."
                    },
                    {
                        "username": "sunny8080",
                        "content": "[@ashish15678](/ashish15678) For every index, find next non-overlapping intervel using `Binary Search`. \\nFor more, just take a look at [My Solution](https://leetcode.com/problems/non-overlapping-intervals/solutions/3788241/c-java-easy-and-clean-code-dp-greedy-beats/)"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@ashish15678](/ashish15678)  u can see my soln, i also did it using DP and Binary Search. \\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/solutions/3789308/dp-binary-search-solution/"
                    },
                    {
                        "username": "ashish15678",
                        "content": "can you please explain more\\n"
                    },
                    {
                        "username": "user4653c",
                        "content": "Labeling this problem as Dynamic Programming is a bit of a nasty move. To solve it, you need to find the right intuition, attempting the DP approach will just make things more confusing"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@Charlemagne5t](/Charlemagne5t) well true it can be difficult, trying joting down all possible scenarios and see if your greedy (or any other) approach works, if it does then try to find a justification for it, sometimes u may pass the question by implementing a approach but can\\'t think of a proof of it, can happen if the proof is mathematically rigorous "
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Agreed. Tried straight forward recursion + caching and got TLE 54/58. What I like about this approach it guarantees the right answer. Greedy is more optimal solution, but how do I prove it in real world problems when I don\\'t have rich test cases sample. I need to improve my knowledge in that field I guess. "
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "It's easy to think that:\\n- If we count the overlapping times with each interval. \\n- Then, for each time we remove the interval with most overlapping interval(let's call it A)\\n- And we update the other intervals' overlapping time which is overlapped with A.\\n- When all interval has zero overlapping times, we get the result.\\n\\nI know how to do it in greedy in O(nlgn) time, but I wonder why this cant work... \\nThis idea failed in the last test case(that with 10k inputs).I can't figure out why... Can someone help me?please...?\\nThanks your time for seeing these. Thank you~"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@nsut_coder](/nsut_coder) It would still not work if we remove all duplicates. Consider the same example, but add small random fractional values to each start and end. No duplicates, but the answer remains the same,"
                    },
                    {
                        "username": "bparanj",
                        "content": "The strategy you described is known as the \"interval graph coloring\" problem and it\\'s not equivalent to the interval scheduling problem we are solving here. You are describing an approach in which we try to color intervals (remove as few as possible) such that no two overlapping intervals share the same color. That is a more complicated problem and is not what we are trying to solve here.\\n\\nYou are trying to remove the interval that has the most overlaps first. This approach does not always lead to the optimal solution. Consider the following example:\\n\\n[[1, 5], [2, 3], [3, 4], [4, 5]]\\n\\nIf we follow your approach, we\\'ll remove [1, 5] first, because it overlaps with the most intervals. But this leads to the need of removing 1 interval, while the optimal solution would be to remove none. If we select [2, 3], [3, 4], [4, 5], we can see that none of these intervals overlap, which leads to the optimal solution of 0 removals.\\n\\nThis shows why the greedy algorithm of always choosing the interval that ends the earliest works: it leaves the most room for the rest of the intervals to not overlap.\\n\\nSo the intuition for the greedy algorithm in this problem is: the sooner an interval ends, the more room we have for the rest of the intervals to fit in without overlapping. It\\'s about looking ahead and trying to leave as much room as possible for the future intervals."
                    },
                    {
                        "username": "nsut_coder",
                        "content": "[@bharathi1121](/bharathi1121) I think, algorithm would work if we remove the duplicate ranges. but how would algorithm decide which interval to remove when all of them are overlapping with same number of intervals. "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "It doesnt work because its not always the largest overlapping interval to be removed first,\\nex: [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]\\nin this example the largest overlapping interval is [2,4] but it is part of the answer."
                    }
                ]
            },
            {
                "id": 1976780,
                "content": [
                    {
                        "username": "ZimmAgu",
                        "content": "#### Initial Steps\\n* Sort the given intervals based on starting points\\n* While considering the intervals in the ascending order of starting points\\n\\t* we make use of a pointer prev pointer \\n\\t* to keep track of the interval just included in the final list\\n![image](https://assets.leetcode.com/users/images/515fa83b-44c2-4c42-8ef5-d41c7942ec32_1653774876.169032.jpeg)\\n\\n\\n\\n#### Case 1\\n* You don\\'t need to remove any intervals\\n* Continue by simply assigning the *prev* pointer to the later interval\\n* The count of intervals removed remains unchanged\\n\\n\\n#### Case 2\\n* Remove the interval with the later end point \\n* The *prev* pointer is updated to current interval\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Case 3\\n* Remove the interval with the later end point \\n* The *prev* pointer remains unchanged\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Rule of Thumb\\n* Always choose the interval that ends first\\n\\n"
                    },
                    {
                        "username": "Muhammadamin",
                        "content": "[@rohitanjane999](/rohitanjane999)  + "
                    },
                    {
                        "username": "MayuD",
                        "content": "Thank you\nThe second case had got me"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "That was really good...thanks"
                    },
                    {
                        "username": "0x415374",
                        "content": "Pretty intuitive! Unfortunately I was not able to figure this out in a reasonable amount of time."
                    },
                    {
                        "username": "voodooism",
                        "content": "with this explanation the problem becomes easy!\\nthanks!"
                    },
                    {
                        "username": "rohitanjane999",
                        "content": "thanks for explanation...."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "And this marks my 200 days of streak..."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "So i\\'m not alone. [@sarpalmadhav](/sarpalmadhav)[@Ashutosh kumar](/ashurockzz) We started on jan1. Hope we complete our 365 days challenge."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ashu0123](/ashu0123) Congrats! Same here. I too have hit 200. We both started on Jan 1!!\\n"
                    },
                    {
                        "username": "ashu0123",
                        "content": "Looks like you\\'ve used Time travel tickets"
                    },
                    {
                        "username": "oops_moment",
                        "content": "If you\\'ve already cracked this challenging problem, kudos to you! If not, fret not! Let\\'s go step by step to find the perfect solution together! \\uD83D\\uDCAA\\n\\n\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F Problem Analysis:\\nWe\\'re given an array of intervals, and the goal is to find the minimum number of intervals to remove to make the rest non-overlapping. To achieve this, we\\'ll apply the greedy approach.\\n\\n\\u2B50 Greedy Insight:\\nLet\\'s try out a few greedy strategies. Say we select the interval with the smallest start time. Oops! This fails when the interval with the smallest start time also happens to be the longest one, leading to many overlapping intervals that need to be discarded.\\n\\n\\uD83D\\uDCA1 The Winning Greedy Strategy:\\nInstead, let\\'s sort the intervals based on their end times. Why? Imagine two intervals, one ending at x and the other ending at y (where x < y). If we skip the interval ending at x and take the one ending at y, we\\'ll may have to remove at least one interval that starts in the range (x, y). So, we should always sort based on the end time of intervals.\\n\\n\\uD83D\\uDEE0\\uFE0F Implementation:\\n\\n1: Sort the intervals based on their end times in ascending order.\\n\\n2: Initialize a variable \\'answer\\' to keep track of the number of intervals to be removed.\\n\\n3: Consider the first interval as \\'last\\' or the last taken interval.\\n\\n4: Iterate through the intervals, and for each interval:\\n\\n- If the current interval\\'s start time is less than the end time of the \\'last\\' interval, they overlap. Increment \\'answer\\' as we need to remove an interval to avoid overlap.\\n\\n- Otherwise, update \\'last\\' to the current interval.\\n\\n5: Return the final value of answer.\\n\\nNow you can confidently explain this solution to others and spread the joy of problem-solving! Happy coding! \\uD83D\\uDE80"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I don\\'t get why sorting by the end of the range helps.\\nI did\\n```\\nintervals.sort(key=lambda x: x[1])\\n```"
                    },
                    {
                        "username": "jkswapnil99",
                        "content": "Why is greedy solution correct for this problem. How do we know that, of all the ways in which intervals can be deleted the greedy approach is the optimal strategy?\\n\\nI always have trouble proving this for greedy solutions"
                    },
                    {
                        "username": "aLaN09",
                        "content": "[@bparanj](/bparanj) Nicely written"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The \"proof\" does not convince me for at least a two reasons:\\n\\n1) If there is an optimal solution different from ours, why must there an interval `i` with end time larger than ours?\\n2) We have no idea where `x` starts, how do we guarantee adding `x` after removing `i` won\\'t introduce conflicts?\\n\\nSince this is a classic problem - the proof is publicly available - all we needed is to do some search. For example, there is a one liner proof on wikipedia here. https://en.wikipedia.org/wiki/Interval_scheduling#Unweighted"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand your confusion. Proving the correctness of a greedy solution can often be tricky. For this particular problem, we could demonstrate the greedy choice property and optimal substructure, two key characteristics of problems that can be solved using a greedy approach.\\n\\nThe **greedy choice property** means that a local optimum can lead to a global optimum. For this problem, the local optimum is to always select the interval with the earliest end time that doesn\\'t overlap with the current one. This choice leaves as much space as possible for the remaining intervals. If we can prove that making the greedy choice at each step leads to the solution of the overall problem, then we\\'ve shown the greedy choice property.\\n\\nThe **optimal substructure** means that an optimal solution to the problem can be constructed efficiently from optimal solutions to its subproblems. In this problem, once we make the greedy choice of picking the interval with the earliest end time, we\\'re left with a smaller subproblem: finding the optimal solution in the remaining intervals.\\n\\nHere\\'s the intuition for why this greedy strategy works:\\n\\nThe crucial observation is that the interval with the earliest end time is least likely to overlap with other intervals. Hence, keeping this interval in our solution gives us the maximum space to accommodate the remaining intervals, which in turn reduces the number of removals. \\n\\nNow, let\\'s say there\\'s an optimal solution different from ours that keeps an interval `i` with an end time later than the one we chose (let\\'s call our interval `x`). We can replace `i` with `x` in this solution, and it\\'s guaranteed not to create more overlaps because `x` ends earlier than `i`. Therefore, the new solution is still optimal, showing that our greedy choice doesn\\'t lead to a worse solution.\\n\\nThis demonstrates that the greedy choice leads to an optimal solution and that the problem has an optimal substructure, thus validating our greedy solution."
                    },
                    {
                        "username": "abhay3141",
                        "content": "Getting Time limit Exceeded even though all 58/58 case passed. Any help ?"
                    },
                    {
                        "username": "jason3410",
                        "content": "You could just regard it as a regular TLE . It\\'s just a relatively closer one."
                    },
                    {
                        "username": "spookyflame",
                        "content": "[@cqrbala](/cqrbala) ty it worked. Forgot about that lmao"
                    },
                    {
                        "username": "cqrbala",
                        "content": "[@tanisha_daharwal](/tanisha_daharwal) [@Abhay](/abhay3141) Try to pass the vectors in the comparison function by reference (using & in c++). It is much faster as there is no need to make a copy of the vectors to perform the comparison."
                    },
                    {
                        "username": "tanisha_daharwal",
                        "content": "same thing happening with me"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Task failed successfully!"
                    },
                    {
                        "username": "ashu-xx",
                        "content": "[[1,100],[11,22],[1,11],[2,12]] \\nExpect: 2\\n\\nAccording to me expected answer should be 3 because [1,100] cannot be removed and all other 3 intervals are sub-intervals of [1,100].\\n\\nCan someone explain why is expected answer 2?"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "[@Ashutosh Mittal](/ashu-xx) in above case when we consider [1, 100] it will remove 3  other interval. but there a one option remain ie Consider [11,22] and [1, 11] than there is two inverval which are overlapping with these two [1,100] and [2,12] from the two option 3,  2, 2 option minimum so the result should be 2"
                    },
                    {
                        "username": "sasimouni",
                        "content": "[@bparanj](/bparanj)  nice explanation "
                    },
                    {
                        "username": "vermadeepesh248",
                        "content": "question said to remove minimum number of intervals. \\n\\nif we let [1,100] stay then we have to remove remaining three intervals.\\nbut instead if we remove [1,100] and [2,12] then we can let [1,11] and [11,22] stay. In this case we are removing only 2 intervals. so output should be 2."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@ShaliniMishra31](/ShaliniMishra31) [@ShaliniMishra31](/ShaliniMishra31) Your approach is not completely incorrect, but it\\'s not the most optimal one. In your solution, you are trying to represent the intervals on a number line and mark the occupied points. However, this approach has a couple of significant issues:\\n\\n1. It doesn\\'t consider the interval as a whole. Intervals are more than just individual points on a line, and their overlaps can\\'t always be accurately represented by the overlap of individual points.\\n\\n2. It doesn\\'t correctly account for the case when a smaller interval is entirely within a larger one. Your solution may consider the larger interval to be overlapping, even if removing the smaller one would make all intervals non-overlapping.\\n\\n3. Your solution has a time complexity of O(N^2), which is not efficient for large inputs.\\n\\nHere is an optimal solution using the greedy algorithm. It sorts the intervals by their end time and always tries to keep the one that ends earlier. This approach ensures we have more room for the remaining intervals.\\n\\nIn C++, it would look something like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 0) return 0;\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int ans = 0, end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i][0] < end){\\n                ans++;\\n            }\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution, we first sort the intervals by their end time. Then, we iterate over the sorted intervals. For each interval, if its start time is less than the end time of the previous interval, we increment our count (as it\\'s overlapping and needs to be removed). Otherwise, we update our end time to the current interval\\'s end time. This solution has a time complexity of O(N log N), which is more efficient."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected answer is 2 because the optimal solution doesn\\'t necessarily require keeping the interval [1,100]. It seems like you\\'re operating under the assumption that the larger interval has to be kept, but that\\'s not always the case.\\n\\nLet\\'s examine the problem with the given list of intervals:\\n\\n[[1,100],[11,22],[1,11],[2,12]]\\n\\nA key point to remember is that the objective is to minimize the number of removals so as to make the remaining intervals non-overlapping. To achieve this, the optimal strategy involves removing the intervals that cause the most overlaps. In this case, interval [1,100] overlaps with all other intervals, so if we keep it, we\\'d need to remove all other intervals, which is not optimal.\\n\\nInstead, if we remove [1,100], we\\'re left with:\\n\\n[[11,22],[1,11],[2,12]]\\n\\nOut of these, [1,11] and [11,22] don\\'t overlap. However, [2,12] overlaps with both. Thus, we can remove [2,12] to make the remaining intervals non-overlapping. This way, we only need to remove 2 intervals ([1,100] and [2,12]), which is why the expected answer is 2."
                    },
                    {
                        "username": "ShaliniMishra31",
                        "content": "[@cpblnc](/cpblnc) Could you explain again?\nI have the same doubt \n\nHere is my solution:\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        vector <pair<int,int>> vec(100000, {0,0});\n        int ans = 0;\n        for(int i=0;i<intervals.size();i++)\n        {\n            int f = intervals[i][0];\n            int s = intervals[i][1];\n            int dif = s-f;\n            int c = 0;\n            for(int j=f;j<=s;j++)\n            {\n                if(vec[j].second != 1)\n                {\n                    vec[j].first = j;\n                    vec[j].second = 1;\n                }\n                else\n                {\n                    c++;\n                }\n            }\n            if(c > dif)\n            {\n                ans++;\n            }\n        }\n        return(ans);\n    }\n};\n"
                    },
                    {
                        "username": "cpblnc",
                        "content": "Why can\\'t [1,100] be removed? If you remove it and [2,12] as well, you are left with [1,11] and [11,22], which are non overlapping - 2 intervals got removed, as expected."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Sort & Greedy make people happy!"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After I saw this problem, My first thought was to use `Binary Search` with `DP` and solved it."
                    },
                    {
                        "username": "sunny8080",
                        "content": "[@ashish15678](/ashish15678) For every index, find next non-overlapping intervel using `Binary Search`. \\nFor more, just take a look at [My Solution](https://leetcode.com/problems/non-overlapping-intervals/solutions/3788241/c-java-easy-and-clean-code-dp-greedy-beats/)"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@ashish15678](/ashish15678)  u can see my soln, i also did it using DP and Binary Search. \\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/solutions/3789308/dp-binary-search-solution/"
                    },
                    {
                        "username": "ashish15678",
                        "content": "can you please explain more\\n"
                    },
                    {
                        "username": "user4653c",
                        "content": "Labeling this problem as Dynamic Programming is a bit of a nasty move. To solve it, you need to find the right intuition, attempting the DP approach will just make things more confusing"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@Charlemagne5t](/Charlemagne5t) well true it can be difficult, trying joting down all possible scenarios and see if your greedy (or any other) approach works, if it does then try to find a justification for it, sometimes u may pass the question by implementing a approach but can\\'t think of a proof of it, can happen if the proof is mathematically rigorous "
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Agreed. Tried straight forward recursion + caching and got TLE 54/58. What I like about this approach it guarantees the right answer. Greedy is more optimal solution, but how do I prove it in real world problems when I don\\'t have rich test cases sample. I need to improve my knowledge in that field I guess. "
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "It's easy to think that:\\n- If we count the overlapping times with each interval. \\n- Then, for each time we remove the interval with most overlapping interval(let's call it A)\\n- And we update the other intervals' overlapping time which is overlapped with A.\\n- When all interval has zero overlapping times, we get the result.\\n\\nI know how to do it in greedy in O(nlgn) time, but I wonder why this cant work... \\nThis idea failed in the last test case(that with 10k inputs).I can't figure out why... Can someone help me?please...?\\nThanks your time for seeing these. Thank you~"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@nsut_coder](/nsut_coder) It would still not work if we remove all duplicates. Consider the same example, but add small random fractional values to each start and end. No duplicates, but the answer remains the same,"
                    },
                    {
                        "username": "bparanj",
                        "content": "The strategy you described is known as the \"interval graph coloring\" problem and it\\'s not equivalent to the interval scheduling problem we are solving here. You are describing an approach in which we try to color intervals (remove as few as possible) such that no two overlapping intervals share the same color. That is a more complicated problem and is not what we are trying to solve here.\\n\\nYou are trying to remove the interval that has the most overlaps first. This approach does not always lead to the optimal solution. Consider the following example:\\n\\n[[1, 5], [2, 3], [3, 4], [4, 5]]\\n\\nIf we follow your approach, we\\'ll remove [1, 5] first, because it overlaps with the most intervals. But this leads to the need of removing 1 interval, while the optimal solution would be to remove none. If we select [2, 3], [3, 4], [4, 5], we can see that none of these intervals overlap, which leads to the optimal solution of 0 removals.\\n\\nThis shows why the greedy algorithm of always choosing the interval that ends the earliest works: it leaves the most room for the rest of the intervals to not overlap.\\n\\nSo the intuition for the greedy algorithm in this problem is: the sooner an interval ends, the more room we have for the rest of the intervals to fit in without overlapping. It\\'s about looking ahead and trying to leave as much room as possible for the future intervals."
                    },
                    {
                        "username": "nsut_coder",
                        "content": "[@bharathi1121](/bharathi1121) I think, algorithm would work if we remove the duplicate ranges. but how would algorithm decide which interval to remove when all of them are overlapping with same number of intervals. "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "It doesnt work because its not always the largest overlapping interval to be removed first,\\nex: [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]\\nin this example the largest overlapping interval is [2,4] but it is part of the answer."
                    }
                ]
            },
            {
                "id": 1920316,
                "content": [
                    {
                        "username": "ZimmAgu",
                        "content": "#### Initial Steps\\n* Sort the given intervals based on starting points\\n* While considering the intervals in the ascending order of starting points\\n\\t* we make use of a pointer prev pointer \\n\\t* to keep track of the interval just included in the final list\\n![image](https://assets.leetcode.com/users/images/515fa83b-44c2-4c42-8ef5-d41c7942ec32_1653774876.169032.jpeg)\\n\\n\\n\\n#### Case 1\\n* You don\\'t need to remove any intervals\\n* Continue by simply assigning the *prev* pointer to the later interval\\n* The count of intervals removed remains unchanged\\n\\n\\n#### Case 2\\n* Remove the interval with the later end point \\n* The *prev* pointer is updated to current interval\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Case 3\\n* Remove the interval with the later end point \\n* The *prev* pointer remains unchanged\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Rule of Thumb\\n* Always choose the interval that ends first\\n\\n"
                    },
                    {
                        "username": "Muhammadamin",
                        "content": "[@rohitanjane999](/rohitanjane999)  + "
                    },
                    {
                        "username": "MayuD",
                        "content": "Thank you\nThe second case had got me"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "That was really good...thanks"
                    },
                    {
                        "username": "0x415374",
                        "content": "Pretty intuitive! Unfortunately I was not able to figure this out in a reasonable amount of time."
                    },
                    {
                        "username": "voodooism",
                        "content": "with this explanation the problem becomes easy!\\nthanks!"
                    },
                    {
                        "username": "rohitanjane999",
                        "content": "thanks for explanation...."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "And this marks my 200 days of streak..."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "So i\\'m not alone. [@sarpalmadhav](/sarpalmadhav)[@Ashutosh kumar](/ashurockzz) We started on jan1. Hope we complete our 365 days challenge."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ashu0123](/ashu0123) Congrats! Same here. I too have hit 200. We both started on Jan 1!!\\n"
                    },
                    {
                        "username": "ashu0123",
                        "content": "Looks like you\\'ve used Time travel tickets"
                    },
                    {
                        "username": "oops_moment",
                        "content": "If you\\'ve already cracked this challenging problem, kudos to you! If not, fret not! Let\\'s go step by step to find the perfect solution together! \\uD83D\\uDCAA\\n\\n\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F Problem Analysis:\\nWe\\'re given an array of intervals, and the goal is to find the minimum number of intervals to remove to make the rest non-overlapping. To achieve this, we\\'ll apply the greedy approach.\\n\\n\\u2B50 Greedy Insight:\\nLet\\'s try out a few greedy strategies. Say we select the interval with the smallest start time. Oops! This fails when the interval with the smallest start time also happens to be the longest one, leading to many overlapping intervals that need to be discarded.\\n\\n\\uD83D\\uDCA1 The Winning Greedy Strategy:\\nInstead, let\\'s sort the intervals based on their end times. Why? Imagine two intervals, one ending at x and the other ending at y (where x < y). If we skip the interval ending at x and take the one ending at y, we\\'ll may have to remove at least one interval that starts in the range (x, y). So, we should always sort based on the end time of intervals.\\n\\n\\uD83D\\uDEE0\\uFE0F Implementation:\\n\\n1: Sort the intervals based on their end times in ascending order.\\n\\n2: Initialize a variable \\'answer\\' to keep track of the number of intervals to be removed.\\n\\n3: Consider the first interval as \\'last\\' or the last taken interval.\\n\\n4: Iterate through the intervals, and for each interval:\\n\\n- If the current interval\\'s start time is less than the end time of the \\'last\\' interval, they overlap. Increment \\'answer\\' as we need to remove an interval to avoid overlap.\\n\\n- Otherwise, update \\'last\\' to the current interval.\\n\\n5: Return the final value of answer.\\n\\nNow you can confidently explain this solution to others and spread the joy of problem-solving! Happy coding! \\uD83D\\uDE80"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I don\\'t get why sorting by the end of the range helps.\\nI did\\n```\\nintervals.sort(key=lambda x: x[1])\\n```"
                    },
                    {
                        "username": "jkswapnil99",
                        "content": "Why is greedy solution correct for this problem. How do we know that, of all the ways in which intervals can be deleted the greedy approach is the optimal strategy?\\n\\nI always have trouble proving this for greedy solutions"
                    },
                    {
                        "username": "aLaN09",
                        "content": "[@bparanj](/bparanj) Nicely written"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The \"proof\" does not convince me for at least a two reasons:\\n\\n1) If there is an optimal solution different from ours, why must there an interval `i` with end time larger than ours?\\n2) We have no idea where `x` starts, how do we guarantee adding `x` after removing `i` won\\'t introduce conflicts?\\n\\nSince this is a classic problem - the proof is publicly available - all we needed is to do some search. For example, there is a one liner proof on wikipedia here. https://en.wikipedia.org/wiki/Interval_scheduling#Unweighted"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand your confusion. Proving the correctness of a greedy solution can often be tricky. For this particular problem, we could demonstrate the greedy choice property and optimal substructure, two key characteristics of problems that can be solved using a greedy approach.\\n\\nThe **greedy choice property** means that a local optimum can lead to a global optimum. For this problem, the local optimum is to always select the interval with the earliest end time that doesn\\'t overlap with the current one. This choice leaves as much space as possible for the remaining intervals. If we can prove that making the greedy choice at each step leads to the solution of the overall problem, then we\\'ve shown the greedy choice property.\\n\\nThe **optimal substructure** means that an optimal solution to the problem can be constructed efficiently from optimal solutions to its subproblems. In this problem, once we make the greedy choice of picking the interval with the earliest end time, we\\'re left with a smaller subproblem: finding the optimal solution in the remaining intervals.\\n\\nHere\\'s the intuition for why this greedy strategy works:\\n\\nThe crucial observation is that the interval with the earliest end time is least likely to overlap with other intervals. Hence, keeping this interval in our solution gives us the maximum space to accommodate the remaining intervals, which in turn reduces the number of removals. \\n\\nNow, let\\'s say there\\'s an optimal solution different from ours that keeps an interval `i` with an end time later than the one we chose (let\\'s call our interval `x`). We can replace `i` with `x` in this solution, and it\\'s guaranteed not to create more overlaps because `x` ends earlier than `i`. Therefore, the new solution is still optimal, showing that our greedy choice doesn\\'t lead to a worse solution.\\n\\nThis demonstrates that the greedy choice leads to an optimal solution and that the problem has an optimal substructure, thus validating our greedy solution."
                    },
                    {
                        "username": "abhay3141",
                        "content": "Getting Time limit Exceeded even though all 58/58 case passed. Any help ?"
                    },
                    {
                        "username": "jason3410",
                        "content": "You could just regard it as a regular TLE . It\\'s just a relatively closer one."
                    },
                    {
                        "username": "spookyflame",
                        "content": "[@cqrbala](/cqrbala) ty it worked. Forgot about that lmao"
                    },
                    {
                        "username": "cqrbala",
                        "content": "[@tanisha_daharwal](/tanisha_daharwal) [@Abhay](/abhay3141) Try to pass the vectors in the comparison function by reference (using & in c++). It is much faster as there is no need to make a copy of the vectors to perform the comparison."
                    },
                    {
                        "username": "tanisha_daharwal",
                        "content": "same thing happening with me"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Task failed successfully!"
                    },
                    {
                        "username": "ashu-xx",
                        "content": "[[1,100],[11,22],[1,11],[2,12]] \\nExpect: 2\\n\\nAccording to me expected answer should be 3 because [1,100] cannot be removed and all other 3 intervals are sub-intervals of [1,100].\\n\\nCan someone explain why is expected answer 2?"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "[@Ashutosh Mittal](/ashu-xx) in above case when we consider [1, 100] it will remove 3  other interval. but there a one option remain ie Consider [11,22] and [1, 11] than there is two inverval which are overlapping with these two [1,100] and [2,12] from the two option 3,  2, 2 option minimum so the result should be 2"
                    },
                    {
                        "username": "sasimouni",
                        "content": "[@bparanj](/bparanj)  nice explanation "
                    },
                    {
                        "username": "vermadeepesh248",
                        "content": "question said to remove minimum number of intervals. \\n\\nif we let [1,100] stay then we have to remove remaining three intervals.\\nbut instead if we remove [1,100] and [2,12] then we can let [1,11] and [11,22] stay. In this case we are removing only 2 intervals. so output should be 2."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@ShaliniMishra31](/ShaliniMishra31) [@ShaliniMishra31](/ShaliniMishra31) Your approach is not completely incorrect, but it\\'s not the most optimal one. In your solution, you are trying to represent the intervals on a number line and mark the occupied points. However, this approach has a couple of significant issues:\\n\\n1. It doesn\\'t consider the interval as a whole. Intervals are more than just individual points on a line, and their overlaps can\\'t always be accurately represented by the overlap of individual points.\\n\\n2. It doesn\\'t correctly account for the case when a smaller interval is entirely within a larger one. Your solution may consider the larger interval to be overlapping, even if removing the smaller one would make all intervals non-overlapping.\\n\\n3. Your solution has a time complexity of O(N^2), which is not efficient for large inputs.\\n\\nHere is an optimal solution using the greedy algorithm. It sorts the intervals by their end time and always tries to keep the one that ends earlier. This approach ensures we have more room for the remaining intervals.\\n\\nIn C++, it would look something like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 0) return 0;\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int ans = 0, end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i][0] < end){\\n                ans++;\\n            }\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution, we first sort the intervals by their end time. Then, we iterate over the sorted intervals. For each interval, if its start time is less than the end time of the previous interval, we increment our count (as it\\'s overlapping and needs to be removed). Otherwise, we update our end time to the current interval\\'s end time. This solution has a time complexity of O(N log N), which is more efficient."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected answer is 2 because the optimal solution doesn\\'t necessarily require keeping the interval [1,100]. It seems like you\\'re operating under the assumption that the larger interval has to be kept, but that\\'s not always the case.\\n\\nLet\\'s examine the problem with the given list of intervals:\\n\\n[[1,100],[11,22],[1,11],[2,12]]\\n\\nA key point to remember is that the objective is to minimize the number of removals so as to make the remaining intervals non-overlapping. To achieve this, the optimal strategy involves removing the intervals that cause the most overlaps. In this case, interval [1,100] overlaps with all other intervals, so if we keep it, we\\'d need to remove all other intervals, which is not optimal.\\n\\nInstead, if we remove [1,100], we\\'re left with:\\n\\n[[11,22],[1,11],[2,12]]\\n\\nOut of these, [1,11] and [11,22] don\\'t overlap. However, [2,12] overlaps with both. Thus, we can remove [2,12] to make the remaining intervals non-overlapping. This way, we only need to remove 2 intervals ([1,100] and [2,12]), which is why the expected answer is 2."
                    },
                    {
                        "username": "ShaliniMishra31",
                        "content": "[@cpblnc](/cpblnc) Could you explain again?\nI have the same doubt \n\nHere is my solution:\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        vector <pair<int,int>> vec(100000, {0,0});\n        int ans = 0;\n        for(int i=0;i<intervals.size();i++)\n        {\n            int f = intervals[i][0];\n            int s = intervals[i][1];\n            int dif = s-f;\n            int c = 0;\n            for(int j=f;j<=s;j++)\n            {\n                if(vec[j].second != 1)\n                {\n                    vec[j].first = j;\n                    vec[j].second = 1;\n                }\n                else\n                {\n                    c++;\n                }\n            }\n            if(c > dif)\n            {\n                ans++;\n            }\n        }\n        return(ans);\n    }\n};\n"
                    },
                    {
                        "username": "cpblnc",
                        "content": "Why can\\'t [1,100] be removed? If you remove it and [2,12] as well, you are left with [1,11] and [11,22], which are non overlapping - 2 intervals got removed, as expected."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Sort & Greedy make people happy!"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After I saw this problem, My first thought was to use `Binary Search` with `DP` and solved it."
                    },
                    {
                        "username": "sunny8080",
                        "content": "[@ashish15678](/ashish15678) For every index, find next non-overlapping intervel using `Binary Search`. \\nFor more, just take a look at [My Solution](https://leetcode.com/problems/non-overlapping-intervals/solutions/3788241/c-java-easy-and-clean-code-dp-greedy-beats/)"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@ashish15678](/ashish15678)  u can see my soln, i also did it using DP and Binary Search. \\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/solutions/3789308/dp-binary-search-solution/"
                    },
                    {
                        "username": "ashish15678",
                        "content": "can you please explain more\\n"
                    },
                    {
                        "username": "user4653c",
                        "content": "Labeling this problem as Dynamic Programming is a bit of a nasty move. To solve it, you need to find the right intuition, attempting the DP approach will just make things more confusing"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@Charlemagne5t](/Charlemagne5t) well true it can be difficult, trying joting down all possible scenarios and see if your greedy (or any other) approach works, if it does then try to find a justification for it, sometimes u may pass the question by implementing a approach but can\\'t think of a proof of it, can happen if the proof is mathematically rigorous "
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Agreed. Tried straight forward recursion + caching and got TLE 54/58. What I like about this approach it guarantees the right answer. Greedy is more optimal solution, but how do I prove it in real world problems when I don\\'t have rich test cases sample. I need to improve my knowledge in that field I guess. "
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "It's easy to think that:\\n- If we count the overlapping times with each interval. \\n- Then, for each time we remove the interval with most overlapping interval(let's call it A)\\n- And we update the other intervals' overlapping time which is overlapped with A.\\n- When all interval has zero overlapping times, we get the result.\\n\\nI know how to do it in greedy in O(nlgn) time, but I wonder why this cant work... \\nThis idea failed in the last test case(that with 10k inputs).I can't figure out why... Can someone help me?please...?\\nThanks your time for seeing these. Thank you~"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@nsut_coder](/nsut_coder) It would still not work if we remove all duplicates. Consider the same example, but add small random fractional values to each start and end. No duplicates, but the answer remains the same,"
                    },
                    {
                        "username": "bparanj",
                        "content": "The strategy you described is known as the \"interval graph coloring\" problem and it\\'s not equivalent to the interval scheduling problem we are solving here. You are describing an approach in which we try to color intervals (remove as few as possible) such that no two overlapping intervals share the same color. That is a more complicated problem and is not what we are trying to solve here.\\n\\nYou are trying to remove the interval that has the most overlaps first. This approach does not always lead to the optimal solution. Consider the following example:\\n\\n[[1, 5], [2, 3], [3, 4], [4, 5]]\\n\\nIf we follow your approach, we\\'ll remove [1, 5] first, because it overlaps with the most intervals. But this leads to the need of removing 1 interval, while the optimal solution would be to remove none. If we select [2, 3], [3, 4], [4, 5], we can see that none of these intervals overlap, which leads to the optimal solution of 0 removals.\\n\\nThis shows why the greedy algorithm of always choosing the interval that ends the earliest works: it leaves the most room for the rest of the intervals to not overlap.\\n\\nSo the intuition for the greedy algorithm in this problem is: the sooner an interval ends, the more room we have for the rest of the intervals to fit in without overlapping. It\\'s about looking ahead and trying to leave as much room as possible for the future intervals."
                    },
                    {
                        "username": "nsut_coder",
                        "content": "[@bharathi1121](/bharathi1121) I think, algorithm would work if we remove the duplicate ranges. but how would algorithm decide which interval to remove when all of them are overlapping with same number of intervals. "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "It doesnt work because its not always the largest overlapping interval to be removed first,\\nex: [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]\\nin this example the largest overlapping interval is [2,4] but it is part of the answer."
                    }
                ]
            },
            {
                "id": 1571704,
                "content": [
                    {
                        "username": "ZimmAgu",
                        "content": "#### Initial Steps\\n* Sort the given intervals based on starting points\\n* While considering the intervals in the ascending order of starting points\\n\\t* we make use of a pointer prev pointer \\n\\t* to keep track of the interval just included in the final list\\n![image](https://assets.leetcode.com/users/images/515fa83b-44c2-4c42-8ef5-d41c7942ec32_1653774876.169032.jpeg)\\n\\n\\n\\n#### Case 1\\n* You don\\'t need to remove any intervals\\n* Continue by simply assigning the *prev* pointer to the later interval\\n* The count of intervals removed remains unchanged\\n\\n\\n#### Case 2\\n* Remove the interval with the later end point \\n* The *prev* pointer is updated to current interval\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Case 3\\n* Remove the interval with the later end point \\n* The *prev* pointer remains unchanged\\n* count of intervals removed is incremented by 1\\n\\n\\n#### Rule of Thumb\\n* Always choose the interval that ends first\\n\\n"
                    },
                    {
                        "username": "Muhammadamin",
                        "content": "[@rohitanjane999](/rohitanjane999)  + "
                    },
                    {
                        "username": "MayuD",
                        "content": "Thank you\nThe second case had got me"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "That was really good...thanks"
                    },
                    {
                        "username": "0x415374",
                        "content": "Pretty intuitive! Unfortunately I was not able to figure this out in a reasonable amount of time."
                    },
                    {
                        "username": "voodooism",
                        "content": "with this explanation the problem becomes easy!\\nthanks!"
                    },
                    {
                        "username": "rohitanjane999",
                        "content": "thanks for explanation...."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "And this marks my 200 days of streak..."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "So i\\'m not alone. [@sarpalmadhav](/sarpalmadhav)[@Ashutosh kumar](/ashurockzz) We started on jan1. Hope we complete our 365 days challenge."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ashu0123](/ashu0123) Congrats! Same here. I too have hit 200. We both started on Jan 1!!\\n"
                    },
                    {
                        "username": "ashu0123",
                        "content": "Looks like you\\'ve used Time travel tickets"
                    },
                    {
                        "username": "oops_moment",
                        "content": "If you\\'ve already cracked this challenging problem, kudos to you! If not, fret not! Let\\'s go step by step to find the perfect solution together! \\uD83D\\uDCAA\\n\\n\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F Problem Analysis:\\nWe\\'re given an array of intervals, and the goal is to find the minimum number of intervals to remove to make the rest non-overlapping. To achieve this, we\\'ll apply the greedy approach.\\n\\n\\u2B50 Greedy Insight:\\nLet\\'s try out a few greedy strategies. Say we select the interval with the smallest start time. Oops! This fails when the interval with the smallest start time also happens to be the longest one, leading to many overlapping intervals that need to be discarded.\\n\\n\\uD83D\\uDCA1 The Winning Greedy Strategy:\\nInstead, let\\'s sort the intervals based on their end times. Why? Imagine two intervals, one ending at x and the other ending at y (where x < y). If we skip the interval ending at x and take the one ending at y, we\\'ll may have to remove at least one interval that starts in the range (x, y). So, we should always sort based on the end time of intervals.\\n\\n\\uD83D\\uDEE0\\uFE0F Implementation:\\n\\n1: Sort the intervals based on their end times in ascending order.\\n\\n2: Initialize a variable \\'answer\\' to keep track of the number of intervals to be removed.\\n\\n3: Consider the first interval as \\'last\\' or the last taken interval.\\n\\n4: Iterate through the intervals, and for each interval:\\n\\n- If the current interval\\'s start time is less than the end time of the \\'last\\' interval, they overlap. Increment \\'answer\\' as we need to remove an interval to avoid overlap.\\n\\n- Otherwise, update \\'last\\' to the current interval.\\n\\n5: Return the final value of answer.\\n\\nNow you can confidently explain this solution to others and spread the joy of problem-solving! Happy coding! \\uD83D\\uDE80"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I don\\'t get why sorting by the end of the range helps.\\nI did\\n```\\nintervals.sort(key=lambda x: x[1])\\n```"
                    },
                    {
                        "username": "jkswapnil99",
                        "content": "Why is greedy solution correct for this problem. How do we know that, of all the ways in which intervals can be deleted the greedy approach is the optimal strategy?\\n\\nI always have trouble proving this for greedy solutions"
                    },
                    {
                        "username": "aLaN09",
                        "content": "[@bparanj](/bparanj) Nicely written"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The \"proof\" does not convince me for at least a two reasons:\\n\\n1) If there is an optimal solution different from ours, why must there an interval `i` with end time larger than ours?\\n2) We have no idea where `x` starts, how do we guarantee adding `x` after removing `i` won\\'t introduce conflicts?\\n\\nSince this is a classic problem - the proof is publicly available - all we needed is to do some search. For example, there is a one liner proof on wikipedia here. https://en.wikipedia.org/wiki/Interval_scheduling#Unweighted"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand your confusion. Proving the correctness of a greedy solution can often be tricky. For this particular problem, we could demonstrate the greedy choice property and optimal substructure, two key characteristics of problems that can be solved using a greedy approach.\\n\\nThe **greedy choice property** means that a local optimum can lead to a global optimum. For this problem, the local optimum is to always select the interval with the earliest end time that doesn\\'t overlap with the current one. This choice leaves as much space as possible for the remaining intervals. If we can prove that making the greedy choice at each step leads to the solution of the overall problem, then we\\'ve shown the greedy choice property.\\n\\nThe **optimal substructure** means that an optimal solution to the problem can be constructed efficiently from optimal solutions to its subproblems. In this problem, once we make the greedy choice of picking the interval with the earliest end time, we\\'re left with a smaller subproblem: finding the optimal solution in the remaining intervals.\\n\\nHere\\'s the intuition for why this greedy strategy works:\\n\\nThe crucial observation is that the interval with the earliest end time is least likely to overlap with other intervals. Hence, keeping this interval in our solution gives us the maximum space to accommodate the remaining intervals, which in turn reduces the number of removals. \\n\\nNow, let\\'s say there\\'s an optimal solution different from ours that keeps an interval `i` with an end time later than the one we chose (let\\'s call our interval `x`). We can replace `i` with `x` in this solution, and it\\'s guaranteed not to create more overlaps because `x` ends earlier than `i`. Therefore, the new solution is still optimal, showing that our greedy choice doesn\\'t lead to a worse solution.\\n\\nThis demonstrates that the greedy choice leads to an optimal solution and that the problem has an optimal substructure, thus validating our greedy solution."
                    },
                    {
                        "username": "abhay3141",
                        "content": "Getting Time limit Exceeded even though all 58/58 case passed. Any help ?"
                    },
                    {
                        "username": "jason3410",
                        "content": "You could just regard it as a regular TLE . It\\'s just a relatively closer one."
                    },
                    {
                        "username": "spookyflame",
                        "content": "[@cqrbala](/cqrbala) ty it worked. Forgot about that lmao"
                    },
                    {
                        "username": "cqrbala",
                        "content": "[@tanisha_daharwal](/tanisha_daharwal) [@Abhay](/abhay3141) Try to pass the vectors in the comparison function by reference (using & in c++). It is much faster as there is no need to make a copy of the vectors to perform the comparison."
                    },
                    {
                        "username": "tanisha_daharwal",
                        "content": "same thing happening with me"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Task failed successfully!"
                    },
                    {
                        "username": "ashu-xx",
                        "content": "[[1,100],[11,22],[1,11],[2,12]] \\nExpect: 2\\n\\nAccording to me expected answer should be 3 because [1,100] cannot be removed and all other 3 intervals are sub-intervals of [1,100].\\n\\nCan someone explain why is expected answer 2?"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "[@Ashutosh Mittal](/ashu-xx) in above case when we consider [1, 100] it will remove 3  other interval. but there a one option remain ie Consider [11,22] and [1, 11] than there is two inverval which are overlapping with these two [1,100] and [2,12] from the two option 3,  2, 2 option minimum so the result should be 2"
                    },
                    {
                        "username": "sasimouni",
                        "content": "[@bparanj](/bparanj)  nice explanation "
                    },
                    {
                        "username": "vermadeepesh248",
                        "content": "question said to remove minimum number of intervals. \\n\\nif we let [1,100] stay then we have to remove remaining three intervals.\\nbut instead if we remove [1,100] and [2,12] then we can let [1,11] and [11,22] stay. In this case we are removing only 2 intervals. so output should be 2."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@ShaliniMishra31](/ShaliniMishra31) [@ShaliniMishra31](/ShaliniMishra31) Your approach is not completely incorrect, but it\\'s not the most optimal one. In your solution, you are trying to represent the intervals on a number line and mark the occupied points. However, this approach has a couple of significant issues:\\n\\n1. It doesn\\'t consider the interval as a whole. Intervals are more than just individual points on a line, and their overlaps can\\'t always be accurately represented by the overlap of individual points.\\n\\n2. It doesn\\'t correctly account for the case when a smaller interval is entirely within a larger one. Your solution may consider the larger interval to be overlapping, even if removing the smaller one would make all intervals non-overlapping.\\n\\n3. Your solution has a time complexity of O(N^2), which is not efficient for large inputs.\\n\\nHere is an optimal solution using the greedy algorithm. It sorts the intervals by their end time and always tries to keep the one that ends earlier. This approach ensures we have more room for the remaining intervals.\\n\\nIn C++, it would look something like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    \\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 0) return 0;\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        int ans = 0, end = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i][0] < end){\\n                ans++;\\n            }\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution, we first sort the intervals by their end time. Then, we iterate over the sorted intervals. For each interval, if its start time is less than the end time of the previous interval, we increment our count (as it\\'s overlapping and needs to be removed). Otherwise, we update our end time to the current interval\\'s end time. This solution has a time complexity of O(N log N), which is more efficient."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected answer is 2 because the optimal solution doesn\\'t necessarily require keeping the interval [1,100]. It seems like you\\'re operating under the assumption that the larger interval has to be kept, but that\\'s not always the case.\\n\\nLet\\'s examine the problem with the given list of intervals:\\n\\n[[1,100],[11,22],[1,11],[2,12]]\\n\\nA key point to remember is that the objective is to minimize the number of removals so as to make the remaining intervals non-overlapping. To achieve this, the optimal strategy involves removing the intervals that cause the most overlaps. In this case, interval [1,100] overlaps with all other intervals, so if we keep it, we\\'d need to remove all other intervals, which is not optimal.\\n\\nInstead, if we remove [1,100], we\\'re left with:\\n\\n[[11,22],[1,11],[2,12]]\\n\\nOut of these, [1,11] and [11,22] don\\'t overlap. However, [2,12] overlaps with both. Thus, we can remove [2,12] to make the remaining intervals non-overlapping. This way, we only need to remove 2 intervals ([1,100] and [2,12]), which is why the expected answer is 2."
                    },
                    {
                        "username": "ShaliniMishra31",
                        "content": "[@cpblnc](/cpblnc) Could you explain again?\nI have the same doubt \n\nHere is my solution:\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        vector <pair<int,int>> vec(100000, {0,0});\n        int ans = 0;\n        for(int i=0;i<intervals.size();i++)\n        {\n            int f = intervals[i][0];\n            int s = intervals[i][1];\n            int dif = s-f;\n            int c = 0;\n            for(int j=f;j<=s;j++)\n            {\n                if(vec[j].second != 1)\n                {\n                    vec[j].first = j;\n                    vec[j].second = 1;\n                }\n                else\n                {\n                    c++;\n                }\n            }\n            if(c > dif)\n            {\n                ans++;\n            }\n        }\n        return(ans);\n    }\n};\n"
                    },
                    {
                        "username": "cpblnc",
                        "content": "Why can\\'t [1,100] be removed? If you remove it and [2,12] as well, you are left with [1,11] and [11,22], which are non overlapping - 2 intervals got removed, as expected."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Sort & Greedy make people happy!"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After I saw this problem, My first thought was to use `Binary Search` with `DP` and solved it."
                    },
                    {
                        "username": "sunny8080",
                        "content": "[@ashish15678](/ashish15678) For every index, find next non-overlapping intervel using `Binary Search`. \\nFor more, just take a look at [My Solution](https://leetcode.com/problems/non-overlapping-intervals/solutions/3788241/c-java-easy-and-clean-code-dp-greedy-beats/)"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@ashish15678](/ashish15678)  u can see my soln, i also did it using DP and Binary Search. \\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/solutions/3789308/dp-binary-search-solution/"
                    },
                    {
                        "username": "ashish15678",
                        "content": "can you please explain more\\n"
                    },
                    {
                        "username": "user4653c",
                        "content": "Labeling this problem as Dynamic Programming is a bit of a nasty move. To solve it, you need to find the right intuition, attempting the DP approach will just make things more confusing"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@Charlemagne5t](/Charlemagne5t) well true it can be difficult, trying joting down all possible scenarios and see if your greedy (or any other) approach works, if it does then try to find a justification for it, sometimes u may pass the question by implementing a approach but can\\'t think of a proof of it, can happen if the proof is mathematically rigorous "
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Agreed. Tried straight forward recursion + caching and got TLE 54/58. What I like about this approach it guarantees the right answer. Greedy is more optimal solution, but how do I prove it in real world problems when I don\\'t have rich test cases sample. I need to improve my knowledge in that field I guess. "
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "It's easy to think that:\\n- If we count the overlapping times with each interval. \\n- Then, for each time we remove the interval with most overlapping interval(let's call it A)\\n- And we update the other intervals' overlapping time which is overlapped with A.\\n- When all interval has zero overlapping times, we get the result.\\n\\nI know how to do it in greedy in O(nlgn) time, but I wonder why this cant work... \\nThis idea failed in the last test case(that with 10k inputs).I can't figure out why... Can someone help me?please...?\\nThanks your time for seeing these. Thank you~"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@nsut_coder](/nsut_coder) It would still not work if we remove all duplicates. Consider the same example, but add small random fractional values to each start and end. No duplicates, but the answer remains the same,"
                    },
                    {
                        "username": "bparanj",
                        "content": "The strategy you described is known as the \"interval graph coloring\" problem and it\\'s not equivalent to the interval scheduling problem we are solving here. You are describing an approach in which we try to color intervals (remove as few as possible) such that no two overlapping intervals share the same color. That is a more complicated problem and is not what we are trying to solve here.\\n\\nYou are trying to remove the interval that has the most overlaps first. This approach does not always lead to the optimal solution. Consider the following example:\\n\\n[[1, 5], [2, 3], [3, 4], [4, 5]]\\n\\nIf we follow your approach, we\\'ll remove [1, 5] first, because it overlaps with the most intervals. But this leads to the need of removing 1 interval, while the optimal solution would be to remove none. If we select [2, 3], [3, 4], [4, 5], we can see that none of these intervals overlap, which leads to the optimal solution of 0 removals.\\n\\nThis shows why the greedy algorithm of always choosing the interval that ends the earliest works: it leaves the most room for the rest of the intervals to not overlap.\\n\\nSo the intuition for the greedy algorithm in this problem is: the sooner an interval ends, the more room we have for the rest of the intervals to fit in without overlapping. It\\'s about looking ahead and trying to leave as much room as possible for the future intervals."
                    },
                    {
                        "username": "nsut_coder",
                        "content": "[@bharathi1121](/bharathi1121) I think, algorithm would work if we remove the duplicate ranges. but how would algorithm decide which interval to remove when all of them are overlapping with same number of intervals. "
                    },
                    {
                        "username": "bharathi1121",
                        "content": "It doesnt work because its not always the largest overlapping interval to be removed first,\\nex: [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]\\nin this example the largest overlapping interval is [2,4] but it is part of the answer."
                    }
                ]
            },
            {
                "id": 1719087,
                "content": [
                    {
                        "username": "subz3r0",
                        "content": "Getting **TLE** for this. **HELP**\\n```\\nclass Solution {\\nprivate:\\n    static bool cmp (vector<int> a, vector<int> b) {\\n        return a[0] < b[0];\\n    }\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        int prevEnd = INT_MIN;\\n        int res = 0;\\n        for (vector<int> interval: intervals) {\\n            if (interval[0] >= prevEnd) {\\n                // no overlap\\n                prevEnd = interval[1];\\n            }\\n            else {\\n                // overlap\\n                res++;\\n                prevEnd = min(prevEnd, interval[1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "OP101202",
                        "content": "[@asahoo27](/asahoo27) without cmp it won\\'t work , it is must."
                    },
                    {
                        "username": "asahoo27",
                        "content": "``` sort(intervals.begin(),intervals.end());```  just use this no need of cmp"
                    },
                    {
                        "username": "saisantosh3007",
                        "content": "[@1111aakansharao](/1111aakansharao) Thank you for this"
                    },
                    {
                        "username": "1111aakansharao",
                        "content": "your cmp function containg parameters as vectors, you need to pass it by reference beacause by value it will take a longer time and changes will not be reflected.\\n```\\nstatic bool cmp (vector<int>&a, vector<int>&b) {\\n        return a[0] < b[0];\\n    }\\n```\\nHope this helps you !\\nKeep hustlin :)"
                    },
                    {
                        "username": "Aiyaz123",
                        "content": "Thats the great solution tbh, easy and simple to understand.. "
                    },
                    {
                        "username": "Gaurav_Upreti",
                        "content": "Use pass by reference in cmp function, i.e. cmp(vector<int> &a, vector<int> &b)."
                    },
                    {
                        "username": "subz3r0",
                        "content": "I\\'m not sure why but the compare function was causing the TLE !! -_- "
                    },
                    {
                        "username": "rishavjain",
                        "content": "Time Limit Exceeded\\n58 / 58 testcases passed\\n?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Just regard it as a regular TLE ."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "show your code \nstatic bool cmp (vector<int>&a, vector<int>&b) {\n        return a[0] < b[0];\n    }\nhere a lot of ppl didnt pass the vector by reference are getting the same error as you perhaps that is the issue in your code"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So I\\'ve looked at an *awful lot* of solutions but nobody explains why their solution can be relied on to remove the minimum number of intervals. My first solution didn\\'t. I assume all the posted solutions do but after 5 pages of them I gave up hoping that somebody would explain how they met that part of the spec. Does anybody here have a solution where they know why it removes the minimum number of intervals? Can they explain why? Can ANYONE explain why?"
                    },
                    {
                        "username": "jfitzg7",
                        "content": "It helped me to visualize it by organizing intervals with the same end dates (sorted in ascending order) into groups. In the best case, if there is at least one interval in each group that doesn\\'t overlap with the previous group, you will be able to pick one interval from each group and discard the rest. It helps to look at the cases when there are 1 groups, 2 groups, 3 groups, etc.\\n\\n1 group: You can only pick 1 interval from the first group.\\n\\n2 groups: If all the intervals in the second group overlap with the first groups end date, then we will only be able to pick 1 interval. If only some (or none) overlapped, then we would be able to pick 2 intervals, one from the first group and another from the second group. But it\\'s not yet clear why we should be greedy.\\n\\n3 groups: Let\\'s say all the intervals in the second group overlap with the first group so that we would only be able to pick a single interval from one or the other, but which group do we pick from? If we pick from the second group instead of the first group, then this becomes a problem when all of the intervals in the third group overlap the second group (and maybe some overlap the first, but not all). If we had picked from the first group, then we would have been able to pick from the third group as well. If some or none of the intervals in the second group overlap the first, then we would greedily pick from the second group and it basically gets boiled down into the 2 groups case when dealing with the third group.\\n\\nIt gets complicated when looking at examples with more groups and thinking of all the cases, but hopefully this is a good starting point and can help give a different perspective. I think why this problem is so hard is that there are many cases to consider, and I needed to use this idea of grouping the intervals together just to make sense of why the greedy approach works."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, I can explain why the greedy algorithm that chooses to keep intervals with the earliest end time will remove the minimum number of intervals. This is a result of how the greedy strategy prioritizes creating the maximum room for the remaining intervals, which minimizes the number of intervals that have to be removed.\\n\\nThe key here is that if you have two overlapping intervals, keeping the one that ends earliest will leave more room for the remaining intervals. \\n\\nConsider two overlapping intervals, interval A and interval B, where A ends before B. \\n\\n```\\nA: |------|\\nB:     |---------|\\n```\\nIf you keep interval B, any subsequent interval cannot start until after B ends. But if you keep A, subsequent intervals can start right after A ends, providing more room for other intervals. Therefore, keeping A, the interval with the earliest end time, will allow us to fit in the most intervals, thereby minimizing the number we need to remove.\\n\\nTo generalize, we sort all intervals by end time, then iterate through the sorted list. We always keep the interval with the earliest end time among all overlapping intervals, and remove the others. By doing so, we can ensure that we\\'ve made the most room for the remaining intervals, thereby minimizing the number of intervals we need to remove.\\n\\nThis strategy satisfies the problem\\'s requirement of removing the minimum number of intervals because we\\'re always maximizing the space for the remaining intervals at each step, which is the key to minimizing removals."
                    },
                    {
                        "username": "shakthi4526",
                        "content": "Removing minimum number of intervals is the same as KEEPING maximum number of intervals. \\n\\nNow, if you look at it as scheduling maximum number of meetings in a room, then you should get it.\\nFor those unfamiliar with the Meeting scheduling problem, it is similar to this problem here, but each interval [start,end] represents the start and end time of a meeting. As there is only one room and we can have only one meeting at a time, we want to find maximum number of meetings we can schedule (in other words reject minimum number of meetings).\\n\\nAgain we sort by end times. Why? Because regardless of when a meeting starts, a meeting that ends first leaves more time for other meetings to take place. We do not want a meeting that starts early and ends late, what we really care about is when the meeting ends and how much time it leaves for the other meetings. So, sort by endtimes, remove all overlapping meetings to get maximum meetings or reject minimum meetings. Same logic applies here in this problem."
                    },
                    {
                        "username": "magicsign",
                        "content": "You can understand the solution by visualizing the intervals as lines. The key first of all is sorting the intervals by their ending point. For example say you have: [1,11],[2,12],[11,22],[1,100] , notice all intervals are sorted in ascending order based on their ending point.\\n\\nNow if you keep 2 pointers, prev and curr and a counter, prev gets initialized to [1,11], curr to [2,12]. 11 > 2 so it means that the interval [1,11] overlaps [2,12], we can remove [2,12] and in our case we increment our counter by one.\\nprev is [1,11], curr is [11,22], 11 > 11 no, so no overlapping. We need to move prev pointer to [11,22] to perform the next comparisons because we know that the previous intervals are non overlapping.\\n\\nprev is [11,22], curr is [1,100], 22 > 1, yes, we remove [1,100] or in another words, increment our counter. We reached the end with counter set to 2. "
                    },
                    {
                        "username": "lcgt",
                        "content": "I cant seem to think of a case where removing the latter interval is a bad idea, but it is a source of uncertainty."
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s consider a scenario where you might be tempted to remove a later interval, but it\\'s actually not the best move. Take a look at these intervals:\\n\\n```\\n[[1,10],[2,3],[4,5],[6,7],[8,9]]\\n```\\n\\nIn this case, interval [1,10] overlaps with all other intervals. Now, you might think to remove a later interval, say [8,9], because it\\'s later and removing it seems like it would minimize the overlaps.\\n\\nBut removing any of [2,3],[4,5],[6,7],[8,9] won\\'t solve the problem because they are not the root cause of the overlaps. The real issue is with the [1,10] interval, because it overlaps with all others. If you remove [1,10], you\\'ll only have to remove one interval and none of the remaining intervals overlap.\\n\\nThis illustrates that sometimes the best move is to remove an interval that isn\\'t necessarily the latest one, but the one that causes the most overlaps. It\\'s why the strategy of always removing the interval with the latest end time works \\u2013 it maximizes the room for other intervals and decreases the chances of overlaps."
                    },
                    {
                        "username": "ajv97",
                        "content": "Think this array as a list of start and end times of your favourite movies in a theatre where you can watch anything for free for that day.(you never get tired and you can teleport-only after the movie ends)\\nNow wouldn\\'t you be GREEDY and try to watch the maximum amount of movies.\\nBut you would also want the movie list to be SORTED by end time to get a better overview."
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can start by considering intervals in some \"natural\" order.\\n1. Earliest start time\\n![image.png](https://assets.leetcode.com/users/images/9ae02534-c9af-4239-b5f6-e1bdd43feaa0_1684388688.0637023.png)\\n2. Earliest finish time\\n3. Shortest interval\\n![image.png](https://assets.leetcode.com/users/images/70407e84-c791-40da-9e62-c2b4506ef72d_1684388702.40602.png)\\n4. Fewest conflicts\\n![image.png](https://assets.leetcode.com/users/images/e70553be-2b51-4c03-804b-0c6939de7391_1684388714.3131933.png)\\nWe found some counterexamples for 1, 2 and 4.\\nNow let\\'s prove why greedy with EFT works.\\n# Proof of optimality by contradiction\\n- Suppose for contradiction that greedy is not optimal\\n- Say greedy selects interval `\\uD835\\uDC561, \\uD835\\uDC562, \\u2026 , \\uD835\\uDC56\\uD835\\uDC58` sorted by finish time\\n- Consider an optimal solution `\\uD835\\uDC571,\\uD835\\uDC572, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5A` (also sorted by finish time) which matches greedy for as many indices as possible\\n    - That is, we want `\\uD835\\uDC571 = \\uD835\\uDC561, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5F = \\uD835\\uDC56\\uD835\\uDC5F` for the greatest possible `\\uD835\\uDC5F`\\n- Both `\\uD835\\uDC56\\uD835\\uDC5F+1` and `\\uD835\\uDC57\\uD835\\uDC5F+1` must be compatible with the previous selection\\n`(\\uD835\\uDC561 = \\uD835\\uDC571, \\u2026 , \\uD835\\uDC56\\uD835\\uDC5F = \\uD835\\uDC57\\uD835\\uDC5F)`\\n- Consider a new solution `\\uD835\\uDC561, \\uD835\\uDC562, \\u2026 , \\uD835\\uDC56\\uD835\\uDC5F, \\uD835\\uDC56\\uD835\\uDC5F+1,\\uD835\\uDC57\\uD835\\uDC5F+2, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5A`\\n- We have replaced `\\uD835\\uDC57\\uD835\\uDC5F+1` by `\\uD835\\uDC56\\uD835\\uDC5F+1` in our reference optimal solution\\n- This is still feasible because `\\uD835\\uDC53\\uD835\\uDC56\\uD835\\uDC5F+1 \\u2264 \\uD835\\uDC53\\uD835\\uDC57\\uD835\\uDC5F+1 \\u2264 \\uD835\\uDC60\\uD835\\uDC57\\uD835\\uDC61`\\nfor `\\uD835\\uDC61 \\u2265 \\uD835\\uDC5F + 2` where `\\uD835\\uDC53\\uD835\\uDC56` is the finish time for interval `i`.\\n- This is still optimal because `\\uD835\\uDC5A` intervals are selected.\\n- But it matches the greedy solution in \\uD835\\uDC5F + 1 indices\\n    - This is the desired contradiction\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort intervals by finish time.\\n2. For each interval `j` we check if it\\'s compatible with the last added interval `i`. If not, increase `res` and `j`, otherwise increate `i` and `j`. "
                    },
                    {
                        "username": "Leaderboard",
                        "content": "> We found some counterexamples for 1, 2 and 4.\\n\\nShould it not be \"1, 3 and 4\"?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "So many of you comment like I\\'m reading ChatGPT. You may have a proper solution but its improperly explained with holes and leaps in the logic or its just flat out word salad with no meaning.\\n\\nYou can basically boil this down to sorting by start position and greedily picking the intervals that end first. This is optimal precisely because given some starting position (suppose you consider only the intervals with starts after some $$X$$, in practice $$X$$ is the end of the last chosen interval). Then you should always pick the next interval which ends first, call it interval $$F$$\\n\\nThe proof is simple, suppose the interval $$F$$  isn\\'t part of the optimal choices, then that means that there is some interval, $$Q$$, which overlaps it you should pick instead  that gives you better choices later on somehow. However picking $$Q$$ can be no better than picking $$F$$ because you could always copy remaining ones after $$Q$$ even if you picked $$F$$ because we assumed $$F$$ is the one that ends first."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@cecilia5](/cecilia5) I didn\\'t not provide the complete proof because I wanted to leave some minor details as an exercise to the reader.\\n\\nHowever the details are that $$F$$ is assumed not to be a trivial choice, I.E it must be overlapping something else. \\n\\nIf it doesn\\'t overlap anything you must always include it because you are maximizing intervals. This removes the possibility that $$Q$$ doesn\\'t overlap.\\n\\nSecondly because $$F$$ is assumed to end first, then there cannot be anything before it. The endpoints of other intervals are at or after it. So there cannot be these theoretical intervals that are choosable before it that don\\'t overlap with $$Q$$. "
                    },
                    {
                        "username": "cecilia5",
                        "content": "There are a few things I nit picked from your comment. It is not meant to say you have a problem, please take that as an opportunity for you to improve your writing:\\n\\nThis is optimal precisely because [...], but the [...] doesn\\'t explain why it is optimal, it just describe the algorithm, and it isn\\'t complete (it doesn\\'t talk about skipping the conflicting ones, which is probably obvious \"to you\")\\n\\nFor the proof itself:\\n\\nI rather you not say the proof is simple - people looking for proofs find it hard - that\\'s why they are looking for it.\\n\\nYou didn\\'t explain why if `F` is not part of the optimal choice, then there exists `Q` that overlaps with it.\\n\\nYou also didn\\'t show why copy the remaining after `Q` is enough, what if the optimal solution including `Q` can include a lot more intervals before `Q`?\\n\\nYour idea is right on, and your proof could be polished to become a flawless one, you just need to:\\n\\n1.) See it from the adversary angle - what could someone argue about your proof, and how you plug those holes so that you answer the question before it happens, and\\n2.) See it from the learner\\'s angle - some facts could be obvious to you, but not the reader.\\n\\nI hope that helps you."
                    },
                    {
                        "username": "niraj243",
                        "content": "Can somenone explain why my solution is giving Runtime error  \n\"Line 1034: Char 34: runtime error: applying non-zero offset 4 to null pointer (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\"\nBut when I change  `return (v1[1] <= v2[1]);` to `return (v1[1] < v2[1]);` in cmp function. It works, but why ??\n```cpp\nclass Solution {\npublic:\n    static bool cmp(vector<int> &v1,vector<int> &v2){\n        // return (v1[1] <= v2[1]); // gives error why ??\n        return (v1[1] < v2[1]);\n    }\n    bool isok(vector<int> i1,vector<int> i2){\n        return (i1[1]<=i2[0] || i1[0]>=i2[1]);\n    }\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        int n = intervals.size();\n        sort(intervals.begin(),intervals.end(),cmp);\n        vector<int> end(n);\n        for(int i=0;i<n;i++){\n            end[i] = intervals[i][1];\n        }\n        int ans=1;\n        vector<int> dp(n,1);\n        for(int i=1;i<n;i++){\n            int mx = 0;\n            int prev_ok = upper_bound(end.begin(),end.end(),intervals[i][0])-end.begin()-1;\n            if(prev_ok>=0)\n            mx = dp[prev_ok];\n            dp[i] = max(dp[i-1],mx+1);\n            ans = max(ans,dp[i]);\n        }\n        return n-ans;\n    }\n};\n```  "
                    },
                    {
                        "username": "AndreiZherder",
                        "content": "If you think about DP solution, it is very similar to problem we solved four days ago:\\n[1751. Maximum number of events that can be attended II](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/)\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "Sort the intervals based on their ending point and track the last relevant interval (i) and comp the curr index\\'s 0th point with tracked (i)\\'s 1st point and if it less then increase ans++ (skip this interval) otherwise we have to consider this and assign your track index to this index"
                    }
                ]
            },
            {
                "id": 1976520,
                "content": [
                    {
                        "username": "subz3r0",
                        "content": "Getting **TLE** for this. **HELP**\\n```\\nclass Solution {\\nprivate:\\n    static bool cmp (vector<int> a, vector<int> b) {\\n        return a[0] < b[0];\\n    }\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        int prevEnd = INT_MIN;\\n        int res = 0;\\n        for (vector<int> interval: intervals) {\\n            if (interval[0] >= prevEnd) {\\n                // no overlap\\n                prevEnd = interval[1];\\n            }\\n            else {\\n                // overlap\\n                res++;\\n                prevEnd = min(prevEnd, interval[1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "OP101202",
                        "content": "[@asahoo27](/asahoo27) without cmp it won\\'t work , it is must."
                    },
                    {
                        "username": "asahoo27",
                        "content": "``` sort(intervals.begin(),intervals.end());```  just use this no need of cmp"
                    },
                    {
                        "username": "saisantosh3007",
                        "content": "[@1111aakansharao](/1111aakansharao) Thank you for this"
                    },
                    {
                        "username": "1111aakansharao",
                        "content": "your cmp function containg parameters as vectors, you need to pass it by reference beacause by value it will take a longer time and changes will not be reflected.\\n```\\nstatic bool cmp (vector<int>&a, vector<int>&b) {\\n        return a[0] < b[0];\\n    }\\n```\\nHope this helps you !\\nKeep hustlin :)"
                    },
                    {
                        "username": "Aiyaz123",
                        "content": "Thats the great solution tbh, easy and simple to understand.. "
                    },
                    {
                        "username": "Gaurav_Upreti",
                        "content": "Use pass by reference in cmp function, i.e. cmp(vector<int> &a, vector<int> &b)."
                    },
                    {
                        "username": "subz3r0",
                        "content": "I\\'m not sure why but the compare function was causing the TLE !! -_- "
                    },
                    {
                        "username": "rishavjain",
                        "content": "Time Limit Exceeded\\n58 / 58 testcases passed\\n?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Just regard it as a regular TLE ."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "show your code \nstatic bool cmp (vector<int>&a, vector<int>&b) {\n        return a[0] < b[0];\n    }\nhere a lot of ppl didnt pass the vector by reference are getting the same error as you perhaps that is the issue in your code"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So I\\'ve looked at an *awful lot* of solutions but nobody explains why their solution can be relied on to remove the minimum number of intervals. My first solution didn\\'t. I assume all the posted solutions do but after 5 pages of them I gave up hoping that somebody would explain how they met that part of the spec. Does anybody here have a solution where they know why it removes the minimum number of intervals? Can they explain why? Can ANYONE explain why?"
                    },
                    {
                        "username": "jfitzg7",
                        "content": "It helped me to visualize it by organizing intervals with the same end dates (sorted in ascending order) into groups. In the best case, if there is at least one interval in each group that doesn\\'t overlap with the previous group, you will be able to pick one interval from each group and discard the rest. It helps to look at the cases when there are 1 groups, 2 groups, 3 groups, etc.\\n\\n1 group: You can only pick 1 interval from the first group.\\n\\n2 groups: If all the intervals in the second group overlap with the first groups end date, then we will only be able to pick 1 interval. If only some (or none) overlapped, then we would be able to pick 2 intervals, one from the first group and another from the second group. But it\\'s not yet clear why we should be greedy.\\n\\n3 groups: Let\\'s say all the intervals in the second group overlap with the first group so that we would only be able to pick a single interval from one or the other, but which group do we pick from? If we pick from the second group instead of the first group, then this becomes a problem when all of the intervals in the third group overlap the second group (and maybe some overlap the first, but not all). If we had picked from the first group, then we would have been able to pick from the third group as well. If some or none of the intervals in the second group overlap the first, then we would greedily pick from the second group and it basically gets boiled down into the 2 groups case when dealing with the third group.\\n\\nIt gets complicated when looking at examples with more groups and thinking of all the cases, but hopefully this is a good starting point and can help give a different perspective. I think why this problem is so hard is that there are many cases to consider, and I needed to use this idea of grouping the intervals together just to make sense of why the greedy approach works."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, I can explain why the greedy algorithm that chooses to keep intervals with the earliest end time will remove the minimum number of intervals. This is a result of how the greedy strategy prioritizes creating the maximum room for the remaining intervals, which minimizes the number of intervals that have to be removed.\\n\\nThe key here is that if you have two overlapping intervals, keeping the one that ends earliest will leave more room for the remaining intervals. \\n\\nConsider two overlapping intervals, interval A and interval B, where A ends before B. \\n\\n```\\nA: |------|\\nB:     |---------|\\n```\\nIf you keep interval B, any subsequent interval cannot start until after B ends. But if you keep A, subsequent intervals can start right after A ends, providing more room for other intervals. Therefore, keeping A, the interval with the earliest end time, will allow us to fit in the most intervals, thereby minimizing the number we need to remove.\\n\\nTo generalize, we sort all intervals by end time, then iterate through the sorted list. We always keep the interval with the earliest end time among all overlapping intervals, and remove the others. By doing so, we can ensure that we\\'ve made the most room for the remaining intervals, thereby minimizing the number of intervals we need to remove.\\n\\nThis strategy satisfies the problem\\'s requirement of removing the minimum number of intervals because we\\'re always maximizing the space for the remaining intervals at each step, which is the key to minimizing removals."
                    },
                    {
                        "username": "shakthi4526",
                        "content": "Removing minimum number of intervals is the same as KEEPING maximum number of intervals. \\n\\nNow, if you look at it as scheduling maximum number of meetings in a room, then you should get it.\\nFor those unfamiliar with the Meeting scheduling problem, it is similar to this problem here, but each interval [start,end] represents the start and end time of a meeting. As there is only one room and we can have only one meeting at a time, we want to find maximum number of meetings we can schedule (in other words reject minimum number of meetings).\\n\\nAgain we sort by end times. Why? Because regardless of when a meeting starts, a meeting that ends first leaves more time for other meetings to take place. We do not want a meeting that starts early and ends late, what we really care about is when the meeting ends and how much time it leaves for the other meetings. So, sort by endtimes, remove all overlapping meetings to get maximum meetings or reject minimum meetings. Same logic applies here in this problem."
                    },
                    {
                        "username": "magicsign",
                        "content": "You can understand the solution by visualizing the intervals as lines. The key first of all is sorting the intervals by their ending point. For example say you have: [1,11],[2,12],[11,22],[1,100] , notice all intervals are sorted in ascending order based on their ending point.\\n\\nNow if you keep 2 pointers, prev and curr and a counter, prev gets initialized to [1,11], curr to [2,12]. 11 > 2 so it means that the interval [1,11] overlaps [2,12], we can remove [2,12] and in our case we increment our counter by one.\\nprev is [1,11], curr is [11,22], 11 > 11 no, so no overlapping. We need to move prev pointer to [11,22] to perform the next comparisons because we know that the previous intervals are non overlapping.\\n\\nprev is [11,22], curr is [1,100], 22 > 1, yes, we remove [1,100] or in another words, increment our counter. We reached the end with counter set to 2. "
                    },
                    {
                        "username": "lcgt",
                        "content": "I cant seem to think of a case where removing the latter interval is a bad idea, but it is a source of uncertainty."
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s consider a scenario where you might be tempted to remove a later interval, but it\\'s actually not the best move. Take a look at these intervals:\\n\\n```\\n[[1,10],[2,3],[4,5],[6,7],[8,9]]\\n```\\n\\nIn this case, interval [1,10] overlaps with all other intervals. Now, you might think to remove a later interval, say [8,9], because it\\'s later and removing it seems like it would minimize the overlaps.\\n\\nBut removing any of [2,3],[4,5],[6,7],[8,9] won\\'t solve the problem because they are not the root cause of the overlaps. The real issue is with the [1,10] interval, because it overlaps with all others. If you remove [1,10], you\\'ll only have to remove one interval and none of the remaining intervals overlap.\\n\\nThis illustrates that sometimes the best move is to remove an interval that isn\\'t necessarily the latest one, but the one that causes the most overlaps. It\\'s why the strategy of always removing the interval with the latest end time works \\u2013 it maximizes the room for other intervals and decreases the chances of overlaps."
                    },
                    {
                        "username": "ajv97",
                        "content": "Think this array as a list of start and end times of your favourite movies in a theatre where you can watch anything for free for that day.(you never get tired and you can teleport-only after the movie ends)\\nNow wouldn\\'t you be GREEDY and try to watch the maximum amount of movies.\\nBut you would also want the movie list to be SORTED by end time to get a better overview."
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can start by considering intervals in some \"natural\" order.\\n1. Earliest start time\\n![image.png](https://assets.leetcode.com/users/images/9ae02534-c9af-4239-b5f6-e1bdd43feaa0_1684388688.0637023.png)\\n2. Earliest finish time\\n3. Shortest interval\\n![image.png](https://assets.leetcode.com/users/images/70407e84-c791-40da-9e62-c2b4506ef72d_1684388702.40602.png)\\n4. Fewest conflicts\\n![image.png](https://assets.leetcode.com/users/images/e70553be-2b51-4c03-804b-0c6939de7391_1684388714.3131933.png)\\nWe found some counterexamples for 1, 2 and 4.\\nNow let\\'s prove why greedy with EFT works.\\n# Proof of optimality by contradiction\\n- Suppose for contradiction that greedy is not optimal\\n- Say greedy selects interval `\\uD835\\uDC561, \\uD835\\uDC562, \\u2026 , \\uD835\\uDC56\\uD835\\uDC58` sorted by finish time\\n- Consider an optimal solution `\\uD835\\uDC571,\\uD835\\uDC572, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5A` (also sorted by finish time) which matches greedy for as many indices as possible\\n    - That is, we want `\\uD835\\uDC571 = \\uD835\\uDC561, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5F = \\uD835\\uDC56\\uD835\\uDC5F` for the greatest possible `\\uD835\\uDC5F`\\n- Both `\\uD835\\uDC56\\uD835\\uDC5F+1` and `\\uD835\\uDC57\\uD835\\uDC5F+1` must be compatible with the previous selection\\n`(\\uD835\\uDC561 = \\uD835\\uDC571, \\u2026 , \\uD835\\uDC56\\uD835\\uDC5F = \\uD835\\uDC57\\uD835\\uDC5F)`\\n- Consider a new solution `\\uD835\\uDC561, \\uD835\\uDC562, \\u2026 , \\uD835\\uDC56\\uD835\\uDC5F, \\uD835\\uDC56\\uD835\\uDC5F+1,\\uD835\\uDC57\\uD835\\uDC5F+2, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5A`\\n- We have replaced `\\uD835\\uDC57\\uD835\\uDC5F+1` by `\\uD835\\uDC56\\uD835\\uDC5F+1` in our reference optimal solution\\n- This is still feasible because `\\uD835\\uDC53\\uD835\\uDC56\\uD835\\uDC5F+1 \\u2264 \\uD835\\uDC53\\uD835\\uDC57\\uD835\\uDC5F+1 \\u2264 \\uD835\\uDC60\\uD835\\uDC57\\uD835\\uDC61`\\nfor `\\uD835\\uDC61 \\u2265 \\uD835\\uDC5F + 2` where `\\uD835\\uDC53\\uD835\\uDC56` is the finish time for interval `i`.\\n- This is still optimal because `\\uD835\\uDC5A` intervals are selected.\\n- But it matches the greedy solution in \\uD835\\uDC5F + 1 indices\\n    - This is the desired contradiction\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort intervals by finish time.\\n2. For each interval `j` we check if it\\'s compatible with the last added interval `i`. If not, increase `res` and `j`, otherwise increate `i` and `j`. "
                    },
                    {
                        "username": "Leaderboard",
                        "content": "> We found some counterexamples for 1, 2 and 4.\\n\\nShould it not be \"1, 3 and 4\"?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "So many of you comment like I\\'m reading ChatGPT. You may have a proper solution but its improperly explained with holes and leaps in the logic or its just flat out word salad with no meaning.\\n\\nYou can basically boil this down to sorting by start position and greedily picking the intervals that end first. This is optimal precisely because given some starting position (suppose you consider only the intervals with starts after some $$X$$, in practice $$X$$ is the end of the last chosen interval). Then you should always pick the next interval which ends first, call it interval $$F$$\\n\\nThe proof is simple, suppose the interval $$F$$  isn\\'t part of the optimal choices, then that means that there is some interval, $$Q$$, which overlaps it you should pick instead  that gives you better choices later on somehow. However picking $$Q$$ can be no better than picking $$F$$ because you could always copy remaining ones after $$Q$$ even if you picked $$F$$ because we assumed $$F$$ is the one that ends first."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@cecilia5](/cecilia5) I didn\\'t not provide the complete proof because I wanted to leave some minor details as an exercise to the reader.\\n\\nHowever the details are that $$F$$ is assumed not to be a trivial choice, I.E it must be overlapping something else. \\n\\nIf it doesn\\'t overlap anything you must always include it because you are maximizing intervals. This removes the possibility that $$Q$$ doesn\\'t overlap.\\n\\nSecondly because $$F$$ is assumed to end first, then there cannot be anything before it. The endpoints of other intervals are at or after it. So there cannot be these theoretical intervals that are choosable before it that don\\'t overlap with $$Q$$. "
                    },
                    {
                        "username": "cecilia5",
                        "content": "There are a few things I nit picked from your comment. It is not meant to say you have a problem, please take that as an opportunity for you to improve your writing:\\n\\nThis is optimal precisely because [...], but the [...] doesn\\'t explain why it is optimal, it just describe the algorithm, and it isn\\'t complete (it doesn\\'t talk about skipping the conflicting ones, which is probably obvious \"to you\")\\n\\nFor the proof itself:\\n\\nI rather you not say the proof is simple - people looking for proofs find it hard - that\\'s why they are looking for it.\\n\\nYou didn\\'t explain why if `F` is not part of the optimal choice, then there exists `Q` that overlaps with it.\\n\\nYou also didn\\'t show why copy the remaining after `Q` is enough, what if the optimal solution including `Q` can include a lot more intervals before `Q`?\\n\\nYour idea is right on, and your proof could be polished to become a flawless one, you just need to:\\n\\n1.) See it from the adversary angle - what could someone argue about your proof, and how you plug those holes so that you answer the question before it happens, and\\n2.) See it from the learner\\'s angle - some facts could be obvious to you, but not the reader.\\n\\nI hope that helps you."
                    },
                    {
                        "username": "niraj243",
                        "content": "Can somenone explain why my solution is giving Runtime error  \n\"Line 1034: Char 34: runtime error: applying non-zero offset 4 to null pointer (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\"\nBut when I change  `return (v1[1] <= v2[1]);` to `return (v1[1] < v2[1]);` in cmp function. It works, but why ??\n```cpp\nclass Solution {\npublic:\n    static bool cmp(vector<int> &v1,vector<int> &v2){\n        // return (v1[1] <= v2[1]); // gives error why ??\n        return (v1[1] < v2[1]);\n    }\n    bool isok(vector<int> i1,vector<int> i2){\n        return (i1[1]<=i2[0] || i1[0]>=i2[1]);\n    }\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        int n = intervals.size();\n        sort(intervals.begin(),intervals.end(),cmp);\n        vector<int> end(n);\n        for(int i=0;i<n;i++){\n            end[i] = intervals[i][1];\n        }\n        int ans=1;\n        vector<int> dp(n,1);\n        for(int i=1;i<n;i++){\n            int mx = 0;\n            int prev_ok = upper_bound(end.begin(),end.end(),intervals[i][0])-end.begin()-1;\n            if(prev_ok>=0)\n            mx = dp[prev_ok];\n            dp[i] = max(dp[i-1],mx+1);\n            ans = max(ans,dp[i]);\n        }\n        return n-ans;\n    }\n};\n```  "
                    },
                    {
                        "username": "AndreiZherder",
                        "content": "If you think about DP solution, it is very similar to problem we solved four days ago:\\n[1751. Maximum number of events that can be attended II](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/)\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "Sort the intervals based on their ending point and track the last relevant interval (i) and comp the curr index\\'s 0th point with tracked (i)\\'s 1st point and if it less then increase ans++ (skip this interval) otherwise we have to consider this and assign your track index to this index"
                    }
                ]
            },
            {
                "id": 1781289,
                "content": [
                    {
                        "username": "subz3r0",
                        "content": "Getting **TLE** for this. **HELP**\\n```\\nclass Solution {\\nprivate:\\n    static bool cmp (vector<int> a, vector<int> b) {\\n        return a[0] < b[0];\\n    }\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        int prevEnd = INT_MIN;\\n        int res = 0;\\n        for (vector<int> interval: intervals) {\\n            if (interval[0] >= prevEnd) {\\n                // no overlap\\n                prevEnd = interval[1];\\n            }\\n            else {\\n                // overlap\\n                res++;\\n                prevEnd = min(prevEnd, interval[1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "OP101202",
                        "content": "[@asahoo27](/asahoo27) without cmp it won\\'t work , it is must."
                    },
                    {
                        "username": "asahoo27",
                        "content": "``` sort(intervals.begin(),intervals.end());```  just use this no need of cmp"
                    },
                    {
                        "username": "saisantosh3007",
                        "content": "[@1111aakansharao](/1111aakansharao) Thank you for this"
                    },
                    {
                        "username": "1111aakansharao",
                        "content": "your cmp function containg parameters as vectors, you need to pass it by reference beacause by value it will take a longer time and changes will not be reflected.\\n```\\nstatic bool cmp (vector<int>&a, vector<int>&b) {\\n        return a[0] < b[0];\\n    }\\n```\\nHope this helps you !\\nKeep hustlin :)"
                    },
                    {
                        "username": "Aiyaz123",
                        "content": "Thats the great solution tbh, easy and simple to understand.. "
                    },
                    {
                        "username": "Gaurav_Upreti",
                        "content": "Use pass by reference in cmp function, i.e. cmp(vector<int> &a, vector<int> &b)."
                    },
                    {
                        "username": "subz3r0",
                        "content": "I\\'m not sure why but the compare function was causing the TLE !! -_- "
                    },
                    {
                        "username": "rishavjain",
                        "content": "Time Limit Exceeded\\n58 / 58 testcases passed\\n?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Just regard it as a regular TLE ."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "show your code \nstatic bool cmp (vector<int>&a, vector<int>&b) {\n        return a[0] < b[0];\n    }\nhere a lot of ppl didnt pass the vector by reference are getting the same error as you perhaps that is the issue in your code"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So I\\'ve looked at an *awful lot* of solutions but nobody explains why their solution can be relied on to remove the minimum number of intervals. My first solution didn\\'t. I assume all the posted solutions do but after 5 pages of them I gave up hoping that somebody would explain how they met that part of the spec. Does anybody here have a solution where they know why it removes the minimum number of intervals? Can they explain why? Can ANYONE explain why?"
                    },
                    {
                        "username": "jfitzg7",
                        "content": "It helped me to visualize it by organizing intervals with the same end dates (sorted in ascending order) into groups. In the best case, if there is at least one interval in each group that doesn\\'t overlap with the previous group, you will be able to pick one interval from each group and discard the rest. It helps to look at the cases when there are 1 groups, 2 groups, 3 groups, etc.\\n\\n1 group: You can only pick 1 interval from the first group.\\n\\n2 groups: If all the intervals in the second group overlap with the first groups end date, then we will only be able to pick 1 interval. If only some (or none) overlapped, then we would be able to pick 2 intervals, one from the first group and another from the second group. But it\\'s not yet clear why we should be greedy.\\n\\n3 groups: Let\\'s say all the intervals in the second group overlap with the first group so that we would only be able to pick a single interval from one or the other, but which group do we pick from? If we pick from the second group instead of the first group, then this becomes a problem when all of the intervals in the third group overlap the second group (and maybe some overlap the first, but not all). If we had picked from the first group, then we would have been able to pick from the third group as well. If some or none of the intervals in the second group overlap the first, then we would greedily pick from the second group and it basically gets boiled down into the 2 groups case when dealing with the third group.\\n\\nIt gets complicated when looking at examples with more groups and thinking of all the cases, but hopefully this is a good starting point and can help give a different perspective. I think why this problem is so hard is that there are many cases to consider, and I needed to use this idea of grouping the intervals together just to make sense of why the greedy approach works."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, I can explain why the greedy algorithm that chooses to keep intervals with the earliest end time will remove the minimum number of intervals. This is a result of how the greedy strategy prioritizes creating the maximum room for the remaining intervals, which minimizes the number of intervals that have to be removed.\\n\\nThe key here is that if you have two overlapping intervals, keeping the one that ends earliest will leave more room for the remaining intervals. \\n\\nConsider two overlapping intervals, interval A and interval B, where A ends before B. \\n\\n```\\nA: |------|\\nB:     |---------|\\n```\\nIf you keep interval B, any subsequent interval cannot start until after B ends. But if you keep A, subsequent intervals can start right after A ends, providing more room for other intervals. Therefore, keeping A, the interval with the earliest end time, will allow us to fit in the most intervals, thereby minimizing the number we need to remove.\\n\\nTo generalize, we sort all intervals by end time, then iterate through the sorted list. We always keep the interval with the earliest end time among all overlapping intervals, and remove the others. By doing so, we can ensure that we\\'ve made the most room for the remaining intervals, thereby minimizing the number of intervals we need to remove.\\n\\nThis strategy satisfies the problem\\'s requirement of removing the minimum number of intervals because we\\'re always maximizing the space for the remaining intervals at each step, which is the key to minimizing removals."
                    },
                    {
                        "username": "shakthi4526",
                        "content": "Removing minimum number of intervals is the same as KEEPING maximum number of intervals. \\n\\nNow, if you look at it as scheduling maximum number of meetings in a room, then you should get it.\\nFor those unfamiliar with the Meeting scheduling problem, it is similar to this problem here, but each interval [start,end] represents the start and end time of a meeting. As there is only one room and we can have only one meeting at a time, we want to find maximum number of meetings we can schedule (in other words reject minimum number of meetings).\\n\\nAgain we sort by end times. Why? Because regardless of when a meeting starts, a meeting that ends first leaves more time for other meetings to take place. We do not want a meeting that starts early and ends late, what we really care about is when the meeting ends and how much time it leaves for the other meetings. So, sort by endtimes, remove all overlapping meetings to get maximum meetings or reject minimum meetings. Same logic applies here in this problem."
                    },
                    {
                        "username": "magicsign",
                        "content": "You can understand the solution by visualizing the intervals as lines. The key first of all is sorting the intervals by their ending point. For example say you have: [1,11],[2,12],[11,22],[1,100] , notice all intervals are sorted in ascending order based on their ending point.\\n\\nNow if you keep 2 pointers, prev and curr and a counter, prev gets initialized to [1,11], curr to [2,12]. 11 > 2 so it means that the interval [1,11] overlaps [2,12], we can remove [2,12] and in our case we increment our counter by one.\\nprev is [1,11], curr is [11,22], 11 > 11 no, so no overlapping. We need to move prev pointer to [11,22] to perform the next comparisons because we know that the previous intervals are non overlapping.\\n\\nprev is [11,22], curr is [1,100], 22 > 1, yes, we remove [1,100] or in another words, increment our counter. We reached the end with counter set to 2. "
                    },
                    {
                        "username": "lcgt",
                        "content": "I cant seem to think of a case where removing the latter interval is a bad idea, but it is a source of uncertainty."
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s consider a scenario where you might be tempted to remove a later interval, but it\\'s actually not the best move. Take a look at these intervals:\\n\\n```\\n[[1,10],[2,3],[4,5],[6,7],[8,9]]\\n```\\n\\nIn this case, interval [1,10] overlaps with all other intervals. Now, you might think to remove a later interval, say [8,9], because it\\'s later and removing it seems like it would minimize the overlaps.\\n\\nBut removing any of [2,3],[4,5],[6,7],[8,9] won\\'t solve the problem because they are not the root cause of the overlaps. The real issue is with the [1,10] interval, because it overlaps with all others. If you remove [1,10], you\\'ll only have to remove one interval and none of the remaining intervals overlap.\\n\\nThis illustrates that sometimes the best move is to remove an interval that isn\\'t necessarily the latest one, but the one that causes the most overlaps. It\\'s why the strategy of always removing the interval with the latest end time works \\u2013 it maximizes the room for other intervals and decreases the chances of overlaps."
                    },
                    {
                        "username": "ajv97",
                        "content": "Think this array as a list of start and end times of your favourite movies in a theatre where you can watch anything for free for that day.(you never get tired and you can teleport-only after the movie ends)\\nNow wouldn\\'t you be GREEDY and try to watch the maximum amount of movies.\\nBut you would also want the movie list to be SORTED by end time to get a better overview."
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can start by considering intervals in some \"natural\" order.\\n1. Earliest start time\\n![image.png](https://assets.leetcode.com/users/images/9ae02534-c9af-4239-b5f6-e1bdd43feaa0_1684388688.0637023.png)\\n2. Earliest finish time\\n3. Shortest interval\\n![image.png](https://assets.leetcode.com/users/images/70407e84-c791-40da-9e62-c2b4506ef72d_1684388702.40602.png)\\n4. Fewest conflicts\\n![image.png](https://assets.leetcode.com/users/images/e70553be-2b51-4c03-804b-0c6939de7391_1684388714.3131933.png)\\nWe found some counterexamples for 1, 2 and 4.\\nNow let\\'s prove why greedy with EFT works.\\n# Proof of optimality by contradiction\\n- Suppose for contradiction that greedy is not optimal\\n- Say greedy selects interval `\\uD835\\uDC561, \\uD835\\uDC562, \\u2026 , \\uD835\\uDC56\\uD835\\uDC58` sorted by finish time\\n- Consider an optimal solution `\\uD835\\uDC571,\\uD835\\uDC572, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5A` (also sorted by finish time) which matches greedy for as many indices as possible\\n    - That is, we want `\\uD835\\uDC571 = \\uD835\\uDC561, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5F = \\uD835\\uDC56\\uD835\\uDC5F` for the greatest possible `\\uD835\\uDC5F`\\n- Both `\\uD835\\uDC56\\uD835\\uDC5F+1` and `\\uD835\\uDC57\\uD835\\uDC5F+1` must be compatible with the previous selection\\n`(\\uD835\\uDC561 = \\uD835\\uDC571, \\u2026 , \\uD835\\uDC56\\uD835\\uDC5F = \\uD835\\uDC57\\uD835\\uDC5F)`\\n- Consider a new solution `\\uD835\\uDC561, \\uD835\\uDC562, \\u2026 , \\uD835\\uDC56\\uD835\\uDC5F, \\uD835\\uDC56\\uD835\\uDC5F+1,\\uD835\\uDC57\\uD835\\uDC5F+2, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5A`\\n- We have replaced `\\uD835\\uDC57\\uD835\\uDC5F+1` by `\\uD835\\uDC56\\uD835\\uDC5F+1` in our reference optimal solution\\n- This is still feasible because `\\uD835\\uDC53\\uD835\\uDC56\\uD835\\uDC5F+1 \\u2264 \\uD835\\uDC53\\uD835\\uDC57\\uD835\\uDC5F+1 \\u2264 \\uD835\\uDC60\\uD835\\uDC57\\uD835\\uDC61`\\nfor `\\uD835\\uDC61 \\u2265 \\uD835\\uDC5F + 2` where `\\uD835\\uDC53\\uD835\\uDC56` is the finish time for interval `i`.\\n- This is still optimal because `\\uD835\\uDC5A` intervals are selected.\\n- But it matches the greedy solution in \\uD835\\uDC5F + 1 indices\\n    - This is the desired contradiction\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort intervals by finish time.\\n2. For each interval `j` we check if it\\'s compatible with the last added interval `i`. If not, increase `res` and `j`, otherwise increate `i` and `j`. "
                    },
                    {
                        "username": "Leaderboard",
                        "content": "> We found some counterexamples for 1, 2 and 4.\\n\\nShould it not be \"1, 3 and 4\"?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "So many of you comment like I\\'m reading ChatGPT. You may have a proper solution but its improperly explained with holes and leaps in the logic or its just flat out word salad with no meaning.\\n\\nYou can basically boil this down to sorting by start position and greedily picking the intervals that end first. This is optimal precisely because given some starting position (suppose you consider only the intervals with starts after some $$X$$, in practice $$X$$ is the end of the last chosen interval). Then you should always pick the next interval which ends first, call it interval $$F$$\\n\\nThe proof is simple, suppose the interval $$F$$  isn\\'t part of the optimal choices, then that means that there is some interval, $$Q$$, which overlaps it you should pick instead  that gives you better choices later on somehow. However picking $$Q$$ can be no better than picking $$F$$ because you could always copy remaining ones after $$Q$$ even if you picked $$F$$ because we assumed $$F$$ is the one that ends first."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@cecilia5](/cecilia5) I didn\\'t not provide the complete proof because I wanted to leave some minor details as an exercise to the reader.\\n\\nHowever the details are that $$F$$ is assumed not to be a trivial choice, I.E it must be overlapping something else. \\n\\nIf it doesn\\'t overlap anything you must always include it because you are maximizing intervals. This removes the possibility that $$Q$$ doesn\\'t overlap.\\n\\nSecondly because $$F$$ is assumed to end first, then there cannot be anything before it. The endpoints of other intervals are at or after it. So there cannot be these theoretical intervals that are choosable before it that don\\'t overlap with $$Q$$. "
                    },
                    {
                        "username": "cecilia5",
                        "content": "There are a few things I nit picked from your comment. It is not meant to say you have a problem, please take that as an opportunity for you to improve your writing:\\n\\nThis is optimal precisely because [...], but the [...] doesn\\'t explain why it is optimal, it just describe the algorithm, and it isn\\'t complete (it doesn\\'t talk about skipping the conflicting ones, which is probably obvious \"to you\")\\n\\nFor the proof itself:\\n\\nI rather you not say the proof is simple - people looking for proofs find it hard - that\\'s why they are looking for it.\\n\\nYou didn\\'t explain why if `F` is not part of the optimal choice, then there exists `Q` that overlaps with it.\\n\\nYou also didn\\'t show why copy the remaining after `Q` is enough, what if the optimal solution including `Q` can include a lot more intervals before `Q`?\\n\\nYour idea is right on, and your proof could be polished to become a flawless one, you just need to:\\n\\n1.) See it from the adversary angle - what could someone argue about your proof, and how you plug those holes so that you answer the question before it happens, and\\n2.) See it from the learner\\'s angle - some facts could be obvious to you, but not the reader.\\n\\nI hope that helps you."
                    },
                    {
                        "username": "niraj243",
                        "content": "Can somenone explain why my solution is giving Runtime error  \n\"Line 1034: Char 34: runtime error: applying non-zero offset 4 to null pointer (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\"\nBut when I change  `return (v1[1] <= v2[1]);` to `return (v1[1] < v2[1]);` in cmp function. It works, but why ??\n```cpp\nclass Solution {\npublic:\n    static bool cmp(vector<int> &v1,vector<int> &v2){\n        // return (v1[1] <= v2[1]); // gives error why ??\n        return (v1[1] < v2[1]);\n    }\n    bool isok(vector<int> i1,vector<int> i2){\n        return (i1[1]<=i2[0] || i1[0]>=i2[1]);\n    }\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        int n = intervals.size();\n        sort(intervals.begin(),intervals.end(),cmp);\n        vector<int> end(n);\n        for(int i=0;i<n;i++){\n            end[i] = intervals[i][1];\n        }\n        int ans=1;\n        vector<int> dp(n,1);\n        for(int i=1;i<n;i++){\n            int mx = 0;\n            int prev_ok = upper_bound(end.begin(),end.end(),intervals[i][0])-end.begin()-1;\n            if(prev_ok>=0)\n            mx = dp[prev_ok];\n            dp[i] = max(dp[i-1],mx+1);\n            ans = max(ans,dp[i]);\n        }\n        return n-ans;\n    }\n};\n```  "
                    },
                    {
                        "username": "AndreiZherder",
                        "content": "If you think about DP solution, it is very similar to problem we solved four days ago:\\n[1751. Maximum number of events that can be attended II](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/)\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "Sort the intervals based on their ending point and track the last relevant interval (i) and comp the curr index\\'s 0th point with tracked (i)\\'s 1st point and if it less then increase ans++ (skip this interval) otherwise we have to consider this and assign your track index to this index"
                    }
                ]
            },
            {
                "id": 1569555,
                "content": [
                    {
                        "username": "subz3r0",
                        "content": "Getting **TLE** for this. **HELP**\\n```\\nclass Solution {\\nprivate:\\n    static bool cmp (vector<int> a, vector<int> b) {\\n        return a[0] < b[0];\\n    }\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        int prevEnd = INT_MIN;\\n        int res = 0;\\n        for (vector<int> interval: intervals) {\\n            if (interval[0] >= prevEnd) {\\n                // no overlap\\n                prevEnd = interval[1];\\n            }\\n            else {\\n                // overlap\\n                res++;\\n                prevEnd = min(prevEnd, interval[1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "OP101202",
                        "content": "[@asahoo27](/asahoo27) without cmp it won\\'t work , it is must."
                    },
                    {
                        "username": "asahoo27",
                        "content": "``` sort(intervals.begin(),intervals.end());```  just use this no need of cmp"
                    },
                    {
                        "username": "saisantosh3007",
                        "content": "[@1111aakansharao](/1111aakansharao) Thank you for this"
                    },
                    {
                        "username": "1111aakansharao",
                        "content": "your cmp function containg parameters as vectors, you need to pass it by reference beacause by value it will take a longer time and changes will not be reflected.\\n```\\nstatic bool cmp (vector<int>&a, vector<int>&b) {\\n        return a[0] < b[0];\\n    }\\n```\\nHope this helps you !\\nKeep hustlin :)"
                    },
                    {
                        "username": "Aiyaz123",
                        "content": "Thats the great solution tbh, easy and simple to understand.. "
                    },
                    {
                        "username": "Gaurav_Upreti",
                        "content": "Use pass by reference in cmp function, i.e. cmp(vector<int> &a, vector<int> &b)."
                    },
                    {
                        "username": "subz3r0",
                        "content": "I\\'m not sure why but the compare function was causing the TLE !! -_- "
                    },
                    {
                        "username": "rishavjain",
                        "content": "Time Limit Exceeded\\n58 / 58 testcases passed\\n?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Just regard it as a regular TLE ."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "show your code \nstatic bool cmp (vector<int>&a, vector<int>&b) {\n        return a[0] < b[0];\n    }\nhere a lot of ppl didnt pass the vector by reference are getting the same error as you perhaps that is the issue in your code"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So I\\'ve looked at an *awful lot* of solutions but nobody explains why their solution can be relied on to remove the minimum number of intervals. My first solution didn\\'t. I assume all the posted solutions do but after 5 pages of them I gave up hoping that somebody would explain how they met that part of the spec. Does anybody here have a solution where they know why it removes the minimum number of intervals? Can they explain why? Can ANYONE explain why?"
                    },
                    {
                        "username": "jfitzg7",
                        "content": "It helped me to visualize it by organizing intervals with the same end dates (sorted in ascending order) into groups. In the best case, if there is at least one interval in each group that doesn\\'t overlap with the previous group, you will be able to pick one interval from each group and discard the rest. It helps to look at the cases when there are 1 groups, 2 groups, 3 groups, etc.\\n\\n1 group: You can only pick 1 interval from the first group.\\n\\n2 groups: If all the intervals in the second group overlap with the first groups end date, then we will only be able to pick 1 interval. If only some (or none) overlapped, then we would be able to pick 2 intervals, one from the first group and another from the second group. But it\\'s not yet clear why we should be greedy.\\n\\n3 groups: Let\\'s say all the intervals in the second group overlap with the first group so that we would only be able to pick a single interval from one or the other, but which group do we pick from? If we pick from the second group instead of the first group, then this becomes a problem when all of the intervals in the third group overlap the second group (and maybe some overlap the first, but not all). If we had picked from the first group, then we would have been able to pick from the third group as well. If some or none of the intervals in the second group overlap the first, then we would greedily pick from the second group and it basically gets boiled down into the 2 groups case when dealing with the third group.\\n\\nIt gets complicated when looking at examples with more groups and thinking of all the cases, but hopefully this is a good starting point and can help give a different perspective. I think why this problem is so hard is that there are many cases to consider, and I needed to use this idea of grouping the intervals together just to make sense of why the greedy approach works."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, I can explain why the greedy algorithm that chooses to keep intervals with the earliest end time will remove the minimum number of intervals. This is a result of how the greedy strategy prioritizes creating the maximum room for the remaining intervals, which minimizes the number of intervals that have to be removed.\\n\\nThe key here is that if you have two overlapping intervals, keeping the one that ends earliest will leave more room for the remaining intervals. \\n\\nConsider two overlapping intervals, interval A and interval B, where A ends before B. \\n\\n```\\nA: |------|\\nB:     |---------|\\n```\\nIf you keep interval B, any subsequent interval cannot start until after B ends. But if you keep A, subsequent intervals can start right after A ends, providing more room for other intervals. Therefore, keeping A, the interval with the earliest end time, will allow us to fit in the most intervals, thereby minimizing the number we need to remove.\\n\\nTo generalize, we sort all intervals by end time, then iterate through the sorted list. We always keep the interval with the earliest end time among all overlapping intervals, and remove the others. By doing so, we can ensure that we\\'ve made the most room for the remaining intervals, thereby minimizing the number of intervals we need to remove.\\n\\nThis strategy satisfies the problem\\'s requirement of removing the minimum number of intervals because we\\'re always maximizing the space for the remaining intervals at each step, which is the key to minimizing removals."
                    },
                    {
                        "username": "shakthi4526",
                        "content": "Removing minimum number of intervals is the same as KEEPING maximum number of intervals. \\n\\nNow, if you look at it as scheduling maximum number of meetings in a room, then you should get it.\\nFor those unfamiliar with the Meeting scheduling problem, it is similar to this problem here, but each interval [start,end] represents the start and end time of a meeting. As there is only one room and we can have only one meeting at a time, we want to find maximum number of meetings we can schedule (in other words reject minimum number of meetings).\\n\\nAgain we sort by end times. Why? Because regardless of when a meeting starts, a meeting that ends first leaves more time for other meetings to take place. We do not want a meeting that starts early and ends late, what we really care about is when the meeting ends and how much time it leaves for the other meetings. So, sort by endtimes, remove all overlapping meetings to get maximum meetings or reject minimum meetings. Same logic applies here in this problem."
                    },
                    {
                        "username": "magicsign",
                        "content": "You can understand the solution by visualizing the intervals as lines. The key first of all is sorting the intervals by their ending point. For example say you have: [1,11],[2,12],[11,22],[1,100] , notice all intervals are sorted in ascending order based on their ending point.\\n\\nNow if you keep 2 pointers, prev and curr and a counter, prev gets initialized to [1,11], curr to [2,12]. 11 > 2 so it means that the interval [1,11] overlaps [2,12], we can remove [2,12] and in our case we increment our counter by one.\\nprev is [1,11], curr is [11,22], 11 > 11 no, so no overlapping. We need to move prev pointer to [11,22] to perform the next comparisons because we know that the previous intervals are non overlapping.\\n\\nprev is [11,22], curr is [1,100], 22 > 1, yes, we remove [1,100] or in another words, increment our counter. We reached the end with counter set to 2. "
                    },
                    {
                        "username": "lcgt",
                        "content": "I cant seem to think of a case where removing the latter interval is a bad idea, but it is a source of uncertainty."
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s consider a scenario where you might be tempted to remove a later interval, but it\\'s actually not the best move. Take a look at these intervals:\\n\\n```\\n[[1,10],[2,3],[4,5],[6,7],[8,9]]\\n```\\n\\nIn this case, interval [1,10] overlaps with all other intervals. Now, you might think to remove a later interval, say [8,9], because it\\'s later and removing it seems like it would minimize the overlaps.\\n\\nBut removing any of [2,3],[4,5],[6,7],[8,9] won\\'t solve the problem because they are not the root cause of the overlaps. The real issue is with the [1,10] interval, because it overlaps with all others. If you remove [1,10], you\\'ll only have to remove one interval and none of the remaining intervals overlap.\\n\\nThis illustrates that sometimes the best move is to remove an interval that isn\\'t necessarily the latest one, but the one that causes the most overlaps. It\\'s why the strategy of always removing the interval with the latest end time works \\u2013 it maximizes the room for other intervals and decreases the chances of overlaps."
                    },
                    {
                        "username": "ajv97",
                        "content": "Think this array as a list of start and end times of your favourite movies in a theatre where you can watch anything for free for that day.(you never get tired and you can teleport-only after the movie ends)\\nNow wouldn\\'t you be GREEDY and try to watch the maximum amount of movies.\\nBut you would also want the movie list to be SORTED by end time to get a better overview."
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can start by considering intervals in some \"natural\" order.\\n1. Earliest start time\\n![image.png](https://assets.leetcode.com/users/images/9ae02534-c9af-4239-b5f6-e1bdd43feaa0_1684388688.0637023.png)\\n2. Earliest finish time\\n3. Shortest interval\\n![image.png](https://assets.leetcode.com/users/images/70407e84-c791-40da-9e62-c2b4506ef72d_1684388702.40602.png)\\n4. Fewest conflicts\\n![image.png](https://assets.leetcode.com/users/images/e70553be-2b51-4c03-804b-0c6939de7391_1684388714.3131933.png)\\nWe found some counterexamples for 1, 2 and 4.\\nNow let\\'s prove why greedy with EFT works.\\n# Proof of optimality by contradiction\\n- Suppose for contradiction that greedy is not optimal\\n- Say greedy selects interval `\\uD835\\uDC561, \\uD835\\uDC562, \\u2026 , \\uD835\\uDC56\\uD835\\uDC58` sorted by finish time\\n- Consider an optimal solution `\\uD835\\uDC571,\\uD835\\uDC572, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5A` (also sorted by finish time) which matches greedy for as many indices as possible\\n    - That is, we want `\\uD835\\uDC571 = \\uD835\\uDC561, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5F = \\uD835\\uDC56\\uD835\\uDC5F` for the greatest possible `\\uD835\\uDC5F`\\n- Both `\\uD835\\uDC56\\uD835\\uDC5F+1` and `\\uD835\\uDC57\\uD835\\uDC5F+1` must be compatible with the previous selection\\n`(\\uD835\\uDC561 = \\uD835\\uDC571, \\u2026 , \\uD835\\uDC56\\uD835\\uDC5F = \\uD835\\uDC57\\uD835\\uDC5F)`\\n- Consider a new solution `\\uD835\\uDC561, \\uD835\\uDC562, \\u2026 , \\uD835\\uDC56\\uD835\\uDC5F, \\uD835\\uDC56\\uD835\\uDC5F+1,\\uD835\\uDC57\\uD835\\uDC5F+2, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5A`\\n- We have replaced `\\uD835\\uDC57\\uD835\\uDC5F+1` by `\\uD835\\uDC56\\uD835\\uDC5F+1` in our reference optimal solution\\n- This is still feasible because `\\uD835\\uDC53\\uD835\\uDC56\\uD835\\uDC5F+1 \\u2264 \\uD835\\uDC53\\uD835\\uDC57\\uD835\\uDC5F+1 \\u2264 \\uD835\\uDC60\\uD835\\uDC57\\uD835\\uDC61`\\nfor `\\uD835\\uDC61 \\u2265 \\uD835\\uDC5F + 2` where `\\uD835\\uDC53\\uD835\\uDC56` is the finish time for interval `i`.\\n- This is still optimal because `\\uD835\\uDC5A` intervals are selected.\\n- But it matches the greedy solution in \\uD835\\uDC5F + 1 indices\\n    - This is the desired contradiction\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort intervals by finish time.\\n2. For each interval `j` we check if it\\'s compatible with the last added interval `i`. If not, increase `res` and `j`, otherwise increate `i` and `j`. "
                    },
                    {
                        "username": "Leaderboard",
                        "content": "> We found some counterexamples for 1, 2 and 4.\\n\\nShould it not be \"1, 3 and 4\"?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "So many of you comment like I\\'m reading ChatGPT. You may have a proper solution but its improperly explained with holes and leaps in the logic or its just flat out word salad with no meaning.\\n\\nYou can basically boil this down to sorting by start position and greedily picking the intervals that end first. This is optimal precisely because given some starting position (suppose you consider only the intervals with starts after some $$X$$, in practice $$X$$ is the end of the last chosen interval). Then you should always pick the next interval which ends first, call it interval $$F$$\\n\\nThe proof is simple, suppose the interval $$F$$  isn\\'t part of the optimal choices, then that means that there is some interval, $$Q$$, which overlaps it you should pick instead  that gives you better choices later on somehow. However picking $$Q$$ can be no better than picking $$F$$ because you could always copy remaining ones after $$Q$$ even if you picked $$F$$ because we assumed $$F$$ is the one that ends first."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@cecilia5](/cecilia5) I didn\\'t not provide the complete proof because I wanted to leave some minor details as an exercise to the reader.\\n\\nHowever the details are that $$F$$ is assumed not to be a trivial choice, I.E it must be overlapping something else. \\n\\nIf it doesn\\'t overlap anything you must always include it because you are maximizing intervals. This removes the possibility that $$Q$$ doesn\\'t overlap.\\n\\nSecondly because $$F$$ is assumed to end first, then there cannot be anything before it. The endpoints of other intervals are at or after it. So there cannot be these theoretical intervals that are choosable before it that don\\'t overlap with $$Q$$. "
                    },
                    {
                        "username": "cecilia5",
                        "content": "There are a few things I nit picked from your comment. It is not meant to say you have a problem, please take that as an opportunity for you to improve your writing:\\n\\nThis is optimal precisely because [...], but the [...] doesn\\'t explain why it is optimal, it just describe the algorithm, and it isn\\'t complete (it doesn\\'t talk about skipping the conflicting ones, which is probably obvious \"to you\")\\n\\nFor the proof itself:\\n\\nI rather you not say the proof is simple - people looking for proofs find it hard - that\\'s why they are looking for it.\\n\\nYou didn\\'t explain why if `F` is not part of the optimal choice, then there exists `Q` that overlaps with it.\\n\\nYou also didn\\'t show why copy the remaining after `Q` is enough, what if the optimal solution including `Q` can include a lot more intervals before `Q`?\\n\\nYour idea is right on, and your proof could be polished to become a flawless one, you just need to:\\n\\n1.) See it from the adversary angle - what could someone argue about your proof, and how you plug those holes so that you answer the question before it happens, and\\n2.) See it from the learner\\'s angle - some facts could be obvious to you, but not the reader.\\n\\nI hope that helps you."
                    },
                    {
                        "username": "niraj243",
                        "content": "Can somenone explain why my solution is giving Runtime error  \n\"Line 1034: Char 34: runtime error: applying non-zero offset 4 to null pointer (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\"\nBut when I change  `return (v1[1] <= v2[1]);` to `return (v1[1] < v2[1]);` in cmp function. It works, but why ??\n```cpp\nclass Solution {\npublic:\n    static bool cmp(vector<int> &v1,vector<int> &v2){\n        // return (v1[1] <= v2[1]); // gives error why ??\n        return (v1[1] < v2[1]);\n    }\n    bool isok(vector<int> i1,vector<int> i2){\n        return (i1[1]<=i2[0] || i1[0]>=i2[1]);\n    }\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        int n = intervals.size();\n        sort(intervals.begin(),intervals.end(),cmp);\n        vector<int> end(n);\n        for(int i=0;i<n;i++){\n            end[i] = intervals[i][1];\n        }\n        int ans=1;\n        vector<int> dp(n,1);\n        for(int i=1;i<n;i++){\n            int mx = 0;\n            int prev_ok = upper_bound(end.begin(),end.end(),intervals[i][0])-end.begin()-1;\n            if(prev_ok>=0)\n            mx = dp[prev_ok];\n            dp[i] = max(dp[i-1],mx+1);\n            ans = max(ans,dp[i]);\n        }\n        return n-ans;\n    }\n};\n```  "
                    },
                    {
                        "username": "AndreiZherder",
                        "content": "If you think about DP solution, it is very similar to problem we solved four days ago:\\n[1751. Maximum number of events that can be attended II](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/)\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "Sort the intervals based on their ending point and track the last relevant interval (i) and comp the curr index\\'s 0th point with tracked (i)\\'s 1st point and if it less then increase ans++ (skip this interval) otherwise we have to consider this and assign your track index to this index"
                    }
                ]
            },
            {
                "id": 1976882,
                "content": [
                    {
                        "username": "subz3r0",
                        "content": "Getting **TLE** for this. **HELP**\\n```\\nclass Solution {\\nprivate:\\n    static bool cmp (vector<int> a, vector<int> b) {\\n        return a[0] < b[0];\\n    }\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        int prevEnd = INT_MIN;\\n        int res = 0;\\n        for (vector<int> interval: intervals) {\\n            if (interval[0] >= prevEnd) {\\n                // no overlap\\n                prevEnd = interval[1];\\n            }\\n            else {\\n                // overlap\\n                res++;\\n                prevEnd = min(prevEnd, interval[1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "OP101202",
                        "content": "[@asahoo27](/asahoo27) without cmp it won\\'t work , it is must."
                    },
                    {
                        "username": "asahoo27",
                        "content": "``` sort(intervals.begin(),intervals.end());```  just use this no need of cmp"
                    },
                    {
                        "username": "saisantosh3007",
                        "content": "[@1111aakansharao](/1111aakansharao) Thank you for this"
                    },
                    {
                        "username": "1111aakansharao",
                        "content": "your cmp function containg parameters as vectors, you need to pass it by reference beacause by value it will take a longer time and changes will not be reflected.\\n```\\nstatic bool cmp (vector<int>&a, vector<int>&b) {\\n        return a[0] < b[0];\\n    }\\n```\\nHope this helps you !\\nKeep hustlin :)"
                    },
                    {
                        "username": "Aiyaz123",
                        "content": "Thats the great solution tbh, easy and simple to understand.. "
                    },
                    {
                        "username": "Gaurav_Upreti",
                        "content": "Use pass by reference in cmp function, i.e. cmp(vector<int> &a, vector<int> &b)."
                    },
                    {
                        "username": "subz3r0",
                        "content": "I\\'m not sure why but the compare function was causing the TLE !! -_- "
                    },
                    {
                        "username": "rishavjain",
                        "content": "Time Limit Exceeded\\n58 / 58 testcases passed\\n?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Just regard it as a regular TLE ."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "show your code \nstatic bool cmp (vector<int>&a, vector<int>&b) {\n        return a[0] < b[0];\n    }\nhere a lot of ppl didnt pass the vector by reference are getting the same error as you perhaps that is the issue in your code"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So I\\'ve looked at an *awful lot* of solutions but nobody explains why their solution can be relied on to remove the minimum number of intervals. My first solution didn\\'t. I assume all the posted solutions do but after 5 pages of them I gave up hoping that somebody would explain how they met that part of the spec. Does anybody here have a solution where they know why it removes the minimum number of intervals? Can they explain why? Can ANYONE explain why?"
                    },
                    {
                        "username": "jfitzg7",
                        "content": "It helped me to visualize it by organizing intervals with the same end dates (sorted in ascending order) into groups. In the best case, if there is at least one interval in each group that doesn\\'t overlap with the previous group, you will be able to pick one interval from each group and discard the rest. It helps to look at the cases when there are 1 groups, 2 groups, 3 groups, etc.\\n\\n1 group: You can only pick 1 interval from the first group.\\n\\n2 groups: If all the intervals in the second group overlap with the first groups end date, then we will only be able to pick 1 interval. If only some (or none) overlapped, then we would be able to pick 2 intervals, one from the first group and another from the second group. But it\\'s not yet clear why we should be greedy.\\n\\n3 groups: Let\\'s say all the intervals in the second group overlap with the first group so that we would only be able to pick a single interval from one or the other, but which group do we pick from? If we pick from the second group instead of the first group, then this becomes a problem when all of the intervals in the third group overlap the second group (and maybe some overlap the first, but not all). If we had picked from the first group, then we would have been able to pick from the third group as well. If some or none of the intervals in the second group overlap the first, then we would greedily pick from the second group and it basically gets boiled down into the 2 groups case when dealing with the third group.\\n\\nIt gets complicated when looking at examples with more groups and thinking of all the cases, but hopefully this is a good starting point and can help give a different perspective. I think why this problem is so hard is that there are many cases to consider, and I needed to use this idea of grouping the intervals together just to make sense of why the greedy approach works."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, I can explain why the greedy algorithm that chooses to keep intervals with the earliest end time will remove the minimum number of intervals. This is a result of how the greedy strategy prioritizes creating the maximum room for the remaining intervals, which minimizes the number of intervals that have to be removed.\\n\\nThe key here is that if you have two overlapping intervals, keeping the one that ends earliest will leave more room for the remaining intervals. \\n\\nConsider two overlapping intervals, interval A and interval B, where A ends before B. \\n\\n```\\nA: |------|\\nB:     |---------|\\n```\\nIf you keep interval B, any subsequent interval cannot start until after B ends. But if you keep A, subsequent intervals can start right after A ends, providing more room for other intervals. Therefore, keeping A, the interval with the earliest end time, will allow us to fit in the most intervals, thereby minimizing the number we need to remove.\\n\\nTo generalize, we sort all intervals by end time, then iterate through the sorted list. We always keep the interval with the earliest end time among all overlapping intervals, and remove the others. By doing so, we can ensure that we\\'ve made the most room for the remaining intervals, thereby minimizing the number of intervals we need to remove.\\n\\nThis strategy satisfies the problem\\'s requirement of removing the minimum number of intervals because we\\'re always maximizing the space for the remaining intervals at each step, which is the key to minimizing removals."
                    },
                    {
                        "username": "shakthi4526",
                        "content": "Removing minimum number of intervals is the same as KEEPING maximum number of intervals. \\n\\nNow, if you look at it as scheduling maximum number of meetings in a room, then you should get it.\\nFor those unfamiliar with the Meeting scheduling problem, it is similar to this problem here, but each interval [start,end] represents the start and end time of a meeting. As there is only one room and we can have only one meeting at a time, we want to find maximum number of meetings we can schedule (in other words reject minimum number of meetings).\\n\\nAgain we sort by end times. Why? Because regardless of when a meeting starts, a meeting that ends first leaves more time for other meetings to take place. We do not want a meeting that starts early and ends late, what we really care about is when the meeting ends and how much time it leaves for the other meetings. So, sort by endtimes, remove all overlapping meetings to get maximum meetings or reject minimum meetings. Same logic applies here in this problem."
                    },
                    {
                        "username": "magicsign",
                        "content": "You can understand the solution by visualizing the intervals as lines. The key first of all is sorting the intervals by their ending point. For example say you have: [1,11],[2,12],[11,22],[1,100] , notice all intervals are sorted in ascending order based on their ending point.\\n\\nNow if you keep 2 pointers, prev and curr and a counter, prev gets initialized to [1,11], curr to [2,12]. 11 > 2 so it means that the interval [1,11] overlaps [2,12], we can remove [2,12] and in our case we increment our counter by one.\\nprev is [1,11], curr is [11,22], 11 > 11 no, so no overlapping. We need to move prev pointer to [11,22] to perform the next comparisons because we know that the previous intervals are non overlapping.\\n\\nprev is [11,22], curr is [1,100], 22 > 1, yes, we remove [1,100] or in another words, increment our counter. We reached the end with counter set to 2. "
                    },
                    {
                        "username": "lcgt",
                        "content": "I cant seem to think of a case where removing the latter interval is a bad idea, but it is a source of uncertainty."
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s consider a scenario where you might be tempted to remove a later interval, but it\\'s actually not the best move. Take a look at these intervals:\\n\\n```\\n[[1,10],[2,3],[4,5],[6,7],[8,9]]\\n```\\n\\nIn this case, interval [1,10] overlaps with all other intervals. Now, you might think to remove a later interval, say [8,9], because it\\'s later and removing it seems like it would minimize the overlaps.\\n\\nBut removing any of [2,3],[4,5],[6,7],[8,9] won\\'t solve the problem because they are not the root cause of the overlaps. The real issue is with the [1,10] interval, because it overlaps with all others. If you remove [1,10], you\\'ll only have to remove one interval and none of the remaining intervals overlap.\\n\\nThis illustrates that sometimes the best move is to remove an interval that isn\\'t necessarily the latest one, but the one that causes the most overlaps. It\\'s why the strategy of always removing the interval with the latest end time works \\u2013 it maximizes the room for other intervals and decreases the chances of overlaps."
                    },
                    {
                        "username": "ajv97",
                        "content": "Think this array as a list of start and end times of your favourite movies in a theatre where you can watch anything for free for that day.(you never get tired and you can teleport-only after the movie ends)\\nNow wouldn\\'t you be GREEDY and try to watch the maximum amount of movies.\\nBut you would also want the movie list to be SORTED by end time to get a better overview."
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can start by considering intervals in some \"natural\" order.\\n1. Earliest start time\\n![image.png](https://assets.leetcode.com/users/images/9ae02534-c9af-4239-b5f6-e1bdd43feaa0_1684388688.0637023.png)\\n2. Earliest finish time\\n3. Shortest interval\\n![image.png](https://assets.leetcode.com/users/images/70407e84-c791-40da-9e62-c2b4506ef72d_1684388702.40602.png)\\n4. Fewest conflicts\\n![image.png](https://assets.leetcode.com/users/images/e70553be-2b51-4c03-804b-0c6939de7391_1684388714.3131933.png)\\nWe found some counterexamples for 1, 2 and 4.\\nNow let\\'s prove why greedy with EFT works.\\n# Proof of optimality by contradiction\\n- Suppose for contradiction that greedy is not optimal\\n- Say greedy selects interval `\\uD835\\uDC561, \\uD835\\uDC562, \\u2026 , \\uD835\\uDC56\\uD835\\uDC58` sorted by finish time\\n- Consider an optimal solution `\\uD835\\uDC571,\\uD835\\uDC572, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5A` (also sorted by finish time) which matches greedy for as many indices as possible\\n    - That is, we want `\\uD835\\uDC571 = \\uD835\\uDC561, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5F = \\uD835\\uDC56\\uD835\\uDC5F` for the greatest possible `\\uD835\\uDC5F`\\n- Both `\\uD835\\uDC56\\uD835\\uDC5F+1` and `\\uD835\\uDC57\\uD835\\uDC5F+1` must be compatible with the previous selection\\n`(\\uD835\\uDC561 = \\uD835\\uDC571, \\u2026 , \\uD835\\uDC56\\uD835\\uDC5F = \\uD835\\uDC57\\uD835\\uDC5F)`\\n- Consider a new solution `\\uD835\\uDC561, \\uD835\\uDC562, \\u2026 , \\uD835\\uDC56\\uD835\\uDC5F, \\uD835\\uDC56\\uD835\\uDC5F+1,\\uD835\\uDC57\\uD835\\uDC5F+2, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5A`\\n- We have replaced `\\uD835\\uDC57\\uD835\\uDC5F+1` by `\\uD835\\uDC56\\uD835\\uDC5F+1` in our reference optimal solution\\n- This is still feasible because `\\uD835\\uDC53\\uD835\\uDC56\\uD835\\uDC5F+1 \\u2264 \\uD835\\uDC53\\uD835\\uDC57\\uD835\\uDC5F+1 \\u2264 \\uD835\\uDC60\\uD835\\uDC57\\uD835\\uDC61`\\nfor `\\uD835\\uDC61 \\u2265 \\uD835\\uDC5F + 2` where `\\uD835\\uDC53\\uD835\\uDC56` is the finish time for interval `i`.\\n- This is still optimal because `\\uD835\\uDC5A` intervals are selected.\\n- But it matches the greedy solution in \\uD835\\uDC5F + 1 indices\\n    - This is the desired contradiction\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort intervals by finish time.\\n2. For each interval `j` we check if it\\'s compatible with the last added interval `i`. If not, increase `res` and `j`, otherwise increate `i` and `j`. "
                    },
                    {
                        "username": "Leaderboard",
                        "content": "> We found some counterexamples for 1, 2 and 4.\\n\\nShould it not be \"1, 3 and 4\"?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "So many of you comment like I\\'m reading ChatGPT. You may have a proper solution but its improperly explained with holes and leaps in the logic or its just flat out word salad with no meaning.\\n\\nYou can basically boil this down to sorting by start position and greedily picking the intervals that end first. This is optimal precisely because given some starting position (suppose you consider only the intervals with starts after some $$X$$, in practice $$X$$ is the end of the last chosen interval). Then you should always pick the next interval which ends first, call it interval $$F$$\\n\\nThe proof is simple, suppose the interval $$F$$  isn\\'t part of the optimal choices, then that means that there is some interval, $$Q$$, which overlaps it you should pick instead  that gives you better choices later on somehow. However picking $$Q$$ can be no better than picking $$F$$ because you could always copy remaining ones after $$Q$$ even if you picked $$F$$ because we assumed $$F$$ is the one that ends first."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@cecilia5](/cecilia5) I didn\\'t not provide the complete proof because I wanted to leave some minor details as an exercise to the reader.\\n\\nHowever the details are that $$F$$ is assumed not to be a trivial choice, I.E it must be overlapping something else. \\n\\nIf it doesn\\'t overlap anything you must always include it because you are maximizing intervals. This removes the possibility that $$Q$$ doesn\\'t overlap.\\n\\nSecondly because $$F$$ is assumed to end first, then there cannot be anything before it. The endpoints of other intervals are at or after it. So there cannot be these theoretical intervals that are choosable before it that don\\'t overlap with $$Q$$. "
                    },
                    {
                        "username": "cecilia5",
                        "content": "There are a few things I nit picked from your comment. It is not meant to say you have a problem, please take that as an opportunity for you to improve your writing:\\n\\nThis is optimal precisely because [...], but the [...] doesn\\'t explain why it is optimal, it just describe the algorithm, and it isn\\'t complete (it doesn\\'t talk about skipping the conflicting ones, which is probably obvious \"to you\")\\n\\nFor the proof itself:\\n\\nI rather you not say the proof is simple - people looking for proofs find it hard - that\\'s why they are looking for it.\\n\\nYou didn\\'t explain why if `F` is not part of the optimal choice, then there exists `Q` that overlaps with it.\\n\\nYou also didn\\'t show why copy the remaining after `Q` is enough, what if the optimal solution including `Q` can include a lot more intervals before `Q`?\\n\\nYour idea is right on, and your proof could be polished to become a flawless one, you just need to:\\n\\n1.) See it from the adversary angle - what could someone argue about your proof, and how you plug those holes so that you answer the question before it happens, and\\n2.) See it from the learner\\'s angle - some facts could be obvious to you, but not the reader.\\n\\nI hope that helps you."
                    },
                    {
                        "username": "niraj243",
                        "content": "Can somenone explain why my solution is giving Runtime error  \n\"Line 1034: Char 34: runtime error: applying non-zero offset 4 to null pointer (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\"\nBut when I change  `return (v1[1] <= v2[1]);` to `return (v1[1] < v2[1]);` in cmp function. It works, but why ??\n```cpp\nclass Solution {\npublic:\n    static bool cmp(vector<int> &v1,vector<int> &v2){\n        // return (v1[1] <= v2[1]); // gives error why ??\n        return (v1[1] < v2[1]);\n    }\n    bool isok(vector<int> i1,vector<int> i2){\n        return (i1[1]<=i2[0] || i1[0]>=i2[1]);\n    }\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        int n = intervals.size();\n        sort(intervals.begin(),intervals.end(),cmp);\n        vector<int> end(n);\n        for(int i=0;i<n;i++){\n            end[i] = intervals[i][1];\n        }\n        int ans=1;\n        vector<int> dp(n,1);\n        for(int i=1;i<n;i++){\n            int mx = 0;\n            int prev_ok = upper_bound(end.begin(),end.end(),intervals[i][0])-end.begin()-1;\n            if(prev_ok>=0)\n            mx = dp[prev_ok];\n            dp[i] = max(dp[i-1],mx+1);\n            ans = max(ans,dp[i]);\n        }\n        return n-ans;\n    }\n};\n```  "
                    },
                    {
                        "username": "AndreiZherder",
                        "content": "If you think about DP solution, it is very similar to problem we solved four days ago:\\n[1751. Maximum number of events that can be attended II](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/)\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "Sort the intervals based on their ending point and track the last relevant interval (i) and comp the curr index\\'s 0th point with tracked (i)\\'s 1st point and if it less then increase ans++ (skip this interval) otherwise we have to consider this and assign your track index to this index"
                    }
                ]
            },
            {
                "id": 1897747,
                "content": [
                    {
                        "username": "subz3r0",
                        "content": "Getting **TLE** for this. **HELP**\\n```\\nclass Solution {\\nprivate:\\n    static bool cmp (vector<int> a, vector<int> b) {\\n        return a[0] < b[0];\\n    }\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        int prevEnd = INT_MIN;\\n        int res = 0;\\n        for (vector<int> interval: intervals) {\\n            if (interval[0] >= prevEnd) {\\n                // no overlap\\n                prevEnd = interval[1];\\n            }\\n            else {\\n                // overlap\\n                res++;\\n                prevEnd = min(prevEnd, interval[1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "OP101202",
                        "content": "[@asahoo27](/asahoo27) without cmp it won\\'t work , it is must."
                    },
                    {
                        "username": "asahoo27",
                        "content": "``` sort(intervals.begin(),intervals.end());```  just use this no need of cmp"
                    },
                    {
                        "username": "saisantosh3007",
                        "content": "[@1111aakansharao](/1111aakansharao) Thank you for this"
                    },
                    {
                        "username": "1111aakansharao",
                        "content": "your cmp function containg parameters as vectors, you need to pass it by reference beacause by value it will take a longer time and changes will not be reflected.\\n```\\nstatic bool cmp (vector<int>&a, vector<int>&b) {\\n        return a[0] < b[0];\\n    }\\n```\\nHope this helps you !\\nKeep hustlin :)"
                    },
                    {
                        "username": "Aiyaz123",
                        "content": "Thats the great solution tbh, easy and simple to understand.. "
                    },
                    {
                        "username": "Gaurav_Upreti",
                        "content": "Use pass by reference in cmp function, i.e. cmp(vector<int> &a, vector<int> &b)."
                    },
                    {
                        "username": "subz3r0",
                        "content": "I\\'m not sure why but the compare function was causing the TLE !! -_- "
                    },
                    {
                        "username": "rishavjain",
                        "content": "Time Limit Exceeded\\n58 / 58 testcases passed\\n?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Just regard it as a regular TLE ."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "show your code \nstatic bool cmp (vector<int>&a, vector<int>&b) {\n        return a[0] < b[0];\n    }\nhere a lot of ppl didnt pass the vector by reference are getting the same error as you perhaps that is the issue in your code"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So I\\'ve looked at an *awful lot* of solutions but nobody explains why their solution can be relied on to remove the minimum number of intervals. My first solution didn\\'t. I assume all the posted solutions do but after 5 pages of them I gave up hoping that somebody would explain how they met that part of the spec. Does anybody here have a solution where they know why it removes the minimum number of intervals? Can they explain why? Can ANYONE explain why?"
                    },
                    {
                        "username": "jfitzg7",
                        "content": "It helped me to visualize it by organizing intervals with the same end dates (sorted in ascending order) into groups. In the best case, if there is at least one interval in each group that doesn\\'t overlap with the previous group, you will be able to pick one interval from each group and discard the rest. It helps to look at the cases when there are 1 groups, 2 groups, 3 groups, etc.\\n\\n1 group: You can only pick 1 interval from the first group.\\n\\n2 groups: If all the intervals in the second group overlap with the first groups end date, then we will only be able to pick 1 interval. If only some (or none) overlapped, then we would be able to pick 2 intervals, one from the first group and another from the second group. But it\\'s not yet clear why we should be greedy.\\n\\n3 groups: Let\\'s say all the intervals in the second group overlap with the first group so that we would only be able to pick a single interval from one or the other, but which group do we pick from? If we pick from the second group instead of the first group, then this becomes a problem when all of the intervals in the third group overlap the second group (and maybe some overlap the first, but not all). If we had picked from the first group, then we would have been able to pick from the third group as well. If some or none of the intervals in the second group overlap the first, then we would greedily pick from the second group and it basically gets boiled down into the 2 groups case when dealing with the third group.\\n\\nIt gets complicated when looking at examples with more groups and thinking of all the cases, but hopefully this is a good starting point and can help give a different perspective. I think why this problem is so hard is that there are many cases to consider, and I needed to use this idea of grouping the intervals together just to make sense of why the greedy approach works."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, I can explain why the greedy algorithm that chooses to keep intervals with the earliest end time will remove the minimum number of intervals. This is a result of how the greedy strategy prioritizes creating the maximum room for the remaining intervals, which minimizes the number of intervals that have to be removed.\\n\\nThe key here is that if you have two overlapping intervals, keeping the one that ends earliest will leave more room for the remaining intervals. \\n\\nConsider two overlapping intervals, interval A and interval B, where A ends before B. \\n\\n```\\nA: |------|\\nB:     |---------|\\n```\\nIf you keep interval B, any subsequent interval cannot start until after B ends. But if you keep A, subsequent intervals can start right after A ends, providing more room for other intervals. Therefore, keeping A, the interval with the earliest end time, will allow us to fit in the most intervals, thereby minimizing the number we need to remove.\\n\\nTo generalize, we sort all intervals by end time, then iterate through the sorted list. We always keep the interval with the earliest end time among all overlapping intervals, and remove the others. By doing so, we can ensure that we\\'ve made the most room for the remaining intervals, thereby minimizing the number of intervals we need to remove.\\n\\nThis strategy satisfies the problem\\'s requirement of removing the minimum number of intervals because we\\'re always maximizing the space for the remaining intervals at each step, which is the key to minimizing removals."
                    },
                    {
                        "username": "shakthi4526",
                        "content": "Removing minimum number of intervals is the same as KEEPING maximum number of intervals. \\n\\nNow, if you look at it as scheduling maximum number of meetings in a room, then you should get it.\\nFor those unfamiliar with the Meeting scheduling problem, it is similar to this problem here, but each interval [start,end] represents the start and end time of a meeting. As there is only one room and we can have only one meeting at a time, we want to find maximum number of meetings we can schedule (in other words reject minimum number of meetings).\\n\\nAgain we sort by end times. Why? Because regardless of when a meeting starts, a meeting that ends first leaves more time for other meetings to take place. We do not want a meeting that starts early and ends late, what we really care about is when the meeting ends and how much time it leaves for the other meetings. So, sort by endtimes, remove all overlapping meetings to get maximum meetings or reject minimum meetings. Same logic applies here in this problem."
                    },
                    {
                        "username": "magicsign",
                        "content": "You can understand the solution by visualizing the intervals as lines. The key first of all is sorting the intervals by their ending point. For example say you have: [1,11],[2,12],[11,22],[1,100] , notice all intervals are sorted in ascending order based on their ending point.\\n\\nNow if you keep 2 pointers, prev and curr and a counter, prev gets initialized to [1,11], curr to [2,12]. 11 > 2 so it means that the interval [1,11] overlaps [2,12], we can remove [2,12] and in our case we increment our counter by one.\\nprev is [1,11], curr is [11,22], 11 > 11 no, so no overlapping. We need to move prev pointer to [11,22] to perform the next comparisons because we know that the previous intervals are non overlapping.\\n\\nprev is [11,22], curr is [1,100], 22 > 1, yes, we remove [1,100] or in another words, increment our counter. We reached the end with counter set to 2. "
                    },
                    {
                        "username": "lcgt",
                        "content": "I cant seem to think of a case where removing the latter interval is a bad idea, but it is a source of uncertainty."
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s consider a scenario where you might be tempted to remove a later interval, but it\\'s actually not the best move. Take a look at these intervals:\\n\\n```\\n[[1,10],[2,3],[4,5],[6,7],[8,9]]\\n```\\n\\nIn this case, interval [1,10] overlaps with all other intervals. Now, you might think to remove a later interval, say [8,9], because it\\'s later and removing it seems like it would minimize the overlaps.\\n\\nBut removing any of [2,3],[4,5],[6,7],[8,9] won\\'t solve the problem because they are not the root cause of the overlaps. The real issue is with the [1,10] interval, because it overlaps with all others. If you remove [1,10], you\\'ll only have to remove one interval and none of the remaining intervals overlap.\\n\\nThis illustrates that sometimes the best move is to remove an interval that isn\\'t necessarily the latest one, but the one that causes the most overlaps. It\\'s why the strategy of always removing the interval with the latest end time works \\u2013 it maximizes the room for other intervals and decreases the chances of overlaps."
                    },
                    {
                        "username": "ajv97",
                        "content": "Think this array as a list of start and end times of your favourite movies in a theatre where you can watch anything for free for that day.(you never get tired and you can teleport-only after the movie ends)\\nNow wouldn\\'t you be GREEDY and try to watch the maximum amount of movies.\\nBut you would also want the movie list to be SORTED by end time to get a better overview."
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can start by considering intervals in some \"natural\" order.\\n1. Earliest start time\\n![image.png](https://assets.leetcode.com/users/images/9ae02534-c9af-4239-b5f6-e1bdd43feaa0_1684388688.0637023.png)\\n2. Earliest finish time\\n3. Shortest interval\\n![image.png](https://assets.leetcode.com/users/images/70407e84-c791-40da-9e62-c2b4506ef72d_1684388702.40602.png)\\n4. Fewest conflicts\\n![image.png](https://assets.leetcode.com/users/images/e70553be-2b51-4c03-804b-0c6939de7391_1684388714.3131933.png)\\nWe found some counterexamples for 1, 2 and 4.\\nNow let\\'s prove why greedy with EFT works.\\n# Proof of optimality by contradiction\\n- Suppose for contradiction that greedy is not optimal\\n- Say greedy selects interval `\\uD835\\uDC561, \\uD835\\uDC562, \\u2026 , \\uD835\\uDC56\\uD835\\uDC58` sorted by finish time\\n- Consider an optimal solution `\\uD835\\uDC571,\\uD835\\uDC572, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5A` (also sorted by finish time) which matches greedy for as many indices as possible\\n    - That is, we want `\\uD835\\uDC571 = \\uD835\\uDC561, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5F = \\uD835\\uDC56\\uD835\\uDC5F` for the greatest possible `\\uD835\\uDC5F`\\n- Both `\\uD835\\uDC56\\uD835\\uDC5F+1` and `\\uD835\\uDC57\\uD835\\uDC5F+1` must be compatible with the previous selection\\n`(\\uD835\\uDC561 = \\uD835\\uDC571, \\u2026 , \\uD835\\uDC56\\uD835\\uDC5F = \\uD835\\uDC57\\uD835\\uDC5F)`\\n- Consider a new solution `\\uD835\\uDC561, \\uD835\\uDC562, \\u2026 , \\uD835\\uDC56\\uD835\\uDC5F, \\uD835\\uDC56\\uD835\\uDC5F+1,\\uD835\\uDC57\\uD835\\uDC5F+2, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5A`\\n- We have replaced `\\uD835\\uDC57\\uD835\\uDC5F+1` by `\\uD835\\uDC56\\uD835\\uDC5F+1` in our reference optimal solution\\n- This is still feasible because `\\uD835\\uDC53\\uD835\\uDC56\\uD835\\uDC5F+1 \\u2264 \\uD835\\uDC53\\uD835\\uDC57\\uD835\\uDC5F+1 \\u2264 \\uD835\\uDC60\\uD835\\uDC57\\uD835\\uDC61`\\nfor `\\uD835\\uDC61 \\u2265 \\uD835\\uDC5F + 2` where `\\uD835\\uDC53\\uD835\\uDC56` is the finish time for interval `i`.\\n- This is still optimal because `\\uD835\\uDC5A` intervals are selected.\\n- But it matches the greedy solution in \\uD835\\uDC5F + 1 indices\\n    - This is the desired contradiction\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort intervals by finish time.\\n2. For each interval `j` we check if it\\'s compatible with the last added interval `i`. If not, increase `res` and `j`, otherwise increate `i` and `j`. "
                    },
                    {
                        "username": "Leaderboard",
                        "content": "> We found some counterexamples for 1, 2 and 4.\\n\\nShould it not be \"1, 3 and 4\"?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "So many of you comment like I\\'m reading ChatGPT. You may have a proper solution but its improperly explained with holes and leaps in the logic or its just flat out word salad with no meaning.\\n\\nYou can basically boil this down to sorting by start position and greedily picking the intervals that end first. This is optimal precisely because given some starting position (suppose you consider only the intervals with starts after some $$X$$, in practice $$X$$ is the end of the last chosen interval). Then you should always pick the next interval which ends first, call it interval $$F$$\\n\\nThe proof is simple, suppose the interval $$F$$  isn\\'t part of the optimal choices, then that means that there is some interval, $$Q$$, which overlaps it you should pick instead  that gives you better choices later on somehow. However picking $$Q$$ can be no better than picking $$F$$ because you could always copy remaining ones after $$Q$$ even if you picked $$F$$ because we assumed $$F$$ is the one that ends first."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@cecilia5](/cecilia5) I didn\\'t not provide the complete proof because I wanted to leave some minor details as an exercise to the reader.\\n\\nHowever the details are that $$F$$ is assumed not to be a trivial choice, I.E it must be overlapping something else. \\n\\nIf it doesn\\'t overlap anything you must always include it because you are maximizing intervals. This removes the possibility that $$Q$$ doesn\\'t overlap.\\n\\nSecondly because $$F$$ is assumed to end first, then there cannot be anything before it. The endpoints of other intervals are at or after it. So there cannot be these theoretical intervals that are choosable before it that don\\'t overlap with $$Q$$. "
                    },
                    {
                        "username": "cecilia5",
                        "content": "There are a few things I nit picked from your comment. It is not meant to say you have a problem, please take that as an opportunity for you to improve your writing:\\n\\nThis is optimal precisely because [...], but the [...] doesn\\'t explain why it is optimal, it just describe the algorithm, and it isn\\'t complete (it doesn\\'t talk about skipping the conflicting ones, which is probably obvious \"to you\")\\n\\nFor the proof itself:\\n\\nI rather you not say the proof is simple - people looking for proofs find it hard - that\\'s why they are looking for it.\\n\\nYou didn\\'t explain why if `F` is not part of the optimal choice, then there exists `Q` that overlaps with it.\\n\\nYou also didn\\'t show why copy the remaining after `Q` is enough, what if the optimal solution including `Q` can include a lot more intervals before `Q`?\\n\\nYour idea is right on, and your proof could be polished to become a flawless one, you just need to:\\n\\n1.) See it from the adversary angle - what could someone argue about your proof, and how you plug those holes so that you answer the question before it happens, and\\n2.) See it from the learner\\'s angle - some facts could be obvious to you, but not the reader.\\n\\nI hope that helps you."
                    },
                    {
                        "username": "niraj243",
                        "content": "Can somenone explain why my solution is giving Runtime error  \n\"Line 1034: Char 34: runtime error: applying non-zero offset 4 to null pointer (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\"\nBut when I change  `return (v1[1] <= v2[1]);` to `return (v1[1] < v2[1]);` in cmp function. It works, but why ??\n```cpp\nclass Solution {\npublic:\n    static bool cmp(vector<int> &v1,vector<int> &v2){\n        // return (v1[1] <= v2[1]); // gives error why ??\n        return (v1[1] < v2[1]);\n    }\n    bool isok(vector<int> i1,vector<int> i2){\n        return (i1[1]<=i2[0] || i1[0]>=i2[1]);\n    }\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        int n = intervals.size();\n        sort(intervals.begin(),intervals.end(),cmp);\n        vector<int> end(n);\n        for(int i=0;i<n;i++){\n            end[i] = intervals[i][1];\n        }\n        int ans=1;\n        vector<int> dp(n,1);\n        for(int i=1;i<n;i++){\n            int mx = 0;\n            int prev_ok = upper_bound(end.begin(),end.end(),intervals[i][0])-end.begin()-1;\n            if(prev_ok>=0)\n            mx = dp[prev_ok];\n            dp[i] = max(dp[i-1],mx+1);\n            ans = max(ans,dp[i]);\n        }\n        return n-ans;\n    }\n};\n```  "
                    },
                    {
                        "username": "AndreiZherder",
                        "content": "If you think about DP solution, it is very similar to problem we solved four days ago:\\n[1751. Maximum number of events that can be attended II](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/)\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "Sort the intervals based on their ending point and track the last relevant interval (i) and comp the curr index\\'s 0th point with tracked (i)\\'s 1st point and if it less then increase ans++ (skip this interval) otherwise we have to consider this and assign your track index to this index"
                    }
                ]
            },
            {
                "id": 1977392,
                "content": [
                    {
                        "username": "subz3r0",
                        "content": "Getting **TLE** for this. **HELP**\\n```\\nclass Solution {\\nprivate:\\n    static bool cmp (vector<int> a, vector<int> b) {\\n        return a[0] < b[0];\\n    }\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        int prevEnd = INT_MIN;\\n        int res = 0;\\n        for (vector<int> interval: intervals) {\\n            if (interval[0] >= prevEnd) {\\n                // no overlap\\n                prevEnd = interval[1];\\n            }\\n            else {\\n                // overlap\\n                res++;\\n                prevEnd = min(prevEnd, interval[1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "OP101202",
                        "content": "[@asahoo27](/asahoo27) without cmp it won\\'t work , it is must."
                    },
                    {
                        "username": "asahoo27",
                        "content": "``` sort(intervals.begin(),intervals.end());```  just use this no need of cmp"
                    },
                    {
                        "username": "saisantosh3007",
                        "content": "[@1111aakansharao](/1111aakansharao) Thank you for this"
                    },
                    {
                        "username": "1111aakansharao",
                        "content": "your cmp function containg parameters as vectors, you need to pass it by reference beacause by value it will take a longer time and changes will not be reflected.\\n```\\nstatic bool cmp (vector<int>&a, vector<int>&b) {\\n        return a[0] < b[0];\\n    }\\n```\\nHope this helps you !\\nKeep hustlin :)"
                    },
                    {
                        "username": "Aiyaz123",
                        "content": "Thats the great solution tbh, easy and simple to understand.. "
                    },
                    {
                        "username": "Gaurav_Upreti",
                        "content": "Use pass by reference in cmp function, i.e. cmp(vector<int> &a, vector<int> &b)."
                    },
                    {
                        "username": "subz3r0",
                        "content": "I\\'m not sure why but the compare function was causing the TLE !! -_- "
                    },
                    {
                        "username": "rishavjain",
                        "content": "Time Limit Exceeded\\n58 / 58 testcases passed\\n?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Just regard it as a regular TLE ."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "show your code \nstatic bool cmp (vector<int>&a, vector<int>&b) {\n        return a[0] < b[0];\n    }\nhere a lot of ppl didnt pass the vector by reference are getting the same error as you perhaps that is the issue in your code"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So I\\'ve looked at an *awful lot* of solutions but nobody explains why their solution can be relied on to remove the minimum number of intervals. My first solution didn\\'t. I assume all the posted solutions do but after 5 pages of them I gave up hoping that somebody would explain how they met that part of the spec. Does anybody here have a solution where they know why it removes the minimum number of intervals? Can they explain why? Can ANYONE explain why?"
                    },
                    {
                        "username": "jfitzg7",
                        "content": "It helped me to visualize it by organizing intervals with the same end dates (sorted in ascending order) into groups. In the best case, if there is at least one interval in each group that doesn\\'t overlap with the previous group, you will be able to pick one interval from each group and discard the rest. It helps to look at the cases when there are 1 groups, 2 groups, 3 groups, etc.\\n\\n1 group: You can only pick 1 interval from the first group.\\n\\n2 groups: If all the intervals in the second group overlap with the first groups end date, then we will only be able to pick 1 interval. If only some (or none) overlapped, then we would be able to pick 2 intervals, one from the first group and another from the second group. But it\\'s not yet clear why we should be greedy.\\n\\n3 groups: Let\\'s say all the intervals in the second group overlap with the first group so that we would only be able to pick a single interval from one or the other, but which group do we pick from? If we pick from the second group instead of the first group, then this becomes a problem when all of the intervals in the third group overlap the second group (and maybe some overlap the first, but not all). If we had picked from the first group, then we would have been able to pick from the third group as well. If some or none of the intervals in the second group overlap the first, then we would greedily pick from the second group and it basically gets boiled down into the 2 groups case when dealing with the third group.\\n\\nIt gets complicated when looking at examples with more groups and thinking of all the cases, but hopefully this is a good starting point and can help give a different perspective. I think why this problem is so hard is that there are many cases to consider, and I needed to use this idea of grouping the intervals together just to make sense of why the greedy approach works."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, I can explain why the greedy algorithm that chooses to keep intervals with the earliest end time will remove the minimum number of intervals. This is a result of how the greedy strategy prioritizes creating the maximum room for the remaining intervals, which minimizes the number of intervals that have to be removed.\\n\\nThe key here is that if you have two overlapping intervals, keeping the one that ends earliest will leave more room for the remaining intervals. \\n\\nConsider two overlapping intervals, interval A and interval B, where A ends before B. \\n\\n```\\nA: |------|\\nB:     |---------|\\n```\\nIf you keep interval B, any subsequent interval cannot start until after B ends. But if you keep A, subsequent intervals can start right after A ends, providing more room for other intervals. Therefore, keeping A, the interval with the earliest end time, will allow us to fit in the most intervals, thereby minimizing the number we need to remove.\\n\\nTo generalize, we sort all intervals by end time, then iterate through the sorted list. We always keep the interval with the earliest end time among all overlapping intervals, and remove the others. By doing so, we can ensure that we\\'ve made the most room for the remaining intervals, thereby minimizing the number of intervals we need to remove.\\n\\nThis strategy satisfies the problem\\'s requirement of removing the minimum number of intervals because we\\'re always maximizing the space for the remaining intervals at each step, which is the key to minimizing removals."
                    },
                    {
                        "username": "shakthi4526",
                        "content": "Removing minimum number of intervals is the same as KEEPING maximum number of intervals. \\n\\nNow, if you look at it as scheduling maximum number of meetings in a room, then you should get it.\\nFor those unfamiliar with the Meeting scheduling problem, it is similar to this problem here, but each interval [start,end] represents the start and end time of a meeting. As there is only one room and we can have only one meeting at a time, we want to find maximum number of meetings we can schedule (in other words reject minimum number of meetings).\\n\\nAgain we sort by end times. Why? Because regardless of when a meeting starts, a meeting that ends first leaves more time for other meetings to take place. We do not want a meeting that starts early and ends late, what we really care about is when the meeting ends and how much time it leaves for the other meetings. So, sort by endtimes, remove all overlapping meetings to get maximum meetings or reject minimum meetings. Same logic applies here in this problem."
                    },
                    {
                        "username": "magicsign",
                        "content": "You can understand the solution by visualizing the intervals as lines. The key first of all is sorting the intervals by their ending point. For example say you have: [1,11],[2,12],[11,22],[1,100] , notice all intervals are sorted in ascending order based on their ending point.\\n\\nNow if you keep 2 pointers, prev and curr and a counter, prev gets initialized to [1,11], curr to [2,12]. 11 > 2 so it means that the interval [1,11] overlaps [2,12], we can remove [2,12] and in our case we increment our counter by one.\\nprev is [1,11], curr is [11,22], 11 > 11 no, so no overlapping. We need to move prev pointer to [11,22] to perform the next comparisons because we know that the previous intervals are non overlapping.\\n\\nprev is [11,22], curr is [1,100], 22 > 1, yes, we remove [1,100] or in another words, increment our counter. We reached the end with counter set to 2. "
                    },
                    {
                        "username": "lcgt",
                        "content": "I cant seem to think of a case where removing the latter interval is a bad idea, but it is a source of uncertainty."
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s consider a scenario where you might be tempted to remove a later interval, but it\\'s actually not the best move. Take a look at these intervals:\\n\\n```\\n[[1,10],[2,3],[4,5],[6,7],[8,9]]\\n```\\n\\nIn this case, interval [1,10] overlaps with all other intervals. Now, you might think to remove a later interval, say [8,9], because it\\'s later and removing it seems like it would minimize the overlaps.\\n\\nBut removing any of [2,3],[4,5],[6,7],[8,9] won\\'t solve the problem because they are not the root cause of the overlaps. The real issue is with the [1,10] interval, because it overlaps with all others. If you remove [1,10], you\\'ll only have to remove one interval and none of the remaining intervals overlap.\\n\\nThis illustrates that sometimes the best move is to remove an interval that isn\\'t necessarily the latest one, but the one that causes the most overlaps. It\\'s why the strategy of always removing the interval with the latest end time works \\u2013 it maximizes the room for other intervals and decreases the chances of overlaps."
                    },
                    {
                        "username": "ajv97",
                        "content": "Think this array as a list of start and end times of your favourite movies in a theatre where you can watch anything for free for that day.(you never get tired and you can teleport-only after the movie ends)\\nNow wouldn\\'t you be GREEDY and try to watch the maximum amount of movies.\\nBut you would also want the movie list to be SORTED by end time to get a better overview."
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can start by considering intervals in some \"natural\" order.\\n1. Earliest start time\\n![image.png](https://assets.leetcode.com/users/images/9ae02534-c9af-4239-b5f6-e1bdd43feaa0_1684388688.0637023.png)\\n2. Earliest finish time\\n3. Shortest interval\\n![image.png](https://assets.leetcode.com/users/images/70407e84-c791-40da-9e62-c2b4506ef72d_1684388702.40602.png)\\n4. Fewest conflicts\\n![image.png](https://assets.leetcode.com/users/images/e70553be-2b51-4c03-804b-0c6939de7391_1684388714.3131933.png)\\nWe found some counterexamples for 1, 2 and 4.\\nNow let\\'s prove why greedy with EFT works.\\n# Proof of optimality by contradiction\\n- Suppose for contradiction that greedy is not optimal\\n- Say greedy selects interval `\\uD835\\uDC561, \\uD835\\uDC562, \\u2026 , \\uD835\\uDC56\\uD835\\uDC58` sorted by finish time\\n- Consider an optimal solution `\\uD835\\uDC571,\\uD835\\uDC572, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5A` (also sorted by finish time) which matches greedy for as many indices as possible\\n    - That is, we want `\\uD835\\uDC571 = \\uD835\\uDC561, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5F = \\uD835\\uDC56\\uD835\\uDC5F` for the greatest possible `\\uD835\\uDC5F`\\n- Both `\\uD835\\uDC56\\uD835\\uDC5F+1` and `\\uD835\\uDC57\\uD835\\uDC5F+1` must be compatible with the previous selection\\n`(\\uD835\\uDC561 = \\uD835\\uDC571, \\u2026 , \\uD835\\uDC56\\uD835\\uDC5F = \\uD835\\uDC57\\uD835\\uDC5F)`\\n- Consider a new solution `\\uD835\\uDC561, \\uD835\\uDC562, \\u2026 , \\uD835\\uDC56\\uD835\\uDC5F, \\uD835\\uDC56\\uD835\\uDC5F+1,\\uD835\\uDC57\\uD835\\uDC5F+2, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5A`\\n- We have replaced `\\uD835\\uDC57\\uD835\\uDC5F+1` by `\\uD835\\uDC56\\uD835\\uDC5F+1` in our reference optimal solution\\n- This is still feasible because `\\uD835\\uDC53\\uD835\\uDC56\\uD835\\uDC5F+1 \\u2264 \\uD835\\uDC53\\uD835\\uDC57\\uD835\\uDC5F+1 \\u2264 \\uD835\\uDC60\\uD835\\uDC57\\uD835\\uDC61`\\nfor `\\uD835\\uDC61 \\u2265 \\uD835\\uDC5F + 2` where `\\uD835\\uDC53\\uD835\\uDC56` is the finish time for interval `i`.\\n- This is still optimal because `\\uD835\\uDC5A` intervals are selected.\\n- But it matches the greedy solution in \\uD835\\uDC5F + 1 indices\\n    - This is the desired contradiction\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort intervals by finish time.\\n2. For each interval `j` we check if it\\'s compatible with the last added interval `i`. If not, increase `res` and `j`, otherwise increate `i` and `j`. "
                    },
                    {
                        "username": "Leaderboard",
                        "content": "> We found some counterexamples for 1, 2 and 4.\\n\\nShould it not be \"1, 3 and 4\"?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "So many of you comment like I\\'m reading ChatGPT. You may have a proper solution but its improperly explained with holes and leaps in the logic or its just flat out word salad with no meaning.\\n\\nYou can basically boil this down to sorting by start position and greedily picking the intervals that end first. This is optimal precisely because given some starting position (suppose you consider only the intervals with starts after some $$X$$, in practice $$X$$ is the end of the last chosen interval). Then you should always pick the next interval which ends first, call it interval $$F$$\\n\\nThe proof is simple, suppose the interval $$F$$  isn\\'t part of the optimal choices, then that means that there is some interval, $$Q$$, which overlaps it you should pick instead  that gives you better choices later on somehow. However picking $$Q$$ can be no better than picking $$F$$ because you could always copy remaining ones after $$Q$$ even if you picked $$F$$ because we assumed $$F$$ is the one that ends first."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@cecilia5](/cecilia5) I didn\\'t not provide the complete proof because I wanted to leave some minor details as an exercise to the reader.\\n\\nHowever the details are that $$F$$ is assumed not to be a trivial choice, I.E it must be overlapping something else. \\n\\nIf it doesn\\'t overlap anything you must always include it because you are maximizing intervals. This removes the possibility that $$Q$$ doesn\\'t overlap.\\n\\nSecondly because $$F$$ is assumed to end first, then there cannot be anything before it. The endpoints of other intervals are at or after it. So there cannot be these theoretical intervals that are choosable before it that don\\'t overlap with $$Q$$. "
                    },
                    {
                        "username": "cecilia5",
                        "content": "There are a few things I nit picked from your comment. It is not meant to say you have a problem, please take that as an opportunity for you to improve your writing:\\n\\nThis is optimal precisely because [...], but the [...] doesn\\'t explain why it is optimal, it just describe the algorithm, and it isn\\'t complete (it doesn\\'t talk about skipping the conflicting ones, which is probably obvious \"to you\")\\n\\nFor the proof itself:\\n\\nI rather you not say the proof is simple - people looking for proofs find it hard - that\\'s why they are looking for it.\\n\\nYou didn\\'t explain why if `F` is not part of the optimal choice, then there exists `Q` that overlaps with it.\\n\\nYou also didn\\'t show why copy the remaining after `Q` is enough, what if the optimal solution including `Q` can include a lot more intervals before `Q`?\\n\\nYour idea is right on, and your proof could be polished to become a flawless one, you just need to:\\n\\n1.) See it from the adversary angle - what could someone argue about your proof, and how you plug those holes so that you answer the question before it happens, and\\n2.) See it from the learner\\'s angle - some facts could be obvious to you, but not the reader.\\n\\nI hope that helps you."
                    },
                    {
                        "username": "niraj243",
                        "content": "Can somenone explain why my solution is giving Runtime error  \n\"Line 1034: Char 34: runtime error: applying non-zero offset 4 to null pointer (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\"\nBut when I change  `return (v1[1] <= v2[1]);` to `return (v1[1] < v2[1]);` in cmp function. It works, but why ??\n```cpp\nclass Solution {\npublic:\n    static bool cmp(vector<int> &v1,vector<int> &v2){\n        // return (v1[1] <= v2[1]); // gives error why ??\n        return (v1[1] < v2[1]);\n    }\n    bool isok(vector<int> i1,vector<int> i2){\n        return (i1[1]<=i2[0] || i1[0]>=i2[1]);\n    }\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        int n = intervals.size();\n        sort(intervals.begin(),intervals.end(),cmp);\n        vector<int> end(n);\n        for(int i=0;i<n;i++){\n            end[i] = intervals[i][1];\n        }\n        int ans=1;\n        vector<int> dp(n,1);\n        for(int i=1;i<n;i++){\n            int mx = 0;\n            int prev_ok = upper_bound(end.begin(),end.end(),intervals[i][0])-end.begin()-1;\n            if(prev_ok>=0)\n            mx = dp[prev_ok];\n            dp[i] = max(dp[i-1],mx+1);\n            ans = max(ans,dp[i]);\n        }\n        return n-ans;\n    }\n};\n```  "
                    },
                    {
                        "username": "AndreiZherder",
                        "content": "If you think about DP solution, it is very similar to problem we solved four days ago:\\n[1751. Maximum number of events that can be attended II](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/)\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "Sort the intervals based on their ending point and track the last relevant interval (i) and comp the curr index\\'s 0th point with tracked (i)\\'s 1st point and if it less then increase ans++ (skip this interval) otherwise we have to consider this and assign your track index to this index"
                    }
                ]
            },
            {
                "id": 1976907,
                "content": [
                    {
                        "username": "subz3r0",
                        "content": "Getting **TLE** for this. **HELP**\\n```\\nclass Solution {\\nprivate:\\n    static bool cmp (vector<int> a, vector<int> b) {\\n        return a[0] < b[0];\\n    }\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        int prevEnd = INT_MIN;\\n        int res = 0;\\n        for (vector<int> interval: intervals) {\\n            if (interval[0] >= prevEnd) {\\n                // no overlap\\n                prevEnd = interval[1];\\n            }\\n            else {\\n                // overlap\\n                res++;\\n                prevEnd = min(prevEnd, interval[1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "OP101202",
                        "content": "[@asahoo27](/asahoo27) without cmp it won\\'t work , it is must."
                    },
                    {
                        "username": "asahoo27",
                        "content": "``` sort(intervals.begin(),intervals.end());```  just use this no need of cmp"
                    },
                    {
                        "username": "saisantosh3007",
                        "content": "[@1111aakansharao](/1111aakansharao) Thank you for this"
                    },
                    {
                        "username": "1111aakansharao",
                        "content": "your cmp function containg parameters as vectors, you need to pass it by reference beacause by value it will take a longer time and changes will not be reflected.\\n```\\nstatic bool cmp (vector<int>&a, vector<int>&b) {\\n        return a[0] < b[0];\\n    }\\n```\\nHope this helps you !\\nKeep hustlin :)"
                    },
                    {
                        "username": "Aiyaz123",
                        "content": "Thats the great solution tbh, easy and simple to understand.. "
                    },
                    {
                        "username": "Gaurav_Upreti",
                        "content": "Use pass by reference in cmp function, i.e. cmp(vector<int> &a, vector<int> &b)."
                    },
                    {
                        "username": "subz3r0",
                        "content": "I\\'m not sure why but the compare function was causing the TLE !! -_- "
                    },
                    {
                        "username": "rishavjain",
                        "content": "Time Limit Exceeded\\n58 / 58 testcases passed\\n?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Just regard it as a regular TLE ."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "show your code \nstatic bool cmp (vector<int>&a, vector<int>&b) {\n        return a[0] < b[0];\n    }\nhere a lot of ppl didnt pass the vector by reference are getting the same error as you perhaps that is the issue in your code"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So I\\'ve looked at an *awful lot* of solutions but nobody explains why their solution can be relied on to remove the minimum number of intervals. My first solution didn\\'t. I assume all the posted solutions do but after 5 pages of them I gave up hoping that somebody would explain how they met that part of the spec. Does anybody here have a solution where they know why it removes the minimum number of intervals? Can they explain why? Can ANYONE explain why?"
                    },
                    {
                        "username": "jfitzg7",
                        "content": "It helped me to visualize it by organizing intervals with the same end dates (sorted in ascending order) into groups. In the best case, if there is at least one interval in each group that doesn\\'t overlap with the previous group, you will be able to pick one interval from each group and discard the rest. It helps to look at the cases when there are 1 groups, 2 groups, 3 groups, etc.\\n\\n1 group: You can only pick 1 interval from the first group.\\n\\n2 groups: If all the intervals in the second group overlap with the first groups end date, then we will only be able to pick 1 interval. If only some (or none) overlapped, then we would be able to pick 2 intervals, one from the first group and another from the second group. But it\\'s not yet clear why we should be greedy.\\n\\n3 groups: Let\\'s say all the intervals in the second group overlap with the first group so that we would only be able to pick a single interval from one or the other, but which group do we pick from? If we pick from the second group instead of the first group, then this becomes a problem when all of the intervals in the third group overlap the second group (and maybe some overlap the first, but not all). If we had picked from the first group, then we would have been able to pick from the third group as well. If some or none of the intervals in the second group overlap the first, then we would greedily pick from the second group and it basically gets boiled down into the 2 groups case when dealing with the third group.\\n\\nIt gets complicated when looking at examples with more groups and thinking of all the cases, but hopefully this is a good starting point and can help give a different perspective. I think why this problem is so hard is that there are many cases to consider, and I needed to use this idea of grouping the intervals together just to make sense of why the greedy approach works."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, I can explain why the greedy algorithm that chooses to keep intervals with the earliest end time will remove the minimum number of intervals. This is a result of how the greedy strategy prioritizes creating the maximum room for the remaining intervals, which minimizes the number of intervals that have to be removed.\\n\\nThe key here is that if you have two overlapping intervals, keeping the one that ends earliest will leave more room for the remaining intervals. \\n\\nConsider two overlapping intervals, interval A and interval B, where A ends before B. \\n\\n```\\nA: |------|\\nB:     |---------|\\n```\\nIf you keep interval B, any subsequent interval cannot start until after B ends. But if you keep A, subsequent intervals can start right after A ends, providing more room for other intervals. Therefore, keeping A, the interval with the earliest end time, will allow us to fit in the most intervals, thereby minimizing the number we need to remove.\\n\\nTo generalize, we sort all intervals by end time, then iterate through the sorted list. We always keep the interval with the earliest end time among all overlapping intervals, and remove the others. By doing so, we can ensure that we\\'ve made the most room for the remaining intervals, thereby minimizing the number of intervals we need to remove.\\n\\nThis strategy satisfies the problem\\'s requirement of removing the minimum number of intervals because we\\'re always maximizing the space for the remaining intervals at each step, which is the key to minimizing removals."
                    },
                    {
                        "username": "shakthi4526",
                        "content": "Removing minimum number of intervals is the same as KEEPING maximum number of intervals. \\n\\nNow, if you look at it as scheduling maximum number of meetings in a room, then you should get it.\\nFor those unfamiliar with the Meeting scheduling problem, it is similar to this problem here, but each interval [start,end] represents the start and end time of a meeting. As there is only one room and we can have only one meeting at a time, we want to find maximum number of meetings we can schedule (in other words reject minimum number of meetings).\\n\\nAgain we sort by end times. Why? Because regardless of when a meeting starts, a meeting that ends first leaves more time for other meetings to take place. We do not want a meeting that starts early and ends late, what we really care about is when the meeting ends and how much time it leaves for the other meetings. So, sort by endtimes, remove all overlapping meetings to get maximum meetings or reject minimum meetings. Same logic applies here in this problem."
                    },
                    {
                        "username": "magicsign",
                        "content": "You can understand the solution by visualizing the intervals as lines. The key first of all is sorting the intervals by their ending point. For example say you have: [1,11],[2,12],[11,22],[1,100] , notice all intervals are sorted in ascending order based on their ending point.\\n\\nNow if you keep 2 pointers, prev and curr and a counter, prev gets initialized to [1,11], curr to [2,12]. 11 > 2 so it means that the interval [1,11] overlaps [2,12], we can remove [2,12] and in our case we increment our counter by one.\\nprev is [1,11], curr is [11,22], 11 > 11 no, so no overlapping. We need to move prev pointer to [11,22] to perform the next comparisons because we know that the previous intervals are non overlapping.\\n\\nprev is [11,22], curr is [1,100], 22 > 1, yes, we remove [1,100] or in another words, increment our counter. We reached the end with counter set to 2. "
                    },
                    {
                        "username": "lcgt",
                        "content": "I cant seem to think of a case where removing the latter interval is a bad idea, but it is a source of uncertainty."
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s consider a scenario where you might be tempted to remove a later interval, but it\\'s actually not the best move. Take a look at these intervals:\\n\\n```\\n[[1,10],[2,3],[4,5],[6,7],[8,9]]\\n```\\n\\nIn this case, interval [1,10] overlaps with all other intervals. Now, you might think to remove a later interval, say [8,9], because it\\'s later and removing it seems like it would minimize the overlaps.\\n\\nBut removing any of [2,3],[4,5],[6,7],[8,9] won\\'t solve the problem because they are not the root cause of the overlaps. The real issue is with the [1,10] interval, because it overlaps with all others. If you remove [1,10], you\\'ll only have to remove one interval and none of the remaining intervals overlap.\\n\\nThis illustrates that sometimes the best move is to remove an interval that isn\\'t necessarily the latest one, but the one that causes the most overlaps. It\\'s why the strategy of always removing the interval with the latest end time works \\u2013 it maximizes the room for other intervals and decreases the chances of overlaps."
                    },
                    {
                        "username": "ajv97",
                        "content": "Think this array as a list of start and end times of your favourite movies in a theatre where you can watch anything for free for that day.(you never get tired and you can teleport-only after the movie ends)\\nNow wouldn\\'t you be GREEDY and try to watch the maximum amount of movies.\\nBut you would also want the movie list to be SORTED by end time to get a better overview."
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can start by considering intervals in some \"natural\" order.\\n1. Earliest start time\\n![image.png](https://assets.leetcode.com/users/images/9ae02534-c9af-4239-b5f6-e1bdd43feaa0_1684388688.0637023.png)\\n2. Earliest finish time\\n3. Shortest interval\\n![image.png](https://assets.leetcode.com/users/images/70407e84-c791-40da-9e62-c2b4506ef72d_1684388702.40602.png)\\n4. Fewest conflicts\\n![image.png](https://assets.leetcode.com/users/images/e70553be-2b51-4c03-804b-0c6939de7391_1684388714.3131933.png)\\nWe found some counterexamples for 1, 2 and 4.\\nNow let\\'s prove why greedy with EFT works.\\n# Proof of optimality by contradiction\\n- Suppose for contradiction that greedy is not optimal\\n- Say greedy selects interval `\\uD835\\uDC561, \\uD835\\uDC562, \\u2026 , \\uD835\\uDC56\\uD835\\uDC58` sorted by finish time\\n- Consider an optimal solution `\\uD835\\uDC571,\\uD835\\uDC572, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5A` (also sorted by finish time) which matches greedy for as many indices as possible\\n    - That is, we want `\\uD835\\uDC571 = \\uD835\\uDC561, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5F = \\uD835\\uDC56\\uD835\\uDC5F` for the greatest possible `\\uD835\\uDC5F`\\n- Both `\\uD835\\uDC56\\uD835\\uDC5F+1` and `\\uD835\\uDC57\\uD835\\uDC5F+1` must be compatible with the previous selection\\n`(\\uD835\\uDC561 = \\uD835\\uDC571, \\u2026 , \\uD835\\uDC56\\uD835\\uDC5F = \\uD835\\uDC57\\uD835\\uDC5F)`\\n- Consider a new solution `\\uD835\\uDC561, \\uD835\\uDC562, \\u2026 , \\uD835\\uDC56\\uD835\\uDC5F, \\uD835\\uDC56\\uD835\\uDC5F+1,\\uD835\\uDC57\\uD835\\uDC5F+2, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5A`\\n- We have replaced `\\uD835\\uDC57\\uD835\\uDC5F+1` by `\\uD835\\uDC56\\uD835\\uDC5F+1` in our reference optimal solution\\n- This is still feasible because `\\uD835\\uDC53\\uD835\\uDC56\\uD835\\uDC5F+1 \\u2264 \\uD835\\uDC53\\uD835\\uDC57\\uD835\\uDC5F+1 \\u2264 \\uD835\\uDC60\\uD835\\uDC57\\uD835\\uDC61`\\nfor `\\uD835\\uDC61 \\u2265 \\uD835\\uDC5F + 2` where `\\uD835\\uDC53\\uD835\\uDC56` is the finish time for interval `i`.\\n- This is still optimal because `\\uD835\\uDC5A` intervals are selected.\\n- But it matches the greedy solution in \\uD835\\uDC5F + 1 indices\\n    - This is the desired contradiction\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort intervals by finish time.\\n2. For each interval `j` we check if it\\'s compatible with the last added interval `i`. If not, increase `res` and `j`, otherwise increate `i` and `j`. "
                    },
                    {
                        "username": "Leaderboard",
                        "content": "> We found some counterexamples for 1, 2 and 4.\\n\\nShould it not be \"1, 3 and 4\"?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "So many of you comment like I\\'m reading ChatGPT. You may have a proper solution but its improperly explained with holes and leaps in the logic or its just flat out word salad with no meaning.\\n\\nYou can basically boil this down to sorting by start position and greedily picking the intervals that end first. This is optimal precisely because given some starting position (suppose you consider only the intervals with starts after some $$X$$, in practice $$X$$ is the end of the last chosen interval). Then you should always pick the next interval which ends first, call it interval $$F$$\\n\\nThe proof is simple, suppose the interval $$F$$  isn\\'t part of the optimal choices, then that means that there is some interval, $$Q$$, which overlaps it you should pick instead  that gives you better choices later on somehow. However picking $$Q$$ can be no better than picking $$F$$ because you could always copy remaining ones after $$Q$$ even if you picked $$F$$ because we assumed $$F$$ is the one that ends first."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@cecilia5](/cecilia5) I didn\\'t not provide the complete proof because I wanted to leave some minor details as an exercise to the reader.\\n\\nHowever the details are that $$F$$ is assumed not to be a trivial choice, I.E it must be overlapping something else. \\n\\nIf it doesn\\'t overlap anything you must always include it because you are maximizing intervals. This removes the possibility that $$Q$$ doesn\\'t overlap.\\n\\nSecondly because $$F$$ is assumed to end first, then there cannot be anything before it. The endpoints of other intervals are at or after it. So there cannot be these theoretical intervals that are choosable before it that don\\'t overlap with $$Q$$. "
                    },
                    {
                        "username": "cecilia5",
                        "content": "There are a few things I nit picked from your comment. It is not meant to say you have a problem, please take that as an opportunity for you to improve your writing:\\n\\nThis is optimal precisely because [...], but the [...] doesn\\'t explain why it is optimal, it just describe the algorithm, and it isn\\'t complete (it doesn\\'t talk about skipping the conflicting ones, which is probably obvious \"to you\")\\n\\nFor the proof itself:\\n\\nI rather you not say the proof is simple - people looking for proofs find it hard - that\\'s why they are looking for it.\\n\\nYou didn\\'t explain why if `F` is not part of the optimal choice, then there exists `Q` that overlaps with it.\\n\\nYou also didn\\'t show why copy the remaining after `Q` is enough, what if the optimal solution including `Q` can include a lot more intervals before `Q`?\\n\\nYour idea is right on, and your proof could be polished to become a flawless one, you just need to:\\n\\n1.) See it from the adversary angle - what could someone argue about your proof, and how you plug those holes so that you answer the question before it happens, and\\n2.) See it from the learner\\'s angle - some facts could be obvious to you, but not the reader.\\n\\nI hope that helps you."
                    },
                    {
                        "username": "niraj243",
                        "content": "Can somenone explain why my solution is giving Runtime error  \n\"Line 1034: Char 34: runtime error: applying non-zero offset 4 to null pointer (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\"\nBut when I change  `return (v1[1] <= v2[1]);` to `return (v1[1] < v2[1]);` in cmp function. It works, but why ??\n```cpp\nclass Solution {\npublic:\n    static bool cmp(vector<int> &v1,vector<int> &v2){\n        // return (v1[1] <= v2[1]); // gives error why ??\n        return (v1[1] < v2[1]);\n    }\n    bool isok(vector<int> i1,vector<int> i2){\n        return (i1[1]<=i2[0] || i1[0]>=i2[1]);\n    }\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        int n = intervals.size();\n        sort(intervals.begin(),intervals.end(),cmp);\n        vector<int> end(n);\n        for(int i=0;i<n;i++){\n            end[i] = intervals[i][1];\n        }\n        int ans=1;\n        vector<int> dp(n,1);\n        for(int i=1;i<n;i++){\n            int mx = 0;\n            int prev_ok = upper_bound(end.begin(),end.end(),intervals[i][0])-end.begin()-1;\n            if(prev_ok>=0)\n            mx = dp[prev_ok];\n            dp[i] = max(dp[i-1],mx+1);\n            ans = max(ans,dp[i]);\n        }\n        return n-ans;\n    }\n};\n```  "
                    },
                    {
                        "username": "AndreiZherder",
                        "content": "If you think about DP solution, it is very similar to problem we solved four days ago:\\n[1751. Maximum number of events that can be attended II](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/)\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "Sort the intervals based on their ending point and track the last relevant interval (i) and comp the curr index\\'s 0th point with tracked (i)\\'s 1st point and if it less then increase ans++ (skip this interval) otherwise we have to consider this and assign your track index to this index"
                    }
                ]
            },
            {
                "id": 1976866,
                "content": [
                    {
                        "username": "subz3r0",
                        "content": "Getting **TLE** for this. **HELP**\\n```\\nclass Solution {\\nprivate:\\n    static bool cmp (vector<int> a, vector<int> b) {\\n        return a[0] < b[0];\\n    }\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        int prevEnd = INT_MIN;\\n        int res = 0;\\n        for (vector<int> interval: intervals) {\\n            if (interval[0] >= prevEnd) {\\n                // no overlap\\n                prevEnd = interval[1];\\n            }\\n            else {\\n                // overlap\\n                res++;\\n                prevEnd = min(prevEnd, interval[1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "OP101202",
                        "content": "[@asahoo27](/asahoo27) without cmp it won\\'t work , it is must."
                    },
                    {
                        "username": "asahoo27",
                        "content": "``` sort(intervals.begin(),intervals.end());```  just use this no need of cmp"
                    },
                    {
                        "username": "saisantosh3007",
                        "content": "[@1111aakansharao](/1111aakansharao) Thank you for this"
                    },
                    {
                        "username": "1111aakansharao",
                        "content": "your cmp function containg parameters as vectors, you need to pass it by reference beacause by value it will take a longer time and changes will not be reflected.\\n```\\nstatic bool cmp (vector<int>&a, vector<int>&b) {\\n        return a[0] < b[0];\\n    }\\n```\\nHope this helps you !\\nKeep hustlin :)"
                    },
                    {
                        "username": "Aiyaz123",
                        "content": "Thats the great solution tbh, easy and simple to understand.. "
                    },
                    {
                        "username": "Gaurav_Upreti",
                        "content": "Use pass by reference in cmp function, i.e. cmp(vector<int> &a, vector<int> &b)."
                    },
                    {
                        "username": "subz3r0",
                        "content": "I\\'m not sure why but the compare function was causing the TLE !! -_- "
                    },
                    {
                        "username": "rishavjain",
                        "content": "Time Limit Exceeded\\n58 / 58 testcases passed\\n?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Just regard it as a regular TLE ."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "show your code \nstatic bool cmp (vector<int>&a, vector<int>&b) {\n        return a[0] < b[0];\n    }\nhere a lot of ppl didnt pass the vector by reference are getting the same error as you perhaps that is the issue in your code"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So I\\'ve looked at an *awful lot* of solutions but nobody explains why their solution can be relied on to remove the minimum number of intervals. My first solution didn\\'t. I assume all the posted solutions do but after 5 pages of them I gave up hoping that somebody would explain how they met that part of the spec. Does anybody here have a solution where they know why it removes the minimum number of intervals? Can they explain why? Can ANYONE explain why?"
                    },
                    {
                        "username": "jfitzg7",
                        "content": "It helped me to visualize it by organizing intervals with the same end dates (sorted in ascending order) into groups. In the best case, if there is at least one interval in each group that doesn\\'t overlap with the previous group, you will be able to pick one interval from each group and discard the rest. It helps to look at the cases when there are 1 groups, 2 groups, 3 groups, etc.\\n\\n1 group: You can only pick 1 interval from the first group.\\n\\n2 groups: If all the intervals in the second group overlap with the first groups end date, then we will only be able to pick 1 interval. If only some (or none) overlapped, then we would be able to pick 2 intervals, one from the first group and another from the second group. But it\\'s not yet clear why we should be greedy.\\n\\n3 groups: Let\\'s say all the intervals in the second group overlap with the first group so that we would only be able to pick a single interval from one or the other, but which group do we pick from? If we pick from the second group instead of the first group, then this becomes a problem when all of the intervals in the third group overlap the second group (and maybe some overlap the first, but not all). If we had picked from the first group, then we would have been able to pick from the third group as well. If some or none of the intervals in the second group overlap the first, then we would greedily pick from the second group and it basically gets boiled down into the 2 groups case when dealing with the third group.\\n\\nIt gets complicated when looking at examples with more groups and thinking of all the cases, but hopefully this is a good starting point and can help give a different perspective. I think why this problem is so hard is that there are many cases to consider, and I needed to use this idea of grouping the intervals together just to make sense of why the greedy approach works."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, I can explain why the greedy algorithm that chooses to keep intervals with the earliest end time will remove the minimum number of intervals. This is a result of how the greedy strategy prioritizes creating the maximum room for the remaining intervals, which minimizes the number of intervals that have to be removed.\\n\\nThe key here is that if you have two overlapping intervals, keeping the one that ends earliest will leave more room for the remaining intervals. \\n\\nConsider two overlapping intervals, interval A and interval B, where A ends before B. \\n\\n```\\nA: |------|\\nB:     |---------|\\n```\\nIf you keep interval B, any subsequent interval cannot start until after B ends. But if you keep A, subsequent intervals can start right after A ends, providing more room for other intervals. Therefore, keeping A, the interval with the earliest end time, will allow us to fit in the most intervals, thereby minimizing the number we need to remove.\\n\\nTo generalize, we sort all intervals by end time, then iterate through the sorted list. We always keep the interval with the earliest end time among all overlapping intervals, and remove the others. By doing so, we can ensure that we\\'ve made the most room for the remaining intervals, thereby minimizing the number of intervals we need to remove.\\n\\nThis strategy satisfies the problem\\'s requirement of removing the minimum number of intervals because we\\'re always maximizing the space for the remaining intervals at each step, which is the key to minimizing removals."
                    },
                    {
                        "username": "shakthi4526",
                        "content": "Removing minimum number of intervals is the same as KEEPING maximum number of intervals. \\n\\nNow, if you look at it as scheduling maximum number of meetings in a room, then you should get it.\\nFor those unfamiliar with the Meeting scheduling problem, it is similar to this problem here, but each interval [start,end] represents the start and end time of a meeting. As there is only one room and we can have only one meeting at a time, we want to find maximum number of meetings we can schedule (in other words reject minimum number of meetings).\\n\\nAgain we sort by end times. Why? Because regardless of when a meeting starts, a meeting that ends first leaves more time for other meetings to take place. We do not want a meeting that starts early and ends late, what we really care about is when the meeting ends and how much time it leaves for the other meetings. So, sort by endtimes, remove all overlapping meetings to get maximum meetings or reject minimum meetings. Same logic applies here in this problem."
                    },
                    {
                        "username": "magicsign",
                        "content": "You can understand the solution by visualizing the intervals as lines. The key first of all is sorting the intervals by their ending point. For example say you have: [1,11],[2,12],[11,22],[1,100] , notice all intervals are sorted in ascending order based on their ending point.\\n\\nNow if you keep 2 pointers, prev and curr and a counter, prev gets initialized to [1,11], curr to [2,12]. 11 > 2 so it means that the interval [1,11] overlaps [2,12], we can remove [2,12] and in our case we increment our counter by one.\\nprev is [1,11], curr is [11,22], 11 > 11 no, so no overlapping. We need to move prev pointer to [11,22] to perform the next comparisons because we know that the previous intervals are non overlapping.\\n\\nprev is [11,22], curr is [1,100], 22 > 1, yes, we remove [1,100] or in another words, increment our counter. We reached the end with counter set to 2. "
                    },
                    {
                        "username": "lcgt",
                        "content": "I cant seem to think of a case where removing the latter interval is a bad idea, but it is a source of uncertainty."
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s consider a scenario where you might be tempted to remove a later interval, but it\\'s actually not the best move. Take a look at these intervals:\\n\\n```\\n[[1,10],[2,3],[4,5],[6,7],[8,9]]\\n```\\n\\nIn this case, interval [1,10] overlaps with all other intervals. Now, you might think to remove a later interval, say [8,9], because it\\'s later and removing it seems like it would minimize the overlaps.\\n\\nBut removing any of [2,3],[4,5],[6,7],[8,9] won\\'t solve the problem because they are not the root cause of the overlaps. The real issue is with the [1,10] interval, because it overlaps with all others. If you remove [1,10], you\\'ll only have to remove one interval and none of the remaining intervals overlap.\\n\\nThis illustrates that sometimes the best move is to remove an interval that isn\\'t necessarily the latest one, but the one that causes the most overlaps. It\\'s why the strategy of always removing the interval with the latest end time works \\u2013 it maximizes the room for other intervals and decreases the chances of overlaps."
                    },
                    {
                        "username": "ajv97",
                        "content": "Think this array as a list of start and end times of your favourite movies in a theatre where you can watch anything for free for that day.(you never get tired and you can teleport-only after the movie ends)\\nNow wouldn\\'t you be GREEDY and try to watch the maximum amount of movies.\\nBut you would also want the movie list to be SORTED by end time to get a better overview."
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can start by considering intervals in some \"natural\" order.\\n1. Earliest start time\\n![image.png](https://assets.leetcode.com/users/images/9ae02534-c9af-4239-b5f6-e1bdd43feaa0_1684388688.0637023.png)\\n2. Earliest finish time\\n3. Shortest interval\\n![image.png](https://assets.leetcode.com/users/images/70407e84-c791-40da-9e62-c2b4506ef72d_1684388702.40602.png)\\n4. Fewest conflicts\\n![image.png](https://assets.leetcode.com/users/images/e70553be-2b51-4c03-804b-0c6939de7391_1684388714.3131933.png)\\nWe found some counterexamples for 1, 2 and 4.\\nNow let\\'s prove why greedy with EFT works.\\n# Proof of optimality by contradiction\\n- Suppose for contradiction that greedy is not optimal\\n- Say greedy selects interval `\\uD835\\uDC561, \\uD835\\uDC562, \\u2026 , \\uD835\\uDC56\\uD835\\uDC58` sorted by finish time\\n- Consider an optimal solution `\\uD835\\uDC571,\\uD835\\uDC572, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5A` (also sorted by finish time) which matches greedy for as many indices as possible\\n    - That is, we want `\\uD835\\uDC571 = \\uD835\\uDC561, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5F = \\uD835\\uDC56\\uD835\\uDC5F` for the greatest possible `\\uD835\\uDC5F`\\n- Both `\\uD835\\uDC56\\uD835\\uDC5F+1` and `\\uD835\\uDC57\\uD835\\uDC5F+1` must be compatible with the previous selection\\n`(\\uD835\\uDC561 = \\uD835\\uDC571, \\u2026 , \\uD835\\uDC56\\uD835\\uDC5F = \\uD835\\uDC57\\uD835\\uDC5F)`\\n- Consider a new solution `\\uD835\\uDC561, \\uD835\\uDC562, \\u2026 , \\uD835\\uDC56\\uD835\\uDC5F, \\uD835\\uDC56\\uD835\\uDC5F+1,\\uD835\\uDC57\\uD835\\uDC5F+2, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5A`\\n- We have replaced `\\uD835\\uDC57\\uD835\\uDC5F+1` by `\\uD835\\uDC56\\uD835\\uDC5F+1` in our reference optimal solution\\n- This is still feasible because `\\uD835\\uDC53\\uD835\\uDC56\\uD835\\uDC5F+1 \\u2264 \\uD835\\uDC53\\uD835\\uDC57\\uD835\\uDC5F+1 \\u2264 \\uD835\\uDC60\\uD835\\uDC57\\uD835\\uDC61`\\nfor `\\uD835\\uDC61 \\u2265 \\uD835\\uDC5F + 2` where `\\uD835\\uDC53\\uD835\\uDC56` is the finish time for interval `i`.\\n- This is still optimal because `\\uD835\\uDC5A` intervals are selected.\\n- But it matches the greedy solution in \\uD835\\uDC5F + 1 indices\\n    - This is the desired contradiction\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort intervals by finish time.\\n2. For each interval `j` we check if it\\'s compatible with the last added interval `i`. If not, increase `res` and `j`, otherwise increate `i` and `j`. "
                    },
                    {
                        "username": "Leaderboard",
                        "content": "> We found some counterexamples for 1, 2 and 4.\\n\\nShould it not be \"1, 3 and 4\"?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "So many of you comment like I\\'m reading ChatGPT. You may have a proper solution but its improperly explained with holes and leaps in the logic or its just flat out word salad with no meaning.\\n\\nYou can basically boil this down to sorting by start position and greedily picking the intervals that end first. This is optimal precisely because given some starting position (suppose you consider only the intervals with starts after some $$X$$, in practice $$X$$ is the end of the last chosen interval). Then you should always pick the next interval which ends first, call it interval $$F$$\\n\\nThe proof is simple, suppose the interval $$F$$  isn\\'t part of the optimal choices, then that means that there is some interval, $$Q$$, which overlaps it you should pick instead  that gives you better choices later on somehow. However picking $$Q$$ can be no better than picking $$F$$ because you could always copy remaining ones after $$Q$$ even if you picked $$F$$ because we assumed $$F$$ is the one that ends first."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@cecilia5](/cecilia5) I didn\\'t not provide the complete proof because I wanted to leave some minor details as an exercise to the reader.\\n\\nHowever the details are that $$F$$ is assumed not to be a trivial choice, I.E it must be overlapping something else. \\n\\nIf it doesn\\'t overlap anything you must always include it because you are maximizing intervals. This removes the possibility that $$Q$$ doesn\\'t overlap.\\n\\nSecondly because $$F$$ is assumed to end first, then there cannot be anything before it. The endpoints of other intervals are at or after it. So there cannot be these theoretical intervals that are choosable before it that don\\'t overlap with $$Q$$. "
                    },
                    {
                        "username": "cecilia5",
                        "content": "There are a few things I nit picked from your comment. It is not meant to say you have a problem, please take that as an opportunity for you to improve your writing:\\n\\nThis is optimal precisely because [...], but the [...] doesn\\'t explain why it is optimal, it just describe the algorithm, and it isn\\'t complete (it doesn\\'t talk about skipping the conflicting ones, which is probably obvious \"to you\")\\n\\nFor the proof itself:\\n\\nI rather you not say the proof is simple - people looking for proofs find it hard - that\\'s why they are looking for it.\\n\\nYou didn\\'t explain why if `F` is not part of the optimal choice, then there exists `Q` that overlaps with it.\\n\\nYou also didn\\'t show why copy the remaining after `Q` is enough, what if the optimal solution including `Q` can include a lot more intervals before `Q`?\\n\\nYour idea is right on, and your proof could be polished to become a flawless one, you just need to:\\n\\n1.) See it from the adversary angle - what could someone argue about your proof, and how you plug those holes so that you answer the question before it happens, and\\n2.) See it from the learner\\'s angle - some facts could be obvious to you, but not the reader.\\n\\nI hope that helps you."
                    },
                    {
                        "username": "niraj243",
                        "content": "Can somenone explain why my solution is giving Runtime error  \n\"Line 1034: Char 34: runtime error: applying non-zero offset 4 to null pointer (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\"\nBut when I change  `return (v1[1] <= v2[1]);` to `return (v1[1] < v2[1]);` in cmp function. It works, but why ??\n```cpp\nclass Solution {\npublic:\n    static bool cmp(vector<int> &v1,vector<int> &v2){\n        // return (v1[1] <= v2[1]); // gives error why ??\n        return (v1[1] < v2[1]);\n    }\n    bool isok(vector<int> i1,vector<int> i2){\n        return (i1[1]<=i2[0] || i1[0]>=i2[1]);\n    }\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        int n = intervals.size();\n        sort(intervals.begin(),intervals.end(),cmp);\n        vector<int> end(n);\n        for(int i=0;i<n;i++){\n            end[i] = intervals[i][1];\n        }\n        int ans=1;\n        vector<int> dp(n,1);\n        for(int i=1;i<n;i++){\n            int mx = 0;\n            int prev_ok = upper_bound(end.begin(),end.end(),intervals[i][0])-end.begin()-1;\n            if(prev_ok>=0)\n            mx = dp[prev_ok];\n            dp[i] = max(dp[i-1],mx+1);\n            ans = max(ans,dp[i]);\n        }\n        return n-ans;\n    }\n};\n```  "
                    },
                    {
                        "username": "AndreiZherder",
                        "content": "If you think about DP solution, it is very similar to problem we solved four days ago:\\n[1751. Maximum number of events that can be attended II](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/)\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "Sort the intervals based on their ending point and track the last relevant interval (i) and comp the curr index\\'s 0th point with tracked (i)\\'s 1st point and if it less then increase ans++ (skip this interval) otherwise we have to consider this and assign your track index to this index"
                    }
                ]
            },
            {
                "id": 1976854,
                "content": [
                    {
                        "username": "subz3r0",
                        "content": "Getting **TLE** for this. **HELP**\\n```\\nclass Solution {\\nprivate:\\n    static bool cmp (vector<int> a, vector<int> b) {\\n        return a[0] < b[0];\\n    }\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        int prevEnd = INT_MIN;\\n        int res = 0;\\n        for (vector<int> interval: intervals) {\\n            if (interval[0] >= prevEnd) {\\n                // no overlap\\n                prevEnd = interval[1];\\n            }\\n            else {\\n                // overlap\\n                res++;\\n                prevEnd = min(prevEnd, interval[1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "OP101202",
                        "content": "[@asahoo27](/asahoo27) without cmp it won\\'t work , it is must."
                    },
                    {
                        "username": "asahoo27",
                        "content": "``` sort(intervals.begin(),intervals.end());```  just use this no need of cmp"
                    },
                    {
                        "username": "saisantosh3007",
                        "content": "[@1111aakansharao](/1111aakansharao) Thank you for this"
                    },
                    {
                        "username": "1111aakansharao",
                        "content": "your cmp function containg parameters as vectors, you need to pass it by reference beacause by value it will take a longer time and changes will not be reflected.\\n```\\nstatic bool cmp (vector<int>&a, vector<int>&b) {\\n        return a[0] < b[0];\\n    }\\n```\\nHope this helps you !\\nKeep hustlin :)"
                    },
                    {
                        "username": "Aiyaz123",
                        "content": "Thats the great solution tbh, easy and simple to understand.. "
                    },
                    {
                        "username": "Gaurav_Upreti",
                        "content": "Use pass by reference in cmp function, i.e. cmp(vector<int> &a, vector<int> &b)."
                    },
                    {
                        "username": "subz3r0",
                        "content": "I\\'m not sure why but the compare function was causing the TLE !! -_- "
                    },
                    {
                        "username": "rishavjain",
                        "content": "Time Limit Exceeded\\n58 / 58 testcases passed\\n?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Just regard it as a regular TLE ."
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "show your code \nstatic bool cmp (vector<int>&a, vector<int>&b) {\n        return a[0] < b[0];\n    }\nhere a lot of ppl didnt pass the vector by reference are getting the same error as you perhaps that is the issue in your code"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So I\\'ve looked at an *awful lot* of solutions but nobody explains why their solution can be relied on to remove the minimum number of intervals. My first solution didn\\'t. I assume all the posted solutions do but after 5 pages of them I gave up hoping that somebody would explain how they met that part of the spec. Does anybody here have a solution where they know why it removes the minimum number of intervals? Can they explain why? Can ANYONE explain why?"
                    },
                    {
                        "username": "jfitzg7",
                        "content": "It helped me to visualize it by organizing intervals with the same end dates (sorted in ascending order) into groups. In the best case, if there is at least one interval in each group that doesn\\'t overlap with the previous group, you will be able to pick one interval from each group and discard the rest. It helps to look at the cases when there are 1 groups, 2 groups, 3 groups, etc.\\n\\n1 group: You can only pick 1 interval from the first group.\\n\\n2 groups: If all the intervals in the second group overlap with the first groups end date, then we will only be able to pick 1 interval. If only some (or none) overlapped, then we would be able to pick 2 intervals, one from the first group and another from the second group. But it\\'s not yet clear why we should be greedy.\\n\\n3 groups: Let\\'s say all the intervals in the second group overlap with the first group so that we would only be able to pick a single interval from one or the other, but which group do we pick from? If we pick from the second group instead of the first group, then this becomes a problem when all of the intervals in the third group overlap the second group (and maybe some overlap the first, but not all). If we had picked from the first group, then we would have been able to pick from the third group as well. If some or none of the intervals in the second group overlap the first, then we would greedily pick from the second group and it basically gets boiled down into the 2 groups case when dealing with the third group.\\n\\nIt gets complicated when looking at examples with more groups and thinking of all the cases, but hopefully this is a good starting point and can help give a different perspective. I think why this problem is so hard is that there are many cases to consider, and I needed to use this idea of grouping the intervals together just to make sense of why the greedy approach works."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, I can explain why the greedy algorithm that chooses to keep intervals with the earliest end time will remove the minimum number of intervals. This is a result of how the greedy strategy prioritizes creating the maximum room for the remaining intervals, which minimizes the number of intervals that have to be removed.\\n\\nThe key here is that if you have two overlapping intervals, keeping the one that ends earliest will leave more room for the remaining intervals. \\n\\nConsider two overlapping intervals, interval A and interval B, where A ends before B. \\n\\n```\\nA: |------|\\nB:     |---------|\\n```\\nIf you keep interval B, any subsequent interval cannot start until after B ends. But if you keep A, subsequent intervals can start right after A ends, providing more room for other intervals. Therefore, keeping A, the interval with the earliest end time, will allow us to fit in the most intervals, thereby minimizing the number we need to remove.\\n\\nTo generalize, we sort all intervals by end time, then iterate through the sorted list. We always keep the interval with the earliest end time among all overlapping intervals, and remove the others. By doing so, we can ensure that we\\'ve made the most room for the remaining intervals, thereby minimizing the number of intervals we need to remove.\\n\\nThis strategy satisfies the problem\\'s requirement of removing the minimum number of intervals because we\\'re always maximizing the space for the remaining intervals at each step, which is the key to minimizing removals."
                    },
                    {
                        "username": "shakthi4526",
                        "content": "Removing minimum number of intervals is the same as KEEPING maximum number of intervals. \\n\\nNow, if you look at it as scheduling maximum number of meetings in a room, then you should get it.\\nFor those unfamiliar with the Meeting scheduling problem, it is similar to this problem here, but each interval [start,end] represents the start and end time of a meeting. As there is only one room and we can have only one meeting at a time, we want to find maximum number of meetings we can schedule (in other words reject minimum number of meetings).\\n\\nAgain we sort by end times. Why? Because regardless of when a meeting starts, a meeting that ends first leaves more time for other meetings to take place. We do not want a meeting that starts early and ends late, what we really care about is when the meeting ends and how much time it leaves for the other meetings. So, sort by endtimes, remove all overlapping meetings to get maximum meetings or reject minimum meetings. Same logic applies here in this problem."
                    },
                    {
                        "username": "magicsign",
                        "content": "You can understand the solution by visualizing the intervals as lines. The key first of all is sorting the intervals by their ending point. For example say you have: [1,11],[2,12],[11,22],[1,100] , notice all intervals are sorted in ascending order based on their ending point.\\n\\nNow if you keep 2 pointers, prev and curr and a counter, prev gets initialized to [1,11], curr to [2,12]. 11 > 2 so it means that the interval [1,11] overlaps [2,12], we can remove [2,12] and in our case we increment our counter by one.\\nprev is [1,11], curr is [11,22], 11 > 11 no, so no overlapping. We need to move prev pointer to [11,22] to perform the next comparisons because we know that the previous intervals are non overlapping.\\n\\nprev is [11,22], curr is [1,100], 22 > 1, yes, we remove [1,100] or in another words, increment our counter. We reached the end with counter set to 2. "
                    },
                    {
                        "username": "lcgt",
                        "content": "I cant seem to think of a case where removing the latter interval is a bad idea, but it is a source of uncertainty."
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s consider a scenario where you might be tempted to remove a later interval, but it\\'s actually not the best move. Take a look at these intervals:\\n\\n```\\n[[1,10],[2,3],[4,5],[6,7],[8,9]]\\n```\\n\\nIn this case, interval [1,10] overlaps with all other intervals. Now, you might think to remove a later interval, say [8,9], because it\\'s later and removing it seems like it would minimize the overlaps.\\n\\nBut removing any of [2,3],[4,5],[6,7],[8,9] won\\'t solve the problem because they are not the root cause of the overlaps. The real issue is with the [1,10] interval, because it overlaps with all others. If you remove [1,10], you\\'ll only have to remove one interval and none of the remaining intervals overlap.\\n\\nThis illustrates that sometimes the best move is to remove an interval that isn\\'t necessarily the latest one, but the one that causes the most overlaps. It\\'s why the strategy of always removing the interval with the latest end time works \\u2013 it maximizes the room for other intervals and decreases the chances of overlaps."
                    },
                    {
                        "username": "ajv97",
                        "content": "Think this array as a list of start and end times of your favourite movies in a theatre where you can watch anything for free for that day.(you never get tired and you can teleport-only after the movie ends)\\nNow wouldn\\'t you be GREEDY and try to watch the maximum amount of movies.\\nBut you would also want the movie list to be SORTED by end time to get a better overview."
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can start by considering intervals in some \"natural\" order.\\n1. Earliest start time\\n![image.png](https://assets.leetcode.com/users/images/9ae02534-c9af-4239-b5f6-e1bdd43feaa0_1684388688.0637023.png)\\n2. Earliest finish time\\n3. Shortest interval\\n![image.png](https://assets.leetcode.com/users/images/70407e84-c791-40da-9e62-c2b4506ef72d_1684388702.40602.png)\\n4. Fewest conflicts\\n![image.png](https://assets.leetcode.com/users/images/e70553be-2b51-4c03-804b-0c6939de7391_1684388714.3131933.png)\\nWe found some counterexamples for 1, 2 and 4.\\nNow let\\'s prove why greedy with EFT works.\\n# Proof of optimality by contradiction\\n- Suppose for contradiction that greedy is not optimal\\n- Say greedy selects interval `\\uD835\\uDC561, \\uD835\\uDC562, \\u2026 , \\uD835\\uDC56\\uD835\\uDC58` sorted by finish time\\n- Consider an optimal solution `\\uD835\\uDC571,\\uD835\\uDC572, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5A` (also sorted by finish time) which matches greedy for as many indices as possible\\n    - That is, we want `\\uD835\\uDC571 = \\uD835\\uDC561, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5F = \\uD835\\uDC56\\uD835\\uDC5F` for the greatest possible `\\uD835\\uDC5F`\\n- Both `\\uD835\\uDC56\\uD835\\uDC5F+1` and `\\uD835\\uDC57\\uD835\\uDC5F+1` must be compatible with the previous selection\\n`(\\uD835\\uDC561 = \\uD835\\uDC571, \\u2026 , \\uD835\\uDC56\\uD835\\uDC5F = \\uD835\\uDC57\\uD835\\uDC5F)`\\n- Consider a new solution `\\uD835\\uDC561, \\uD835\\uDC562, \\u2026 , \\uD835\\uDC56\\uD835\\uDC5F, \\uD835\\uDC56\\uD835\\uDC5F+1,\\uD835\\uDC57\\uD835\\uDC5F+2, \\u2026 ,\\uD835\\uDC57\\uD835\\uDC5A`\\n- We have replaced `\\uD835\\uDC57\\uD835\\uDC5F+1` by `\\uD835\\uDC56\\uD835\\uDC5F+1` in our reference optimal solution\\n- This is still feasible because `\\uD835\\uDC53\\uD835\\uDC56\\uD835\\uDC5F+1 \\u2264 \\uD835\\uDC53\\uD835\\uDC57\\uD835\\uDC5F+1 \\u2264 \\uD835\\uDC60\\uD835\\uDC57\\uD835\\uDC61`\\nfor `\\uD835\\uDC61 \\u2265 \\uD835\\uDC5F + 2` where `\\uD835\\uDC53\\uD835\\uDC56` is the finish time for interval `i`.\\n- This is still optimal because `\\uD835\\uDC5A` intervals are selected.\\n- But it matches the greedy solution in \\uD835\\uDC5F + 1 indices\\n    - This is the desired contradiction\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort intervals by finish time.\\n2. For each interval `j` we check if it\\'s compatible with the last added interval `i`. If not, increase `res` and `j`, otherwise increate `i` and `j`. "
                    },
                    {
                        "username": "Leaderboard",
                        "content": "> We found some counterexamples for 1, 2 and 4.\\n\\nShould it not be \"1, 3 and 4\"?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "So many of you comment like I\\'m reading ChatGPT. You may have a proper solution but its improperly explained with holes and leaps in the logic or its just flat out word salad with no meaning.\\n\\nYou can basically boil this down to sorting by start position and greedily picking the intervals that end first. This is optimal precisely because given some starting position (suppose you consider only the intervals with starts after some $$X$$, in practice $$X$$ is the end of the last chosen interval). Then you should always pick the next interval which ends first, call it interval $$F$$\\n\\nThe proof is simple, suppose the interval $$F$$  isn\\'t part of the optimal choices, then that means that there is some interval, $$Q$$, which overlaps it you should pick instead  that gives you better choices later on somehow. However picking $$Q$$ can be no better than picking $$F$$ because you could always copy remaining ones after $$Q$$ even if you picked $$F$$ because we assumed $$F$$ is the one that ends first."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@cecilia5](/cecilia5) I didn\\'t not provide the complete proof because I wanted to leave some minor details as an exercise to the reader.\\n\\nHowever the details are that $$F$$ is assumed not to be a trivial choice, I.E it must be overlapping something else. \\n\\nIf it doesn\\'t overlap anything you must always include it because you are maximizing intervals. This removes the possibility that $$Q$$ doesn\\'t overlap.\\n\\nSecondly because $$F$$ is assumed to end first, then there cannot be anything before it. The endpoints of other intervals are at or after it. So there cannot be these theoretical intervals that are choosable before it that don\\'t overlap with $$Q$$. "
                    },
                    {
                        "username": "cecilia5",
                        "content": "There are a few things I nit picked from your comment. It is not meant to say you have a problem, please take that as an opportunity for you to improve your writing:\\n\\nThis is optimal precisely because [...], but the [...] doesn\\'t explain why it is optimal, it just describe the algorithm, and it isn\\'t complete (it doesn\\'t talk about skipping the conflicting ones, which is probably obvious \"to you\")\\n\\nFor the proof itself:\\n\\nI rather you not say the proof is simple - people looking for proofs find it hard - that\\'s why they are looking for it.\\n\\nYou didn\\'t explain why if `F` is not part of the optimal choice, then there exists `Q` that overlaps with it.\\n\\nYou also didn\\'t show why copy the remaining after `Q` is enough, what if the optimal solution including `Q` can include a lot more intervals before `Q`?\\n\\nYour idea is right on, and your proof could be polished to become a flawless one, you just need to:\\n\\n1.) See it from the adversary angle - what could someone argue about your proof, and how you plug those holes so that you answer the question before it happens, and\\n2.) See it from the learner\\'s angle - some facts could be obvious to you, but not the reader.\\n\\nI hope that helps you."
                    },
                    {
                        "username": "niraj243",
                        "content": "Can somenone explain why my solution is giving Runtime error  \n\"Line 1034: Char 34: runtime error: applying non-zero offset 4 to null pointer (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\"\nBut when I change  `return (v1[1] <= v2[1]);` to `return (v1[1] < v2[1]);` in cmp function. It works, but why ??\n```cpp\nclass Solution {\npublic:\n    static bool cmp(vector<int> &v1,vector<int> &v2){\n        // return (v1[1] <= v2[1]); // gives error why ??\n        return (v1[1] < v2[1]);\n    }\n    bool isok(vector<int> i1,vector<int> i2){\n        return (i1[1]<=i2[0] || i1[0]>=i2[1]);\n    }\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        int n = intervals.size();\n        sort(intervals.begin(),intervals.end(),cmp);\n        vector<int> end(n);\n        for(int i=0;i<n;i++){\n            end[i] = intervals[i][1];\n        }\n        int ans=1;\n        vector<int> dp(n,1);\n        for(int i=1;i<n;i++){\n            int mx = 0;\n            int prev_ok = upper_bound(end.begin(),end.end(),intervals[i][0])-end.begin()-1;\n            if(prev_ok>=0)\n            mx = dp[prev_ok];\n            dp[i] = max(dp[i-1],mx+1);\n            ans = max(ans,dp[i]);\n        }\n        return n-ans;\n    }\n};\n```  "
                    },
                    {
                        "username": "AndreiZherder",
                        "content": "If you think about DP solution, it is very similar to problem we solved four days ago:\\n[1751. Maximum number of events that can be attended II](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/)\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "Sort the intervals based on their ending point and track the last relevant interval (i) and comp the curr index\\'s 0th point with tracked (i)\\'s 1st point and if it less then increase ans++ (skip this interval) otherwise we have to consider this and assign your track index to this index"
                    }
                ]
            },
            {
                "id": 1976832,
                "content": [
                    {
                        "username": "MNARAYAN04",
                        "content": "And this make my 200 active days of code "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Another interval can start on the end day of a previous interval without overlapping. They didn\\'t specifically mention that, but I thought it was relevant."
                    },
                    {
                        "username": "piyushisawesome2",
                        "content": "Can some help understand the solution for this case\\n\\n[[-100,-87],[-90,-44],[-86,7],[-85,-76],[-70,33]]"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@bparanj](/bparanj) the correct answer is 2, need to remove [-90,-44] and [-86,7]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks us to remove the minimum number of intervals such that no two intervals are overlapping. Let\\'s break down the process of solving this for the provided list of intervals using the greedy approach.\\n\\nHere\\'s the list of intervals you\\'ve given:\\n\\n    [[-100,-87],[-90,-44],[-86,7],[-85,-76],[-70,33]]\\n\\nFirst, we\\'ll want to sort these intervals by their end times:\\n\\n    [[-100,-87],[-85,-76],[-90,-44],[-86,7],[-70,33]]\\n\\nNow we\\'ll start going through these intervals one by one, from beginning to end, keeping track of the end of the interval that we\\'re considering including in our final set of non-overlapping intervals. Initially, we haven\\'t chosen any intervals, so this \"current end\" is negative infinity.\\n\\nAs we go through the intervals in our sorted list:\\n\\n1. For the first interval, [-100, -87], we see that its start time is greater than our current end (which is negative infinity at this point). So, we include this interval and update our current end to -87.\\n\\n2. The next interval is [-85, -76], which starts before the current end of -87. That means it\\'s overlapping with the previous interval, so we have to remove it.\\n\\n3. Next, we have [-90, -44]. Its start time (-90) is also less than the current end (-87), so it overlaps with the interval [-100, -87]. We need to remove it.\\n\\n4. The fourth interval is [-86, 7]. Its start time is also less than the current end (-87), so we remove this one too.\\n\\n5. Finally, we have [-70, 33], which starts after our current end of -87. We can include this interval and update our current end to 33.\\n\\nSo, out of the five intervals, we had to remove three and were left with two non-overlapping intervals: [-100,-87] and [-70,33]. The minimum number of intervals we have to remove to make sure no two intervals overlap is 3.\\n"
                    },
                    {
                        "username": "codejstube",
                        "content": "https://youtu.be/Gs7nngH1AEY\\n![image](https://assets.leetcode.com/users/images/de470f4c-692b-47be-8da6-1f1ef545b637_1597558380.5355117.png)\\n"
                    },
                    {
                        "username": "aLaN09",
                        "content": "The initial thoughts to solve this problem would be to iterate throught and have checks for different types of overlappings. Using the greedy approach however we can \"be greedy\" and compute the minimum end time at each overlapping case. Now why should you consider the minimum end time, Because, a minimum current end time would have a lesser chance to overlap with the next interval (don\\'t forget that we need the minimum number of removals). Hence we are greedy in the sense that we compute the **best outcome at each stage **and the best outcome being the minimum end time"
                    },
                    {
                        "username": "yasserhussain1110",
                        "content": "The interval here is half open. [start, end - 1]"
                    },
                    {
                        "username": "ssmoon",
                        "content": "`[1, 2], [2, 3]` isn\\'t considered overlapping, which isn\\'t noted in the description. **56. Merge Intervals** is a similar problem, but the same interval *would* be considered overlapping.\\n\\nTerrible problem description."
                    },
                    {
                        "username": "vivekgr92",
                        "content": "I also had the same issue. I don\\'t know why in this case it is considered as non overlapping"
                    },
                    {
                        "username": "coolspec",
                        "content": "Can somebody tell why the first comparator function is throwing an error given at the end? But the second comparator function doesn\\'t throw any error. Only difference is the equal to sign.\\n1)\\n`bool compareSecondElement(vector<int>& a, vector<int>& b) {\\n    return a[1] <= b[1];\\n}`\\n2)\\n`bool compareSecondElement(vector<int>& a, vector<int>& b) {\\n    return a[1] < b[1];\\n}`\\nSorting code:\\n`sort(intervals.begin(), intervals.end(), compareSecondElement);` \\nERROR: (I think it is a out of bound error)\\nLine 1034: Char 34: runtime error: applying non-zero offset 4 to null pointer (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "curryGoat",
                        "content": "Can someone provide list of all interval problems"
                    },
                    {
                        "username": "iffthen",
                        "content": "Is there any way to optimise it to O(n), I mean by using some sort of extra sapce?? as far as I know if i solve it with dp or greedy it will take O(nlogn). "
                    }
                ]
            },
            {
                "id": 1976364,
                "content": [
                    {
                        "username": "MNARAYAN04",
                        "content": "And this make my 200 active days of code "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Another interval can start on the end day of a previous interval without overlapping. They didn\\'t specifically mention that, but I thought it was relevant."
                    },
                    {
                        "username": "piyushisawesome2",
                        "content": "Can some help understand the solution for this case\\n\\n[[-100,-87],[-90,-44],[-86,7],[-85,-76],[-70,33]]"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@bparanj](/bparanj) the correct answer is 2, need to remove [-90,-44] and [-86,7]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks us to remove the minimum number of intervals such that no two intervals are overlapping. Let\\'s break down the process of solving this for the provided list of intervals using the greedy approach.\\n\\nHere\\'s the list of intervals you\\'ve given:\\n\\n    [[-100,-87],[-90,-44],[-86,7],[-85,-76],[-70,33]]\\n\\nFirst, we\\'ll want to sort these intervals by their end times:\\n\\n    [[-100,-87],[-85,-76],[-90,-44],[-86,7],[-70,33]]\\n\\nNow we\\'ll start going through these intervals one by one, from beginning to end, keeping track of the end of the interval that we\\'re considering including in our final set of non-overlapping intervals. Initially, we haven\\'t chosen any intervals, so this \"current end\" is negative infinity.\\n\\nAs we go through the intervals in our sorted list:\\n\\n1. For the first interval, [-100, -87], we see that its start time is greater than our current end (which is negative infinity at this point). So, we include this interval and update our current end to -87.\\n\\n2. The next interval is [-85, -76], which starts before the current end of -87. That means it\\'s overlapping with the previous interval, so we have to remove it.\\n\\n3. Next, we have [-90, -44]. Its start time (-90) is also less than the current end (-87), so it overlaps with the interval [-100, -87]. We need to remove it.\\n\\n4. The fourth interval is [-86, 7]. Its start time is also less than the current end (-87), so we remove this one too.\\n\\n5. Finally, we have [-70, 33], which starts after our current end of -87. We can include this interval and update our current end to 33.\\n\\nSo, out of the five intervals, we had to remove three and were left with two non-overlapping intervals: [-100,-87] and [-70,33]. The minimum number of intervals we have to remove to make sure no two intervals overlap is 3.\\n"
                    },
                    {
                        "username": "codejstube",
                        "content": "https://youtu.be/Gs7nngH1AEY\\n![image](https://assets.leetcode.com/users/images/de470f4c-692b-47be-8da6-1f1ef545b637_1597558380.5355117.png)\\n"
                    },
                    {
                        "username": "aLaN09",
                        "content": "The initial thoughts to solve this problem would be to iterate throught and have checks for different types of overlappings. Using the greedy approach however we can \"be greedy\" and compute the minimum end time at each overlapping case. Now why should you consider the minimum end time, Because, a minimum current end time would have a lesser chance to overlap with the next interval (don\\'t forget that we need the minimum number of removals). Hence we are greedy in the sense that we compute the **best outcome at each stage **and the best outcome being the minimum end time"
                    },
                    {
                        "username": "yasserhussain1110",
                        "content": "The interval here is half open. [start, end - 1]"
                    },
                    {
                        "username": "ssmoon",
                        "content": "`[1, 2], [2, 3]` isn\\'t considered overlapping, which isn\\'t noted in the description. **56. Merge Intervals** is a similar problem, but the same interval *would* be considered overlapping.\\n\\nTerrible problem description."
                    },
                    {
                        "username": "vivekgr92",
                        "content": "I also had the same issue. I don\\'t know why in this case it is considered as non overlapping"
                    },
                    {
                        "username": "coolspec",
                        "content": "Can somebody tell why the first comparator function is throwing an error given at the end? But the second comparator function doesn\\'t throw any error. Only difference is the equal to sign.\\n1)\\n`bool compareSecondElement(vector<int>& a, vector<int>& b) {\\n    return a[1] <= b[1];\\n}`\\n2)\\n`bool compareSecondElement(vector<int>& a, vector<int>& b) {\\n    return a[1] < b[1];\\n}`\\nSorting code:\\n`sort(intervals.begin(), intervals.end(), compareSecondElement);` \\nERROR: (I think it is a out of bound error)\\nLine 1034: Char 34: runtime error: applying non-zero offset 4 to null pointer (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "curryGoat",
                        "content": "Can someone provide list of all interval problems"
                    },
                    {
                        "username": "iffthen",
                        "content": "Is there any way to optimise it to O(n), I mean by using some sort of extra sapce?? as far as I know if i solve it with dp or greedy it will take O(nlogn). "
                    }
                ]
            },
            {
                "id": 1574726,
                "content": [
                    {
                        "username": "MNARAYAN04",
                        "content": "And this make my 200 active days of code "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Another interval can start on the end day of a previous interval without overlapping. They didn\\'t specifically mention that, but I thought it was relevant."
                    },
                    {
                        "username": "piyushisawesome2",
                        "content": "Can some help understand the solution for this case\\n\\n[[-100,-87],[-90,-44],[-86,7],[-85,-76],[-70,33]]"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@bparanj](/bparanj) the correct answer is 2, need to remove [-90,-44] and [-86,7]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks us to remove the minimum number of intervals such that no two intervals are overlapping. Let\\'s break down the process of solving this for the provided list of intervals using the greedy approach.\\n\\nHere\\'s the list of intervals you\\'ve given:\\n\\n    [[-100,-87],[-90,-44],[-86,7],[-85,-76],[-70,33]]\\n\\nFirst, we\\'ll want to sort these intervals by their end times:\\n\\n    [[-100,-87],[-85,-76],[-90,-44],[-86,7],[-70,33]]\\n\\nNow we\\'ll start going through these intervals one by one, from beginning to end, keeping track of the end of the interval that we\\'re considering including in our final set of non-overlapping intervals. Initially, we haven\\'t chosen any intervals, so this \"current end\" is negative infinity.\\n\\nAs we go through the intervals in our sorted list:\\n\\n1. For the first interval, [-100, -87], we see that its start time is greater than our current end (which is negative infinity at this point). So, we include this interval and update our current end to -87.\\n\\n2. The next interval is [-85, -76], which starts before the current end of -87. That means it\\'s overlapping with the previous interval, so we have to remove it.\\n\\n3. Next, we have [-90, -44]. Its start time (-90) is also less than the current end (-87), so it overlaps with the interval [-100, -87]. We need to remove it.\\n\\n4. The fourth interval is [-86, 7]. Its start time is also less than the current end (-87), so we remove this one too.\\n\\n5. Finally, we have [-70, 33], which starts after our current end of -87. We can include this interval and update our current end to 33.\\n\\nSo, out of the five intervals, we had to remove three and were left with two non-overlapping intervals: [-100,-87] and [-70,33]. The minimum number of intervals we have to remove to make sure no two intervals overlap is 3.\\n"
                    },
                    {
                        "username": "codejstube",
                        "content": "https://youtu.be/Gs7nngH1AEY\\n![image](https://assets.leetcode.com/users/images/de470f4c-692b-47be-8da6-1f1ef545b637_1597558380.5355117.png)\\n"
                    },
                    {
                        "username": "aLaN09",
                        "content": "The initial thoughts to solve this problem would be to iterate throught and have checks for different types of overlappings. Using the greedy approach however we can \"be greedy\" and compute the minimum end time at each overlapping case. Now why should you consider the minimum end time, Because, a minimum current end time would have a lesser chance to overlap with the next interval (don\\'t forget that we need the minimum number of removals). Hence we are greedy in the sense that we compute the **best outcome at each stage **and the best outcome being the minimum end time"
                    },
                    {
                        "username": "yasserhussain1110",
                        "content": "The interval here is half open. [start, end - 1]"
                    },
                    {
                        "username": "ssmoon",
                        "content": "`[1, 2], [2, 3]` isn\\'t considered overlapping, which isn\\'t noted in the description. **56. Merge Intervals** is a similar problem, but the same interval *would* be considered overlapping.\\n\\nTerrible problem description."
                    },
                    {
                        "username": "vivekgr92",
                        "content": "I also had the same issue. I don\\'t know why in this case it is considered as non overlapping"
                    },
                    {
                        "username": "coolspec",
                        "content": "Can somebody tell why the first comparator function is throwing an error given at the end? But the second comparator function doesn\\'t throw any error. Only difference is the equal to sign.\\n1)\\n`bool compareSecondElement(vector<int>& a, vector<int>& b) {\\n    return a[1] <= b[1];\\n}`\\n2)\\n`bool compareSecondElement(vector<int>& a, vector<int>& b) {\\n    return a[1] < b[1];\\n}`\\nSorting code:\\n`sort(intervals.begin(), intervals.end(), compareSecondElement);` \\nERROR: (I think it is a out of bound error)\\nLine 1034: Char 34: runtime error: applying non-zero offset 4 to null pointer (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "curryGoat",
                        "content": "Can someone provide list of all interval problems"
                    },
                    {
                        "username": "iffthen",
                        "content": "Is there any way to optimise it to O(n), I mean by using some sort of extra sapce?? as far as I know if i solve it with dp or greedy it will take O(nlogn). "
                    }
                ]
            },
            {
                "id": 1574221,
                "content": [
                    {
                        "username": "MNARAYAN04",
                        "content": "And this make my 200 active days of code "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Another interval can start on the end day of a previous interval without overlapping. They didn\\'t specifically mention that, but I thought it was relevant."
                    },
                    {
                        "username": "piyushisawesome2",
                        "content": "Can some help understand the solution for this case\\n\\n[[-100,-87],[-90,-44],[-86,7],[-85,-76],[-70,33]]"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@bparanj](/bparanj) the correct answer is 2, need to remove [-90,-44] and [-86,7]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks us to remove the minimum number of intervals such that no two intervals are overlapping. Let\\'s break down the process of solving this for the provided list of intervals using the greedy approach.\\n\\nHere\\'s the list of intervals you\\'ve given:\\n\\n    [[-100,-87],[-90,-44],[-86,7],[-85,-76],[-70,33]]\\n\\nFirst, we\\'ll want to sort these intervals by their end times:\\n\\n    [[-100,-87],[-85,-76],[-90,-44],[-86,7],[-70,33]]\\n\\nNow we\\'ll start going through these intervals one by one, from beginning to end, keeping track of the end of the interval that we\\'re considering including in our final set of non-overlapping intervals. Initially, we haven\\'t chosen any intervals, so this \"current end\" is negative infinity.\\n\\nAs we go through the intervals in our sorted list:\\n\\n1. For the first interval, [-100, -87], we see that its start time is greater than our current end (which is negative infinity at this point). So, we include this interval and update our current end to -87.\\n\\n2. The next interval is [-85, -76], which starts before the current end of -87. That means it\\'s overlapping with the previous interval, so we have to remove it.\\n\\n3. Next, we have [-90, -44]. Its start time (-90) is also less than the current end (-87), so it overlaps with the interval [-100, -87]. We need to remove it.\\n\\n4. The fourth interval is [-86, 7]. Its start time is also less than the current end (-87), so we remove this one too.\\n\\n5. Finally, we have [-70, 33], which starts after our current end of -87. We can include this interval and update our current end to 33.\\n\\nSo, out of the five intervals, we had to remove three and were left with two non-overlapping intervals: [-100,-87] and [-70,33]. The minimum number of intervals we have to remove to make sure no two intervals overlap is 3.\\n"
                    },
                    {
                        "username": "codejstube",
                        "content": "https://youtu.be/Gs7nngH1AEY\\n![image](https://assets.leetcode.com/users/images/de470f4c-692b-47be-8da6-1f1ef545b637_1597558380.5355117.png)\\n"
                    },
                    {
                        "username": "aLaN09",
                        "content": "The initial thoughts to solve this problem would be to iterate throught and have checks for different types of overlappings. Using the greedy approach however we can \"be greedy\" and compute the minimum end time at each overlapping case. Now why should you consider the minimum end time, Because, a minimum current end time would have a lesser chance to overlap with the next interval (don\\'t forget that we need the minimum number of removals). Hence we are greedy in the sense that we compute the **best outcome at each stage **and the best outcome being the minimum end time"
                    },
                    {
                        "username": "yasserhussain1110",
                        "content": "The interval here is half open. [start, end - 1]"
                    },
                    {
                        "username": "ssmoon",
                        "content": "`[1, 2], [2, 3]` isn\\'t considered overlapping, which isn\\'t noted in the description. **56. Merge Intervals** is a similar problem, but the same interval *would* be considered overlapping.\\n\\nTerrible problem description."
                    },
                    {
                        "username": "vivekgr92",
                        "content": "I also had the same issue. I don\\'t know why in this case it is considered as non overlapping"
                    },
                    {
                        "username": "coolspec",
                        "content": "Can somebody tell why the first comparator function is throwing an error given at the end? But the second comparator function doesn\\'t throw any error. Only difference is the equal to sign.\\n1)\\n`bool compareSecondElement(vector<int>& a, vector<int>& b) {\\n    return a[1] <= b[1];\\n}`\\n2)\\n`bool compareSecondElement(vector<int>& a, vector<int>& b) {\\n    return a[1] < b[1];\\n}`\\nSorting code:\\n`sort(intervals.begin(), intervals.end(), compareSecondElement);` \\nERROR: (I think it is a out of bound error)\\nLine 1034: Char 34: runtime error: applying non-zero offset 4 to null pointer (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "curryGoat",
                        "content": "Can someone provide list of all interval problems"
                    },
                    {
                        "username": "iffthen",
                        "content": "Is there any way to optimise it to O(n), I mean by using some sort of extra sapce?? as far as I know if i solve it with dp or greedy it will take O(nlogn). "
                    }
                ]
            },
            {
                "id": 2039909,
                "content": [
                    {
                        "username": "MNARAYAN04",
                        "content": "And this make my 200 active days of code "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Another interval can start on the end day of a previous interval without overlapping. They didn\\'t specifically mention that, but I thought it was relevant."
                    },
                    {
                        "username": "piyushisawesome2",
                        "content": "Can some help understand the solution for this case\\n\\n[[-100,-87],[-90,-44],[-86,7],[-85,-76],[-70,33]]"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@bparanj](/bparanj) the correct answer is 2, need to remove [-90,-44] and [-86,7]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks us to remove the minimum number of intervals such that no two intervals are overlapping. Let\\'s break down the process of solving this for the provided list of intervals using the greedy approach.\\n\\nHere\\'s the list of intervals you\\'ve given:\\n\\n    [[-100,-87],[-90,-44],[-86,7],[-85,-76],[-70,33]]\\n\\nFirst, we\\'ll want to sort these intervals by their end times:\\n\\n    [[-100,-87],[-85,-76],[-90,-44],[-86,7],[-70,33]]\\n\\nNow we\\'ll start going through these intervals one by one, from beginning to end, keeping track of the end of the interval that we\\'re considering including in our final set of non-overlapping intervals. Initially, we haven\\'t chosen any intervals, so this \"current end\" is negative infinity.\\n\\nAs we go through the intervals in our sorted list:\\n\\n1. For the first interval, [-100, -87], we see that its start time is greater than our current end (which is negative infinity at this point). So, we include this interval and update our current end to -87.\\n\\n2. The next interval is [-85, -76], which starts before the current end of -87. That means it\\'s overlapping with the previous interval, so we have to remove it.\\n\\n3. Next, we have [-90, -44]. Its start time (-90) is also less than the current end (-87), so it overlaps with the interval [-100, -87]. We need to remove it.\\n\\n4. The fourth interval is [-86, 7]. Its start time is also less than the current end (-87), so we remove this one too.\\n\\n5. Finally, we have [-70, 33], which starts after our current end of -87. We can include this interval and update our current end to 33.\\n\\nSo, out of the five intervals, we had to remove three and were left with two non-overlapping intervals: [-100,-87] and [-70,33]. The minimum number of intervals we have to remove to make sure no two intervals overlap is 3.\\n"
                    },
                    {
                        "username": "codejstube",
                        "content": "https://youtu.be/Gs7nngH1AEY\\n![image](https://assets.leetcode.com/users/images/de470f4c-692b-47be-8da6-1f1ef545b637_1597558380.5355117.png)\\n"
                    },
                    {
                        "username": "aLaN09",
                        "content": "The initial thoughts to solve this problem would be to iterate throught and have checks for different types of overlappings. Using the greedy approach however we can \"be greedy\" and compute the minimum end time at each overlapping case. Now why should you consider the minimum end time, Because, a minimum current end time would have a lesser chance to overlap with the next interval (don\\'t forget that we need the minimum number of removals). Hence we are greedy in the sense that we compute the **best outcome at each stage **and the best outcome being the minimum end time"
                    },
                    {
                        "username": "yasserhussain1110",
                        "content": "The interval here is half open. [start, end - 1]"
                    },
                    {
                        "username": "ssmoon",
                        "content": "`[1, 2], [2, 3]` isn\\'t considered overlapping, which isn\\'t noted in the description. **56. Merge Intervals** is a similar problem, but the same interval *would* be considered overlapping.\\n\\nTerrible problem description."
                    },
                    {
                        "username": "vivekgr92",
                        "content": "I also had the same issue. I don\\'t know why in this case it is considered as non overlapping"
                    },
                    {
                        "username": "coolspec",
                        "content": "Can somebody tell why the first comparator function is throwing an error given at the end? But the second comparator function doesn\\'t throw any error. Only difference is the equal to sign.\\n1)\\n`bool compareSecondElement(vector<int>& a, vector<int>& b) {\\n    return a[1] <= b[1];\\n}`\\n2)\\n`bool compareSecondElement(vector<int>& a, vector<int>& b) {\\n    return a[1] < b[1];\\n}`\\nSorting code:\\n`sort(intervals.begin(), intervals.end(), compareSecondElement);` \\nERROR: (I think it is a out of bound error)\\nLine 1034: Char 34: runtime error: applying non-zero offset 4 to null pointer (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "curryGoat",
                        "content": "Can someone provide list of all interval problems"
                    },
                    {
                        "username": "iffthen",
                        "content": "Is there any way to optimise it to O(n), I mean by using some sort of extra sapce?? as far as I know if i solve it with dp or greedy it will take O(nlogn). "
                    }
                ]
            },
            {
                "id": 2022454,
                "content": [
                    {
                        "username": "MNARAYAN04",
                        "content": "And this make my 200 active days of code "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Another interval can start on the end day of a previous interval without overlapping. They didn\\'t specifically mention that, but I thought it was relevant."
                    },
                    {
                        "username": "piyushisawesome2",
                        "content": "Can some help understand the solution for this case\\n\\n[[-100,-87],[-90,-44],[-86,7],[-85,-76],[-70,33]]"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@bparanj](/bparanj) the correct answer is 2, need to remove [-90,-44] and [-86,7]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks us to remove the minimum number of intervals such that no two intervals are overlapping. Let\\'s break down the process of solving this for the provided list of intervals using the greedy approach.\\n\\nHere\\'s the list of intervals you\\'ve given:\\n\\n    [[-100,-87],[-90,-44],[-86,7],[-85,-76],[-70,33]]\\n\\nFirst, we\\'ll want to sort these intervals by their end times:\\n\\n    [[-100,-87],[-85,-76],[-90,-44],[-86,7],[-70,33]]\\n\\nNow we\\'ll start going through these intervals one by one, from beginning to end, keeping track of the end of the interval that we\\'re considering including in our final set of non-overlapping intervals. Initially, we haven\\'t chosen any intervals, so this \"current end\" is negative infinity.\\n\\nAs we go through the intervals in our sorted list:\\n\\n1. For the first interval, [-100, -87], we see that its start time is greater than our current end (which is negative infinity at this point). So, we include this interval and update our current end to -87.\\n\\n2. The next interval is [-85, -76], which starts before the current end of -87. That means it\\'s overlapping with the previous interval, so we have to remove it.\\n\\n3. Next, we have [-90, -44]. Its start time (-90) is also less than the current end (-87), so it overlaps with the interval [-100, -87]. We need to remove it.\\n\\n4. The fourth interval is [-86, 7]. Its start time is also less than the current end (-87), so we remove this one too.\\n\\n5. Finally, we have [-70, 33], which starts after our current end of -87. We can include this interval and update our current end to 33.\\n\\nSo, out of the five intervals, we had to remove three and were left with two non-overlapping intervals: [-100,-87] and [-70,33]. The minimum number of intervals we have to remove to make sure no two intervals overlap is 3.\\n"
                    },
                    {
                        "username": "codejstube",
                        "content": "https://youtu.be/Gs7nngH1AEY\\n![image](https://assets.leetcode.com/users/images/de470f4c-692b-47be-8da6-1f1ef545b637_1597558380.5355117.png)\\n"
                    },
                    {
                        "username": "aLaN09",
                        "content": "The initial thoughts to solve this problem would be to iterate throught and have checks for different types of overlappings. Using the greedy approach however we can \"be greedy\" and compute the minimum end time at each overlapping case. Now why should you consider the minimum end time, Because, a minimum current end time would have a lesser chance to overlap with the next interval (don\\'t forget that we need the minimum number of removals). Hence we are greedy in the sense that we compute the **best outcome at each stage **and the best outcome being the minimum end time"
                    },
                    {
                        "username": "yasserhussain1110",
                        "content": "The interval here is half open. [start, end - 1]"
                    },
                    {
                        "username": "ssmoon",
                        "content": "`[1, 2], [2, 3]` isn\\'t considered overlapping, which isn\\'t noted in the description. **56. Merge Intervals** is a similar problem, but the same interval *would* be considered overlapping.\\n\\nTerrible problem description."
                    },
                    {
                        "username": "vivekgr92",
                        "content": "I also had the same issue. I don\\'t know why in this case it is considered as non overlapping"
                    },
                    {
                        "username": "coolspec",
                        "content": "Can somebody tell why the first comparator function is throwing an error given at the end? But the second comparator function doesn\\'t throw any error. Only difference is the equal to sign.\\n1)\\n`bool compareSecondElement(vector<int>& a, vector<int>& b) {\\n    return a[1] <= b[1];\\n}`\\n2)\\n`bool compareSecondElement(vector<int>& a, vector<int>& b) {\\n    return a[1] < b[1];\\n}`\\nSorting code:\\n`sort(intervals.begin(), intervals.end(), compareSecondElement);` \\nERROR: (I think it is a out of bound error)\\nLine 1034: Char 34: runtime error: applying non-zero offset 4 to null pointer (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "curryGoat",
                        "content": "Can someone provide list of all interval problems"
                    },
                    {
                        "username": "iffthen",
                        "content": "Is there any way to optimise it to O(n), I mean by using some sort of extra sapce?? as far as I know if i solve it with dp or greedy it will take O(nlogn). "
                    }
                ]
            },
            {
                "id": 1989766,
                "content": [
                    {
                        "username": "MNARAYAN04",
                        "content": "And this make my 200 active days of code "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Another interval can start on the end day of a previous interval without overlapping. They didn\\'t specifically mention that, but I thought it was relevant."
                    },
                    {
                        "username": "piyushisawesome2",
                        "content": "Can some help understand the solution for this case\\n\\n[[-100,-87],[-90,-44],[-86,7],[-85,-76],[-70,33]]"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@bparanj](/bparanj) the correct answer is 2, need to remove [-90,-44] and [-86,7]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks us to remove the minimum number of intervals such that no two intervals are overlapping. Let\\'s break down the process of solving this for the provided list of intervals using the greedy approach.\\n\\nHere\\'s the list of intervals you\\'ve given:\\n\\n    [[-100,-87],[-90,-44],[-86,7],[-85,-76],[-70,33]]\\n\\nFirst, we\\'ll want to sort these intervals by their end times:\\n\\n    [[-100,-87],[-85,-76],[-90,-44],[-86,7],[-70,33]]\\n\\nNow we\\'ll start going through these intervals one by one, from beginning to end, keeping track of the end of the interval that we\\'re considering including in our final set of non-overlapping intervals. Initially, we haven\\'t chosen any intervals, so this \"current end\" is negative infinity.\\n\\nAs we go through the intervals in our sorted list:\\n\\n1. For the first interval, [-100, -87], we see that its start time is greater than our current end (which is negative infinity at this point). So, we include this interval and update our current end to -87.\\n\\n2. The next interval is [-85, -76], which starts before the current end of -87. That means it\\'s overlapping with the previous interval, so we have to remove it.\\n\\n3. Next, we have [-90, -44]. Its start time (-90) is also less than the current end (-87), so it overlaps with the interval [-100, -87]. We need to remove it.\\n\\n4. The fourth interval is [-86, 7]. Its start time is also less than the current end (-87), so we remove this one too.\\n\\n5. Finally, we have [-70, 33], which starts after our current end of -87. We can include this interval and update our current end to 33.\\n\\nSo, out of the five intervals, we had to remove three and were left with two non-overlapping intervals: [-100,-87] and [-70,33]. The minimum number of intervals we have to remove to make sure no two intervals overlap is 3.\\n"
                    },
                    {
                        "username": "codejstube",
                        "content": "https://youtu.be/Gs7nngH1AEY\\n![image](https://assets.leetcode.com/users/images/de470f4c-692b-47be-8da6-1f1ef545b637_1597558380.5355117.png)\\n"
                    },
                    {
                        "username": "aLaN09",
                        "content": "The initial thoughts to solve this problem would be to iterate throught and have checks for different types of overlappings. Using the greedy approach however we can \"be greedy\" and compute the minimum end time at each overlapping case. Now why should you consider the minimum end time, Because, a minimum current end time would have a lesser chance to overlap with the next interval (don\\'t forget that we need the minimum number of removals). Hence we are greedy in the sense that we compute the **best outcome at each stage **and the best outcome being the minimum end time"
                    },
                    {
                        "username": "yasserhussain1110",
                        "content": "The interval here is half open. [start, end - 1]"
                    },
                    {
                        "username": "ssmoon",
                        "content": "`[1, 2], [2, 3]` isn\\'t considered overlapping, which isn\\'t noted in the description. **56. Merge Intervals** is a similar problem, but the same interval *would* be considered overlapping.\\n\\nTerrible problem description."
                    },
                    {
                        "username": "vivekgr92",
                        "content": "I also had the same issue. I don\\'t know why in this case it is considered as non overlapping"
                    },
                    {
                        "username": "coolspec",
                        "content": "Can somebody tell why the first comparator function is throwing an error given at the end? But the second comparator function doesn\\'t throw any error. Only difference is the equal to sign.\\n1)\\n`bool compareSecondElement(vector<int>& a, vector<int>& b) {\\n    return a[1] <= b[1];\\n}`\\n2)\\n`bool compareSecondElement(vector<int>& a, vector<int>& b) {\\n    return a[1] < b[1];\\n}`\\nSorting code:\\n`sort(intervals.begin(), intervals.end(), compareSecondElement);` \\nERROR: (I think it is a out of bound error)\\nLine 1034: Char 34: runtime error: applying non-zero offset 4 to null pointer (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "curryGoat",
                        "content": "Can someone provide list of all interval problems"
                    },
                    {
                        "username": "iffthen",
                        "content": "Is there any way to optimise it to O(n), I mean by using some sort of extra sapce?? as far as I know if i solve it with dp or greedy it will take O(nlogn). "
                    }
                ]
            },
            {
                "id": 1989229,
                "content": [
                    {
                        "username": "MNARAYAN04",
                        "content": "And this make my 200 active days of code "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Another interval can start on the end day of a previous interval without overlapping. They didn\\'t specifically mention that, but I thought it was relevant."
                    },
                    {
                        "username": "piyushisawesome2",
                        "content": "Can some help understand the solution for this case\\n\\n[[-100,-87],[-90,-44],[-86,7],[-85,-76],[-70,33]]"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@bparanj](/bparanj) the correct answer is 2, need to remove [-90,-44] and [-86,7]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks us to remove the minimum number of intervals such that no two intervals are overlapping. Let\\'s break down the process of solving this for the provided list of intervals using the greedy approach.\\n\\nHere\\'s the list of intervals you\\'ve given:\\n\\n    [[-100,-87],[-90,-44],[-86,7],[-85,-76],[-70,33]]\\n\\nFirst, we\\'ll want to sort these intervals by their end times:\\n\\n    [[-100,-87],[-85,-76],[-90,-44],[-86,7],[-70,33]]\\n\\nNow we\\'ll start going through these intervals one by one, from beginning to end, keeping track of the end of the interval that we\\'re considering including in our final set of non-overlapping intervals. Initially, we haven\\'t chosen any intervals, so this \"current end\" is negative infinity.\\n\\nAs we go through the intervals in our sorted list:\\n\\n1. For the first interval, [-100, -87], we see that its start time is greater than our current end (which is negative infinity at this point). So, we include this interval and update our current end to -87.\\n\\n2. The next interval is [-85, -76], which starts before the current end of -87. That means it\\'s overlapping with the previous interval, so we have to remove it.\\n\\n3. Next, we have [-90, -44]. Its start time (-90) is also less than the current end (-87), so it overlaps with the interval [-100, -87]. We need to remove it.\\n\\n4. The fourth interval is [-86, 7]. Its start time is also less than the current end (-87), so we remove this one too.\\n\\n5. Finally, we have [-70, 33], which starts after our current end of -87. We can include this interval and update our current end to 33.\\n\\nSo, out of the five intervals, we had to remove three and were left with two non-overlapping intervals: [-100,-87] and [-70,33]. The minimum number of intervals we have to remove to make sure no two intervals overlap is 3.\\n"
                    },
                    {
                        "username": "codejstube",
                        "content": "https://youtu.be/Gs7nngH1AEY\\n![image](https://assets.leetcode.com/users/images/de470f4c-692b-47be-8da6-1f1ef545b637_1597558380.5355117.png)\\n"
                    },
                    {
                        "username": "aLaN09",
                        "content": "The initial thoughts to solve this problem would be to iterate throught and have checks for different types of overlappings. Using the greedy approach however we can \"be greedy\" and compute the minimum end time at each overlapping case. Now why should you consider the minimum end time, Because, a minimum current end time would have a lesser chance to overlap with the next interval (don\\'t forget that we need the minimum number of removals). Hence we are greedy in the sense that we compute the **best outcome at each stage **and the best outcome being the minimum end time"
                    },
                    {
                        "username": "yasserhussain1110",
                        "content": "The interval here is half open. [start, end - 1]"
                    },
                    {
                        "username": "ssmoon",
                        "content": "`[1, 2], [2, 3]` isn\\'t considered overlapping, which isn\\'t noted in the description. **56. Merge Intervals** is a similar problem, but the same interval *would* be considered overlapping.\\n\\nTerrible problem description."
                    },
                    {
                        "username": "vivekgr92",
                        "content": "I also had the same issue. I don\\'t know why in this case it is considered as non overlapping"
                    },
                    {
                        "username": "coolspec",
                        "content": "Can somebody tell why the first comparator function is throwing an error given at the end? But the second comparator function doesn\\'t throw any error. Only difference is the equal to sign.\\n1)\\n`bool compareSecondElement(vector<int>& a, vector<int>& b) {\\n    return a[1] <= b[1];\\n}`\\n2)\\n`bool compareSecondElement(vector<int>& a, vector<int>& b) {\\n    return a[1] < b[1];\\n}`\\nSorting code:\\n`sort(intervals.begin(), intervals.end(), compareSecondElement);` \\nERROR: (I think it is a out of bound error)\\nLine 1034: Char 34: runtime error: applying non-zero offset 4 to null pointer (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "curryGoat",
                        "content": "Can someone provide list of all interval problems"
                    },
                    {
                        "username": "iffthen",
                        "content": "Is there any way to optimise it to O(n), I mean by using some sort of extra sapce?? as far as I know if i solve it with dp or greedy it will take O(nlogn). "
                    }
                ]
            },
            {
                "id": 1977682,
                "content": [
                    {
                        "username": "MNARAYAN04",
                        "content": "And this make my 200 active days of code "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Another interval can start on the end day of a previous interval without overlapping. They didn\\'t specifically mention that, but I thought it was relevant."
                    },
                    {
                        "username": "piyushisawesome2",
                        "content": "Can some help understand the solution for this case\\n\\n[[-100,-87],[-90,-44],[-86,7],[-85,-76],[-70,33]]"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@bparanj](/bparanj) the correct answer is 2, need to remove [-90,-44] and [-86,7]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks us to remove the minimum number of intervals such that no two intervals are overlapping. Let\\'s break down the process of solving this for the provided list of intervals using the greedy approach.\\n\\nHere\\'s the list of intervals you\\'ve given:\\n\\n    [[-100,-87],[-90,-44],[-86,7],[-85,-76],[-70,33]]\\n\\nFirst, we\\'ll want to sort these intervals by their end times:\\n\\n    [[-100,-87],[-85,-76],[-90,-44],[-86,7],[-70,33]]\\n\\nNow we\\'ll start going through these intervals one by one, from beginning to end, keeping track of the end of the interval that we\\'re considering including in our final set of non-overlapping intervals. Initially, we haven\\'t chosen any intervals, so this \"current end\" is negative infinity.\\n\\nAs we go through the intervals in our sorted list:\\n\\n1. For the first interval, [-100, -87], we see that its start time is greater than our current end (which is negative infinity at this point). So, we include this interval and update our current end to -87.\\n\\n2. The next interval is [-85, -76], which starts before the current end of -87. That means it\\'s overlapping with the previous interval, so we have to remove it.\\n\\n3. Next, we have [-90, -44]. Its start time (-90) is also less than the current end (-87), so it overlaps with the interval [-100, -87]. We need to remove it.\\n\\n4. The fourth interval is [-86, 7]. Its start time is also less than the current end (-87), so we remove this one too.\\n\\n5. Finally, we have [-70, 33], which starts after our current end of -87. We can include this interval and update our current end to 33.\\n\\nSo, out of the five intervals, we had to remove three and were left with two non-overlapping intervals: [-100,-87] and [-70,33]. The minimum number of intervals we have to remove to make sure no two intervals overlap is 3.\\n"
                    },
                    {
                        "username": "codejstube",
                        "content": "https://youtu.be/Gs7nngH1AEY\\n![image](https://assets.leetcode.com/users/images/de470f4c-692b-47be-8da6-1f1ef545b637_1597558380.5355117.png)\\n"
                    },
                    {
                        "username": "aLaN09",
                        "content": "The initial thoughts to solve this problem would be to iterate throught and have checks for different types of overlappings. Using the greedy approach however we can \"be greedy\" and compute the minimum end time at each overlapping case. Now why should you consider the minimum end time, Because, a minimum current end time would have a lesser chance to overlap with the next interval (don\\'t forget that we need the minimum number of removals). Hence we are greedy in the sense that we compute the **best outcome at each stage **and the best outcome being the minimum end time"
                    },
                    {
                        "username": "yasserhussain1110",
                        "content": "The interval here is half open. [start, end - 1]"
                    },
                    {
                        "username": "ssmoon",
                        "content": "`[1, 2], [2, 3]` isn\\'t considered overlapping, which isn\\'t noted in the description. **56. Merge Intervals** is a similar problem, but the same interval *would* be considered overlapping.\\n\\nTerrible problem description."
                    },
                    {
                        "username": "vivekgr92",
                        "content": "I also had the same issue. I don\\'t know why in this case it is considered as non overlapping"
                    },
                    {
                        "username": "coolspec",
                        "content": "Can somebody tell why the first comparator function is throwing an error given at the end? But the second comparator function doesn\\'t throw any error. Only difference is the equal to sign.\\n1)\\n`bool compareSecondElement(vector<int>& a, vector<int>& b) {\\n    return a[1] <= b[1];\\n}`\\n2)\\n`bool compareSecondElement(vector<int>& a, vector<int>& b) {\\n    return a[1] < b[1];\\n}`\\nSorting code:\\n`sort(intervals.begin(), intervals.end(), compareSecondElement);` \\nERROR: (I think it is a out of bound error)\\nLine 1034: Char 34: runtime error: applying non-zero offset 4 to null pointer (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "curryGoat",
                        "content": "Can someone provide list of all interval problems"
                    },
                    {
                        "username": "iffthen",
                        "content": "Is there any way to optimise it to O(n), I mean by using some sort of extra sapce?? as far as I know if i solve it with dp or greedy it will take O(nlogn). "
                    }
                ]
            },
            {
                "id": 1977641,
                "content": [
                    {
                        "username": "MNARAYAN04",
                        "content": "And this make my 200 active days of code "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Another interval can start on the end day of a previous interval without overlapping. They didn\\'t specifically mention that, but I thought it was relevant."
                    },
                    {
                        "username": "piyushisawesome2",
                        "content": "Can some help understand the solution for this case\\n\\n[[-100,-87],[-90,-44],[-86,7],[-85,-76],[-70,33]]"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@bparanj](/bparanj) the correct answer is 2, need to remove [-90,-44] and [-86,7]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks us to remove the minimum number of intervals such that no two intervals are overlapping. Let\\'s break down the process of solving this for the provided list of intervals using the greedy approach.\\n\\nHere\\'s the list of intervals you\\'ve given:\\n\\n    [[-100,-87],[-90,-44],[-86,7],[-85,-76],[-70,33]]\\n\\nFirst, we\\'ll want to sort these intervals by their end times:\\n\\n    [[-100,-87],[-85,-76],[-90,-44],[-86,7],[-70,33]]\\n\\nNow we\\'ll start going through these intervals one by one, from beginning to end, keeping track of the end of the interval that we\\'re considering including in our final set of non-overlapping intervals. Initially, we haven\\'t chosen any intervals, so this \"current end\" is negative infinity.\\n\\nAs we go through the intervals in our sorted list:\\n\\n1. For the first interval, [-100, -87], we see that its start time is greater than our current end (which is negative infinity at this point). So, we include this interval and update our current end to -87.\\n\\n2. The next interval is [-85, -76], which starts before the current end of -87. That means it\\'s overlapping with the previous interval, so we have to remove it.\\n\\n3. Next, we have [-90, -44]. Its start time (-90) is also less than the current end (-87), so it overlaps with the interval [-100, -87]. We need to remove it.\\n\\n4. The fourth interval is [-86, 7]. Its start time is also less than the current end (-87), so we remove this one too.\\n\\n5. Finally, we have [-70, 33], which starts after our current end of -87. We can include this interval and update our current end to 33.\\n\\nSo, out of the five intervals, we had to remove three and were left with two non-overlapping intervals: [-100,-87] and [-70,33]. The minimum number of intervals we have to remove to make sure no two intervals overlap is 3.\\n"
                    },
                    {
                        "username": "codejstube",
                        "content": "https://youtu.be/Gs7nngH1AEY\\n![image](https://assets.leetcode.com/users/images/de470f4c-692b-47be-8da6-1f1ef545b637_1597558380.5355117.png)\\n"
                    },
                    {
                        "username": "aLaN09",
                        "content": "The initial thoughts to solve this problem would be to iterate throught and have checks for different types of overlappings. Using the greedy approach however we can \"be greedy\" and compute the minimum end time at each overlapping case. Now why should you consider the minimum end time, Because, a minimum current end time would have a lesser chance to overlap with the next interval (don\\'t forget that we need the minimum number of removals). Hence we are greedy in the sense that we compute the **best outcome at each stage **and the best outcome being the minimum end time"
                    },
                    {
                        "username": "yasserhussain1110",
                        "content": "The interval here is half open. [start, end - 1]"
                    },
                    {
                        "username": "ssmoon",
                        "content": "`[1, 2], [2, 3]` isn\\'t considered overlapping, which isn\\'t noted in the description. **56. Merge Intervals** is a similar problem, but the same interval *would* be considered overlapping.\\n\\nTerrible problem description."
                    },
                    {
                        "username": "vivekgr92",
                        "content": "I also had the same issue. I don\\'t know why in this case it is considered as non overlapping"
                    },
                    {
                        "username": "coolspec",
                        "content": "Can somebody tell why the first comparator function is throwing an error given at the end? But the second comparator function doesn\\'t throw any error. Only difference is the equal to sign.\\n1)\\n`bool compareSecondElement(vector<int>& a, vector<int>& b) {\\n    return a[1] <= b[1];\\n}`\\n2)\\n`bool compareSecondElement(vector<int>& a, vector<int>& b) {\\n    return a[1] < b[1];\\n}`\\nSorting code:\\n`sort(intervals.begin(), intervals.end(), compareSecondElement);` \\nERROR: (I think it is a out of bound error)\\nLine 1034: Char 34: runtime error: applying non-zero offset 4 to null pointer (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "curryGoat",
                        "content": "Can someone provide list of all interval problems"
                    },
                    {
                        "username": "iffthen",
                        "content": "Is there any way to optimise it to O(n), I mean by using some sort of extra sapce?? as far as I know if i solve it with dp or greedy it will take O(nlogn). "
                    }
                ]
            },
            {
                "id": 1977553,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "To sort double dimensional array, I used this but it throws an error on sorting a big input of test case 56, does anyone know why?\\nArrays.sort(intervals,new Comparator<int[]>() {\\n            public int compare(int[] f, int[] s){\\n                if(f[1]>s[1]){\\n                    return 1;\\n                }\\n                else return -1;\\n            }"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "its showing the last test case blank and rejecting the answer by saying time limit exceeded"
                    },
                    {
                        "username": "SMAbhay",
                        "content": "VERY MUCH SIMILAR TO \"MAXIMUM MEETING ALLOWED IN A ROOM \" PROBLEM"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "After trying to apply dynamic programming on this question, I knew we had to delete one of the two overlapping intervals. Deleting the interval with highest end time came to my mind but I thought it make go wrong with one or the other case. Had a hard time believing greedy actually worked here. What are your thoughts?"
                    },
                    {
                        "username": "An0rack",
                        "content": "Why did we sort on basis of end time and not on the basis of starting time?"
                    },
                    {
                        "username": "devanshbatra",
                        "content": "Because it would not be feasible to pick the interval with lowest start time first without knowing its end time. It may be possible that the first interval\\'s end time is much greater than next three intervals.\\nOn the other hand if we sort by the end times, then we know that after the interval has ended it\\'s story is over now and we can check the next ones.\\nHope this helps!"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "am I the only one who did it like this \\n \\n class Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int n=intervals.size();\\n        int prevend=intervals[0][1];\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n            if(intervals[i][0]<prevend){\\n                ans++;\\n                prevend=min(prevend,intervals[i][1]);\\n            }\\n            else{\\n                prevend=intervals[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are the only one who post solution in Discussions :)\\nPeople try to rescue tips here, not spoilers."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Anyone else find it really discouraging when runtime is bugged for a problem? My solution is almost identical to those getting ~15ms runtime on java, and yet i\\'m getting ~70ms. "
                    },
                    {
                        "username": "sravani_15",
                        "content": "Why do I feel it as the hardest question today...????\\nAm I the only one who felt that, someone help me with this problem please"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Don\\'t Worry if the problem seems hard then you got something new on your hands to learn and if u wanna solve more problems like this one check line sweep algorithm\\nhttps://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms\\nhere\\'s a great post for u"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s a funny problem to me!"
                    },
                    {
                        "username": "rituraazz",
                        "content": "Isn\\'t it necessary that all the intervals be included in solution set of non-overlapping sub intervals?\\nWhat should be the answer for [ [2,5] ,[3,6] ]?\\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "It should be 1 because [2,5] and [3,6] are overlapped. Removing either one works. "
                    }
                ]
            },
            {
                "id": 1977531,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "To sort double dimensional array, I used this but it throws an error on sorting a big input of test case 56, does anyone know why?\\nArrays.sort(intervals,new Comparator<int[]>() {\\n            public int compare(int[] f, int[] s){\\n                if(f[1]>s[1]){\\n                    return 1;\\n                }\\n                else return -1;\\n            }"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "its showing the last test case blank and rejecting the answer by saying time limit exceeded"
                    },
                    {
                        "username": "SMAbhay",
                        "content": "VERY MUCH SIMILAR TO \"MAXIMUM MEETING ALLOWED IN A ROOM \" PROBLEM"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "After trying to apply dynamic programming on this question, I knew we had to delete one of the two overlapping intervals. Deleting the interval with highest end time came to my mind but I thought it make go wrong with one or the other case. Had a hard time believing greedy actually worked here. What are your thoughts?"
                    },
                    {
                        "username": "An0rack",
                        "content": "Why did we sort on basis of end time and not on the basis of starting time?"
                    },
                    {
                        "username": "devanshbatra",
                        "content": "Because it would not be feasible to pick the interval with lowest start time first without knowing its end time. It may be possible that the first interval\\'s end time is much greater than next three intervals.\\nOn the other hand if we sort by the end times, then we know that after the interval has ended it\\'s story is over now and we can check the next ones.\\nHope this helps!"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "am I the only one who did it like this \\n \\n class Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int n=intervals.size();\\n        int prevend=intervals[0][1];\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n            if(intervals[i][0]<prevend){\\n                ans++;\\n                prevend=min(prevend,intervals[i][1]);\\n            }\\n            else{\\n                prevend=intervals[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are the only one who post solution in Discussions :)\\nPeople try to rescue tips here, not spoilers."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Anyone else find it really discouraging when runtime is bugged for a problem? My solution is almost identical to those getting ~15ms runtime on java, and yet i\\'m getting ~70ms. "
                    },
                    {
                        "username": "sravani_15",
                        "content": "Why do I feel it as the hardest question today...????\\nAm I the only one who felt that, someone help me with this problem please"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Don\\'t Worry if the problem seems hard then you got something new on your hands to learn and if u wanna solve more problems like this one check line sweep algorithm\\nhttps://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms\\nhere\\'s a great post for u"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s a funny problem to me!"
                    },
                    {
                        "username": "rituraazz",
                        "content": "Isn\\'t it necessary that all the intervals be included in solution set of non-overlapping sub intervals?\\nWhat should be the answer for [ [2,5] ,[3,6] ]?\\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "It should be 1 because [2,5] and [3,6] are overlapped. Removing either one works. "
                    }
                ]
            },
            {
                "id": 1977493,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "To sort double dimensional array, I used this but it throws an error on sorting a big input of test case 56, does anyone know why?\\nArrays.sort(intervals,new Comparator<int[]>() {\\n            public int compare(int[] f, int[] s){\\n                if(f[1]>s[1]){\\n                    return 1;\\n                }\\n                else return -1;\\n            }"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "its showing the last test case blank and rejecting the answer by saying time limit exceeded"
                    },
                    {
                        "username": "SMAbhay",
                        "content": "VERY MUCH SIMILAR TO \"MAXIMUM MEETING ALLOWED IN A ROOM \" PROBLEM"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "After trying to apply dynamic programming on this question, I knew we had to delete one of the two overlapping intervals. Deleting the interval with highest end time came to my mind but I thought it make go wrong with one or the other case. Had a hard time believing greedy actually worked here. What are your thoughts?"
                    },
                    {
                        "username": "An0rack",
                        "content": "Why did we sort on basis of end time and not on the basis of starting time?"
                    },
                    {
                        "username": "devanshbatra",
                        "content": "Because it would not be feasible to pick the interval with lowest start time first without knowing its end time. It may be possible that the first interval\\'s end time is much greater than next three intervals.\\nOn the other hand if we sort by the end times, then we know that after the interval has ended it\\'s story is over now and we can check the next ones.\\nHope this helps!"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "am I the only one who did it like this \\n \\n class Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int n=intervals.size();\\n        int prevend=intervals[0][1];\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n            if(intervals[i][0]<prevend){\\n                ans++;\\n                prevend=min(prevend,intervals[i][1]);\\n            }\\n            else{\\n                prevend=intervals[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are the only one who post solution in Discussions :)\\nPeople try to rescue tips here, not spoilers."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Anyone else find it really discouraging when runtime is bugged for a problem? My solution is almost identical to those getting ~15ms runtime on java, and yet i\\'m getting ~70ms. "
                    },
                    {
                        "username": "sravani_15",
                        "content": "Why do I feel it as the hardest question today...????\\nAm I the only one who felt that, someone help me with this problem please"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Don\\'t Worry if the problem seems hard then you got something new on your hands to learn and if u wanna solve more problems like this one check line sweep algorithm\\nhttps://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms\\nhere\\'s a great post for u"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s a funny problem to me!"
                    },
                    {
                        "username": "rituraazz",
                        "content": "Isn\\'t it necessary that all the intervals be included in solution set of non-overlapping sub intervals?\\nWhat should be the answer for [ [2,5] ,[3,6] ]?\\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "It should be 1 because [2,5] and [3,6] are overlapped. Removing either one works. "
                    }
                ]
            },
            {
                "id": 1977476,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "To sort double dimensional array, I used this but it throws an error on sorting a big input of test case 56, does anyone know why?\\nArrays.sort(intervals,new Comparator<int[]>() {\\n            public int compare(int[] f, int[] s){\\n                if(f[1]>s[1]){\\n                    return 1;\\n                }\\n                else return -1;\\n            }"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "its showing the last test case blank and rejecting the answer by saying time limit exceeded"
                    },
                    {
                        "username": "SMAbhay",
                        "content": "VERY MUCH SIMILAR TO \"MAXIMUM MEETING ALLOWED IN A ROOM \" PROBLEM"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "After trying to apply dynamic programming on this question, I knew we had to delete one of the two overlapping intervals. Deleting the interval with highest end time came to my mind but I thought it make go wrong with one or the other case. Had a hard time believing greedy actually worked here. What are your thoughts?"
                    },
                    {
                        "username": "An0rack",
                        "content": "Why did we sort on basis of end time and not on the basis of starting time?"
                    },
                    {
                        "username": "devanshbatra",
                        "content": "Because it would not be feasible to pick the interval with lowest start time first without knowing its end time. It may be possible that the first interval\\'s end time is much greater than next three intervals.\\nOn the other hand if we sort by the end times, then we know that after the interval has ended it\\'s story is over now and we can check the next ones.\\nHope this helps!"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "am I the only one who did it like this \\n \\n class Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int n=intervals.size();\\n        int prevend=intervals[0][1];\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n            if(intervals[i][0]<prevend){\\n                ans++;\\n                prevend=min(prevend,intervals[i][1]);\\n            }\\n            else{\\n                prevend=intervals[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are the only one who post solution in Discussions :)\\nPeople try to rescue tips here, not spoilers."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Anyone else find it really discouraging when runtime is bugged for a problem? My solution is almost identical to those getting ~15ms runtime on java, and yet i\\'m getting ~70ms. "
                    },
                    {
                        "username": "sravani_15",
                        "content": "Why do I feel it as the hardest question today...????\\nAm I the only one who felt that, someone help me with this problem please"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Don\\'t Worry if the problem seems hard then you got something new on your hands to learn and if u wanna solve more problems like this one check line sweep algorithm\\nhttps://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms\\nhere\\'s a great post for u"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s a funny problem to me!"
                    },
                    {
                        "username": "rituraazz",
                        "content": "Isn\\'t it necessary that all the intervals be included in solution set of non-overlapping sub intervals?\\nWhat should be the answer for [ [2,5] ,[3,6] ]?\\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "It should be 1 because [2,5] and [3,6] are overlapped. Removing either one works. "
                    }
                ]
            },
            {
                "id": 1977468,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "To sort double dimensional array, I used this but it throws an error on sorting a big input of test case 56, does anyone know why?\\nArrays.sort(intervals,new Comparator<int[]>() {\\n            public int compare(int[] f, int[] s){\\n                if(f[1]>s[1]){\\n                    return 1;\\n                }\\n                else return -1;\\n            }"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "its showing the last test case blank and rejecting the answer by saying time limit exceeded"
                    },
                    {
                        "username": "SMAbhay",
                        "content": "VERY MUCH SIMILAR TO \"MAXIMUM MEETING ALLOWED IN A ROOM \" PROBLEM"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "After trying to apply dynamic programming on this question, I knew we had to delete one of the two overlapping intervals. Deleting the interval with highest end time came to my mind but I thought it make go wrong with one or the other case. Had a hard time believing greedy actually worked here. What are your thoughts?"
                    },
                    {
                        "username": "An0rack",
                        "content": "Why did we sort on basis of end time and not on the basis of starting time?"
                    },
                    {
                        "username": "devanshbatra",
                        "content": "Because it would not be feasible to pick the interval with lowest start time first without knowing its end time. It may be possible that the first interval\\'s end time is much greater than next three intervals.\\nOn the other hand if we sort by the end times, then we know that after the interval has ended it\\'s story is over now and we can check the next ones.\\nHope this helps!"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "am I the only one who did it like this \\n \\n class Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int n=intervals.size();\\n        int prevend=intervals[0][1];\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n            if(intervals[i][0]<prevend){\\n                ans++;\\n                prevend=min(prevend,intervals[i][1]);\\n            }\\n            else{\\n                prevend=intervals[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are the only one who post solution in Discussions :)\\nPeople try to rescue tips here, not spoilers."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Anyone else find it really discouraging when runtime is bugged for a problem? My solution is almost identical to those getting ~15ms runtime on java, and yet i\\'m getting ~70ms. "
                    },
                    {
                        "username": "sravani_15",
                        "content": "Why do I feel it as the hardest question today...????\\nAm I the only one who felt that, someone help me with this problem please"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Don\\'t Worry if the problem seems hard then you got something new on your hands to learn and if u wanna solve more problems like this one check line sweep algorithm\\nhttps://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms\\nhere\\'s a great post for u"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s a funny problem to me!"
                    },
                    {
                        "username": "rituraazz",
                        "content": "Isn\\'t it necessary that all the intervals be included in solution set of non-overlapping sub intervals?\\nWhat should be the answer for [ [2,5] ,[3,6] ]?\\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "It should be 1 because [2,5] and [3,6] are overlapped. Removing either one works. "
                    }
                ]
            },
            {
                "id": 1977419,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "To sort double dimensional array, I used this but it throws an error on sorting a big input of test case 56, does anyone know why?\\nArrays.sort(intervals,new Comparator<int[]>() {\\n            public int compare(int[] f, int[] s){\\n                if(f[1]>s[1]){\\n                    return 1;\\n                }\\n                else return -1;\\n            }"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "its showing the last test case blank and rejecting the answer by saying time limit exceeded"
                    },
                    {
                        "username": "SMAbhay",
                        "content": "VERY MUCH SIMILAR TO \"MAXIMUM MEETING ALLOWED IN A ROOM \" PROBLEM"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "After trying to apply dynamic programming on this question, I knew we had to delete one of the two overlapping intervals. Deleting the interval with highest end time came to my mind but I thought it make go wrong with one or the other case. Had a hard time believing greedy actually worked here. What are your thoughts?"
                    },
                    {
                        "username": "An0rack",
                        "content": "Why did we sort on basis of end time and not on the basis of starting time?"
                    },
                    {
                        "username": "devanshbatra",
                        "content": "Because it would not be feasible to pick the interval with lowest start time first without knowing its end time. It may be possible that the first interval\\'s end time is much greater than next three intervals.\\nOn the other hand if we sort by the end times, then we know that after the interval has ended it\\'s story is over now and we can check the next ones.\\nHope this helps!"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "am I the only one who did it like this \\n \\n class Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int n=intervals.size();\\n        int prevend=intervals[0][1];\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n            if(intervals[i][0]<prevend){\\n                ans++;\\n                prevend=min(prevend,intervals[i][1]);\\n            }\\n            else{\\n                prevend=intervals[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are the only one who post solution in Discussions :)\\nPeople try to rescue tips here, not spoilers."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Anyone else find it really discouraging when runtime is bugged for a problem? My solution is almost identical to those getting ~15ms runtime on java, and yet i\\'m getting ~70ms. "
                    },
                    {
                        "username": "sravani_15",
                        "content": "Why do I feel it as the hardest question today...????\\nAm I the only one who felt that, someone help me with this problem please"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Don\\'t Worry if the problem seems hard then you got something new on your hands to learn and if u wanna solve more problems like this one check line sweep algorithm\\nhttps://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms\\nhere\\'s a great post for u"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s a funny problem to me!"
                    },
                    {
                        "username": "rituraazz",
                        "content": "Isn\\'t it necessary that all the intervals be included in solution set of non-overlapping sub intervals?\\nWhat should be the answer for [ [2,5] ,[3,6] ]?\\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "It should be 1 because [2,5] and [3,6] are overlapped. Removing either one works. "
                    }
                ]
            },
            {
                "id": 1977321,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "To sort double dimensional array, I used this but it throws an error on sorting a big input of test case 56, does anyone know why?\\nArrays.sort(intervals,new Comparator<int[]>() {\\n            public int compare(int[] f, int[] s){\\n                if(f[1]>s[1]){\\n                    return 1;\\n                }\\n                else return -1;\\n            }"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "its showing the last test case blank and rejecting the answer by saying time limit exceeded"
                    },
                    {
                        "username": "SMAbhay",
                        "content": "VERY MUCH SIMILAR TO \"MAXIMUM MEETING ALLOWED IN A ROOM \" PROBLEM"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "After trying to apply dynamic programming on this question, I knew we had to delete one of the two overlapping intervals. Deleting the interval with highest end time came to my mind but I thought it make go wrong with one or the other case. Had a hard time believing greedy actually worked here. What are your thoughts?"
                    },
                    {
                        "username": "An0rack",
                        "content": "Why did we sort on basis of end time and not on the basis of starting time?"
                    },
                    {
                        "username": "devanshbatra",
                        "content": "Because it would not be feasible to pick the interval with lowest start time first without knowing its end time. It may be possible that the first interval\\'s end time is much greater than next three intervals.\\nOn the other hand if we sort by the end times, then we know that after the interval has ended it\\'s story is over now and we can check the next ones.\\nHope this helps!"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "am I the only one who did it like this \\n \\n class Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int n=intervals.size();\\n        int prevend=intervals[0][1];\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n            if(intervals[i][0]<prevend){\\n                ans++;\\n                prevend=min(prevend,intervals[i][1]);\\n            }\\n            else{\\n                prevend=intervals[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are the only one who post solution in Discussions :)\\nPeople try to rescue tips here, not spoilers."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Anyone else find it really discouraging when runtime is bugged for a problem? My solution is almost identical to those getting ~15ms runtime on java, and yet i\\'m getting ~70ms. "
                    },
                    {
                        "username": "sravani_15",
                        "content": "Why do I feel it as the hardest question today...????\\nAm I the only one who felt that, someone help me with this problem please"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Don\\'t Worry if the problem seems hard then you got something new on your hands to learn and if u wanna solve more problems like this one check line sweep algorithm\\nhttps://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms\\nhere\\'s a great post for u"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s a funny problem to me!"
                    },
                    {
                        "username": "rituraazz",
                        "content": "Isn\\'t it necessary that all the intervals be included in solution set of non-overlapping sub intervals?\\nWhat should be the answer for [ [2,5] ,[3,6] ]?\\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "It should be 1 because [2,5] and [3,6] are overlapped. Removing either one works. "
                    }
                ]
            },
            {
                "id": 1977210,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "To sort double dimensional array, I used this but it throws an error on sorting a big input of test case 56, does anyone know why?\\nArrays.sort(intervals,new Comparator<int[]>() {\\n            public int compare(int[] f, int[] s){\\n                if(f[1]>s[1]){\\n                    return 1;\\n                }\\n                else return -1;\\n            }"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "its showing the last test case blank and rejecting the answer by saying time limit exceeded"
                    },
                    {
                        "username": "SMAbhay",
                        "content": "VERY MUCH SIMILAR TO \"MAXIMUM MEETING ALLOWED IN A ROOM \" PROBLEM"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "After trying to apply dynamic programming on this question, I knew we had to delete one of the two overlapping intervals. Deleting the interval with highest end time came to my mind but I thought it make go wrong with one or the other case. Had a hard time believing greedy actually worked here. What are your thoughts?"
                    },
                    {
                        "username": "An0rack",
                        "content": "Why did we sort on basis of end time and not on the basis of starting time?"
                    },
                    {
                        "username": "devanshbatra",
                        "content": "Because it would not be feasible to pick the interval with lowest start time first without knowing its end time. It may be possible that the first interval\\'s end time is much greater than next three intervals.\\nOn the other hand if we sort by the end times, then we know that after the interval has ended it\\'s story is over now and we can check the next ones.\\nHope this helps!"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "am I the only one who did it like this \\n \\n class Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int n=intervals.size();\\n        int prevend=intervals[0][1];\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n            if(intervals[i][0]<prevend){\\n                ans++;\\n                prevend=min(prevend,intervals[i][1]);\\n            }\\n            else{\\n                prevend=intervals[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are the only one who post solution in Discussions :)\\nPeople try to rescue tips here, not spoilers."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Anyone else find it really discouraging when runtime is bugged for a problem? My solution is almost identical to those getting ~15ms runtime on java, and yet i\\'m getting ~70ms. "
                    },
                    {
                        "username": "sravani_15",
                        "content": "Why do I feel it as the hardest question today...????\\nAm I the only one who felt that, someone help me with this problem please"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Don\\'t Worry if the problem seems hard then you got something new on your hands to learn and if u wanna solve more problems like this one check line sweep algorithm\\nhttps://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms\\nhere\\'s a great post for u"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s a funny problem to me!"
                    },
                    {
                        "username": "rituraazz",
                        "content": "Isn\\'t it necessary that all the intervals be included in solution set of non-overlapping sub intervals?\\nWhat should be the answer for [ [2,5] ,[3,6] ]?\\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "It should be 1 because [2,5] and [3,6] are overlapped. Removing either one works. "
                    }
                ]
            },
            {
                "id": 1977177,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "To sort double dimensional array, I used this but it throws an error on sorting a big input of test case 56, does anyone know why?\\nArrays.sort(intervals,new Comparator<int[]>() {\\n            public int compare(int[] f, int[] s){\\n                if(f[1]>s[1]){\\n                    return 1;\\n                }\\n                else return -1;\\n            }"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "its showing the last test case blank and rejecting the answer by saying time limit exceeded"
                    },
                    {
                        "username": "SMAbhay",
                        "content": "VERY MUCH SIMILAR TO \"MAXIMUM MEETING ALLOWED IN A ROOM \" PROBLEM"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "After trying to apply dynamic programming on this question, I knew we had to delete one of the two overlapping intervals. Deleting the interval with highest end time came to my mind but I thought it make go wrong with one or the other case. Had a hard time believing greedy actually worked here. What are your thoughts?"
                    },
                    {
                        "username": "An0rack",
                        "content": "Why did we sort on basis of end time and not on the basis of starting time?"
                    },
                    {
                        "username": "devanshbatra",
                        "content": "Because it would not be feasible to pick the interval with lowest start time first without knowing its end time. It may be possible that the first interval\\'s end time is much greater than next three intervals.\\nOn the other hand if we sort by the end times, then we know that after the interval has ended it\\'s story is over now and we can check the next ones.\\nHope this helps!"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "am I the only one who did it like this \\n \\n class Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int n=intervals.size();\\n        int prevend=intervals[0][1];\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n            if(intervals[i][0]<prevend){\\n                ans++;\\n                prevend=min(prevend,intervals[i][1]);\\n            }\\n            else{\\n                prevend=intervals[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are the only one who post solution in Discussions :)\\nPeople try to rescue tips here, not spoilers."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Anyone else find it really discouraging when runtime is bugged for a problem? My solution is almost identical to those getting ~15ms runtime on java, and yet i\\'m getting ~70ms. "
                    },
                    {
                        "username": "sravani_15",
                        "content": "Why do I feel it as the hardest question today...????\\nAm I the only one who felt that, someone help me with this problem please"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Don\\'t Worry if the problem seems hard then you got something new on your hands to learn and if u wanna solve more problems like this one check line sweep algorithm\\nhttps://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms\\nhere\\'s a great post for u"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s a funny problem to me!"
                    },
                    {
                        "username": "rituraazz",
                        "content": "Isn\\'t it necessary that all the intervals be included in solution set of non-overlapping sub intervals?\\nWhat should be the answer for [ [2,5] ,[3,6] ]?\\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "It should be 1 because [2,5] and [3,6] are overlapped. Removing either one works. "
                    }
                ]
            },
            {
                "id": 1977157,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "To sort double dimensional array, I used this but it throws an error on sorting a big input of test case 56, does anyone know why?\\nArrays.sort(intervals,new Comparator<int[]>() {\\n            public int compare(int[] f, int[] s){\\n                if(f[1]>s[1]){\\n                    return 1;\\n                }\\n                else return -1;\\n            }"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "its showing the last test case blank and rejecting the answer by saying time limit exceeded"
                    },
                    {
                        "username": "SMAbhay",
                        "content": "VERY MUCH SIMILAR TO \"MAXIMUM MEETING ALLOWED IN A ROOM \" PROBLEM"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "After trying to apply dynamic programming on this question, I knew we had to delete one of the two overlapping intervals. Deleting the interval with highest end time came to my mind but I thought it make go wrong with one or the other case. Had a hard time believing greedy actually worked here. What are your thoughts?"
                    },
                    {
                        "username": "An0rack",
                        "content": "Why did we sort on basis of end time and not on the basis of starting time?"
                    },
                    {
                        "username": "devanshbatra",
                        "content": "Because it would not be feasible to pick the interval with lowest start time first without knowing its end time. It may be possible that the first interval\\'s end time is much greater than next three intervals.\\nOn the other hand if we sort by the end times, then we know that after the interval has ended it\\'s story is over now and we can check the next ones.\\nHope this helps!"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "am I the only one who did it like this \\n \\n class Solution {\\npublic:\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int n=intervals.size();\\n        int prevend=intervals[0][1];\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n            if(intervals[i][0]<prevend){\\n                ans++;\\n                prevend=min(prevend,intervals[i][1]);\\n            }\\n            else{\\n                prevend=intervals[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are the only one who post solution in Discussions :)\\nPeople try to rescue tips here, not spoilers."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Anyone else find it really discouraging when runtime is bugged for a problem? My solution is almost identical to those getting ~15ms runtime on java, and yet i\\'m getting ~70ms. "
                    },
                    {
                        "username": "sravani_15",
                        "content": "Why do I feel it as the hardest question today...????\\nAm I the only one who felt that, someone help me with this problem please"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Don\\'t Worry if the problem seems hard then you got something new on your hands to learn and if u wanna solve more problems like this one check line sweep algorithm\\nhttps://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms\\nhere\\'s a great post for u"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s a funny problem to me!"
                    },
                    {
                        "username": "rituraazz",
                        "content": "Isn\\'t it necessary that all the intervals be included in solution set of non-overlapping sub intervals?\\nWhat should be the answer for [ [2,5] ,[3,6] ]?\\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "It should be 1 because [2,5] and [3,6] are overlapped. Removing either one works. "
                    }
                ]
            },
            {
                "id": 1976891,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "easy, Academic problem. every institute teach this problem to introduce greedy Algorithm."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Congrats to your Ego :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Two test cases that helped me to figure out the solution:    \n  \n    [[-73,-26],[-65,-11],[-62,-49]]\n    [[1,100],[11,22],[1,11],[2,12]]"
                    },
                    {
                        "username": "srjkmr619",
                        "content": "Why does it shows 58/58 testcases passed but still getting TLE. \\nIf I am getting TLE then how 58/58 passed, it should have been less than the total testcases that should have passed. How can all the test cases pass and still get TLE."
                    },
                    {
                        "username": "sikora92",
                        "content": "It happens when your solution returns correct value, but works too long."
                    },
                    {
                        "username": "santanusen",
                        "content": "Choose the interval that ends first between two overlapping intervals and discard the other."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "This is very similar to July 15 Daily Challenge. Just make a few changes and you are good to continue your Streak!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "It\\'s a relief today"
                    },
                    {
                        "username": "marco_seven",
                        "content": "nice start of the week ,, all the problems from last 3 days ,picked from LeetCode TOP 150 series, I have already done it, and people you try the Leetcode top150 questions"
                    },
                    {
                        "username": "noman598",
                        "content": "greedy - if you get optimal sol then take it & don't worry abt future. eventhough there is more optimal sol.\n\nDP - if you get optimal sol then don't take it. check future optimal sol. Not getting ? backtrack and find other path to get optimal sol. "
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, your description is quite accurate, but it\\'s slightly simplified. \\n\\n1. **Greedy Algorithms:** These algorithms make the locally optimal choice at each step in the hope that these local choices will lead to a global optimum. They do not always produce the absolute best possible solution over all possible solutions for some problems, but they are often efficient and easier to understand and implement. The key aspect here is that once a decision is made, it is not revisited.\\n\\n2. **Dynamic Programming (DP):** DP algorithms solve complex problems by breaking them down into simpler subproblems, solving the subproblems, and using the solutions to build up the solutions to larger problems. The solutions to the subproblems are often stored for future use to avoid redundant calculations (a technique called memoization). The DP approach is typically used when the problem requires making a series of decisions that affect the final solution, and when the problem exhibits \"overlapping subproblems\" and \"optimal substructure\" properties. The decisions made can be revisited and adjusted as more of the problem is explored, hence can find the overall optimal solution. \\n\\nYour point on backtracking is true but more associated with another set of problem-solving strategies where decisions are methodically unmade to explore other potential solutions, usually when the current path being explored is determined to be suboptimal.\\n\\nIn the context of this interval problem, the greedy approach works because choosing the interval with the earliest ending time as soon as possible leaves the most room for the remaining intervals. The locally optimal decision of choosing the interval that ends the earliest results in the globally optimal solution of the maximum number of non-overlapping intervals."
                    },
                    {
                        "username": "loloksEth",
                        "content": "i thinking about sort but constrains bring me down from my way,but why sort work with 10^5"
                    },
                    {
                        "username": "psionl0",
                        "content": "Library sorts run in O(N log N) time."
                    },
                    {
                        "username": "notbutterchick",
                        "content": "typical CSES"
                    }
                ]
            },
            {
                "id": 1976878,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "easy, Academic problem. every institute teach this problem to introduce greedy Algorithm."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Congrats to your Ego :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Two test cases that helped me to figure out the solution:    \n  \n    [[-73,-26],[-65,-11],[-62,-49]]\n    [[1,100],[11,22],[1,11],[2,12]]"
                    },
                    {
                        "username": "srjkmr619",
                        "content": "Why does it shows 58/58 testcases passed but still getting TLE. \\nIf I am getting TLE then how 58/58 passed, it should have been less than the total testcases that should have passed. How can all the test cases pass and still get TLE."
                    },
                    {
                        "username": "sikora92",
                        "content": "It happens when your solution returns correct value, but works too long."
                    },
                    {
                        "username": "santanusen",
                        "content": "Choose the interval that ends first between two overlapping intervals and discard the other."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "This is very similar to July 15 Daily Challenge. Just make a few changes and you are good to continue your Streak!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "It\\'s a relief today"
                    },
                    {
                        "username": "marco_seven",
                        "content": "nice start of the week ,, all the problems from last 3 days ,picked from LeetCode TOP 150 series, I have already done it, and people you try the Leetcode top150 questions"
                    },
                    {
                        "username": "noman598",
                        "content": "greedy - if you get optimal sol then take it & don't worry abt future. eventhough there is more optimal sol.\n\nDP - if you get optimal sol then don't take it. check future optimal sol. Not getting ? backtrack and find other path to get optimal sol. "
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, your description is quite accurate, but it\\'s slightly simplified. \\n\\n1. **Greedy Algorithms:** These algorithms make the locally optimal choice at each step in the hope that these local choices will lead to a global optimum. They do not always produce the absolute best possible solution over all possible solutions for some problems, but they are often efficient and easier to understand and implement. The key aspect here is that once a decision is made, it is not revisited.\\n\\n2. **Dynamic Programming (DP):** DP algorithms solve complex problems by breaking them down into simpler subproblems, solving the subproblems, and using the solutions to build up the solutions to larger problems. The solutions to the subproblems are often stored for future use to avoid redundant calculations (a technique called memoization). The DP approach is typically used when the problem requires making a series of decisions that affect the final solution, and when the problem exhibits \"overlapping subproblems\" and \"optimal substructure\" properties. The decisions made can be revisited and adjusted as more of the problem is explored, hence can find the overall optimal solution. \\n\\nYour point on backtracking is true but more associated with another set of problem-solving strategies where decisions are methodically unmade to explore other potential solutions, usually when the current path being explored is determined to be suboptimal.\\n\\nIn the context of this interval problem, the greedy approach works because choosing the interval with the earliest ending time as soon as possible leaves the most room for the remaining intervals. The locally optimal decision of choosing the interval that ends the earliest results in the globally optimal solution of the maximum number of non-overlapping intervals."
                    },
                    {
                        "username": "loloksEth",
                        "content": "i thinking about sort but constrains bring me down from my way,but why sort work with 10^5"
                    },
                    {
                        "username": "psionl0",
                        "content": "Library sorts run in O(N log N) time."
                    },
                    {
                        "username": "notbutterchick",
                        "content": "typical CSES"
                    }
                ]
            },
            {
                "id": 1976777,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "easy, Academic problem. every institute teach this problem to introduce greedy Algorithm."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Congrats to your Ego :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Two test cases that helped me to figure out the solution:    \n  \n    [[-73,-26],[-65,-11],[-62,-49]]\n    [[1,100],[11,22],[1,11],[2,12]]"
                    },
                    {
                        "username": "srjkmr619",
                        "content": "Why does it shows 58/58 testcases passed but still getting TLE. \\nIf I am getting TLE then how 58/58 passed, it should have been less than the total testcases that should have passed. How can all the test cases pass and still get TLE."
                    },
                    {
                        "username": "sikora92",
                        "content": "It happens when your solution returns correct value, but works too long."
                    },
                    {
                        "username": "santanusen",
                        "content": "Choose the interval that ends first between two overlapping intervals and discard the other."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "This is very similar to July 15 Daily Challenge. Just make a few changes and you are good to continue your Streak!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "It\\'s a relief today"
                    },
                    {
                        "username": "marco_seven",
                        "content": "nice start of the week ,, all the problems from last 3 days ,picked from LeetCode TOP 150 series, I have already done it, and people you try the Leetcode top150 questions"
                    },
                    {
                        "username": "noman598",
                        "content": "greedy - if you get optimal sol then take it & don't worry abt future. eventhough there is more optimal sol.\n\nDP - if you get optimal sol then don't take it. check future optimal sol. Not getting ? backtrack and find other path to get optimal sol. "
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, your description is quite accurate, but it\\'s slightly simplified. \\n\\n1. **Greedy Algorithms:** These algorithms make the locally optimal choice at each step in the hope that these local choices will lead to a global optimum. They do not always produce the absolute best possible solution over all possible solutions for some problems, but they are often efficient and easier to understand and implement. The key aspect here is that once a decision is made, it is not revisited.\\n\\n2. **Dynamic Programming (DP):** DP algorithms solve complex problems by breaking them down into simpler subproblems, solving the subproblems, and using the solutions to build up the solutions to larger problems. The solutions to the subproblems are often stored for future use to avoid redundant calculations (a technique called memoization). The DP approach is typically used when the problem requires making a series of decisions that affect the final solution, and when the problem exhibits \"overlapping subproblems\" and \"optimal substructure\" properties. The decisions made can be revisited and adjusted as more of the problem is explored, hence can find the overall optimal solution. \\n\\nYour point on backtracking is true but more associated with another set of problem-solving strategies where decisions are methodically unmade to explore other potential solutions, usually when the current path being explored is determined to be suboptimal.\\n\\nIn the context of this interval problem, the greedy approach works because choosing the interval with the earliest ending time as soon as possible leaves the most room for the remaining intervals. The locally optimal decision of choosing the interval that ends the earliest results in the globally optimal solution of the maximum number of non-overlapping intervals."
                    },
                    {
                        "username": "loloksEth",
                        "content": "i thinking about sort but constrains bring me down from my way,but why sort work with 10^5"
                    },
                    {
                        "username": "psionl0",
                        "content": "Library sorts run in O(N log N) time."
                    },
                    {
                        "username": "notbutterchick",
                        "content": "typical CSES"
                    }
                ]
            },
            {
                "id": 1976625,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "easy, Academic problem. every institute teach this problem to introduce greedy Algorithm."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Congrats to your Ego :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Two test cases that helped me to figure out the solution:    \n  \n    [[-73,-26],[-65,-11],[-62,-49]]\n    [[1,100],[11,22],[1,11],[2,12]]"
                    },
                    {
                        "username": "srjkmr619",
                        "content": "Why does it shows 58/58 testcases passed but still getting TLE. \\nIf I am getting TLE then how 58/58 passed, it should have been less than the total testcases that should have passed. How can all the test cases pass and still get TLE."
                    },
                    {
                        "username": "sikora92",
                        "content": "It happens when your solution returns correct value, but works too long."
                    },
                    {
                        "username": "santanusen",
                        "content": "Choose the interval that ends first between two overlapping intervals and discard the other."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "This is very similar to July 15 Daily Challenge. Just make a few changes and you are good to continue your Streak!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "It\\'s a relief today"
                    },
                    {
                        "username": "marco_seven",
                        "content": "nice start of the week ,, all the problems from last 3 days ,picked from LeetCode TOP 150 series, I have already done it, and people you try the Leetcode top150 questions"
                    },
                    {
                        "username": "noman598",
                        "content": "greedy - if you get optimal sol then take it & don't worry abt future. eventhough there is more optimal sol.\n\nDP - if you get optimal sol then don't take it. check future optimal sol. Not getting ? backtrack and find other path to get optimal sol. "
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, your description is quite accurate, but it\\'s slightly simplified. \\n\\n1. **Greedy Algorithms:** These algorithms make the locally optimal choice at each step in the hope that these local choices will lead to a global optimum. They do not always produce the absolute best possible solution over all possible solutions for some problems, but they are often efficient and easier to understand and implement. The key aspect here is that once a decision is made, it is not revisited.\\n\\n2. **Dynamic Programming (DP):** DP algorithms solve complex problems by breaking them down into simpler subproblems, solving the subproblems, and using the solutions to build up the solutions to larger problems. The solutions to the subproblems are often stored for future use to avoid redundant calculations (a technique called memoization). The DP approach is typically used when the problem requires making a series of decisions that affect the final solution, and when the problem exhibits \"overlapping subproblems\" and \"optimal substructure\" properties. The decisions made can be revisited and adjusted as more of the problem is explored, hence can find the overall optimal solution. \\n\\nYour point on backtracking is true but more associated with another set of problem-solving strategies where decisions are methodically unmade to explore other potential solutions, usually when the current path being explored is determined to be suboptimal.\\n\\nIn the context of this interval problem, the greedy approach works because choosing the interval with the earliest ending time as soon as possible leaves the most room for the remaining intervals. The locally optimal decision of choosing the interval that ends the earliest results in the globally optimal solution of the maximum number of non-overlapping intervals."
                    },
                    {
                        "username": "loloksEth",
                        "content": "i thinking about sort but constrains bring me down from my way,but why sort work with 10^5"
                    },
                    {
                        "username": "psionl0",
                        "content": "Library sorts run in O(N log N) time."
                    },
                    {
                        "username": "notbutterchick",
                        "content": "typical CSES"
                    }
                ]
            },
            {
                "id": 1976472,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "easy, Academic problem. every institute teach this problem to introduce greedy Algorithm."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Congrats to your Ego :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Two test cases that helped me to figure out the solution:    \n  \n    [[-73,-26],[-65,-11],[-62,-49]]\n    [[1,100],[11,22],[1,11],[2,12]]"
                    },
                    {
                        "username": "srjkmr619",
                        "content": "Why does it shows 58/58 testcases passed but still getting TLE. \\nIf I am getting TLE then how 58/58 passed, it should have been less than the total testcases that should have passed. How can all the test cases pass and still get TLE."
                    },
                    {
                        "username": "sikora92",
                        "content": "It happens when your solution returns correct value, but works too long."
                    },
                    {
                        "username": "santanusen",
                        "content": "Choose the interval that ends first between two overlapping intervals and discard the other."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "This is very similar to July 15 Daily Challenge. Just make a few changes and you are good to continue your Streak!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "It\\'s a relief today"
                    },
                    {
                        "username": "marco_seven",
                        "content": "nice start of the week ,, all the problems from last 3 days ,picked from LeetCode TOP 150 series, I have already done it, and people you try the Leetcode top150 questions"
                    },
                    {
                        "username": "noman598",
                        "content": "greedy - if you get optimal sol then take it & don't worry abt future. eventhough there is more optimal sol.\n\nDP - if you get optimal sol then don't take it. check future optimal sol. Not getting ? backtrack and find other path to get optimal sol. "
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, your description is quite accurate, but it\\'s slightly simplified. \\n\\n1. **Greedy Algorithms:** These algorithms make the locally optimal choice at each step in the hope that these local choices will lead to a global optimum. They do not always produce the absolute best possible solution over all possible solutions for some problems, but they are often efficient and easier to understand and implement. The key aspect here is that once a decision is made, it is not revisited.\\n\\n2. **Dynamic Programming (DP):** DP algorithms solve complex problems by breaking them down into simpler subproblems, solving the subproblems, and using the solutions to build up the solutions to larger problems. The solutions to the subproblems are often stored for future use to avoid redundant calculations (a technique called memoization). The DP approach is typically used when the problem requires making a series of decisions that affect the final solution, and when the problem exhibits \"overlapping subproblems\" and \"optimal substructure\" properties. The decisions made can be revisited and adjusted as more of the problem is explored, hence can find the overall optimal solution. \\n\\nYour point on backtracking is true but more associated with another set of problem-solving strategies where decisions are methodically unmade to explore other potential solutions, usually when the current path being explored is determined to be suboptimal.\\n\\nIn the context of this interval problem, the greedy approach works because choosing the interval with the earliest ending time as soon as possible leaves the most room for the remaining intervals. The locally optimal decision of choosing the interval that ends the earliest results in the globally optimal solution of the maximum number of non-overlapping intervals."
                    },
                    {
                        "username": "loloksEth",
                        "content": "i thinking about sort but constrains bring me down from my way,but why sort work with 10^5"
                    },
                    {
                        "username": "psionl0",
                        "content": "Library sorts run in O(N log N) time."
                    },
                    {
                        "username": "notbutterchick",
                        "content": "typical CSES"
                    }
                ]
            },
            {
                "id": 1976465,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "easy, Academic problem. every institute teach this problem to introduce greedy Algorithm."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Congrats to your Ego :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Two test cases that helped me to figure out the solution:    \n  \n    [[-73,-26],[-65,-11],[-62,-49]]\n    [[1,100],[11,22],[1,11],[2,12]]"
                    },
                    {
                        "username": "srjkmr619",
                        "content": "Why does it shows 58/58 testcases passed but still getting TLE. \\nIf I am getting TLE then how 58/58 passed, it should have been less than the total testcases that should have passed. How can all the test cases pass and still get TLE."
                    },
                    {
                        "username": "sikora92",
                        "content": "It happens when your solution returns correct value, but works too long."
                    },
                    {
                        "username": "santanusen",
                        "content": "Choose the interval that ends first between two overlapping intervals and discard the other."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "This is very similar to July 15 Daily Challenge. Just make a few changes and you are good to continue your Streak!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "It\\'s a relief today"
                    },
                    {
                        "username": "marco_seven",
                        "content": "nice start of the week ,, all the problems from last 3 days ,picked from LeetCode TOP 150 series, I have already done it, and people you try the Leetcode top150 questions"
                    },
                    {
                        "username": "noman598",
                        "content": "greedy - if you get optimal sol then take it & don't worry abt future. eventhough there is more optimal sol.\n\nDP - if you get optimal sol then don't take it. check future optimal sol. Not getting ? backtrack and find other path to get optimal sol. "
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, your description is quite accurate, but it\\'s slightly simplified. \\n\\n1. **Greedy Algorithms:** These algorithms make the locally optimal choice at each step in the hope that these local choices will lead to a global optimum. They do not always produce the absolute best possible solution over all possible solutions for some problems, but they are often efficient and easier to understand and implement. The key aspect here is that once a decision is made, it is not revisited.\\n\\n2. **Dynamic Programming (DP):** DP algorithms solve complex problems by breaking them down into simpler subproblems, solving the subproblems, and using the solutions to build up the solutions to larger problems. The solutions to the subproblems are often stored for future use to avoid redundant calculations (a technique called memoization). The DP approach is typically used when the problem requires making a series of decisions that affect the final solution, and when the problem exhibits \"overlapping subproblems\" and \"optimal substructure\" properties. The decisions made can be revisited and adjusted as more of the problem is explored, hence can find the overall optimal solution. \\n\\nYour point on backtracking is true but more associated with another set of problem-solving strategies where decisions are methodically unmade to explore other potential solutions, usually when the current path being explored is determined to be suboptimal.\\n\\nIn the context of this interval problem, the greedy approach works because choosing the interval with the earliest ending time as soon as possible leaves the most room for the remaining intervals. The locally optimal decision of choosing the interval that ends the earliest results in the globally optimal solution of the maximum number of non-overlapping intervals."
                    },
                    {
                        "username": "loloksEth",
                        "content": "i thinking about sort but constrains bring me down from my way,but why sort work with 10^5"
                    },
                    {
                        "username": "psionl0",
                        "content": "Library sorts run in O(N log N) time."
                    },
                    {
                        "username": "notbutterchick",
                        "content": "typical CSES"
                    }
                ]
            },
            {
                "id": 1976429,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "easy, Academic problem. every institute teach this problem to introduce greedy Algorithm."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Congrats to your Ego :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Two test cases that helped me to figure out the solution:    \n  \n    [[-73,-26],[-65,-11],[-62,-49]]\n    [[1,100],[11,22],[1,11],[2,12]]"
                    },
                    {
                        "username": "srjkmr619",
                        "content": "Why does it shows 58/58 testcases passed but still getting TLE. \\nIf I am getting TLE then how 58/58 passed, it should have been less than the total testcases that should have passed. How can all the test cases pass and still get TLE."
                    },
                    {
                        "username": "sikora92",
                        "content": "It happens when your solution returns correct value, but works too long."
                    },
                    {
                        "username": "santanusen",
                        "content": "Choose the interval that ends first between two overlapping intervals and discard the other."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "This is very similar to July 15 Daily Challenge. Just make a few changes and you are good to continue your Streak!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "It\\'s a relief today"
                    },
                    {
                        "username": "marco_seven",
                        "content": "nice start of the week ,, all the problems from last 3 days ,picked from LeetCode TOP 150 series, I have already done it, and people you try the Leetcode top150 questions"
                    },
                    {
                        "username": "noman598",
                        "content": "greedy - if you get optimal sol then take it & don't worry abt future. eventhough there is more optimal sol.\n\nDP - if you get optimal sol then don't take it. check future optimal sol. Not getting ? backtrack and find other path to get optimal sol. "
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, your description is quite accurate, but it\\'s slightly simplified. \\n\\n1. **Greedy Algorithms:** These algorithms make the locally optimal choice at each step in the hope that these local choices will lead to a global optimum. They do not always produce the absolute best possible solution over all possible solutions for some problems, but they are often efficient and easier to understand and implement. The key aspect here is that once a decision is made, it is not revisited.\\n\\n2. **Dynamic Programming (DP):** DP algorithms solve complex problems by breaking them down into simpler subproblems, solving the subproblems, and using the solutions to build up the solutions to larger problems. The solutions to the subproblems are often stored for future use to avoid redundant calculations (a technique called memoization). The DP approach is typically used when the problem requires making a series of decisions that affect the final solution, and when the problem exhibits \"overlapping subproblems\" and \"optimal substructure\" properties. The decisions made can be revisited and adjusted as more of the problem is explored, hence can find the overall optimal solution. \\n\\nYour point on backtracking is true but more associated with another set of problem-solving strategies where decisions are methodically unmade to explore other potential solutions, usually when the current path being explored is determined to be suboptimal.\\n\\nIn the context of this interval problem, the greedy approach works because choosing the interval with the earliest ending time as soon as possible leaves the most room for the remaining intervals. The locally optimal decision of choosing the interval that ends the earliest results in the globally optimal solution of the maximum number of non-overlapping intervals."
                    },
                    {
                        "username": "loloksEth",
                        "content": "i thinking about sort but constrains bring me down from my way,but why sort work with 10^5"
                    },
                    {
                        "username": "psionl0",
                        "content": "Library sorts run in O(N log N) time."
                    },
                    {
                        "username": "notbutterchick",
                        "content": "typical CSES"
                    }
                ]
            },
            {
                "id": 1976411,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "easy, Academic problem. every institute teach this problem to introduce greedy Algorithm."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Congrats to your Ego :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Two test cases that helped me to figure out the solution:    \n  \n    [[-73,-26],[-65,-11],[-62,-49]]\n    [[1,100],[11,22],[1,11],[2,12]]"
                    },
                    {
                        "username": "srjkmr619",
                        "content": "Why does it shows 58/58 testcases passed but still getting TLE. \\nIf I am getting TLE then how 58/58 passed, it should have been less than the total testcases that should have passed. How can all the test cases pass and still get TLE."
                    },
                    {
                        "username": "sikora92",
                        "content": "It happens when your solution returns correct value, but works too long."
                    },
                    {
                        "username": "santanusen",
                        "content": "Choose the interval that ends first between two overlapping intervals and discard the other."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "This is very similar to July 15 Daily Challenge. Just make a few changes and you are good to continue your Streak!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "It\\'s a relief today"
                    },
                    {
                        "username": "marco_seven",
                        "content": "nice start of the week ,, all the problems from last 3 days ,picked from LeetCode TOP 150 series, I have already done it, and people you try the Leetcode top150 questions"
                    },
                    {
                        "username": "noman598",
                        "content": "greedy - if you get optimal sol then take it & don't worry abt future. eventhough there is more optimal sol.\n\nDP - if you get optimal sol then don't take it. check future optimal sol. Not getting ? backtrack and find other path to get optimal sol. "
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, your description is quite accurate, but it\\'s slightly simplified. \\n\\n1. **Greedy Algorithms:** These algorithms make the locally optimal choice at each step in the hope that these local choices will lead to a global optimum. They do not always produce the absolute best possible solution over all possible solutions for some problems, but they are often efficient and easier to understand and implement. The key aspect here is that once a decision is made, it is not revisited.\\n\\n2. **Dynamic Programming (DP):** DP algorithms solve complex problems by breaking them down into simpler subproblems, solving the subproblems, and using the solutions to build up the solutions to larger problems. The solutions to the subproblems are often stored for future use to avoid redundant calculations (a technique called memoization). The DP approach is typically used when the problem requires making a series of decisions that affect the final solution, and when the problem exhibits \"overlapping subproblems\" and \"optimal substructure\" properties. The decisions made can be revisited and adjusted as more of the problem is explored, hence can find the overall optimal solution. \\n\\nYour point on backtracking is true but more associated with another set of problem-solving strategies where decisions are methodically unmade to explore other potential solutions, usually when the current path being explored is determined to be suboptimal.\\n\\nIn the context of this interval problem, the greedy approach works because choosing the interval with the earliest ending time as soon as possible leaves the most room for the remaining intervals. The locally optimal decision of choosing the interval that ends the earliest results in the globally optimal solution of the maximum number of non-overlapping intervals."
                    },
                    {
                        "username": "loloksEth",
                        "content": "i thinking about sort but constrains bring me down from my way,but why sort work with 10^5"
                    },
                    {
                        "username": "psionl0",
                        "content": "Library sorts run in O(N log N) time."
                    },
                    {
                        "username": "notbutterchick",
                        "content": "typical CSES"
                    }
                ]
            },
            {
                "id": 1971682,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "easy, Academic problem. every institute teach this problem to introduce greedy Algorithm."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Congrats to your Ego :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Two test cases that helped me to figure out the solution:    \n  \n    [[-73,-26],[-65,-11],[-62,-49]]\n    [[1,100],[11,22],[1,11],[2,12]]"
                    },
                    {
                        "username": "srjkmr619",
                        "content": "Why does it shows 58/58 testcases passed but still getting TLE. \\nIf I am getting TLE then how 58/58 passed, it should have been less than the total testcases that should have passed. How can all the test cases pass and still get TLE."
                    },
                    {
                        "username": "sikora92",
                        "content": "It happens when your solution returns correct value, but works too long."
                    },
                    {
                        "username": "santanusen",
                        "content": "Choose the interval that ends first between two overlapping intervals and discard the other."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "This is very similar to July 15 Daily Challenge. Just make a few changes and you are good to continue your Streak!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "It\\'s a relief today"
                    },
                    {
                        "username": "marco_seven",
                        "content": "nice start of the week ,, all the problems from last 3 days ,picked from LeetCode TOP 150 series, I have already done it, and people you try the Leetcode top150 questions"
                    },
                    {
                        "username": "noman598",
                        "content": "greedy - if you get optimal sol then take it & don't worry abt future. eventhough there is more optimal sol.\n\nDP - if you get optimal sol then don't take it. check future optimal sol. Not getting ? backtrack and find other path to get optimal sol. "
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, your description is quite accurate, but it\\'s slightly simplified. \\n\\n1. **Greedy Algorithms:** These algorithms make the locally optimal choice at each step in the hope that these local choices will lead to a global optimum. They do not always produce the absolute best possible solution over all possible solutions for some problems, but they are often efficient and easier to understand and implement. The key aspect here is that once a decision is made, it is not revisited.\\n\\n2. **Dynamic Programming (DP):** DP algorithms solve complex problems by breaking them down into simpler subproblems, solving the subproblems, and using the solutions to build up the solutions to larger problems. The solutions to the subproblems are often stored for future use to avoid redundant calculations (a technique called memoization). The DP approach is typically used when the problem requires making a series of decisions that affect the final solution, and when the problem exhibits \"overlapping subproblems\" and \"optimal substructure\" properties. The decisions made can be revisited and adjusted as more of the problem is explored, hence can find the overall optimal solution. \\n\\nYour point on backtracking is true but more associated with another set of problem-solving strategies where decisions are methodically unmade to explore other potential solutions, usually when the current path being explored is determined to be suboptimal.\\n\\nIn the context of this interval problem, the greedy approach works because choosing the interval with the earliest ending time as soon as possible leaves the most room for the remaining intervals. The locally optimal decision of choosing the interval that ends the earliest results in the globally optimal solution of the maximum number of non-overlapping intervals."
                    },
                    {
                        "username": "loloksEth",
                        "content": "i thinking about sort but constrains bring me down from my way,but why sort work with 10^5"
                    },
                    {
                        "username": "psionl0",
                        "content": "Library sorts run in O(N log N) time."
                    },
                    {
                        "username": "notbutterchick",
                        "content": "typical CSES"
                    }
                ]
            },
            {
                "id": 1949688,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "easy, Academic problem. every institute teach this problem to introduce greedy Algorithm."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Congrats to your Ego :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Two test cases that helped me to figure out the solution:    \n  \n    [[-73,-26],[-65,-11],[-62,-49]]\n    [[1,100],[11,22],[1,11],[2,12]]"
                    },
                    {
                        "username": "srjkmr619",
                        "content": "Why does it shows 58/58 testcases passed but still getting TLE. \\nIf I am getting TLE then how 58/58 passed, it should have been less than the total testcases that should have passed. How can all the test cases pass and still get TLE."
                    },
                    {
                        "username": "sikora92",
                        "content": "It happens when your solution returns correct value, but works too long."
                    },
                    {
                        "username": "santanusen",
                        "content": "Choose the interval that ends first between two overlapping intervals and discard the other."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "This is very similar to July 15 Daily Challenge. Just make a few changes and you are good to continue your Streak!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "It\\'s a relief today"
                    },
                    {
                        "username": "marco_seven",
                        "content": "nice start of the week ,, all the problems from last 3 days ,picked from LeetCode TOP 150 series, I have already done it, and people you try the Leetcode top150 questions"
                    },
                    {
                        "username": "noman598",
                        "content": "greedy - if you get optimal sol then take it & don't worry abt future. eventhough there is more optimal sol.\n\nDP - if you get optimal sol then don't take it. check future optimal sol. Not getting ? backtrack and find other path to get optimal sol. "
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, your description is quite accurate, but it\\'s slightly simplified. \\n\\n1. **Greedy Algorithms:** These algorithms make the locally optimal choice at each step in the hope that these local choices will lead to a global optimum. They do not always produce the absolute best possible solution over all possible solutions for some problems, but they are often efficient and easier to understand and implement. The key aspect here is that once a decision is made, it is not revisited.\\n\\n2. **Dynamic Programming (DP):** DP algorithms solve complex problems by breaking them down into simpler subproblems, solving the subproblems, and using the solutions to build up the solutions to larger problems. The solutions to the subproblems are often stored for future use to avoid redundant calculations (a technique called memoization). The DP approach is typically used when the problem requires making a series of decisions that affect the final solution, and when the problem exhibits \"overlapping subproblems\" and \"optimal substructure\" properties. The decisions made can be revisited and adjusted as more of the problem is explored, hence can find the overall optimal solution. \\n\\nYour point on backtracking is true but more associated with another set of problem-solving strategies where decisions are methodically unmade to explore other potential solutions, usually when the current path being explored is determined to be suboptimal.\\n\\nIn the context of this interval problem, the greedy approach works because choosing the interval with the earliest ending time as soon as possible leaves the most room for the remaining intervals. The locally optimal decision of choosing the interval that ends the earliest results in the globally optimal solution of the maximum number of non-overlapping intervals."
                    },
                    {
                        "username": "loloksEth",
                        "content": "i thinking about sort but constrains bring me down from my way,but why sort work with 10^5"
                    },
                    {
                        "username": "psionl0",
                        "content": "Library sorts run in O(N log N) time."
                    },
                    {
                        "username": "notbutterchick",
                        "content": "typical CSES"
                    }
                ]
            }
        ]
    }
]