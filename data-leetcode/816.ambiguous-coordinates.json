[
    {
        "title": "Ambiguous Coordinates",
        "question_content": "We had some 2-dimensional coordinates, like \"(1, 3)\" or \"(2, 0.5)\". Then, we removed all commas, decimal points, and spaces and ended up with the string s.\n\n\tFor example, \"(1, 3)\" becomes s = \"(13)\" and \"(2, 0.5)\" becomes s = \"(205)\".\n\nReturn a list of strings representing all possibilities for what our original coordinates could have been.\nOur original representation never had extraneous zeroes, so we never started with numbers like \"00\", \"0.0\", \"0.00\", \"1.0\", \"001\", \"00.01\", or any other number that can be represented with fewer digits. Also, a decimal point within a number never occurs without at least one digit occurring before it, so we never started with numbers like \".1\".\nThe final answer list can be returned in any order. All coordinates in the final answer have exactly one space between them (occurring after the comma.)\n&nbsp;\nExample 1:\n\nInput: s = \"(123)\"\nOutput: [\"(1, 2.3)\",\"(1, 23)\",\"(1.2, 3)\",\"(12, 3)\"]\n\nExample 2:\n\nInput: s = \"(0123)\"\nOutput: [\"(0, 1.23)\",\"(0, 12.3)\",\"(0, 123)\",\"(0.1, 2.3)\",\"(0.1, 23)\",\"(0.12, 3)\"]\nExplanation: 0.0, 00, 0001 or 00.01 are not allowed.\n\nExample 3:\n\nInput: s = \"(00011)\"\nOutput: [\"(0, 0.011)\",\"(0.001, 1)\"]\n\n&nbsp;\nConstraints:\n\n\t4 <= s.length <= 12\n\ts[0] == '(' and s[s.length - 1] == ')'.\n\tThe rest of s are digits.",
        "solutions": [
            {
                "id": 123851,
                "title": "c-java-python-solution-with-explanation",
                "content": "We can split S to two parts for two coordinates.\\nThen we use sub function ```f``` to find all possible strings for each coordinate.\\n\\n**In sub functon f(S)**\\nif S == \"\": return []\\nif S == \"0\": return [S]\\nif S == \"0XXX0\": return []\\nif S == \"0XXX\": return [\"0.XXX\"]\\nif S == \"XXX0\": return [S]\\nreturn [S, \"X.XXX\", \"XX.XX\", \"XXX.X\"...]\\n\\nThen we add the product of two lists to result.\\n\\n**Time complexity**\\nO(N^3) with N <= 10\\n\\nProvement:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/lee215/image_1523920967.png)\\n\\n\\nC++:\\n```\\n    vector<string> ambiguousCoordinates(string S) {\\n        int n = S.size();\\n        vector<string> res;\\n        for (int i = 1; i < n - 2; ++i) {\\n            vector<string> A = f(S.substr(1, i)), B = f(S.substr(i + 1, n - 2 - i));\\n            for (auto & a : A) for (auto & b : B) res.push_back(\"(\" + a + \", \" + b + \")\");\\n        }\\n        return res;\\n    }\\n    vector<string> f(string S) {\\n        int n = S.size();\\n        if (n == 0 || (n > 1 && S[0] == \\'0\\' && S[n - 1] == \\'0\\')) return {};\\n        if (n > 1 && S[0] == \\'0\\') return {\"0.\" + S.substr(1)};\\n        if (n == 1 || S[n - 1] == \\'0\\') return {S};\\n        vector<string> res = {S};\\n        for (int i = 1; i < n; ++i) res.push_back(S.substr(0, i) + \\'.\\' + S.substr(i));\\n        return res;\\n    }\\n```\\n**Java:**\\n```\\n    public List<String> ambiguousCoordinates(String S) {\\n        int n = S.length();\\n        List<String> res = new ArrayList();\\n        for (int i = 1; i < n - 2; ++i) {\\n            List<String> A = f(S.substring(1, i + 1)), B = f(S.substring(i + 1, n - 1));\\n            for (String a : A) for (String b : B) res.add(\"(\" + a + \", \" + b + \")\");\\n        }\\n        return res;\\n    }\\n    public List<String> f(String S) {\\n        int n = S.length();\\n        List<String> res = new ArrayList();\\n        if (n == 0 || (n > 1 && S.charAt(0) == \\'0\\' && S.charAt(n - 1) == \\'0\\')) return res;\\n        if (n > 1 && S.charAt(0) == \\'0\\') {\\n            res.add(\"0.\" + S.substring(1));\\n            return res;\\n        }\\n        res.add(S);\\n        if (n == 1 || S.charAt(n - 1) == \\'0\\') return res;\\n        for (int i = 1; i < n; ++i) res.add(S.substring(0, i) + \\'.\\' + S.substring(i));\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def ambiguousCoordinates(self, S):\\n        S = S[1:-1]\\n        def f(S):\\n            if not S or len(S) > 1 and S[0] == S[-1] == \\'0\\': return []\\n            if S[-1] == \\'0\\': return [S]\\n            if S[0] == \\'0\\': return [S[0] + \\'.\\' + S[1:]]\\n            return [S] + [S[:i] + \\'.\\' + S[i:] for i in range(1, len(S))]\\n        return [\\'(%s, %s)\\' % (a, b) for i in range(len(S)) for a, b in itertools.product(f(S[:i]), f(S[i:]))]\\n```",
                "solutionTags": [],
                "code": "```f```\n```\\n    vector<string> ambiguousCoordinates(string S) {\\n        int n = S.size();\\n        vector<string> res;\\n        for (int i = 1; i < n - 2; ++i) {\\n            vector<string> A = f(S.substr(1, i)), B = f(S.substr(i + 1, n - 2 - i));\\n            for (auto & a : A) for (auto & b : B) res.push_back(\"(\" + a + \", \" + b + \")\");\\n        }\\n        return res;\\n    }\\n    vector<string> f(string S) {\\n        int n = S.size();\\n        if (n == 0 || (n > 1 && S[0] == \\'0\\' && S[n - 1] == \\'0\\')) return {};\\n        if (n > 1 && S[0] == \\'0\\') return {\"0.\" + S.substr(1)};\\n        if (n == 1 || S[n - 1] == \\'0\\') return {S};\\n        vector<string> res = {S};\\n        for (int i = 1; i < n; ++i) res.push_back(S.substr(0, i) + \\'.\\' + S.substr(i));\\n        return res;\\n    }\\n```\n```\\n    public List<String> ambiguousCoordinates(String S) {\\n        int n = S.length();\\n        List<String> res = new ArrayList();\\n        for (int i = 1; i < n - 2; ++i) {\\n            List<String> A = f(S.substring(1, i + 1)), B = f(S.substring(i + 1, n - 1));\\n            for (String a : A) for (String b : B) res.add(\"(\" + a + \", \" + b + \")\");\\n        }\\n        return res;\\n    }\\n    public List<String> f(String S) {\\n        int n = S.length();\\n        List<String> res = new ArrayList();\\n        if (n == 0 || (n > 1 && S.charAt(0) == \\'0\\' && S.charAt(n - 1) == \\'0\\')) return res;\\n        if (n > 1 && S.charAt(0) == \\'0\\') {\\n            res.add(\"0.\" + S.substring(1));\\n            return res;\\n        }\\n        res.add(S);\\n        if (n == 1 || S.charAt(n - 1) == \\'0\\') return res;\\n        for (int i = 1; i < n; ++i) res.add(S.substring(0, i) + \\'.\\' + S.substring(i));\\n        return res;\\n    }\\n```\n```\\n    def ambiguousCoordinates(self, S):\\n        S = S[1:-1]\\n        def f(S):\\n            if not S or len(S) > 1 and S[0] == S[-1] == \\'0\\': return []\\n            if S[-1] == \\'0\\': return [S]\\n            if S[0] == \\'0\\': return [S[0] + \\'.\\' + S[1:]]\\n            return [S] + [S[:i] + \\'.\\' + S[i:] for i in range(1, len(S))]\\n        return [\\'(%s, %s)\\' % (a, b) for i in range(len(S)) for a, b in itertools.product(f(S[:i]), f(S[i:]))]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 123875,
                "title": "really-clear-java-code",
                "content": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String S) {\\n        S = S.substring(1, S.length() - 1);\\n        List<String> result = new LinkedList<>();\\n        for (int i = 1; i < S.length(); i++) {\\n            List<String> left = allowed(S.substring(0, i));\\n            List<String> right = allowed(S.substring(i));\\n            for (String ls : left) {\\n                for (String rs : right) {\\n                    result.add(\"(\" + ls + \", \" + rs + \")\");\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    private List<String> allowed(String s) {\\n        int l = s.length();\\n        char[] cs = s.toCharArray();\\n        List<String> result = new LinkedList<>();\\n        if (cs[0] == \\'0\\' && cs[l - 1] == \\'0\\') { // \"0xxxx0\" Invalid unless a single \"0\"\\n            if (l == 1) {\\n                result.add(\"0\");\\n            }\\n            return result;\\n        }\\n        if (cs[0] == \\'0\\') { // \"0xxxxx\" The only valid result is \"0.xxxxx\"\\n            result.add(\"0.\" + s.substring(1));\\n            return result;\\n        }\\n        if (cs[l - 1] == \\'0\\') { // \"xxxxx0\" The only valid result is itself\\n            result.add(s);\\n            return result;\\n        }\\n        result.add(s); // Add itself\\n        for (int i = 1; i < l; i++) { // \"xxxx\" -> \"x.xxx\", \"xx.xx\", \"xxx.x\"\\n            result.add(s.substring(0, i) + \\'.\\' + s.substring(i));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String S) {\\n        S = S.substring(1, S.length() - 1);\\n        List<String> result = new LinkedList<>();\\n        for (int i = 1; i < S.length(); i++) {\\n            List<String> left = allowed(S.substring(0, i));\\n            List<String> right = allowed(S.substring(i));\\n            for (String ls : left) {\\n                for (String rs : right) {\\n                    result.add(\"(\" + ls + \", \" + rs + \")\");\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    private List<String> allowed(String s) {\\n        int l = s.length();\\n        char[] cs = s.toCharArray();\\n        List<String> result = new LinkedList<>();\\n        if (cs[0] == \\'0\\' && cs[l - 1] == \\'0\\') { // \"0xxxx0\" Invalid unless a single \"0\"\\n            if (l == 1) {\\n                result.add(\"0\");\\n            }\\n            return result;\\n        }\\n        if (cs[0] == \\'0\\') { // \"0xxxxx\" The only valid result is \"0.xxxxx\"\\n            result.add(\"0.\" + s.substring(1));\\n            return result;\\n        }\\n        if (cs[l - 1] == \\'0\\') { // \"xxxxx0\" The only valid result is itself\\n            result.add(s);\\n            return result;\\n        }\\n        result.add(s); // Add itself\\n        for (int i = 1; i < l; i++) { // \"xxxx\" -> \"x.xxx\", \"xx.xx\", \"xxx.x\"\\n            result.add(s.substring(0, i) + \\'.\\' + s.substring(i));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205855,
                "title": "c-clean-and-simple-solution-faster-than-96",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> res;\\n        string s2 = s.substr(1, s.size()-2);\\n        int n = s2.size();\\n        \\n        for (int i = 1; i < n; i++) {\\n            vector<string> first = getNumbers(s2.substr(0, i));\\n            vector<string> second = getNumbers(s2.substr(i));\\n            \\n            for (int j = 0; j < first.size(); j++) {\\n                for (int k = 0; k < second.size(); k++) {\\n                    res.push_back(\"(\" + first[j] + \", \" + second[k] + \")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<string> getNumbers(string num) {\\n        vector<string> res;\\n        int n = num.size();\\n        \\n        if (n == 1) \\n            return {num};\\n        \\n        if (num[0] != \\'0\\') \\n            res.push_back(num);\\n        \\n        if (num[0] == \\'0\\') {\\n            if (num.back() == \\'0\\') return {};\\n            return {\"0.\" + num.substr(1)};\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (num.substr(i).back() == \\'0\\') continue;\\n            res.push_back(num.substr(0, i) + \".\" + num.substr(i));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> res;\\n        string s2 = s.substr(1, s.size()-2);\\n        int n = s2.size();\\n        \\n        for (int i = 1; i < n; i++) {\\n            vector<string> first = getNumbers(s2.substr(0, i));\\n            vector<string> second = getNumbers(s2.substr(i));\\n            \\n            for (int j = 0; j < first.size(); j++) {\\n                for (int k = 0; k < second.size(); k++) {\\n                    res.push_back(\"(\" + first[j] + \", \" + second[k] + \")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<string> getNumbers(string num) {\\n        vector<string> res;\\n        int n = num.size();\\n        \\n        if (n == 1) \\n            return {num};\\n        \\n        if (num[0] != \\'0\\') \\n            res.push_back(num);\\n        \\n        if (num[0] == \\'0\\') {\\n            if (num.back() == \\'0\\') return {};\\n            return {\"0.\" + num.substr(1)};\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (num.substr(i).back() == \\'0\\') continue;\\n            res.push_back(num.substr(0, i) + \".\" + num.substr(i));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123881,
                "title": "concise-c-solution-with-comments",
                "content": "```\\nvector<string> cases(string &&s) {\\n    if (s.size() == 1) // single digit\\n        return {s};\\n    if (s.front() == \\'0\\') { // 0xxx\\n        if (s.back() == \\'0\\') // 0xxx0\\n            return {};\\n        return {\"0.\" + s.substr(1)}; // 0xxx9\\n    }\\n    if (s.back() == \\'0\\') // 9xxx0\\n        return {s};\\n    vector<string> res{s}; // 9xxx9\\n    for (int i = 1; i < s.size(); i++)\\n        res.emplace_back(s.substr(0, i) + \".\" + s.substr(i));\\n    return res;\\n}\\n\\nvector<string> ambiguousCoordinates(string S) {\\n    vector<string> res;\\n    for (int i = 2; i < S.size() - 1; i++) // position of comma\\n    for (auto &x : cases(S.substr(1, i - 1)))\\n    for (auto &y : cases(S.substr(i, S.size() - i - 1)))\\n        res.emplace_back(\"(\" + x + \", \" + y + \")\");\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> cases(string &&s) {\\n    if (s.size() == 1) // single digit\\n        return {s};\\n    if (s.front() == \\'0\\') { // 0xxx\\n        if (s.back() == \\'0\\') // 0xxx0\\n            return {};\\n        return {\"0.\" + s.substr(1)}; // 0xxx9\\n    }\\n    if (s.back() == \\'0\\') // 9xxx0\\n        return {s};\\n    vector<string> res{s}; // 9xxx9\\n    for (int i = 1; i < s.size(); i++)\\n        res.emplace_back(s.substr(0, i) + \".\" + s.substr(i));\\n    return res;\\n}\\n\\nvector<string> ambiguousCoordinates(string S) {\\n    vector<string> res;\\n    for (int i = 2; i < S.size() - 1; i++) // position of comma\\n    for (auto &x : cases(S.substr(1, i - 1)))\\n    for (auto &y : cases(S.substr(i, S.size() - i - 1)))\\n        res.emplace_back(\"(\" + x + \", \" + y + \")\");\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1205982,
                "title": "python-product-solution-with-correct-complexity-explained",
                "content": "Let us create function `generate(s)`, which generate all possible candidates for string `s`: we need to check number without dot and also all possible ways to put dot inside. We need to check the condition `our original representation never had extraneous zeroes`, so we check that if some number starts with `0`, it should be equal to `0`.\\n\\nThen we split `S` into all possible  ways, for each part generate all numbers and then choose all pairs of numbers. \\n\\n#### Complexity\\nThere is `O(n)` ways to split string `S` into two parts. Overall time and space complexity will be `O(n^4)`, for example for string `\"(\" + \"1\"*n + \")\"`, number of ways will be approximately `n^3/6`, each of them have length `O(n)`.\\n\\n```python\\nclass Solution:\\n    def ambiguousCoordinates(self, S):\\n        def generate(s):\\n            ans = []\\n            if s == \"0\" or s[0] != \"0\": ans.append(s)\\n            for i in range(1, len(s)):\\n                if (s[:i] == \"0\" or s[0] != \"0\") and s[-1] != \"0\":\\n                    ans.append(s[:i] + \".\" + s[i:])\\n            return ans\\n        \\n        n, ans = len(S), []\\n        for i in range(2, n-1):\\n            cand_l, cand_r = generate(S[1:i]), generate(S[i:-1])     \\n            for l, r in product(cand_l, cand_r):\\n                ans.append(\"(\" + l + \", \" + r + \")\")\\n                \\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def ambiguousCoordinates(self, S):\\n        def generate(s):\\n            ans = []\\n            if s == \"0\" or s[0] != \"0\": ans.append(s)\\n            for i in range(1, len(s)):\\n                if (s[:i] == \"0\" or s[0] != \"0\") and s[-1] != \"0\":\\n                    ans.append(s[:i] + \".\" + s[i:])\\n            return ans\\n        \\n        n, ans = len(S), []\\n        for i in range(2, n-1):\\n            cand_l, cand_r = generate(S[1:i]), generate(S[i:-1])     \\n            for l, r in product(cand_l, cand_r):\\n                ans.append(\"(\" + l + \", \" + r + \")\")\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206218,
                "title": "js-python-java-c-easy-iterative-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nFor this problem, we have two basic challenges. The first challenge is preventing invalid coordinates. For that, we can define a helper function (**parse**) which will take a string (**str**) and only pass on valid options for another helper (**process**) to handle.\\n\\nWe can break down the options into three categories:\\n - _No decimal_: Any option except one with more than **1** digit and a leading **\"0\"**.\\n - _Decimal after first digit_: Any option with more than **1** digit and no trailing **\"0\"**.\\n - _Decimals throughout_: Any option that doesn\\'t start and end with a **\"0\"**\\n\\nAfter defining our first helper function, the next thing we should do is iterate through possible comma locations in our input string (**S**) and separate the coordinate pair strings (**xStr, yStr**).\\n\\nThen we\\'ll run into the second challenge, which is to avoid repeating the same processing. If we were to employ a simple nested loop or recursive function to solve this problem, it would end up redoing the same processes many times, since both coordinates can have a decimal.\\n\\nWhat we actually want is the product of two loops. The basic solution would be to create two arrays and iterate through their combinations, but there\\'s really no need to actually build the second array, since we can just as easily process the combinations while we iterate through the second coordinate naturally.\\n\\nSo we should first build and validate all decimal options for the **xStr** of a given comma position and store the valid possibilities in an array (**xPoss**). Once this is complete we should find each valid decimal option for **yStr**, combine it with each value in **xPoss**, and add the results to our answer array (**ans**) before moving onto the next comma position.\\n\\nTo aid in this, we can define **process**, which will either store the valid decimal options from **xStr** into **xPoss** or combine valid decimal options from **yStr** with the contents of **xPoss** and store the results in **ans**, depending on which coordinate string we\\'re currently on (**xy**).\\n\\nOnce we finish iterating through all comma positions, we can **return ans**.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **76ms / 42.3MB** (beats 100% / 100%).\\n```javascript\\nvar ambiguousCoordinates = function(S) {\\n    let ans = [], xPoss\\n    const process = (str, xy) => {\\n        if (xy)\\n            for (let x of xPoss)\\n                ans.push(`(${x}, ${str})`)\\n        else xPoss.push(str)\\n    }\\n    const parse = (str, xy) => {\\n        if (str.length === 1 || str[0] !== \"0\")\\n            process(str, xy)\\n        if (str.length > 1 && str[str.length-1] !== \"0\")\\n            process(str.slice(0,1) + \".\" + str.slice(1), xy)\\n        if (str.length > 2 && str[0] !== \"0\" && str[str.length-1] !== \"0\")\\n            for (let i = 2; i < str.length; i++)\\n                process(str.slice(0,i) + \".\" + str.slice(i), xy)\\n    }\\n    for (let i = 2; i < S.length - 1; i++) {\\n        let strs = [S.slice(1,i), S.slice(i, S.length - 1)]\\n        xPoss = []\\n        for (let j = 0; j < 2; j++)\\n            if (xPoss.length || !j) parse(strs[j], j)\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **32ms / 14.1MB** (beats 99% / 92%).\\n```python\\nclass Solution:\\n    def ambiguousCoordinates(self, S: str) -> List[str]:\\n        ans, xPoss = [], []\\n        def process(st: str, xy: int):\\n            if xy:\\n                for x in xPoss:\\n                    ans.append(\"(\" + x + \", \" + st + \")\")\\n            else: xPoss.append(st)\\n        def parse(st: str, xy: int):\\n            if len(st) == 1 or st[0] != \"0\":\\n                process(st, xy)\\n            if len(st) > 1 and st[-1] != \"0\":\\n                process(st[:1] + \".\" + st[1:], xy)\\n            if len(st) > 2 and st[0] != \"0\" and st[-1] != \"0\":\\n                for i in range(2, len(st)):\\n                    process(st[:i] + \".\" + st[i:], xy)  \\n        for i in range(2, len(S)-1):\\n            strs, xPoss = [S[1:i], S[i:-1]], []\\n            for j in range(2):\\n                if xPoss or not j: parse(strs[j], j)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **7ms / 39.5MB** (beats 100% / 91%).\\n```java\\nclass Solution {\\n    private List<String> xPoss, ans;\\n    public List<String> ambiguousCoordinates(String S) {\\n        ans = new ArrayList<>();\\n        for (int i = 2; i < S.length() - 1; i++) {\\n            String[] strs = {S.substring(1,i), S.substring(i, S.length() - 1)};\\n            xPoss = new ArrayList<>();\\n            for (int j = 0; j < 2; j++)\\n                if (xPoss.size() > 0 || j == 0) parse(strs[j], j);\\n        }\\n        return ans;\\n    }\\n    private void parse(String str, int xy) {\\n        if (str.length() == 1 || str.charAt(0) != \\'0\\')\\n            process(str, xy);\\n        if (str.length() > 1 && str.charAt(str.length()-1) != \\'0\\')\\n            process(str.substring(0,1) + \".\" + str.substring(1), xy);\\n        if (str.length() > 2 && str.charAt(0) != \\'0\\' && str.charAt(str.length()-1) != \\'0\\')\\n            for (int i = 2; i < str.length(); i++)\\n                process(str.substring(0,i) + \".\" + str.substring(i), xy);\\n    }\\n    private void process(String str, int xy) {\\n        if (xy > 0)\\n            for (String x : xPoss)\\n                ans.add(\"(\" + x + \", \" + str + \")\");\\n        else xPoss.add(str);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 9.1MB** (beats 100% / 95%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string S) {\\n        for (int i = 2; i < S.size() - 1; i++) {\\n            string strs[2] = {S.substr(1,i-1), S.substr(i,S.size()-i-1)};\\n            xPoss.clear();\\n            for (int j = 0; j < 2; j++)\\n                if (xPoss.size() || !j) parse(strs[j], j);\\n        }\\n        return ans;\\n    }\\nprivate:\\n    vector<string> ans, xPoss;\\n    void parse(string str, int xy) {\\n        if (str.size() == 1 || str.front() != \\'0\\')\\n            process(str, xy);\\n        if (str.size() > 1 && str.back() != \\'0\\')\\n            process(str.substr(0,1) + \".\" + str.substr(1), xy);\\n        if (str.size() > 2 && str.front() != \\'0\\' && str.back() != \\'0\\')\\n            for (int i = 2; i < str.size(); i++)\\n                process(str.substr(0,i) + \".\" + str.substr(i), xy);\\n    }\\n    void process(string str, int xy) {\\n        if (xy)\\n            for (auto x : xPoss)\\n                ans.push_back(\"(\" + x + \", \" + str + \")\");\\n        else xPoss.push_back(str);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar ambiguousCoordinates = function(S) {\\n    let ans = [], xPoss\\n    const process = (str, xy) => {\\n        if (xy)\\n            for (let x of xPoss)\\n                ans.push(`(${x}, ${str})`)\\n        else xPoss.push(str)\\n    }\\n    const parse = (str, xy) => {\\n        if (str.length === 1 || str[0] !== \"0\")\\n            process(str, xy)\\n        if (str.length > 1 && str[str.length-1] !== \"0\")\\n            process(str.slice(0,1) + \".\" + str.slice(1), xy)\\n        if (str.length > 2 && str[0] !== \"0\" && str[str.length-1] !== \"0\")\\n            for (let i = 2; i < str.length; i++)\\n                process(str.slice(0,i) + \".\" + str.slice(i), xy)\\n    }\\n    for (let i = 2; i < S.length - 1; i++) {\\n        let strs = [S.slice(1,i), S.slice(i, S.length - 1)]\\n        xPoss = []\\n        for (let j = 0; j < 2; j++)\\n            if (xPoss.length || !j) parse(strs[j], j)\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def ambiguousCoordinates(self, S: str) -> List[str]:\\n        ans, xPoss = [], []\\n        def process(st: str, xy: int):\\n            if xy:\\n                for x in xPoss:\\n                    ans.append(\"(\" + x + \", \" + st + \")\")\\n            else: xPoss.append(st)\\n        def parse(st: str, xy: int):\\n            if len(st) == 1 or st[0] != \"0\":\\n                process(st, xy)\\n            if len(st) > 1 and st[-1] != \"0\":\\n                process(st[:1] + \".\" + st[1:], xy)\\n            if len(st) > 2 and st[0] != \"0\" and st[-1] != \"0\":\\n                for i in range(2, len(st)):\\n                    process(st[:i] + \".\" + st[i:], xy)  \\n        for i in range(2, len(S)-1):\\n            strs, xPoss = [S[1:i], S[i:-1]], []\\n            for j in range(2):\\n                if xPoss or not j: parse(strs[j], j)\\n        return ans\\n```\n```java\\nclass Solution {\\n    private List<String> xPoss, ans;\\n    public List<String> ambiguousCoordinates(String S) {\\n        ans = new ArrayList<>();\\n        for (int i = 2; i < S.length() - 1; i++) {\\n            String[] strs = {S.substring(1,i), S.substring(i, S.length() - 1)};\\n            xPoss = new ArrayList<>();\\n            for (int j = 0; j < 2; j++)\\n                if (xPoss.size() > 0 || j == 0) parse(strs[j], j);\\n        }\\n        return ans;\\n    }\\n    private void parse(String str, int xy) {\\n        if (str.length() == 1 || str.charAt(0) != \\'0\\')\\n            process(str, xy);\\n        if (str.length() > 1 && str.charAt(str.length()-1) != \\'0\\')\\n            process(str.substring(0,1) + \".\" + str.substring(1), xy);\\n        if (str.length() > 2 && str.charAt(0) != \\'0\\' && str.charAt(str.length()-1) != \\'0\\')\\n            for (int i = 2; i < str.length(); i++)\\n                process(str.substring(0,i) + \".\" + str.substring(i), xy);\\n    }\\n    private void process(String str, int xy) {\\n        if (xy > 0)\\n            for (String x : xPoss)\\n                ans.add(\"(\" + x + \", \" + str + \")\");\\n        else xPoss.add(str);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string S) {\\n        for (int i = 2; i < S.size() - 1; i++) {\\n            string strs[2] = {S.substr(1,i-1), S.substr(i,S.size()-i-1)};\\n            xPoss.clear();\\n            for (int j = 0; j < 2; j++)\\n                if (xPoss.size() || !j) parse(strs[j], j);\\n        }\\n        return ans;\\n    }\\nprivate:\\n    vector<string> ans, xPoss;\\n    void parse(string str, int xy) {\\n        if (str.size() == 1 || str.front() != \\'0\\')\\n            process(str, xy);\\n        if (str.size() > 1 && str.back() != \\'0\\')\\n            process(str.substr(0,1) + \".\" + str.substr(1), xy);\\n        if (str.size() > 2 && str.front() != \\'0\\' && str.back() != \\'0\\')\\n            for (int i = 2; i < str.size(); i++)\\n                process(str.substr(0,i) + \".\" + str.substr(i), xy);\\n    }\\n    void process(string str, int xy) {\\n        if (xy)\\n            for (auto x : xPoss)\\n                ans.push_back(\"(\" + x + \", \" + str + \")\");\\n        else xPoss.push_back(str);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206219,
                "title": "ambiguous-coordinates-js-python-java-c-easy-iterative-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nFor this problem, we have two basic challenges. The first challenge is preventing invalid coordinates. For that, we can define a helper function (**parse**) which will take a string (**str**) and only pass on valid options for another helper (**process**) to handle.\\n\\nWe can break down the options into three categories:\\n - _No decimal_: Any option except one with more than **1** digit and a leading **\"0\"**.\\n - _Decimal after first digit_: Any option with more than **1** digit and no trailing **\"0\"**.\\n - _Decimals throughout_: Any option that doesn\\'t start and end with a **\"0\"**\\n\\nAfter defining our first helper function, the next thing we should do is iterate through possible comma locations in our input string (**S**) and separate the coordinate pair strings (**xStr, yStr**).\\n\\nThen we\\'ll run into the second challenge, which is to avoid repeating the same processing. If we were to employ a simple nested loop or recursive function to solve this problem, it would end up redoing the same processes many times, since both coordinates can have a decimal.\\n\\nWhat we actually want is the product of two loops. The basic solution would be to create two arrays and iterate through their combinations, but there\\'s really no need to actually build the second array, since we can just as easily process the combinations while we iterate through the second coordinate naturally.\\n\\nSo we should first build and validate all decimal options for the **xStr** of a given comma position and store the valid possibilities in an array (**xPoss**). Once this is complete we should find each valid decimal option for **yStr**, combine it with each value in **xPoss**, and add the results to our answer array (**ans**) before moving onto the next comma position.\\n\\nTo aid in this, we can define **process**, which will either store the valid decimal options from **xStr** into **xPoss** or combine valid decimal options from **yStr** with the contents of **xPoss** and store the results in **ans**, depending on which coordinate string we\\'re currently on (**xy**).\\n\\nOnce we finish iterating through all comma positions, we can **return ans**.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **76ms / 42.3MB** (beats 100% / 100%).\\n```javascript\\nvar ambiguousCoordinates = function(S) {\\n    let ans = [], xPoss\\n    const process = (str, xy) => {\\n        if (xy)\\n            for (let x of xPoss)\\n                ans.push(`(${x}, ${str})`)\\n        else xPoss.push(str)\\n    }\\n    const parse = (str, xy) => {\\n        if (str.length === 1 || str[0] !== \"0\")\\n            process(str, xy)\\n        if (str.length > 1 && str[str.length-1] !== \"0\")\\n            process(str.slice(0,1) + \".\" + str.slice(1), xy)\\n        if (str.length > 2 && str[0] !== \"0\" && str[str.length-1] !== \"0\")\\n            for (let i = 2; i < str.length; i++)\\n                process(str.slice(0,i) + \".\" + str.slice(i), xy)\\n    }\\n    for (let i = 2; i < S.length - 1; i++) {\\n        let strs = [S.slice(1,i), S.slice(i, S.length - 1)]\\n        xPoss = []\\n        for (let j = 0; j < 2; j++)\\n            if (xPoss.length || !j) parse(strs[j], j)\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **32ms / 14.1MB** (beats 99% / 92%).\\n```python\\nclass Solution:\\n    def ambiguousCoordinates(self, S: str) -> List[str]:\\n        ans, xPoss = [], []\\n        def process(st: str, xy: int):\\n            if xy:\\n                for x in xPoss:\\n                    ans.append(\"(\" + x + \", \" + st + \")\")\\n            else: xPoss.append(st)\\n        def parse(st: str, xy: int):\\n            if len(st) == 1 or st[0] != \"0\":\\n                process(st, xy)\\n            if len(st) > 1 and st[-1] != \"0\":\\n                process(st[:1] + \".\" + st[1:], xy)\\n            if len(st) > 2 and st[0] != \"0\" and st[-1] != \"0\":\\n                for i in range(2, len(st)):\\n                    process(st[:i] + \".\" + st[i:], xy)  \\n        for i in range(2, len(S)-1):\\n            strs, xPoss = [S[1:i], S[i:-1]], []\\n            for j in range(2):\\n                if xPoss or not j: parse(strs[j], j)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **7ms / 39.5MB** (beats 100% / 91%).\\n```java\\nclass Solution {\\n    private List<String> xPoss, ans;\\n    public List<String> ambiguousCoordinates(String S) {\\n        ans = new ArrayList<>();\\n        for (int i = 2; i < S.length() - 1; i++) {\\n            String[] strs = {S.substring(1,i), S.substring(i, S.length() - 1)};\\n            xPoss = new ArrayList<>();\\n            for (int j = 0; j < 2; j++)\\n                if (xPoss.size() > 0 || j == 0) parse(strs[j], j);\\n        }\\n        return ans;\\n    }\\n    private void parse(String str, int xy) {\\n        if (str.length() == 1 || str.charAt(0) != \\'0\\')\\n            process(str, xy);\\n        if (str.length() > 1 && str.charAt(str.length()-1) != \\'0\\')\\n            process(str.substring(0,1) + \".\" + str.substring(1), xy);\\n        if (str.length() > 2 && str.charAt(0) != \\'0\\' && str.charAt(str.length()-1) != \\'0\\')\\n            for (int i = 2; i < str.length(); i++)\\n                process(str.substring(0,i) + \".\" + str.substring(i), xy);\\n    }\\n    private void process(String str, int xy) {\\n        if (xy > 0)\\n            for (String x : xPoss)\\n                ans.add(\"(\" + x + \", \" + str + \")\");\\n        else xPoss.add(str);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 9.1MB** (beats 100% / 95%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string S) {\\n        for (int i = 2; i < S.size() - 1; i++) {\\n            string strs[2] = {S.substr(1,i-1), S.substr(i,S.size()-i-1)};\\n            xPoss.clear();\\n            for (int j = 0; j < 2; j++)\\n                if (xPoss.size() || !j) parse(strs[j], j);\\n        }\\n        return ans;\\n    }\\nprivate:\\n    vector<string> ans, xPoss;\\n    void parse(string str, int xy) {\\n        if (str.size() == 1 || str.front() != \\'0\\')\\n            process(str, xy);\\n        if (str.size() > 1 && str.back() != \\'0\\')\\n            process(str.substr(0,1) + \".\" + str.substr(1), xy);\\n        if (str.size() > 2 && str.front() != \\'0\\' && str.back() != \\'0\\')\\n            for (int i = 2; i < str.size(); i++)\\n                process(str.substr(0,i) + \".\" + str.substr(i), xy);\\n    }\\n    void process(string str, int xy) {\\n        if (xy)\\n            for (auto x : xPoss)\\n                ans.push_back(\"(\" + x + \", \" + str + \")\");\\n        else xPoss.push_back(str);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar ambiguousCoordinates = function(S) {\\n    let ans = [], xPoss\\n    const process = (str, xy) => {\\n        if (xy)\\n            for (let x of xPoss)\\n                ans.push(`(${x}, ${str})`)\\n        else xPoss.push(str)\\n    }\\n    const parse = (str, xy) => {\\n        if (str.length === 1 || str[0] !== \"0\")\\n            process(str, xy)\\n        if (str.length > 1 && str[str.length-1] !== \"0\")\\n            process(str.slice(0,1) + \".\" + str.slice(1), xy)\\n        if (str.length > 2 && str[0] !== \"0\" && str[str.length-1] !== \"0\")\\n            for (let i = 2; i < str.length; i++)\\n                process(str.slice(0,i) + \".\" + str.slice(i), xy)\\n    }\\n    for (let i = 2; i < S.length - 1; i++) {\\n        let strs = [S.slice(1,i), S.slice(i, S.length - 1)]\\n        xPoss = []\\n        for (let j = 0; j < 2; j++)\\n            if (xPoss.length || !j) parse(strs[j], j)\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def ambiguousCoordinates(self, S: str) -> List[str]:\\n        ans, xPoss = [], []\\n        def process(st: str, xy: int):\\n            if xy:\\n                for x in xPoss:\\n                    ans.append(\"(\" + x + \", \" + st + \")\")\\n            else: xPoss.append(st)\\n        def parse(st: str, xy: int):\\n            if len(st) == 1 or st[0] != \"0\":\\n                process(st, xy)\\n            if len(st) > 1 and st[-1] != \"0\":\\n                process(st[:1] + \".\" + st[1:], xy)\\n            if len(st) > 2 and st[0] != \"0\" and st[-1] != \"0\":\\n                for i in range(2, len(st)):\\n                    process(st[:i] + \".\" + st[i:], xy)  \\n        for i in range(2, len(S)-1):\\n            strs, xPoss = [S[1:i], S[i:-1]], []\\n            for j in range(2):\\n                if xPoss or not j: parse(strs[j], j)\\n        return ans\\n```\n```java\\nclass Solution {\\n    private List<String> xPoss, ans;\\n    public List<String> ambiguousCoordinates(String S) {\\n        ans = new ArrayList<>();\\n        for (int i = 2; i < S.length() - 1; i++) {\\n            String[] strs = {S.substring(1,i), S.substring(i, S.length() - 1)};\\n            xPoss = new ArrayList<>();\\n            for (int j = 0; j < 2; j++)\\n                if (xPoss.size() > 0 || j == 0) parse(strs[j], j);\\n        }\\n        return ans;\\n    }\\n    private void parse(String str, int xy) {\\n        if (str.length() == 1 || str.charAt(0) != \\'0\\')\\n            process(str, xy);\\n        if (str.length() > 1 && str.charAt(str.length()-1) != \\'0\\')\\n            process(str.substring(0,1) + \".\" + str.substring(1), xy);\\n        if (str.length() > 2 && str.charAt(0) != \\'0\\' && str.charAt(str.length()-1) != \\'0\\')\\n            for (int i = 2; i < str.length(); i++)\\n                process(str.substring(0,i) + \".\" + str.substring(i), xy);\\n    }\\n    private void process(String str, int xy) {\\n        if (xy > 0)\\n            for (String x : xPoss)\\n                ans.add(\"(\" + x + \", \" + str + \")\");\\n        else xPoss.add(str);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string S) {\\n        for (int i = 2; i < S.size() - 1; i++) {\\n            string strs[2] = {S.substr(1,i-1), S.substr(i,S.size()-i-1)};\\n            xPoss.clear();\\n            for (int j = 0; j < 2; j++)\\n                if (xPoss.size() || !j) parse(strs[j], j);\\n        }\\n        return ans;\\n    }\\nprivate:\\n    vector<string> ans, xPoss;\\n    void parse(string str, int xy) {\\n        if (str.size() == 1 || str.front() != \\'0\\')\\n            process(str, xy);\\n        if (str.size() > 1 && str.back() != \\'0\\')\\n            process(str.substr(0,1) + \".\" + str.substr(1), xy);\\n        if (str.size() > 2 && str.front() != \\'0\\' && str.back() != \\'0\\')\\n            for (int i = 2; i < str.size(); i++)\\n                process(str.substr(0,i) + \".\" + str.substr(i), xy);\\n    }\\n    void process(string str, int xy) {\\n        if (xy)\\n            for (auto x : xPoss)\\n                ans.push_back(\"(\" + x + \", \" + str + \")\");\\n        else xPoss.push_back(str);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599950,
                "title": "c-modular-code-with-explanation",
                "content": "The logic is quite simple for this problem. You have to break the strings, at all possible points. Then you have to again break all the formed substrings, by placing dots in between the substrings, and following the `0` rules.\\n\\nExample - `(1234)`\\n\\nAfter removing the brackets, we get `s = 1234`. If you break the string at all points, the substrings you get are-\\n\\n`1  234`    ->   `1  234`,  `1  2.34`,  `1  23.4`\\n`12  34`    ->   `12  34`,  `12  3.4`,  `1.2  34`,  `1.2  3.4`\\n`123  4`    ->   `123  4`,  `1.23  4`,  `12.3  4`\\n\\nAs you can see I broke the substrings again to insert decimals. Of course you can\\'t have something like `1.` or `0001` or `1.00`. For that I use a `check function`.\\n\\nAs you can see after breaking the string at a particular point, I get two substrings `s1` and `s2`. Then I break both of them into `first` and `second`. `first` represents the part before the decimal and `second` is the part after that.\\n\\nFor `first`, if it\\'s length is greater than `1`, then first digit can\\'t be `0`. For example `0.xx` or `0` is valid, but something like `01.xx` or `000` is not acceptable. \\nSimilarly, for `second`, the last digit cant be `0`. For example `xx.0` or `xx.30` is not valid.\\n\\nThe reset is simple. I take 2 vectors `res1` (for storing the first coordinates) and `res2` (for storing the second coordinates), and combine them into the final vector.\\n\\n```\\nclass Solution {\\npublic:\\n\\t// issecword denotes if it is the second word (the part after the decimal)\\n    bool check(string s, bool issecword)\\n    {\\n        int n=s.length();\\n\\t\\t// Logic explained above\\n        if(issecword){\\n            if(n>0 && s[n-1]==\\'0\\') return false;\\n        }\\n        else{\\n            if(n>1 && s[0]==\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n\\n    vector<string> ambiguousCoordinates(string S) {\\n        vector<string> res;\\n        S=S.substr(1,S.length()-2);  // Remove the brackets\\n        int n=S.length();\\n\\n        for(int i=1;i<n;i++){\\n            string s1=S.substr(0,i);\\n            string s2=S.substr(i);\\n            vector<string> res1, res2;\\n\\t\\t\\t\\n\\t\\t\\t// The full string without any decimal point can also be a coordinate.\\n\\t\\t\\t// But \\'01\\' or \\'001\\' is not possible.\\n            if(check(s1, false)) res1.push_back(s1);\\n            if(check(s2, false)) res2.push_back(s2);\\n\\t\\t\\t\\n\\t\\t\\t// First co-ordinate\\n            for(int j=1;j<s1.length();j++){\\n                string first=s1.substr(0,j);\\n                string second=s1.substr(j);\\n                if(check(first, false) && check(second, true)) res1.push_back(first+\".\"+second);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Second co-ordinate\\n            for(int j=1;j<s2.length();j++){\\n                string first=s2.substr(0,j);\\n                string second=s2.substr(j);\\n                if(check(first, false) && check(second, true)) res2.push_back(first+\".\"+second);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Combine all the results\\n            for(auto left:res1){\\n                for(auto right:res2){\\n                    res.push_back(\"(\" + left + \", \"+ right + \")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n*Time Complexity* - `O(n^4)`  (Because `substr` function is `O(n)` worst case)\\n*Space Compexity* - `O(n)`",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// issecword denotes if it is the second word (the part after the decimal)\\n    bool check(string s, bool issecword)\\n    {\\n        int n=s.length();\\n\\t\\t// Logic explained above\\n        if(issecword){\\n            if(n>0 && s[n-1]==\\'0\\') return false;\\n        }\\n        else{\\n            if(n>1 && s[0]==\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n\\n    vector<string> ambiguousCoordinates(string S) {\\n        vector<string> res;\\n        S=S.substr(1,S.length()-2);  // Remove the brackets\\n        int n=S.length();\\n\\n        for(int i=1;i<n;i++){\\n            string s1=S.substr(0,i);\\n            string s2=S.substr(i);\\n            vector<string> res1, res2;\\n\\t\\t\\t\\n\\t\\t\\t// The full string without any decimal point can also be a coordinate.\\n\\t\\t\\t// But \\'01\\' or \\'001\\' is not possible.\\n            if(check(s1, false)) res1.push_back(s1);\\n            if(check(s2, false)) res2.push_back(s2);\\n\\t\\t\\t\\n\\t\\t\\t// First co-ordinate\\n            for(int j=1;j<s1.length();j++){\\n                string first=s1.substr(0,j);\\n                string second=s1.substr(j);\\n                if(check(first, false) && check(second, true)) res1.push_back(first+\".\"+second);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Second co-ordinate\\n            for(int j=1;j<s2.length();j++){\\n                string first=s2.substr(0,j);\\n                string second=s2.substr(j);\\n                if(check(first, false) && check(second, true)) res2.push_back(first+\".\"+second);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Combine all the results\\n            for(auto left:res1){\\n                for(auto right:res2){\\n                    res.push_back(\"(\" + left + \", \"+ right + \")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934654,
                "title": "python3-valid-numbers",
                "content": "Algo\\nThe key is to deal with extraneous zeros. Below rule gives the what\\'s required\\n1) if a string has length 1, return it;\\n2) if a string with length larger than 1 and starts and ends with 0, it cannot contain valid number;\\n3) if a string starts with 0, return `0.xxx`;\\n4) if a string ends with 0, return `xxx0`;\\n5) otherwise, put decimal point in the `n-1` places. \\n\\nImplementation \\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s.strip(\"(\").strip(\")\")\\n        \\n        def fn(s): \\n            \"\"\"Return valid numbers from s.\"\"\"\\n            if len(s) == 1: return [s]\\n            if s.startswith(\"0\") and s.endswith(\"0\"): return []\\n            if s.startswith(\"0\"): return [s[:1] + \".\" + s[1:]]\\n            if s.endswith(\"0\"): return [s]\\n            return [s[:i] + \".\" + s[i:] for i in range(1, len(s))] + [s]\\n        \\n        ans = []\\n        for i in range(1, len(s)): \\n            for x in fn(s[:i]):\\n                for y in fn(s[i:]): \\n                    ans.append(f\"({x}, {y})\")\\n        return ans  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s.strip(\"(\").strip(\")\")\\n        \\n        def fn(s): \\n            \"\"\"Return valid numbers from s.\"\"\"\\n            if len(s) == 1: return [s]\\n            if s.startswith(\"0\") and s.endswith(\"0\"): return []\\n            if s.startswith(\"0\"): return [s[:1] + \".\" + s[1:]]\\n            if s.endswith(\"0\"): return [s]\\n            return [s[:i] + \".\" + s[i:] for i in range(1, len(s))] + [s]\\n        \\n        ans = []\\n        for i in range(1, len(s)): \\n            for x in fn(s[:i]):\\n                for y in fn(s[i:]): \\n                    ans.append(f\"({x}, {y})\")\\n        return ans  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205957,
                "title": "rust-0-4ms-100-runtime-iterative-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn ambiguous_coordinates(s: String) -> Vec<String> {\\n        let s = &s.as_bytes()[1..s.len() - 1]; // ignore the parenthesis around the coords\\n        (1..s.len()).fold(vec![], |mut acc, commai| {\\n            let (x, y) = s.split_at(commai);\\n            (0..x.len())\\n                .filter_map(|doti| Self::make_coord(x, doti))\\n                .for_each(|x| {\\n                    (0..y.len())\\n                        .filter_map(|doti| Self::make_coord(y, doti))\\n                        .for_each(|y| acc.push(format!(\"({}, {})\", x, y)))\\n                });\\n            acc\\n        })\\n    }\\n\\n    fn make_coord(s: &[u8], doti: usize) -> Option<String> {\\n        if (s.len() == 1 || doti == 1 || s[0] != b\\'0\\') && (doti == 0 || s[s.len() - 1] != b\\'0\\') {\\n            let (l, r) = s.split_at(doti);\\n            let l = unsafe { String::from_utf8_unchecked(l.into()) }; // these are safe, as s is\\n            let r = unsafe { String::from_utf8_unchecked(r.into()) }; // always valid ASCII\\n            Some(format!(\"{}{}{}\", l, if l.is_empty() { \"\" } else { \".\" }, r))\\n        } else {\\n            None\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Iterator"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn ambiguous_coordinates(s: String) -> Vec<String> {\\n        let s = &s.as_bytes()[1..s.len() - 1]; // ignore the parenthesis around the coords\\n        (1..s.len()).fold(vec![], |mut acc, commai| {\\n            let (x, y) = s.split_at(commai);\\n            (0..x.len())\\n                .filter_map(|doti| Self::make_coord(x, doti))\\n                .for_each(|x| {\\n                    (0..y.len())\\n                        .filter_map(|doti| Self::make_coord(y, doti))\\n                        .for_each(|y| acc.push(format!(\"({}, {})\", x, y)))\\n                });\\n            acc\\n        })\\n    }\\n\\n    fn make_coord(s: &[u8], doti: usize) -> Option<String> {\\n        if (s.len() == 1 || doti == 1 || s[0] != b\\'0\\') && (doti == 0 || s[s.len() - 1] != b\\'0\\') {\\n            let (l, r) = s.split_at(doti);\\n            let l = unsafe { String::from_utf8_unchecked(l.into()) }; // these are safe, as s is\\n            let r = unsafe { String::from_utf8_unchecked(r.into()) }; // always valid ASCII\\n            Some(format!(\"{}{}{}\", l, if l.is_empty() { \"\" } else { \".\" }, r))\\n        } else {\\n            None\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1207300,
                "title": "java-simple-and-easy-to-understand-solution-8-ms-faster-than-79-79-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        String digits = s.substring(1, s.length() - 1);\\n        \\n        List<String> result = new ArrayList();\\n        if(digits.length() < 2) return result;\\n        \\n        \\n        for(int i = 1; i < digits.length(); i++){\\n            //split the digits in 2 parts\\n            String left = digits.substring(0, i);\\n            String right = digits.substring(i);\\n            \\n            //check any of part contains only zeroes \\n            if((left.length() > 1 && Long.valueOf(left) == 0) || (right.length() > 1 && Long.valueOf(right) == 0)) continue;\\n            \\n            \\n            List<String> leftCoordinates = getValidCoordinates(left);\\n            if(leftCoordinates.size() == 0) continue;\\n            \\n            List<String> rightCoordinates = getValidCoordinates(right);\\n            if(rightCoordinates.size() == 0) continue;\\n            \\n            \\n            for(String leftCor : leftCoordinates){\\n                for(String rightCor : rightCoordinates){\\n                    //concatenate right and left coordinate\\n                    StringBuilder sb = new StringBuilder();\\n                        sb\\n                        .append(\\'(\\')\\n                        .append(leftCor)\\n                        .append(\", \")\\n                        .append(rightCor)\\n                        .append(\\')\\');\\n                    //String coordinate = \"(\" + leftCor + \", \" + rightCor + \")\";\\n                    //result.add(coordinate);\\n                    \\n                    result.add(sb.toString());\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        \\n        return result;\\n    }\\n    \\n    private List<String> getValidCoordinates(String str){\\n        \\n        List<String> result = new ArrayList();\\n        \\n        int n = str.length();\\n        \\n        if(n == 1) {\\n            result.add(str);\\n            return result;\\n        }\\n        \\n        if(str.charAt(0) == \\'0\\'){\\n            if(str.charAt(n - 1) == \\'0\\'){\\n                return result;\\n            }\\n            \\n            String coordinate = \"0.\" + str.substring(1); \\n            result.add(coordinate);\\n            return result;\\n        }\\n        \\n        if(str.charAt(n - 1) == \\'0\\'){\\n            result.add(str);\\n            return result;\\n        }\\n        \\n        \\n        for(int i = 1; i < n; i++){\\n            String coordinate = str.substring(0, i) + \".\" + str.substring(i); \\n            result.add(coordinate);\\n        }\\n        result.add(str);\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        String digits = s.substring(1, s.length() - 1);\\n        \\n        List<String> result = new ArrayList();\\n        if(digits.length() < 2) return result;\\n        \\n        \\n        for(int i = 1; i < digits.length(); i++){\\n            //split the digits in 2 parts\\n            String left = digits.substring(0, i);\\n            String right = digits.substring(i);\\n            \\n            //check any of part contains only zeroes \\n            if((left.length() > 1 && Long.valueOf(left) == 0) || (right.length() > 1 && Long.valueOf(right) == 0)) continue;\\n            \\n            \\n            List<String> leftCoordinates = getValidCoordinates(left);\\n            if(leftCoordinates.size() == 0) continue;\\n            \\n            List<String> rightCoordinates = getValidCoordinates(right);\\n            if(rightCoordinates.size() == 0) continue;\\n            \\n            \\n            for(String leftCor : leftCoordinates){\\n                for(String rightCor : rightCoordinates){\\n                    //concatenate right and left coordinate\\n                    StringBuilder sb = new StringBuilder();\\n                        sb\\n                        .append(\\'(\\')\\n                        .append(leftCor)\\n                        .append(\", \")\\n                        .append(rightCor)\\n                        .append(\\')\\');\\n                    //String coordinate = \"(\" + leftCor + \", \" + rightCor + \")\";\\n                    //result.add(coordinate);\\n                    \\n                    result.add(sb.toString());\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        \\n        return result;\\n    }\\n    \\n    private List<String> getValidCoordinates(String str){\\n        \\n        List<String> result = new ArrayList();\\n        \\n        int n = str.length();\\n        \\n        if(n == 1) {\\n            result.add(str);\\n            return result;\\n        }\\n        \\n        if(str.charAt(0) == \\'0\\'){\\n            if(str.charAt(n - 1) == \\'0\\'){\\n                return result;\\n            }\\n            \\n            String coordinate = \"0.\" + str.substring(1); \\n            result.add(coordinate);\\n            return result;\\n        }\\n        \\n        if(str.charAt(n - 1) == \\'0\\'){\\n            result.add(str);\\n            return result;\\n        }\\n        \\n        \\n        for(int i = 1; i < n; i++){\\n            String coordinate = str.substring(0, i) + \".\" + str.substring(i); \\n            result.add(coordinate);\\n        }\\n        result.add(str);\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1512858,
                "title": "python-generate-beats-94-runtime-and-91-memory",
                "content": "For a string slice, we generate a list of numbers with following rules:\\n1. If the slice is `\\'0\\'`, then return `[\\'0\\']`\\n2. If the slice starts and ends with `\\'0\\'`, we generate nothing. Because we cannot have `0.****0`\\n3. If the slice starts with `\\'0\\'`, then the only number we generate is `0.****`\\n4. If the slice does not start with `\\'0\\'`, but ends with `\\'0\\'`, which means we can only generate `*****0` without decimal point. Otherwise, we\\'d end up with `***.***0`\\n5. If the slice does not start with or end with `\\'0\\'`, then we can generate lots of numbers by inserting the decimal points at any position. For example, using `ABCD` as a base, then we can generate `A.BCD`, `AB.CD`, `ABC.D`.\\n```python\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1] # remove parenthesis\\n        def generateNumbers(start, end):\\n            if s[start] == \\'0\\': \\n                if end == start: return [\\'0\\'] # rule 1\\n                elif s[end] == \\'0\\': return [] # rule 2\\n                else: return [f\\'{s[start]}.{s[start+1:end+1]}\\'] # rule 3\\n            base = s[start:end+1]\\n            res = [base]\\n            if s[end] != \\'0\\': # rule 4\\n                for i in range(1, len(base)): # rule 5\\n                    res.append(f\\'{base[:i]}.{base[i:]}\\')\\n            return res\\n        size = len(s)\\n        res = []\\n        for split in range(1, size):\\n            for first in generateNumbers(0, split - 1):\\n                for second in generateNumbers(split, size - 1):\\n                    res.append(f\\'({first}, {second})\\')\\n        return res\\n            \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1] # remove parenthesis\\n        def generateNumbers(start, end):\\n            if s[start] == \\'0\\': \\n                if end == start: return [\\'0\\'] # rule 1\\n                elif s[end] == \\'0\\': return [] # rule 2\\n                else: return [f\\'{s[start]}.{s[start+1:end+1]}\\'] # rule 3\\n            base = s[start:end+1]\\n            res = [base]\\n            if s[end] != \\'0\\': # rule 4\\n                for i in range(1, len(base)): # rule 5\\n                    res.append(f\\'{base[:i]}.{base[i:]}\\')\\n            return res\\n        size = len(s)\\n        res = []\\n        for split in range(1, size):\\n            for first in generateNumbers(0, split - 1):\\n                for second in generateNumbers(split, size - 1):\\n                    res.append(f\\'({first}, {second})\\')\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206637,
                "title": "java-simple-split-and-apply-dots-approach-beats-80-with-explaination",
                "content": "Key Intuition: \\n1. Split the string up in 2 parts in all possible ways. \\n2. Now add dots at various possible places in each split part. Remember to skip instances where pre dot part has leading zeros and post dot part has trailing zeros. Also do not forget to include the complete string itself without the dot in case it has no leading zeros. \\n3. Find the cross product of list of strings obtained by putting the dot at various places in the left (xcord) and right (ycord) coordinates.\\n4. Return this list of cross products of possible string combinations.\\n```\\n/*\\nKey Intuition: \\n1. Split the string up in 2 parts in all possible ways. \\n2. Now add dots at various possible places in each split part. Remember to skip instances where pre dot part has leading zeros and post dot part has trailing zeros. Also do not forget to include the complete string itself without the dow in case it has no leading zeros. \\n3. Find the cross product of list of strings obtained by putting the dot at various places in the left (xcord) and right (ycord) coordinates.\\n4. Return this list of cross products of possible string combinations.\\n\\n*/\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> result = new ArrayList<>();\\n        \\n        //Split the string up in 2 parts in all possible ways. \\n        List<String[]> list = split(s.substring(1, s.length() - 1));\\n\\n        for(String[] split : list) {\\n            \\n            //Now add dots at various possible places in each split part. Remember to skip instances where pre dot part has leading zeros and post dot part has trailing zeros. Also do not forget to include the complete string itself without the dot in case it has no leading zeros.\\n            List<String> xcords = dot(split[0]);\\n            List<String> ycords = dot(split[1]);\\n\\t\\t\\t\\n\\t\\t\\t//Find the cross product of list of strings obtained by putting the dot at various places in the left (xcord) and right (ycord) coordinates.\\n            for(String xcord : xcords) {\\n                for(String ycord : ycords) {\\n                    result.add(\"(\" + xcord + \", \" + ycord + \")\");\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    //Split the string up in 2 parts in all possible ways. \\n    private List<String[]> split(String s) {\\n        List<String[]> list = new ArrayList<>();\\n        for(int i = 1; i < s.length(); i++) {\\n            String[] splits = new String[2];\\n            splits[0] = s.substring(0, i);\\n            splits[1] = s.substring(i);\\n            list.add(splits);\\n        }\\n        return list;\\n    }\\n    \\n    private List<String> dot(String s) {\\n        \\n        List<String> list = new ArrayList<>();\\n        \\n        // do not forget to include the complete string itself without the dow in case it has no leading zeros.\\n        if(!s.startsWith(\"0\") || s.length() == 1) {\\n            list.add(s);\\n        }\\n        \\n        if(s.length() == 1) {\\n            return list;\\n        }\\n        \\n        //Now add dots at various possible places in each split part.\\n        for(int i = 1; i < s.length(); i++) {\\n            \\n            //Remember to skip instances where pre dot part has leading zeros and post dot part has trailing zeros\\n            String preDot = s.substring(0, i);\\n            if(preDot.startsWith(\"0\") && preDot.length() > 1) {\\n                continue;\\n            }\\n            String postDot = s.substring(i);\\n            if(postDot.endsWith(\"0\")) {\\n                continue;\\n            }\\n            list.add(preDot + \".\" + postDot);\\n        }\\n        return list;\\n    }\\n}\\n```\\n\\n**Please upvote if this helped**",
                "solutionTags": [],
                "code": "```\\n/*\\nKey Intuition: \\n1. Split the string up in 2 parts in all possible ways. \\n2. Now add dots at various possible places in each split part. Remember to skip instances where pre dot part has leading zeros and post dot part has trailing zeros. Also do not forget to include the complete string itself without the dow in case it has no leading zeros. \\n3. Find the cross product of list of strings obtained by putting the dot at various places in the left (xcord) and right (ycord) coordinates.\\n4. Return this list of cross products of possible string combinations.\\n\\n*/\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> result = new ArrayList<>();\\n        \\n        //Split the string up in 2 parts in all possible ways. \\n        List<String[]> list = split(s.substring(1, s.length() - 1));\\n\\n        for(String[] split : list) {\\n            \\n            //Now add dots at various possible places in each split part. Remember to skip instances where pre dot part has leading zeros and post dot part has trailing zeros. Also do not forget to include the complete string itself without the dot in case it has no leading zeros.\\n            List<String> xcords = dot(split[0]);\\n            List<String> ycords = dot(split[1]);\\n\\t\\t\\t\\n\\t\\t\\t//Find the cross product of list of strings obtained by putting the dot at various places in the left (xcord) and right (ycord) coordinates.\\n            for(String xcord : xcords) {\\n                for(String ycord : ycords) {\\n                    result.add(\"(\" + xcord + \", \" + ycord + \")\");\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    //Split the string up in 2 parts in all possible ways. \\n    private List<String[]> split(String s) {\\n        List<String[]> list = new ArrayList<>();\\n        for(int i = 1; i < s.length(); i++) {\\n            String[] splits = new String[2];\\n            splits[0] = s.substring(0, i);\\n            splits[1] = s.substring(i);\\n            list.add(splits);\\n        }\\n        return list;\\n    }\\n    \\n    private List<String> dot(String s) {\\n        \\n        List<String> list = new ArrayList<>();\\n        \\n        // do not forget to include the complete string itself without the dow in case it has no leading zeros.\\n        if(!s.startsWith(\"0\") || s.length() == 1) {\\n            list.add(s);\\n        }\\n        \\n        if(s.length() == 1) {\\n            return list;\\n        }\\n        \\n        //Now add dots at various possible places in each split part.\\n        for(int i = 1; i < s.length(); i++) {\\n            \\n            //Remember to skip instances where pre dot part has leading zeros and post dot part has trailing zeros\\n            String preDot = s.substring(0, i);\\n            if(preDot.startsWith(\"0\") && preDot.length() > 1) {\\n                continue;\\n            }\\n            String postDot = s.substring(i);\\n            if(postDot.endsWith(\"0\")) {\\n                continue;\\n            }\\n            list.add(preDot + \".\" + postDot);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206060,
                "title": "python-well-explained-97-33-faster-easy-understanding",
                "content": "## **Idea :**\\nSplit the string into left and right , then create the possible string seperately , then merge .\\n\\n* When there is only one letter in the string , directly return itself.\\n* when the first and last letter is \\'0\\', then it\\'s impossible to create a valid string, return []\\n* when the first letter is \\'0\\', then we only have one choice : \\'0.xxxx\\'\\n* when the last letter is \\'0\\', then we only have one choice , the string itself.\\n* all other , we can put \\'.\\' between any two letters.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\n        def create(num):\\n            l=len(num)\\n            if l==1:\\n                return [num]\\n            if num[0]==\"0\" and num[-1]==\"0\":\\n                return []\\n            if num[0]==\"0\":\\n                return [\"0.\"+num[1:]]\\n            if num[-1]==\"0\":\\n                return [num]\\n            local=[num]\\n            for i in range(1,len(num)):\\n                local.append(num[:i]+\".\"+num[i:])\\n            return local\\n        \\n        s=s[1:-1]\\n        n=len(s)\\n        res=[]\\n        for i in range(1,n):\\n            left = create(s[:i])\\n            right= create(s[i:])\\n            if not left or not right:\\n                continue\\n            for l in left:\\n                for r in right:\\n                    res.append(f\\'({l}, {r})\\')\\n        return res\\n\\nThank You!!\\nIf you dont get it , feel free to ask.",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "class Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\n        def create(num):\\n            l=len(num)\\n            if l==1:\\n                return [num]\\n            if num[0]==\"0\" and num[-1]==\"0\":\\n                return []\\n            if num[0]==\"0\":\\n                return [\"0.\"+num[1:]]\\n            if num[-1]==\"0\":\\n                return [num]\\n            local=[num]\\n            for i in range(1,len(num)):\\n                local.append(num[:i]+\".\"+num[i:])\\n            return local\\n        \\n        s=s[1:-1]\\n        n=len(s)\\n        res=[]\\n        for i in range(1,n):\\n            left = create(s[:i])\\n            right= create(s[i:])\\n            if not left or not right:\\n                continue\\n            for l in left:\\n                for r in right:\\n                    res.append(f\\'({l}",
                "codeTag": "Java"
            },
            {
                "id": 1205884,
                "title": "modular-programming-easy-to-read-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1, s.length() - 2);\\n        vector<string> result;\\n        for (int i = 1; i < s.length(); i++)\\n        {\\n            string str1 = s.substr(0, i), str2 = s.substr(i);\\n            vector<string> res1 = genValid(str1), res2 = genValid(str2);\\n\\n            for (auto& s1 : res1)\\n                for (auto& s2 : res2)\\n                    genResult(s1, s2, result);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    vector<string> genValid(string& str)\\n    {\\n        vector<string> res;\\n        if (valid(str))\\n            res.push_back(str);\\n        \\n        for (int i = 1; i < str.length(); i++)\\n        {\\n            string cur = str.substr(0, i) + \".\" + str.substr(i);\\n            if (valid(cur))\\n                res.emplace_back(cur);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    bool valid(string& str)\\n    {\\n        if (str.length() > 1 && str[0] == \\'0\\' && str[1] != \\'.\\')\\n            return false;\\n\\n        if (str.back() == \\'0\\')\\n        {\\n            for (int i = str.length() - 1; i >= 0; i--)\\n                if (str[i] == \\'.\\')\\n                    return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    void genResult(string& str1, string& str2, vector<string>& result)\\n    {\\n        result.emplace_back(\"(\" + str1 + \", \" + str2 + \")\");\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1, s.length() - 2);\\n        vector<string> result;\\n        for (int i = 1; i < s.length(); i++)\\n        {\\n            string str1 = s.substr(0, i), str2 = s.substr(i);\\n            vector<string> res1 = genValid(str1), res2 = genValid(str2);\\n\\n            for (auto& s1 : res1)\\n                for (auto& s2 : res2)\\n                    genResult(s1, s2, result);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    vector<string> genValid(string& str)\\n    {\\n        vector<string> res;\\n        if (valid(str))\\n            res.push_back(str);\\n        \\n        for (int i = 1; i < str.length(); i++)\\n        {\\n            string cur = str.substr(0, i) + \".\" + str.substr(i);\\n            if (valid(cur))\\n                res.emplace_back(cur);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    bool valid(string& str)\\n    {\\n        if (str.length() > 1 && str[0] == \\'0\\' && str[1] != \\'.\\')\\n            return false;\\n\\n        if (str.back() == \\'0\\')\\n        {\\n            for (int i = str.length() - 1; i >= 0; i--)\\n                if (str[i] == \\'.\\')\\n                    return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    void genResult(string& str1, string& str2, vector<string>& result)\\n    {\\n        result.emplace_back(\"(\" + str1 + \", \" + str2 + \")\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1115781,
                "title": "c-solution-with-some-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string S) {\\n        // First get rid of paranthesis at the both end\\n        S.erase(0, 1);\\n        S.pop_back();\\n        vector<string> result;\\n        vector<pair<string, string>> valids;\\n        int size = S.size();\\n        // Without dots\\n        for (int i = 0; i < size - 1; i++) {\\n            string A = S.substr(0, i + 1);\\n            string B = S.substr(i + 1, size - i + 1);\\n            valids.push_back({A, B});\\n        }\\n        // With Dots\\n        for (int i = 0; i < valids.size(); i++) {\\n            vector<string> left = { valids[i].first }, right = { valids[i].second };\\n            if (valids[i].first.size() > 1) {\\n                for (int j = 1; j < valids[i].first.size(); j++) {\\n                    string withDotL = valids[i].first;\\n                    withDotL.insert(j, 1, \\'.\\');\\n                    left.push_back(withDotL);\\n                }\\n            }\\n            if (valids[i].second.size() > 1) {\\n                for (int j = 1; j < valids[i].second.size(); j++) {\\n                    string withDotR = valids[i].second;\\n                    withDotR.insert(j, 1, \\'.\\');\\n                    right.push_back(withDotR);\\n                }\\n            }\\n            // Start checking validity\\n            for (int i = 0; i < left.size(); i++) {\\n                for (int j = 0; j < right.size(); j++) {\\n                    if (isValid(left[i]) && isValid(right[j])) {\\n                        result.push_back(\"(\" + left[i] + \", \" + right[j] + \")\");\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    // Valid 0, 0.X\\n    // Invalid: \"5.0\", \"00\", \"0.0\", \"0.00\", \"1.0\", \"001\", \"00.01\"\\n    bool isValid(string &s) {\\n        // Single char\\n        if (s.size() == 1) {\\n            return true;\\n        }\\n        // Invalid case: 0xxx0\\n        if (s[0] == \\'0\\') {\\n            // Only valid 0.xxx\\n            if (s[1] != \\'.\\') {\\n                return false;\\n            }\\n            // 00, 0xx0\\n            if (s.back() == \\'0\\' || s[1] == \\'0\\') {\\n                return false;\\n            }\\n            return true;\\n        }\\n        // Invalid case: xxx.0\\n        if (s.back() == \\'0\\') {\\n            // Only valid case xxx0\\n            if (s.find(\\'.\\') == std::string::npos) {\\n                return true;\\n            }\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string S) {\\n        // First get rid of paranthesis at the both end\\n        S.erase(0, 1);\\n        S.pop_back();\\n        vector<string> result;\\n        vector<pair<string, string>> valids;\\n        int size = S.size();\\n        // Without dots\\n        for (int i = 0; i < size - 1; i++) {\\n            string A = S.substr(0, i + 1);\\n            string B = S.substr(i + 1, size - i + 1);\\n            valids.push_back({A, B});\\n        }\\n        // With Dots\\n        for (int i = 0; i < valids.size(); i++) {\\n            vector<string> left = { valids[i].first }, right = { valids[i].second };\\n            if (valids[i].first.size() > 1) {\\n                for (int j = 1; j < valids[i].first.size(); j++) {\\n                    string withDotL = valids[i].first;\\n                    withDotL.insert(j, 1, \\'.\\');\\n                    left.push_back(withDotL);\\n                }\\n            }\\n            if (valids[i].second.size() > 1) {\\n                for (int j = 1; j < valids[i].second.size(); j++) {\\n                    string withDotR = valids[i].second;\\n                    withDotR.insert(j, 1, \\'.\\');\\n                    right.push_back(withDotR);\\n                }\\n            }\\n            // Start checking validity\\n            for (int i = 0; i < left.size(); i++) {\\n                for (int j = 0; j < right.size(); j++) {\\n                    if (isValid(left[i]) && isValid(right[j])) {\\n                        result.push_back(\"(\" + left[i] + \", \" + right[j] + \")\");\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    // Valid 0, 0.X\\n    // Invalid: \"5.0\", \"00\", \"0.0\", \"0.00\", \"1.0\", \"001\", \"00.01\"\\n    bool isValid(string &s) {\\n        // Single char\\n        if (s.size() == 1) {\\n            return true;\\n        }\\n        // Invalid case: 0xxx0\\n        if (s[0] == \\'0\\') {\\n            // Only valid 0.xxx\\n            if (s[1] != \\'.\\') {\\n                return false;\\n            }\\n            // 00, 0xx0\\n            if (s.back() == \\'0\\' || s[1] == \\'0\\') {\\n                return false;\\n            }\\n            return true;\\n        }\\n        // Invalid case: xxx.0\\n        if (s.back() == \\'0\\') {\\n            // Only valid case xxx0\\n            if (s.find(\\'.\\') == std::string::npos) {\\n                return true;\\n            }\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861233,
                "title": "javascript-100-with-comments",
                "content": "```\\nfunction solution(S) {\\n    S = S.slice(1, S.length - 1);\\n    let arr = [];\\n\\n    // Separate in 2 parts. All possible ways (just put comma in all possible places).\\n    for (let i = 1; i < S.length; i++) {\\n        // get all possible (distinct) numbers that a string can be converted to. Do this for string1 and string2\\n        let p1 = combos(S.slice(0, i));\\n        let p2 = combos(S.slice(i));\\n\\n\\n        if (p1.length && p2.length) {\\n            for (let x1 of p1) {\\n                for (let x2 of p2) {\\n                    arr.push([x1, x2]);\\n                }\\n            }\\n        }\\n    }\\n    return arr.map(e => `(${e[0]}, ${e[1]})`);\\n}\\n\\n// get all possible (distinct) numbers that a string can be converted to.\\nfunction combos(s) {\\n    let set = new Set(); // Use set so that it keeps distinct values\\n    if (String(Number(s)).length === s.length) set.add(Number(s));\\n    if (s.length === 1) return [...set];\\n\\n    // Just put a dot in all possible places.\\n    for (let i = 1; i < s.length; i++) {\\n        let x = Number(s.slice(0, i) + \\'.\\' + s.slice(i));\\n\\n        // Don\\'t add if some digits were lost during convert (e.g. 0012 --> 12)\\n        if (String(x).length === (s.length + 1)) set.add(x);\\n    }\\n    return [...set];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunction solution(S) {\\n    S = S.slice(1, S.length - 1);\\n    let arr = [];\\n\\n    // Separate in 2 parts. All possible ways (just put comma in all possible places).\\n    for (let i = 1; i < S.length; i++) {\\n        // get all possible (distinct) numbers that a string can be converted to. Do this for string1 and string2\\n        let p1 = combos(S.slice(0, i));\\n        let p2 = combos(S.slice(i));\\n\\n\\n        if (p1.length && p2.length) {\\n            for (let x1 of p1) {\\n                for (let x2 of p2) {\\n                    arr.push([x1, x2]);\\n                }\\n            }\\n        }\\n    }\\n    return arr.map(e => `(${e[0]}, ${e[1]})`);\\n}\\n\\n// get all possible (distinct) numbers that a string can be converted to.\\nfunction combos(s) {\\n    let set = new Set(); // Use set so that it keeps distinct values\\n    if (String(Number(s)).length === s.length) set.add(Number(s));\\n    if (s.length === 1) return [...set];\\n\\n    // Just put a dot in all possible places.\\n    for (let i = 1; i < s.length; i++) {\\n        let x = Number(s.slice(0, i) + \\'.\\' + s.slice(i));\\n\\n        // Don\\'t add if some digits were lost during convert (e.g. 0012 --> 12)\\n        if (String(x).length === (s.length + 1)) set.add(x);\\n    }\\n    return [...set];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 641809,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string s, bool issecword){\\n        int n=s.length();\\n\\t\\t// Logic explained above\\n        if(issecword){\\n            if(n>0 && s[n-1]==\\'0\\') return false;\\n        }\\n        else{\\n            if(n>1 && s[0]==\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n\\n    vector<string> ambiguousCoordinates(string S) {\\n        vector<string> res;\\n        S=S.substr(1,S.length()-2);\\n        int n=S.length();\\n\\n        for(int i=1;i<n;i++){\\n            string s1=S.substr(0,i);\\n            string s2=S.substr(i);\\n            vector<string> res1, res2;\\n\\t\\t\\t\\n            if(check(s1, false)) res1.push_back(s1);\\n            if(check(s2, false)) res2.push_back(s2);\\n\\t\\t\\t\\n            for(int j=1;j<s1.length();j++){\\n                string first=s1.substr(0,j);\\n                string second=s1.substr(j);\\n                if(check(first, false) && check(second, true)) res1.push_back(first+\".\"+second);\\n            }\\n            \\n            for(int j=1;j<s2.length();j++){\\n                string first=s2.substr(0,j);\\n                string second=s2.substr(j);\\n                if(check(first, false) && check(second, true)) res2.push_back(first+\".\"+second);\\n            }\\n\\t\\t\\t\\n            for(auto left:res1){\\n                for(auto right:res2){\\n                    res.push_back(\"(\" + left + \", \"+ right + \")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string s, bool issecword){\\n        int n=s.length();\\n\\t\\t// Logic explained above\\n        if(issecword){\\n            if(n>0 && s[n-1]==\\'0\\') return false;\\n        }\\n        else{\\n            if(n>1 && s[0]==\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n\\n    vector<string> ambiguousCoordinates(string S) {\\n        vector<string> res;\\n        S=S.substr(1,S.length()-2);\\n        int n=S.length();\\n\\n        for(int i=1;i<n;i++){\\n            string s1=S.substr(0,i);\\n            string s2=S.substr(i);\\n            vector<string> res1, res2;\\n\\t\\t\\t\\n            if(check(s1, false)) res1.push_back(s1);\\n            if(check(s2, false)) res2.push_back(s2);\\n\\t\\t\\t\\n            for(int j=1;j<s1.length();j++){\\n                string first=s1.substr(0,j);\\n                string second=s1.substr(j);\\n                if(check(first, false) && check(second, true)) res1.push_back(first+\".\"+second);\\n            }\\n            \\n            for(int j=1;j<s2.length();j++){\\n                string first=s2.substr(0,j);\\n                string second=s2.substr(j);\\n                if(check(first, false) && check(second, true)) res2.push_back(first+\".\"+second);\\n            }\\n\\t\\t\\t\\n            for(auto left:res1){\\n                for(auto right:res2){\\n                    res.push_back(\"(\" + left + \", \"+ right + \")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507569,
                "title": "accepted-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        public IList<string> AmbiguousCoordinates(string s)\\n        {\\n            s = s.Substring(1, s.Length - 2);\\n            IList<string> res = new List<string>();\\n            for (int i = 1; i < s.Length; i++)\\n            {\\n                var left = s.Substring(0, i);\\n                var right = s.Substring(i, s.Length - i);\\n\\n\\n                IList<string> lefts = new List<string>();\\n                IList<string> rights = new List<string>();\\n\\n                if (!(left.Length >= 2 && left[0] == \\'0\\'))\\n                {\\n                    lefts.Add(left);\\n                }\\n\\n\\n                if (!(right.Length >= 2 && right[0] == \\'0\\'))\\n                {\\n                    rights.Add(right);\\n                }\\n\\n                for (int j = 1; j < left.Length; j++)\\n                {\\n                    var leftLeft = left.Substring(0, j);\\n                    if (j > 1 && leftLeft[0] == \\'0\\')\\n                    {\\n                        continue;\\n                    }\\n                    var leftRight = left.Substring(j, left.Length - j);\\n\\n                    if (leftRight.Length > 1 && leftRight[leftRight.Length - 1] == \\'0\\')\\n                    {\\n                        continue;\\n                    }\\n\\n\\n                    var cand = $\"{leftLeft}.{leftRight}\";\\n                    if (int.Parse(leftRight) == 0)\\n                    {\\n                        continue;\\n                    }\\n                    lefts.Add(cand);\\n                }\\n\\n\\n                for (int j = 1; j < right.Length; j++)\\n                {\\n                    var rightLeft = right.Substring(0, j);\\n                    if (j > 1 && rightLeft[0] == \\'0\\')\\n                    {\\n                        continue;\\n                    }\\n                    var rightRight = right.Substring(j, right.Length - j);\\n\\n                    if (rightRight.Length > 1 && rightRight[rightRight.Length - 1] == \\'0\\')\\n                    {\\n                        continue;\\n                    }\\n\\n                    var cand = $\"{rightLeft}.{rightRight}\";\\n                    if (int.Parse(rightRight) == 0)\\n                    {\\n                        continue;\\n                    }\\n                    rights.Add(cand);\\n                }\\n\\n                foreach (var l in lefts)\\n                {\\n                    foreach (var r in rights)\\n                    {\\n                        res.Add($\"({l}, {r})\");\\n                    }\\n                }\\n\\n            }\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        public IList<string> AmbiguousCoordinates(string s)\\n        {\\n            s = s.Substring(1, s.Length - 2);\\n            IList<string> res = new List<string>();\\n            for (int i = 1; i < s.Length; i++)\\n            {\\n                var left = s.Substring(0, i);\\n                var right = s.Substring(i, s.Length - i);\\n\\n\\n                IList<string> lefts = new List<string>();\\n                IList<string> rights = new List<string>();\\n\\n                if (!(left.Length >= 2 && left[0] == \\'0\\'))\\n                {\\n                    lefts.Add(left);\\n                }\\n\\n\\n                if (!(right.Length >= 2 && right[0] == \\'0\\'))\\n                {\\n                    rights.Add(right);\\n                }\\n\\n                for (int j = 1; j < left.Length; j++)\\n                {\\n                    var leftLeft = left.Substring(0, j);\\n                    if (j > 1 && leftLeft[0] == \\'0\\')\\n                    {\\n                        continue;\\n                    }\\n                    var leftRight = left.Substring(j, left.Length - j);\\n\\n                    if (leftRight.Length > 1 && leftRight[leftRight.Length - 1] == \\'0\\')\\n                    {\\n                        continue;\\n                    }\\n\\n\\n                    var cand = $\"{leftLeft}.{leftRight}\";\\n                    if (int.Parse(leftRight) == 0)\\n                    {\\n                        continue;\\n                    }\\n                    lefts.Add(cand);\\n                }\\n\\n\\n                for (int j = 1; j < right.Length; j++)\\n                {\\n                    var rightLeft = right.Substring(0, j);\\n                    if (j > 1 && rightLeft[0] == \\'0\\')\\n                    {\\n                        continue;\\n                    }\\n                    var rightRight = right.Substring(j, right.Length - j);\\n\\n                    if (rightRight.Length > 1 && rightRight[rightRight.Length - 1] == \\'0\\')\\n                    {\\n                        continue;\\n                    }\\n\\n                    var cand = $\"{rightLeft}.{rightRight}\";\\n                    if (int.Parse(rightRight) == 0)\\n                    {\\n                        continue;\\n                    }\\n                    rights.Add(cand);\\n                }\\n\\n                foreach (var l in lefts)\\n                {\\n                    foreach (var r in rights)\\n                    {\\n                        res.Add($\"({l}, {r})\");\\n                    }\\n                }\\n\\n            }\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327572,
                "title": "java-super-clear-solution",
                "content": "```\\nclass Solution {\\n    private List<String> sub(String s) {\\n        if (s.length() == 1) return Collections.singletonList(s);\\n\\n        List<String> ans = new ArrayList<>();\\n        if (s.charAt(0) != \\'0\\') {\\n            ans.add(s);\\n            for (int i = 1; i < s.length() && !s.endsWith(\"0\"); i++) {\\n                ans.add(s.substring(0, i) + \".\" + s.substring(i));\\n            }\\n        } else if (!s.endsWith(\"0\")) {\\n            ans.add(s.substring(0, 1) + \".\" + s.substring(1));\\n        }\\n\\n        return ans;\\n    }\\n\\n    public List<String> ambiguousCoordinates(String S) {\\n        List<String> ans = new ArrayList<>();\\n        List<String> left;\\n        List<String> right;\\n\\n        for (int i = 2; i < S.length() - 1; i++) {\\n            left = sub(S.substring(1, i));\\n            right = sub(S.substring(i, S.length() - 1));\\n\\n            if (!left.isEmpty() && !right.isEmpty()) {\\n                for (String l : left) {\\n                    for (String r : right) {\\n                        ans.add(\"(\" + l + \", \" + r + \")\");\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private List<String> sub(String s) {\\n        if (s.length() == 1) return Collections.singletonList(s);\\n\\n        List<String> ans = new ArrayList<>();\\n        if (s.charAt(0) != \\'0\\') {\\n            ans.add(s);\\n            for (int i = 1; i < s.length() && !s.endsWith(\"0\"); i++) {\\n                ans.add(s.substring(0, i) + \".\" + s.substring(i));\\n            }\\n        } else if (!s.endsWith(\"0\")) {\\n            ans.add(s.substring(0, 1) + \".\" + s.substring(1));\\n        }\\n\\n        return ans;\\n    }\\n\\n    public List<String> ambiguousCoordinates(String S) {\\n        List<String> ans = new ArrayList<>();\\n        List<String> left;\\n        List<String> right;\\n\\n        for (int i = 2; i < S.length() - 1; i++) {\\n            left = sub(S.substring(1, i));\\n            right = sub(S.substring(i, S.length() - 1));\\n\\n            if (!left.isEmpty() && !right.isEmpty()) {\\n                for (String l : left) {\\n                    for (String r : right) {\\n                        ans.add(\"(\" + l + \", \" + r + \")\");\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477750,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        string cur1 = \"\";\\n        string cur2 = \"\";\\n        vector<string> res;\\n        bool confirmedFirstPart = false;\\n        bool usedDot = false;\\n        backtrack(s, cur1, cur2, res, 0, confirmedFirstPart, usedDot);\\n        return res;\\n    }\\n    void backtrack(string& s, string& cur1, string& cur2, vector<string>& res, int index, bool& confirmedFirstPart, bool& usedDot)\\n    {\\n        if (index == s.length())\\n        {\\n            if (confirmedFirstPart == true)\\n            {\\n                if (cur2.size() != 2 && (cur2[cur2.size() - 2] == \\'0\\') && (cur2[0] == \\'0\\')) return;\\n                res.push_back(cur1 + cur2);\\n            }\\n            return;\\n        }\\n        if (s[index] != \\'(\\' && s[index] != \\')\\')\\n        {\\n            if (usedDot == false && index != s.length() - 2)\\n            {\\n                if (!confirmedFirstPart)\\n                {\\n                    cur1.push_back(s[index]);\\n                    cur1.push_back(\\'.\\');\\n                    usedDot = true;\\n                    backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                    cur1.pop_back();\\n                    cur1.pop_back();\\n                    usedDot = false;\\n                }\\n                else\\n                {\\n                    cur2.push_back(s[index]);\\n                    cur2.push_back(\\'.\\');\\n                    usedDot = true;\\n                    backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                    cur2.pop_back();\\n                    cur2.pop_back();\\n                    usedDot = false;\\n                }\\n            }\\n            if (confirmedFirstPart == false && index != s.length() - 2)\\n            {\\n                if (!(usedDot == true && s[index] == \\'0\\'))\\n                {\\n                    cur1.push_back(s[index]);\\n                    cur1.push_back(\\',\\');\\n                    cur1.push_back(\\' \\');\\n                    confirmedFirstPart = true;\\n                    bool usedDotCopy = usedDot;\\n                    usedDot = false;\\n                    backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                    cur1.pop_back();\\n                    cur1.pop_back();\\n                    cur1.pop_back();\\n                    confirmedFirstPart = false;\\n                    usedDot = usedDotCopy;\\n                }\\n            }\\n            if (!confirmedFirstPart) \\n            {\\n                if (!(cur1.size() == 1 && s[index] == \\'0\\'))\\n                {\\n                    cur1.push_back(s[index]);\\n                    backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                    cur1.pop_back();\\n                }\\n            }\\n            else\\n            {\\n                if (!(cur2.empty() && index != s.length() - 2 && s[index] == \\'0\\') && \\n                    !(usedDot && index == s.length() - 2 && s[index] == \\'0\\'))\\n                {\\n                    cur2.push_back(s[index]);\\n                    backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                    cur2.pop_back();\\n                }\\n            }\\n        }\\n        else\\n        {\\n            if (s[index] == \\'(\\')\\n            {\\n                cur1.push_back(\\'(\\');\\n                backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                cur1.pop_back();\\n            }\\n            else\\n            {\\n                cur2.push_back(\\')\\');\\n                backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                cur2.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def gen_nums(self, s):\\n        ans = []\\n        if s == \"0\" or s[0] != \"0\":\\n            ans.append(s)\\n        \\n        if s[-1] == \\'0\\':\\n            return ans\\n        \\n        if s[0] == \\'0\\':\\n            return ans + [\\'0.\\' + s[1:]]\\n\\n        for i in range(1, len(s)):\\n            ans.append(s[:i] + \\'.\\' + s[i:])\\n        return ans\\n\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        res = []\\n        for left_len in range(1, len(s)):\\n            l = self.gen_nums(s[:left_len])\\n            r = self.gen_nums(s[left_len:])\\n            for n1 in l:\\n                for n2 in r:\\n                    res.append(f\\'({n1}, {n2})\\')\\n                    \\n        return res\\n```\\n\\n```Java []\\nclass Solution {\\n    public List<String> helper (String s) {\\n        List<String> answer = new ArrayList<> ();\\n        if (s.length () == 1) {\\n            answer.add (s);\\n            return answer;\\n        }\\n        else if (s.charAt (0) == \\'0\\' && s.charAt (s.length () - 1) == \\'0\\') {\\n            return answer;\\n        }\\n        else if (s.charAt (0) == \\'0\\') {\\n            StringBuilder sb = new StringBuilder ();\\n            sb.append (s.charAt (0)).append (\".\").append (s.substring (1));\\n            answer.add (sb.toString ());\\n            return answer;\\n        }\\n        else if (s.charAt (s.length () - 1) == \\'0\\') {\\n            answer.add (s);\\n            return answer;\\n        }\\n        answer.add (s);\\n        for (int i = 1; i < s.length (); i++) {\\n            StringBuilder sb = new StringBuilder ();\\n            sb.append (s.substring (0, i)).append (\".\").append (s.substring (i));\\n            answer.add (sb.toString ());\\n        }\\n        return answer;\\n    }\\n    public List<String> ambiguousCoordinates(String s) {   \\n        List<String> answer = new ArrayList<> ();\\n        for (int i = 2; i < s.length () - 1; i++) {\\n            List<String> leftLists = helper (s.substring (1, i));\\n            List<String> rightLists = helper (s.substring (i, s.length () - 1));\\n            \\n            for (String leftString : leftLists) {\\n                for (String rightString : rightLists) {\\n                    StringBuilder sb = new StringBuilder ();\\n                    sb.append (\"(\").append (leftString).append (\", \").append (rightString).append (\")\");\\n                    answer.add (sb.toString ());\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        string cur1 = \"\";\\n        string cur2 = \"\";\\n        vector<string> res;\\n        bool confirmedFirstPart = false;\\n        bool usedDot = false;\\n        backtrack(s, cur1, cur2, res, 0, confirmedFirstPart, usedDot);\\n        return res;\\n    }\\n    void backtrack(string& s, string& cur1, string& cur2, vector<string>& res, int index, bool& confirmedFirstPart, bool& usedDot)\\n    {\\n        if (index == s.length())\\n        {\\n            if (confirmedFirstPart == true)\\n            {\\n                if (cur2.size() != 2 && (cur2[cur2.size() - 2] == \\'0\\') && (cur2[0] == \\'0\\')) return;\\n                res.push_back(cur1 + cur2);\\n            }\\n            return;\\n        }\\n        if (s[index] != \\'(\\' && s[index] != \\')\\')\\n        {\\n            if (usedDot == false && index != s.length() - 2)\\n            {\\n                if (!confirmedFirstPart)\\n                {\\n                    cur1.push_back(s[index]);\\n                    cur1.push_back(\\'.\\');\\n                    usedDot = true;\\n                    backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                    cur1.pop_back();\\n                    cur1.pop_back();\\n                    usedDot = false;\\n                }\\n                else\\n                {\\n                    cur2.push_back(s[index]);\\n                    cur2.push_back(\\'.\\');\\n                    usedDot = true;\\n                    backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                    cur2.pop_back();\\n                    cur2.pop_back();\\n                    usedDot = false;\\n                }\\n            }\\n            if (confirmedFirstPart == false && index != s.length() - 2)\\n            {\\n                if (!(usedDot == true && s[index] == \\'0\\'))\\n                {\\n                    cur1.push_back(s[index]);\\n                    cur1.push_back(\\',\\');\\n                    cur1.push_back(\\' \\');\\n                    confirmedFirstPart = true;\\n                    bool usedDotCopy = usedDot;\\n                    usedDot = false;\\n                    backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                    cur1.pop_back();\\n                    cur1.pop_back();\\n                    cur1.pop_back();\\n                    confirmedFirstPart = false;\\n                    usedDot = usedDotCopy;\\n                }\\n            }\\n            if (!confirmedFirstPart) \\n            {\\n                if (!(cur1.size() == 1 && s[index] == \\'0\\'))\\n                {\\n                    cur1.push_back(s[index]);\\n                    backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                    cur1.pop_back();\\n                }\\n            }\\n            else\\n            {\\n                if (!(cur2.empty() && index != s.length() - 2 && s[index] == \\'0\\') && \\n                    !(usedDot && index == s.length() - 2 && s[index] == \\'0\\'))\\n                {\\n                    cur2.push_back(s[index]);\\n                    backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                    cur2.pop_back();\\n                }\\n            }\\n        }\\n        else\\n        {\\n            if (s[index] == \\'(\\')\\n            {\\n                cur1.push_back(\\'(\\');\\n                backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                cur1.pop_back();\\n            }\\n            else\\n            {\\n                cur2.push_back(\\')\\');\\n                backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                cur2.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def gen_nums(self, s):\\n        ans = []\\n        if s == \"0\" or s[0] != \"0\":\\n            ans.append(s)\\n        \\n        if s[-1] == \\'0\\':\\n            return ans\\n        \\n        if s[0] == \\'0\\':\\n            return ans + [\\'0.\\' + s[1:]]\\n\\n        for i in range(1, len(s)):\\n            ans.append(s[:i] + \\'.\\' + s[i:])\\n        return ans\\n\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        res = []\\n        for left_len in range(1, len(s)):\\n            l = self.gen_nums(s[:left_len])\\n            r = self.gen_nums(s[left_len:])\\n            for n1 in l:\\n                for n2 in r:\\n                    res.append(f\\'({n1}, {n2})\\')\\n                    \\n        return res\\n```\n```Java []\\nclass Solution {\\n    public List<String> helper (String s) {\\n        List<String> answer = new ArrayList<> ();\\n        if (s.length () == 1) {\\n            answer.add (s);\\n            return answer;\\n        }\\n        else if (s.charAt (0) == \\'0\\' && s.charAt (s.length () - 1) == \\'0\\') {\\n            return answer;\\n        }\\n        else if (s.charAt (0) == \\'0\\') {\\n            StringBuilder sb = new StringBuilder ();\\n            sb.append (s.charAt (0)).append (\".\").append (s.substring (1));\\n            answer.add (sb.toString ());\\n            return answer;\\n        }\\n        else if (s.charAt (s.length () - 1) == \\'0\\') {\\n            answer.add (s);\\n            return answer;\\n        }\\n        answer.add (s);\\n        for (int i = 1; i < s.length (); i++) {\\n            StringBuilder sb = new StringBuilder ();\\n            sb.append (s.substring (0, i)).append (\".\").append (s.substring (i));\\n            answer.add (sb.toString ());\\n        }\\n        return answer;\\n    }\\n    public List<String> ambiguousCoordinates(String s) {   \\n        List<String> answer = new ArrayList<> ();\\n        for (int i = 2; i < s.length () - 1; i++) {\\n            List<String> leftLists = helper (s.substring (1, i));\\n            List<String> rightLists = helper (s.substring (i, s.length () - 1));\\n            \\n            for (String leftString : leftLists) {\\n                for (String rightString : rightLists) {\\n                    StringBuilder sb = new StringBuilder ();\\n                    sb.append (\"(\").append (leftString).append (\", \").append (rightString).append (\")\");\\n                    answer.add (sb.toString ());\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637129,
                "title": "c-easy-solution",
                "content": "\\tpublic class Solution\\n\\t{\\n\\t\\tList<string> ans;\\n\\t\\tpublic IList<string> AmbiguousCoordinates(string s)\\n\\t\\t{\\n\\t\\t\\tans = new List<string>();\\n\\t\\t\\tSolve(s, new List<string>(), 1);\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tprivate void Solve(string s, List<string> str, int idx)\\n\\t\\t{\\n\\t\\t\\tif(str.Count >= 2)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (IsValid(str, s.Length - 2))\\n\\t\\t\\t\\t\\tans.Add(\\'(\\' + str[0] + \", \" + str[1] + \\')\\');\\n\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i = idx; i < s.Length - 1; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstr.Add(s.Substring(idx, i - idx + 1));\\n\\t\\t\\t\\tSolve(s, str, i + 1);\\n\\t\\t\\t\\tstr.RemoveAt(str.Count - 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i = idx; i < s.Length - 1; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring temp = s.Substring(idx, i - idx + 1) + \\'.\\';\\n\\t\\t\\t\\tfor(int j = i + 1; j < s.Length - 1; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstr.Add(temp + s.Substring(i + 1, j - i));\\n\\t\\t\\t\\t\\tSolve(s, str, j + 1);\\n\\t\\t\\t\\t\\tstr.RemoveAt(str.Count - 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate bool IsValid(List<string> str, int stringLength)\\n\\t\\t{\\n\\t\\t\\treturn !string.IsNullOrWhiteSpace(str[0]) &&\\n\\t\\t\\t\\t!string.IsNullOrWhiteSpace(str[1]) &&\\n\\t\\t\\t\\t(str[0][0] != \\'0\\' || str[0].Length == 1 || str[0][1] == \\'.\\') &&\\n\\t\\t\\t\\t(str[1][0] != \\'0\\' || str[1].Length == 1 || str[1][1] == \\'.\\') &&\\n\\t\\t\\t\\t(!str[0].Contains(\\'.\\') || str[0][^1] != \\'0\\') &&\\n\\t\\t\\t\\t(!str[1].Contains(\\'.\\') || str[1][^1] != \\'0\\') &&\\n\\t\\t\\t\\t(str[0].Replace(\".\", string.Empty).Length + str[1].Replace(\".\", string.Empty).Length >= stringLength);\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution\\n\\t{\\n\\t\\tList<string> ans;\\n\\t\\tpublic IList<string> AmbiguousCoordinates(string s)\\n\\t\\t{\\n\\t\\t\\tans = new List<string>();\\n\\t\\t\\tSolve(s, new List<string>(), 1);\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1427481,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int len;\\n    vector<string>ans;\\n    string helper(string s,int k){\\n        if(s.size() == 1) return s;\\n        if(k>=2){\\n            if(s[0] == \\'0\\') return \"-1\";\\n        }\\n        if(s[s.size()-1] == \\'0\\'){\\n            if(k != s.size()) return \"-1\";\\n        }\\n        if(k == s.size()) return s;\\n        string res = s.substr(0,k)+\".\"+s.substr(k);\\n        return res;\\n    }\\n    void backtrack(string s,int pos,string prev){\\n        if(prev.size()>0){\\n            for(int i = 1;i<=len-pos;i++){\\n                string t = helper(s.substr(pos),i);\\n                if(t == \"-1\") continue;\\n                else ans.push_back(\"(\"+prev+\", \"+t+\")\");\\n            }\\n            return;\\n        }\\n        else{\\n            for(int i = 1;i<len;i++){\\n                string temp = s.substr(0,i);\\n                for(int j = 1;j<=i;j++){\\n                    string t = helper(temp,j);\\n                    if(t == \"-1\") continue;\\n                    backtrack(s,i,t);\\n                }\\n            }\\n        }\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1,s.size()-2);\\n        len = s.size();\\n        backtrack(s,0,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int len;\\n    vector<string>ans;\\n    string helper(string s,int k){\\n        if(s.size() == 1) return s;\\n        if(k>=2){\\n            if(s[0] == \\'0\\') return \"-1\";\\n        }\\n        if(s[s.size()-1] == \\'0\\'){\\n            if(k != s.size()) return \"-1\";\\n        }\\n        if(k == s.size()) return s;\\n        string res = s.substr(0,k)+\".\"+s.substr(k);\\n        return res;\\n    }\\n    void backtrack(string s,int pos,string prev){\\n        if(prev.size()>0){\\n            for(int i = 1;i<=len-pos;i++){\\n                string t = helper(s.substr(pos),i);\\n                if(t == \"-1\") continue;\\n                else ans.push_back(\"(\"+prev+\", \"+t+\")\");\\n            }\\n            return;\\n        }\\n        else{\\n            for(int i = 1;i<len;i++){\\n                string temp = s.substr(0,i);\\n                for(int j = 1;j<=i;j++){\\n                    string t = helper(temp,j);\\n                    if(t == \"-1\") continue;\\n                    backtrack(s,i,t);\\n                }\\n            }\\n        }\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1,s.size()-2);\\n        len = s.size();\\n        backtrack(s,0,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250312,
                "title": "c-solution-with-explanation",
                "content": "```\\n    /*\\n     * input: \"(123)\"\\n     * First we will assign commas\\n     *               123\\n     *                |\\n     *            ----------\\n     *           |          |\\n     *         1, 23       12, 3\\n     *\\n     * Now we have 2 pairs after putting comma. Now try tp put the \\n     * decimal point\\n     *\\n     *         1, 2.3       1.2, 3\\n     * So there are total 4 combinations (1, 23), (1, 2.3), (12, 3), (1.2, 3)\\n     * While applying decimal point, we need to exclude the nos that are \"00\"\\n     * \"0.0\", \"0.00\", \"1.0\", \"001\", \"00.01\", \".1\"\\n    */\\n\\n    //Function that will generate all nos (including decimal)\\n    void generateNumbers(string s, vector<string>& out) {\\n        // If the string has only one character then there won\\'t be any\\n        // decimal point, so pushing the num and returning\\n        if (s.length() == 1) {\\n            out.push_back(s);\\n            return;\\n        }\\n        \\n        // Check if the first char is zero or not\\n        if (s[0] != \\'0\\') {\\n            // The first char is not zero, so we have a valid number and one\\n            // combination, push it to res\\n            // Eg: s = 12 for input 123, then 12 is one combination of input.\\n            out.push_back(s);\\n        }\\n        else {\\n            // First char is zero, check if the last char is zero, if so the\\n            // number had extraneous zeros which is not valid. If last char is\\n            // not zero then we add a decimal point after the first char and\\n            // return from the function\\n            // Eg: s = \"01230\" return empty vecctor\\n            //     s = \"01234\" return 0.1234\\n            if (s.back() != \\'0\\') {\\n                out.push_back(\"0.\" + s.substr(1));\\n            }\\n            \\n            return;\\n        }\\n\\n        // Check if the last char is 0, if so return\\n        // Eg: s = \"10\" skip as 1.0 not allowed\\n        if (s.back() == \\'0\\') {\\n            return;\\n        }\\n        \\n        // Now that we have valid numbers, loop all characters and find the\\n        // decimal combinations.\\n        for (int i = 1; i < s.length(); i++) {\\n            out.push_back(s.substr(0, i) + \".\" + s.substr(i));\\n        }\\n        \\n        return;\\n    }\\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        // Generate a string by excluding open and close\\n        // brackets\\n        string s2 = s.substr(1, s.length() - 2);\\n        \\n        // Variable to store the length of input\\n        int n = s2.length();\\n        \\n        // Vector to store result\\n        vector<string> res;\\n        // Left and right vectors are for storing the number combinations for\\n        // left and right values\\n        vector<string> left;\\n        vector<string> right;\\n        \\n        // Traverse each char in string starting from 1 as we need\\n        // at least one char\\n        for (int i = 1; i < n; i++) {\\n            // Generate the left half and right half ie.., if input is 123\\n            // below logic will generate it as 1 and 23\\n            // Send it to generate numbers function to get the decimal nos\\n            // out of it\\n            generateNumbers(s2.substr(0, i), left);            \\n            generateNumbers(s2.substr(i), right);\\n            \\n            // Now that we have all combinations for this number, put it in\\n            // result by adding space between nos and open and close brackets\\n            for (string& lnum : left) {\\n                for (string& rnum : right) {\\n                    res.push_back(\"(\" + lnum + \", \" + rnum + \")\");\\n                }\\n            }\\n            // Clear the vectors for the next set of generated nums\\n            left.clear();\\n            right.clear();\\n        }\\n        \\n        // return the result\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n     * input: \"(123)\"\\n     * First we will assign commas\\n     *               123\\n     *                |\\n     *            ----------\\n     *           |          |\\n     *         1, 23       12, 3\\n     *\\n     * Now we have 2 pairs after putting comma. Now try tp put the \\n     * decimal point\\n     *\\n     *         1, 2.3       1.2, 3\\n     * So there are total 4 combinations (1, 23), (1, 2.3), (12, 3), (1.2, 3)\\n     * While applying decimal point, we need to exclude the nos that are \"00\"\\n     * \"0.0\", \"0.00\", \"1.0\", \"001\", \"00.01\", \".1\"\\n    */\\n\\n    //Function that will generate all nos (including decimal)\\n    void generateNumbers(string s, vector<string>& out) {\\n        // If the string has only one character then there won\\'t be any\\n        // decimal point, so pushing the num and returning\\n        if (s.length() == 1) {\\n            out.push_back(s);\\n            return;\\n        }\\n        \\n        // Check if the first char is zero or not\\n        if (s[0] != \\'0\\') {\\n            // The first char is not zero, so we have a valid number and one\\n            // combination, push it to res\\n            // Eg: s = 12 for input 123, then 12 is one combination of input.\\n            out.push_back(s);\\n        }\\n        else {\\n            // First char is zero, check if the last char is zero, if so the\\n            // number had extraneous zeros which is not valid. If last char is\\n            // not zero then we add a decimal point after the first char and\\n            // return from the function\\n            // Eg: s = \"01230\" return empty vecctor\\n            //     s = \"01234\" return 0.1234\\n            if (s.back() != \\'0\\') {\\n                out.push_back(\"0.\" + s.substr(1));\\n            }\\n            \\n            return;\\n        }\\n\\n        // Check if the last char is 0, if so return\\n        // Eg: s = \"10\" skip as 1.0 not allowed\\n        if (s.back() == \\'0\\') {\\n            return;\\n        }\\n        \\n        // Now that we have valid numbers, loop all characters and find the\\n        // decimal combinations.\\n        for (int i = 1; i < s.length(); i++) {\\n            out.push_back(s.substr(0, i) + \".\" + s.substr(i));\\n        }\\n        \\n        return;\\n    }\\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        // Generate a string by excluding open and close\\n        // brackets\\n        string s2 = s.substr(1, s.length() - 2);\\n        \\n        // Variable to store the length of input\\n        int n = s2.length();\\n        \\n        // Vector to store result\\n        vector<string> res;\\n        // Left and right vectors are for storing the number combinations for\\n        // left and right values\\n        vector<string> left;\\n        vector<string> right;\\n        \\n        // Traverse each char in string starting from 1 as we need\\n        // at least one char\\n        for (int i = 1; i < n; i++) {\\n            // Generate the left half and right half ie.., if input is 123\\n            // below logic will generate it as 1 and 23\\n            // Send it to generate numbers function to get the decimal nos\\n            // out of it\\n            generateNumbers(s2.substr(0, i), left);            \\n            generateNumbers(s2.substr(i), right);\\n            \\n            // Now that we have all combinations for this number, put it in\\n            // result by adding space between nos and open and close brackets\\n            for (string& lnum : left) {\\n                for (string& rnum : right) {\\n                    res.push_back(\"(\" + lnum + \", \" + rnum + \")\");\\n                }\\n            }\\n            // Clear the vectors for the next set of generated nums\\n            left.clear();\\n            right.clear();\\n        }\\n        \\n        // return the result\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1249467,
                "title": "bhayank-code-h-bhai-c",
                "content": "```c++\\nclass Solution {\\npublic:\\n    bool valpre(string &s){\\n        if(s.size()==1) return true;\\n        if(s[0]==\\'0\\') return false;\\n        return true;\\n    }\\n    bool valsuff(string &s){\\n        if(s[s.size()-1]==\\'0\\') return false;\\n        return true;\\n    }\\n    bool isvalid(string &s){\\n        if(s.size()==1) return true;\\n        int i = 0;\\n        string pre = \"\";\\n        string suff = \"\";\\n        while(i<s.size()&&s[i]!=\\'.\\'){\\n            pre+=s[i];\\n            i++;\\n        }\\n        if(i==s.size()){\\n            if(s[0]==\\'0\\') return false;\\n            return true;\\n        }\\n        suff = s.substr(i,s.size());\\n        return valpre(pre)&&valsuff(suff);\\n        \\n    }\\n    vector<string>make_coordinate(string &s){\\n        vector<string>res;\\n        res.push_back(s);\\n        if(s.size()==1) return res;\\n        string prefix = \"\";\\n        string suffix = \"\";\\n        for(int i = 0;i<s.size()-1;i++){\\n            prefix+=s[i];\\n            suffix = s.substr(i+1,s.size());\\n            if(suffix.size()==0){\\n                res.push_back(prefix);\\n                continue;\\n            }\\n            string curr = \"\";\\n            curr+=prefix;\\n            curr+=\\'.\\';\\n            curr+=suffix;\\n            res.push_back(curr);\\n        }\\n        return res;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        s.erase(s.begin());\\n        s.erase(--s.end());\\n        string prefix = \"\";\\n        string suffix;\\n        vector<string>ans;\\n        string temp = \"01\";\\n        for(int i = 0;i<s.size()-1;i++){\\n            prefix+=s[i];\\n            suffix = s.substr(i+1,s.size());\\n            vector<string>leftcord = make_coordinate(prefix);\\n            vector<string>rightcord = make_coordinate(suffix);\\n            for(auto &s1 : leftcord){\\n                for(auto &s2 : rightcord){\\n                    if(isvalid(s1)==false||isvalid(s2)==false) continue;\\n                    string curr = \"(\";\\n                    curr+=s1;\\n                    curr+=\", \";\\n                    curr+=s2;\\n                    curr+=\\')\\';\\n                    ans.push_back(curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool valpre(string &s){\\n        if(s.size()==1) return true;\\n        if(s[0]==\\'0\\') return false;\\n        return true;\\n    }\\n    bool valsuff(string &s){\\n        if(s[s.size()-1]==\\'0\\') return false;\\n        return true;\\n    }\\n    bool isvalid(string &s){\\n        if(s.size()==1) return true;\\n        int i = 0;\\n        string pre = \"\";\\n        string suff = \"\";\\n        while(i<s.size()&&s[i]!=\\'.\\'){\\n            pre+=s[i];\\n            i++;\\n        }\\n        if(i==s.size()){\\n            if(s[0]==\\'0\\') return false;\\n            return true;\\n        }\\n        suff = s.substr(i,s.size());\\n        return valpre(pre)&&valsuff(suff);\\n        \\n    }\\n    vector<string>make_coordinate(string &s){\\n        vector<string>res;\\n        res.push_back(s);\\n        if(s.size()==1) return res;\\n        string prefix = \"\";\\n        string suffix = \"\";\\n        for(int i = 0;i<s.size()-1;i++){\\n            prefix+=s[i];\\n            suffix = s.substr(i+1,s.size());\\n            if(suffix.size()==0){\\n                res.push_back(prefix);\\n                continue;\\n            }\\n            string curr = \"\";\\n            curr+=prefix;\\n            curr+=\\'.\\';\\n            curr+=suffix;\\n            res.push_back(curr);\\n        }\\n        return res;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        s.erase(s.begin());\\n        s.erase(--s.end());\\n        string prefix = \"\";\\n        string suffix;\\n        vector<string>ans;\\n        string temp = \"01\";\\n        for(int i = 0;i<s.size()-1;i++){\\n            prefix+=s[i];\\n            suffix = s.substr(i+1,s.size());\\n            vector<string>leftcord = make_coordinate(prefix);\\n            vector<string>rightcord = make_coordinate(suffix);\\n            for(auto &s1 : leftcord){\\n                for(auto &s2 : rightcord){\\n                    if(isvalid(s1)==false||isvalid(s2)==false) continue;\\n                    string curr = \"(\";\\n                    curr+=s1;\\n                    curr+=\", \";\\n                    curr+=s2;\\n                    curr+=\\')\\';\\n                    ans.push_back(curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208709,
                "title": "c-cartesian-product-faster-than-100",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool Prefix(string s)\\n    {\\n        int n=(int)s.length();\\n        if(n==1) return true;\\n        if(s[0]==\\'0\\') return false;\\n        return true;\\n    }\\n    bool Suffix(string s)\\n    {\\n        int n=(int)s.length();\\n        if(s[n-1]==\\'0\\') return false;\\n        return true;\\n    }\\n    vector<string> generate(string s)\\n    {\\n        vector<string> g;\\n        int n=(int)s.length();\\n        if(Prefix(s)) g.push_back(s);\\n        for(int i=1;i<n;i++)\\n        {\\n            string left=s.substr(0,i);\\n            string right=s.substr(i);\\n            if(Prefix(left)==true and Suffix(right)==true){\\n                g.push_back(left+\".\"+right);\\n            }\\n        }\\n        return g;\\n    }\\npublic:\\n    vector<string> ambiguousCoordinates(string str) {\\n        vector<string> sol;\\n        string s=str.substr(1,str.length()-2);\\n        int n=(int)s.length();\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            vector<string> left=generate(s.substr(0,i));\\n            vector<string> right=generate(s.substr(i));\\n            for(auto l:left)\\n            {\\n                for(auto r:right) sol.push_back(\"(\"+l+\", \"+r+\")\");\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool Prefix(string s)\\n    {\\n        int n=(int)s.length();\\n        if(n==1) return true;\\n        if(s[0]==\\'0\\') return false;\\n        return true;\\n    }\\n    bool Suffix(string s)\\n    {\\n        int n=(int)s.length();\\n        if(s[n-1]==\\'0\\') return false;\\n        return true;\\n    }\\n    vector<string> generate(string s)\\n    {\\n        vector<string> g;\\n        int n=(int)s.length();\\n        if(Prefix(s)) g.push_back(s);\\n        for(int i=1;i<n;i++)\\n        {\\n            string left=s.substr(0,i);\\n            string right=s.substr(i);\\n            if(Prefix(left)==true and Suffix(right)==true){\\n                g.push_back(left+\".\"+right);\\n            }\\n        }\\n        return g;\\n    }\\npublic:\\n    vector<string> ambiguousCoordinates(string str) {\\n        vector<string> sol;\\n        string s=str.substr(1,str.length()-2);\\n        int n=(int)s.length();\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            vector<string> left=generate(s.substr(0,i));\\n            vector<string> right=generate(s.substr(i));\\n            for(auto l:left)\\n            {\\n                for(auto r:right) sol.push_back(\"(\"+l+\", \"+r+\")\");\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207736,
                "title": "swift-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    func ambiguousCoordinates(_ s: String) -> [String] {\\n        var str = Array(s)\\n        str.removeFirst()\\n        str.removeLast()\\n        var ans: [String] = []\\n        var lefts: [String] = []\\n        var rights: [String] = []\\n        for i in 0..<str.count-1 {\\n            lefts = makeStrings(str, 0, i)\\n            rights = makeStrings(str, i+1, str.count-1)\\n            for left in lefts {\\n                for right in rights {\\n                    let temp = \"(\" + left + \", \" + right + \")\"\\n                    ans.append(temp)\\n                }\\n            }\\n        }\\n        return ans\\n    }\\n\\n    func makeStrings(_ s: [Character], _ i: Int, _ j: Int) -> [String] {\\n        var str = s[i...j]\\n        var result: [String] = []\\n        for idx in i...j { // Array.Slice is only a view of an original arran, so we use original index rather than 0..<str.count, which will cause index out of bounds error\\n            var left: [Character] = []\\n            var right: [Character] = []\\n            \\n            if idx == j { // reach the last index, do not need to split\\n                left.append(contentsOf: Array(str[i...j]))\\n                right = []\\n            } else {\\n                left = Array(str[i...idx])\\n                right = Array(str[idx+1...j])\\n            }\\n            if !(left.count > 1 && left.first! == \"0\") { // case like left =  \"01\" right = \"23\" we do not add dot\\n                if right.isEmpty {\\n                    result.append(String(left))\\n                } else {\\n                    var temp = left\\n                    temp.append(\".\")\\n                    temp.append(contentsOf: right)\\n                    if temp.last! != \"0\" { // case like \"1.0\" is not eligible\\n                        result.append(String(temp))\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func ambiguousCoordinates(_ s: String) -> [String] {\\n        var str = Array(s)\\n        str.removeFirst()\\n        str.removeLast()\\n        var ans: [String] = []\\n        var lefts: [String] = []\\n        var rights: [String] = []\\n        for i in 0..<str.count-1 {\\n            lefts = makeStrings(str, 0, i)\\n            rights = makeStrings(str, i+1, str.count-1)\\n            for left in lefts {\\n                for right in rights {\\n                    let temp = \"(\" + left + \", \" + right + \")\"\\n                    ans.append(temp)\\n                }\\n            }\\n        }\\n        return ans\\n    }\\n\\n    func makeStrings(_ s: [Character], _ i: Int, _ j: Int) -> [String] {\\n        var str = s[i...j]\\n        var result: [String] = []\\n        for idx in i...j { // Array.Slice is only a view of an original arran, so we use original index rather than 0..<str.count, which will cause index out of bounds error\\n            var left: [Character] = []\\n            var right: [Character] = []\\n            \\n            if idx == j { // reach the last index, do not need to split\\n                left.append(contentsOf: Array(str[i...j]))\\n                right = []\\n            } else {\\n                left = Array(str[i...idx])\\n                right = Array(str[idx+1...j])\\n            }\\n            if !(left.count > 1 && left.first! == \"0\") { // case like left =  \"01\" right = \"23\" we do not add dot\\n                if right.isEmpty {\\n                    result.append(String(left))\\n                } else {\\n                    var temp = left\\n                    temp.append(\".\")\\n                    temp.append(contentsOf: right)\\n                    if temp.last! != \"0\" { // case like \"1.0\" is not eligible\\n                        result.append(String(temp))\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207148,
                "title": "java-100-2ms-fast-simple-explanation",
                "content": "This code runs in 2ms or sometimes 3ms.\\n\\nThe execution speed comes from converting the original `String` to a `char[]` array, then do all the testing and building of any valid coordinate strings directly from the `char[]` array, without any slow substring creation.  The code works with comma and any decimal point positions that are indexes into the `char[]` array, without actually putting any comma character or decimal point character into the `char[]` array.  The index for the comma or any decimal point are the index of the character in the `char[]` array that they would appear before, but they are **never** inserted into the `char[]`.  The loops that provide the comma or decimal point indexes, *always* give valid positions.\\n\\nThe basic code structure it to try all possible comma positions.  For a comma position, check if the first number is a valid integer, and try all possible decimal point positions for the first number and check if the first number is a valid decimal point\\'ed number for that decimal point position.  For all valid first numbers, check if the second number would be a valid integer, or try all decimal point positions in the second number.  If two valid numbers are found, then call a method to build the valid coordinate string and add it to the result list.\\n\\nIf useful, please up-vote.\\n```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        char[] sc = s.toCharArray();\\n        List<String> result = new ArrayList();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        // Loop through all possible index positions for the comma.\\n        for (int commaPos = 2; commaPos < sc.length - 1; commaPos++) {\\n            \\n            // If first number if a valid integer without any decimal point.\\n            if (isValidNum(sc, 1, commaPos - 1)) {\\n                if (isValidNum(sc, commaPos, sc.length - 2))\\n                    buildNums(result, sb, sc, 1, commaPos-1, 0, commaPos, sc.length-2, 0);\\n                for (int dp2Idx = commaPos + 1; dp2Idx < sc.length - 1; dp2Idx++)\\n                    if (isValidDPNum(sc, commaPos, sc.length - 2, dp2Idx))\\n                        buildNums(result, sb, sc, 1, commaPos-1, 0, commaPos, sc.length-2, dp2Idx);\\n            }\\n            \\n            // Check all possible decimal point positions for the first number.\\n            for (int dp1Idx = 2; dp1Idx < commaPos; dp1Idx++) {\\n                if (isValidDPNum(sc, 1, commaPos - 1, dp1Idx)) {\\n                    if (isValidNum(sc, commaPos, sc.length - 2))\\n                        buildNums(result, sb, sc, 1, commaPos-1, dp1Idx, commaPos, sc.length-2, 0);\\n                    for (int dp2Idx = commaPos + 1; dp2Idx < sc.length - 1; dp2Idx++)\\n                        if (isValidDPNum(sc, commaPos, sc.length - 2, dp2Idx))\\n                            buildNums(result, sb, sc, 1, commaPos-1, dp1Idx, commaPos, sc.length-2, dp2Idx);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    \\n    // Check if a number in the char[] array is a valid integer without any decimal point.\\n    private boolean isValidNum(char[] sc, int startIdx, int lastIdx) {\\n        if (sc[startIdx] == \\'0\\' && lastIdx - startIdx != 0)  return false;\\n        return true;\\n    }\\n    \\n    \\n    // Check if a number in the char[] array is valid number with virtual decimal point at the specified index.\\n    private boolean isValidDPNum(char[] sc, int startIdx, int lastIdx, int dpIdx) {\\n        if ((sc[startIdx] == \\'0\\' && dpIdx - startIdx != 1) || sc[lastIdx] == \\'0\\')  return false;\\n        return true;\\n    }\\n    \\n    \\n    // Build the result two number coordinate string and add to the List of results.\\n    private void buildNums(List<String> result, StringBuilder sb, char[] sc, \\n                            int start1Idx, int last1Idx, int dp1Idx, \\n                            int start2Idx, int last2Idx, int dp2Idx) {\\n        sb.setLength(0);\\n        sb.append(\\'(\\');\\n        if (dp1Idx == 0)\\n            sb.append(sc, start1Idx, last1Idx - start1Idx + 1);\\n        else\\n            sb.append(sc, start1Idx, dp1Idx - start1Idx).append(\\'.\\').append(sc, dp1Idx, last1Idx - dp1Idx + 1);\\n        sb.append(\\',\\').append(\\' \\');\\n        if (dp2Idx == 0)\\n            sb.append(sc, start2Idx, last2Idx - start2Idx + 1);\\n        else\\n            sb.append(sc, start2Idx, dp2Idx - start2Idx).append(\\'.\\').append(sc, dp2Idx, last2Idx - dp2Idx + 1);\\n        sb.append(\\')\\');\\n        result.add(sb.toString());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        char[] sc = s.toCharArray();\\n        List<String> result = new ArrayList();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        // Loop through all possible index positions for the comma.\\n        for (int commaPos = 2; commaPos < sc.length - 1; commaPos++) {\\n            \\n            // If first number if a valid integer without any decimal point.\\n            if (isValidNum(sc, 1, commaPos - 1)) {\\n                if (isValidNum(sc, commaPos, sc.length - 2))\\n                    buildNums(result, sb, sc, 1, commaPos-1, 0, commaPos, sc.length-2, 0);\\n                for (int dp2Idx = commaPos + 1; dp2Idx < sc.length - 1; dp2Idx++)\\n                    if (isValidDPNum(sc, commaPos, sc.length - 2, dp2Idx))\\n                        buildNums(result, sb, sc, 1, commaPos-1, 0, commaPos, sc.length-2, dp2Idx);\\n            }\\n            \\n            // Check all possible decimal point positions for the first number.\\n            for (int dp1Idx = 2; dp1Idx < commaPos; dp1Idx++) {\\n                if (isValidDPNum(sc, 1, commaPos - 1, dp1Idx)) {\\n                    if (isValidNum(sc, commaPos, sc.length - 2))\\n                        buildNums(result, sb, sc, 1, commaPos-1, dp1Idx, commaPos, sc.length-2, 0);\\n                    for (int dp2Idx = commaPos + 1; dp2Idx < sc.length - 1; dp2Idx++)\\n                        if (isValidDPNum(sc, commaPos, sc.length - 2, dp2Idx))\\n                            buildNums(result, sb, sc, 1, commaPos-1, dp1Idx, commaPos, sc.length-2, dp2Idx);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    \\n    // Check if a number in the char[] array is a valid integer without any decimal point.\\n    private boolean isValidNum(char[] sc, int startIdx, int lastIdx) {\\n        if (sc[startIdx] == \\'0\\' && lastIdx - startIdx != 0)  return false;\\n        return true;\\n    }\\n    \\n    \\n    // Check if a number in the char[] array is valid number with virtual decimal point at the specified index.\\n    private boolean isValidDPNum(char[] sc, int startIdx, int lastIdx, int dpIdx) {\\n        if ((sc[startIdx] == \\'0\\' && dpIdx - startIdx != 1) || sc[lastIdx] == \\'0\\')  return false;\\n        return true;\\n    }\\n    \\n    \\n    // Build the result two number coordinate string and add to the List of results.\\n    private void buildNums(List<String> result, StringBuilder sb, char[] sc, \\n                            int start1Idx, int last1Idx, int dp1Idx, \\n                            int start2Idx, int last2Idx, int dp2Idx) {\\n        sb.setLength(0);\\n        sb.append(\\'(\\');\\n        if (dp1Idx == 0)\\n            sb.append(sc, start1Idx, last1Idx - start1Idx + 1);\\n        else\\n            sb.append(sc, start1Idx, dp1Idx - start1Idx).append(\\'.\\').append(sc, dp1Idx, last1Idx - dp1Idx + 1);\\n        sb.append(\\',\\').append(\\' \\');\\n        if (dp2Idx == 0)\\n            sb.append(sc, start2Idx, last2Idx - start2Idx + 1);\\n        else\\n            sb.append(sc, start2Idx, dp2Idx - start2Idx).append(\\'.\\').append(sc, dp2Idx, last2Idx - dp2Idx + 1);\\n        sb.append(\\')\\');\\n        result.add(sb.toString());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206931,
                "title": "easy-clean-go-solution-beats-100",
                "content": "```\\nfunc ambiguousCoordinates(s string) []string {\\n\\tvar result []string\\n\\n\\tfor i := 2; i <= len(s)-2; i++ {\\n\\t\\tleft, right := s[1:i], s[i:len(s)-1]\\n\\n\\t\\tif isLegalPart(left) && isLegalPart(right) {\\n\\t\\t\\tleftPartitions, rightPartitions := getAllPartitions(left), getAllPartitions(right)\\n\\n\\t\\t\\tfor _, leftPartition := range leftPartitions {\\n\\t\\t\\t\\tfor _, rightPartition := range rightPartitions {\\n\\t\\t\\t\\t\\tresult = append(result, fmt.Sprintf(\"(%s, %s)\", leftPartition, rightPartition))\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc isLegalPart(s string) bool {\\n\\treturn len(s) == 1 || s[0] != \\'0\\' || s[len(s)-1] != \\'0\\'\\n}\\n\\nfunc getAllPartitions(s string) []string {\\n\\tswitch {\\n\\tcase len(s) == 1 || s[len(s)-1] == \\'0\\':\\n\\t\\treturn []string{s}\\n\\tcase s[0] == \\'0\\':\\n\\t\\treturn []string{fmt.Sprintf(\"0.%s\", s[1:])}\\n\\tdefault:\\n\\t\\tresult := make([]string, 1, len(s))\\n\\t\\tresult[0] = s\\n\\t\\tfor i := 1; i < len(s); i++ {\\n\\t\\t\\tresult = append(result, fmt.Sprintf(\"%s.%s\", s[:i], s[i:]))\\n\\t\\t}\\n\\t\\treturn result\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc ambiguousCoordinates(s string) []string {\\n\\tvar result []string\\n\\n\\tfor i := 2; i <= len(s)-2; i++ {\\n\\t\\tleft, right := s[1:i], s[i:len(s)-1]\\n\\n\\t\\tif isLegalPart(left) && isLegalPart(right) {\\n\\t\\t\\tleftPartitions, rightPartitions := getAllPartitions(left), getAllPartitions(right)\\n\\n\\t\\t\\tfor _, leftPartition := range leftPartitions {\\n\\t\\t\\t\\tfor _, rightPartition := range rightPartitions {\\n\\t\\t\\t\\t\\tresult = append(result, fmt.Sprintf(\"(%s, %s)\", leftPartition, rightPartition))\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc isLegalPart(s string) bool {\\n\\treturn len(s) == 1 || s[0] != \\'0\\' || s[len(s)-1] != \\'0\\'\\n}\\n\\nfunc getAllPartitions(s string) []string {\\n\\tswitch {\\n\\tcase len(s) == 1 || s[len(s)-1] == \\'0\\':\\n\\t\\treturn []string{s}\\n\\tcase s[0] == \\'0\\':\\n\\t\\treturn []string{fmt.Sprintf(\"0.%s\", s[1:])}\\n\\tdefault:\\n\\t\\tresult := make([]string, 1, len(s))\\n\\t\\tresult[0] = s\\n\\t\\tfor i := 1; i < len(s); i++ {\\n\\t\\t\\tresult = append(result, fmt.Sprintf(\"%s.%s\", s[:i], s[i:]))\\n\\t\\t}\\n\\t\\treturn result\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1206759,
                "title": "70-python",
                "content": "```\\nclass Solution:\\n    def putDecimal(self, num):\\n        ans = []\\n        if not int(num):\\n            if len(num) == 1:\\n                return [\\'0\\']\\n            else:\\n                return []\\n            \\n        if num.startswith(\\'0\\'):\\n            return [\\'0.\\' + num[1:]] if not num.endswith(\\'0\\') else []\\n        \\n        if num.endswith(\\'0\\'):\\n            return [num]\\n        \\n        for i in range(len(num) - 1):\\n            # [0, i + 1), [i + 1, ..)\\n            left, right = num[:i + 1], num[i + 1: ]\\n            if not int(right):\\n                break\\n            if not right.endswith(\\'0\\'):\\n                ans.append(left + \\'.\\' + right)\\n            \\n        return ans + [num] if not num.startswith(\\'0\\') else ans\\n    \\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1: -1]\\n        ans = set()\\n        for i in range(len(s) - 1):\\n            left, right = s[:i + 1], s[i + 1: ]\\n            leftDecimals = self.putDecimal(left)\\n            rightDecimals = self.putDecimal(right)\\n            \\n            if leftDecimals and rightDecimals:\\n                for leftDecimal in leftDecimals:\\n                    for rightDecimal in rightDecimals:\\n                        ans.add(\"(\" + leftDecimal + \", \" + rightDecimal + \")\")\\n        return ans\\n    # \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def putDecimal(self, num):\\n        ans = []\\n        if not int(num):\\n            if len(num) == 1:\\n                return [\\'0\\']\\n            else:\\n                return []\\n            \\n        if num.startswith(\\'0\\'):\\n            return [\\'0.\\' + num[1:]] if not num.endswith(\\'0\\') else []\\n        \\n        if num.endswith(\\'0\\'):\\n            return [num]\\n        \\n        for i in range(len(num) - 1):\\n            # [0, i + 1), [i + 1, ..)\\n            left, right = num[:i + 1], num[i + 1: ]\\n            if not int(right):\\n                break\\n            if not right.endswith(\\'0\\'):\\n                ans.append(left + \\'.\\' + right)\\n            \\n        return ans + [num] if not num.startswith(\\'0\\') else ans\\n    \\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1: -1]\\n        ans = set()\\n        for i in range(len(s) - 1):\\n            left, right = s[:i + 1], s[i + 1: ]\\n            leftDecimals = self.putDecimal(left)\\n            rightDecimals = self.putDecimal(right)\\n            \\n            if leftDecimals and rightDecimals:\\n                for leftDecimal in leftDecimals:\\n                    for rightDecimal in rightDecimals:\\n                        ans.add(\"(\" + leftDecimal + \", \" + rightDecimal + \")\")\\n        return ans\\n    # \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206598,
                "title": "c-solution-95-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.size();\\n        vector<string>ans;\\n        for(int i = 1; i < n-2; i++){\\n            vector<string>A = helper(s.substr(1, i));\\n            vector<string>B = helper(s.substr(i+1, n-2-i));\\n            for(auto &a : A)\\n                for(auto &b : B)\\n                    ans.push_back(\"(\" + a + \", \" + b + \")\");\\n        }\\n        return ans;\\n    }\\n    vector<string>helper(string s){\\n        int n = s.size();\\n        if(n == 0 || (n > 1 && s[0] == \\'0\\' && s[n-1] == \\'0\\')) return {};  //Null string or 0xxx0         \\n        if(n > 1 && s[0] == \\'0\\') return {\"0.\" + s.substr(1)};   //0xxx9\\n        if(n == 1 || s[n-1] == \\'0\\') return {s};   //single digit or 9xxx0\\n        \\n        //9xxx9\\n        vector<string>ans = {s};\\n        for(int i = 1; i < n; i++)\\n            ans.push_back(s.substr(0,i) + \\'.\\' + s.substr(i));\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.size();\\n        vector<string>ans;\\n        for(int i = 1; i < n-2; i++){\\n            vector<string>A = helper(s.substr(1, i));\\n            vector<string>B = helper(s.substr(i+1, n-2-i));\\n            for(auto &a : A)\\n                for(auto &b : B)\\n                    ans.push_back(\"(\" + a + \", \" + b + \")\");\\n        }\\n        return ans;\\n    }\\n    vector<string>helper(string s){\\n        int n = s.size();\\n        if(n == 0 || (n > 1 && s[0] == \\'0\\' && s[n-1] == \\'0\\')) return {};  //Null string or 0xxx0         \\n        if(n > 1 && s[0] == \\'0\\') return {\"0.\" + s.substr(1)};   //0xxx9\\n        if(n == 1 || s[n-1] == \\'0\\') return {s};   //single digit or 9xxx0\\n        \\n        //9xxx9\\n        vector<string>ans = {s};\\n        for(int i = 1; i < n; i++)\\n            ans.push_back(s.substr(0,i) + \\'.\\' + s.substr(i));\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206404,
                "title": "java-clean-and-fast-beats-100",
                "content": "The solution is self explanatory.\\n\\n```\\nclass Solution {\\n\\n    public List<String> ambiguousCoordinates(String digits) {\\n        List<String> answer = new ArrayList<>();\\n        char[] digitsArr = digits.toCharArray();\\n        int n = digitsArr.length;\\n\\n        for (int comaIdx = 2; comaIdx < n - 1; comaIdx++) {\\n            String left = new String(Arrays.copyOfRange(digitsArr, 1, comaIdx));\\n            String right = new String(Arrays.copyOfRange(digitsArr, comaIdx, n - 1));\\n\\n            List<String> leftWithPoint = addPoints(left);\\n            List<String> rightWithPoint = addPoints(right);\\n\\n            for (String leftFloat : leftWithPoint) {\\n                for (String rightFloat : rightWithPoint) {\\n                    answer.add(build(leftFloat, rightFloat, true));\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    private List<String> addPoints(String digits) {\\n\\n        List<String> answer = new ArrayList<>();\\n\\n        if (isValid(digits)) {\\n            answer.add(digits);\\n        }\\n\\n        char[] digitsArr = digits.toCharArray();\\n        int n = digitsArr.length;\\n\\n        for (int pointIdx = 1; pointIdx < n; pointIdx++) {\\n            String left = new String(Arrays.copyOfRange(digitsArr, 0, pointIdx));\\n            String right = new String(Arrays.copyOfRange(digitsArr, pointIdx, n));\\n            String floatNum = build(left, right, false);\\n\\n            if (isValid(floatNum)) {\\n                answer.add(floatNum);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    private String build(String left, String right, boolean comaSep) {\\n        StringBuilder builder = new StringBuilder();\\n\\n        if (comaSep) {\\n            builder.append(\"(\");\\n        }\\n\\n        builder.append(left);\\n\\n        if (comaSep) {\\n            builder.append(\", \");\\n        } else {\\n            builder.append(\".\");\\n        }\\n\\n        builder.append(right);\\n\\n        if (comaSep) {\\n            builder.append(\")\");\\n        }\\n\\n        return builder.toString();\\n    }\\n\\n    private boolean isValid(String value) {\\n        if (value.length() > 1 && value.charAt(1) != \\'.\\' && value.startsWith(\"0\")) {\\n            return false;\\n        }\\n\\n        if (value.contains(\".\") && value.endsWith(\"0\")) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public List<String> ambiguousCoordinates(String digits) {\\n        List<String> answer = new ArrayList<>();\\n        char[] digitsArr = digits.toCharArray();\\n        int n = digitsArr.length;\\n\\n        for (int comaIdx = 2; comaIdx < n - 1; comaIdx++) {\\n            String left = new String(Arrays.copyOfRange(digitsArr, 1, comaIdx));\\n            String right = new String(Arrays.copyOfRange(digitsArr, comaIdx, n - 1));\\n\\n            List<String> leftWithPoint = addPoints(left);\\n            List<String> rightWithPoint = addPoints(right);\\n\\n            for (String leftFloat : leftWithPoint) {\\n                for (String rightFloat : rightWithPoint) {\\n                    answer.add(build(leftFloat, rightFloat, true));\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    private List<String> addPoints(String digits) {\\n\\n        List<String> answer = new ArrayList<>();\\n\\n        if (isValid(digits)) {\\n            answer.add(digits);\\n        }\\n\\n        char[] digitsArr = digits.toCharArray();\\n        int n = digitsArr.length;\\n\\n        for (int pointIdx = 1; pointIdx < n; pointIdx++) {\\n            String left = new String(Arrays.copyOfRange(digitsArr, 0, pointIdx));\\n            String right = new String(Arrays.copyOfRange(digitsArr, pointIdx, n));\\n            String floatNum = build(left, right, false);\\n\\n            if (isValid(floatNum)) {\\n                answer.add(floatNum);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    private String build(String left, String right, boolean comaSep) {\\n        StringBuilder builder = new StringBuilder();\\n\\n        if (comaSep) {\\n            builder.append(\"(\");\\n        }\\n\\n        builder.append(left);\\n\\n        if (comaSep) {\\n            builder.append(\", \");\\n        } else {\\n            builder.append(\".\");\\n        }\\n\\n        builder.append(right);\\n\\n        if (comaSep) {\\n            builder.append(\")\");\\n        }\\n\\n        return builder.toString();\\n    }\\n\\n    private boolean isValid(String value) {\\n        if (value.length() > 1 && value.charAt(1) != \\'.\\' && value.startsWith(\"0\")) {\\n            return false;\\n        }\\n\\n        if (value.contains(\".\") && value.endsWith(\"0\")) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206236,
                "title": "816-the-long-answer",
                "content": "Not a simple one :)\\n\\nLong answer ahead :), with a lot of code duplication. Hopefully others can understand.\\n\\n    var ambiguousCoordinates = function (s) {\\n        let n = s.length;\\n\\n        // answer array\\n        let A = [];\\n\\n        // remove ( and ),   reduce length by 2\\n        s = s.slice(1, n - 1);\\n        n -= 2;\\n\\n        for (let i = 1; i < n; i++) {\\n            let left = s.slice(0, i);\\n            let right = s.slice(i);\\n\\n            // ---------- no decimals\\n\\n            if (\\n                (left.length >= 2 && left.startsWith(\"0\")) ||\\n                (right.length >= 2 && right.startsWith(\"0\"))\\n            ) {\\n            } else {\\n                A.push(\"(\" + left + \", \" + right + \")\");\\n            }\\n\\n            // ---------- left decimal\\n\\n            for (let j = 1; j < left.length; j++) {\\n                left1 = left.slice(0, j);\\n                left2 = left.slice(j);\\n                if (\\n                    (left1.length >= 2 && left1.startsWith(\"0\")) || //\\n                    (left2.length >= 2 && left2.endsWith(\"0\")) || //\\n                    +left2 === 0 || //\\n                    (right.length >= 2 && right.startsWith(\"0\"))\\n                ) {\\n                } else {\\n                    A.push(\"(\" + left1 + \".\" + left2 + \", \" + right + \")\");\\n                }\\n            }\\n\\n            // ---------- right decimal\\n\\n            for (let j = 1; j < right.length; j++) {\\n                right1 = right.slice(0, j);\\n                right2 = right.slice(j);\\n                if (\\n                    (right1.length >= 2 && right1.startsWith(\"0\")) || //\\n                    (right2.length >= 2 && right2.endsWith(\"0\")) || //\\n                    +right2 === 0 || //\\n                    (left.length >= 2 && left.startsWith(\"0\"))\\n                ) {\\n                } else {\\n                    A.push(\"(\" + left + \", \" + right1 + \".\" + right2 + \")\");\\n                }\\n            }\\n\\n            // ---------- left & right decimal\\n\\n            for (let j = 1; j < left.length; j++) {\\n                left1 = left.slice(0, j);\\n                left2 = left.slice(j);\\n                if (\\n                    (left1.length >= 2 && left1.startsWith(\"0\")) || //\\n                    (left2.length >= 2 && left2.endsWith(\"0\")) || //\\n                    +left2 === 0\\n                ) {\\n                } else {\\n                    for (let j = 1; j < right.length; j++) {\\n                        right1 = right.slice(0, j);\\n                        right2 = right.slice(j);\\n\\n                        if (\\n                            (right1.length >= 2 && right1.startsWith(\"0\")) || //\\n                            (right2.length >= 2 && right2.endsWith(\"0\")) || //\\n                            +right2 === 0\\n                        ) {\\n                        } else {\\n                            A.push(\"(\" + left1 + \".\" + left2 + \", \" + right1 + \".\" + right2 + \")\");\\n                        }\\n                    }\\n                }\\n            }\\n\\n            // ---------- right & left decimal\\n\\n            for (let j = 1; j < right.length; j++) {\\n                right1 = right.slice(0, j);\\n                right2 = right.slice(j);\\n                if (\\n                    (right1.length >= 2 && right1.startsWith(\"0\")) || //\\n                    (right2.length >= 2 && right2.endsWith(\"0\")) || //\\n                    +right2 === 0\\n                ) {\\n                } else {\\n                    for (let j = 1; j < left.length; j++) {\\n                        left1 = left.slice(0, j);\\n                        left2 = left.slice(j);\\n                        if (\\n                            (left1.length >= 2 && left1.startsWith(\"0\")) || //\\n                            (left2.length >= 2 && left2.endsWith(\"0\")) || //\\n                            +left2 === 0\\n                        ) {\\n                        } else {\\n                            A.push(\"(\" + left1 + \".\" + left2 + \", \" + right1 + \".\" + right2 + \")\");\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return [...new Set(A)];\\n    };\\n\\n----\\n\\nAfter merging loops into another ( `left` into `left & right`,  and   `right` into `right & left`)\\n\\n    var ambiguousCoordinates = function (s) {\\n        let n = s.length;\\n\\n        // answer array\\n        let A = [];\\n\\n        // remove ( and ),   reduce length by 2\\n        s = s.slice(1, n - 1);\\n        n -= 2;\\n\\n        for (let i = 1; i < n; i++) {\\n            let left = s.slice(0, i);\\n            let right = s.slice(i);\\n\\n            // ---------- no decimals\\n            if (\\n                (left.length >= 2 && left.startsWith(\"0\")) ||\\n                (right.length >= 2 && right.startsWith(\"0\"))\\n            ) {\\n            } else {\\n                A.push(\"(\" + left + \", \" + right + \")\");\\n            }\\n\\n            // left decimal, then  left & right decimal\\n            for (let j = 1; j < left.length; j++) {\\n                left1 = left.slice(0, j);\\n                left2 = left.slice(j);\\n                if (\\n                    (left1.length >= 2 && left1.startsWith(\"0\")) || //\\n                    (left2.length >= 2 && left2.endsWith(\"0\")) || //\\n                    +left2 === 0\\n                ) {\\n                    continue;\\n                }\\n\\n                // ---------- left decimal\\n                if (right.length >= 2 && right.startsWith(\"0\")) {\\n                } else {\\n                    A.push(\"(\" + left1 + \".\" + left2 + \", \" + right + \")\");\\n                }\\n\\n                // ---------- left & right decimal\\n                for (let j = 1; j < right.length; j++) {\\n                    right1 = right.slice(0, j);\\n                    right2 = right.slice(j);\\n                    if (\\n                        (right1.length >= 2 && right1.startsWith(\"0\")) || //\\n                        (right2.length >= 2 && right2.endsWith(\"0\")) || //\\n                        +right2 === 0\\n                    ) {\\n                        continue;\\n                    }\\n\\n                    A.push(\"(\" + left1 + \".\" + left2 + \", \" + right1 + \".\" + right2 + \")\"); //prettier-ignore\\n                }\\n            }\\n\\n            // right decimal, then  right & left decimal\\n            for (let j = 1; j < right.length; j++) {\\n                right1 = right.slice(0, j);\\n                right2 = right.slice(j);\\n                if (\\n                    (right1.length >= 2 && right1.startsWith(\"0\")) || //\\n                    (right2.length >= 2 && right2.endsWith(\"0\")) || //\\n                    +right2 === 0\\n                ) {\\n                    continue;\\n                }\\n\\n                // ---------- right decimal\\n                if (left.length >= 2 && left.startsWith(\"0\")) {\\n                } else {\\n                    A.push(\"(\" + left + \", \" + right1 + \".\" + right2 + \")\");\\n                }\\n\\n                // ---------- right & left decimal\\n                for (let j = 1; j < left.length; j++) {\\n                    left1 = left.slice(0, j);\\n                    left2 = left.slice(j);\\n                    if (\\n                        (left1.length >= 2 && left1.startsWith(\"0\")) || //\\n                        (left2.length >= 2 && left2.endsWith(\"0\")) || //\\n                        +left2 === 0\\n                    ) {\\n                        continue;\\n                    }\\n\\n                    A.push(\"(\" + left1 + \".\" + left2 + \", \" + right1 + \".\" + right2 + \")\"); //prettier-ignore\\n                }\\n            }\\n        }\\n\\n        return [...new Set(A)];\\n    };\\n\\n----\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Not a simple one :)\\n\\nLong answer ahead :), with a lot of code duplication. Hopefully others can understand.\\n\\n    var ambiguousCoordinates = function (s) {\\n        let n = s.length;\\n\\n        // answer array\\n        let A = [];\\n\\n        // remove ( and ),   reduce length by 2\\n        s = s.slice(1, n - 1);\\n        n -= 2;\\n\\n        for (let i = 1; i < n; i++) {\\n            let left = s.slice(0, i);\\n            let right = s.slice(i);\\n\\n            // ---------- no decimals\\n\\n            if (\\n                (left.length >= 2 && left.startsWith(\"0\")) ||\\n                (right.length >= 2 && right.startsWith(\"0\"))\\n            ) {\\n            } else {\\n                A.push(\"(\" + left + \", \" + right + \")\");\\n            }\\n\\n            // ---------- left decimal\\n\\n            for (let j = 1; j < left.length; j++) {\\n                left1 = left.slice(0, j);\\n                left2 = left.slice(j);\\n                if (\\n                    (left1.length >= 2 && left1.startsWith(\"0\")) || //\\n                    (left2.length >= 2 && left2.endsWith(\"0\")) || //\\n                    +left2 === 0 || //\\n                    (right.length >= 2 && right.startsWith(\"0\"))\\n                ) {\\n                } else {\\n                    A.push(\"(\" + left1 + \".\" + left2 + \", \" + right + \")\");\\n                }\\n            }\\n\\n            // ---------- right decimal\\n\\n            for (let j = 1; j < right.length; j++) {\\n                right1 = right.slice(0, j);\\n                right2 = right.slice(j);\\n                if (\\n                    (right1.length >= 2 && right1.startsWith(\"0\")) || //\\n                    (right2.length >= 2 && right2.endsWith(\"0\")) || //\\n                    +right2 === 0 || //\\n                    (left.length >= 2 && left.startsWith(\"0\"))\\n                ) {\\n                } else {\\n                    A.push(\"(\" + left + \", \" + right1 + \".\" + right2 + \")\");\\n                }\\n            }\\n\\n            // ---------- left & right decimal\\n\\n            for (let j = 1; j < left.length; j++) {\\n                left1 = left.slice(0, j);\\n                left2 = left.slice(j);\\n                if (\\n                    (left1.length >= 2 && left1.startsWith(\"0\")) || //\\n                    (left2.length >= 2 && left2.endsWith(\"0\")) || //\\n                    +left2 === 0\\n                ) {\\n                } else {\\n                    for (let j = 1; j < right.length; j++) {\\n                        right1 = right.slice(0, j);\\n                        right2 = right.slice(j);\\n\\n                        if (\\n                            (right1.length >= 2 && right1.startsWith(\"0\")) || //\\n                            (right2.length >= 2 && right2.endsWith(\"0\")) || //\\n                            +right2 === 0\\n                        ) {\\n                        } else {\\n                            A.push(\"(\" + left1 + \".\" + left2 + \", \" + right1 + \".\" + right2 + \")\");\\n                        }\\n                    }\\n                }\\n            }\\n\\n            // ---------- right & left decimal\\n\\n            for (let j = 1; j < right.length; j++) {\\n                right1 = right.slice(0, j);\\n                right2 = right.slice(j);\\n                if (\\n                    (right1.length >= 2 && right1.startsWith(\"0\")) || //\\n                    (right2.length >= 2 && right2.endsWith(\"0\")) || //\\n                    +right2 === 0\\n                ) {\\n                } else {\\n                    for (let j = 1; j < left.length; j++) {\\n                        left1 = left.slice(0, j);\\n                        left2 = left.slice(j);\\n                        if (\\n                            (left1.length >= 2 && left1.startsWith(\"0\")) || //\\n                            (left2.length >= 2 && left2.endsWith(\"0\")) || //\\n                            +left2 === 0\\n                        ) {\\n                        } else {\\n                            A.push(\"(\" + left1 + \".\" + left2 + \", \" + right1 + \".\" + right2 + \")\");\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return [...new Set(A)];\\n    };\\n\\n----\\n\\nAfter merging loops into another ( `left` into `left & right`,  and   `right` into `right & left`)\\n\\n    var ambiguousCoordinates = function (s) {\\n        let n = s.length;\\n\\n        // answer array\\n        let A = [];\\n\\n        // remove ( and ),   reduce length by 2\\n        s = s.slice(1, n - 1);\\n        n -= 2;\\n\\n        for (let i = 1; i < n; i++) {\\n            let left = s.slice(0, i);\\n            let right = s.slice(i);\\n\\n            // ---------- no decimals\\n            if (\\n                (left.length >= 2 && left.startsWith(\"0\")) ||\\n                (right.length >= 2 && right.startsWith(\"0\"))\\n            ) {\\n            } else {\\n                A.push(\"(\" + left + \", \" + right + \")\");\\n            }\\n\\n            // left decimal, then  left & right decimal\\n            for (let j = 1; j < left.length; j++) {\\n                left1 = left.slice(0, j);\\n                left2 = left.slice(j);\\n                if (\\n                    (left1.length >= 2 && left1.startsWith(\"0\")) || //\\n                    (left2.length >= 2 && left2.endsWith(\"0\")) || //\\n                    +left2 === 0\\n                ) {\\n                    continue;\\n                }\\n\\n                // ---------- left decimal\\n                if (right.length >= 2 && right.startsWith(\"0\")) {\\n                } else {\\n                    A.push(\"(\" + left1 + \".\" + left2 + \", \" + right + \")\");\\n                }\\n\\n                // ---------- left & right decimal\\n                for (let j = 1; j < right.length; j++) {\\n                    right1 = right.slice(0, j);\\n                    right2 = right.slice(j);\\n                    if (\\n                        (right1.length >= 2 && right1.startsWith(\"0\")) || //\\n                        (right2.length >= 2 && right2.endsWith(\"0\")) || //\\n                        +right2 === 0\\n                    ) {\\n                        continue;\\n                    }\\n\\n                    A.push(\"(\" + left1 + \".\" + left2 + \", \" + right1 + \".\" + right2 + \")\"); //prettier-ignore\\n                }\\n            }\\n\\n            // right decimal, then  right & left decimal\\n            for (let j = 1; j < right.length; j++) {\\n                right1 = right.slice(0, j);\\n                right2 = right.slice(j);\\n                if (\\n                    (right1.length >= 2 && right1.startsWith(\"0\")) || //\\n                    (right2.length >= 2 && right2.endsWith(\"0\")) || //\\n                    +right2 === 0\\n                ) {\\n                    continue;\\n                }\\n\\n                // ---------- right decimal\\n                if (left.length >= 2 && left.startsWith(\"0\")) {\\n                } else {\\n                    A.push(\"(\" + left + \", \" + right1 + \".\" + right2 + \")\");\\n                }\\n\\n                // ---------- right & left decimal\\n                for (let j = 1; j < left.length; j++) {\\n                    left1 = left.slice(0, j);\\n                    left2 = left.slice(j);\\n                    if (\\n                        (left1.length >= 2 && left1.startsWith(\"0\")) || //\\n                        (left2.length >= 2 && left2.endsWith(\"0\")) || //\\n                        +left2 === 0\\n                    ) {\\n                        continue;\\n                    }\\n\\n                    A.push(\"(\" + left1 + \".\" + left2 + \", \" + right1 + \".\" + right2 + \")\"); //prettier-ignore\\n                }\\n            }\\n        }\\n\\n        return [...new Set(A)];\\n    };\\n\\n----\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1206129,
                "title": "c-clean-and-short-codes",
                "content": "```\\nchar buf[14];\\nclass Solution {\\npublic:\\n    inline bool check(const char *c, int n) {\\n        return 1==n||c[0]!=\\'0\\'||c[n-1]!=\\'0\\';\\n    }\\n    vector<string> helper (const char *c, int n) {\\n        vector<string> ans;\\n        if(n==1) {\\n            ans.push_back(string(c, 1));\\n            return move(ans);\\n        }\\n        if(c[0]==\\'0\\') {\\n            buf[0]=\\'0\\';\\n            buf[1]=\\'.\\';\\n            for(int i=1; i<n; ++i) {\\n                buf[i+1]=c[i];\\n            }\\n            buf[n+1]=\\'\\\\0\\';\\n            ans.push_back(buf);\\n        } else if(c[n-1]==\\'0\\'){\\n            ans.push_back(string(c,n));\\n        } else {\\n            for(int i=0; i<n; ++i) {\\n                buf[i]=c[i];\\n            }\\n            buf[n]=\\'\\\\0\\';\\n            buf[n+1]=\\'\\\\0\\';\\n            ans.push_back(buf);\\n            buf[n]=\\'.\\';\\n            for(int i=n-1; i>0; --i){\\n                swap(buf[i], buf[i+1]);\\n                ans.push_back(buf);\\n            }\\n        }\\n        return move(ans);\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int N=s.size()-2;\\n        const char * c =s.c_str()+1;\\n        string str(\"(\");\\n        vector<string> ans;\\n        for(int i=0; i<N-1; ++i) {\\n            // cout<<string(c, i+1)<<\":\"<<check(c, i+1)<<\" | \"\\n            //     <<string(c+i+1, N-i-1)<<\":\"<<check(c+i+1, N-i-1)<<\"\\\\n\";\\n            if(check(c, i+1) && check(c+i+1, N-i-1)) {\\n                auto left=helper(c, i+1);\\n                auto right=helper(c+i+1, N-i-1);\\n                for(auto &l:left) {\\n                    for(auto &r:right) {\\n                        ans.push_back(str+l+\", \"+r+\")\");\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nchar buf[14];\\nclass Solution {\\npublic:\\n    inline bool check(const char *c, int n) {\\n        return 1==n||c[0]!=\\'0\\'||c[n-1]!=\\'0\\';\\n    }\\n    vector<string> helper (const char *c, int n) {\\n        vector<string> ans;\\n        if(n==1) {\\n            ans.push_back(string(c, 1));\\n            return move(ans);\\n        }\\n        if(c[0]==\\'0\\') {\\n            buf[0]=\\'0\\';\\n            buf[1]=\\'.\\';\\n            for(int i=1; i<n; ++i) {\\n                buf[i+1]=c[i];\\n            }\\n            buf[n+1]=\\'\\\\0\\';\\n            ans.push_back(buf);\\n        } else if(c[n-1]==\\'0\\'){\\n            ans.push_back(string(c,n));\\n        } else {\\n            for(int i=0; i<n; ++i) {\\n                buf[i]=c[i];\\n            }\\n            buf[n]=\\'\\\\0\\';\\n            buf[n+1]=\\'\\\\0\\';\\n            ans.push_back(buf);\\n            buf[n]=\\'.\\';\\n            for(int i=n-1; i>0; --i){\\n                swap(buf[i], buf[i+1]);\\n                ans.push_back(buf);\\n            }\\n        }\\n        return move(ans);\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int N=s.size()-2;\\n        const char * c =s.c_str()+1;\\n        string str(\"(\");\\n        vector<string> ans;\\n        for(int i=0; i<N-1; ++i) {\\n            // cout<<string(c, i+1)<<\":\"<<check(c, i+1)<<\" | \"\\n            //     <<string(c+i+1, N-i-1)<<\":\"<<check(c+i+1, N-i-1)<<\"\\\\n\";\\n            if(check(c, i+1) && check(c+i+1, N-i-1)) {\\n                auto left=helper(c, i+1);\\n                auto right=helper(c+i+1, N-i-1);\\n                for(auto &l:left) {\\n                    for(auto &r:right) {\\n                        ans.push_back(str+l+\", \"+r+\")\");\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1206062,
                "title": "simple-commented-code-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string>fun(string str)\\n    {\\n        vector<string>ans;\\n        int n = str.length();\\n        if(n == 1)\\n        {\\n            return {str};\\n        }\\n        // cases like \"123\"\\n        if(str[0] != \\'0\\')\\n        {\\n            ans.push_back(str);\\n        }\\n        \\n        if(str[0] == \\'0\\')\\n        {\\n            // cases like \"0110\"\\n            if(str.back() == \\'0\\')\\n            {\\n                return {};\\n            }\\n            // cases like \"011\"\\n            return {\"0.\" + str.substr(1)};\\n        }\\n        \\n        // for cases like 123 -- final vector would be {123, 1.23, 12.3}, but\\n        // for cases like 120 -- final vector would be {120} and not {120, 1.20, 12.0} as 1.20 and 12.0 are invalid \\n        if(str.back() != \\'0\\')\\n        {\\n                 for(int i = 1; i < n; i++)\\n                    {\\n                        string first = str.substr(0, i);\\n                        string second = str.substr(i);\\n                        ans.push_back(first + \".\" + second);\\n                    }   \\n        }\\n        return ans;\\n    }\\n    vector<string> ambiguousCoordinates(string s) \\n    {\\n        vector<string>ans;\\n        // removing parenthesis\\n        string str = s.substr(1, s.length() - 2);\\n        int n = str.length();\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            string first = str.substr(0, i);\\n            string second = str.substr(i);\\n            \\n            vector<string>for_first = fun(first);\\n            vector<string>for_second = fun(second);\\n            \\n            for(int i  = 0; i < for_first.size(); i++)\\n            {\\n                for(int j = 0; j < for_second.size(); j++)\\n                {\\n                    ans.push_back(\"(\" + for_first[i] + \", \" + for_second[j] + \")\");\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>fun(string str)\\n    {\\n        vector<string>ans;\\n        int n = str.length();\\n        if(n == 1)\\n        {\\n            return {str};\\n        }\\n        // cases like \"123\"\\n        if(str[0] != \\'0\\')\\n        {\\n            ans.push_back(str);\\n        }\\n        \\n        if(str[0] == \\'0\\')\\n        {\\n            // cases like \"0110\"\\n            if(str.back() == \\'0\\')\\n            {\\n                return {};\\n            }\\n            // cases like \"011\"\\n            return {\"0.\" + str.substr(1)};\\n        }\\n        \\n        // for cases like 123 -- final vector would be {123, 1.23, 12.3}, but\\n        // for cases like 120 -- final vector would be {120} and not {120, 1.20, 12.0} as 1.20 and 12.0 are invalid \\n        if(str.back() != \\'0\\')\\n        {\\n                 for(int i = 1; i < n; i++)\\n                    {\\n                        string first = str.substr(0, i);\\n                        string second = str.substr(i);\\n                        ans.push_back(first + \".\" + second);\\n                    }   \\n        }\\n        return ans;\\n    }\\n    vector<string> ambiguousCoordinates(string s) \\n    {\\n        vector<string>ans;\\n        // removing parenthesis\\n        string str = s.substr(1, s.length() - 2);\\n        int n = str.length();\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            string first = str.substr(0, i);\\n            string second = str.substr(i);\\n            \\n            vector<string>for_first = fun(first);\\n            vector<string>for_second = fun(second);\\n            \\n            for(int i  = 0; i < for_first.size(); i++)\\n            {\\n                for(int j = 0; j < for_second.size(); j++)\\n                {\\n                    ans.push_back(\"(\" + for_first[i] + \", \" + for_second[j] + \")\");\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206052,
                "title": "explained-algorithm-c-clean-code",
                "content": "**Intuition:**\\n1. Need to divide string in two halves and place decimal properly in each half.\\n2. Broke the string in two halves and made valid combination list of each half. \\n3. Received two list from left half and right half - assuming size a and b respectively\\n4. Now simple make (a* b) combinations of all elements present in two lists.\\n\\nWhere to place decimal :\\n1. [0XXXX0] -> {}\\n2. [0XXXXX] -> {0.XXXX}\\n3. [XXXXX0] -> {XXXXX0}\\n4. [XXXX] -> [XXXX]+[X.XXX]+[XX.XX]+[XXX.X] \\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> insertDecimal(string s){\\n        int n = s.length();\\n        \\n        vector<string> v;\\n        \\n        if(n == 0)\\n            return {};\\n        if(n == 1)\\n            return {s};\\n            \\n        if(s[0] == \\'0\\' && s[n-1] == \\'0\\')\\n            return {};\\n        if(s[0] == \\'0\\')\\n            return {\"0.\"+s.substr(1)};\\n        if(s[n-1] == \\'0\\')\\n            return {s};\\n        v.emplace_back(s);\\n        for(int i = 1; i<n; i++){\\n            v.emplace_back(s.substr(0,i)+\".\"+s.substr(i));\\n        }\\n        return v;\\n        \\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.length();\\n        vector<string> ans;\\n        \\n        for(int i = 1; i<n-2; i++){\\n            string s1 = s.substr(1,i);\\n            string s2 = s.substr(i+1,n-i-2);\\n            \\n            //cout<<s1<<\" \"<<s2<<endl;\\n            \\n            vector<string> v1 = insertDecimal(s1);\\n            vector<string> v2 = insertDecimal(s2);\\n            \\n            for(string s1 : v1){\\n                for(string s2 :  v2){\\n                    ans.emplace_back(\"(\"+s1+\", \"+s2+\")\");\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Time complexity** - O(n^3)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> insertDecimal(string s){\\n        int n = s.length();\\n        \\n        vector<string> v;\\n        \\n        if(n == 0)\\n            return {};\\n        if(n == 1)\\n            return {s};\\n            \\n        if(s[0] == \\'0\\' && s[n-1] == \\'0\\')\\n            return {};\\n        if(s[0] == \\'0\\')\\n            return {\"0.\"+s.substr(1)};\\n        if(s[n-1] == \\'0\\')\\n            return {s};\\n        v.emplace_back(s);\\n        for(int i = 1; i<n; i++){\\n            v.emplace_back(s.substr(0,i)+\".\"+s.substr(i));\\n        }\\n        return v;\\n        \\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.length();\\n        vector<string> ans;\\n        \\n        for(int i = 1; i<n-2; i++){\\n            string s1 = s.substr(1,i);\\n            string s2 = s.substr(i+1,n-i-2);\\n            \\n            //cout<<s1<<\" \"<<s2<<endl;\\n            \\n            vector<string> v1 = insertDecimal(s1);\\n            vector<string> v2 = insertDecimal(s2);\\n            \\n            for(string s1 : v1){\\n                for(string s2 :  v2){\\n                    ans.emplace_back(\"(\"+s1+\", \"+s2+\")\");\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 887214,
                "title": "python3-straightforward-solution-ambiguous-coordinates",
                "content": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, S: str) -> List[str]:\\n        S = S[1:-1]\\n        def numbers(s):\\n            ans = []\\n            for i in range(1, len(s)+1):\\n                ns = s[:i]\\n                if s[i:]:\\n                    ns += \".\" + s[i:]\\n                if len(ns) > 1 and (\\n                    ns[0] == \\'0\\' and ns[-1] == \\'0\\' or\\n                    ns[0] == \\'0\\' and ns[1] != \\'.\\' or\\n                    ns[-1] == \\'0\\' and \\'.\\' in ns):\\n                    continue\\n                ans.append(ns)    \\n            return ans        \\n        return [\\'(\\' + p[0] + \\', \\' + p[1] + \\')\\'\\n               for i in range(1, len(S))\\n               for p in itertools.product(numbers(S[:i]), numbers(S[i:]))]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, S: str) -> List[str]:\\n        S = S[1:-1]\\n        def numbers(s):\\n            ans = []\\n            for i in range(1, len(s)+1):\\n                ns = s[:i]\\n                if s[i:]:\\n                    ns += \".\" + s[i:]\\n                if len(ns) > 1 and (\\n                    ns[0] == \\'0\\' and ns[-1] == \\'0\\' or\\n                    ns[0] == \\'0\\' and ns[1] != \\'.\\' or\\n                    ns[-1] == \\'0\\' and \\'.\\' in ns):\\n                    continue\\n                ans.append(ns)    \\n            return ans        \\n        return [\\'(\\' + p[0] + \\', \\' + p[1] + \\')\\'\\n               for i in range(1, len(S))\\n               for p in itertools.product(numbers(S[:i]), numbers(S[i:]))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763418,
                "title": "c-easy-solution-explained",
                "content": "The idea is very simple. We continuously split the substring in 2 parts. One is our x coordinate the other is y coordinate. Now the helper function finds the number of ways we can form the x coordinate and the y coordinate, we form the final string by combining all x coordinates and y coordinates. Rest of the explanation is in code. Comment for any doubt.\\n```\\nclass Solution {\\npublic:\\n    vector <string> helper(string s)\\n    {\\n        vector <string> v;\\n        if(s.size()<2)\\n            return {s};\\n        int n=s.size();\\n        if(s[0]==\\'0\\')\\n        {\\n             if(s[n-1]==\\'0\\')\\n                 return {};\\n            string t=s.substr(0,1)+ \\'.\\' + s.substr(1); // if s[0] is 0, only possible solution is 0.xxxxx where last digit!=0\\n            return {t};\\n        }\\n        if(s[n-1]==\\'0\\')\\n            return {s}; // if last digit is 0, only possible solution is the string itself\\n        for(int i=0;i<n-1;i++)\\n        {\\n            v.push_back(s.substr(0,i+1)+\\'.\\'+s.substr(i+1)); // \\'.\\' in between all substrings\\n        }\\n        v.push_back(s);\\n        return v;\\n        \\n    }\\n    vector<string> ambiguousCoordinates(string S) {\\n        int n=S.size();\\n        \\n        vector <string> ans;\\n        vector <string> v1,v2;\\n        for(int i=1;i<n-2;i++)\\n        {\\n            v1.clear();\\n            v2.clear();\\n            v1= helper(S.substr(1,i));\\n            v2= helper(S.substr(i+1,n-i-2));\\n            cout<<S.substr(1,i)<<\" \"<<S.substr(i+1,n-i-2)<<\" \";\\n            if(v1.empty() || v2.empty())\\n                continue;\\n            for(int a=0;a<v1.size();a++)\\n            {\\n                for(int b=0;b<v2.size();b++)\\n                {\\n                    ans.push_back(\\'(\\'+v1[a]+\\',\\'+\\' \\'+v2[b]+\\')\\');\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <string> helper(string s)\\n    {\\n        vector <string> v;\\n        if(s.size()<2)\\n            return {s};\\n        int n=s.size();\\n        if(s[0]==\\'0\\')\\n        {\\n             if(s[n-1]==\\'0\\')\\n                 return {};\\n            string t=s.substr(0,1)+ \\'.\\' + s.substr(1); // if s[0] is 0, only possible solution is 0.xxxxx where last digit!=0\\n            return {t};\\n        }\\n        if(s[n-1]==\\'0\\')\\n            return {s}; // if last digit is 0, only possible solution is the string itself\\n        for(int i=0;i<n-1;i++)\\n        {\\n            v.push_back(s.substr(0,i+1)+\\'.\\'+s.substr(i+1)); // \\'.\\' in between all substrings\\n        }\\n        v.push_back(s);\\n        return v;\\n        \\n    }\\n    vector<string> ambiguousCoordinates(string S) {\\n        int n=S.size();\\n        \\n        vector <string> ans;\\n        vector <string> v1,v2;\\n        for(int i=1;i<n-2;i++)\\n        {\\n            v1.clear();\\n            v2.clear();\\n            v1= helper(S.substr(1,i));\\n            v2= helper(S.substr(i+1,n-i-2));\\n            cout<<S.substr(1,i)<<\" \"<<S.substr(i+1,n-i-2)<<\" \";\\n            if(v1.empty() || v2.empty())\\n                continue;\\n            for(int a=0;a<v1.size();a++)\\n            {\\n                for(int b=0;b<v2.size();b++)\\n                {\\n                    ans.push_back(\\'(\\'+v1[a]+\\',\\'+\\' \\'+v2[b]+\\')\\');\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 600675,
                "title": "java-solution-with-a-simple-predicate",
                "content": "```\\nclass Solution {\\n    private Predicate<String> coordinatePredicate =\\n            s -> !(s.contains(\".\") && s.endsWith(\"0\") || s.startsWith(\"0\") && s.length() > 1 && !s.startsWith(\"0.\"));\\n\\n    private String removeParentheses(String s) {\\n        return s.substring(1, s.length() - 1);\\n    }\\n\\n    public List<String> ambiguousCoordinates(String S) {\\n        List<String> result = new ArrayList<>();\\n        S = removeParentheses(S);\\n        for (int i = 1; i < S.length(); i++) {\\n            result.addAll(combine(\\n                    possibleCoordinates(S.substring(0, i)),\\n                    possibleCoordinates(S.substring(i))\\n            ));\\n        }\\n        return result;\\n    }\\n\\n    private List<String> possibleCoordinates(String s) {\\n        return IntStream.range(0, s.length())\\n                .mapToObj(i -> insertDot(s, i))\\n                .filter(coordinatePredicate)\\n                .collect(Collectors.toList());\\n    }\\n\\n    private static String insertDot(String val, int place) {\\n        if (place == 0) {\\n            return val;\\n        }\\n        return val.substring(0, place) + \".\" + val.substring(place);\\n    }\\n\\n    private static List<String> combine(List<String> l1, List<String> l2) {\\n        return l1.stream().flatMap(s1 -> l2.stream().map(s2 -> \"(\" + s1 + \", \" + s2 + \")\")).collect(Collectors.toList());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Predicate<String> coordinatePredicate =\\n            s -> !(s.contains(\".\") && s.endsWith(\"0\") || s.startsWith(\"0\") && s.length() > 1 && !s.startsWith(\"0.\"));\\n\\n    private String removeParentheses(String s) {\\n        return s.substring(1, s.length() - 1);\\n    }\\n\\n    public List<String> ambiguousCoordinates(String S) {\\n        List<String> result = new ArrayList<>();\\n        S = removeParentheses(S);\\n        for (int i = 1; i < S.length(); i++) {\\n            result.addAll(combine(\\n                    possibleCoordinates(S.substring(0, i)),\\n                    possibleCoordinates(S.substring(i))\\n            ));\\n        }\\n        return result;\\n    }\\n\\n    private List<String> possibleCoordinates(String s) {\\n        return IntStream.range(0, s.length())\\n                .mapToObj(i -> insertDot(s, i))\\n                .filter(coordinatePredicate)\\n                .collect(Collectors.toList());\\n    }\\n\\n    private static String insertDot(String val, int place) {\\n        if (place == 0) {\\n            return val;\\n        }\\n        return val.substring(0, place) + \".\" + val.substring(place);\\n    }\\n\\n    private static List<String> combine(List<String> l1, List<String> l2) {\\n        return l1.stream().flatMap(s1 -> l2.stream().map(s2 -> \"(\" + s1 + \", \" + s2 + \")\")).collect(Collectors.toList());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 553676,
                "title": "python-intuitive-solution",
                "content": "```\\n\\'\\'\\'\\nSplit the number into left and right halves.\\nCompute possible combinations of each half\\npick one from left comb and one from right comb to build final results.\\nwhen build the combinations of a given word, the helper function doesn\\'t count invalid numbers.\\ntime complexity: O(n*n*n)\\nspace: O(n*n)\\n\\'\\'\\'\\nclass Solution:\\n    def ambiguousCoordinates(self, S: str) -> List[str]:\\n        res = []\\n        len_S = len(S)\\n        for i in range(2,len_S-1):\\n            left = S[1:i]\\n            right = S[i:len_S-1]\\n            left_comb = self.helper(left)\\n            right_comb = self.helper(right)\\n            for l in left_comb:\\n                for r in right_comb:\\n                    res.append(\\'(\\'+l+\\', \\'+r+\\')\\')\\n        return res\\n    \\n    def helper(self, word):\\n        if len(word) == 1:\\n            return [word]\\n        if word[0] == \\'0\\':\\n            if word[-1] != \\'0\\':\\n                return [\\'0.\\'+word[1:]]\\n            return []\\n        res = [word]\\n        if word[-1] != \\'0\\':\\n            for i in range(1, len(word)):\\n                res.append(word[:i]+\\'.\\'+word[i:])\\n        return res\\n            \\n```",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\nSplit the number into left and right halves.\\nCompute possible combinations of each half\\npick one from left comb and one from right comb to build final results.\\nwhen build the combinations of a given word, the helper function doesn\\'t count invalid numbers.\\ntime complexity: O(n*n*n)\\nspace: O(n*n)\\n\\'\\'\\'\\nclass Solution:\\n    def ambiguousCoordinates(self, S: str) -> List[str]:\\n        res = []\\n        len_S = len(S)\\n        for i in range(2,len_S-1):\\n            left = S[1:i]\\n            right = S[i:len_S-1]\\n            left_comb = self.helper(left)\\n            right_comb = self.helper(right)\\n            for l in left_comb:\\n                for r in right_comb:\\n                    res.append(\\'(\\'+l+\\', \\'+r+\\')\\')\\n        return res\\n    \\n    def helper(self, word):\\n        if len(word) == 1:\\n            return [word]\\n        if word[0] == \\'0\\':\\n            if word[-1] != \\'0\\':\\n                return [\\'0.\\'+word[1:]]\\n            return []\\n        res = [word]\\n        if word[-1] != \\'0\\':\\n            for i in range(1, len(word)):\\n                res.append(word[:i]+\\'.\\'+word[i:])\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 188921,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun ambiguousCoordinates(S: String): List<String> {\\n        val content = S.substring(1, S.length - 1)\\n        if (content.length <= 1) return listOf()\\n        return (0 until content.length - 1).flatMap {\\n            val left = decimals(content.substring(0, it + 1))\\n            val right = decimals(content.substring(it + 1))\\n            if (left != null && right != null) {\\n                left.flatMap { l -> right.map { r -> \"($l, $r)\"} }\\n            } else {\\n                emptyList()\\n            }\\n        }\\n    }\\n\\n    private fun decimals(S: String): List<String>? {\\n        if (S[0] == \\'0\\') {\\n            if (S.length == 1) return listOf(\"0\")\\n            if (S.all { it == \\'0\\' }) return null\\n            if (S.last() == \\'0\\') return null\\n            return listOf(\"0.${S.substring(1)}\")\\n        } else {\\n            return if (S.last() == \\'0\\') listOf(S) else (0 until S.length).map {\\n                if (it < S.length - 1) \"${S.substring(0, it + 1)}.${S.substring(it + 1)}\" else S\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun ambiguousCoordinates(S: String): List<String> {\\n        val content = S.substring(1, S.length - 1)\\n        if (content.length <= 1) return listOf()\\n        return (0 until content.length - 1).flatMap {\\n            val left = decimals(content.substring(0, it + 1))\\n            val right = decimals(content.substring(it + 1))\\n            if (left != null && right != null) {\\n                left.flatMap { l -> right.map { r -> \"($l, $r)\"} }\\n            } else {\\n                emptyList()\\n            }\\n        }\\n    }\\n\\n    private fun decimals(S: String): List<String>? {\\n        if (S[0] == \\'0\\') {\\n            if (S.length == 1) return listOf(\"0\")\\n            if (S.all { it == \\'0\\' }) return null\\n            if (S.last() == \\'0\\') return null\\n            return listOf(\"0.${S.substring(1)}\")\\n        } else {\\n            return if (S.last() == \\'0\\') listOf(S) else (0 until S.length).map {\\n                if (it < S.length - 1) \"${S.substring(0, it + 1)}.${S.substring(it + 1)}\" else S\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158464,
                "title": "c-real-clear-8ms-solution-beats-100",
                "content": "```\\n    vector<string> ambiguousCoordinates(string S) {\\n        vector<string> res;\\n        for(int i=1;i<S.size()-2;i++) {\\n            vector<string> left=makeNum(S.substr(1, i));\\n            vector<string> right=makeNum(S.substr(i+1, S.size()-2-i));\\n            for(int m=0;m<left.size();m++) {\\n                for(int n=0;n<right.size();n++) res.push_back(\"(\"+left[m]+\", \"+right[n]+\")\");\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    vector<string> makeNum(string num) {\\n        vector<string> res;\\n        if(num[0]!=\\'0\\'||num.size()==1) res.push_back(num);\\n        for(int i=0;i<num.size()-1;i++) {\\n            if((num[0]==\\'0\\'&&i!=0)||num.back()==\\'0\\') continue;\\n            res.push_back(num.substr(0, i+1)+\".\"+num.substr(i+1));\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    vector<string> ambiguousCoordinates(string S) {\\n        vector<string> res;\\n        for(int i=1;i<S.size()-2;i++) {\\n            vector<string> left=makeNum(S.substr(1, i));\\n            vector<string> right=makeNum(S.substr(i+1, S.size()-2-i));\\n            for(int m=0;m<left.size();m++) {\\n                for(int n=0;n<right.size();n++) res.push_back(\"(\"+left[m]+\", \"+right[n]+\")\");\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    vector<string> makeNum(string num) {\\n        vector<string> res;\\n        if(num[0]!=\\'0\\'||num.size()==1) res.push_back(num);\\n        for(int i=0;i<num.size()-1;i++) {\\n            if((num[0]==\\'0\\'&&i!=0)||num.back()==\\'0\\') continue;\\n            res.push_back(num.substr(0, i+1)+\".\"+num.substr(i+1));\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4090391,
                "title": "c-annoying-validation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force with validation of generated numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Split input into 2 parts (left & right) process each in seperation.\\n- Combine results in nested loop.\\n- Call function to validate if generated number looks reasonable.\\n\\n# Complexity\\n- Time complexity:\\nSeems like a $$O(n^3)$$ in the worst case.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSeems like a $$O(n^2)$$ in the worst case.\\n\\n# Code\\n```\\npublic class Solution {\\n\\n    bool reasonable(string s)\\n    {\\n// use a hack to simplofy\\n         if (s.IndexOf(\\'.\\') < 0)\\n         {\\n             return $\"{int.Parse(s)}\" == s;\\n         }\\n                \\n// only cases with floating point left here - can\\'t end with a 0\\n        if (s.Last() == \\'0\\')                        \\n            return false;        \\n\\n// floating point that starts with a 0, means must have a . as 2nd\\n        if (s[0] == \\'0\\')\\n        {\\n            if (s.Length < 3)\\n                return false;\\n\\n            if (s[1] != \\'.\\')\\n            {\\n                return false;\\n            }\\n        }\\n    \\n        return true;\\n    }\\n// generate possible cases out of supplied digits\\n    IList<string> generate(string s)\\n    {\\n        var a = new List<string>();\\n        a.Add(s);\\n        for (int i = 1; i < s.Length; i++)\\n        {\\n            a.Add($\"{s.Substring(0,i)}.{s.Substring(i, s.Length-i)}\");\\n        }\\n        return a;\\n    }\\n\\n    public IList<string> AmbiguousCoordinates(string s) {\\n\\n        var st = s.Substring(1, s.Length-2);\\n        var answer = new List<string>();\\n   // slide possible position of ,     \\n        for (int i = 1; i < st.Length; i++)\\n        {\\n            var ls = st.Substring(0, i);\\n            var rs = st.Substring(i, st.Length-i);\\n\\n            foreach(var lc in generate(ls))\\n            {\\n                if (!reasonable(lc))\\n                    continue;\\n\\n                foreach(var rc in generate(rs))\\n                {\\n                    if (reasonable(rc))\\n                        answer.Add($\"({lc}, {rc})\");\\n                }\\n            }\\n        }    \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n    bool reasonable(string s)\\n    {\\n// use a hack to simplofy\\n         if (s.IndexOf(\\'.\\') < 0)\\n         {\\n             return $\"{int.Parse(s)}\" == s;\\n         }\\n                \\n// only cases with floating point left here - can\\'t end with a 0\\n        if (s.Last() == \\'0\\')                        \\n            return false;        \\n\\n// floating point that starts with a 0, means must have a . as 2nd\\n        if (s[0] == \\'0\\')\\n        {\\n            if (s.Length < 3)\\n                return false;\\n\\n            if (s[1] != \\'.\\')\\n            {\\n                return false;\\n            }\\n        }\\n    \\n        return true;\\n    }\\n// generate possible cases out of supplied digits\\n    IList<string> generate(string s)\\n    {\\n        var a = new List<string>();\\n        a.Add(s);\\n        for (int i = 1; i < s.Length; i++)\\n        {\\n            a.Add($\"{s.Substring(0,i)}.{s.Substring(i, s.Length-i)}\");\\n        }\\n        return a;\\n    }\\n\\n    public IList<string> AmbiguousCoordinates(string s) {\\n\\n        var st = s.Substring(1, s.Length-2);\\n        var answer = new List<string>();\\n   // slide possible position of ,     \\n        for (int i = 1; i < st.Length; i++)\\n        {\\n            var ls = st.Substring(0, i);\\n            var rs = st.Substring(i, st.Length-i);\\n\\n            foreach(var lc in generate(ls))\\n            {\\n                if (!reasonable(lc))\\n                    continue;\\n\\n                foreach(var rc in generate(rs))\\n                {\\n                    if (reasonable(rc))\\n                        answer.Add($\"({lc}, {rc})\");\\n                }\\n            }\\n        }    \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049037,
                "title": "go-solution-with-comments",
                "content": "```\\nfunc ambiguousCoordinates(s string) []string {\\n    res := []string{}\\n    // remove parenthesis\\n    s = s[1:len(s) - 1]\\n\\n    for i := 1; i < len(s); i++ {\\n        // generate possible x coordinates based on split\\n        lefts := gen(s, 0, i)\\n        // generate possible y coordinates based on split\\n        rights := gen(s, i, len(s))\\n\\n        // for each possible pair of  coordinates\\n        for _, left := range lefts {\\n            for _, right := range rights {\\n                val := \"(\" + left + \", \" + right + \")\"\\n                res = append(res, val)\\n            }\\n        }\\n    }\\n\\n    return res\\n}\\n\\nfunc gen(s string, start, end int) []string {\\n    res := []string{}\\n\\n    // partitioning for whole number and decimal part\\n    for p := 1; p <= end - start; p++ {\\n        // whole number part\\n        w := s[start:start + p]\\n        // decimal number part\\n        d := s[start + p:end]\\n\\n        // either whole number part is a zero or it cannot start with zero\\n        // and either decimal part doesn\\'t exist or it cannot end with a zero\\n        if (w == \"0\" || w[0] != \\'0\\') && (len(d) == 0 || d[len(d) - 1] != \\'0\\') {\\n            if len(d) == 0 {\\n                // decimal part does not exist\\n                res = append(res, w)\\n            } else {\\n                // decimal exists\\n                res = append(res, w + \".\" + d)\\n            }\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc ambiguousCoordinates(s string) []string {\\n    res := []string{}\\n    // remove parenthesis\\n    s = s[1:len(s) - 1]\\n\\n    for i := 1; i < len(s); i++ {\\n        // generate possible x coordinates based on split\\n        lefts := gen(s, 0, i)\\n        // generate possible y coordinates based on split\\n        rights := gen(s, i, len(s))\\n\\n        // for each possible pair of  coordinates\\n        for _, left := range lefts {\\n            for _, right := range rights {\\n                val := \"(\" + left + \", \" + right + \")\"\\n                res = append(res, val)\\n            }\\n        }\\n    }\\n\\n    return res\\n}\\n\\nfunc gen(s string, start, end int) []string {\\n    res := []string{}\\n\\n    // partitioning for whole number and decimal part\\n    for p := 1; p <= end - start; p++ {\\n        // whole number part\\n        w := s[start:start + p]\\n        // decimal number part\\n        d := s[start + p:end]\\n\\n        // either whole number part is a zero or it cannot start with zero\\n        // and either decimal part doesn\\'t exist or it cannot end with a zero\\n        if (w == \"0\" || w[0] != \\'0\\') && (len(d) == 0 || d[len(d) - 1] != \\'0\\') {\\n            if len(d) == 0 {\\n                // decimal part does not exist\\n                res = append(res, w)\\n            } else {\\n                // decimal exists\\n                res = append(res, w + \".\" + d)\\n            }\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028585,
                "title": "python-solution-explanation",
                "content": "We can split this problem into two subproblems:\\n1. Get all the possible values for coordinates substring (`102` -> `[1.02, 10.2, 102]`, `00` -> `[]`)\\n2. Get all the possible combinations for two coordinates substrings\\n\\nFor the first subproblem, refer to `variants` function. It should be self-explanatory: we iterate through coordinate substring and split it into whole part and fractional part. Then we validate each part according to problem description. If both parts are valid, we add it to our answer.\\n\\nFor the second subproblem we iterate through input string, split it into two parts, call `variants` function and use `itertools.product` to generate all the possible combinations.\\n\\n# Code\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:len(s) - 1]\\n\\n        @functools.cache\\n        def variants(val):\\n            vals = []\\n\\n            for i in range(1, len(val) + 1):\\n                whole = val[:i]\\n                fractional = val[i:]\\n\\n                if whole[0] == \"0\" and len(whole) > 1:\\n                    continue\\n\\n                if fractional:\\n                    if fractional[-1] == \"0\":\\n                        continue\\n\\n                    vals.append(f\"{whole}.{fractional}\")\\n                else:\\n                    vals.append(whole)    \\n\\n            return vals\\n\\n        result = []\\n\\n        for i in range(1, len(s)):\\n            result.extend(\\n                f\"({a}, {b})\" \\n                for a, b in itertools.product(variants(s[:i]), variants(s[i:]))\\n            )\\n\\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:len(s) - 1]\\n\\n        @functools.cache\\n        def variants(val):\\n            vals = []\\n\\n            for i in range(1, len(val) + 1):\\n                whole = val[:i]\\n                fractional = val[i:]\\n\\n                if whole[0] == \"0\" and len(whole) > 1:\\n                    continue\\n\\n                if fractional:\\n                    if fractional[-1] == \"0\":\\n                        continue\\n\\n                    vals.append(f\"{whole}.{fractional}\")\\n                else:\\n                    vals.append(whole)    \\n\\n            return vals\\n\\n        result = []\\n\\n        for i in range(1, len(s)):\\n            result.extend(\\n                f\"({a}, {b})\" \\n                for a, b in itertools.product(variants(s[:i]), variants(s[i:]))\\n            )\\n\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018347,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\n// the constraints are really small so we can use brute force , rest of the code is self explanatory\\n\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        String str = s.substring(1,s.length()-1); // remove brackets from the expression to make it easier to process \\n        List<String> list = new ArrayList();\\n        for(int i =0;i<str.length()-1;i++){\\n            String s1 = str.substring(0,i+1); // first coordinate \\n            String s2 = str.substring(i+1);   // second coordinate \\n            if(isValid(s1)&&isValid(s2)){ // if both are valid numbers , then we will add this to our result \\n                String ans = \"(\"+s1+\", \"+s2+\")\";\\n                list.add(ans);\\n            }\\n            // now we form two lists l1 and l2 , l1 consists of all possible decimal numbers that can be formed from s1 , l2 consists of all possible decimal numbers that can be formed from s2 \\n            List<String> l1 = new ArrayList();\\n            List<String> l2 = new ArrayList();\\n            fillList(s1,l1);\\n            fillList(s2,l2);\\n            for(String ss1 : l1){\\n                for(String ss2 : l2){\\n                     String ans = \"(\"+ss1+\", \"+ss2+\")\"; // adding all (decimal , decimal) pairs to answer\\n                     list.add(ans);\\n                }\\n            }\\n            if(isValid(s1)){ // add all (integer , decimal) pairs to answer if s1 is a valid integer\\n                for(String ss2 : l2){\\n                     String ans = \"(\"+s1+\", \"+ss2+\")\";\\n                     list.add(ans);\\n                }\\n            }\\n            if(isValid(s2)){ // add all (decimal , integer) pairs to answer if s2 is a valid integer \\n                for(String ss1 : l1){\\n                     String ans = \"(\"+ss1+\", \"+s2+\")\";\\n                     list.add(ans);\\n                }\\n            }\\n            \\n   }\\n        return list;\\n    }\\n    public boolean isValid(String s){ // this is used to check if an integer is valid and it is also used to check if part of number before decimal is valid \\n        if(s.length()==1) return true; // always valid \\n        return s.charAt(0)==\\'0\\'?false:true; // form : 0000....... invalid \\n    }\\n    public boolean isSecondValid(String s){ // this is used to check if part of number after decimal is valid \\n        boolean found = false; // found == true if >=\\'1\\' found \\n        for(int i = 0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch>=\\'1\\') found = true;\\n            else{\\n                if(found){ // if >=\\'1\\' found check if after this do we have only zeroes , because 0.5000000 is invalid \\n                    boolean allZeroes = true;\\n                    for(int j = i+1;j<s.length();j++){\\n                        if(s.charAt(j)>=\\'1\\') allZeroes = false;\\n                    }\\n                    if(allZeroes) return false;\\n                }\\n            }\\n        }\\n        return found; // found becomes true when >=\\'1\\' is found so if we have something like 0.0000000 its invalid and we return false in that case \\n    }\\n \\n    public void fillList(String s , List<String> list){ // fills list with all decimal numbers possible from given string s\\n            for(int i = 0;i<s.length()-1;i++){\\n             String s1 = s.substring(0,i+1);\\n             String s2 = s.substring(i+1);\\n             if(isValid(s1)&&isSecondValid(s2)){\\n                 String ans = s1+\".\"+s2;\\n                 list.add(ans);\\n             }\\n            }\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    \\n    bool valid(string t) { // is this coord valid? \\n        int i=1,n=t.size();\\n        if(n>=2 and t[0]==\\'0\\' and t[1]!=\\'.\\') // 01, 03... --> not valid\\n            return false;\\n        \\n        while(i<n and t[i]!=\\'.\\') // get position of the point\\n              i++;\\n        if(i!=n and t[n-1]==\\'0\\') // 234.0, 931.424320 --> not valid\\n            return false;\\n        i++;\\n        while(i<n and t[i]==\\'0\\') // if after the point are all zeros, not valid\\n            i++;\\n        if(i==n) return false;\\n        \\n        return true; // if here, coord is valid\\n   }\\n    \\n    void get_coord(string s1, string s2, vector<string>& res) {\\n        int n1=s1.size(), n2=s2.size();\\n        for(int i=0;i<n1;i++){ \\n            // get every possible partition, as before, but with point at the middle\\n            // es. s1 = 1234 -> (.1234), (1.234), (12.234), (123.4)\\n            string s11 = s1.substr(0,i);\\n            string s12 = s1.substr(i);\\n            string t1 = s11 + \".\" + s12;\\n            if(t1[0] == \\'.\\') // remove initial point if present\\n                t1=t1.substr(1);\\n            if(valid(t1)){ // if it is valid, look at the second string\\n                for(int i=0;i<n2;i++){\\n                    string s21 = s2.substr(0,i);\\n                    string s22 = s2.substr(i);  \\n                    string t2 = s21 + \".\" + s22;\\n                    if(t2[0] == \\'.\\') // remove initial point if present\\n                        t2=t2.substr(1);\\n                    if(valid(t2)){ // if the second is valid too, add to res\\n                        res.push_back(\"(\"+t1+\", \"+t2+\")\");\\n                    }\\n                }\\n            }\\n        }\\n    }   \\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1,s.size()-2); // string without ( )\\n        vector<string> res;\\n        int n=s.size();\\n        for(int i=0;i<n;i++) {\\n            // get every double partition of string\\n            // es. s = 1234 -> (, 1234), (1, 234), (12, 234), (123, 4)\\n            get_coord(s.substr(0,i), s.substr(i), res); \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\n// the constraints are really small so we can use brute force , rest of the code is self explanatory\\n\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        String str = s.substring(1,s.length()-1); // remove brackets from the expression to make it easier to process \\n        List<String> list = new ArrayList();\\n        for(int i =0;i<str.length()-1;i++){\\n            String s1 = str.substring(0,i+1); // first coordinate \\n            String s2 = str.substring(i+1);   // second coordinate \\n            if(isValid(s1)&&isValid(s2)){ // if both are valid numbers , then we will add this to our result \\n                String ans = \"(\"+s1+\", \"+s2+\")\";\\n                list.add(ans);\\n            }\\n            // now we form two lists l1 and l2 , l1 consists of all possible decimal numbers that can be formed from s1 , l2 consists of all possible decimal numbers that can be formed from s2 \\n            List<String> l1 = new ArrayList();\\n            List<String> l2 = new ArrayList();\\n            fillList(s1,l1);\\n            fillList(s2,l2);\\n            for(String ss1 : l1){\\n                for(String ss2 : l2){\\n                     String ans = \"(\"+ss1+\", \"+ss2+\")\"; // adding all (decimal , decimal) pairs to answer\\n                     list.add(ans);\\n                }\\n            }\\n            if(isValid(s1)){ // add all (integer , decimal) pairs to answer if s1 is a valid integer\\n                for(String ss2 : l2){\\n                     String ans = \"(\"+s1+\", \"+ss2+\")\";\\n                     list.add(ans);\\n                }\\n            }\\n            if(isValid(s2)){ // add all (decimal , integer) pairs to answer if s2 is a valid integer \\n                for(String ss1 : l1){\\n                     String ans = \"(\"+ss1+\", \"+s2+\")\";\\n                     list.add(ans);\\n                }\\n            }\\n            \\n   }\\n        return list;\\n    }\\n    public boolean isValid(String s){ // this is used to check if an integer is valid and it is also used to check if part of number before decimal is valid \\n        if(s.length()==1) return true; // always valid \\n        return s.charAt(0)==\\'0\\'?false:true; // form : 0000....... invalid \\n    }\\n    public boolean isSecondValid(String s){ // this is used to check if part of number after decimal is valid \\n        boolean found = false; // found == true if >=\\'1\\' found \\n        for(int i = 0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch>=\\'1\\') found = true;\\n            else{\\n                if(found){ // if >=\\'1\\' found check if after this do we have only zeroes , because 0.5000000 is invalid \\n                    boolean allZeroes = true;\\n                    for(int j = i+1;j<s.length();j++){\\n                        if(s.charAt(j)>=\\'1\\') allZeroes = false;\\n                    }\\n                    if(allZeroes) return false;\\n                }\\n            }\\n        }\\n        return found; // found becomes true when >=\\'1\\' is found so if we have something like 0.0000000 its invalid and we return false in that case \\n    }\\n \\n    public void fillList(String s , List<String> list){ // fills list with all decimal numbers possible from given string s\\n            for(int i = 0;i<s.length()-1;i++){\\n             String s1 = s.substring(0,i+1);\\n             String s2 = s.substring(i+1);\\n             if(isValid(s1)&&isSecondValid(s2)){\\n                 String ans = s1+\".\"+s2;\\n                 list.add(ans);\\n             }\\n            }\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    \\n    bool valid(string t) { // is this coord valid? \\n        int i=1,n=t.size();\\n        if(n>=2 and t[0]==\\'0\\' and t[1]!=\\'.\\') // 01, 03... --> not valid\\n            return false;\\n        \\n        while(i<n and t[i]!=\\'.\\') // get position of the point\\n              i++;\\n        if(i!=n and t[n-1]==\\'0\\') // 234.0, 931.424320 --> not valid\\n            return false;\\n        i++;\\n        while(i<n and t[i]==\\'0\\') // if after the point are all zeros, not valid\\n            i++;\\n        if(i==n) return false;\\n        \\n        return true; // if here, coord is valid\\n   }\\n    \\n    void get_coord(string s1, string s2, vector<string>& res) {\\n        int n1=s1.size(), n2=s2.size();\\n        for(int i=0;i<n1;i++){ \\n            // get every possible partition, as before, but with point at the middle\\n            // es. s1 = 1234 -> (.1234), (1.234), (12.234), (123.4)\\n            string s11 = s1.substr(0,i);\\n            string s12 = s1.substr(i);\\n            string t1 = s11 + \".\" + s12;\\n            if(t1[0] == \\'.\\') // remove initial point if present\\n                t1=t1.substr(1);\\n            if(valid(t1)){ // if it is valid, look at the second string\\n                for(int i=0;i<n2;i++){\\n                    string s21 = s2.substr(0,i);\\n                    string s22 = s2.substr(i);  \\n                    string t2 = s21 + \".\" + s22;\\n                    if(t2[0] == \\'.\\') // remove initial point if present\\n                        t2=t2.substr(1);\\n                    if(valid(t2)){ // if the second is valid too, add to res\\n                        res.push_back(\"(\"+t1+\", \"+t2+\")\");\\n                    }\\n                }\\n            }\\n        }\\n    }   \\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1,s.size()-2); // string without ( )\\n        vector<string> res;\\n        int n=s.size();\\n        for(int i=0;i<n;i++) {\\n            // get every double partition of string\\n            // es. s = 1234 -> (, 1234), (1, 234), (12, 234), (123, 4)\\n            get_coord(s.substr(0,i), s.substr(i), res); \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644493,
                "title": "very-simple-intuition-solution-c",
                "content": "# Complexity\\n- Time complexity: O(N^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(vector<string> &ans, string &a, string &b){\\n        // Here we have to validate and then add that to answer\\n        vector<string> tem;\\n        string t = \"(\";\\n        // putting dot on\\n        for(int i=0;i<a.length();i++){\\n            t = \"(\";\\n            if(i == 0) t += a;\\n            else{\\n                t += a.substr(0,i);\\n                t += \\'.\\';\\n                t += a.substr(i,a.length()-i);\\n            }\\n            // Now we got t\\n            // check for 00. or 000. 01.\\n            if(t[1] == \\'0\\'){\\n                // if first char is zero we must see if we got any other char after that or not if we got that we break\\n                if(t.length() > 2 && t[2] != \\'.\\') continue;\\n            }\\n            // check for .000 or .00\\n            if(i != 0 && t[t.length()-1] == \\'0\\') continue;\\n            tem.push_back(t);\\n        }\\n        t = \"\";\\n        for(int i=0;i<b.length();i++){\\n            if(i == 0) t = b;\\n            else{\\n                t = b.substr(0,i);\\n                t += \\'.\\';\\n                t += b.substr(i,b.length()-i);\\n            }\\n            // Now we got t\\n            // check for 00. or 000. 01.\\n            if(t[0] == \\'0\\'){\\n                // if first char is zero we must see if we got any other char after that or not if we got that we break\\n                if(t.length() > 1 && t[1] != \\'.\\') continue;\\n            }\\n            // check for .000 or .00\\n            if(i != 0 && t[t.length()-1] == \\'0\\') continue;\\n            for(auto s: tem){\\n                string n = s;\\n                n += \", \";\\n                n += t;\\n                n += \\')\\';\\n                ans.push_back(n);\\n            }\\n        }\\n    }\\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> ans;\\n        string fi = \"\", se = \"\";\\n        // we are making first coordinate and second then try to add point in all and validate \\n        for(int j = 1;j<s.length()-2;j++){\\n            fi += s[j];\\n            se = s.substr(j+1,s.length()-1-(j+1));\\n            // Now we have to pass this\\n            solve(ans,fi,se);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(vector<string> &ans, string &a, string &b){\\n        // Here we have to validate and then add that to answer\\n        vector<string> tem;\\n        string t = \"(\";\\n        // putting dot on\\n        for(int i=0;i<a.length();i++){\\n            t = \"(\";\\n            if(i == 0) t += a;\\n            else{\\n                t += a.substr(0,i);\\n                t += \\'.\\';\\n                t += a.substr(i,a.length()-i);\\n            }\\n            // Now we got t\\n            // check for 00. or 000. 01.\\n            if(t[1] == \\'0\\'){\\n                // if first char is zero we must see if we got any other char after that or not if we got that we break\\n                if(t.length() > 2 && t[2] != \\'.\\') continue;\\n            }\\n            // check for .000 or .00\\n            if(i != 0 && t[t.length()-1] == \\'0\\') continue;\\n            tem.push_back(t);\\n        }\\n        t = \"\";\\n        for(int i=0;i<b.length();i++){\\n            if(i == 0) t = b;\\n            else{\\n                t = b.substr(0,i);\\n                t += \\'.\\';\\n                t += b.substr(i,b.length()-i);\\n            }\\n            // Now we got t\\n            // check for 00. or 000. 01.\\n            if(t[0] == \\'0\\'){\\n                // if first char is zero we must see if we got any other char after that or not if we got that we break\\n                if(t.length() > 1 && t[1] != \\'.\\') continue;\\n            }\\n            // check for .000 or .00\\n            if(i != 0 && t[t.length()-1] == \\'0\\') continue;\\n            for(auto s: tem){\\n                string n = s;\\n                n += \", \";\\n                n += t;\\n                n += \\')\\';\\n                ans.push_back(n);\\n            }\\n        }\\n    }\\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> ans;\\n        string fi = \"\", se = \"\";\\n        // we are making first coordinate and second then try to add point in all and validate \\n        for(int j = 1;j<s.length()-2;j++){\\n            fi += s[j];\\n            se = s.substr(j+1,s.length()-1-(j+1));\\n            // Now we have to pass this\\n            solve(ans,fi,se);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592211,
                "title": "easy-division",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsuppose s=pre+suf, the corresponding coordinates include the join of all possible divisions of pre/suf. Note that, for any pre/suf, it is not valid for division if the length of it is larger than 1 and both the front and end of it are \\'0\\'s.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^3)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    unordered_map<string,vector<string>> mp;\\n    vector<string> helper(string&s){\\n        if(mp.count(s)) return mp[s];\\n        if(s.size()>1 and s[0]==\\'0\\' and s.back()==\\'0\\') return {};\\n        if(s.back()==\\'0\\'){\\n            mp[s]={s};\\n            return mp[s];\\n        }\\n        if(s[0]==\\'0\\'){\\n            string tmp=s.substr(0,1)+\\'.\\'+s.substr(1);\\n            mp[s]={tmp};\\n            return mp[s];\\n        }\\n        for(int i=1;i<s.size();i++){\\n            string tmp=s.substr(0,i)+\\'.\\'+s.substr(i);\\n            mp[s].emplace_back(tmp);\\n        }\\n        mp[s].emplace_back(s);\\n        return mp[s];\\n    }\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> result;\\n        for(int i=1;i+2<s.size();i++){\\n            string pre=s.substr(1,i),suf=s.substr(i+1,s.size()-i-2);\\n            auto ss1=helper(pre);\\n            auto ss2=helper(suf);\\n            if(ss1.empty() or ss2.empty())  continue;\\n            for(auto&x:ss1) for(auto&y:ss2){\\n                    string tmp=\"(\"+x+\", \"+y+\")\";\\n                    result.emplace_back(tmp);\\n                }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<string,vector<string>> mp;\\n    vector<string> helper(string&s){\\n        if(mp.count(s)) return mp[s];\\n        if(s.size()>1 and s[0]==\\'0\\' and s.back()==\\'0\\') return {};\\n        if(s.back()==\\'0\\'){\\n            mp[s]={s};\\n            return mp[s];\\n        }\\n        if(s[0]==\\'0\\'){\\n            string tmp=s.substr(0,1)+\\'.\\'+s.substr(1);\\n            mp[s]={tmp};\\n            return mp[s];\\n        }\\n        for(int i=1;i<s.size();i++){\\n            string tmp=s.substr(0,i)+\\'.\\'+s.substr(i);\\n            mp[s].emplace_back(tmp);\\n        }\\n        mp[s].emplace_back(s);\\n        return mp[s];\\n    }\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> result;\\n        for(int i=1;i+2<s.size();i++){\\n            string pre=s.substr(1,i),suf=s.substr(i+1,s.size()-i-2);\\n            auto ss1=helper(pre);\\n            auto ss2=helper(suf);\\n            if(ss1.empty() or ss2.empty())  continue;\\n            for(auto&x:ss1) for(auto&y:ss2){\\n                    string tmp=\"(\"+x+\", \"+y+\")\";\\n                    result.emplace_back(tmp);\\n                }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574885,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cases(string &&s)\\n     {\\n    if (s.size() == 1) \\n        return {s};\\n    if (s.front() == \\'0\\') \\n    { \\n        if (s.back() == \\'0\\') \\n            return\\n             {\\n\\n             };\\n        return {\"0.\" + s.substr(1)}; \\n    }\\n    if (s.back() == \\'0\\') \\n        return \\n        {\\n            s\\n            };\\n    vector<string> res\\n    {\\n        s\\n        }; \\n    for (int i = 1; i < s.size(); i++)\\n        res.emplace_back(s.substr(0, i) + \".\" + s.substr(i));\\n    return res;\\n}\\nvector<string> ambiguousCoordinates(string S)\\n {\\n    vector<string> res;\\n    for (int i = 2; i < S.size() - 1; i++) \\n    for (auto &x : cases(S.substr(1, i - 1)))\\n    for (auto &y : cases(S.substr(i, S.size() - i - 1)))\\n        res.emplace_back(\"(\" + x + \", \" + y + \")\");\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cases(string &&s)\\n     {\\n    if (s.size() == 1) \\n        return {s};\\n    if (s.front() == \\'0\\') \\n    { \\n        if (s.back() == \\'0\\') \\n            return\\n             {\\n\\n             };\\n        return {\"0.\" + s.substr(1)}; \\n    }\\n    if (s.back() == \\'0\\') \\n        return \\n        {\\n            s\\n            };\\n    vector<string> res\\n    {\\n        s\\n        }; \\n    for (int i = 1; i < s.size(); i++)\\n        res.emplace_back(s.substr(0, i) + \".\" + s.substr(i));\\n    return res;\\n}\\nvector<string> ambiguousCoordinates(string S)\\n {\\n    vector<string> res;\\n    for (int i = 2; i < S.size() - 1; i++) \\n    for (auto &x : cases(S.substr(1, i - 1)))\\n    for (auto &y : cases(S.substr(i, S.size() - i - 1)))\\n        res.emplace_back(\"(\" + x + \", \" + y + \")\");\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573862,
                "title": "python3-ye-olde-one-liner",
                "content": "# Intuition\\nCuz why not?\\n\\n# Code\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        return [f\"({x}, {y})\" for d in [lambda n:  [x for x in [f\"{n[:i]}.{n[i:]}\".strip(\\'.\\') for i in range(1, len(n)+1)] if (\\'.\\' not in x or x[-1] != \\'0\\') and x[:2] != \\'00\\' and (x[0] != \\'0\\' or x[:2]==\\'0.\\' or len(x) == 1)]] for i in range(2, len(s)-1) for x in d(s[1:i]) for y in d(s[i:-1])]\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        return [f\"({x}, {y})\" for d in [lambda n:  [x for x in [f\"{n[:i]}.{n[i:]}\".strip(\\'.\\') for i in range(1, len(n)+1)] if (\\'.\\' not in x or x[-1] != \\'0\\') and x[:2] != \\'00\\' and (x[0] != \\'0\\' or x[:2]==\\'0.\\' or len(x) == 1)]] for i in range(2, len(s)-1) for x in d(s[1:i]) for y in d(s[i:-1])]\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393069,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func ambiguousCoordinates(_ s: String) -> [String] {\\n\\n        func lr(_ s: String) -> [(String, String)] {\\n            (1..<s.count).map { (String(s.prefix($0)), String(s.dropFirst($0))) }\\n        }\\n\\n        func opts(_ s: String) -> [String] {\\n            guard !s.hasPrefix(\"00\") || s.contains(where: { $0 != \"0\" }) else { return [] }\\n            guard !s.hasPrefix(\"0\") || !s.hasSuffix(\"0\") || s == \"0\" else { return [] }\\n            guard s.count > 1, !s.hasSuffix(\"0\") else { return [s] }\\n            guard !s.hasPrefix(\"0\") else { return [\"\\\\(0).\\\\(s.dropFirst())\"] }\\n            return [s] + lr(s).map { \"\\\\($0).\\\\($1)\" }\\n        }\\n        \\n        return lr(String(s.dropFirst().dropLast()))\\n            .map { (opts($0), opts($1)) }\\n            .filter { !$0.isEmpty && !$1.isEmpty }\\n            .flatMap { ls, rs in ls.flatMap { l in rs.map { r in \"(\\\\(l), \\\\(r))\" } } }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func ambiguousCoordinates(_ s: String) -> [String] {\\n\\n        func lr(_ s: String) -> [(String, String)] {\\n            (1..<s.count).map { (String(s.prefix($0)), String(s.dropFirst($0))) }\\n        }\\n\\n        func opts(_ s: String) -> [String] {\\n            guard !s.hasPrefix(\"00\") || s.contains(where: { $0 != \"0\" }) else { return [] }\\n            guard !s.hasPrefix(\"0\") || !s.hasSuffix(\"0\") || s == \"0\" else { return [] }\\n            guard s.count > 1, !s.hasSuffix(\"0\") else { return [s] }\\n            guard !s.hasPrefix(\"0\") else { return [\"\\\\(0).\\\\(s.dropFirst())\"] }\\n            return [s] + lr(s).map { \"\\\\($0).\\\\($1)\" }\\n        }\\n        \\n        return lr(String(s.dropFirst().dropLast()))\\n            .map { (opts($0), opts($1)) }\\n            .filter { !$0.isEmpty && !$1.isEmpty }\\n            .flatMap { ls, rs in ls.flatMap { l in rs.map { r in \"(\\\\(l), \\\\(r))\" } } }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355645,
                "title": "i-ruby",
                "content": "```ruby\\ndef ambiguous_coordinates s\\n    f = -> s do\\n        r, z = [s], s.size\\n        return r if z == 1\\n        return (s[/^0/] ? [] : r) if s[/0$/]\\n        return [\\'0.\\' + s[1..]] if s[/^0/]\\n        (1...z).reduce(r) { _1 << s.clone.insert(_2, ?.) }\\n    end\\n    (1...(s = s[1..-2]).size).flat_map do | i |\\n        f.(s[...i]).product(f.(s[i..])).map do\\n            \"(#{_1.first}, #{_1.last})\"\\n        end\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef ambiguous_coordinates s\\n    f = -> s do\\n        r, z = [s], s.size\\n        return r if z == 1\\n        return (s[/^0/] ? [] : r) if s[/0$/]\\n        return [\\'0.\\' + s[1..]] if s[/^0/]\\n        (1...z).reduce(r) { _1 << s.clone.insert(_2, ?.) }\\n    end\\n    (1...(s = s[1..-2]).size).flat_map do | i |\\n        f.(s[...i]).product(f.(s[i..])).map do\\n            \"(#{_1.first}, #{_1.last})\"\\n        end\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3351264,
                "title": "c",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<string>splits(string s){\\n        if(s.size() == 0)\\n            return {} ;\\n        if(s.size() > 1 && s[0] == \\'0\\' && s.back() == \\'0\\')\\n            return {} ;\\n        if(s.back() == \\'0\\')\\n            return {s} ;\\n        if(s.front() == \\'0\\')\\n            return {\"0.\" + s.substr(1)} ;\\n        \\n        vector<string>ret ;\\n        ret.push_back(s) ;\\n        for(int i = 1; i < s.size(); i++){\\n            ret.push_back(s.substr(0, i) + \".\" + s.substr(i)) ;\\n        }\\n        return ret ;\\n    }\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string>ret ;\\n        s = s.substr(1, s.size()-2) ;\\n        for(int i = 1; i < s.size(); i++){\\n            for(auto& x : splits(s.substr(0, i))){\\n                for(auto& y : splits(s.substr(i))){\\n                    ret.push_back(\"(\" + x + \", \" + y +\")\" ) ;\\n                }\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<string>splits(string s){\\n        if(s.size() == 0)\\n            return {} ;\\n        if(s.size() > 1 && s[0] == \\'0\\' && s.back() == \\'0\\')\\n            return {} ;\\n        if(s.back() == \\'0\\')\\n            return {s} ;\\n        if(s.front() == \\'0\\')\\n            return {\"0.\" + s.substr(1)} ;\\n        \\n        vector<string>ret ;\\n        ret.push_back(s) ;\\n        for(int i = 1; i < s.size(); i++){\\n            ret.push_back(s.substr(0, i) + \".\" + s.substr(i)) ;\\n        }\\n        return ret ;\\n    }\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string>ret ;\\n        s = s.substr(1, s.size()-2) ;\\n        for(int i = 1; i < s.size(); i++){\\n            for(auto& x : splits(s.substr(0, i))){\\n                for(auto& y : splits(s.substr(i))){\\n                    ret.push_back(\"(\" + x + \", \" + y +\")\" ) ;\\n                }\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306935,
                "title": "python-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\n2D coordinate has two values\\n1. enumerate all of the ways to split the string in two substring\\n2. enumerate all of the values which the substring can be turned into\\n3. do the `prodcut` of two value sets\\n\\'\\'\\'\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        def getNums(sub):\\n            ans = []\\n            leng = len(sub)\\n            for i in range(1, leng+1):\\n                l = sub[:i]\\n                r = sub[i:]\\n                if (l[0] != \\'0\\' or l == \\'0\\') and (len(r) == 0 or r[-1] != \\'0\\'):\\n                    ans.append(l + (\\'.\\' if len(r) > 0 else \\'\\') + r)\\n            return ans\\n        ans = []\\n        for i in range(1, len(s)):\\n            for sub1 in getNums(s[:i]):\\n                for sub2 in getNums(s[i:]):\\n                    ans.append(\\'({}, {})\\'.format(sub1, sub2))\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\\'\\'\\'\\n2D coordinate has two values\\n1. enumerate all of the ways to split the string in two substring\\n2. enumerate all of the values which the substring can be turned into\\n3. do the `prodcut` of two value sets\\n\\'\\'\\'\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        def getNums(sub):\\n            ans = []\\n            leng = len(sub)\\n            for i in range(1, leng+1):\\n                l = sub[:i]\\n                r = sub[i:]\\n                if (l[0] != \\'0\\' or l == \\'0\\') and (len(r) == 0 or r[-1] != \\'0\\'):\\n                    ans.append(l + (\\'.\\' if len(r) > 0 else \\'\\') + r)\\n            return ans\\n        ans = []\\n        for i in range(1, len(s)):\\n            for sub1 in getNums(s[:i]):\\n                for sub2 in getNums(s[i:]):\\n                    ans.append(\\'({}, {})\\'.format(sub1, sub2))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971696,
                "title": "swift-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBacktracking\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ne.g. `(123)`\\n1. Remove brackets first\\n2. Collect LHS e.g. `1, 1, 1.2, 12`\\n3. Collect RHS e.g. `2.3, 23, 3, 3`\\n3. Combine them \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n . 2^(p-1))\\nn partition options and each partition can have 2^p-1 option to place \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) + O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func ambiguousCoordinates(_ s: String) -> [String] {\\n        var string = s\\n        string.removeFirst()\\n        string.removeLast()\\n\\n        var lefts = [String]()\\n        var rights = [String]()\\n        var result = [String]()\\n\\n        for i in 0..<string.count - 1 {\\n            lefts = f(string, 0, i) // Extract lefts only e.g. 1, 1.2, 12\\n            rights = f(string, i + 1, string.count - 1) // Extract right only e.g. 2.3, 23, 3\\n\\n            for left in lefts {\\n                for right in rights {\\n                    let temp = \"(\\\\(left), \\\\(right))\"\\n                    result.append(temp)\\n                }\\n            }\\n        }\\n        return result\\n    }\\n\\n    private func f(_ s: String, _ i: Int, _ j: Int) -> [String] {\\n        var result = [String]()\\n        \\n        for x in i...j {\\n            var left = String()\\n            var right = String()\\n            \\n            if x == j {\\n                left = s.getSubstring(i, j)\\n                right = String()\\n            } else {\\n                left = s.getSubstring(i, x)\\n                right = s.getSubstring(x + 1, j)\\n            }\\n\\n            if !(left.count > 1 && left.first! == \"0\") { // Edge case Left = 01 Right = 23 \\n                if right.isEmpty {\\n                    result.append(left)\\n                } else {\\n                    var temp = left\\n                    temp.append(\".\")\\n                    temp.append(right)\\n\\n                    if temp.last! != \"0\" { // Edge case temp = 1.0\\n                        result.append(temp)\\n                    } \\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n\\nextension String {\\n    subscript (_ at: Int) -> Self {\\n        return String( self[index(startIndex, offsetBy: at)] )\\n    }\\n\\n    func getSubstring(_ from: Int, _ to: Int) -> Self {\\n        let start = index(startIndex, offsetBy: from)\\n        let end = index(startIndex, offsetBy: to)\\n        let stringSubsequence = self[start...end]\\n        return String(stringSubsequence)\\n    }\\n}\\n```\\n\\n# Reference\\n* https://leetcode.com/problems/ambiguous-coordinates/solutions/1207736/swift-solution-with-explanation/?orderBy=most_votes&languageTags=swift",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func ambiguousCoordinates(_ s: String) -> [String] {\\n        var string = s\\n        string.removeFirst()\\n        string.removeLast()\\n\\n        var lefts = [String]()\\n        var rights = [String]()\\n        var result = [String]()\\n\\n        for i in 0..<string.count - 1 {\\n            lefts = f(string, 0, i) // Extract lefts only e.g. 1, 1.2, 12\\n            rights = f(string, i + 1, string.count - 1) // Extract right only e.g. 2.3, 23, 3\\n\\n            for left in lefts {\\n                for right in rights {\\n                    let temp = \"(\\\\(left), \\\\(right))\"\\n                    result.append(temp)\\n                }\\n            }\\n        }\\n        return result\\n    }\\n\\n    private func f(_ s: String, _ i: Int, _ j: Int) -> [String] {\\n        var result = [String]()\\n        \\n        for x in i...j {\\n            var left = String()\\n            var right = String()\\n            \\n            if x == j {\\n                left = s.getSubstring(i, j)\\n                right = String()\\n            } else {\\n                left = s.getSubstring(i, x)\\n                right = s.getSubstring(x + 1, j)\\n            }\\n\\n            if !(left.count > 1 && left.first! == \"0\") { // Edge case Left = 01 Right = 23 \\n                if right.isEmpty {\\n                    result.append(left)\\n                } else {\\n                    var temp = left\\n                    temp.append(\".\")\\n                    temp.append(right)\\n\\n                    if temp.last! != \"0\" { // Edge case temp = 1.0\\n                        result.append(temp)\\n                    } \\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n\\nextension String {\\n    subscript (_ at: Int) -> Self {\\n        return String( self[index(startIndex, offsetBy: at)] )\\n    }\\n\\n    func getSubstring(_ from: Int, _ to: Int) -> Self {\\n        let start = index(startIndex, offsetBy: from)\\n        let end = index(startIndex, offsetBy: to)\\n        let stringSubsequence = self[start...end]\\n        return String(stringSubsequence)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949735,
                "title": "kotlin-implementation",
                "content": "# Approach\\n- Ignore leading & tailing braces by limiting the index range\\n- Split remaining string into 2 chunks of at least 1 character\\n- Get all possible number configurations for each chunk\\n    - Split number string at each possible decimal-point location\\n    - If both chunks are valid, add to possible configurations\\n    - First chunk\\n        - Invalid, if more than 1 leading \\'0\\'s\\n        - Invalid, if 1 leading \\'0\\' and length more than 1\\n    - Second chunk (may be of length 0)\\n        - Invalid if more than 0 tailing \\'0\\'s\\n- Zip those for both chunks (all permutations)\\n\\n# Code\\n```\\nclass Solution {\\n    private fun leadingZeros(v: String): Int {\\n        var leadingZeros = 0\\n        while(leadingZeros < v.length && v[leadingZeros] == \\'0\\') leadingZeros++\\n        return leadingZeros\\n    }\\n    private fun tailingZeros(v: String): Int {\\n        var tailingZeros = 0\\n        while(tailingZeros < v.length && v[v.lastIndex - tailingZeros] == \\'0\\') tailingZeros++\\n        return tailingZeros\\n    }\\n    private fun allValuesOf(n: String): List<String> {\\n        val values = mutableListOf<String>()\\n        for(decimalPointIndex in 1 .. n.length) {\\n            val first = n.substring(0, decimalPointIndex)\\n            val fl0 = leadingZeros(first)\\n            if(fl0 >= 2 || fl0 != 0 && first.length != 1) continue\\n            values += if(decimalPointIndex != n.length) {\\n                val second = n.substring(decimalPointIndex)\\n                if(tailingZeros(second) != 0) continue\\n                \"$first.$second\"\\n            } else first\\n        }\\n        return values\\n    }\\n    fun ambiguousCoordinates(s: String): List<String> {\\n        val result = mutableListOf<String>()\\n        for(breakpoint in 2 .. s.lastIndex - 1) {\\n            val firstValues = allValuesOf(s.substring(1, breakpoint))\\n            val secondValues = allValuesOf(s.substring(breakpoint, s.lastIndex))\\n\\n            for(first in firstValues)\\n                for(second in secondValues)\\n                    result += \"($first, $second)\"\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    private fun leadingZeros(v: String): Int {\\n        var leadingZeros = 0\\n        while(leadingZeros < v.length && v[leadingZeros] == \\'0\\') leadingZeros++\\n        return leadingZeros\\n    }\\n    private fun tailingZeros(v: String): Int {\\n        var tailingZeros = 0\\n        while(tailingZeros < v.length && v[v.lastIndex - tailingZeros] == \\'0\\') tailingZeros++\\n        return tailingZeros\\n    }\\n    private fun allValuesOf(n: String): List<String> {\\n        val values = mutableListOf<String>()\\n        for(decimalPointIndex in 1 .. n.length) {\\n            val first = n.substring(0, decimalPointIndex)\\n            val fl0 = leadingZeros(first)\\n            if(fl0 >= 2 || fl0 != 0 && first.length != 1) continue\\n            values += if(decimalPointIndex != n.length) {\\n                val second = n.substring(decimalPointIndex)\\n                if(tailingZeros(second) != 0) continue\\n                \"$first.$second\"\\n            } else first\\n        }\\n        return values\\n    }\\n    fun ambiguousCoordinates(s: String): List<String> {\\n        val result = mutableListOf<String>()\\n        for(breakpoint in 2 .. s.lastIndex - 1) {\\n            val firstValues = allValuesOf(s.substring(1, breakpoint))\\n            val secondValues = allValuesOf(s.substring(breakpoint, s.lastIndex))\\n\\n            for(first in firstValues)\\n                for(second in secondValues)\\n                    result += \"($first, $second)\"\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939247,
                "title": "python3-concise-solution-beats-99",
                "content": "# Algo\\nThe key is to deal with extraneous zeros. Below rule gives the what\\'s required\\n\\n1. if a string has length 1, return it;\\n2. if a string with length larger than 1 and starts and ends with 0, it cannot contain valid number;\\n3. if a string starts with 0, return 0.xxx;\\n4. if a string ends with 0, return xxx0;\\n5. otherwise, put decimal point in the n-1 places.\\n\\n# Code\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s.strip(\"(\").strip(\")\")\\n        \\n        def fn(s): \\n            \"\"\"Return valid numbers from s.\"\"\"\\n            if len(s) == 1: return [s]\\n            if s.startswith(\"0\") and s.endswith(\"0\"): return []\\n            if s.startswith(\"0\"): return [s[:1] + \".\" + s[1:]]\\n            if s.endswith(\"0\"): return [s]\\n            return [s[:i] + \".\" + s[i:] for i in range(1, len(s))] + [s]\\n        \\n        ans = []\\n        for i in range(1, len(s)): \\n            for x in fn(s[:i]):\\n                for y in fn(s[i:]): \\n                    ans.append(f\"({x}, {y})\")\\n        return ans  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s.strip(\"(\").strip(\")\")\\n        \\n        def fn(s): \\n            \"\"\"Return valid numbers from s.\"\"\"\\n            if len(s) == 1: return [s]\\n            if s.startswith(\"0\") and s.endswith(\"0\"): return []\\n            if s.startswith(\"0\"): return [s[:1] + \".\" + s[1:]]\\n            if s.endswith(\"0\"): return [s]\\n            return [s[:i] + \".\" + s[i:] for i in range(1, len(s))] + [s]\\n        \\n        ans = []\\n        for i in range(1, len(s)): \\n            for x in fn(s[:i]):\\n                for y in fn(s[i:]): \\n                    ans.append(f\"({x}, {y})\")\\n        return ans  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2922878,
                "title": "python3-iterative-with-regex",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First, split the input into two numbers with a comma at every valid index. \\n    - e.g. `1234 -> (1, 234), (12, 34), (1,234)`\\n- For each of those pairs of numbers, further split each number with a period at every valid index.\\n    - e.g. `(12,34) -> (12, 34), (1.2, 34), (1.2, 3.4), (12,3.4)`\\n- Check if both numbers are valid (have no zeroes where there shouldn\\'t be)\\n    - e.g. `100 -> (10, 0) -> (1.0, 0)X, (10, 0)OK -> [(10, 0)]` \\n\\nFiguring out the regexes was nasty here. On an interview I definitely would have run out of time. \\n\\n# Code\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\n        # remove the parentheses \\n        num = s[1:-1] \\n        # split the number at every index into tuples\\n        # e.g \\'123\\' -> (1, 23) , (12, 3)\\n        comma_split = [(num[:i] , num[i:]) for i in range(1, len(num))]\\n\\n        def num_ok(*args):\\n            # checks number(s) are valid\\n            for n in args:\\n                # reject nums with zeroes after \\'.\\' and 0 or more digits, OR leading zeroes before one \\'0\\' or one or more nonzero digits\\n                if re.search(\"\\\\.[0-9]*0+$\", n) or re.search(\"^0+(0|[1-9]+)\\\\.?\", n):\\n                    return False\\n            return True\\n\\n        ans = []\\n        # algo: \\n        # split the first number with a period at every valid index: 123 -> 123, 1.23, 12.3 (not .123 or 123.)\\n        # do the same for the second number\\n        # check if the numbers produced are valid \\n        # if so, add every combination to answer\\n        for n1, n2 in comma_split:\\n            for i in range(len(n1)):\\n                # split the first number with a period at all indices\\n                n1s = n1[:i]+\\'.\\'+n1[i:] if i > 0 else n1\\n                for j in range(len(n2)):\\n                    # split the second number with a period at all indices\\n                    n2s = n2[:j]+\\'.\\'+n2[j:] if j > 0 else n2\\n                    if num_ok(n1s, n2s):\\n                        # check validity\\n                        ans.append((n1s, n2s))\\n                    \\n        for i, (n1, n2) in enumerate(ans):\\n            # formatting nonsense\\n            ans[i] = \\'(\\' + n1 + \\', \\' + n2 +\\')\\'\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\n        # remove the parentheses \\n        num = s[1:-1] \\n        # split the number at every index into tuples\\n        # e.g \\'123\\' -> (1, 23) , (12, 3)\\n        comma_split = [(num[:i] , num[i:]) for i in range(1, len(num))]\\n\\n        def num_ok(*args):\\n            # checks number(s) are valid\\n            for n in args:\\n                # reject nums with zeroes after \\'.\\' and 0 or more digits, OR leading zeroes before one \\'0\\' or one or more nonzero digits\\n                if re.search(\"\\\\.[0-9]*0+$\", n) or re.search(\"^0+(0|[1-9]+)\\\\.?\", n):\\n                    return False\\n            return True\\n\\n        ans = []\\n        # algo: \\n        # split the first number with a period at every valid index: 123 -> 123, 1.23, 12.3 (not .123 or 123.)\\n        # do the same for the second number\\n        # check if the numbers produced are valid \\n        # if so, add every combination to answer\\n        for n1, n2 in comma_split:\\n            for i in range(len(n1)):\\n                # split the first number with a period at all indices\\n                n1s = n1[:i]+\\'.\\'+n1[i:] if i > 0 else n1\\n                for j in range(len(n2)):\\n                    # split the second number with a period at all indices\\n                    n2s = n2[:j]+\\'.\\'+n2[j:] if j > 0 else n2\\n                    if num_ok(n1s, n2s):\\n                        # check validity\\n                        ans.append((n1s, n2s))\\n                    \\n        for i, (n1, n2) in enumerate(ans):\\n            # formatting nonsense\\n            ans[i] = \\'(\\' + n1 + \\', \\' + n2 +\\')\\'\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889745,
                "title": "c-iterative-solution-14ms",
                "content": "# Intuition\\n- actually we divided string into two part left and right and add  `.` into each position of left and right string. and making combinations of that strings. \\n```  \\n if(s1[0] != \\'0\\' || s1 == \"0\") a.push_back(s1);\\n``` \\n- above condition used for checking any leading zero present or not in string\\n```\\n if(flag || sub2[sub2.size() - 1] == \\'0\\') continue;\\n```\\n- above condition used for checking string contains all zero\\'s or also check last char is zero or not if condition true then this string is invalid for making combinations with left string. e.g `\\nsuppose left str = 34 and right str = 000 or 450 so whole string is 34.000 or 34.450 and that strings are invalid`\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n     -- $$O(n*n)$$. n = length of string\\n\\n- Space complexity:\\n    -- $$O(n*n)$$. n = length of string\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.size();\\n        string t = s.substr(1, n-2);\\n        int m = t.size();\\n\\n        vector<string> v;\\n        for(int j = 0; j < m - 1; j++) {\\n            string s1 = t.substr(0, j+1), s2 =t.substr(j+1, m-1-j);\\n            vector<string> a, b;\\n\\n            if(s1[0] != \\'0\\' || s1 == \"0\") a.push_back(s1);\\n            if(s2[0] != \\'0\\' || s2 == \"0\") b.push_back(s2);\\n\\n\\n            for(int k = 0; k < s1.size() - 1; k++) {\\n                bool flag = true;\\n                string sub1 = s1.substr(0, k+1), sub2 = s1.substr(k+1, s1.size() - 1 - k);\\n\\n                for(int i = 0; i < sub2.size(); i++) {\\n                    if(sub2[i] != \\'0\\') flag = false;\\n                }\\n                if(flag || sub2[sub2.size() - 1] == \\'0\\') continue;\\n\\n                string str = sub1 + \".\" + sub2;\\n\\n                if(str[0] ==\\'0\\' && str[1] != \\'.\\') continue;\\n                a.push_back(str);\\n            }\\n\\n            for(int k = 0; k < s2.size() - 1; k++) {\\n                bool flag = true;\\n                string sub1 = s2.substr(0, k+1), sub2 =  s2.substr(k+1, s2.size() - 1 - k);\\n\\n                for(int i = 0; i < sub2.size(); i++) {\\n                    if(sub2[i] != \\'0\\') flag = false;\\n                }\\n                if(flag || sub2[sub2.size() - 1] == \\'0\\') continue;\\n\\n                string str = sub1 + \".\" + sub2;\\n\\n                if(str[0] ==\\'0\\' && str[1] != \\'.\\') continue;\\n                b.push_back(str);\\n            }\\n            \\n            for(int i = 0; i < a.size(); i++) {\\n                for(int k = 0; k < b.size(); k++) {\\n                    v.push_back(\"(\" + a[i] + \", \" + b[k] + \")\");\\n                }\\n            }\\n        }\\n    \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```  \\n if(s1[0] != \\'0\\' || s1 == \"0\") a.push_back(s1);\\n```\n```\\n if(flag || sub2[sub2.size() - 1] == \\'0\\') continue;\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.size();\\n        string t = s.substr(1, n-2);\\n        int m = t.size();\\n\\n        vector<string> v;\\n        for(int j = 0; j < m - 1; j++) {\\n            string s1 = t.substr(0, j+1), s2 =t.substr(j+1, m-1-j);\\n            vector<string> a, b;\\n\\n            if(s1[0] != \\'0\\' || s1 == \"0\") a.push_back(s1);\\n            if(s2[0] != \\'0\\' || s2 == \"0\") b.push_back(s2);\\n\\n\\n            for(int k = 0; k < s1.size() - 1; k++) {\\n                bool flag = true;\\n                string sub1 = s1.substr(0, k+1), sub2 = s1.substr(k+1, s1.size() - 1 - k);\\n\\n                for(int i = 0; i < sub2.size(); i++) {\\n                    if(sub2[i] != \\'0\\') flag = false;\\n                }\\n                if(flag || sub2[sub2.size() - 1] == \\'0\\') continue;\\n\\n                string str = sub1 + \".\" + sub2;\\n\\n                if(str[0] ==\\'0\\' && str[1] != \\'.\\') continue;\\n                a.push_back(str);\\n            }\\n\\n            for(int k = 0; k < s2.size() - 1; k++) {\\n                bool flag = true;\\n                string sub1 = s2.substr(0, k+1), sub2 =  s2.substr(k+1, s2.size() - 1 - k);\\n\\n                for(int i = 0; i < sub2.size(); i++) {\\n                    if(sub2[i] != \\'0\\') flag = false;\\n                }\\n                if(flag || sub2[sub2.size() - 1] == \\'0\\') continue;\\n\\n                string str = sub1 + \".\" + sub2;\\n\\n                if(str[0] ==\\'0\\' && str[1] != \\'.\\') continue;\\n                b.push_back(str);\\n            }\\n            \\n            for(int i = 0; i < a.size(); i++) {\\n                for(int k = 0; k < b.size(); k++) {\\n                    v.push_back(\"(\" + a[i] + \", \" + b[k] + \")\");\\n                }\\n            }\\n        }\\n    \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867427,
                "title": "java-self-descriptive-codes-no-need-of-any-explanation",
                "content": "```\\nclass Solution {\\n    \\n    private List<String> coordinates;\\n    \\n    public Solution() {\\n        coordinates = new ArrayList<>();\\n    }\\n    \\n    public List<String> ambiguousCoordinates(String s) {\\n        s = s.substring(1, s.length() - 1); // remove left & right parenthesis\\n        // This part can be done recursively as well.\\n        for(int i = 1; i < s.length(); i += 1) {\\n            // Try every possible (x, y) type xs & ys\\n            String x = s.substring(0, i), y = s.substring(i);\\n            addValidCoordinates(x, y);\\n        }\\n        return coordinates;\\n    }\\n    \\n    \\n    private void addValidCoordinates(String x, String y) {\\n        List<String> dottedXs = addADot(x);\\n        List<String> dottedYs = addADot(y);\\n        for(String x_ : dottedXs) {\\n            if(isValidNumber(x_)) { \\n                for(String y_ : dottedYs) {\\n                    if(isValidNumber(y_)) {\\n                        coordinates.add(\"(\" + x_ + \", \" + y_ + \")\");\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    private List<String> addADot(String num) {\\n        List<String> dottedNums = new ArrayList<>();\\n        dottedNums.add(num); // add whole number itself\\n        for(int i = 1; i < num.length(); i += 1) {\\n            dottedNums.add(num.substring(0, i) + \".\" + num.substring(i));\\n        }\\n        return dottedNums;\\n    }\\n    \\n    /*\\n        If a coordinate\\'s x/y is valid: \\n        \\n        Type:1 dddd\\n        ----------\\n            + If doesn\\'t have dot, it should either be \"0\" OR\\n                cannot have leading zeros.\\n                \\n        Type:2 dd.dd\\n        ------------\\n            + If it has a dot, the first half(before dot) should either be \"0\" \\n                OR cannot have any leading zero(s).\\n                \\n       Type:3 dd.ddd (Actually can be added into the Type#2)\\n       -----------------------------------------------------\\n            + If it has a dot, first part doesn\\'t have any leading zero(s)\\n                then second half(after dot) cannot have trailing zero(s) as well.\\n    */\\n    private boolean isValidNumber(String num) {\\n        int dotIdx = num.indexOf(\".\");\\n        boolean isValid = false;\\n        // Type#1\\n        if(dotIdx == -1) {\\n            if(num.equals(\"0\") || num.charAt(0) != \\'0\\') isValid = true;\\n        } else {\\n            // Type#2, #3 \\n            String beforeDot = num.substring(0, dotIdx); \\n            String afterDot = num.substring(dotIdx + 1);\\n            if(beforeDot.equals(\"0\") || beforeDot.charAt(0) != \\'0\\') {\\n                if(afterDot.charAt(afterDot.length() - 1) != \\'0\\') {\\n                    // Both before & after dot is valid then only given number \\'num\\'\\n                    // is valid. Invalid, otherwise.\\n                    isValid = true;\\n                }\\n            }\\n        }\\n        return isValid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private List<String> coordinates;\\n    \\n    public Solution() {\\n        coordinates = new ArrayList<>();\\n    }\\n    \\n    public List<String> ambiguousCoordinates(String s) {\\n        s = s.substring(1, s.length() - 1); // remove left & right parenthesis\\n        // This part can be done recursively as well.\\n        for(int i = 1; i < s.length(); i += 1) {\\n            // Try every possible (x, y) type xs & ys\\n            String x = s.substring(0, i), y = s.substring(i);\\n            addValidCoordinates(x, y);\\n        }\\n        return coordinates;\\n    }\\n    \\n    \\n    private void addValidCoordinates(String x, String y) {\\n        List<String> dottedXs = addADot(x);\\n        List<String> dottedYs = addADot(y);\\n        for(String x_ : dottedXs) {\\n            if(isValidNumber(x_)) { \\n                for(String y_ : dottedYs) {\\n                    if(isValidNumber(y_)) {\\n                        coordinates.add(\"(\" + x_ + \", \" + y_ + \")\");\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    private List<String> addADot(String num) {\\n        List<String> dottedNums = new ArrayList<>();\\n        dottedNums.add(num); // add whole number itself\\n        for(int i = 1; i < num.length(); i += 1) {\\n            dottedNums.add(num.substring(0, i) + \".\" + num.substring(i));\\n        }\\n        return dottedNums;\\n    }\\n    \\n    /*\\n        If a coordinate\\'s x/y is valid: \\n        \\n        Type:1 dddd\\n        ----------\\n            + If doesn\\'t have dot, it should either be \"0\" OR\\n                cannot have leading zeros.\\n                \\n        Type:2 dd.dd\\n        ------------\\n            + If it has a dot, the first half(before dot) should either be \"0\" \\n                OR cannot have any leading zero(s).\\n                \\n       Type:3 dd.ddd (Actually can be added into the Type#2)\\n       -----------------------------------------------------\\n            + If it has a dot, first part doesn\\'t have any leading zero(s)\\n                then second half(after dot) cannot have trailing zero(s) as well.\\n    */\\n    private boolean isValidNumber(String num) {\\n        int dotIdx = num.indexOf(\".\");\\n        boolean isValid = false;\\n        // Type#1\\n        if(dotIdx == -1) {\\n            if(num.equals(\"0\") || num.charAt(0) != \\'0\\') isValid = true;\\n        } else {\\n            // Type#2, #3 \\n            String beforeDot = num.substring(0, dotIdx); \\n            String afterDot = num.substring(dotIdx + 1);\\n            if(beforeDot.equals(\"0\") || beforeDot.charAt(0) != \\'0\\') {\\n                if(afterDot.charAt(afterDot.length() - 1) != \\'0\\') {\\n                    // Both before & after dot is valid then only given number \\'num\\'\\n                    // is valid. Invalid, otherwise.\\n                    isValid = true;\\n                }\\n            }\\n        }\\n        return isValid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787784,
                "title": "python-solution-backtrack-faster-than-9-time-o-2-n-space-o-2-n",
                "content": "\\tclass Solution:\\n\\t\\tdef ambiguousCoordinates(self, s: str) -> List[str]:\\n\\t\\t\\ts_list = list(s[1:-1])\\n\\t\\t\\ts_list_len = len(s_list)\\n\\t\\t\\tres = list()\\n\\t\\t\\tif s_list_len < 2: \\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif s_list_len == 2: \\n\\t\\t\\t\\ts_list.insert(1, \\', \\')\\n\\t\\t\\t\\tres.append(\\'(\\' + \\'\\'.join(s_list) + \\')\\')\\n\\t\\t\\t\\treturn res\\n\\n\\t\\t\\tdef is_valid_integer(nums_list):\\n\\t\\t\\t\\tnums_list_len = len(nums_list)\\n\\t\\t\\t\\tif nums_list_len>1 and nums_list[0]==\\'0\\':\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\treturn True    \\n\\n\\t\\t\\tdef is_valid_decimal(nums_list):\\n\\t\\t\\t\\t# print(\"nums: \", nums_list)\\n\\t\\t\\t\\tif nums_list[-1]==\\'0\\':\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tfor idx in range(1, s_list_len):\\n\\t\\t\\t\\ts_list.insert(idx, \\', \\')\\n\\t\\t\\t\\tfirst_part = s_list[:idx]\\n\\t\\t\\t\\tsecond_part = s_list[idx+1:]\\n\\t\\t\\t\\tfirst_part_len = len(first_part)\\n\\t\\t\\t\\tsecond_part_len = len(second_part)\\n\\t\\t\\t\\t# print(first_part, \\', \\', second_part)\\n\\t\\t\\t\\tif is_valid_integer(first_part) and is_valid_integer(second_part): \\n\\t\\t\\t\\t\\tres.append(\\'(\\' + \\'\\'.join(first_part) + \\', \\' + \\'\\'.join(second_part) + \\')\\')\\n\\t\\t\\t\\tfor sdx in range(1, second_part_len): \\n\\t\\t\\t\\t\\tsecond_part.insert(sdx, \\'.\\')  \\n\\t\\t\\t\\t\\tsecond_part_integer = second_part[:sdx]\\n\\t\\t\\t\\t\\tsecond_part_decimal = second_part[sdx+1:]\\n\\t\\t\\t\\t\\t# print(\"second:\", second_part_integer, second_part_decimal)\\n\\n\\t\\t\\t\\t\\tif is_valid_integer(first_part) and is_valid_integer(second_part_integer) and is_valid_decimal(second_part_decimal): \\n\\t\\t\\t\\t\\t\\tres.append(\\'(\\' + \\'\\'.join(first_part) + \\', \\' + \\'\\'.join(second_part) + \\')\\')\\n\\t\\t\\t\\t\\tsecond_part.pop(sdx)  \\n\\n\\t\\t\\t\\tfor fdx in range(1, first_part_len):\\n\\t\\t\\t\\t\\tfirst_part.insert(fdx, \\'.\\')\\n\\t\\t\\t\\t\\tfirst_part_integer = first_part[:fdx]\\n\\t\\t\\t\\t\\tfirst_part_decimal = first_part[fdx+1:]\\n\\t\\t\\t\\t\\tif is_valid_integer(first_part_integer) and is_valid_decimal(first_part_decimal) and is_valid_integer(second_part): \\n\\t\\t\\t\\t\\t\\tres.append(\\'(\\' + \\'\\'.join(first_part) + \\', \\' + \\'\\'.join(second_part) + \\')\\')\\n\\t\\t\\t\\t\\tfirst_part.pop(fdx)    \\n\\n\\t\\t\\t\\tfor fdx in range(1, first_part_len): \\n\\t\\t\\t\\t\\tfirst_part.insert(fdx, \\'.\\')\\n\\t\\t\\t\\t\\tfirst_part_integer = first_part[:fdx]\\n\\t\\t\\t\\t\\tfirst_part_decimal = first_part[fdx+1:]\\n\\t\\t\\t\\t\\tfor sdx in range(1, second_part_len): \\n\\t\\t\\t\\t\\t\\tsecond_part.insert(sdx, \\'.\\')\\n\\t\\t\\t\\t\\t\\tsecond_part_integer = second_part[:sdx]\\n\\t\\t\\t\\t\\t\\tsecond_part_decimal = second_part[sdx+1:]\\n\\t\\t\\t\\t\\t\\tif is_valid_integer(first_part_integer) and is_valid_decimal(first_part_decimal) and is_valid_integer(second_part_integer) and is_valid_decimal(second_part_decimal): \\n\\t\\t\\t\\t\\t\\t\\tres.append(\\'(\\' + \\'\\'.join(first_part) + \\', \\' + \\'\\'.join(second_part) + \\')\\')\\n\\t\\t\\t\\t\\t\\tsecond_part.pop(sdx)     \\n\\t\\t\\t\\t\\tfirst_part.pop(fdx)   \\n\\t\\t\\t\\ts_list.pop(idx)    \\n\\t\\t\\treturn res        \\n\\n\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef ambiguousCoordinates(self, s: str) -> List[str]:\\n\\t\\t\\ts_list = list(s[1:-1])\\n\\t\\t\\ts_list_len = len(s_list)\\n\\t\\t\\tres = list()\\n\\t\\t\\tif s_list_len < 2: \\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif s_list_len == 2: \\n\\t\\t\\t\\ts_list.insert(1, \\', \\')\\n\\t\\t\\t\\tres.append(\\'(\\' + \\'\\'.join(s_list) + \\')\\')\\n\\t\\t\\t\\treturn res\\n\\n\\t\\t\\tdef is_valid_integer(nums_list):\\n\\t\\t\\t\\tnums_list_len = len(nums_list)\\n\\t\\t\\t\\tif nums_list_len>1 and nums_list[0]==\\'0\\':\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\treturn True    \\n\\n\\t\\t\\tdef is_valid_decimal(nums_list):\\n\\t\\t\\t\\t# print(\"nums: \", nums_list)\\n\\t\\t\\t\\tif nums_list[-1]==\\'0\\':\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tfor idx in range(1, s_list_len):\\n\\t\\t\\t\\ts_list.insert(idx, \\', \\')\\n\\t\\t\\t\\tfirst_part = s_list[:idx]\\n\\t\\t\\t\\tsecond_part = s_list[idx+1:]\\n\\t\\t\\t\\tfirst_part_len = len(first_part)\\n\\t\\t\\t\\tsecond_part_len = len(second_part)\\n\\t\\t\\t\\t# print(first_part, \\', \\', second_part)\\n\\t\\t\\t\\tif is_valid_integer(first_part) and is_valid_integer(second_part): \\n\\t\\t\\t\\t\\tres.append(\\'(\\' + \\'\\'.join(first_part) + \\', \\' + \\'\\'.join(second_part) + \\')\\')\\n\\t\\t\\t\\tfor sdx in range(1, second_part_len): \\n\\t\\t\\t\\t\\tsecond_part.insert(sdx, \\'.\\')  \\n\\t\\t\\t\\t\\tsecond_part_integer = second_part[:sdx]\\n\\t\\t\\t\\t\\tsecond_part_decimal = second_part[sdx+1:]\\n\\t\\t\\t\\t\\t# print(\"second:\", second_part_integer, second_part_decimal)\\n\\n\\t\\t\\t\\t\\tif is_valid_integer(first_part) and is_valid_integer(second_part_integer) and is_valid_decimal(second_part_decimal): \\n\\t\\t\\t\\t\\t\\tres.append(\\'(\\' + \\'\\'.join(first_part) + \\', \\' + \\'\\'.join(second_part) + \\')\\')\\n\\t\\t\\t\\t\\tsecond_part.pop(sdx)  \\n\\n\\t\\t\\t\\tfor fdx in range(1, first_part_len):\\n\\t\\t\\t\\t\\tfirst_part.insert(fdx, \\'.\\')\\n\\t\\t\\t\\t\\tfirst_part_integer = first_part[:fdx]\\n\\t\\t\\t\\t\\tfirst_part_decimal = first_part[fdx+1:]\\n\\t\\t\\t\\t\\tif is_valid_integer(first_part_integer) and is_valid_decimal(first_part_decimal) and is_valid_integer(second_part): \\n\\t\\t\\t\\t\\t\\tres.append(\\'(\\' + \\'\\'.join(first_part) + \\', \\' + \\'\\'.join(second_part) + \\')\\')\\n\\t\\t\\t\\t\\tfirst_part.pop(fdx)    \\n\\n\\t\\t\\t\\tfor fdx in range(1, first_part_len): \\n\\t\\t\\t\\t\\tfirst_part.insert(fdx, \\'.\\')\\n\\t\\t\\t\\t\\tfirst_part_integer = first_part[:fdx]\\n\\t\\t\\t\\t\\tfirst_part_decimal = first_part[fdx+1:]\\n\\t\\t\\t\\t\\tfor sdx in range(1, second_part_len): \\n\\t\\t\\t\\t\\t\\tsecond_part.insert(sdx, \\'.\\')\\n\\t\\t\\t\\t\\t\\tsecond_part_integer = second_part[:sdx]\\n\\t\\t\\t\\t\\t\\tsecond_part_decimal = second_part[sdx+1:]\\n\\t\\t\\t\\t\\t\\tif is_valid_integer(first_part_integer) and is_valid_decimal(first_part_decimal) and is_valid_integer(second_part_integer) and is_valid_decimal(second_part_decimal): \\n\\t\\t\\t\\t\\t\\t\\tres.append(\\'(\\' + \\'\\'.join(first_part) + \\', \\' + \\'\\'.join(second_part) + \\')\\')\\n\\t\\t\\t\\t\\t\\tsecond_part.pop(sdx)     \\n\\t\\t\\t\\t\\tfirst_part.pop(fdx)   \\n\\t\\t\\t\\ts_list.pop(idx)    \\n\\t\\t\\treturn res        \\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2786263,
                "title": "python-clear-explained-clean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDivide it into sub problems:\\n - split left hand side and right hand side (123 | 456)\\n - split the \\'.\\' (123, 1.23, 12.3)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNested for loops\\n```\\nfor (lhs, rhs):\\n    for comb(lhs):\\n        for comb(rhs):\\n            add to output\\n# 3 loops => very likely in O(n^3)\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N<sup>3</sup>)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N<sup>3</sup>)\\n# Code\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\n        def possibleSplit(inputStr):\\n            # integer (no leading zeros or \\'0\\' itself)\\n            output = [inputStr] if inputStr[0] != \\'0\\' or inputStr == \\'0\\' else []\\n            # float\\n            for i in range(1, len(inputStr)):\\n                digit, decimal = inputStr[:i], inputStr[i:]\\n                # checking digit (left extra zeros)\\n                if len(digit) >= 2 and digit[0] == \\'0\\':\\n                    break\\n                # checking decimal (right extra zeros)\\n                if decimal[-1] == \\'0\\':\\n                    break\\n                output.append(f\\'{digit}.{decimal}\\')\\n            return output\\n        \\n        numStr = s[1:-1]\\n        output = []\\n        for i in range(1, len(numStr)):\\n            for x in possibleSplit(numStr[:i]):\\n                for y in possibleSplit(numStr[i:]):\\n                    output.append(f\\'({x}, {y})\\')\\n\\n        return output\\n\\n \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfor (lhs, rhs):\\n    for comb(lhs):\\n        for comb(rhs):\\n            add to output\\n# 3 loops => very likely in O(n^3)\\n```\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\n        def possibleSplit(inputStr):\\n            # integer (no leading zeros or \\'0\\' itself)\\n            output = [inputStr] if inputStr[0] != \\'0\\' or inputStr == \\'0\\' else []\\n            # float\\n            for i in range(1, len(inputStr)):\\n                digit, decimal = inputStr[:i], inputStr[i:]\\n                # checking digit (left extra zeros)\\n                if len(digit) >= 2 and digit[0] == \\'0\\':\\n                    break\\n                # checking decimal (right extra zeros)\\n                if decimal[-1] == \\'0\\':\\n                    break\\n                output.append(f\\'{digit}.{decimal}\\')\\n            return output\\n        \\n        numStr = s[1:-1]\\n        output = []\\n        for i in range(1, len(numStr)):\\n            for x in possibleSplit(numStr[:i]):\\n                for y in possibleSplit(numStr[i:]):\\n                    output.append(f\\'({x}, {y})\\')\\n\\n        return output\\n\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766104,
                "title": "c-annoying-question-with-annoying-code",
                "content": "Simple idea, just be careful of syntax errors... if any.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> res = {};\\n    string createResult(string l, string r) {\\n        return \"(\" + l + \", \" + r + \")\"; \\n    }\\n    string createDouble(string raw, int didx) {\\n        string res = \"\";\\n        res = raw.substr(0, didx + 1) + \".\" + raw.substr(didx + 1, raw.length() - didx - 1);\\n        return res;\\n    }\\n    void ckRightThenAppend(string ls, string rs, int rsl) {\\n        if (rsl == 1) {\\n            res.push_back(createResult(ls, rs));\\n        }\\n        else {\\n            if (rs[0] == \\'0\\') {\\n                if (rs[rsl - 1] == \\'0\\') {\\n                    \\n                }\\n                else {\\n                    res.push_back(createResult(ls, createDouble(rs, 0)));\\n                }\\n            }\\n            else {\\n                res.push_back(createResult(ls, rs));\\n                if (rs[rsl - 1] == \\'0\\') {\\n                    \\n                }\\n                else {\\n                    for (int i = 0; i < rsl - 1; i++) {\\n                         res.push_back(createResult(ls, createDouble(rs, i)));\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int len = s.length();\\n        string t = s.substr(1, (len - 2));\\n        len = t.length();\\n        for (int i = 0; i < len - 1; i++) {\\n            string ls = t.substr(0, (i + 1));\\n            string rs = t.substr((i + 1), (len - i - 1));\\n            int lsl = ls.length();\\n            int rsl = rs.length();\\n            string ltmp, rtmp;\\n            if (ls.length() == 1) {\\n                ckRightThenAppend(ls, rs, rsl);\\n            }\\n            else {\\n                if (ls[0] == \\'0\\') {\\n                    if (ls[lsl - 1] == \\'0\\') {\\n                        \\n                    }\\n                    else {\\n                        ltmp = createDouble(ls, 0);\\n                        ckRightThenAppend(ltmp, rs, rsl);\\n                    }\\n                }\\n                else {\\n                    ckRightThenAppend(ls, rs, rsl);\\n                    if (ls[lsl - 1] == \\'0\\') {\\n                        \\n                    }\\n                    else {\\n                        for (int i = 0; i < lsl - 1; i++) {\\n                            ltmp = createDouble(ls, i);\\n                            ckRightThenAppend(ltmp, rs, rsl);\\n                        }\\n                    }                    \\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> res = {};\\n    string createResult(string l, string r) {\\n        return \"(\" + l + \", \" + r + \")\"; \\n    }\\n    string createDouble(string raw, int didx) {\\n        string res = \"\";\\n        res = raw.substr(0, didx + 1) + \".\" + raw.substr(didx + 1, raw.length() - didx - 1);\\n        return res;\\n    }\\n    void ckRightThenAppend(string ls, string rs, int rsl) {\\n        if (rsl == 1) {\\n            res.push_back(createResult(ls, rs));\\n        }\\n        else {\\n            if (rs[0] == \\'0\\') {\\n                if (rs[rsl - 1] == \\'0\\') {\\n                    \\n                }\\n                else {\\n                    res.push_back(createResult(ls, createDouble(rs, 0)));\\n                }\\n            }\\n            else {\\n                res.push_back(createResult(ls, rs));\\n                if (rs[rsl - 1] == \\'0\\') {\\n                    \\n                }\\n                else {\\n                    for (int i = 0; i < rsl - 1; i++) {\\n                         res.push_back(createResult(ls, createDouble(rs, i)));\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int len = s.length();\\n        string t = s.substr(1, (len - 2));\\n        len = t.length();\\n        for (int i = 0; i < len - 1; i++) {\\n            string ls = t.substr(0, (i + 1));\\n            string rs = t.substr((i + 1), (len - i - 1));\\n            int lsl = ls.length();\\n            int rsl = rs.length();\\n            string ltmp, rtmp;\\n            if (ls.length() == 1) {\\n                ckRightThenAppend(ls, rs, rsl);\\n            }\\n            else {\\n                if (ls[0] == \\'0\\') {\\n                    if (ls[lsl - 1] == \\'0\\') {\\n                        \\n                    }\\n                    else {\\n                        ltmp = createDouble(ls, 0);\\n                        ckRightThenAppend(ltmp, rs, rsl);\\n                    }\\n                }\\n                else {\\n                    ckRightThenAppend(ls, rs, rsl);\\n                    if (ls[lsl - 1] == \\'0\\') {\\n                        \\n                    }\\n                    else {\\n                        for (int i = 0; i < lsl - 1; i++) {\\n                            ltmp = createDouble(ls, i);\\n                            ckRightThenAppend(ltmp, rs, rsl);\\n                        }\\n                    }                    \\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753546,
                "title": "divide-conquer-faster-than-70",
                "content": "\\tclass Solution:\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.ans=[]\\n\\n\\n\\t\\tdef checkCorrect(self,string):\\n\\n\\t\\t\\tif \\'.\\' not in string:\\n\\t\\t\\t\\tif(str(int(string))==string):\\n\\t\\t\\t\\t\\treturn string\\n\\t\\t\\t\\treturn \"\"\\n\\t\\t\\telse:\\n\\t\\t\\t\\tindex=-1\\n\\t\\t\\t\\tfor i in range(len(string)):\\n\\t\\t\\t\\t\\tif(string[i]==\\'.\\'):\\n\\t\\t\\t\\t\\t\\tindex=i\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\ts1=string[:index]\\n\\t\\t\\t\\ts2=string[index+1:]\\n\\n\\t\\t\\t\\tc=0\\n\\t\\t\\t\\tfor i in s1:\\n\\t\\t\\t\\t\\tif(i==\\'0\\'):\\n\\t\\t\\t\\t\\t\\tc+=1\\n\\n\\t\\t\\t\\tif(((c!=len(s1) and s1[0]!=\\'0\\') or (c==1 and len(s1)==1) or( c>1 and s1[0]!=\\'0\\')))  and s2[-1]!=\\'0\\':\\n\\t\\t\\t\\t\\treturn string\\n\\n\\t\\t\\t\\treturn \"\"\\n\\n\\n\\t\\tdef makeAnswer(self,string,index,ans,c,final):\\n\\t\\t\\tif(index==len(string)-1):\\n\\t\\t\\t\\tfor i in range(index,len(string)):\\n\\t\\t\\t\\t\\tans+=string[i]\\n\\n\\t\\t\\t\\tst=\"\"\\n\\t\\t\\t\\tfor i in ans:\\n\\t\\t\\t\\t\\tst+=i\\n\\n\\t\\t\\t\\tres=self.checkCorrect(st)\\n\\t\\t\\t\\tif(res!=\"\"):\\n\\t\\t\\t\\t\\tfinal.append(res)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\telif(c==0):\\n\\t\\t\\t\\tfor i in range(index,len(string)):\\n\\t\\t\\t\\t\\tans+=string[i]\\n\\t\\t\\t\\tst=\"\"\\n\\t\\t\\t\\tfor i in ans:\\n\\t\\t\\t\\t\\tst+=i\\n\\n\\t\\t\\t\\tres=self.checkCorrect(st)\\n\\t\\t\\t\\tif(res!=\"\"):\\n\\t\\t\\t\\t\\tfinal.append(res)\\n\\t\\t\\t\\treturn\\n\\n\\n\\t\\t\\tself.makeAnswer(string,index+1,ans+string[index]+\".\",c-1,final)\\n\\t\\t\\tself.makeAnswer(string,index+1,ans+string[index],c,final)\\n\\n\\t\\t\\treturn\\n\\n\\t\\tdef divideCon(self,string):\\n\\t\\t\\tans=[]\\n\\t\\t\\tfor i in range(2,len(string)-1):\\n\\n\\t\\t\\t\\ts1=string[:i]\\n\\t\\t\\t\\ts2=string[i:]\\n\\t\\t\\t\\ts1=s1[1:]\\n\\t\\t\\t\\ts2=s2[:-1]\\n\\t\\t\\t\\tl1=[]\\n\\t\\t\\t\\tl2=[]\\n\\t\\t\\t\\tself.makeAnswer(s1,0,\"\",1,l1)\\n\\t\\t\\t\\tself.makeAnswer(s2,0,\"\",1,l2)\\n\\n\\t\\t\\t\\tif(len(l1)!=0 and len(l2)!=0):\\n\\t\\t\\t\\t\\tfor i in l1:\\n\\t\\t\\t\\t\\t\\tfor j in l2:\\n\\t\\t\\t\\t\\t\\t\\tfg=\\'(\\'+i+\", \"+j+\")\"\\n\\t\\t\\t\\t\\t\\t\\tans.append(fg)\\n\\n\\t\\t\\treturn ans\\n\\n\\n\\t\\tdef ambiguousCoordinates(self, s: str) -> List[str]:\\n\\n\\t\\t\\treturn self.divideCon(s)\\n\\t\\t\\t\\n\\t\\t\\t\\n**Please Upvote**\\n\\ntraverse the string from 2 index, becoz we will always place a \\',\\' between 2 numbers.\\nThan try all combos for \\'.\\' in the first anf second string, and at last just arrange those strings.\\nThe imp work here is to validate that the string formed is valid or not, like\\nthere must be no continuous zeros before \\'.\\', etc etc. make sure that.",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.ans=[]\\n\\n\\n\\t\\tdef checkCorrect(self,string):\\n\\n\\t\\t\\tif \\'.\\' not in string:\\n\\t\\t\\t\\tif(str(int(string))==string):\\n\\t\\t\\t\\t\\treturn string\\n\\t\\t\\t\\treturn \"\"\\n\\t\\t\\telse:\\n\\t\\t\\t\\tindex=-1\\n\\t\\t\\t\\tfor i in range(len(string)):\\n\\t\\t\\t\\t\\tif(string[i]==\\'.\\'):\\n\\t\\t\\t\\t\\t\\tindex=i\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\ts1=string[:index]\\n\\t\\t\\t\\ts2=string[index+1:]\\n\\n\\t\\t\\t\\tc=0\\n\\t\\t\\t\\tfor i in s1:\\n\\t\\t\\t\\t\\tif(i==\\'0\\'):\\n\\t\\t\\t\\t\\t\\tc+=1\\n\\n\\t\\t\\t\\tif(((c!=len(s1) and s1[0]!=\\'0\\') or (c==1 and len(s1)==1) or( c>1 and s1[0]!=\\'0\\')))  and s2[-1]!=\\'0\\':\\n\\t\\t\\t\\t\\treturn string\\n\\n\\t\\t\\t\\treturn \"\"\\n\\n\\n\\t\\tdef makeAnswer(self,string,index,ans,c,final):\\n\\t\\t\\tif(index==len(string)-1):\\n\\t\\t\\t\\tfor i in range(index,len(string)):\\n\\t\\t\\t\\t\\tans+=string[i]\\n\\n\\t\\t\\t\\tst=\"\"\\n\\t\\t\\t\\tfor i in ans:\\n\\t\\t\\t\\t\\tst+=i\\n\\n\\t\\t\\t\\tres=self.checkCorrect(st)\\n\\t\\t\\t\\tif(res!=\"\"):\\n\\t\\t\\t\\t\\tfinal.append(res)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\telif(c==0):\\n\\t\\t\\t\\tfor i in range(index,len(string)):\\n\\t\\t\\t\\t\\tans+=string[i]\\n\\t\\t\\t\\tst=\"\"\\n\\t\\t\\t\\tfor i in ans:\\n\\t\\t\\t\\t\\tst+=i\\n\\n\\t\\t\\t\\tres=self.checkCorrect(st)\\n\\t\\t\\t\\tif(res!=\"\"):\\n\\t\\t\\t\\t\\tfinal.append(res)\\n\\t\\t\\t\\treturn\\n\\n\\n\\t\\t\\tself.makeAnswer(string,index+1,ans+string[index]+\".\",c-1,final)\\n\\t\\t\\tself.makeAnswer(string,index+1,ans+string[index],c,final)\\n\\n\\t\\t\\treturn\\n\\n\\t\\tdef divideCon(self,string):\\n\\t\\t\\tans=[]\\n\\t\\t\\tfor i in range(2,len(string)-1):\\n\\n\\t\\t\\t\\ts1=string[:i]\\n\\t\\t\\t\\ts2=string[i:]\\n\\t\\t\\t\\ts1=s1[1:]\\n\\t\\t\\t\\ts2=s2[:-1]\\n\\t\\t\\t\\tl1=[]\\n\\t\\t\\t\\tl2=[]\\n\\t\\t\\t\\tself.makeAnswer(s1,0,\"\",1,l1)\\n\\t\\t\\t\\tself.makeAnswer(s2,0,\"\",1,l2)\\n\\n\\t\\t\\t\\tif(len(l1)!=0 and len(l2)!=0):\\n\\t\\t\\t\\t\\tfor i in l1:\\n\\t\\t\\t\\t\\t\\tfor j in l2:\\n\\t\\t\\t\\t\\t\\t\\tfg=\\'(\\'+i+\", \"+j+\")\"\\n\\t\\t\\t\\t\\t\\t\\tans.append(fg)\\n\\n\\t\\t\\treturn ans\\n\\n\\n\\t\\tdef ambiguousCoordinates(self, s: str) -> List[str]:\\n\\n\\t\\t\\treturn self.divideCon(s)\\n\\t\\t\\t\\n\\t\\t\\t\\n**Please Upvote**\\n\\ntraverse the string from 2 index, becoz we will always place a \\',\\' between 2 numbers.\\nThan try all combos for \\'.\\' in the first anf second string, and at last just arrange those strings.\\nThe imp work here is to validate that the string formed is valid or not, like\\nthere must be no continuous zeros before \\'.\\', etc etc. make sure that.",
                "codeTag": "Java"
            },
            {
                "id": 2752463,
                "title": "explained-c",
                "content": "```\\nCan be done in two steps.\\nSeparate x and y coordinates in one step.\\nPlace decimal point in second step.\\nThe decimal can\\'t be placed when starting is with \\'0\\' and left part size is > 1\\nAlso when the last char is \\'0\\'.\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<string> sep(string s){\\n        int n = s.size();\\n        vector<string> ans;\\n\\t\\t// if size is 1 or starting is not with \\'0\\'\\n\\t\\t// we can take whole string is valid\\n        if(n == 1 || s[0] != \\'0\\') ans.push_back(s);\\n        for(int i=1; i<n; i++){\\n            string a = s.substr(0,i);\\n            string b = s.substr(i,n-i);\\n\\t\\t\\t// if size > 1 and starting is 0, invalid\\n            if(i > 1 && s[0] == \\'0\\') break;\\n\\t\\t\\t// if last index is 0, invalid\\n            if(s[n-1] == \\'0\\') break;\\n            string x = a + \".\" + b;\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.size();\\n        vector<string> ans;\\n        for(int i=1; i<n-2; i++){\\n\\t\\t\\t// first char is (, so start with 1\\n\\t\\t\\t// separate left and right part \\n\\t\\t\\t// apply decimal of both the parts\\n            vector<string> a = sep(s.substr(1,i));\\n            vector<string> b = sep(s.substr(i+1,n-2-i));\\n            for(auto i:a){\\n                for(auto j:b){\\n                    string x = \"(\" + i + \", \" + j + \")\";\\n                    ans.push_back(x);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nCan be done in two steps.\\nSeparate x and y coordinates in one step.\\nPlace decimal point in second step.\\nThe decimal can\\'t be placed when starting is with \\'0\\' and left part size is > 1\\nAlso when the last char is \\'0\\'.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> sep(string s){\\n        int n = s.size();\\n        vector<string> ans;\\n\\t\\t// if size is 1 or starting is not with \\'0\\'\\n\\t\\t// we can take whole string is valid\\n        if(n == 1 || s[0] != \\'0\\') ans.push_back(s);\\n        for(int i=1; i<n; i++){\\n            string a = s.substr(0,i);\\n            string b = s.substr(i,n-i);\\n\\t\\t\\t// if size > 1 and starting is 0, invalid\\n            if(i > 1 && s[0] == \\'0\\') break;\\n\\t\\t\\t// if last index is 0, invalid\\n            if(s[n-1] == \\'0\\') break;\\n            string x = a + \".\" + b;\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.size();\\n        vector<string> ans;\\n        for(int i=1; i<n-2; i++){\\n\\t\\t\\t// first char is (, so start with 1\\n\\t\\t\\t// separate left and right part \\n\\t\\t\\t// apply decimal of both the parts\\n            vector<string> a = sep(s.substr(1,i));\\n            vector<string> b = sep(s.substr(i+1,n-2-i));\\n            for(auto i:a){\\n                for(auto j:b){\\n                    string x = \"(\" + i + \", \" + j + \")\";\\n                    ans.push_back(x);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645114,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar ambiguousCoordinates = function(s) {\\n\\t\\tconst set = new Set();\\n\\t\\tconst getCoordinate = (str) => {\\n\\t\\t\\tif (str.length === 1) return [str];\\n\\t\\t\\tconst isStartZero = str.startsWith(\\'0\\');\\n\\t\\t\\tconst isEndZero = str.endsWith(\\'0\\');\\n\\t\\t\\tif (isStartZero && isEndZero) return;\\n\\t\\t\\tif (isStartZero && !isEndZero) return [`0.${str.slice(1)}`];\\n\\t\\t\\tif (isEndZero) return [str];\\n\\n\\t\\t\\tconst dot = [];\\n\\t\\t\\tfor (let index = 1; index < str.length; index++) {\\n\\t\\t\\t\\tconst reuslt = `${str.slice(0, index)}.${str.slice(index)}`;\\n\\t\\t\\t\\tdot.push(reuslt);\\n\\t\\t\\t}\\n\\t\\t\\treturn [str, ...dot];\\n\\t\\t};\\n\\n\\t\\ts = s.slice(1, -1);\\n\\n\\t\\tfor (let index = 0; index < s.length - 1; index++) {\\n\\t\\t\\tconst x = getCoordinate(s.slice(0, index + 1));\\n\\t\\t\\tconst y = getCoordinate(s.slice(index + 1));\\n\\t\\t\\tif (!x || !y) continue;\\n\\n\\t\\t\\tx.forEach(valueX => {\\n\\t\\t\\t\\ty.forEach(valueY => set.add(`(${valueX}, ${valueY})`));\\n\\t\\t\\t});\\n\\t\\t}\\n\\t\\treturn [...set];\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar ambiguousCoordinates = function(s) {\\n\\t\\tconst set = new Set();\\n\\t\\tconst getCoordinate = (str) => {\\n\\t\\t\\tif (str.length === 1) return [str];\\n\\t\\t\\tconst isStartZero = str.startsWith(\\'0\\');\\n\\t\\t\\tconst isEndZero = str.endsWith(\\'0\\');\\n\\t\\t\\tif (isStartZero && isEndZero) return;\\n\\t\\t\\tif (isStartZero && !isEndZero) return [`0.${str.slice(1)}`];\\n\\t\\t\\tif (isEndZero) return [str];\\n\\n\\t\\t\\tconst dot = [];\\n\\t\\t\\tfor (let index = 1; index < str.length; index++) {\\n\\t\\t\\t\\tconst reuslt = `${str.slice(0, index)}.${str.slice(index)}`;\\n\\t\\t\\t\\tdot.push(reuslt);\\n\\t\\t\\t}\\n\\t\\t\\treturn [str, ...dot];\\n\\t\\t};\\n\\n\\t\\ts = s.slice(1, -1);\\n\\n\\t\\tfor (let index = 0; index < s.length - 1; index++) {\\n\\t\\t\\tconst x = getCoordinate(s.slice(0, index + 1));\\n\\t\\t\\tconst y = getCoordinate(s.slice(index + 1));\\n\\t\\t\\tif (!x || !y) continue;\\n\\n\\t\\t\\tx.forEach(valueX => {\\n\\t\\t\\t\\ty.forEach(valueY => set.add(`(${valueX}, ${valueY})`));\\n\\t\\t\\t});\\n\\t\\t}\\n\\t\\treturn [...set];\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2631672,
                "title": "o-n-3-time-o-n-3-space-clear-explanation-consider-all-the-options",
                "content": "![image](https://assets.leetcode.com/users/images/8eeb3ee6-e135-43e3-87a0-a5b75059365e_1664299536.0641801.png)\\n\\n\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \"\"\" O(N^3)TS \"\"\"\\n\\n        def fn(n):\\n            if not (len(n) > 1 and n[0] == n[-1] == \\'0\\'):\\n                if n[-1] == \\'0\\':\\n                    yield n\\n                elif n[0] == \\'0\\':\\n                    yield n[0] + \\'.\\' + n[1:]\\n                else:\\n                    yield from [n] + [f\\'{n[:i]}.{n[i:]}\\' for i in range(1, len(n))]\\n\\n        arr = s.strip(\\'()\\')\\n        return [f\\'({a}, {b})\\' for i in range(1, len(arr)) for a, b in itertools.product(fn(arr[:i]), fn(arr[i:]))]\\n\\n![image](https://assets.leetcode.com/users/images/17b584c9-0b1e-45ba-b478-0791ffd5b514_1664299547.2679756.png)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/8eeb3ee6-e135-43e3-87a0-a5b75059365e_1664299536.0641801.png)\\n\\n\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \"\"\" O(N^3)TS \"\"\"\\n\\n        def fn(n):\\n            if not (len(n) > 1 and n[0] == n[-1] == \\'0\\'):\\n                if n[-1] == \\'0\\':\\n                    yield n\\n                elif n[0] == \\'0\\':\\n                    yield n[0] + \\'.\\' + n[1:]\\n                else:\\n                    yield from [n] + [f\\'{n[:i]}.{n[i:]}\\' for i in range(1, len(n))]\\n\\n        arr = s.strip(\\'()\\')\\n        return [f\\'({a}, {b})\\' for i in range(1, len(arr)) for a, b in itertools.product(fn(arr[:i]), fn(arr[i:]))]\\n\\n![image](https://assets.leetcode.com/users/images/17b584c9-0b1e-45ba-b478-0791ffd5b514_1664299547.2679756.png)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2579252,
                "title": "c-backtracking-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n\\n    void backtrack(string &s, char last = \\'(\\', int index = 1, bool dec = false, bool comma = false, bool beg = false, string out = \"(\") {\\n        if(index == s.length()-1) {\\n            if(comma and ((dec and last != \\'0\\') or !dec)) {\\n                out += s[index];\\n                ans.push_back(out);\\n            }\\n            return;\\n        }\\n\\n        string outcopy = out+\\'*\\';\\n        if(dec or last != \\'0\\' or (last == \\'0\\' and beg)) {\\n            outcopy.back() = s[index];\\n            if(last == \\'(\\' or last == \\',\\') backtrack(s,s[index],index+1,dec,comma,s[index] != \\'0\\',outcopy);\\n            else backtrack(s,s[index],index+1,dec,comma,beg,outcopy);\\n        }\\n        \\n        if(!dec and last != \\',\\' and last != \\'(\\') {\\n            outcopy.back() = \\'.\\';\\n            backtrack(s,\\'.\\',index,true,comma,beg,outcopy);\\n        }\\n        \\n        if(!comma and last != \\'.\\' and last != \\'(\\' and !(dec and last == \\'0\\')) {\\n            outcopy.back() = \\',\\';\\n            outcopy += \\' \\';\\n            backtrack(s,\\',\\',index,false,true,false,outcopy);\\n        }\\n    }\\n\\n    vector<string> ambiguousCoordinates(string s) {\\n        backtrack(s);\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> ans;\\n\\n    void backtrack(string &s, char last = \\'(\\', int index = 1, bool dec = false, bool comma = false, bool beg = false, string out = \"(\") {\\n        if(index == s.length()-1) {\\n            if(comma and ((dec and last != \\'0\\') or !dec)) {\\n                out += s[index];\\n                ans.push_back(out);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2470876,
                "title": "python3-solved-using-general-intuition-and-handling-edge-cases-with-0",
                "content": "```\\nclass Solution:\\n    #Time-Complexity: O(n^3), since outer for loop runs n times, and in worst case,\\n    #the first_value and second_value array of coordinates used to pairing up is in worst case\\n    #at most size n if the substring we passed to helper is around n characters! \\n    #Space-Complexity: O(2*n * n) -> O(n^2)\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        #First, we need to decide how to split s into two numbers! This will decide where to put\\n        #comma! \\n        \\n        #Then, we need to see if we are able to put decimal point in only one of the two splitted\\n        #numbers!\\n        \\n        #we also need to exclude the parentheses characteres!\\n        s = s[1:len(s)-1]\\n        #we need to define some helper to determine all possible valid coordinate values\\n        #we can form using substring x as input!\\n        def helper(x):\\n            #if x is single character, then itself is a valid coordinate value and only one!\\n            if(len(x) == 1):\\n                return [x]\\n            #if x has both first and last character be a 0, it can\\'t ever result in a \\n            #valid coordinate value!\\n            if(x[0] == \"0\" and x[len(x)-1] == \"0\"):\\n                return []\\n            #if only first character is 0, only valid coordinate value it can form is \\n            #in form 0.xxxxxx...!\\n            if(x[0] == \"0\"):\\n                return [\"0.\" + x[1:]]\\n            #if last digit is a 0, it can always be simplified no matter where I place\\n            #decimal point, thus only possible coordinate value candidate is x itself!\\n            if(x[-1] == \\'0\\'):\\n                return [x]\\n            #otherwise, we can simply generate all possible coordinate values by placing\\n            #decimal point between every two digits!\\n            else:\\n                #string x as itself is one of many ways!\\n                local = [x]\\n                #we will iterate from first char to 2nd to last char!\\n                cur = \"\"\\n                for i in range(0, len(x) - 1):\\n                    cur += x[i]\\n                    second_portion = x[i+1:]\\n                    overall = cur + \".\" + second_portion\\n                    local.append(overall)\\n                return local\\n                    \\n                    \\n                    \\n                    \\n            \\n        \\n        \\n        ans = []\\n        n = len(s)\\n        #For each iteration, we consider a possible split!\\n        for i in range(1, n):\\n            #consider splitting the string input s into left and right portions!\\n            #Left portion will determine all possible first coordinate values!\\n            #Right portion will determine all possible second coordinate values!\\n            l = s[:i]\\n            r = s[i:]\\n            #Once we find all possible first and second coordinate values, we simply\\n            #need to find all pairings!\\n            left_vals = helper(l)\\n            right_vals = helper(r)\\n            \\n            #before running for loop, we need to make sure that left_vals and right_vals is both\\n            #not an empty array. If even one of them is empty, it is not possible to form\\n            #a single valid 2-d coordinate pairing!\\n            if(not left_vals and not right_vals):\\n                continue\\n            for l in left_vals:\\n                for r in right_vals:\\n                    new_pairing = \"(\" + l + \", \" + r + \")\"\\n                    ans.append(new_pairing)\\n        return ans",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    #Time-Complexity: O(n^3), since outer for loop runs n times, and in worst case,\\n    #the first_value and second_value array of coordinates used to pairing up is in worst case\\n    #at most size n if the substring we passed to helper is around n characters! \\n    #Space-Complexity: O(2*n * n) -> O(n^2)\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        #First, we need to decide how to split s into two numbers! This will decide where to put\\n        #comma! \\n        \\n        #Then, we need to see if we are able to put decimal point in only one of the two splitted\\n        #numbers!\\n        \\n        #we also need to exclude the parentheses characteres!\\n        s = s[1:len(s)-1]\\n        #we need to define some helper to determine all possible valid coordinate values\\n        #we can form using substring x as input!\\n        def helper(x):\\n            #if x is single character, then itself is a valid coordinate value and only one!\\n            if(len(x) == 1):\\n                return [x]\\n            #if x has both first and last character be a 0, it can\\'t ever result in a \\n            #valid coordinate value!\\n            if(x[0] == \"0\" and x[len(x)-1] == \"0\"):\\n                return []\\n            #if only first character is 0, only valid coordinate value it can form is \\n            #in form 0.xxxxxx...!\\n            if(x[0] == \"0\"):\\n                return [\"0.\" + x[1:]]\\n            #if last digit is a 0, it can always be simplified no matter where I place\\n            #decimal point, thus only possible coordinate value candidate is x itself!\\n            if(x[-1] == \\'0\\'):\\n                return [x]\\n            #otherwise, we can simply generate all possible coordinate values by placing\\n            #decimal point between every two digits!\\n            else:\\n                #string x as itself is one of many ways!\\n                local = [x]\\n                #we will iterate from first char to 2nd to last char!\\n                cur = \"\"\\n                for i in range(0, len(x) - 1):\\n                    cur += x[i]\\n                    second_portion = x[i+1:]\\n                    overall = cur + \".\" + second_portion\\n                    local.append(overall)\\n                return local\\n                    \\n                    \\n                    \\n                    \\n            \\n        \\n        \\n        ans = []\\n        n = len(s)\\n        #For each iteration, we consider a possible split!\\n        for i in range(1, n):\\n            #consider splitting the string input s into left and right portions!\\n            #Left portion will determine all possible first coordinate values!\\n            #Right portion will determine all possible second coordinate values!\\n            l = s[:i]\\n            r = s[i:]\\n            #Once we find all possible first and second coordinate values, we simply\\n            #need to find all pairings!\\n            left_vals = helper(l)\\n            right_vals = helper(r)\\n            \\n            #before running for loop, we need to make sure that left_vals and right_vals is both\\n            #not an empty array. If even one of them is empty, it is not possible to form\\n            #a single valid 2-d coordinate pairing!\\n            if(not left_vals and not right_vals):\\n                continue\\n            for l in left_vals:\\n                for r in right_vals:\\n                    new_pairing = \"(\" + l + \", \" + r + \")\"\\n                    ans.append(new_pairing)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2401452,
                "title": "intuitive-simulation",
                "content": "```\\nclass Solution {\\n    \\n    vector<string> make(const string& str) {\\n        vector<string> res;\\n        int len = str.size();\\n        \\n        for (int sep = 1; sep <= len; ++sep) {\\n            auto left = str.substr(0, sep);\\n            auto right = str.substr(sep);\\n            if ((left[0] != \\'0\\' or left == \"0\") and right.back() != \\'0\\')\\n                res.push_back(left + (sep < len ? \".\" : \"\") + right);\\n        }\\n        \\n        return res;\\n    }\\n    \\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1, s.size() - 2);\\n        vector<string> res;\\n        for (int sep = 1; sep < s.size(); ++sep) {\\n            for (auto left : make(s.substr(0, sep))) {\\n                for (auto right : make(s.substr(sep))) {\\n                    res.push_back(\"(\" + left + \", \" + right + \")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    vector<string> make(const string& str) {\\n        vector<string> res;\\n        int len = str.size();\\n        \\n        for (int sep = 1; sep <= len; ++sep) {\\n            auto left = str.substr(0, sep);\\n            auto right = str.substr(sep);\\n            if ((left[0] != \\'0\\' or left == \"0\") and right.back() != \\'0\\')\\n                res.push_back(left + (sep < len ? \".\" : \"\") + right);\\n        }\\n        \\n        return res;\\n    }\\n    \\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1, s.size() - 2);\\n        vector<string> res;\\n        for (int sep = 1; sep < s.size(); ++sep) {\\n            for (auto left : make(s.substr(0, sep))) {\\n                for (auto right : make(s.substr(sep))) {\\n                    res.push_back(\"(\" + left + \", \" + right + \")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399267,
                "title": "typescript-100",
                "content": "```\\nfunction ambiguousCoordinates(s: string): string[] {\\n    s = s.substr(1, s.length-2);\\n    let pairs = [];\\n    for(let i=1; i<s.length; i++) {\\n        pairs.push([s.substr(0,i), s.substr(i)])\\n    }\\n    \\n    function getValidCombinations(s) {\\n        \\n        let possible = [];\\n        \\n        if(s.length == `${+s}`.length) {\\n           possible.push(s); \\n        }\\n        \\n        for(let i=1; i<s.length; i++) {\\n            let modified = s.substr(0,i)+\".\"+s.substr(i);\\n            if(modified.length == `${+modified}`.length) {\\n               possible.push(modified); \\n            }\\n        }\\n        return possible;\\n        \\n    }\\n    \\n    let result = [];\\n    for(let pair of pairs) {\\n        let comb1 = getValidCombinations(pair[0]);\\n        if(comb1.length) {\\n            let comb2 = getValidCombinations(pair[1]);\\n            for(let c1 of comb1) {\\n                for(let c2 of comb2) {\\n                    result.push(`(${c1}, ${c2})`);\\n                }\\n            }\\n        }\\n    }\\n    \\n    return result;\\n\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/96bed362-8e33-4156-94e7-45abe83eaa89_1659985691.1875932.png)\\n",
                "solutionTags": [],
                "code": "```\\nfunction ambiguousCoordinates(s: string): string[] {\\n    s = s.substr(1, s.length-2);\\n    let pairs = [];\\n    for(let i=1; i<s.length; i++) {\\n        pairs.push([s.substr(0,i), s.substr(i)])\\n    }\\n    \\n    function getValidCombinations(s) {\\n        \\n        let possible = [];\\n        \\n        if(s.length == `${+s}`.length) {\\n           possible.push(s); \\n        }\\n        \\n        for(let i=1; i<s.length; i++) {\\n            let modified = s.substr(0,i)+\".\"+s.substr(i);\\n            if(modified.length == `${+modified}`.length) {\\n               possible.push(modified); \\n            }\\n        }\\n        return possible;\\n        \\n    }\\n    \\n    let result = [];\\n    for(let pair of pairs) {\\n        let comb1 = getValidCombinations(pair[0]);\\n        if(comb1.length) {\\n            let comb2 = getValidCombinations(pair[1]);\\n            for(let c1 of comb1) {\\n                for(let c2 of comb2) {\\n                    result.push(`(${c1}, ${c2})`);\\n                }\\n            }\\n        }\\n    }\\n    \\n    return result;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2346369,
                "title": "python-brute-force-with-validation-solution",
                "content": "Intuition:\\n1. split s into all-possible two coordinates, some cases maybe invalid,we can filter out: 00110, possible splits: 0,0110 00,110, 001,10 but 00,110 is invalied as 00, so if one sub-split all contains all 0s length than 1 we can abort it.\\n2. for every split we enumerate all possible formed numbers(also filterout some invalied cases), eg, 011 there is 0.11 only, 110 there is:110 only, 101 there\\'re 1.01 10.1 101\\n3. using itertools.product to combine all paired of results from 1 and 2\\n*eg>s = \"(0123)\"\\n0,123 can be [0] combine with [1.23 12.3 123] so there are:(0,1,23),(0,12.3),(0,123)\\n01,23 can be [0.1] combine [2.3,23], so there are is:(0.1,2.3) and (0.1,23)\\n012,3 can be [0.12] and [3] so, (0.12,3)\\ntotal results:[\"(0, 1.23)\",\"(0, 12.3)\",\"(0, 123)\",\"(0.1, 2.3)\",\"(0.1, 23)\",\"(0.12, 3)\"]*\\n```\\nclass Solution(object):\\n    def ambiguousCoordinates(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        def _isValidSplit(s):\\n            return False if len(s)>1 and re.match(\\'/^[0]+$/\\',s) else True\\n            \\n        def _isValidNum(ipart,fpart):\\n            return False if (len(ipart)>1 and ipart[0]==\\'0\\') or (fpart and fpart[-1]==\\'0\\') else True\\n                             \\n        def _splitToNums(s):\\n            rets=[]\\n            if len(s)==1:return [s]\\n            for i in range(1,len(s)+1):\\n                a,b=s[:i],s[i:]\\n                if _isValidNum(a,b):rets.append(\"%s.%s\"%(a,b) if b else \"%s\"%(a))\\n            return rets               \\n        \\n        ans,s=[],s[1:-1]\\n        for i in range(1,len(s)):\\n            a,b=s[:i],s[i:]\\n            if not _isValidSplit(a) or not _isValidSplit(b):continue\\n            for c1,c2 in itertools.product(_splitToNums(a),_splitToNums(b)):ans.append(\"(%s, %s)\"%(c1,c2))\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def ambiguousCoordinates(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        def _isValidSplit(s):\\n            return False if len(s)>1 and re.match(\\'/^[0]+$/\\',s) else True\\n            \\n        def _isValidNum(ipart,fpart):\\n            return False if (len(ipart)>1 and ipart[0]==\\'0\\') or (fpart and fpart[-1]==\\'0\\') else True\\n                             \\n        def _splitToNums(s):\\n            rets=[]\\n            if len(s)==1:return [s]\\n            for i in range(1,len(s)+1):\\n                a,b=s[:i],s[i:]\\n                if _isValidNum(a,b):rets.append(\"%s.%s\"%(a,b) if b else \"%s\"%(a))\\n            return rets               \\n        \\n        ans,s=[],s[1:-1]\\n        for i in range(1,len(s)):\\n            a,b=s[:i],s[i:]\\n            if not _isValidSplit(a) or not _isValidSplit(b):continue\\n            for c1,c2 in itertools.product(_splitToNums(a),_splitToNums(b)):ans.append(\"(%s, %s)\"%(c1,c2))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340066,
                "title": "go-cartesian-product-fast",
                "content": "```\\nfunc ambiguousCoordinates(st string) []string {\\n\\tres := []string{}\\n\\n\\tisNotLegal := func(s string) bool {\\n\\t\\treturn !(len(s) == 1 || s[0] != \\'0\\' || s[len(s)-1] != \\'0\\')\\n\\t}\\n\\n\\tmakeCoordinates := func(s string) []string {\\n\\t\\tswitch {\\n\\t\\t\\tcase len(s) == 1 || s[len(s)-1] == \\'0\\':\\n\\t\\t\\t\\treturn []string{s}\\n\\t\\t\\tcase s[0] == \\'0\\':\\n\\t\\t\\t\\treturn []string{fmt.Sprintf(\"0.%s\", s[1:])}\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tresult := make([]string, 1, len(s))\\n\\t\\t\\t\\tresult[0] = s\\n\\t\\t\\t\\tfor i := 1; i < len(s); i++ {\\n\\t\\t\\t\\t\\tresult = append(result, fmt.Sprintf(\"%s.%s\", s[:i], s[i:]))\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result\\n\\t\\t\\t}\\n\\t}\\n\\n\\tfor i:=2; i<len(st)-1; i++ {\\n\\t\\tleft, right := st[1:i], st[i:len(st)-1]\\n\\t\\tif isNotLegal(left) || isNotLegal(right) {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tleftC, rightC := makeCoordinates(left), makeCoordinates(right)\\n\\t\\tfor _, l := range leftC {\\n\\t\\t\\tfor _, r := range rightC {\\n\\t\\t\\t\\tres = append(res, []string{fmt.Sprintf(\"(%s, %s)\", l, r)} ...)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc ambiguousCoordinates(st string) []string {\\n\\tres := []string{}\\n\\n\\tisNotLegal := func(s string) bool {\\n\\t\\treturn !(len(s) == 1 || s[0] != \\'0\\' || s[len(s)-1] != \\'0\\')\\n\\t}\\n\\n\\tmakeCoordinates := func(s string) []string {\\n\\t\\tswitch {\\n\\t\\t\\tcase len(s) == 1 || s[len(s)-1] == \\'0\\':\\n\\t\\t\\t\\treturn []string{s}\\n\\t\\t\\tcase s[0] == \\'0\\':\\n\\t\\t\\t\\treturn []string{fmt.Sprintf(\"0.%s\", s[1:])}\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tresult := make([]string, 1, len(s))\\n\\t\\t\\t\\tresult[0] = s\\n\\t\\t\\t\\tfor i := 1; i < len(s); i++ {\\n\\t\\t\\t\\t\\tresult = append(result, fmt.Sprintf(\"%s.%s\", s[:i], s[i:]))\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result\\n\\t\\t\\t}\\n\\t}\\n\\n\\tfor i:=2; i<len(st)-1; i++ {\\n\\t\\tleft, right := st[1:i], st[i:len(st)-1]\\n\\t\\tif isNotLegal(left) || isNotLegal(right) {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tleftC, rightC := makeCoordinates(left), makeCoordinates(right)\\n\\t\\tfor _, l := range leftC {\\n\\t\\t\\tfor _, r := range rightC {\\n\\t\\t\\t\\tres = append(res, []string{fmt.Sprintf(\"(%s, %s)\", l, r)} ...)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2313001,
                "title": "c-clean-code-recursive-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> getnumber(string s)\\n    {\\n        vector<string> ans;\\n        int n=s.size();\\n        if(n==1)\\n            return {s};\\n        if(s[0]!=\\'0\\')\\n        {\\n            ans.push_back(s);\\n                \\n        }\\n        if(s[0]==\\'0\\')\\n        {\\n            if(s[n-1]==\\'0\\')\\n            {\\n                return {};\\n            }\\n            else\\n                return {\"0.\"+s.substr(1)};\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s.substr(i).back()==\\'0\\')\\n                continue;\\n            ans.push_back(s.substr(0,i)+\".\"+s.substr(i));\\n        }\\n        return ans;\\n    }\\n    vector<string> ambiguousCoordinates(string ss) \\n    {\\n        vector<string> res;\\n        string s=ss.substr(1,ss.size()-2);\\n        int n=s.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<string> s1=getnumber(s.substr(0,i));\\n            vector<string> s2=getnumber(s.substr(i));\\n            for(int j=0;j<s1.size();j++)\\n            {\\n    \\n                for(int k=0;k<s2.size();k++)\\n                {\\n                    \\n                    res.push_back(\"(\"+s1[j]+\", \"+s2[k]+\")\");\\n                }\\n            }\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n// if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> getnumber(string s)\\n    {\\n        vector<string> ans;\\n        int n=s.size();\\n        if(n==1)\\n            return {s}",
                "codeTag": "Java"
            },
            {
                "id": 2270249,
                "title": "python-solution-just-follow-the-instruction",
                "content": "```\\nclass Solution:\\n    # DFS to put the comma and zeros\\n    # First put in the comma, and separate the front and back\\n    # For front and back, we try to put decimal point into each spot\\n    # For the decimal point placement to be valid, the one at front is always valid if it is of length 1. If it has length > 1, it must not start with 0\\n    # For the one at back cannot end with 0. Also, it cannot be a single 0\\n    \\n    def valid_decimals(self, front, back):\\n        if len(front) > 1 and front[0] == \"0\":\\n            return False\\n        if len(back) > 1 and back[-1] == \"0\":\\n            return False\\n        if back == \"0\":\\n            return False\\n        return True\\n    \\n    def dfs(self, front, back):\\n        valid_fronts = []\\n        valid_backs = []\\n        # not introducing any decimals\\n        if len(front) == 1:\\n            valid_fronts.append(front)\\n        elif front[0] != \\'0\\':\\n            valid_fronts.append(front)\\n            \\n        if len(back) == 1:\\n            valid_backs.append(back)\\n        elif back[0] != \\'0\\':\\n            valid_backs.append(back)\\n        # introducing the decimals\\n        if len(front) > 1:\\n            for i in range(1, len(front)):\\n                if self.valid_decimals(front[:i], front[i:]):\\n                    valid_fronts.append(front[:i] + \".\" + front[i:])\\n        if len(back) > 1:\\n            for i in range(1, len(back)):\\n                if self.valid_decimals(back[:i], back[i:]):\\n                    valid_backs.append(back[:i] + \".\" + back[i:])\\n        # Construct all the possible words\\n        valid_words = []\\n        for i in range(len(valid_fronts)):\\n            for j in range(len(valid_backs)):\\n                valid_words.append(\"(\" + valid_fronts[i] + \", \" + valid_backs[j] + \")\")\\n        return valid_words\\n            \\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        word = s[1:-1]\\n        result = []\\n        for i in range(1,len(word)):\\n            result += self.dfs(word[:i], word[i:])\\n        return result\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # DFS to put the comma and zeros\\n    # First put in the comma, and separate the front and back\\n    # For front and back, we try to put decimal point into each spot\\n    # For the decimal point placement to be valid, the one at front is always valid if it is of length 1. If it has length > 1, it must not start with 0\\n    # For the one at back cannot end with 0. Also, it cannot be a single 0\\n    \\n    def valid_decimals(self, front, back):\\n        if len(front) > 1 and front[0] == \"0\":\\n            return False\\n        if len(back) > 1 and back[-1] == \"0\":\\n            return False\\n        if back == \"0\":\\n            return False\\n        return True\\n    \\n    def dfs(self, front, back):\\n        valid_fronts = []\\n        valid_backs = []\\n        # not introducing any decimals\\n        if len(front) == 1:\\n            valid_fronts.append(front)\\n        elif front[0] != \\'0\\':\\n            valid_fronts.append(front)\\n            \\n        if len(back) == 1:\\n            valid_backs.append(back)\\n        elif back[0] != \\'0\\':\\n            valid_backs.append(back)\\n        # introducing the decimals\\n        if len(front) > 1:\\n            for i in range(1, len(front)):\\n                if self.valid_decimals(front[:i], front[i:]):\\n                    valid_fronts.append(front[:i] + \".\" + front[i:])\\n        if len(back) > 1:\\n            for i in range(1, len(back)):\\n                if self.valid_decimals(back[:i], back[i:]):\\n                    valid_backs.append(back[:i] + \".\" + back[i:])\\n        # Construct all the possible words\\n        valid_words = []\\n        for i in range(len(valid_fronts)):\\n            for j in range(len(valid_backs)):\\n                valid_words.append(\"(\" + valid_fronts[i] + \", \" + valid_backs[j] + \")\")\\n        return valid_words\\n            \\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        word = s[1:-1]\\n        result = []\\n        for i in range(1,len(word)):\\n            result += self.dfs(word[:i], word[i:])\\n        return result\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2120476,
                "title": "c-string-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> check(string s){\\n        int n = s.size();\\n        vector<string> res;\\n        if(s[0] == \\'0\\'){\\n            if(n == 1)\\n                res.push_back(s);\\n            else{\\n                if(s[n-1] == \\'0\\')\\n                    return res;\\n                \\n                s.insert(1, \".\");\\n                res.push_back(s);\\n            }\\n        }\\n        else{\\n            if(s[n-1] == \\'0\\'){\\n                res.push_back(s);\\n                return res;\\n            }\\n            \\n            for(int i=1; i<n; i++){\\n                string t = s.substr(0, i) + \".\" + s.substr(i, n-i);\\n                res.push_back(t);\\n            }\\n            res.push_back(s);\\n        }\\n        \\n        return res;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.size();\\n        vector<string> res;\\n        \\n        for(int i=2; i<n-1; i++){\\n            vector<string> left = check(s.substr(1, i-1));\\n            vector<string> right = check(s.substr(i, n-i-1));\\n            for(int j=0; j<left.size(); j++){\\n                for(int k=0; k<right.size(); k++){\\n                    string t = \"(\" + left[j] + \", \" + right[k] + \")\";\\n                    res.push_back(t);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> check(string s){\\n        int n = s.size();\\n        vector<string> res;\\n        if(s[0] == \\'0\\'){\\n            if(n == 1)\\n                res.push_back(s);\\n            else{\\n                if(s[n-1] == \\'0\\')\\n                    return res;\\n                \\n                s.insert(1, \".\");\\n                res.push_back(s);\\n            }\\n        }\\n        else{\\n            if(s[n-1] == \\'0\\'){\\n                res.push_back(s);\\n                return res;\\n            }\\n            \\n            for(int i=1; i<n; i++){\\n                string t = s.substr(0, i) + \".\" + s.substr(i, n-i);\\n                res.push_back(t);\\n            }\\n            res.push_back(s);\\n        }\\n        \\n        return res;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.size();\\n        vector<string> res;\\n        \\n        for(int i=2; i<n-1; i++){\\n            vector<string> left = check(s.substr(1, i-1));\\n            vector<string> right = check(s.substr(i, n-i-1));\\n            for(int j=0; j<left.size(); j++){\\n                for(int k=0; k<right.size(); k++){\\n                    string t = \"(\" + left[j] + \", \" + right[k] + \")\";\\n                    res.push_back(t);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093313,
                "title": "c-solution-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n\\n    void backtrack(string &s, char last = \\'(\\', int index = 1, bool dec = false, bool comma = false, bool beg = false, string out = \"(\") {\\n        if(index == s.length()-1) {\\n            if(comma and ((dec and last != \\'0\\') or !dec)) {\\n                out += s[index];\\n                ans.push_back(out);\\n            }\\n            return;\\n        }\\n\\n        string outcopy = out+\\'*\\';\\n        if(dec or last != \\'0\\' or (last == \\'0\\' and beg)) {\\n            outcopy.back() = s[index];\\n            if(last == \\'(\\' or last == \\',\\') backtrack(s,s[index],index+1,dec,comma,s[index] != \\'0\\',outcopy);\\n            else backtrack(s,s[index],index+1,dec,comma,beg,outcopy);\\n        }\\n        \\n        if(!dec and last != \\',\\' and last != \\'(\\') {\\n            outcopy.back() = \\'.\\';\\n            backtrack(s,\\'.\\',index,true,comma,beg,outcopy);\\n        }\\n        \\n        if(!comma and last != \\'.\\' and last != \\'(\\' and !(dec and last == \\'0\\')) {\\n            outcopy.back() = \\',\\';\\n            outcopy += \\' \\';\\n            backtrack(s,\\',\\',index,false,true,false,outcopy);\\n        }\\n    }\\n\\n    vector<string> ambiguousCoordinates(string s) {\\n        backtrack(s);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n\\n    void backtrack(string &s, char last = \\'(\\', int index = 1, bool dec = false, bool comma = false, bool beg = false, string out = \"(\") {\\n        if(index == s.length()-1) {\\n            if(comma and ((dec and last != \\'0\\') or !dec)) {\\n                out += s[index];\\n                ans.push_back(out);\\n            }\\n            return;\\n        }\\n\\n        string outcopy = out+\\'*\\';\\n        if(dec or last != \\'0\\' or (last == \\'0\\' and beg)) {\\n            outcopy.back() = s[index];\\n            if(last == \\'(\\' or last == \\',\\') backtrack(s,s[index],index+1,dec,comma,s[index] != \\'0\\',outcopy);\\n            else backtrack(s,s[index],index+1,dec,comma,beg,outcopy);\\n        }\\n        \\n        if(!dec and last != \\',\\' and last != \\'(\\') {\\n            outcopy.back() = \\'.\\';\\n            backtrack(s,\\'.\\',index,true,comma,beg,outcopy);\\n        }\\n        \\n        if(!comma and last != \\'.\\' and last != \\'(\\' and !(dec and last == \\'0\\')) {\\n            outcopy.back() = \\',\\';\\n            outcopy += \\' \\';\\n            backtrack(s,\\',\\',index,false,true,false,outcopy);\\n        }\\n    }\\n\\n    vector<string> ambiguousCoordinates(string s) {\\n        backtrack(s);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089318,
                "title": "java-detailed-explanation-easy-to-understand",
                "content": "Please refer to the comment, I think it is detailed enough~~\\n```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n\\t    // delete \"(\" and \")\" in the given string\\n        s = s.substring(1, s.length() - 1);\\n        List<String> res = new ArrayList<>();\\n        for (int i = 1; i < s.length(); ++i) {\\n\\t\\t    // split the given string into two parts:\\n\\t\\t\\t// - left part includes all possible x\\n\\t\\t\\t// - right part includes all possible y\\n            String xString = s.substring(0, i);\\n            String yString = s.substring(i);\\n\\t\\t\\t// what we need to do is to find all valid coordinates in each parts\\n            List<String> validX = validCoordinates(xString);\\n            List<String> validY = validCoordinates(yString);\\n\\t\\t\\t// once we get all possible x and y, we just combine them one by one\\n            for (String x : validX) {\\n                for (String y : validY) {\\n                    res.add(\"(\" + x + \", \" + y + \")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private List<String> validCoordinates(String s) {\\n        List<String> res = new ArrayList<String>();\\n\\t    // firstly we can regard the whole string as an integer and check whether it is valid or not\\n        if (checkInteger(s)) {\\n            res.add(s);\\n        }\\n\\t\\t// then we can add \".\" in each possible position, and check the integer part and decimal part respectively\\n        for (int i = 1; i < s.length(); ++i) {\\n            if (checkInteger(s.substring(0, i)) && checkDecimal(s.substring(i))) {\\n                res.add(s.substring(0, i) + \".\" + s.substring(i));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n\\t// integer part shouldn\\'t have leading zero, except \"0\" itself\\n    private boolean checkInteger(String s) {\\n        return !s.startsWith(\"0\") || s.equals(\"0\");\\n    }\\n\\t\\n    // decimal part shouldn\\'t have tailing zero\\n    private boolean checkDecimal(String s) {\\n        return !s.endsWith(\"0\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n\\t    // delete \"(\" and \")\" in the given string\\n        s = s.substring(1, s.length() - 1);\\n        List<String> res = new ArrayList<>();\\n        for (int i = 1; i < s.length(); ++i) {\\n\\t\\t    // split the given string into two parts:\\n\\t\\t\\t// - left part includes all possible x\\n\\t\\t\\t// - right part includes all possible y\\n            String xString = s.substring(0, i);\\n            String yString = s.substring(i);\\n\\t\\t\\t// what we need to do is to find all valid coordinates in each parts\\n            List<String> validX = validCoordinates(xString);\\n            List<String> validY = validCoordinates(yString);\\n\\t\\t\\t// once we get all possible x and y, we just combine them one by one\\n            for (String x : validX) {\\n                for (String y : validY) {\\n                    res.add(\"(\" + x + \", \" + y + \")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private List<String> validCoordinates(String s) {\\n        List<String> res = new ArrayList<String>();\\n\\t    // firstly we can regard the whole string as an integer and check whether it is valid or not\\n        if (checkInteger(s)) {\\n            res.add(s);\\n        }\\n\\t\\t// then we can add \".\" in each possible position, and check the integer part and decimal part respectively\\n        for (int i = 1; i < s.length(); ++i) {\\n            if (checkInteger(s.substring(0, i)) && checkDecimal(s.substring(i))) {\\n                res.add(s.substring(0, i) + \".\" + s.substring(i));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n\\t// integer part shouldn\\'t have leading zero, except \"0\" itself\\n    private boolean checkInteger(String s) {\\n        return !s.startsWith(\"0\") || s.equals(\"0\");\\n    }\\n\\t\\n    // decimal part shouldn\\'t have tailing zero\\n    private boolean checkDecimal(String s) {\\n        return !s.endsWith(\"0\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043904,
                "title": "python",
                "content": "\\n    def dfs(self, s):\\n        if len(s) == 1:\\n            return [s]\\n        \\n        ans = [] if s.startswith(\"0\") else [s]\\n        \\n        if s.endswith(\"0\"):\\n            return ans\\n        \\n        for i in range(1, len(s)):\\n            if s[:i].startswith(\"0\") and len(s[:i]) > 1:\\n                break\\n            \\n            ans.append(s[:i] + \".\" + s[i:])\\n            \\n        return ans\\n    \\n    def ambiguousCoordinates(self, s):\\n        s, res = s[1:-1], []\\n        \\n        for i in range(1,len(s)):\\n            for x in self.dfs(s[:i]):\\n                for y in self.dfs(s[i:]):\\n                    res.append(\"(\" + x + \", \" + y + \")\")\\n                \\n        return res",
                "solutionTags": [],
                "code": "\\n    def dfs(self, s):\\n        if len(s) == 1:\\n            return [s]\\n        \\n        ans = [] if s.startswith(\"0\") else [s]\\n        \\n        if s.endswith(\"0\"):\\n            return ans\\n        \\n        for i in range(1, len(s)):\\n            if s[:i].startswith(\"0\") and len(s[:i]) > 1:\\n                break\\n            \\n            ans.append(s[:i] + \".\" + s[i:])\\n            \\n        return ans\\n    \\n    def ambiguousCoordinates(self, s):\\n        s, res = s[1:-1], []\\n        \\n        for i in range(1,len(s)):\\n            for x in self.dfs(s[:i]):\\n                for y in self.dfs(s[i:]):\\n                    res.append(\"(\" + x + \", \" + y + \")\")\\n                \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2041470,
                "title": "python-straight-forward-solution",
                "content": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        # Extract number \\n        orig = re.findall(\"([0-9]+)\", s)[0]\\n        output = []\\n        # Iterrate trying to split the number to two by `index` (put comma) \\n        for index in range(len(orig)-1):            \\n            result = [None]*2                                                \\n            d1, d2 = orig[:index+1], orig[index+1:]            \\n            # Try to put dot in 1st digit\\n            for x in range(len(d1)):\\n                if x > 0 and d1[0] == \\'0\\':\\n                    continue\\n                if x == len(d1)-1:\\n                    result[0] = d1\\n                else:\\n                    if d1[x+1:][-1] == \"0\":\\n                        continue\\n                    result[0] = f\"{d1[:x+1]}.{d1[x+1:]}\"\\n                # Try to put dot in 2nd digit\\n                for y in range(len(d2)):\\n                    if y > 0 and d2[0] == \\'0\\':\\n                        continue\\n                    if y == len(d2)-1:\\n                        result[1] = d2\\n                    else:\\n                        if d2[y+1:][-1] == \"0\":\\n                            continue\\n                        result[1] = f\"{d2[:y+1]}.{d2[y+1:]}\"\\n\\n                    output.append(f\"({result[0]}, {result[1]})\")\\n            \\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        # Extract number \\n        orig = re.findall(\"([0-9]+)\", s)[0]\\n        output = []\\n        # Iterrate trying to split the number to two by `index` (put comma) \\n        for index in range(len(orig)-1):            \\n            result = [None]*2                                                \\n            d1, d2 = orig[:index+1], orig[index+1:]            \\n            # Try to put dot in 1st digit\\n            for x in range(len(d1)):\\n                if x > 0 and d1[0] == \\'0\\':\\n                    continue\\n                if x == len(d1)-1:\\n                    result[0] = d1\\n                else:\\n                    if d1[x+1:][-1] == \"0\":\\n                        continue\\n                    result[0] = f\"{d1[:x+1]}.{d1[x+1:]}\"\\n                # Try to put dot in 2nd digit\\n                for y in range(len(d2)):\\n                    if y > 0 and d2[0] == \\'0\\':\\n                        continue\\n                    if y == len(d2)-1:\\n                        result[1] = d2\\n                    else:\\n                        if d2[y+1:][-1] == \"0\":\\n                            continue\\n                        result[1] = f\"{d2[:y+1]}.{d2[y+1:]}\"\\n\\n                    output.append(f\"({result[0]}, {result[1]})\")\\n            \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032430,
                "title": "python-soln",
                "content": "finally, after six attempts\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        l=[]\\n        s=s[1:-1]\\n        for i in range(0,len(s)-1):\\n            \\n            l.append([s[:i+1],s[i+1:]])\\n            \\n        print(l)\\n        res=[]\\n        for x in l:\\n            \\n            a=x[0]\\n            b=x[1]\\n            \\n            l1=[]\\n            if (len(a)>=2 and a.count(\\'0\\')==len(a)) or (len(b)>=2 and b.count(\\'0\\')==len(b)):\\n                continue\\n            \\n            \\n            if a[0]==\\'0\\':\\n                if len(a)==1:\\n                    l1.append(a)\\n                else:\\n                    if a[1:][-1]!=\\'0\\':\\n                        l1.append(a[0]+\\'.\\'+a[1:])\\n            else:\\n                \\n                l1.append(a)\\n                \\n                for i in range(len(a)-1):\\n                    m=a[:i+1]\\n                    n=a[i+1:]\\n                    \\n                    if n.count(\\'0\\')==len(n):\\n                        \\n                        continue\\n                    if n[-1]==\\'0\\':\\n                        continue\\n                    \\n                    else:\\n                        l1.append(m+\\'.\\'+n)\\n                    \\n            \\n            l2=[]\\n            \\n            \\n            if b[0]==\\'0\\':\\n                if len(b)==1:\\n                    l2.append(b)\\n                else:\\n                    if b[1:][-1]!=\\'0\\':\\n                        l2.append(b[0]+\\'.\\'+b[1:])\\n                    \\n            \\n            else:\\n                \\n                l2.append(b)\\n                \\n                for i in range(len(b)-1):\\n                    m=b[:i+1]\\n                    n=b[i+1:]\\n                    #print(n)\\n                    if n.count(\\'0\\')==len(n):\\n                        continue\\n                    elif n[-1]==\\'0\\':\\n                        continue\\n                    else:\\n                        l2.append(m+\\'.\\'+n)\\n            for i in l1:\\n                for j in l2:\\n                    \\n                    x=\"(\"+i+\\', \\'+j+\")\"\\n                    res.append(x)\\n        return res\\n            \\n                \\n            \\n                \\n            \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        l=[]\\n        s=s[1:-1]\\n        for i in range(0,len(s)-1):\\n            \\n            l.append([s[:i+1],s[i+1:]])\\n            \\n        print(l)\\n        res=[]\\n        for x in l:\\n            \\n            a=x[0]\\n            b=x[1]\\n            \\n            l1=[]\\n            if (len(a)>=2 and a.count(\\'0\\')==len(a)) or (len(b)>=2 and b.count(\\'0\\')==len(b)):\\n                continue\\n            \\n            \\n            if a[0]==\\'0\\':\\n                if len(a)==1:\\n                    l1.append(a)\\n                else:\\n                    if a[1:][-1]!=\\'0\\':\\n                        l1.append(a[0]+\\'.\\'+a[1:])\\n            else:\\n                \\n                l1.append(a)\\n                \\n                for i in range(len(a)-1):\\n                    m=a[:i+1]\\n                    n=a[i+1:]\\n                    \\n                    if n.count(\\'0\\')==len(n):\\n                        \\n                        continue\\n                    if n[-1]==\\'0\\':\\n                        continue\\n                    \\n                    else:\\n                        l1.append(m+\\'.\\'+n)\\n                    \\n            \\n            l2=[]\\n            \\n            \\n            if b[0]==\\'0\\':\\n                if len(b)==1:\\n                    l2.append(b)\\n                else:\\n                    if b[1:][-1]!=\\'0\\':\\n                        l2.append(b[0]+\\'.\\'+b[1:])\\n                    \\n            \\n            else:\\n                \\n                l2.append(b)\\n                \\n                for i in range(len(b)-1):\\n                    m=b[:i+1]\\n                    n=b[i+1:]\\n                    #print(n)\\n                    if n.count(\\'0\\')==len(n):\\n                        continue\\n                    elif n[-1]==\\'0\\':\\n                        continue\\n                    else:\\n                        l2.append(m+\\'.\\'+n)\\n            for i in l1:\\n                for j in l2:\\n                    \\n                    x=\"(\"+i+\\', \\'+j+\")\"\\n                    res.append(x)\\n        return res\\n            \\n                \\n            \\n                \\n            \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918316,
                "title": "c-hints-to-self-try-solution",
                "content": "**Hints**\\n1. Generate all possible numbers by breaking the intial string in two parts.\\n2. Now since we have broken down the string, all we have to do now is place decimal points.\\n3. Generate all the pairs of unique numbers that we can build with or without placing decimal point.\\n4. Check whether both these generated no.s are valid or not. If  they are, you know what we\\'ve to do.\\n\\n**Personal Advice:** Now you must give it a try.\\n```\\nclass Solution {\\npublic:\\n    bool validOrNot(string &s, int j)\\n    {\\n        // no decimal point\\n        if(j == 0)\\n        {\\n            if(s[0] == \\'0\\' && s.size() > 1)\\n            {\\n                return false;\\n            }\\n        }\\n        // decimal at jth positon in s1\\n        else\\n        {\\n            if(s[s.size() - 1] == \\'0\\')\\n                    return false;\\n            if(s[0] == \\'0\\' && j != 1)\\n                return false;\\n            \\n        }\\n        return true;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1, s.size()-2);\\n        int n = s.size();\\n        vector<string> ans;\\n        for(int i=1; i<n; i++)\\n        {\\n            string first = s.substr(0, i);\\n            string second = s.substr(i);\\n            \\n            for(int j=0; j<first.size(); j++)\\n            {\\n                for(int k=0; k<second.size(); k++)\\n                {\\n                    bool x;\\n                    if(first.size() == 1)\\n                    {\\n                        x = true;\\n                    }\\n                    else \\n                    {\\n                        x = validOrNot(first, j);\\n                        if(!x) continue;\\n                    }\\n                    if(second.size() != 1)\\n                    {\\n                        x = x && validOrNot(second, k);\\n                    }\\n                    \\n                    if(x)\\n                    {\\n                        string s1, s2;\\n                        if(j)\\n                        {\\n                            s1 = first.substr(0, j) + \".\" + first.substr(j);\\n                        }\\n                        else\\n                        {\\n                            s1 = first;\\n                        }\\n                        if(k)\\n                        {\\n                            s2 = second.substr(0, k) + \".\" + second.substr(k);\\n                        }\\n                        else\\n                        {\\n                            s2 = second;\\n                        }\\n                        \\n                        ans.push_back(\"(\" + s1 + \", \" + s2 + \")\");\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validOrNot(string &s, int j)\\n    {\\n        // no decimal point\\n        if(j == 0)\\n        {\\n            if(s[0] == \\'0\\' && s.size() > 1)\\n            {\\n                return false;\\n            }\\n        }\\n        // decimal at jth positon in s1\\n        else\\n        {\\n            if(s[s.size() - 1] == \\'0\\')\\n                    return false;\\n            if(s[0] == \\'0\\' && j != 1)\\n                return false;\\n            \\n        }\\n        return true;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1, s.size()-2);\\n        int n = s.size();\\n        vector<string> ans;\\n        for(int i=1; i<n; i++)\\n        {\\n            string first = s.substr(0, i);\\n            string second = s.substr(i);\\n            \\n            for(int j=0; j<first.size(); j++)\\n            {\\n                for(int k=0; k<second.size(); k++)\\n                {\\n                    bool x;\\n                    if(first.size() == 1)\\n                    {\\n                        x = true;\\n                    }\\n                    else \\n                    {\\n                        x = validOrNot(first, j);\\n                        if(!x) continue;\\n                    }\\n                    if(second.size() != 1)\\n                    {\\n                        x = x && validOrNot(second, k);\\n                    }\\n                    \\n                    if(x)\\n                    {\\n                        string s1, s2;\\n                        if(j)\\n                        {\\n                            s1 = first.substr(0, j) + \".\" + first.substr(j);\\n                        }\\n                        else\\n                        {\\n                            s1 = first;\\n                        }\\n                        if(k)\\n                        {\\n                            s2 = second.substr(0, k) + \".\" + second.substr(k);\\n                        }\\n                        else\\n                        {\\n                            s2 = second;\\n                        }\\n                        \\n                        ans.push_back(\"(\" + s1 + \", \" + s2 + \")\");\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890035,
                "title": "is-this-even-backtracking",
                "content": "I don\\'t think this problem should be labelled backtracking because the solution doesn\\'t involve any sort of DFS, it\\'s just a cartesian product.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1828614,
                "title": "c-combination",
                "content": "**Idea:**\\nFirstly divide string into two parts **s1** and **s2** such that s1+s2=`s`. Generate all possible no. from s1 and s2 , and try every combination of those no.  A number is valid fromed by the string if:\\n* size of string ==1\\n* first and last character of string should not be `\\'0\\'` simultaneously.\\n* If first character == `\\'0\\'` or last character == `\\'0\\'` , then there is only one possible number\\n* else generate all possibility by putting `\\'.\\'` at every position\\n```\\nclass Solution {\\npublic:\\n    void find(string s,int in,int st,vector<string> &nums){\\n        if(st-in==0){\\n            nums.push_back(string(1,s[in])); return;\\n        }\\n        if(s[in]==\\'0\\' && s[st]==\\'0\\') return;\\n        if(s[st]==\\'0\\'){\\n            nums.push_back(s.substr(in,st-in+1)); return;\\n        }\\n        if(s[in]==\\'0\\'){\\n            string re = \"0.\"+s.substr(in+1,st-in);\\n            nums.push_back(re);\\n            return;\\n        }\\n        for(int i = in; i<st;++i){\\n            string re = s.substr(in,i-in+1)+\".\"+s.substr(i+1,st-i);\\n            nums.push_back(re);\\n        }\\n        nums.push_back(s.substr(in,st-in+1));\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> re;\\n        s = s.substr(1,s.size()-2);\\n        for(int i = 1; i<s.size();++i){\\n            vector<string> left,right;\\n            find(s,0,i-1,left); \\n            find(s,i,s.size()-1,right);\\n            if(left.size() && right.size()){\\n                for(int j = 0; j<left.size();++j){\\n                    for(int k = 0; k<right.size();++k){\\n                        re.push_back(\"(\"+left[j]+\", \"+right[k]+\")\");\\n                    }\\n                }\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void find(string s,int in,int st,vector<string> &nums){\\n        if(st-in==0){\\n            nums.push_back(string(1,s[in])); return;\\n        }\\n        if(s[in]==\\'0\\' && s[st]==\\'0\\') return;\\n        if(s[st]==\\'0\\'){\\n            nums.push_back(s.substr(in,st-in+1)); return;\\n        }\\n        if(s[in]==\\'0\\'){\\n            string re = \"0.\"+s.substr(in+1,st-in);\\n            nums.push_back(re);\\n            return;\\n        }\\n        for(int i = in; i<st;++i){\\n            string re = s.substr(in,i-in+1)+\".\"+s.substr(i+1,st-i);\\n            nums.push_back(re);\\n        }\\n        nums.push_back(s.substr(in,st-in+1));\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> re;\\n        s = s.substr(1,s.size()-2);\\n        for(int i = 1; i<s.size();++i){\\n            vector<string> left,right;\\n            find(s,0,i-1,left); \\n            find(s,i,s.size()-1,right);\\n            if(left.size() && right.size()){\\n                for(int j = 0; j<left.size();++j){\\n                    for(int k = 0; k<right.size();++k){\\n                        re.push_back(\"(\"+left[j]+\", \"+right[k]+\")\");\\n                    }\\n                }\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776337,
                "title": "c-solution-dfs-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1,s.length()-2);\\n        int size = s.length();\\n        vector<string> ans;\\n        for (int split=1; split<size; split++){\\n            for(auto first: generate(0, split-1, s)){\\n                for(auto second: generate(split,size-1, s)){\\n                    ans.push_back(\"(\"+first+\",\"+\" \"+second+\")\");\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<string> generate(int start, int end, string& s){\\n        if(s[start]==\\'0\\'){\\n            if(end==start) return{\"0\"};\\n            else if (s[end]==\\'0\\') return{};\\n            else{\\n                return{\"0.\"+s.substr(start+1, end-start)};\\n            }\\n        }\\n        string base = s.substr(start, 1+end-start);\\n        vector<string> res = {base};\\n        if(s[end]!=\\'0\\'){\\n            for(int i=1; i<base.length(); i++){\\n                res.push_back(base.substr(0,i)+\".\"+base.substr(i));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1,s.length()-2);\\n        int size = s.length();\\n        vector<string> ans;\\n        for (int split=1; split<size; split++){\\n            for(auto first: generate(0, split-1, s)){\\n                for(auto second: generate(split,size-1, s)){\\n                    ans.push_back(\"(\"+first+\",\"+\" \"+second+\")\");\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<string> generate(int start, int end, string& s){\\n        if(s[start]==\\'0\\'){\\n            if(end==start) return{\"0\"};\\n            else if (s[end]==\\'0\\') return{};\\n            else{\\n                return{\"0.\"+s.substr(start+1, end-start)};\\n            }\\n        }\\n        string base = s.substr(start, 1+end-start);\\n        vector<string> res = {base};\\n        if(s[end]!=\\'0\\'){\\n            for(int i=1; i<base.length(); i++){\\n                res.push_back(base.substr(0,i)+\".\"+base.substr(i));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775154,
                "title": "java-solution-with-comments-faster-then-52-25",
                "content": "Ret is a list for storing strings after putting \",\" (comma) in them after that we put decimals in correct places \".\" !\\n\\n```\\nclass Solution {\\n    public List<String> ret;\\n    public List<String> ans;\\n    public List<String> ambiguousCoordinates(String s) {\\n        ret=new ArrayList<>();\\n        ans=new ArrayList<>();\\n        String start=s.substring(0,2);\\n        util(s,1);\\n        fun();\\n        return ans;\\n    }\\n    \\n    //putting comma\\n    void util(String s,int idx) {\\n        if(idx==s.length()-2) {\\n            return;\\n        }\\n        \\n        String ns=s.substring(0,idx+1)+\", \"+s.substring(idx+1);\\n        ret.add(ns);\\n        util(s,idx+1);\\n    }\\n    \\n    //helper function for puting decimals after comma\\n    void fun() {\\n        for(String s:ret) {\\n            int cIndex=0;\\n            for(int i=0;i<s.length();i++) {\\n                if(s.charAt(i)==\\',\\') {\\n                    cIndex=i;\\n                    break;\\n                }\\n            }\\n            String a=s.substring(1,cIndex);\\n            String b=s.substring(cIndex+2,s.length()-1);\\n            List<String> n1=dot(a);\\n            List<String> n2=dot(b);\\n            if(n1==null || n2==null) { //invalid strings\\n                continue;\\n            }else { //valid strings\\n                for(String fir:n1) {\\n                    for(String sec:n2) {\\n                        ans.add(\"(\"+fir+\", \"+sec+\")\");\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    //putting decimal point\\n    List<String> dot(String n) {\\n        List<String> li=new ArrayList<>();\\n        if(n.length()==1) {\\n            li.add(n);\\n        }else {\\n            \\n            //just checking for first and last zeroes and making conditions accordingly\\n\\n            if(n.charAt(n.length()-1)==\\'0\\') {\\n                if(n.charAt(0)==\\'0\\') {\\n                    return null;\\n                }else {\\n                    li.add(n);\\n                }\\n            }else if(n.charAt(0)==\\'0\\') {\\n                li.add(\"0.\"+n.substring(1));\\n            }else {\\n                for(int i=0;i<n.length()-1;i++) {\\n                    li.add(n.substring(0,i+1)+\".\"+n.substring(i+1));\\n                }\\n                li.add(n);  //without any decimal\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> ret;\\n    public List<String> ans;\\n    public List<String> ambiguousCoordinates(String s) {\\n        ret=new ArrayList<>();\\n        ans=new ArrayList<>();\\n        String start=s.substring(0,2);\\n        util(s,1);\\n        fun();\\n        return ans;\\n    }\\n    \\n    //putting comma\\n    void util(String s,int idx) {\\n        if(idx==s.length()-2) {\\n            return;\\n        }\\n        \\n        String ns=s.substring(0,idx+1)+\", \"+s.substring(idx+1);\\n        ret.add(ns);\\n        util(s,idx+1);\\n    }\\n    \\n    //helper function for puting decimals after comma\\n    void fun() {\\n        for(String s:ret) {\\n            int cIndex=0;\\n            for(int i=0;i<s.length();i++) {\\n                if(s.charAt(i)==\\',\\') {\\n                    cIndex=i;\\n                    break;\\n                }\\n            }\\n            String a=s.substring(1,cIndex);\\n            String b=s.substring(cIndex+2,s.length()-1);\\n            List<String> n1=dot(a);\\n            List<String> n2=dot(b);\\n            if(n1==null || n2==null) { //invalid strings\\n                continue;\\n            }else { //valid strings\\n                for(String fir:n1) {\\n                    for(String sec:n2) {\\n                        ans.add(\"(\"+fir+\", \"+sec+\")\");\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    //putting decimal point\\n    List<String> dot(String n) {\\n        List<String> li=new ArrayList<>();\\n        if(n.length()==1) {\\n            li.add(n);\\n        }else {\\n            \\n            //just checking for first and last zeroes and making conditions accordingly\\n\\n            if(n.charAt(n.length()-1)==\\'0\\') {\\n                if(n.charAt(0)==\\'0\\') {\\n                    return null;\\n                }else {\\n                    li.add(n);\\n                }\\n            }else if(n.charAt(0)==\\'0\\') {\\n                li.add(\"0.\"+n.substring(1));\\n            }else {\\n                for(int i=0;i<n.length()-1;i++) {\\n                    li.add(n.substring(0,i+1)+\".\"+n.substring(i+1));\\n                }\\n                li.add(n);  //without any decimal\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745242,
                "title": "python-with-comments-97-time-98-memory",
                "content": "python. DFS with MAX_DEPTH of 2 and early stops\\n\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\'\\'\\'\\n        input: S - string\\n        output: all_possible_strings - list\\n        \\'\\'\\'\\n        # write your code here\\n        all_possible_strings = []\\n        string_two_numbers = s[1:len(s)-1]\\n        length = len(string_two_numbers)\\n        for i in range(length - 1):\\n            # split numbers, the same as add comma and space\\n            number_str1 = string_two_numbers[:i+1]\\n            number_str2 = string_two_numbers[i+1:]\\n            # add decimal point if necessary\\n            number_str1_list = self.get_valid_number(number_str1)\\n            if number_str1_list:\\n                number_str2_list = self.get_valid_number(number_str2)\\n                if number_str2_list:\\n                    for str1 in number_str1_list:\\n                        for str2 in number_str2_list:\\n                            solution = \"\".join([\"(\", str1, \", \", str2, \")\"])\\n                            all_possible_strings.append(solution)\\n        return all_possible_strings\\n\\n    def get_valid_number(self, number_str):\\n        number_str_list = []\\n        # check without decimal\\n        if number_str[0] != \\'0\\' or len(number_str) == 1:\\n            number_str_list.append(number_str)\\n        # check add one decimal\\n        # if ending with 0, remove\\n        if number_str[-1] != \\'0\\':\\n            # not ending with \\'0\\'\\n            if number_str[0] == \\'0\\':\\n                # starting with 0, decimal must be next\\n                number_str_list.append(\\'0\\'+\\'.\\' + number_str[1:])\\n            else:\\n                # starting with non-zero, ending with non-zero\\n                for insert_index in range(1, len(number_str)):\\n                    number_str_list.append(number_str[:insert_index] +\\'.\\' + number_str[insert_index:])\\n        return number_str_list\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\'\\'\\'\\n        input: S - string\\n        output: all_possible_strings - list\\n        \\'\\'\\'\\n        # write your code here\\n        all_possible_strings = []\\n        string_two_numbers = s[1:len(s)-1]\\n        length = len(string_two_numbers)\\n        for i in range(length - 1):\\n            # split numbers, the same as add comma and space\\n            number_str1 = string_two_numbers[:i+1]\\n            number_str2 = string_two_numbers[i+1:]\\n            # add decimal point if necessary\\n            number_str1_list = self.get_valid_number(number_str1)\\n            if number_str1_list:\\n                number_str2_list = self.get_valid_number(number_str2)\\n                if number_str2_list:\\n                    for str1 in number_str1_list:\\n                        for str2 in number_str2_list:\\n                            solution = \"\".join([\"(\", str1, \", \", str2, \")\"])\\n                            all_possible_strings.append(solution)\\n        return all_possible_strings\\n\\n    def get_valid_number(self, number_str):\\n        number_str_list = []\\n        # check without decimal\\n        if number_str[0] != \\'0\\' or len(number_str) == 1:\\n            number_str_list.append(number_str)\\n        # check add one decimal\\n        # if ending with 0, remove\\n        if number_str[-1] != \\'0\\':\\n            # not ending with \\'0\\'\\n            if number_str[0] == \\'0\\':\\n                # starting with 0, decimal must be next\\n                number_str_list.append(\\'0\\'+\\'.\\' + number_str[1:])\\n            else:\\n                # starting with non-zero, ending with non-zero\\n                for insert_index in range(1, len(number_str)):\\n                    number_str_list.append(number_str[:insert_index] +\\'.\\' + number_str[insert_index:])\\n        return number_str_list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726226,
                "title": "easy-peasy-backtracking-solution-c",
                "content": "class Solution {\\npublic:\\n\\n    void find(vector<string> &res, string s, string str, bool dot, bool valid, int i)\\n    {\\n        if(i==s.length())\\n        {\\n            if(dot)\\n            {\\n                if(str[str.length()-1]==\\'0\\') //this conditions helps with avoiding cases like 5.30\\n                    return;\\n            }\\n            if(valid || !dot)\\n                res.push_back(str);\\n            return;\\n        }\\n        if(str.length()) //if the string is not empty\\n        {\\n            if(dot)\\n            {\\n                str+=s[i];\\n                if(s[i]!=\\'0\\') //if there is a positive number after \\'.\\', it is valid except for 1 case which we are handling in base conditon\\n                    find(res,s,str,dot,true,i+1);\\n                else\\n                    find(res,s,str,dot,valid,i+1); \\n                str.pop_back();\\n            }\\n            else\\n            {   // Case 1-> either we add another number\\n                if(str[0]!=\\'0\\') //if have a non decimal number, and we are trying to add another number, we only do it if there are no leading zeros\\n                {\\n                    str+=s[i];\\n                    find(res,s,str,dot,valid,i+1);\\n                    str.pop_back();\\n                }\\n                str+=\".\"; //Case 2-> or we add a dot\\n                find(res,s,str,true,valid,i); //We call the function on the same index again so as to add ith digit after \\'.\\' \\n                str.pop_back();\\n            }\\n        } \\n        else //if the string is empty\\n        {\\n            str+=s[i]; //this is our first number\\n            find(res,s,str,dot,valid,i+1);\\n        }\\n    }\\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> res;\\n        for(int i=1;i<s.length()-2;i++) //calling function on all possible lengths of both the coordinates.\\n        {                               // Lets say we have 1234. We will call function on {1,234}, {12,34} & {123,4}\\n            vector<string> arr;\\n            find(arr,s.substr(1,i),\"\",false,false,0); //after the function call, arr stores all possible numbers of first coordinate\\n            vector<string> s1=arr;\\n            arr.clear();\\n            find(arr,s.substr(i+1,s.length()-i-2),\"\",false,false,0);//after the function call, arr stores all possible numbers of second coordinate\\n            vector<string> s2=arr;\\n            arr.clear();\\n            for(auto x : s1) // once we have all possible combinations of coordinates we can just combine all sets of coordinates with each other\\n            {\\n                for(auto y : s2)\\n                {\\n                    res.push_back(\"(\"+x+\", \"+y+\")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    void find(vector<string> &res, string s, string str, bool dot, bool valid, int i)\\n    {\\n        if(i==s.length())\\n        {\\n            if(dot)\\n            {\\n                if(str[str.length()-1]==\\'0\\') //this conditions helps with avoiding cases like 5.30\\n                    return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1507086,
                "title": "your-code-hurt-my-eyes-clean-python-code",
                "content": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s):\\n        # remove paranthesis\\n        s = s[1:-1]\\n        res = []\\n        # split into parts for (x, y)\\n        for x, y in self.partition(s):\\n            x_s = self.coordinates(x)\\n            y_s = self.coordinates(y)\\n\\n            # because x + y == s, we can use all possible values of x \\n            # and y independently, so we take the cartesian product\\n            for x in x_s:\\n                for y in y_s:\\n                    res.append(f\"({x}, {y})\") # format in the required form\\n        return res\\n\\n    def coordinates(self, s):\\n\\t  \"\"\"\\n\\t  A coordinate is either an integral number or\\n\\t  a decimal number with integral and decimal parts\\n\\t  \"\"\"\\n        # check if the whole string* can be an integral coordinate\\n\\t\\t# *because it is not contained in partitions\\n        vals = [s] if self.integral(s) else []\\n\\t\\t\\n        # add coordinates with valid integral and decimal part\\n        for i, d in self.partition(s):\\n            if self.integral(i) and self.decimal(d):\\n                vals.append(f\"{i}.{d}\")\\n        return vals\\n\\n    def integral(self, s):\\n        \"\"\"\\n        An integral part in the coordinates is not allowed \\n\\t\\tto have a leading zero, except when it is 0\\n        \"\"\"\\n        return s[0] != \"0\" or s == \"0\"\\n\\n    def decimal(self, s):\\n        \"\"\"\\n        A decimal part in the coordinates is not allowed \\n\\t\\tto end with a zero \\n        \"\"\"\\n        return s[-1] != \"0\"\\n\\n    def partition(self, s):\\n        \"\"\"\\n        return a generator that splits the string \\n\\t\\tin two-parts of lengths (1, n-1), (2, n-2),... \\n        \"\"\"\\n        return ( (s[0:i], s[i:]) for i in range(1, len(s)) )\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s):\\n        # remove paranthesis\\n        s = s[1:-1]\\n        res = []\\n        # split into parts for (x, y)\\n        for x, y in self.partition(s):\\n            x_s = self.coordinates(x)\\n            y_s = self.coordinates(y)\\n\\n            # because x + y == s, we can use all possible values of x \\n            # and y independently, so we take the cartesian product\\n            for x in x_s:\\n                for y in y_s:\\n                    res.append(f\"({x}, {y})\") # format in the required form\\n        return res\\n\\n    def coordinates(self, s):\\n\\t  \"\"\"\\n\\t  A coordinate is either an integral number or\\n\\t  a decimal number with integral and decimal parts\\n\\t  \"\"\"\\n        # check if the whole string* can be an integral coordinate\\n\\t\\t# *because it is not contained in partitions\\n        vals = [s] if self.integral(s) else []\\n\\t\\t\\n        # add coordinates with valid integral and decimal part\\n        for i, d in self.partition(s):\\n            if self.integral(i) and self.decimal(d):\\n                vals.append(f\"{i}.{d}\")\\n        return vals\\n\\n    def integral(self, s):\\n        \"\"\"\\n        An integral part in the coordinates is not allowed \\n\\t\\tto have a leading zero, except when it is 0\\n        \"\"\"\\n        return s[0] != \"0\" or s == \"0\"\\n\\n    def decimal(self, s):\\n        \"\"\"\\n        A decimal part in the coordinates is not allowed \\n\\t\\tto end with a zero \\n        \"\"\"\\n        return s[-1] != \"0\"\\n\\n    def partition(self, s):\\n        \"\"\"\\n        return a generator that splits the string \\n\\t\\tin two-parts of lengths (1, n-1), (2, n-2),... \\n        \"\"\"\\n        return ( (s[0:i], s[i:]) for i in range(1, len(s)) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480758,
                "title": "using-itertools-product-81-speed",
                "content": "Runtime: 44 ms, faster than 81.05% of Python3 online submissions for Ambiguous Coordinates.\\nMemory Usage: 14.4 MB, less than 18.95% of Python3 online submissions for Ambiguous Coordinates.\\n```\\nclass Solution:\\n\\n    def generate_nums(self, s: str) -> List[str]:\\n        if len(s) == 1:\\n            return [s]\\n        ans = [] if s.startswith(\"0\") else [s]\\n        if s.endswith(\"0\"):\\n            return ans\\n        for i in range(1, len(s)):\\n            a, b = s[:i], s[i:]\\n            if a.startswith(\"0\") and len(a) > 1:\\n                break\\n            ans.append(f\"{a}.{b}\")\\n        return ans\\n\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        ans = []\\n        for i in range(1, len(s)):\\n            a, b = s[:i], s[i:]\\n            for x, y in product(self.generate_nums(a), self.generate_nums(b)):\\n                ans.append(f\"({x}, {y})\")\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def generate_nums(self, s: str) -> List[str]:\\n        if len(s) == 1:\\n            return [s]\\n        ans = [] if s.startswith(\"0\") else [s]\\n        if s.endswith(\"0\"):\\n            return ans\\n        for i in range(1, len(s)):\\n            a, b = s[:i], s[i:]\\n            if a.startswith(\"0\") and len(a) > 1:\\n                break\\n            ans.append(f\"{a}.{b}\")\\n        return ans\\n\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        ans = []\\n        for i in range(1, len(s)):\\n            a, b = s[:i], s[i:]\\n            for x, y in product(self.generate_nums(a), self.generate_nums(b)):\\n                ans.append(f\"({x}, {y})\")\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448698,
                "title": "c-recursion",
                "content": "```\\npublic class Solution \\n{\\n    public IList<string> AmbiguousCoordinates(string s) \\n    {\\n        var output = new List<string>();\\n        \\n        for (int i = 1; i < s.Length - 2; i++)\\n        {\\n            var length = (i - 1) + 1;\\n            var x = s.Substring(1, length);\\n            var y = s.Substring(length + 1, (s.Length - 2) - length);\\n            \\n            var validXs = GetValidNumbers(x);\\n            var validYs = GetValidNumbers(y);\\n            \\n            foreach (string validX in validXs)\\n            {\\n                foreach (string validY in validYs)\\n                {\\n                    output.Add($\"({validX}, {validY})\");\\n                }                \\n            }            \\n        }\\n        \\n        return output;\\n    }\\n    \\n    private List<string> GetValidNumbers(string s)\\n    {\\n        var validNumbers = new List<string>();              \\n        \\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            var length = (i - 0) + 1;\\n            var x = s.Substring(0, length);\\n            var y = s.Substring(length, s.Length - length);\\n\\n            //only add \\'0\\' or numbers that don\\'t start and end with 0\\n            if ((!x.StartsWith(\\'0\\') || x == \"0\") && !y.EndsWith(\\'0\\'))\\n            {\\n                //only add the period up to the 2nd to last char\\n                var period = (i < s.Length - 1) ? \".\" : string.Empty;\\n                \\n                validNumbers.Add($\"{x}{period}{y}\");\\n            }\\n        }\\n        \\n        return validNumbers;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public IList<string> AmbiguousCoordinates(string s) \\n    {\\n        var output = new List<string>();\\n        \\n        for (int i = 1; i < s.Length - 2; i++)\\n        {\\n            var length = (i - 1) + 1;\\n            var x = s.Substring(1, length);\\n            var y = s.Substring(length + 1, (s.Length - 2) - length);\\n            \\n            var validXs = GetValidNumbers(x);\\n            var validYs = GetValidNumbers(y);\\n            \\n            foreach (string validX in validXs)\\n            {\\n                foreach (string validY in validYs)\\n                {\\n                    output.Add($\"({validX}, {validY})\");\\n                }                \\n            }            \\n        }\\n        \\n        return output;\\n    }\\n    \\n    private List<string> GetValidNumbers(string s)\\n    {\\n        var validNumbers = new List<string>();              \\n        \\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            var length = (i - 0) + 1;\\n            var x = s.Substring(0, length);\\n            var y = s.Substring(length, s.Length - length);\\n\\n            //only add \\'0\\' or numbers that don\\'t start and end with 0\\n            if ((!x.StartsWith(\\'0\\') || x == \"0\") && !y.EndsWith(\\'0\\'))\\n            {\\n                //only add the period up to the 2nd to last char\\n                var period = (i < s.Length - 1) ? \".\" : string.Empty;\\n                \\n                validNumbers.Add($\"{x}{period}{y}\");\\n            }\\n        }\\n        \\n        return validNumbers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436178,
                "title": "lessons-from-this-problem-pseudocode",
                "content": "1. When I was  faced with this problem in a virtual contest, I knew I had to brute-force through it. There was no underlying optimization or algorithmic trick that would help. Also the constraints are a huge hint and the problem literally screams brute-force recursion.\\n2.  The second mental barrier were the nasty edge cases which actually made the problem difficult. I thought deeply about how you could handle all the edge cases iteratively and spent a lot of time perfecting it into code but it just got messier and messier.\\n3.  The trick was to use Interval based recursion and handle the edge cases in recursive fashion and not iteratively. This needed a smart observation that is already explained in detail in the top-voted solutions.\\n4.  I was so convinced that the iterative solution could work, that I failed to appreciate the aforementioned approach. In the recursive approach all the nasty edge cases take the form of just 5 simple base conditions.\\n------------------\\n\\n```\\nif(s.size() == 0) return {};\\nif(s.size() == 1) return s;\\nif(s == \"0XXX0\") return {};        // decimal point cant be added, all strings would be invalid.\\nif(s == \"0XXX\") return {0.XXX};    // only one string can be formed which is returned, rest would all be  invalid\\nif(s == \"XXX0\") return {XXX0}     // decimal point cannot be added, only the entire number as a whole is valid\\nreturn {X.XX, XX.X};             // If there are no leading or trailing zeros like (\"XXX\") we can simply assign \\n                                         //the decimal point at various places because all of them would be valid. \\n```",
                "solutionTags": [],
                "code": "```\\nif(s.size() == 0) return {};\\nif(s.size() == 1) return s;\\nif(s == \"0XXX0\") return {};        // decimal point cant be added, all strings would be invalid.\\nif(s == \"0XXX\") return {0.XXX};    // only one string can be formed which is returned, rest would all be  invalid\\nif(s == \"XXX0\") return {XXX0}     // decimal point cannot be added, only the entire number as a whole is valid\\nreturn {X.XX, XX.X};             // If there are no leading or trailing zeros like (\"XXX\") we can simply assign \\n                                         //the decimal point at various places because all of them would be valid. \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1435995,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> res = new ArrayList<>();\\n        for(int i = 2; i < s.length()-1; i++) {\\n            List<String> left = helper(s.substring(1, i));\\n            List<String> right = helper(s.substring(i, s.length()-1));\\n            if(left.size() == 0 || right.size() == 0) {\\n                continue;\\n            } \\n            for(String l : left) {\\n                for(String r : right) {\\n                    String curr = \"(\" + l + \", \" + r + \")\";\\n                    res.add(curr);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public List<String> helper(String s) {\\n        List<String> res = new ArrayList<>();\\n        if(s.length() == 1 || !s.startsWith(\"0\")) {\\n            res.add(s);\\n        }\\n        for(int i = 1; i < s.length(); i++) {\\n            String curr = s.substring(0, i) + \".\" + s.substring(i, s.length());\\n            if(curr.endsWith(\"0\") || (curr.startsWith(\"0\") && curr.charAt(1) != \\'.\\')) {\\n                continue;\\n            }\\n            res.add(curr);\\n        }\\n        return res;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> res = new ArrayList<>();\\n        for(int i = 2; i < s.length()-1; i++) {\\n            List<String> left = helper(s.substring(1, i));\\n            List<String> right = helper(s.substring(i, s.length()-1));\\n            if(left.size() == 0 || right.size() == 0) {\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1433622,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> result = new ArrayList<>();\\n        s = s.substring(1,s.length()-1);\\n        for(int i = 0; i < s.length()-1; i++)\\n        {\\n            String first = s.substring(0, i+1);\\n            String second = s.substring(i+1,s.length());\\n            List<String> firstCombs = getValidCombs(first);\\n            List<String> secondCombs = getValidCombs(second);\\n            for(int j = 0; j < firstCombs.size(); j++)\\n            {\\n                for(int k = 0; k < secondCombs.size(); k++)\\n                {\\n                    result.add(\"(\"+firstCombs.get(j)+\", \"+secondCombs.get(k)+\")\");\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    List<String> getValidCombs(String cordinate)\\n    {\\n        List<String> combs = new ArrayList<>();\\n        if(cordinate.length() > 1 && cordinate.startsWith(\"0\"))\\n        {\\n            if(cordinate.endsWith(\"0\")) return combs;\\n            combs.add(cordinate.substring(0,1)+\".\"+cordinate.substring(1,cordinate.length()));    \\n            return combs;\\n        }\\n        \\n        if(cordinate.length() == 1)\\n        {\\n            combs.add(cordinate);\\n            return combs;\\n        }\\n        \\n        combs.add(cordinate);\\n        for(int i = 1; i < cordinate.length(); i++)\\n        {\\n            String before = cordinate.substring(0,i);\\n            String after = cordinate.substring(i,cordinate.length());\\n            if(after.charAt(after.length()-1) == \\'0\\') continue;\\n            \\n            String total = (before.length() >= 1) ? before+\".\"+after : after;\\n            combs.add(total);\\n        }\\n        \\n        return combs;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> result = new ArrayList<>();\\n        s = s.substring(1,s.length()-1);\\n        for(int i = 0; i < s.length()-1; i++)\\n        {\\n            String first = s.substring(0, i+1);\\n            String second = s.substring(i+1,s.length());\\n            List<String> firstCombs = getValidCombs(first);\\n            List<String> secondCombs = getValidCombs(second);\\n            for(int j = 0; j < firstCombs.size(); j++)\\n            {\\n                for(int k = 0; k < secondCombs.size(); k++)\\n                {\\n                    result.add(\"(\"+firstCombs.get(j)+\", \"+secondCombs.get(k)+\")\");\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1382165,
                "title": "go-double-100",
                "content": "```\\nfunc ambiguousCoordinates(s string) []string {\\n\\tans, prefix, suffix := []string{}, []string{}, []string{}\\n\\tbuff := \"\"\\n\\tstr := s[1 : len(s)-1]\\n\\tlength := len(str)\\n\\n\\tif length == 2 {\\n\\t\\tbuff = \"(\" + string(str[0]) + \", \" + string(str[1]) + \")\"\\n\\t\\tans = append(ans, buff)\\n\\t} else {\\n\\t\\tfor i := 1; i < length; i++ {\\n\\t\\t\\tprefix = addDot(str[:i])\\n\\t\\t\\tsuffix = addDot(str[i:])\\n\\n\\t\\t\\tfor j := 0; j < len(prefix); j++ {\\n\\t\\t\\t\\tfor k := 0; k < len(suffix); k++ {\\n\\t\\t\\t\\t\\tbuff = \"(\" + prefix[j] + \", \" + suffix[k] + \")\"\\n\\t\\t\\t\\t\\tans = append(ans, buff)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n\\nfunc addDot(str string) []string {\\n\\tans := []string{}\\n\\n\\tif checkNum(str, false, false) {\\n\\t\\tans = append(ans, str)\\n\\t}\\n\\n\\tfor i := 1; i < len(str); i++ {\\n\\t\\tbuff := str[0:i] + \".\" + str[i:]\\n\\t\\tif checkNum(buff, false, false) {\\n\\t\\t\\tans = append(ans, buff)\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n\\nfunc checkNum(s string, pre, after bool) bool {\\n\\tif len(s) == 1 && strings.Contains(s, \"0\") && pre && !after {\\n\\t\\treturn true\\n\\t}\\n\\n\\tif len(s) == 1 && strings.Contains(s, \"0\") && !pre && after {\\n\\t\\treturn false\\n\\t}\\n\\n\\tif !strings.Contains(s, \".\") && pre && !after {\\n\\t\\tfor i := len(s) - 1; i >= 0; i-- {\\n\\t\\t\\tif strings.ContainsAny(s[:i], \"123456789\") {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif strings.Contains(s[:i], \"0\") {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\n\\tif !strings.Contains(s, \".\") && !pre && after {\\n\\t\\tfor i := 0; i < len(s); i++ {\\n\\t\\t\\t// fmt.Println(s[i:])\\n\\t\\t\\tif strings.ContainsAny(s[i:], \"123456789\") {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif strings.Contains(s[i:], \"0\") {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif !pre && !after {\\n\\t\\tif strings.Contains(s, \".\") {\\n\\t\\t\\ti := strings.IndexByte(s, \\'.\\')\\n\\n\\t\\t\\tif checkNum(s[:i], true, false) && checkNum(s[i+1:], false, true) {\\n\\t\\t\\t\\tgoto end\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor i := len(s) - 1; i >= 0; i-- {\\n\\t\\t\\t\\tif strings.ContainsAny(s[:i], \"123456789\") {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif strings.Contains(s[:i], \"0\") {\\n\\t\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\nend:\\n\\treturn true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc ambiguousCoordinates(s string) []string {\\n\\tans, prefix, suffix := []string{}, []string{}, []string{}\\n\\tbuff := \"\"\\n\\tstr := s[1 : len(s)-1]\\n\\tlength := len(str)\\n\\n\\tif length == 2 {\\n\\t\\tbuff = \"(\" + string(str[0]) + \", \" + string(str[1]) + \")\"\\n\\t\\tans = append(ans, buff)\\n\\t} else {\\n\\t\\tfor i := 1; i < length; i++ {\\n\\t\\t\\tprefix = addDot(str[:i])\\n\\t\\t\\tsuffix = addDot(str[i:])\\n\\n\\t\\t\\tfor j := 0; j < len(prefix); j++ {\\n\\t\\t\\t\\tfor k := 0; k < len(suffix); k++ {\\n\\t\\t\\t\\t\\tbuff = \"(\" + prefix[j] + \", \" + suffix[k] + \")\"\\n\\t\\t\\t\\t\\tans = append(ans, buff)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n\\nfunc addDot(str string) []string {\\n\\tans := []string{}\\n\\n\\tif checkNum(str, false, false) {\\n\\t\\tans = append(ans, str)\\n\\t}\\n\\n\\tfor i := 1; i < len(str); i++ {\\n\\t\\tbuff := str[0:i] + \".\" + str[i:]\\n\\t\\tif checkNum(buff, false, false) {\\n\\t\\t\\tans = append(ans, buff)\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n\\nfunc checkNum(s string, pre, after bool) bool {\\n\\tif len(s) == 1 && strings.Contains(s, \"0\") && pre && !after {\\n\\t\\treturn true\\n\\t}\\n\\n\\tif len(s) == 1 && strings.Contains(s, \"0\") && !pre && after {\\n\\t\\treturn false\\n\\t}\\n\\n\\tif !strings.Contains(s, \".\") && pre && !after {\\n\\t\\tfor i := len(s) - 1; i >= 0; i-- {\\n\\t\\t\\tif strings.ContainsAny(s[:i], \"123456789\") {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif strings.Contains(s[:i], \"0\") {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\n\\tif !strings.Contains(s, \".\") && !pre && after {\\n\\t\\tfor i := 0; i < len(s); i++ {\\n\\t\\t\\t// fmt.Println(s[i:])\\n\\t\\t\\tif strings.ContainsAny(s[i:], \"123456789\") {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif strings.Contains(s[i:], \"0\") {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif !pre && !after {\\n\\t\\tif strings.Contains(s, \".\") {\\n\\t\\t\\ti := strings.IndexByte(s, \\'.\\')\\n\\n\\t\\t\\tif checkNum(s[:i], true, false) && checkNum(s[i+1:], false, true) {\\n\\t\\t\\t\\tgoto end\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor i := len(s) - 1; i >= 0; i-- {\\n\\t\\t\\t\\tif strings.ContainsAny(s[:i], \"123456789\") {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif strings.Contains(s[:i], \"0\") {\\n\\t\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\nend:\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1215760,
                "title": "93-time-55-space",
                "content": "```\\nclass Solution:\\n    \\n    def validate(self, s: str) -> bool:\\n        \\n        left_zero_count = 0\\n        \\n        if s[0] == \\'0\\' and s[1] != \\'.\\':\\n            return False\\n        \\n        if s[-1] == \\'0\\':\\n            return False\\n        \\n        return True\\n    \\n    def get_possibles(self, s: str, prefix: str, suffix: str) -> list:\\n        \\n        poss = []\\n        if s[0] != \\'0\\' or s==\"0\":\\n            poss.append(prefix + s + suffix)\\n        \\n        for d in range(1, len(s)):\\n            k = s[:d]+\".\"+s[d:]\\n            if self.validate(k):\\n                poss.append(prefix + k + suffix)\\n        \\n        return poss\\n\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        poss = []\\n        # print(s)\\n        for i in range(1,len(s), 1):\\n            # print(s[:i], s[i:])\\n            poss_1 = self.get_possibles(s[:i], \"(\", \", \")\\n            poss_2 = self.get_possibles(s[i:], \"\", \")\")\\n            poss += list(itertools.product(poss_1, poss_2))\\n        \\n        \\n        if len(poss) == 0:\\n            return []\\n        return [a[0]+a[1] for a in poss]\\n        \\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def validate(self, s: str) -> bool:\\n        \\n        left_zero_count = 0\\n        \\n        if s[0] == \\'0\\' and s[1] != \\'.\\':\\n            return False\\n        \\n        if s[-1] == \\'0\\':\\n            return False\\n        \\n        return True\\n    \\n    def get_possibles(self, s: str, prefix: str, suffix: str) -> list:\\n        \\n        poss = []\\n        if s[0] != \\'0\\' or s==\"0\":\\n            poss.append(prefix + s + suffix)\\n        \\n        for d in range(1, len(s)):\\n            k = s[:d]+\".\"+s[d:]\\n            if self.validate(k):\\n                poss.append(prefix + k + suffix)\\n        \\n        return poss\\n\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        poss = []\\n        # print(s)\\n        for i in range(1,len(s), 1):\\n            # print(s[:i], s[i:])\\n            poss_1 = self.get_possibles(s[:i], \"(\", \", \")\\n            poss_2 = self.get_possibles(s[i:], \"\", \")\")\\n            poss += list(itertools.product(poss_1, poss_2))\\n        \\n        \\n        if len(poss) == 0:\\n            return []\\n        return [a[0]+a[1] for a in poss]\\n        \\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1211835,
                "title": "python-3-solution",
                "content": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        def gnrtnum(s):\\n            \\'\\'\\'\\n            This function is to generate valid numbers for each input string.\\n            \\'\\'\\'\\n            l=len(s)\\n            # only one digit, then return the only possible one s\\n            if l==1:\\n                return [s]\\n            # if start with 0 and end with 0, it could only be the format of \\n            # 0.110 which should have been generated in last step of 0.11\\n            # so return empty to skip this step\\n            if s[0]==\\'0\\' and s[-1]==\\'0\\':\\n                return []\\n            # if input string start with 0, then there is only one valid \\n            # number could be generated like 0.11\\n            if s[0]==\\'0\\':\\n                return [\\'0.\\'+s[1:]]\\n            # if input string end with 0, then there is only one valid number\\n            # could be generated like 110\\n            if s[-1]==\\'0\\':\\n                return [s]\\n            nums=[s]\\n            for i in range(1,len(s)):\\n                num=s[:i]+\\'.\\'+s[i:]\\n                nums.append(num)\\n            return nums\\n        nums=[]\\n        for i in range(2,len(s)-1):\\n            nums1=gnrtnum(s[1:i])\\n            nums2=gnrtnum(s[i:-1])\\n            if not nums1 or not nums2:\\n                continue\\n            for a,b in product(nums1, nums2):\\n                nums.append(f\\'({a}, {b})\\')\\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        def gnrtnum(s):\\n            \\'\\'\\'\\n            This function is to generate valid numbers for each input string.\\n            \\'\\'\\'\\n            l=len(s)\\n            # only one digit, then return the only possible one s\\n            if l==1:\\n                return [s]\\n            # if start with 0 and end with 0, it could only be the format of \\n            # 0.110 which should have been generated in last step of 0.11\\n            # so return empty to skip this step\\n            if s[0]==\\'0\\' and s[-1]==\\'0\\':\\n                return []\\n            # if input string start with 0, then there is only one valid \\n            # number could be generated like 0.11\\n            if s[0]==\\'0\\':\\n                return [\\'0.\\'+s[1:]]\\n            # if input string end with 0, then there is only one valid number\\n            # could be generated like 110\\n            if s[-1]==\\'0\\':\\n                return [s]\\n            nums=[s]\\n            for i in range(1,len(s)):\\n                num=s[:i]+\\'.\\'+s[i:]\\n                nums.append(num)\\n            return nums\\n        nums=[]\\n        for i in range(2,len(s)-1):\\n            nums1=gnrtnum(s[1:i])\\n            nums2=gnrtnum(s[i:-1])\\n            if not nums1 or not nums2:\\n                continue\\n            for a,b in product(nums1, nums2):\\n                nums.append(f\\'({a}, {b})\\')\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211795,
                "title": "java-simple-commented-solution",
                "content": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        int n = s.length();\\n        List<String> result = new ArrayList<>();\\n        // i represents the point at which we partition the string into 2 coordinates\\n        for(int i = 2; i<n-1; i++) {\\n             \\n\\t\\t\\t //find all possible representations for left coordinate\\n            List<String> left = find(s.substring(1,i));\\n\\t\\t\\t//if left coordinates are empty, then we can skip this partition point\\n\\t\\t\\t//no need to calculate right coordinates\\n            if(left.isEmpty()) continue;\\n            \\n            List<String> right = find(s.substring(i, n-1));\\n            \\n\\t\\t\\t//each possible left coordinate can be combined with each right coordinate\\n            for(String l  : left){\\n                for(String r : right){\\n                    result.add(\"(\" + l + \", \" + r + \")\");\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private List<String> find(String s){\\n        \\n        if(s.length()==1)\\n            return Arrays.asList(s);\\n        \\n        if(s.charAt(0) == \\'0\\' && s.charAt(s.length()-1)==\\'0\\')\\n            return new ArrayList<>();\\n        \\n        if(s.charAt(0) == \\'0\\'){\\n            return Collections.singletonList(s.charAt(0) + \".\" + s.substring(1));\\n        }\\n        \\n        if(s.charAt(s.length()-1)==\\'0\\')   return Arrays.asList(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        res.add(s);\\n        for(int i = 0; i < s.length() - 1;  i++){\\n            res.add(s.substring(0, i+1) + \".\" + s.substring(i+1));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        int n = s.length();\\n        List<String> result = new ArrayList<>();\\n        // i represents the point at which we partition the string into 2 coordinates\\n        for(int i = 2; i<n-1; i++) {\\n             \\n\\t\\t\\t //find all possible representations for left coordinate\\n            List<String> left = find(s.substring(1,i));\\n\\t\\t\\t//if left coordinates are empty, then we can skip this partition point\\n\\t\\t\\t//no need to calculate right coordinates\\n            if(left.isEmpty()) continue;\\n            \\n            List<String> right = find(s.substring(i, n-1));\\n            \\n\\t\\t\\t//each possible left coordinate can be combined with each right coordinate\\n            for(String l  : left){\\n                for(String r : right){\\n                    result.add(\"(\" + l + \", \" + r + \")\");\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private List<String> find(String s){\\n        \\n        if(s.length()==1)\\n            return Arrays.asList(s);\\n        \\n        if(s.charAt(0) == \\'0\\' && s.charAt(s.length()-1)==\\'0\\')\\n            return new ArrayList<>();\\n        \\n        if(s.charAt(0) == \\'0\\'){\\n            return Collections.singletonList(s.charAt(0) + \".\" + s.substring(1));\\n        }\\n        \\n        if(s.charAt(s.length()-1)==\\'0\\')   return Arrays.asList(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        res.add(s);\\n        for(int i = 0; i < s.length() - 1;  i++){\\n            res.add(s.substring(0, i+1) + \".\" + s.substring(i+1));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210519,
                "title": "python-3-solution-explained",
                "content": "```\\nfrom itertools import product\\n\\n\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str):\\n        \"\"\"\\n        Given a string of digits, this program determines all\\n        possibilities of what two coordinates could be with the\\n        addition of decimal points, a comma, and a space.\\n\\n        :param s: 2-dimensional coordinates with all commas,\\n                  decimal points, and spaces removed\\n        :type s: str\\n        :return: array of all possibilities for what our original\\n                 coordinates could have been\\n        :rtype: list[str]\\n        \"\"\"\\n\\n        def is_valid(coord: str) -> bool:\\n            \"\"\"\\n            This method determines whether a given coordinate\\n            (coord) is valid or can be made valid with the addition\\n            of a decimal point.\\n\\n            :param coord: coordinate string containing only digits\\n            :type coord: str\\n            :return: True if coord is a valid coordinate or can\\n                     be converted to a valid coordinate with the\\n                     addition of a decimal point, else False\\n            :rtype: bool\\n            \"\"\"\\n\\n            \"\"\"\\n            A coordinate is valid if one of the following is true:\\n            - It contains a single digit.\\n            - The first digit or last digit is not \\'0\\'.\\n            \"\"\"\\n            if len(coord) == 1:\\n                return True\\n            if coord[0] == \\'0\\' and coord[-1] == \\'0\\':\\n                return False\\n            return True\\n\\n        def possibilities(coord: str):\\n            \"\"\"\\n            Given a string of digits (coord) that has passed\\n            a validity test that determined that at least one\\n            valid coordinate is possible, this program determines\\n            the list of all possible coordinates that can be\\n            derived from coord.\\n\\n            :param coord: validated string of digits\\n            :type coord: str\\n            :return: array of all possible coordinates that\\n                     can be derived from coord\\n            :rtype: list[str]\\n            \"\"\"\\n\\n            \"\"\"\\n            The following valid coordinates have exactly one\\n            possibility:\\n            - The coordinate has one digit.\\n            - The coordinate begins with \\'0\\'.\\n            - The coordinate ends with \\'0\\'.\\n            Otherwise, the possibilities consist of the unmodified\\n            coordinate plus the possibilities that can be generated\\n            by placing a decimal point between any two digits.\\n            \"\"\"\\n            len_coord = len(coord)\\n            if len_coord == 1:\\n                return [coord]\\n            if coord[0] == \\'0\\':\\n                return [\\'\\'.join([\\'0.\\', coord[1:]])]\\n            if coord[-1] == \\'0\\':\\n                return [coord]\\n            result = [coord]\\n            for decimal in range(1, len_coord):\\n                result.append(\\'\\'.join([coord[:decimal], \\'.\\', coord[decimal:]]))\\n            return result\\n\\n        \"\"\"\\n        - Extract the contents of s by removing the outer parentheses\\n          and store them in content.\\n        - Store the length of content in len_content.\\n        - result will contain the output from this program.\\n        \"\"\"\\n        len_s = len(s)\\n        content = s[1:len_s - 1]\\n        len_content = len(content)\\n        result = []\\n        \\n        \"\"\"\\n        Main Loop:\\n        - Partition content into two coordinates (coord_1, coord_2).\\n        - If both coordinates pass a validity test using the\\n          is_valid method:\\n          - Use the possibilities method to generate a list of\\n            possibilities for each coordinate. Store the results\\n            for coord_1 and coord_2 in list_1 and list_2, respectively.\\n          - Generate coordinate pairs (pairs) from the list product\\n            of list_1 and list_2.\\n          - Add each pair to result in the correct format.\\n        \"\"\"\\n        for k in range(1, len_content):\\n            coord_1 = content[:k]\\n            coord_2 = content[k:]\\n            if is_valid(coord_1) and is_valid(coord_2):\\n                list_1 = possibilities(coord_1)\\n                list_2 = possibilities(coord_2)\\n                pairs = list(product(list_1, list_2))\\n                for p1, p2 in pairs:\\n                    result.append(\\'\\'.join([\\'(\\', p1, \\', \\', p2, \\')\\']))\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import product\\n\\n\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str):\\n        \"\"\"\\n        Given a string of digits, this program determines all\\n        possibilities of what two coordinates could be with the\\n        addition of decimal points, a comma, and a space.\\n\\n        :param s: 2-dimensional coordinates with all commas,\\n                  decimal points, and spaces removed\\n        :type s: str\\n        :return: array of all possibilities for what our original\\n                 coordinates could have been\\n        :rtype: list[str]\\n        \"\"\"\\n\\n        def is_valid(coord: str) -> bool:\\n            \"\"\"\\n            This method determines whether a given coordinate\\n            (coord) is valid or can be made valid with the addition\\n            of a decimal point.\\n\\n            :param coord: coordinate string containing only digits\\n            :type coord: str\\n            :return: True if coord is a valid coordinate or can\\n                     be converted to a valid coordinate with the\\n                     addition of a decimal point, else False\\n            :rtype: bool\\n            \"\"\"\\n\\n            \"\"\"\\n            A coordinate is valid if one of the following is true:\\n            - It contains a single digit.\\n            - The first digit or last digit is not \\'0\\'.\\n            \"\"\"\\n            if len(coord) == 1:\\n                return True\\n            if coord[0] == \\'0\\' and coord[-1] == \\'0\\':\\n                return False\\n            return True\\n\\n        def possibilities(coord: str):\\n            \"\"\"\\n            Given a string of digits (coord) that has passed\\n            a validity test that determined that at least one\\n            valid coordinate is possible, this program determines\\n            the list of all possible coordinates that can be\\n            derived from coord.\\n\\n            :param coord: validated string of digits\\n            :type coord: str\\n            :return: array of all possible coordinates that\\n                     can be derived from coord\\n            :rtype: list[str]\\n            \"\"\"\\n\\n            \"\"\"\\n            The following valid coordinates have exactly one\\n            possibility:\\n            - The coordinate has one digit.\\n            - The coordinate begins with \\'0\\'.\\n            - The coordinate ends with \\'0\\'.\\n            Otherwise, the possibilities consist of the unmodified\\n            coordinate plus the possibilities that can be generated\\n            by placing a decimal point between any two digits.\\n            \"\"\"\\n            len_coord = len(coord)\\n            if len_coord == 1:\\n                return [coord]\\n            if coord[0] == \\'0\\':\\n                return [\\'\\'.join([\\'0.\\', coord[1:]])]\\n            if coord[-1] == \\'0\\':\\n                return [coord]\\n            result = [coord]\\n            for decimal in range(1, len_coord):\\n                result.append(\\'\\'.join([coord[:decimal], \\'.\\', coord[decimal:]]))\\n            return result\\n\\n        \"\"\"\\n        - Extract the contents of s by removing the outer parentheses\\n          and store them in content.\\n        - Store the length of content in len_content.\\n        - result will contain the output from this program.\\n        \"\"\"\\n        len_s = len(s)\\n        content = s[1:len_s - 1]\\n        len_content = len(content)\\n        result = []\\n        \\n        \"\"\"\\n        Main Loop:\\n        - Partition content into two coordinates (coord_1, coord_2).\\n        - If both coordinates pass a validity test using the\\n          is_valid method:\\n          - Use the possibilities method to generate a list of\\n            possibilities for each coordinate. Store the results\\n            for coord_1 and coord_2 in list_1 and list_2, respectively.\\n          - Generate coordinate pairs (pairs) from the list product\\n            of list_1 and list_2.\\n          - Add each pair to result in the correct format.\\n        \"\"\"\\n        for k in range(1, len_content):\\n            coord_1 = content[:k]\\n            coord_2 = content[k:]\\n            if is_valid(coord_1) and is_valid(coord_2):\\n                list_1 = possibilities(coord_1)\\n                list_2 = possibilities(coord_2)\\n                pairs = list(product(list_1, list_2))\\n                for p1, p2 in pairs:\\n                    result.append(\\'\\'.join([\\'(\\', p1, \\', \\', p2, \\')\\']))\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207893,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    bool good(string s) {\\n        int n = s.size();\\n        int dot = 0;\\n        if(n > 1 && s[0] == \\'0\\' && s[1] != \\'.\\') {\\n            return false;\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'.\\') {\\n                dot++;\\n                if(s.substr(i + 1) == string(n - i - 1, \\'0\\'))\\n                    return false;\\n            }\\n        }\\n        if(dot == 1 && s.back() == \\'0\\')\\n            return false;\\n        if(dot <= 1)\\n            return true;\\n        return false;\\n    }\\n    void dfs(string s, vector<string>& a, int pos, string b) {\\n        if(pos == (int) s.size()) {\\n            a.push_back(b);\\n            return;\\n        }\\n        b.push_back(s[pos]);\\n        b.push_back(\\'.\\');\\n        dfs(s, a, pos + 1, b);\\n        if(b.back() == \\'.\\')\\n            b.pop_back();\\n        dfs(s, a, pos + 1, b);\\n    }\\n    vector<string> getStrings(string s) {\\n        vector<string> a;\\n        dfs(s, a, 0, \"\");\\n        return a;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        s.erase(s.begin());\\n        s.pop_back();\\n        int n = s.size();\\n        for(int split = 0; split < n - 1; split++) {\\n            vector<string> a =  getStrings(s.substr(0, split + 1));\\n            vector<string> b = getStrings(s.substr(split + 1));\\n            for(string c : a) {\\n                for(string d : b) {\\n                    if(good(c) && good(d)) {\\n                        string sol = \"(\" + c + \", \" + d + \")\";\\n                        ans.push_back(sol);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    bool good(string s) {\\n        int n = s.size();\\n        int dot = 0;\\n        if(n > 1 && s[0] == \\'0\\' && s[1] != \\'.\\') {\\n            return false;\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'.\\') {\\n                dot++;\\n                if(s.substr(i + 1) == string(n - i - 1, \\'0\\'))\\n                    return false;\\n            }\\n        }\\n        if(dot == 1 && s.back() == \\'0\\')\\n            return false;\\n        if(dot <= 1)\\n            return true;\\n        return false;\\n    }\\n    void dfs(string s, vector<string>& a, int pos, string b) {\\n        if(pos == (int) s.size()) {\\n            a.push_back(b);\\n            return;\\n        }\\n        b.push_back(s[pos]);\\n        b.push_back(\\'.\\');\\n        dfs(s, a, pos + 1, b);\\n        if(b.back() == \\'.\\')\\n            b.pop_back();\\n        dfs(s, a, pos + 1, b);\\n    }\\n    vector<string> getStrings(string s) {\\n        vector<string> a;\\n        dfs(s, a, 0, \"\");\\n        return a;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        s.erase(s.begin());\\n        s.pop_back();\\n        int n = s.size();\\n        for(int split = 0; split < n - 1; split++) {\\n            vector<string> a =  getStrings(s.substr(0, split + 1));\\n            vector<string> b = getStrings(s.substr(split + 1));\\n            for(string c : a) {\\n                for(string d : b) {\\n                    if(good(c) && good(d)) {\\n                        string sol = \"(\" + c + \", \" + d + \")\";\\n                        ans.push_back(sol);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207680,
                "title": "js-split-by-comma-then-put-decimal",
                "content": "```\\nvar ambiguousCoordinates = function(s) {\\n    let list = putComma(s.match(/\\\\d+/)[0]);\\n    let ans = [];\\n    for(let l of list)\\n        putDecimal(l, ans);\\n    return ans;      \\n};\\n\\nvar putComma = function(s) {\\n    let l = [];\\n    let i = 1;\\n    while(i < s.length) {\\n        l.push([s.slice(0,i), s.slice(i)])\\n        i++;\\n    } \\n    return l;\\n}\\nvar putDecimal = function([first, second], ans) {\\n    let firstSet = putDecimalPerString(first);\\n    let secondSet = putDecimalPerString(second);\\n    for(let f of firstSet)\\n        for(let s of secondSet)\\n            ans.push(`(${f}, ${s})`);\\n}\\nvar putDecimalPerString = function(s) {\\n    if(s.length === 1)\\n        return [s];\\n    else {\\n        let ans = s === \"\"+Number(s) ? [s] : [];\\n        let i = 1;\\n        while(i < s.length) {\\n            let s_n = s.slice(0,i) + \\'.\\' + s.slice(i);\\n            if(s_n === \"\" + Number(s_n))\\n                ans.push(s_n);\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar ambiguousCoordinates = function(s) {\\n    let list = putComma(s.match(/\\\\d+/)[0]);\\n    let ans = [];\\n    for(let l of list)\\n        putDecimal(l, ans);\\n    return ans;      \\n};\\n\\nvar putComma = function(s) {\\n    let l = [];\\n    let i = 1;\\n    while(i < s.length) {\\n        l.push([s.slice(0,i), s.slice(i)])\\n        i++;\\n    } \\n    return l;\\n}\\nvar putDecimal = function([first, second], ans) {\\n    let firstSet = putDecimalPerString(first);\\n    let secondSet = putDecimalPerString(second);\\n    for(let f of firstSet)\\n        for(let s of secondSet)\\n            ans.push(`(${f}, ${s})`);\\n}\\nvar putDecimalPerString = function(s) {\\n    if(s.length === 1)\\n        return [s];\\n    else {\\n        let ans = s === \"\"+Number(s) ? [s] : [];\\n        let i = 1;\\n        while(i < s.length) {\\n            let s_n = s.slice(0,i) + \\'.\\' + s.slice(i);\\n            if(s_n === \"\" + Number(s_n))\\n                ans.push(s_n);\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1207623,
                "title": "java-solution-100-beat",
                "content": "```\\nclass Solution {\\n    public List<String> xPoss, ans;\\n    public List<String> ambiguousCoordinates(String s) {\\n        ans = new ArrayList<>();   \\n        for(int i = 2; i < s.length() - 1; i++){\\n            String[] str = {s.substring(1, i), s.substring(i, s.length() - 1)};\\n            xPoss = new ArrayList<>();\\n            for(int j = 0; j < 2; j++){\\n                if(xPoss.size() > 0 || j == 0) placDec(str[j], j);\\n            }\\n        }\\n        return ans;\\n    }\\n    public void placDec(String str, int lr){\\n        if(str.length() == 1 || str.charAt(0) != \\'0\\')\\n            process(str, lr);\\n        if(str.length() > 1 && str.charAt(str.length() - 1) != \\'0\\') \\n            process(str.substring(0, 1) + \".\" + str.substring(1), lr);\\n        if(str.length() > 2 && str.charAt(0) != \\'0\\' && str.charAt(str.length() - 1) != \\'0\\')\\n            for(int j = 2; j < str.length(); j++)\\n                process(str.substring(0, j) + \".\" + str.substring(j), lr);\\n    } \\n    public void process(String str, int lr){\\n        if(lr > 0){\\n          for (String x : xPoss)\\n                ans.add(\"(\" + x + \", \" + str + \")\");\\n        }\\n        else xPoss.add(str);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> xPoss, ans;\\n    public List<String> ambiguousCoordinates(String s) {\\n        ans = new ArrayList<>();   \\n        for(int i = 2; i < s.length() - 1; i++){\\n            String[] str = {s.substring(1, i), s.substring(i, s.length() - 1)};\\n            xPoss = new ArrayList<>();\\n            for(int j = 0; j < 2; j++){\\n                if(xPoss.size() > 0 || j == 0) placDec(str[j], j);\\n            }\\n        }\\n        return ans;\\n    }\\n    public void placDec(String str, int lr){\\n        if(str.length() == 1 || str.charAt(0) != \\'0\\')\\n            process(str, lr);\\n        if(str.length() > 1 && str.charAt(str.length() - 1) != \\'0\\') \\n            process(str.substring(0, 1) + \".\" + str.substring(1), lr);\\n        if(str.length() > 2 && str.charAt(0) != \\'0\\' && str.charAt(str.length() - 1) != \\'0\\')\\n            for(int j = 2; j < str.length(); j++)\\n                process(str.substring(0, j) + \".\" + str.substring(j), lr);\\n    } \\n    public void process(String str, int lr){\\n        if(lr > 0){\\n          for (String x : xPoss)\\n                ans.add(\"(\" + x + \", \" + str + \")\");\\n        }\\n        else xPoss.add(str);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207599,
                "title": "faster-than-100-python-submissions",
                "content": "If we are given string s, then the idea to first try to break the string based on `,` into say `s[:i]` and `s[i:]` and then brute force into all possible numbers formed by `s[:i]` and `s[i:]`\\n\\nFor a number to be well formed, it shouldn\\'t  start with `0`\\'s and after decimal it shouldn\\'t end with `0`\\n```python\\nfrom itertools import product\\n\\nclass Solution(object):\\n    def get(self, s):\\n        # Returns the different numbers formed with string s\\n        ret = []\\n        for i in range(1, len(s)+1):\\n            s1, s2 = s[:i], s[i:]\\n            if (s1[0]==\\'0\\' and len(s1)>1) or (len(s2)>0 and s2[-1]==\\'0\\'):\\n                continue\\n            ret += [str(s1)] if len(s2)==0 else [str(s1 + \\'.\\' + s2)]\\n        return ret\\n                   \\n    def ambiguousCoordinates(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        s = s[1:-1]\\n        ret = []\\n        for i in range(1,len(s)):\\n            # Split s by comma -> s[:i] and s[i:]\\n            for (x, y) in product(self.get(s[:i]), self.get(s[i:])):\\n                ret += [\"(\" + x + \", \" + y + \")\" ]\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom itertools import product\\n\\nclass Solution(object):\\n    def get(self, s):\\n        # Returns the different numbers formed with string s\\n        ret = []\\n        for i in range(1, len(s)+1):\\n            s1, s2 = s[:i], s[i:]\\n            if (s1[0]==\\'0\\' and len(s1)>1) or (len(s2)>0 and s2[-1]==\\'0\\'):\\n                continue\\n            ret += [str(s1)] if len(s2)==0 else [str(s1 + \\'.\\' + s2)]\\n        return ret\\n                   \\n    def ambiguousCoordinates(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        s = s[1:-1]\\n        ret = []\\n        for i in range(1,len(s)):\\n            # Split s by comma -> s[:i] and s[i:]\\n            for (x, y) in product(self.get(s[:i]), self.get(s[i:])):\\n                ret += [\"(\" + x + \", \" + y + \")\" ]\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207532,
                "title": "python-easy-problem-breakdown-steps",
                "content": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        cache = {}\\n        decimal_cache = {}\\n\\t\\t\"\"\"\\n\\t\\tUsing caches to save operations on similar segments if done earlier\\n\\t\\tAs 11111 will break into\\n\\t\\t1 1111\\n\\t\\t11 111\\n\\t\\t111 11\\n\\t\\t1111 1\\n\\t\\tLeft and right segments will repeat\\n\\t\\t\"\"\"\\n        s = s[1:len(s) - 1]\\n\\n        def is_valid(subs: str) -> (bool, List[str]):\\n            if subs == \\'0\\':\\n                return True, [subs]\\n\\n            if len(subs) > 0 and subs[0] == \\'0\\' and subs[-1] == \\'0\\':\\n\\t\\t\\t    \"\"\"\\n\\t\\t\\t\\tBegining and ending with 0 not allowed\\n\\t\\t\\t\\tsegment 01230 or 0010 not allowed to be 0.010 or 0.1230\\n\\t\\t\\t\\t\"\"\"\\n                return False, []\\n\\n            if subs[-1] == \\'0\\':\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tEnding with 0 are allowed to be whole numbers only\\n\\t\\t\\t\\teg: the segment 1230 can be 1230 only\\n\\t\\t\\t\\tor 10 can be 10 only and not 1.0\\n\\t\\t\\t\\t\"\"\"\\n                return True, [subs]\\n\\n            # place decimal\\n            if subs[0] == \\'0\\':\\n                \"\"\"\\n                decimal can only be placed in position 1\\n\\t\\t\\t\\teg: 0123 can be 0.123\\n\\t\\t\\t\\t\"\"\"\\n                return True, [f\\'{subs[0]}.{subs[1:]}\\']\\n            else:\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tFor regular non 0 begining/ ending numbers can have decimals\\n\\t\\t\\t\\tin between every two digits\\n\\t\\t\\t\\t\"\"\"\\n                if subs in decimal_cache:\\n                    return decimal_cache[subs]\\n                res = [subs]\\n                if res[-1] == 0:\\n                    return True, res\\n\\n                for i in range(1, len(subs)):\\n                    l, r = subs[:i], subs[i:]\\n                    res.append(f\\'{l}.{r}\\')\\n                decimal_cache[subs] = True, res\\n                return decimal_cache[subs]\\n\\n\\t\\tres = set()\\n        for i in range(1, len(s)):\\n            left_subs, right_subs = s[:i], s[i:]\\n\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tFor each segment check cache first and if not valid move to next\\n\\t\\t\\tOnly if both valid add to final result set\\n\\t\\t\\t\"\"\"\\n\\n            if left_subs not in cache:\\n                cache[left_subs] = is_valid(left_subs)\\n\\n            left_is_valid, left_res = cache[left_subs]\\n            if not left_is_valid:\\n                continue\\n\\n            if right_subs not in cache:\\n                cache[right_subs] = is_valid(right_subs)\\n\\n            right_is_valid, right_res = cache[right_subs]\\n            if not right_is_valid:\\n                continue\\n\\n            for _, lv in enumerate(left_res):\\n                for _, rv in enumerate(right_res):\\n                    res.add(f\\'({lv}, {rv})\\')\\n\\n        return list(res)\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        cache = {}\\n        decimal_cache = {}\\n\\t\\t\"\"\"\\n\\t\\tUsing caches to save operations on similar segments if done earlier\\n\\t\\tAs 11111 will break into\\n\\t\\t1 1111\\n\\t\\t11 111\\n\\t\\t111 11\\n\\t\\t1111 1\\n\\t\\tLeft and right segments will repeat\\n\\t\\t\"\"\"\\n        s = s[1:len(s) - 1]\\n\\n        def is_valid(subs: str) -> (bool, List[str]):\\n            if subs == \\'0\\':\\n                return True, [subs]\\n\\n            if len(subs) > 0 and subs[0] == \\'0\\' and subs[-1] == \\'0\\':\\n\\t\\t\\t    \"\"\"\\n\\t\\t\\t\\tBegining and ending with 0 not allowed\\n\\t\\t\\t\\tsegment 01230 or 0010 not allowed to be 0.010 or 0.1230\\n\\t\\t\\t\\t\"\"\"\\n                return False, []\\n\\n            if subs[-1] == \\'0\\':\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tEnding with 0 are allowed to be whole numbers only\\n\\t\\t\\t\\teg: the segment 1230 can be 1230 only\\n\\t\\t\\t\\tor 10 can be 10 only and not 1.0\\n\\t\\t\\t\\t\"\"\"\\n                return True, [subs]\\n\\n            # place decimal\\n            if subs[0] == \\'0\\':\\n                \"\"\"\\n                decimal can only be placed in position 1\\n\\t\\t\\t\\teg: 0123 can be 0.123\\n\\t\\t\\t\\t\"\"\"\\n                return True, [f\\'{subs[0]}.{subs[1:]}\\']\\n            else:\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tFor regular non 0 begining/ ending numbers can have decimals\\n\\t\\t\\t\\tin between every two digits\\n\\t\\t\\t\\t\"\"\"\\n                if subs in decimal_cache:\\n                    return decimal_cache[subs]\\n                res = [subs]\\n                if res[-1] == 0:\\n                    return True, res\\n\\n                for i in range(1, len(subs)):\\n                    l, r = subs[:i], subs[i:]\\n                    res.append(f\\'{l}.{r}\\')\\n                decimal_cache[subs] = True, res\\n                return decimal_cache[subs]\\n\\n\\t\\tres = set()\\n        for i in range(1, len(s)):\\n            left_subs, right_subs = s[:i], s[i:]\\n\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tFor each segment check cache first and if not valid move to next\\n\\t\\t\\tOnly if both valid add to final result set\\n\\t\\t\\t\"\"\"\\n\\n            if left_subs not in cache:\\n                cache[left_subs] = is_valid(left_subs)\\n\\n            left_is_valid, left_res = cache[left_subs]\\n            if not left_is_valid:\\n                continue\\n\\n            if right_subs not in cache:\\n                cache[right_subs] = is_valid(right_subs)\\n\\n            right_is_valid, right_res = cache[right_subs]\\n            if not right_is_valid:\\n                continue\\n\\n            for _, lv in enumerate(left_res):\\n                for _, rv in enumerate(right_res):\\n                    res.add(f\\'({lv}, {rv})\\')\\n\\n        return list(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207500,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    func ambiguousCoordinates(_ s: String) -> [String] {\\n        let s = Array(s)[1...(s.count - 2)].map({ Int($0.asciiValue ?? 48) - 48 }), c = s.count\\n        var result = [String](), d1 = 0\\n        for1: for i1 in 0..<(c - 1) {\\n            var d2 = 0, tz2 = 0\\n            if s[0] == 0 && i1 > 0 { break for1 } // leading zero\\n            d1 = d1 * 10 + s[i1]\\n            for2: for i2 in i1..<(c - 1) {\\n                var d3 = 0\\n                if i2 > i1 { d2 = d2 * 10 + s[i2] }\\n                if i2 > i1 && d2 == 0 { tz2 += 1 } // counting leading zeros for d2\\n                if i2 > i1 && s[i2] == 0 { continue for2 } // trailing zero\\n                for3: for i3 in (i2 + 1)..<c {\\n                    var d4 = 0, tz4 = 0\\n                    if s[i2 + 1] == 0 && i3 > i2 + 1 { break for3 } // leading zero\\n                    d3 = d3 * 10 + s[i3]\\n                    for4: for i4 in i3..<c {\\n                        if i4 > i3 { d4 = d4 * 10 + s[i4] }\\n                        if i4 > i3 && d4 == 0 { tz4 += 1 } // counting leading zeros for d4\\n                        if i4 > i3 && s[i4] == 0 { continue for4 } // trailing zero\\n                        if i4 == c - 1 {\\n                            result.append(\"(\\\\(d1)\\\\(i2 > i1 ? \".\\\\(String(repeating: \"0\", count: tz2))\\\\(d2)\" : \"\"), \\\\(d3)\\\\(i4 > i3 ? \".\\\\(String(repeating: \"0\", count: tz4))\\\\(d4)\" : \"\"))\")\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func ambiguousCoordinates(_ s: String) -> [String] {\\n        let s = Array(s)[1...(s.count - 2)].map({ Int($0.asciiValue ?? 48) - 48 }), c = s.count\\n        var result = [String](), d1 = 0\\n        for1: for i1 in 0..<(c - 1) {\\n            var d2 = 0, tz2 = 0\\n            if s[0] == 0 && i1 > 0 { break for1 } // leading zero\\n            d1 = d1 * 10 + s[i1]\\n            for2: for i2 in i1..<(c - 1) {\\n                var d3 = 0\\n                if i2 > i1 { d2 = d2 * 10 + s[i2] }\\n                if i2 > i1 && d2 == 0 { tz2 += 1 } // counting leading zeros for d2\\n                if i2 > i1 && s[i2] == 0 { continue for2 } // trailing zero\\n                for3: for i3 in (i2 + 1)..<c {\\n                    var d4 = 0, tz4 = 0\\n                    if s[i2 + 1] == 0 && i3 > i2 + 1 { break for3 } // leading zero\\n                    d3 = d3 * 10 + s[i3]\\n                    for4: for i4 in i3..<c {\\n                        if i4 > i3 { d4 = d4 * 10 + s[i4] }\\n                        if i4 > i3 && d4 == 0 { tz4 += 1 } // counting leading zeros for d4\\n                        if i4 > i3 && s[i4] == 0 { continue for4 } // trailing zero\\n                        if i4 == c - 1 {\\n                            result.append(\"(\\\\(d1)\\\\(i2 > i1 ? \".\\\\(String(repeating: \"0\", count: tz2))\\\\(d2)\" : \"\"), \\\\(d3)\\\\(i4 > i3 ? \".\\\\(String(repeating: \"0\", count: tz4))\\\\(d4)\" : \"\"))\")\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207357,
                "title": "c-clean-solution-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> res;\\n        string a = s.substr(1,1), b = s.substr(2);\\n        b.pop_back();\\n        while(!b.empty()) {\\n            vector<string> left = getStrDots(a);\\n            vector<string> right = getStrDots(b);\\n            for(string lstr : left) {\\n                for(string rstr: right) res.push_back(\"(\"+lstr+\", \"+rstr+\")\");\\n            }\\n            a.push_back(b.front());\\n            b.erase(0,1);\\n        }\\n        return res;\\n    }\\n    \\n     //generating all valid cordinates of givens str\\n    vector<string> getStrDots(string &str) {\\n        vector<string> res;\\n        if(isValidStr(str)) res.emplace_back(str);\\n        for(int i = 1; i < str.size(); i++) {\\n            string temp = str.substr(0, i) + \".\" + str.substr(i);\\n            if(isValidStr(temp)) res.emplace_back(temp);\\n        }\\n        return res;\\n    }\\n    \\n    \\n    bool isValidStr(string &str) {\\n        // handle case of .12, 123., .0\\n        if(str.size() > 0 && (str[0] == \\'.\\' || str.back() == \\'.\\')) return false;\\n        //handle case of 12.0, 123.00, 0.0\\n        if(str.size() > 1 && str.find(\".\") != string::npos && str.back() == \\'0\\') return false;\\n        // handle case of 01, 001, 0123\\n        if(str.size() > 1 && str[0] == \\'0\\' && str[1] != \\'.\\') return false;\\n        return true;\\n    }\\n    \\n};\\n\\n// for I/O operation Faster\\n#pragma GCC optimize(\"Ofast\")\\nstatic const auto io_sync_off = []()\\n{\\n    std::ios::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n    std::cout.tie(nullptr);\\n    return nullptr;\\n}();\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> res;\\n        string a = s.substr(1,1), b = s.substr(2);\\n        b.pop_back();\\n        while(!b.empty()) {\\n            vector<string> left = getStrDots(a);\\n            vector<string> right = getStrDots(b);\\n            for(string lstr : left) {\\n                for(string rstr: right) res.push_back(\"(\"+lstr+\", \"+rstr+\")\");\\n            }\\n            a.push_back(b.front());\\n            b.erase(0,1);\\n        }\\n        return res;\\n    }\\n    \\n     //generating all valid cordinates of givens str\\n    vector<string> getStrDots(string &str) {\\n        vector<string> res;\\n        if(isValidStr(str)) res.emplace_back(str);\\n        for(int i = 1; i < str.size(); i++) {\\n            string temp = str.substr(0, i) + \".\" + str.substr(i);\\n            if(isValidStr(temp)) res.emplace_back(temp);\\n        }\\n        return res;\\n    }\\n    \\n    \\n    bool isValidStr(string &str) {\\n        // handle case of .12, 123., .0\\n        if(str.size() > 0 && (str[0] == \\'.\\' || str.back() == \\'.\\')) return false;\\n        //handle case of 12.0, 123.00, 0.0\\n        if(str.size() > 1 && str.find(\".\") != string::npos && str.back() == \\'0\\') return false;\\n        // handle case of 01, 001, 0123\\n        if(str.size() > 1 && str[0] == \\'0\\' && str[1] != \\'.\\') return false;\\n        return true;\\n    }\\n    \\n};\\n\\n// for I/O operation Faster\\n#pragma GCC optimize(\"Ofast\")\\nstatic const auto io_sync_off = []()\\n{\\n    std::ios::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n    std::cout.tie(nullptr);\\n    return nullptr;\\n}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1207356,
                "title": "c-explanation-easy-to-understand-with-comments",
                "content": "First, we process the input string to remove the `(` and `)` characters at the beginning and end respectively. Now, we can place commas at `n-1` positions, where `n` is the length of the processed string. For each of these cases, we divide the string into left and right subparts. For each subpart, we place a decimal point after each character, except in the following edge cases:\\n1. If the last character of the subpart is `0`, we return, since there is no point in putting a decimal point with a zero at the end.\\n2. If the subpart has a leading `0`, then we can place a decimal point only after the first character i.e. only after the first `0`\\n\\nHere is the code:\\n```\\nclass Solution {\\npublic:\\n    vector <string> putDecimal(string &s, int startIdx, int endIdx){\\n        //if subpart\\'s len == endIdx-startIdx+1 == 1, return itself\\n        if(endIdx - startIdx + 1 == 1)\\n            return {s.substr(startIdx, 1)};\\n        vector <string> ret;\\n        // if subpart does not contain a leading zero, we can add the whole subpart to the result without placing a decimal point  \\n        if(s[startIdx] != \\'0\\')\\n            ret.push_back(s.substr(startIdx, endIdx - startIdx + 1));\\n        //edge case 1 mentioned above\\n        if(s[endIdx] == \\'0\\')\\n            return ret;\\n        for(int i = startIdx ; i < endIdx ; i++){\\n            //edge case 2 mentioned above\\n            if(s[startIdx] == \\'0\\' && i > startIdx)\\n                break;\\n            string tmp = s.substr(startIdx, i - startIdx + 1) + \\'.\\' + s.substr(i + 1, endIdx - i);\\n            ret.push_back(tmp);\\n        }\\n        return ret;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.size();\\n        //preprocess the input string\\n        s = s.substr(1, n-2);\\n        vector <string> ans;\\n        n = s.size();\\n        // trying to put commas at all the valid positions\\n        for(int i = 0 ; i < n-1 ; i++){\\n            // divide into left and right subparts\\n            vector <string> part1 = putDecimal(s, 0, i), part2 = putDecimal(s, i+1, n-1);\\n            //combine the results of the left and right subparts\\n            for(string s1:part1){\\n                for(string s2:part2)\\n                    ans.push_back(\\'(\\' + s1 + \", \" + s2 + \\')\\');\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <string> putDecimal(string &s, int startIdx, int endIdx){\\n        //if subpart\\'s len == endIdx-startIdx+1 == 1, return itself\\n        if(endIdx - startIdx + 1 == 1)\\n            return {s.substr(startIdx, 1)};\\n        vector <string> ret;\\n        // if subpart does not contain a leading zero, we can add the whole subpart to the result without placing a decimal point  \\n        if(s[startIdx] != \\'0\\')\\n            ret.push_back(s.substr(startIdx, endIdx - startIdx + 1));\\n        //edge case 1 mentioned above\\n        if(s[endIdx] == \\'0\\')\\n            return ret;\\n        for(int i = startIdx ; i < endIdx ; i++){\\n            //edge case 2 mentioned above\\n            if(s[startIdx] == \\'0\\' && i > startIdx)\\n                break;\\n            string tmp = s.substr(startIdx, i - startIdx + 1) + \\'.\\' + s.substr(i + 1, endIdx - i);\\n            ret.push_back(tmp);\\n        }\\n        return ret;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.size();\\n        //preprocess the input string\\n        s = s.substr(1, n-2);\\n        vector <string> ans;\\n        n = s.size();\\n        // trying to put commas at all the valid positions\\n        for(int i = 0 ; i < n-1 ; i++){\\n            // divide into left and right subparts\\n            vector <string> part1 = putDecimal(s, 0, i), part2 = putDecimal(s, i+1, n-1);\\n            //combine the results of the left and right subparts\\n            for(string s1:part1){\\n                for(string s2:part2)\\n                    ans.push_back(\\'(\\' + s1 + \", \" + s2 + \\')\\');\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207355,
                "title": "ambiguous-coordinates-help-with-calculating-complexity",
                "content": "Can anyone help me calculate the time and space complexity of this solution?\\nI am confused by the `substring()` methods and inner loops.\\nThis is my assumption:\\nwith `n` as length of string,\\n* Outer loop: `n`\\n  * subString for xVal and yVal will endup being `n` times total\\n  * we loop for length of xVal (say `x`) and length of yVal (say `y`), again total of `n` times\\n\\t  * But each iteration also does another substring totalling upto `x` and `y` length in their respective loops and also do `isValid()` check which loops through same length again. So I guess: `2x` + `2y` here which is basically `2n`\\n  * Then there is last nested loop of `x * y` times\\n\\nSo total: `n * (n + (n* 2n) + (x * y)`, \\nwhich can be simplified to: `n * (2n ^ 2 + n + xy)` => `2n^3 + n^2 + n.x.y` => O(n^3).\\n**Is this correct?**\\nI am not even sure where to start with space complexity :(\\n\\n```java\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        List<String> result = new ArrayList<>();\\n        \\n        // Find possible values for each comma position\\n        int n = s.length();\\n        for (int i = 2; i < n - 1; i++) {\\n            List<String> validXValues = new ArrayList();\\n            List<String> validYValues = new ArrayList();\\n            \\n            String xVal = s.substring(1, i);\\n            // no decimal, starting with any value other than 0 is valid\\n            if (xVal.charAt(0) != \\'0\\' || xVal.length() == 1) {\\n                validXValues.add(xVal);\\n            }\\n            \\n            String yVal = s.substring(i, n - 1);\\n            if (yVal.charAt(0) != \\'0\\' || yVal.length() == 1) {\\n                validYValues.add(yVal);\\n            }\\n                        \\n            // all possible valid values with decimals in each position for first value\\n            for (int j = 1; j < xVal.length(); j++) {\\n                String xDec = xVal.substring(0, j) + \".\" + xVal.substring(j, xVal.length());\\n                if (isValid(xDec)) {\\n                    validXValues.add(xDec);\\n                }\\n            }\\n            \\n            // and try with decimals in each position for second value\\n            for (int j = 1; j < yVal.length(); j++) {\\n                String yDec = yVal.substring(0, j) + \".\" + yVal.substring(j, yVal.length());\\n                if (isValid(yDec)) {\\n                    validYValues.add(yDec);\\n                }\\n            }\\n            \\n            // now add all combinations\\n            for (String x : validXValues) {\\n                for (String y : validYValues) {\\n                    result.add(\"(\" + x + \", \" + y + \")\");\\n                }\\n            }\\n            \\n        }\\n        return result;\\n    }\\n    \\n    public boolean isValid(String s) {\\n        if (s.length() < 1) {\\n            return false;\\n        } else if (s.length() == 1){\\n            return true;\\n        }\\n        if (s.charAt(0) == \\'0\\') {\\n            // starts with zero, so needs to have a dot right after it\\n            if (s.charAt(1) != \\'.\\') {\\n                return false;\\n            }\\n        }\\n        // if decimal, it cannot end with a 0\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (s.charAt(i) == \\'.\\') {                \\n                if (s.charAt(s.length() - 1) == \\'0\\') {\\n                    return false;\\n                }\\n                break;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        List<String> result = new ArrayList<>();\\n        \\n        // Find possible values for each comma position\\n        int n = s.length();\\n        for (int i = 2; i < n - 1; i++) {\\n            List<String> validXValues = new ArrayList();\\n            List<String> validYValues = new ArrayList();\\n            \\n            String xVal = s.substring(1, i);\\n            // no decimal, starting with any value other than 0 is valid\\n            if (xVal.charAt(0) != \\'0\\' || xVal.length() == 1) {\\n                validXValues.add(xVal);\\n            }\\n            \\n            String yVal = s.substring(i, n - 1);\\n            if (yVal.charAt(0) != \\'0\\' || yVal.length() == 1) {\\n                validYValues.add(yVal);\\n            }\\n                        \\n            // all possible valid values with decimals in each position for first value\\n            for (int j = 1; j < xVal.length(); j++) {\\n                String xDec = xVal.substring(0, j) + \".\" + xVal.substring(j, xVal.length());\\n                if (isValid(xDec)) {\\n                    validXValues.add(xDec);\\n                }\\n            }\\n            \\n            // and try with decimals in each position for second value\\n            for (int j = 1; j < yVal.length(); j++) {\\n                String yDec = yVal.substring(0, j) + \".\" + yVal.substring(j, yVal.length());\\n                if (isValid(yDec)) {\\n                    validYValues.add(yDec);\\n                }\\n            }\\n            \\n            // now add all combinations\\n            for (String x : validXValues) {\\n                for (String y : validYValues) {\\n                    result.add(\"(\" + x + \", \" + y + \")\");\\n                }\\n            }\\n            \\n        }\\n        return result;\\n    }\\n    \\n    public boolean isValid(String s) {\\n        if (s.length() < 1) {\\n            return false;\\n        } else if (s.length() == 1){\\n            return true;\\n        }\\n        if (s.charAt(0) == \\'0\\') {\\n            // starts with zero, so needs to have a dot right after it\\n            if (s.charAt(1) != \\'.\\') {\\n                return false;\\n            }\\n        }\\n        // if decimal, it cannot end with a 0\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (s.charAt(i) == \\'.\\') {                \\n                if (s.charAt(s.length() - 1) == \\'0\\') {\\n                    return false;\\n                }\\n                break;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207325,
                "title": "go-beats-100-runtime-and-memory",
                "content": "```go\\nfunc ambiguousCoordinates(s string) []string {\\n    result := []string{}\\n    var helper func(first string, second string)\\n    \\n    helper = func (first string, second string) {\\n        for i := 0; i < len(first); i++ {\\n            newF := first\\n            if i > 0 {\\n                newF = first[0:i] + \".\" + first[i:]\\n            }\\n            if (!isValid(newF)) {\\n                continue\\n            }\\n            for j := 0; j < len(second); j++  {\\n                newS := second\\n                if j > 0 {\\n                    newS = second[0:j] + \".\" + second[j:]\\n                }\\n                \\n                if !isValid(newS) {\\n                    continue\\n                }\\n                \\n                result = append(result, \"(\" + newF + \", \" + newS + \")\")\\n            }\\n        }\\n    }\\n    \\n    for i := 2; i < len(s) -1; i++ {\\n        helper(s[1:i], s[i:len(s) -1])\\n    }\\n    \\n    return result\\n}\\n\\n//  validate if a string is a valid cordinate.\\nfunc isValid(s string) bool {\\n    if len(s) < 2 {\\n        return true\\n    }\\n    \\n    decimalCount := 0;\\n    numberCount := 0;\\n    for i := 0; i < len(s); i++ {\\n        if s[i] >= \\'1\\' && s[i] <= \\'9\\' {\\n            numberCount++\\n        }\\n        \\n        if s[i] == \\'.\\'{\\n            numberCount = 0\\n            decimalCount++\\n        }\\n        \\n\\t\\t// fail early if he first character is 0 and the secod character is not \\'.\\'\\n        if i == 1 && decimalCount == 0 && s[0] == \\'0\\' {\\n            return false;\\n        }\\n    }\\n    \\n    return (numberCount > 0 && decimalCount == 0) || (decimalCount > 0 && s[len(s) -1] != \\'0\\');\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc ambiguousCoordinates(s string) []string {\\n    result := []string{}\\n    var helper func(first string, second string)\\n    \\n    helper = func (first string, second string) {\\n        for i := 0; i < len(first); i++ {\\n            newF := first\\n            if i > 0 {\\n                newF = first[0:i] + \".\" + first[i:]\\n            }\\n            if (!isValid(newF)) {\\n                continue\\n            }\\n            for j := 0; j < len(second); j++  {\\n                newS := second\\n                if j > 0 {\\n                    newS = second[0:j] + \".\" + second[j:]\\n                }\\n                \\n                if !isValid(newS) {\\n                    continue\\n                }\\n                \\n                result = append(result, \"(\" + newF + \", \" + newS + \")\")\\n            }\\n        }\\n    }\\n    \\n    for i := 2; i < len(s) -1; i++ {\\n        helper(s[1:i], s[i:len(s) -1])\\n    }\\n    \\n    return result\\n}\\n\\n//  validate if a string is a valid cordinate.\\nfunc isValid(s string) bool {\\n    if len(s) < 2 {\\n        return true\\n    }\\n    \\n    decimalCount := 0;\\n    numberCount := 0;\\n    for i := 0; i < len(s); i++ {\\n        if s[i] >= \\'1\\' && s[i] <= \\'9\\' {\\n            numberCount++\\n        }\\n        \\n        if s[i] == \\'.\\'{\\n            numberCount = 0\\n            decimalCount++\\n        }\\n        \\n\\t\\t// fail early if he first character is 0 and the secod character is not \\'.\\'\\n        if i == 1 && decimalCount == 0 && s[0] == \\'0\\' {\\n            return false;\\n        }\\n    }\\n    \\n    return (numberCount > 0 && decimalCount == 0) || (decimalCount > 0 && s[len(s) -1] != \\'0\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1207314,
                "title": "concise-java-solution-with-explanation-beats-100-in-runtime",
                "content": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> coordinates=new ArrayList<String>();\\n        //take out the \\'(\\' and \\')\\'\\n        String digits=s.substring(1,s.length()-1);\\n        \\n        //breaking the string up in two parts in all possible ways\\n        for(int i=1;i<digits.length();++i) {\\n            \\n            //check if the first part can form any valid numbers\\n            List<String> vn1=validNumbers(digits.substring(0, i));\\n            //skip the rest is 1st part is not valid\\n            if(vn1.size()==0) {\\n                continue;\\n            }\\n            //check if 2nd part can form any valid numners\\n            List<String> vn2=validNumbers(digits.substring(i));\\n            \\n            //form all combinations of valid numbers from 1st and 2nd part\\n            for(String d1:vn1) {\\n                for(String d2:vn2) {\\n                    coordinates.add(\"(\"+d1+\", \"+d2+\")\");\\n                }\\n            }\\n        }\\n        return coordinates;    \\n    }\\n    \\n    //method to check is a string can form any valid numbers\\n    public List<String> validNumbers(String str)\\n    {  \\n        List<String> validNumbers=new ArrayList<String>();\\n        //note: we won\\'t pass in any empty strings\\n        if(str.length()==1) { //any string with only 1 digit is a valid number, like 0, 1, or 8\\n            validNumbers.add(str);\\n        }\\n        else if(str.charAt(0)==\\'0\\') { //str has more then 1 digit when we reach this case \\n            //if the 1st digit is 0, it has to be a dismal number, so it\\'s only valid if it does not end with 0\\n            //for example, 0.0 or 0.10 are not valid\\n            if(str.charAt(str.length()-1)!=\\'0\\') {\\n                validNumbers.add(\"0.\"+str.substring(1));\\n            }\\n        }\\n        else {           \\n            //we have at least one valid number at this point like 123, or 100\\n            validNumbers.add(str);\\n            //we can insert a decimal point between digits to get a new valid number \\n            //as long as the number doe snot end with a 0.\\n            //for example, 123 can be 1.23, 12.3 but 1230 can not be a decimal number\\n            if(str.charAt(str.length()-1)!=\\'0\\') {\\n                for(int i=1;i<str.length();++i)  {\\n                    validNumbers.add(str.substring(0, i)+\".\"+str.substring(i));\\n                }\\n            }\\n        }\\n        return validNumbers;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> coordinates=new ArrayList<String>();\\n        //take out the \\'(\\' and \\')\\'\\n        String digits=s.substring(1,s.length()-1);\\n        \\n        //breaking the string up in two parts in all possible ways\\n        for(int i=1;i<digits.length();++i) {\\n            \\n            //check if the first part can form any valid numbers\\n            List<String> vn1=validNumbers(digits.substring(0, i));\\n            //skip the rest is 1st part is not valid\\n            if(vn1.size()==0) {\\n                continue;\\n            }\\n            //check if 2nd part can form any valid numners\\n            List<String> vn2=validNumbers(digits.substring(i));\\n            \\n            //form all combinations of valid numbers from 1st and 2nd part\\n            for(String d1:vn1) {\\n                for(String d2:vn2) {\\n                    coordinates.add(\"(\"+d1+\", \"+d2+\")\");\\n                }\\n            }\\n        }\\n        return coordinates;    \\n    }\\n    \\n    //method to check is a string can form any valid numbers\\n    public List<String> validNumbers(String str)\\n    {  \\n        List<String> validNumbers=new ArrayList<String>();\\n        //note: we won\\'t pass in any empty strings\\n        if(str.length()==1) { //any string with only 1 digit is a valid number, like 0, 1, or 8\\n            validNumbers.add(str);\\n        }\\n        else if(str.charAt(0)==\\'0\\') { //str has more then 1 digit when we reach this case \\n            //if the 1st digit is 0, it has to be a dismal number, so it\\'s only valid if it does not end with 0\\n            //for example, 0.0 or 0.10 are not valid\\n            if(str.charAt(str.length()-1)!=\\'0\\') {\\n                validNumbers.add(\"0.\"+str.substring(1));\\n            }\\n        }\\n        else {           \\n            //we have at least one valid number at this point like 123, or 100\\n            validNumbers.add(str);\\n            //we can insert a decimal point between digits to get a new valid number \\n            //as long as the number doe snot end with a 0.\\n            //for example, 123 can be 1.23, 12.3 but 1230 can not be a decimal number\\n            if(str.charAt(str.length()-1)!=\\'0\\') {\\n                for(int i=1;i<str.length();++i)  {\\n                    validNumbers.add(str.substring(0, i)+\".\"+str.substring(i));\\n                }\\n            }\\n        }\\n        return validNumbers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207291,
                "title": "c-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public IList<string> AmbiguousCoordinates(string s) {\\n        \\n        s = s.TrimStart(\\'(\\').TrimEnd(\\')\\');\\n        \\n        IList<string> res = new List<string>();\\n        \\n        for(int i = 0; i<s.Length - 1; i++) {\\n            string str = s.Substring(0, i+1) + \",\" + s.Substring(i+1);\\n            \\n            if(ContainsAllZeros(str, out string[] arr)) continue;\\n            \\n            var lft = BuildDecimalNumber(arr[0]);\\n            var rght = BuildDecimalNumber(arr[1]);\\n            \\n            for(int j = 0; j < lft.Count(); j++) {\\n                for(int k = 0; k < rght.Count(); k++) {\\n                    res.Add(\"(\" + lft[j] + \", \" + rght[k] + \")\");\\n                }\\n            }\\n            \\n        }\\n        return res.Distinct().ToList();\\n    }\\n    \\n    public bool ContainsAllZeros(string str, out string[] arr) {\\n        arr = str.Split(\",\");\\n        bool  a = false, b = false;\\n        \\n        if(arr[0].Length > 1)\\n            a = arr[0].All(x => x == \\'0\\');\\n        if(arr[1].Length > 1)\\n            b = arr[1].All(x => x == \\'0\\');\\n            \\n        return a || b ; \\n    }\\n    \\n    public List<string> BuildDecimalNumber(string s) {\\n        \\n        List<string> lst = new List<string>();\\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        if(s[0] != \\'0\\') lst.Add(s);\\n        \\n        if(s.Length == 1) {\\n            lst.Add(s);\\n            return lst;\\n        }\\n        \\n        for(int i = 1; i<s.Length; i++) {\\n            sb.Insert(i, \\'.\\');\\n            if(!IsLeadingZeros(sb.ToString())) lst.Add(sb.ToString());\\n            sb.Remove(i, 1);\\n        }\\n        \\n        return lst;\\n    }\\n    \\n    public bool IsLeadingZeros(string s) {\\n        var arr = s.Split(\\'.\\');\\n        if((arr[0].Length > 1 && s[0] == \\'0\\') ||  arr[1].All(x => x == \\'0\\') \\n           || arr[1].Last() == \\'0\\') \\n            return true;\\n        return false;\\n    }\\n}\\n```****",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> AmbiguousCoordinates(string s) {\\n        \\n        s = s.TrimStart(\\'(\\').TrimEnd(\\')\\');\\n        \\n        IList<string> res = new List<string>();\\n        \\n        for(int i = 0; i<s.Length - 1; i++) {\\n            string str = s.Substring(0, i+1) + \",\" + s.Substring(i+1);\\n            \\n            if(ContainsAllZeros(str, out string[] arr)) continue;\\n            \\n            var lft = BuildDecimalNumber(arr[0]);\\n            var rght = BuildDecimalNumber(arr[1]);\\n            \\n            for(int j = 0; j < lft.Count(); j++) {\\n                for(int k = 0; k < rght.Count(); k++) {\\n                    res.Add(\"(\" + lft[j] + \", \" + rght[k] + \")\");\\n                }\\n            }\\n            \\n        }\\n        return res.Distinct().ToList();\\n    }\\n    \\n    public bool ContainsAllZeros(string str, out string[] arr) {\\n        arr = str.Split(\",\");\\n        bool  a = false, b = false;\\n        \\n        if(arr[0].Length > 1)\\n            a = arr[0].All(x => x == \\'0\\');\\n        if(arr[1].Length > 1)\\n            b = arr[1].All(x => x == \\'0\\');\\n            \\n        return a || b ; \\n    }\\n    \\n    public List<string> BuildDecimalNumber(string s) {\\n        \\n        List<string> lst = new List<string>();\\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        if(s[0] != \\'0\\') lst.Add(s);\\n        \\n        if(s.Length == 1) {\\n            lst.Add(s);\\n            return lst;\\n        }\\n        \\n        for(int i = 1; i<s.Length; i++) {\\n            sb.Insert(i, \\'.\\');\\n            if(!IsLeadingZeros(sb.ToString())) lst.Add(sb.ToString());\\n            sb.Remove(i, 1);\\n        }\\n        \\n        return lst;\\n    }\\n    \\n    public bool IsLeadingZeros(string s) {\\n        var arr = s.Split(\\'.\\');\\n        if((arr[0].Length > 1 && s[0] == \\'0\\') ||  arr[1].All(x => x == \\'0\\') \\n           || arr[1].Last() == \\'0\\') \\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207284,
                "title": "python-addressing-edge-cases",
                "content": "class Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\n        def gen(a):\\n            \\n            if len(a) == 1:\\n                return [a]\\n            \\n            if a[0] == \\'0\\' and a[-1] == \\'0\\':\\n                return []\\n            \\n            if a[0] == \\'0\\' and a[-1] != \\'0\\':\\n                return [\\'0.\\' + a[1:]]\\n            \\n            if a[0] != \\'0\\' and a[-1] == \\'0\\':\\n                return [a]\\n            \\n            # if a[0] != \\'0\\' and a[-1] !=\\'0\\' append itself and dot separated ones\\n            comb = [a]\\n            for i in range(1,len(a)):\\n                comb.append(a[:i] + \\'.\\' + a[i:])\\n            \\n            return comb \\n            \\n        \\n        res = []\\n        for i in range(2, len(s)-1):\\n            left, right = gen(s[1:i]), gen(s[i:-1])\\n            for l in left:\\n                for r in right:\\n                    res.append(\\'(\\'+ l + \\', \\' + r + \\')\\')\\n        return res \\n    \\n    \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\n        def gen(a):\\n            \\n            if len(a) == 1:\\n                return [a]\\n            \\n            if a[0] == \\'0\\' and a[-1] == \\'0\\':\\n                return []\\n            \\n            if a[0] == \\'0\\' and a[-1] != \\'0\\':\\n                return [\\'0.\\' + a[1:]]\\n            \\n            if a[0] != \\'0\\' and a[-1] == \\'0\\':\\n                return [a]\\n            \\n            # if a[0] != \\'0\\' and a[-1] !=\\'0\\' append itself and dot separated ones\\n            comb = [a]\\n            for i in range(1,len(a)):\\n                comb.append(a[:i] + \\'.\\' + a[i:])\\n            \\n            return comb \\n            \\n        \\n        res = []\\n        for i in range(2, len(s)-1):\\n            left, right = gen(s[1:i]), gen(s[i:-1])\\n            for l in left:\\n                for r in right:\\n                    res.append(\\'(\\'+ l + \\', \\' + r + \\')\\')\\n        return res \\n    \\n    \\n",
                "codeTag": "Java"
            },
            {
                "id": 1207280,
                "title": "java-backtracking",
                "content": "A bit convoluted, but it works.\\n\\n```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> result = new ArrayList<>();\\n        ambiguousCoordinates(\\n            s.substring(1, s.length() - 1), 0, \"\", result, -1, -1);   \\n        return result;\\n    }\\n    \\n    private void ambiguousCoordinates(\\n            String s, int index, String candidate, List<String> result,\\n            int periodAdded, int commaAdded) {\\n        if (index >= s.length()) {\\n            char last = candidate.charAt(candidate.length() - 1);\\n            if (commaAdded >= 0\\n                    && Character.isDigit(last)\\n                    && (periodAdded < 0 || last != \\'0\\')) {\\n                result.add(\\'(\\' + candidate + \\')\\');\\n            }\\n            return;\\n        }\\n        \\n        char c = s.charAt(index); \\n        candidate += c;\\n        if (periodAdded < 0) {\\n            ambiguousCoordinates(\\n                s, index + 1, candidate + \\'.\\', result, candidate.length(), commaAdded);\\n        }\\n        if (commaAdded < 0 && (periodAdded < 0 || c != \\'0\\')) {\\n            // note that this resets index for periodAdded back to -1\\n            // so that period can be added again after comma\\n            ambiguousCoordinates(\\n                s, index + 1, candidate + \", \", result, -1, candidate.length());\\n        }\\n        if (c != \\'0\\' || index == s.length() - 1 \\n            || (index > 0 && \\n                (commaAdded < 0 || candidate.charAt(candidate.length() - 3) != \\',\\')))\\n        {\\n            ambiguousCoordinates(s, index + 1, candidate, result, periodAdded, commaAdded);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> result = new ArrayList<>();\\n        ambiguousCoordinates(\\n            s.substring(1, s.length() - 1), 0, \"\", result, -1, -1);   \\n        return result;\\n    }\\n    \\n    private void ambiguousCoordinates(\\n            String s, int index, String candidate, List<String> result,\\n            int periodAdded, int commaAdded) {\\n        if (index >= s.length()) {\\n            char last = candidate.charAt(candidate.length() - 1);\\n            if (commaAdded >= 0\\n                    && Character.isDigit(last)\\n                    && (periodAdded < 0 || last != \\'0\\')) {\\n                result.add(\\'(\\' + candidate + \\')\\');\\n            }\\n            return;\\n        }\\n        \\n        char c = s.charAt(index); \\n        candidate += c;\\n        if (periodAdded < 0) {\\n            ambiguousCoordinates(\\n                s, index + 1, candidate + \\'.\\', result, candidate.length(), commaAdded);\\n        }\\n        if (commaAdded < 0 && (periodAdded < 0 || c != \\'0\\')) {\\n            // note that this resets index for periodAdded back to -1\\n            // so that period can be added again after comma\\n            ambiguousCoordinates(\\n                s, index + 1, candidate + \", \", result, -1, candidate.length());\\n        }\\n        if (c != \\'0\\' || index == s.length() - 1 \\n            || (index > 0 && \\n                (commaAdded < 0 || candidate.charAt(candidate.length() - 3) != \\',\\')))\\n        {\\n            ambiguousCoordinates(s, index + 1, candidate, result, periodAdded, commaAdded);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207261,
                "title": "ambigous-coordinates-java-modular-approach",
                "content": "class Solution {\\n    \\n    List<String> ans = new ArrayList<>();\\n    \\n    public List<String> ambiguousCoordinates(String s) { // main function\\n        \\n        s = s.substring(1,s.length()-1);\\n        \\n        for(int i=1;i<s.length();i++)\\n            solve(s.substring(0,i),s.substring(i));\\n                \\n        return ans;\\n    }\\n    \\n    public void solve(String left,String right) { // this functions tries to form all pairs of x,y coordinates\\n        \\n        List<String> left_dots = convert(left);\\n        List<String> right_dots = convert(right);\\n        \\n        for(String left_part_dot : left_dots) {\\n            if(isValid(left_part_dot)) {\\n                \\n                for(String right_part_dot : right_dots ) {\\n                    \\n                    if(isValid(right_part_dot)) {\\n                        \\n                        ans.add(\"(\" + left_part_dot + \", \" + right_part_dot + \")\");\\n                        \\n                    }\\n                }   \\n            }\\n        } \\n    }\\n    \\n    public List<String> convert(String s) { // this method just keeps dots at n-1 places\\n        \\n        List<String> tmp = new ArrayList<>();\\n        tmp.add(s);\\n        \\n        for(int i=1;i<s.length();i++) {\\n            tmp.add(s.substring(0,i) + \".\" + s.substring(i));\\n        }\\n\\n        return tmp;\\n    }\\n    \\n    public boolean isValid(String s) { // this method checks if the formed dot is valid or not.\\n        \\n        if(s.contains(\".\")) {\\n            \\n            String []part = s.split(\"\\\\\\\\.\");\\n            \\n            if(!part[0].equals(\"0\") && part[0].startsWith(\"0\")) return false;\\n            \\n            else return !part[1].endsWith(\"0\"); \\n            \\n        }\\n        else {\\n            \\n            if(s.equals(\"0\")) return true;\\n            \\n            else return !s.startsWith(\"0\");\\n            \\n        }   \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    List<String> ans = new ArrayList<>();\\n    \\n    public List<String> ambiguousCoordinates(String s) { // main function\\n        \\n        s = s.substring(1,s.length()-1);\\n        \\n        for(int i=1;i<s.length();i++)\\n            solve(s.substring(0,i),s.substring(i));\\n                \\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1207188,
                "title": "python-itertools-product-clean-code",
                "content": "```\\nfrom itertools import product\\n\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\n        def get_result_by_split(left: str, right: str) -> List[str]:\\n            sub = []\\n            left_perm = get_decimal_perm(left)\\n            right_perm = get_decimal_perm(right)\\n            if left_perm and right_perm:\\n                perm = product(left_perm, right_perm)\\n                sub.extend([f\\'({t[0]}, {t[1]})\\' for t in perm])\\n            return sub\\n        \\n        def get_decimal_perm(num: str) -> List[str]:\\n            if len(num) == 1:\\n                return [num]\\n            if num[0] == \\'0\\' and num[-1] == \\'0\\':\\n                return []\\n            if num[0] == \\'0\\':\\n                return [f\\'{num[0]}.{num[1:]}\\']\\n            if num[-1] == \\'0\\':\\n                return [num]\\n            return [f\\'{num[:n]}.{num[n:]}\\' for n in range(1, len(num))] + [num]\\n        \\n        res = []\\n        for i in range(2, len(s)-1):\\n            left, right = s[1:i], s[i:len(s)-1]\\n            res.extend(get_result_by_split(left, right))\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import product\\n\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\n        def get_result_by_split(left: str, right: str) -> List[str]:\\n            sub = []\\n            left_perm = get_decimal_perm(left)\\n            right_perm = get_decimal_perm(right)\\n            if left_perm and right_perm:\\n                perm = product(left_perm, right_perm)\\n                sub.extend([f\\'({t[0]}, {t[1]})\\' for t in perm])\\n            return sub\\n        \\n        def get_decimal_perm(num: str) -> List[str]:\\n            if len(num) == 1:\\n                return [num]\\n            if num[0] == \\'0\\' and num[-1] == \\'0\\':\\n                return []\\n            if num[0] == \\'0\\':\\n                return [f\\'{num[0]}.{num[1:]}\\']\\n            if num[-1] == \\'0\\':\\n                return [num]\\n            return [f\\'{num[:n]}.{num[n:]}\\' for n in range(1, len(num))] + [num]\\n        \\n        res = []\\n        for i in range(2, len(s)-1):\\n            left, right = s[1:i], s[i:len(s)-1]\\n            res.extend(get_result_by_split(left, right))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207183,
                "title": "python-elongated-every-case-checking-and-generating-string-on-basis-of-every-case",
                "content": "Okay it took me 4 H to work on this lol.\\nbut hope you can see everycase in this.\\n\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        #three choices add a ./_/nothing\\n        # we cannot add after a gap after last element is zero after a decimal\\n        #check decimal occured\\n        #if we are adding a gap we can make the decimal occured false\\n        #cannot add another 0 if decimal is not occured and last element is 0\\n        #cannot add more than one gap\\n        #check gap added\\n        \\n        #decimal occured\\n        #gap occured\\n        #if decimal occured we cannot add another decimal\\n        q=deque()\\n            \\n        q.append((s[1],False,False,0))\\n        a=set()\\n        s = s[1:-1]\\n        while q:\\n            st,gapocc,decimalocc,li = q.popleft()\\n            st2=st\\n            st = st.split(\\' \\')[-1]\\n            if li==len(s)-1:\\n                ss = st2.split(\\' \\')\\n                if len(ss)==2:\\n                    a.add(\\'(\\'+ss[0]+\\', \\'+ss[1]+\\')\\')\\n                continue\\n            ch = s[li+1]\\n            lch = st[-1]\\n            \\n            \\n            if li==len(s)-2:\\n                if decimalocc==False and gapocc:\\n                    if ch!=\\'0\\':\\n                        q.append((st2+\\'.\\'+ch,gapocc,True,li+1))\\n                        \\n                    if float(st)!=0:\\n                        q.append((st2+ch,gapocc,decimalocc,li+1))\\n                    continue\\n                if decimalocc and gapocc:\\n                    if ch==\\'0\\':\\n                        continue\\n                    else:\\n                        q.append((st2+ch,gapocc,decimalocc,li+1))\\n                    continue\\n                if gapocc==False and decimalocc:\\n                    #if gap not made len of st>1\\n                    if lch!=\\'0\\':                            \\n                        q.append((st2+\\' \\'+ch,True,decimalocc,li+1))\\n                        continue\\n                if not decimalocc and not gapocc:\\n                    q.append((st2+\\' \\'+ch,True,decimalocc,li+1))\\n                    continue\\n                    \\n            if decimalocc==False and gapocc:\\n                q.append((st2+\\'.\\'+ch,gapocc,True,li+1))\\n                if float(st)!=0:\\n                    q.append((st2+ch,gapocc,decimalocc,li+1))\\n            if decimalocc and gapocc==False:\\n                if lch!=\\'0\\':\\n                    q.append((st2+\\' \\'+ch,True,False,li+1))\\n                q.append((st2+ch,gapocc,decimalocc,li+1))\\n            if decimalocc and gapocc:\\n                q.append((st2+ch,gapocc,decimalocc,li+1))\\n            if not decimalocc and not gapocc:\\n                if float(st)!=0:\\n                    q.append((st2+ch,gapocc,decimalocc,li+1))\\n                q.append((st2+\\' \\'+ch,True,False,li+1))\\n                q.append((st2+\\'.\\'+ch,gapocc,True,li+1))\\n                \\n        return a\\n        pass\\n                \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Okay it took me 4 H to work on this lol.\\nbut hope you can see everycase in this.\\n\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        #three choices add a ./_/nothing\\n        # we cannot add after a gap after last element is zero after a decimal\\n        #check decimal occured\\n        #if we are adding a gap we can make the decimal occured false\\n        #cannot add another 0 if decimal is not occured and last element is 0\\n        #cannot add more than one gap\\n        #check gap added\\n        \\n        #decimal occured\\n        #gap occured\\n        #if decimal occured we cannot add another decimal\\n        q=deque()\\n            \\n        q.append((s[1],False,False,0))\\n        a=set()\\n        s = s[1:-1]\\n        while q:\\n            st,gapocc,decimalocc,li = q.popleft()\\n            st2=st\\n            st = st.split(\\' \\')[-1]\\n            if li==len(s)-1:\\n                ss = st2.split(\\' \\')\\n                if len(ss)==2:\\n                    a.add(\\'(\\'+ss[0]+\\', \\'+ss[1]+\\')\\')\\n                continue\\n            ch = s[li+1]\\n            lch = st[-1]\\n            \\n            \\n            if li==len(s)-2:\\n                if decimalocc==False and gapocc:\\n                    if ch!=\\'0\\':\\n                        q.append((st2+\\'.\\'+ch,gapocc,True,li+1))\\n                        \\n                    if float(st)!=0:\\n                        q.append((st2+ch,gapocc,decimalocc,li+1))\\n                    continue\\n                if decimalocc and gapocc:\\n                    if ch==\\'0\\':\\n                        continue\\n                    else:\\n                        q.append((st2+ch,gapocc,decimalocc,li+1))\\n                    continue\\n                if gapocc==False and decimalocc:\\n                    #if gap not made len of st>1\\n                    if lch!=\\'0\\':                            \\n                        q.append((st2+\\' \\'+ch,True,decimalocc,li+1))\\n                        continue\\n                if not decimalocc and not gapocc:\\n                    q.append((st2+\\' \\'+ch,True,decimalocc,li+1))\\n                    continue\\n                    \\n            if decimalocc==False and gapocc:\\n                q.append((st2+\\'.\\'+ch,gapocc,True,li+1))\\n                if float(st)!=0:\\n                    q.append((st2+ch,gapocc,decimalocc,li+1))\\n            if decimalocc and gapocc==False:\\n                if lch!=\\'0\\':\\n                    q.append((st2+\\' \\'+ch,True,False,li+1))\\n                q.append((st2+ch,gapocc,decimalocc,li+1))\\n            if decimalocc and gapocc:\\n                q.append((st2+ch,gapocc,decimalocc,li+1))\\n            if not decimalocc and not gapocc:\\n                if float(st)!=0:\\n                    q.append((st2+ch,gapocc,decimalocc,li+1))\\n                q.append((st2+\\' \\'+ch,True,False,li+1))\\n                q.append((st2+\\'.\\'+ch,gapocc,True,li+1))\\n                \\n        return a\\n        pass\\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 1207108,
                "title": "easy-to-understand-java-solution-slow",
                "content": "```\\n/**\\nPseudo code:\\nGiven string: abcdef\\nabcd | ef\\n\\nfor i is position which divides the string into two substrings\\n    first string\\n    second string\\n    for every possible first string with . (or without) f1\\n        for every possible second string with . (or without) s1\\n            add (f1, s1)\\n\\n\\n*/\\n```\\n\\n\\n```\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    \\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        String sub = s.substring(1, s.length() - 1);\\n        for(int i= 0; i<sub.length(); i++) {\\n            String first = sub.substring(0, i);\\n            String second = sub.substring(i);\\n            \\n            for(String f1: valids(first)) {\\n                for(String s1:   valids(second)) {\\n                    ans.add(String.format(\"(%s, %s)\", f1, s1));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    // return list of strings without or without .\\n    List<String> valids(String str) {\\n        if(str.isEmpty()) return Arrays.asList();\\n        \\n        if(str.length() == 1) {\\n            return Arrays.asList(str);\\n        }\\n        \\n        List<String> lst = new ArrayList<>();\\n        if(str.charAt(0) == \\'0\\'){\\n            if(Integer.valueOf(str) == 0) return Arrays.asList();\\n            if(str.charAt(str.length()-1) == \\'0\\') return Arrays.asList();\\n            lst.add(String.format(\"%s.%s\", 0, str.substring(1)));\\n        } else {\\n            for(int i=0; i<str.length(); i++){\\n                String fst = str.substring(0, i);\\n                String second = str.substring(i);\\n                \\n                if(fst.isEmpty() || second.isEmpty()) continue;\\n                // x.0 is not permitted\\n                if(Integer.valueOf(second) == 0) {\\n                    continue;\\n                }\\n                // x.y0 is not permitted\\n                if(second.length() > 1 && second.charAt(second.length() -1 ) == \\'0\\') continue;\\n                lst.add(String.format(\"%s.%s\", fst, second));\\n            }\\n            lst.add(str);\\n        }\\n        return lst;\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\nPseudo code:\\nGiven string: abcdef\\nabcd | ef\\n\\nfor i is position which divides the string into two substrings\\n    first string\\n    second string\\n    for every possible first string with . (or without) f1\\n        for every possible second string with . (or without) s1\\n            add (f1, s1)\\n\\n\\n*/\\n```\n```\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    \\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        String sub = s.substring(1, s.length() - 1);\\n        for(int i= 0; i<sub.length(); i++) {\\n            String first = sub.substring(0, i);\\n            String second = sub.substring(i);\\n            \\n            for(String f1: valids(first)) {\\n                for(String s1:   valids(second)) {\\n                    ans.add(String.format(\"(%s, %s)\", f1, s1));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    // return list of strings without or without .\\n    List<String> valids(String str) {\\n        if(str.isEmpty()) return Arrays.asList();\\n        \\n        if(str.length() == 1) {\\n            return Arrays.asList(str);\\n        }\\n        \\n        List<String> lst = new ArrayList<>();\\n        if(str.charAt(0) == \\'0\\'){\\n            if(Integer.valueOf(str) == 0) return Arrays.asList();\\n            if(str.charAt(str.length()-1) == \\'0\\') return Arrays.asList();\\n            lst.add(String.format(\"%s.%s\", 0, str.substring(1)));\\n        } else {\\n            for(int i=0; i<str.length(); i++){\\n                String fst = str.substring(0, i);\\n                String second = str.substring(i);\\n                \\n                if(fst.isEmpty() || second.isEmpty()) continue;\\n                // x.0 is not permitted\\n                if(Integer.valueOf(second) == 0) {\\n                    continue;\\n                }\\n                // x.y0 is not permitted\\n                if(second.length() > 1 && second.charAt(second.length() -1 ) == \\'0\\') continue;\\n                lst.add(String.format(\"%s.%s\", fst, second));\\n            }\\n            lst.add(str);\\n        }\\n        return lst;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207014,
                "title": "php-3-step-approach",
                "content": "12 ms 15.7 MB\\n\\nNot a particularly sophisticated problem, just tedious.\\n\\nWe start with a bunch of digits, and start with the fact that we need to split them into 2 groups of 1 or more digits each.\\n\\n#### Phase 1 - Find the next valid pair of groups of digits\\n- Split the digits into 2 groups, starting with 1 digit on the left and everything else on the right, then shifting digits left until only 1 digit is on the right.\\n- For each group, the following patterns are valid:\\n\\t- 1 digit is valid\\n\\t- Any grouping with 1-9 on either the left or right or both is valid.\\n- If both groups are valid, move onto phase 2.\\n#### Phase 2 - Get all the valid decimal locations for each group.\\n- A group of 1 digit has a single non-decimal pattern.\\n- A group ending in 0 also has a single non-decimal pattern (otherwise you have trailing 0 fractions).\\n- A group starting in 0 has a single pattern starting with `0.`.\\n- Everything else has a non-decimal pattern plus everything from `x.xx ... x` to `x ... xx.x`\\n#### Phase 3 - Combine\\n- Concatenate each pattern from the first group with each pattern from the second group as `(p1, p2)` and add it. to the result.\\n\\n```\\nclass Solution \\n{\\n\\n    private function validateGroup(array &$s, int $start, int $end): bool\\n    {\\n        /* Allow multiple consecutive 0\\'s only if the first or last digit is not a 0. */\\n        if($start == $end)\\n            return true;\\n        return($s[$start] != \\'0\\'  ||  $s[$end] != \\'0\\');\\n    }\\n\\n    private function getDecimalStrings(array &$arr, int $start, int $end): array\\n    {\\n        /*\\n            - Single digit: no decimal\\n            - Trailing 0: no decimal.\\n            - Leading 0: decimal after first digit only.\\n            - Otherwise, no decimal, followed by decimals until before last digit. \\n        */\\n        $digitStr = substr(implode(\\'\\',$arr), $start, 1+$end-$start);\\n        $group = [$digitStr];\\n        if($start == $end)\\n            return $group;\\n        if($digitStr[$end-$start] == \\'0\\')\\n            return $group;\\n        if($digitStr[0] == \\'0\\')\\n            return [\\'0.\\'.substr($digitStr, 1)];\\n\\n        $decStr = \\'.\\'.$digitStr;\\n        for($dec=1; $dec<=$end-$start; $dec++)\\n        {\\n            $tmp = $decStr[$dec-1];\\n            $decStr[$dec-1] = $decStr[$dec];\\n            $decStr[$dec] = $tmp;\\n            $group[] = $decStr;\\n        }\\n        \\n        return $group;\\n    }\\n    \\n    /**\\n     * @param String $s\\n     * @return String[]\\n     */\\n    function ambiguousCoordinates($s) \\n    {\\n        $digits = [];\\n        $last = strlen($s)-2;\\n        for($i=1; $i<=$last; $i++)\\n            $digits[] = $s[$i];\\n        \\n        /* Try each valid group. */\\n        $groups = [];\\n        for($i=1; $i<$last; $i++)\\n        {\\n            /* 0\\'s are allowed on both ends only for 0 itself. */\\n            if(!$this->validateGroup($digits,0,$i-1))\\n                continue;\\n            if(!$this->validateGroup($digits,$i,$last-1))\\n                continue;\\n            \\n            /* Get each valid decimal position within each group. */\\n            $g1 = $this->getDecimalStrings($digits, 0, $i-1);\\n            $g2 = $this->getDecimalStrings($digits, $i, $last-1);\\n            for($j=0; $j<count($g1); $j++)\\n            {\\n                for($k=0; $k<count($g2); $k++)\\n                {\\n                    $groups[] = \"(\".$g1[$j].\", \".$g2[$k].\")\";\\n                }\\n            }\\n            \\n        }\\n\\n        return $groups;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n\\n    private function validateGroup(array &$s, int $start, int $end): bool\\n    {\\n        /* Allow multiple consecutive 0\\'s only if the first or last digit is not a 0. */\\n        if($start == $end)\\n            return true;\\n        return($s[$start] != \\'0\\'  ||  $s[$end] != \\'0\\');\\n    }\\n\\n    private function getDecimalStrings(array &$arr, int $start, int $end): array\\n    {\\n        /*\\n            - Single digit: no decimal\\n            - Trailing 0: no decimal.\\n            - Leading 0: decimal after first digit only.\\n            - Otherwise, no decimal, followed by decimals until before last digit. \\n        */\\n        $digitStr = substr(implode(\\'\\',$arr), $start, 1+$end-$start);\\n        $group = [$digitStr];\\n        if($start == $end)\\n            return $group;\\n        if($digitStr[$end-$start] == \\'0\\')\\n            return $group;\\n        if($digitStr[0] == \\'0\\')\\n            return [\\'0.\\'.substr($digitStr, 1)];\\n\\n        $decStr = \\'.\\'.$digitStr;\\n        for($dec=1; $dec<=$end-$start; $dec++)\\n        {\\n            $tmp = $decStr[$dec-1];\\n            $decStr[$dec-1] = $decStr[$dec];\\n            $decStr[$dec] = $tmp;\\n            $group[] = $decStr;\\n        }\\n        \\n        return $group;\\n    }\\n    \\n    /**\\n     * @param String $s\\n     * @return String[]\\n     */\\n    function ambiguousCoordinates($s) \\n    {\\n        $digits = [];\\n        $last = strlen($s)-2;\\n        for($i=1; $i<=$last; $i++)\\n            $digits[] = $s[$i];\\n        \\n        /* Try each valid group. */\\n        $groups = [];\\n        for($i=1; $i<$last; $i++)\\n        {\\n            /* 0\\'s are allowed on both ends only for 0 itself. */\\n            if(!$this->validateGroup($digits,0,$i-1))\\n                continue;\\n            if(!$this->validateGroup($digits,$i,$last-1))\\n                continue;\\n            \\n            /* Get each valid decimal position within each group. */\\n            $g1 = $this->getDecimalStrings($digits, 0, $i-1);\\n            $g2 = $this->getDecimalStrings($digits, $i, $last-1);\\n            for($j=0; $j<count($g1); $j++)\\n            {\\n                for($k=0; $k<count($g2); $k++)\\n                {\\n                    $groups[] = \"(\".$g1[$j].\", \".$g2[$k].\")\";\\n                }\\n            }\\n            \\n        }\\n\\n        return $groups;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207004,
                "title": "ruby-o-n-4",
                "content": "```\\n# @param {String} s\\n# @return {String[]}\\ndef ambiguous_coordinates(s)\\n  n = s.length\\n  result = []\\n  \\n  (2...n-1).each do |i|\\n    cand_left = generate(s[1...i])\\n    cand_right = generate(s[i...-1])     \\n    cand_left.product(cand_right).each do |left, right|\\n      result << \"(\" + left + \", \" + right + \")\"\\n    end\\n  end\\n\\n  result\\nend\\n          \\ndef generate(s)\\n  result = []\\n  result << s if s == \"0\" || s[0] != \"0\"\\n\\n  (1...s.length).each do |i|\\n    if (s[0...i] == \"0\" || s[0] != \"0\") && s[-1] != \"0\"\\n      result << s[0...i] + \".\" + s[i..-1]\\n    end\\n  end\\n\\n  result\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} s\\n# @return {String[]}\\ndef ambiguous_coordinates(s)\\n  n = s.length\\n  result = []\\n  \\n  (2...n-1).each do |i|\\n    cand_left = generate(s[1...i])\\n    cand_right = generate(s[i...-1])     \\n    cand_left.product(cand_right).each do |left, right|\\n      result << \"(\" + left + \", \" + right + \")\"\\n    end\\n  end\\n\\n  result\\nend\\n          \\ndef generate(s)\\n  result = []\\n  result << s if s == \"0\" || s[0] != \"0\"\\n\\n  (1...s.length).each do |i|\\n    if (s[0...i] == \"0\" || s[0] != \"0\") && s[-1] != \"0\"\\n      result << s[0...i] + \".\" + s[i..-1]\\n    end\\n  end\\n\\n  result\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1206982,
                "title": "scala-functional-programming-solution",
                "content": "```scala\\nobject Solution {\\n    def ambiguousCoordinates(s: String): List[String] = {\\n        parser.runP(s.toList).map(p => p._1)\\n    }\\n\\n    case class Parser[+A](runP: List[Char] => List[(A, List[Char])]) { self =>\\n        def map[B](f: A => B): Parser[B] = Parser(l => self.runP(l).map {case (a, remaining) => (f(a), remaining)})\\n        def flatMap[B](f: A => Parser[B]): Parser[B] = Parser(l => {\\n            self.runP(l).flatMap {case (a, remaining) => f(a).runP(remaining)}\\n        })\\n    }\\n    \\n    val fail: Parser[Nothing] = Parser(l => Nil)\\n    def pure[A](a: A): Parser[A] = Parser(l => List((a, l)))\\n    val item: Parser[Char] = Parser(l => l match {\\n        case Nil => Nil\\n        case x :: xs => List((x, xs))\\n    })\\n    \\n    def sat(p: Char => Boolean): Parser[Char] = for {\\n        ch <- item\\n        x <- if(p(ch)) pure(ch) else fail\\n    } yield x\\n    \\n    val leftP: Parser[Char] = sat(ch => ch == \\'(\\')\\n    val rightP: Parser[Char] = sat(ch => ch == \\')\\')\\n    \\n    val digit: Parser[Char] = sat(ch => \\'0\\' <= ch && ch <= \\'9\\')\\n    val zero: Parser[Char] = sat(ch => ch == \\'0\\')\\n    val nonzero: Parser[Char] = sat(ch => \\'1\\' <= ch && ch <= \\'9\\')\\n\\n    \\n    def many1(p: Parser[Char]): Parser[List[Char]] = for {\\n        c <- p\\n        cs <- many(p)\\n    } yield c :: cs\\n    \\n    def or[A](p1: Parser[A], p2: Parser[A]): Parser[A] = Parser(l => p1.runP(l) ++ p2.runP(l))\\n    def many(p: Parser[Char]): Parser[List[Char]] = or(many1(p), pure(Nil))\\n    val integer: Parser[String] = or(\\n        zero.map(_.toString),\\n        for {\\n            n <- nonzero\\n            ns <- many(digit)\\n        } yield ((n :: ns).mkString)\\n    )\\n    \\n    val fraction: Parser[String] = for {\\n        ns <- many(digit)\\n        n <- nonzero\\n    } yield (ns ++ List(n)).mkString\\n    \\n    val number: Parser[String] = or(\\n        for {\\n            int <- integer\\n            frac <- fraction\\n        } yield s\"$int.$frac\",\\n        integer\\n    )\\n    \\n    val parser: Parser[String] = for {\\n        _ <- leftP\\n        n1 <- number\\n        n2 <- number\\n        _ <- rightP\\n    } yield s\"($n1, $n2)\"\\n    \\n    \\n\\n}\\n```",
                "solutionTags": [],
                "code": "```scala\\nobject Solution {\\n    def ambiguousCoordinates(s: String): List[String] = {\\n        parser.runP(s.toList).map(p => p._1)\\n    }\\n\\n    case class Parser[+A](runP: List[Char] => List[(A, List[Char])]) { self =>\\n        def map[B](f: A => B): Parser[B] = Parser(l => self.runP(l).map {case (a, remaining) => (f(a), remaining)})\\n        def flatMap[B](f: A => Parser[B]): Parser[B] = Parser(l => {\\n            self.runP(l).flatMap {case (a, remaining) => f(a).runP(remaining)}\\n        })\\n    }\\n    \\n    val fail: Parser[Nothing] = Parser(l => Nil)\\n    def pure[A](a: A): Parser[A] = Parser(l => List((a, l)))\\n    val item: Parser[Char] = Parser(l => l match {\\n        case Nil => Nil\\n        case x :: xs => List((x, xs))\\n    })\\n    \\n    def sat(p: Char => Boolean): Parser[Char] = for {\\n        ch <- item\\n        x <- if(p(ch)) pure(ch) else fail\\n    } yield x\\n    \\n    val leftP: Parser[Char] = sat(ch => ch == \\'(\\')\\n    val rightP: Parser[Char] = sat(ch => ch == \\')\\')\\n    \\n    val digit: Parser[Char] = sat(ch => \\'0\\' <= ch && ch <= \\'9\\')\\n    val zero: Parser[Char] = sat(ch => ch == \\'0\\')\\n    val nonzero: Parser[Char] = sat(ch => \\'1\\' <= ch && ch <= \\'9\\')\\n\\n    \\n    def many1(p: Parser[Char]): Parser[List[Char]] = for {\\n        c <- p\\n        cs <- many(p)\\n    } yield c :: cs\\n    \\n    def or[A](p1: Parser[A], p2: Parser[A]): Parser[A] = Parser(l => p1.runP(l) ++ p2.runP(l))\\n    def many(p: Parser[Char]): Parser[List[Char]] = or(many1(p), pure(Nil))\\n    val integer: Parser[String] = or(\\n        zero.map(_.toString),\\n        for {\\n            n <- nonzero\\n            ns <- many(digit)\\n        } yield ((n :: ns).mkString)\\n    )\\n    \\n    val fraction: Parser[String] = for {\\n        ns <- many(digit)\\n        n <- nonzero\\n    } yield (ns ++ List(n)).mkString\\n    \\n    val number: Parser[String] = or(\\n        for {\\n            int <- integer\\n            frac <- fraction\\n        } yield s\"$int.$frac\",\\n        integer\\n    )\\n    \\n    val parser: Parser[String] = for {\\n        _ <- leftP\\n        n1 <- number\\n        n2 <- number\\n        _ <- rightP\\n    } yield s\"($n1, $n2)\"\\n    \\n    \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206905,
                "title": "easy-to-understand-java-solution-with-comments",
                "content": "The thought process is to first split the string into two numbers, and then for each number again split the number to get all valid decimal numbers.\\nComments have been added in the code for understanding.\\nPlease upvote if you like the solution. \\n\\n```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        // remove the brackets and get the number\\n        String num = s.substring(1,s.length()-1);\\n        \\n        \\n        List<String> res = new ArrayList<>();\\n        \\n        // split the number into left and right, and\\n        // for each left & right get the decimal & non-decimal permutations.\\n        // Total complexity = O(n^3)\\n        for(int i=1;i<num.length();i++) {\\n            String left = num.substring(0,i);\\n            String right = num.substring(i,num.length());\\n            getDecimalPair(res,left,right);\\n        }\\n        //System.out.println(res);\\n        \\n        return res;\\n    }\\n    \\n\\n    public void getDecimalPair(List<String> res, String left, String right){\\n        \\n        List<String> leftList = getDecimalPermute(left); // O(n)\\n        List<String> rightList = getDecimalPermute(right); // O(n)\\n        \\n        // get all permutation of left and right.\\n        for(String l:leftList) {\\n            for(String r:rightList) {\\n                res.add(addStr(l,r));\\n            }\\n        }\\n    }\\n    \\n  \\n    public List<String> getDecimalPermute(String str){\\n        List<String> res = new ArrayList<>();\\n        if(str.length()==1) {\\n            res.add(str);\\n            return res;\\n        }\\n        \\n        // Split the number to left and right so that decimal point \\n        // can be added in between. The decimal number can only\\n        // be added to the list if it satisfies the condition in the \\n        // problem statement, the condition is specified in the first if() statement.\\n\\t\\t\\n        for(int i=1;i<=str.length();i++) {\\n            String left = str.substring(0,i);\\n            String right = str.substring(i,str.length());\\n            if((!left.startsWith(\"0\") || left.equals(\"0\")) && !right.endsWith(\"0\")) {\\n                if(i<str.length())\\n                    res.add(left+\".\"+right);\\n                else //if s==str.length() then add the whole number(i.e., left+right).\\n                    res.add(left+right); \\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public String addStr(String left, String right) {\\n        return \"(\"+left+\", \"+right+\")\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        // remove the brackets and get the number\\n        String num = s.substring(1,s.length()-1);\\n        \\n        \\n        List<String> res = new ArrayList<>();\\n        \\n        // split the number into left and right, and\\n        // for each left & right get the decimal & non-decimal permutations.\\n        // Total complexity = O(n^3)\\n        for(int i=1;i<num.length();i++) {\\n            String left = num.substring(0,i);\\n            String right = num.substring(i,num.length());\\n            getDecimalPair(res,left,right);\\n        }\\n        //System.out.println(res);\\n        \\n        return res;\\n    }\\n    \\n\\n    public void getDecimalPair(List<String> res, String left, String right){\\n        \\n        List<String> leftList = getDecimalPermute(left); // O(n)\\n        List<String> rightList = getDecimalPermute(right); // O(n)\\n        \\n        // get all permutation of left and right.\\n        for(String l:leftList) {\\n            for(String r:rightList) {\\n                res.add(addStr(l,r));\\n            }\\n        }\\n    }\\n    \\n  \\n    public List<String> getDecimalPermute(String str){\\n        List<String> res = new ArrayList<>();\\n        if(str.length()==1) {\\n            res.add(str);\\n            return res;\\n        }\\n        \\n        // Split the number to left and right so that decimal point \\n        // can be added in between. The decimal number can only\\n        // be added to the list if it satisfies the condition in the \\n        // problem statement, the condition is specified in the first if() statement.\\n\\t\\t\\n        for(int i=1;i<=str.length();i++) {\\n            String left = str.substring(0,i);\\n            String right = str.substring(i,str.length());\\n            if((!left.startsWith(\"0\") || left.equals(\"0\")) && !right.endsWith(\"0\")) {\\n                if(i<str.length())\\n                    res.add(left+\".\"+right);\\n                else //if s==str.length() then add the whole number(i.e., left+right).\\n                    res.add(left+right); \\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public String addStr(String left, String right) {\\n        return \"(\"+left+\", \"+right+\")\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206887,
                "title": "python3-no-regex-and-no-str-int-conversion-48ms-beats-60-o-n-3-time",
                "content": "\\tclass Solution:\\n\\t\\tdef ambiguousCoordinates(self, s: str) -> List[str]:\\n\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t- split s into two parts: left and right\\n\\t\\t\\t- apply getPossible() function to left and right\\n\\t\\t\\t- mix the results from left and right\\n\\t\\t\\t- return list\\n\\n\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t@functools.lru_cache(None)\\n\\t\\t\\tdef getPossible(i, j):\\n\\t\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t\\t- for substring starts from i, ending at j, inclusive\\n\\t\\t\\t\\t- case1: one element, can make only s[i:j+1]\\n\\t\\t\\t\\t- case2: at least two elements\\n\\t\\t\\t\\t\\t- case21: both trailing and leading zeros, return []\\n\\t\\t\\t\\t\\t- case22: only leading zero, return 0.xxxx\\n\\t\\t\\t\\t\\t- case23: only trailing zero, return s[i:j+1]\\n\\t\\t\\t\\t\\t- case24: no trailing/leading zeros, return all xxx.xxx plus xxxxxx itself\\n\\n\\t\\t\\t\\t\\'\\'\\'\\n\\n\\t\\t\\t\\tif i == j: return [s[i]]\\n\\t\\t\\t\\tif s[i] == s[j] == \\'0\\': return []\\n\\t\\t\\t\\tif s[i] == \\'0\\': return [s[i]+\\'.\\'+s[i+1:j+1]]\\n\\t\\t\\t\\tif s[j] == \\'0\\': return [s[i:j+1]]\\n\\t\\t\\t\\tres = [s[i:j+1]]\\n\\t\\t\\t\\tfor k in range(i, j): res.append(s[i:k+1]+\\'.\\'+s[k+1:j+1])\\n\\t\\t\\t\\treturn res\\n\\n\\t\\t\\t# calculate\\n\\t\\t\\tres = []\\n\\t\\t\\tfor k in range(1, len(s)-2): # here needs O(N**3) time\\n\\t\\t\\t\\tfor left in getPossible(1, k):\\n\\t\\t\\t\\t\\tfor right in getPossible(k+1, len(s)-2):\\n\\t\\t\\t\\t\\t\\tres.append(\\'(\\' + left + \\', \\' + right + \\')\\')\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef ambiguousCoordinates(self, s: str) -> List[str]:\\n\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t- split s into two parts: left and right\\n\\t\\t\\t- apply getPossible() function to left and right\\n\\t\\t\\t- mix the results from left and right\\n\\t\\t\\t- return list\\n\\n\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t@functools.lru_cache(None)\\n\\t\\t\\tdef getPossible(i, j):\\n\\t\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t\\t- for substring starts from i, ending at j, inclusive\\n\\t\\t\\t\\t- case1: one element, can make only s[i:j+1]\\n\\t\\t\\t\\t- case2: at least two elements\\n\\t\\t\\t\\t\\t- case21: both trailing and leading zeros, return []\\n\\t\\t\\t\\t\\t- case22: only leading zero, return 0.xxxx\\n\\t\\t\\t\\t\\t- case23: only trailing zero, return s[i:j+1]\\n\\t\\t\\t\\t\\t- case24: no trailing/leading zeros, return all xxx.xxx plus xxxxxx itself\\n\\n\\t\\t\\t\\t\\'\\'\\'\\n\\n\\t\\t\\t\\tif i == j: return [s[i]]\\n\\t\\t\\t\\tif s[i] == s[j] == \\'0\\': return []\\n\\t\\t\\t\\tif s[i] == \\'0\\': return [s[i]+\\'.\\'+s[i+1:j+1]]\\n\\t\\t\\t\\tif s[j] == \\'0\\': return [s[i:j+1]]\\n\\t\\t\\t\\tres = [s[i:j+1]]\\n\\t\\t\\t\\tfor k in range(i, j): res.append(s[i:k+1]+\\'.\\'+s[k+1:j+1])\\n\\t\\t\\t\\treturn res\\n\\n\\t\\t\\t# calculate\\n\\t\\t\\tres = []\\n\\t\\t\\tfor k in range(1, len(s)-2): # here needs O(N**3) time\\n\\t\\t\\t\\tfor left in getPossible(1, k):\\n\\t\\t\\t\\t\\tfor right in getPossible(k+1, len(s)-2):\\n\\t\\t\\t\\t\\t\\tres.append(\\'(\\' + left + \\', \\' + right + \\')\\')\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 1206873,
                "title": "python3-brute-force-93",
                "content": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        #strategy: Brute Force\\n        answer = []\\n        def helper(x: str):\\n            temp = []\\n            #no decimal point\\n            if x[0] != \\'0\\' or len(x) == 1:\\n                temp.append(x)\\n            #decimal point\\n            for i in range(1, len(x)):\\n                #we can\\'t have the ending to ever be 0\\n                #the only time we can use the start as 0 if it is the only digit in front of the decimal point\\n                if ((x[0] == \\'0\\' and i == 1) or (x[0] != \\'0\\')) and (x[-1] != \\'0\\'):\\n                    temp.append(x[0:i] + \".\" + x[i:])\\n            return temp\\n        #don\\'t include parenthesis\\n        for i in range(2, len(s) - 1):\\n            #find the two points\\n            a, b = s[1:i], s[i:len(s) - 1:]\\n            #helper will add decimal points if applicable\\n            for first in helper(a):\\n                for second in helper(b):\\n                    answer.append(\"({}, {})\".format(first, second))\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        #strategy: Brute Force\\n        answer = []\\n        def helper(x: str):\\n            temp = []\\n            #no decimal point\\n            if x[0] != \\'0\\' or len(x) == 1:\\n                temp.append(x)\\n            #decimal point\\n            for i in range(1, len(x)):\\n                #we can\\'t have the ending to ever be 0\\n                #the only time we can use the start as 0 if it is the only digit in front of the decimal point\\n                if ((x[0] == \\'0\\' and i == 1) or (x[0] != \\'0\\')) and (x[-1] != \\'0\\'):\\n                    temp.append(x[0:i] + \".\" + x[i:])\\n            return temp\\n        #don\\'t include parenthesis\\n        for i in range(2, len(s) - 1):\\n            #find the two points\\n            a, b = s[1:i], s[i:len(s) - 1:]\\n            #helper will add decimal points if applicable\\n            for first in helper(a):\\n                for second in helper(b):\\n                    answer.append(\"({}, {})\".format(first, second))\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206868,
                "title": "java-modular-code",
                "content": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> res = new ArrayList<>();\\n        if (s == null || s.length() == 0) return res;\\n        for (int i = 1; i < s.length()-2; i++) {\\n            List<String> left = getAllNums(s.substring(1, i+1));\\n            List<String> right = getAllNums(s.substring(i+1, s.length()-1));\\n            for (String l : left) {\\n                for (String r : right) {\\n                    res.add(\"(\" + l + \", \" + r + \")\");\\n                }\\n            }\\n        }\\n        return res;        \\n    }\\n\\n    private List<String> getAllNums(String str) {\\n        StringBuilder sb = new StringBuilder(str);\\n        List<String> res = new ArrayList<>();\\n        if (isValid(str)) {\\n            res.add(str);\\n        }\\n        for (int i = 1; i < str.length(); i++) {\\n            sb.insert(i, \\'.\\');\\n            if (isValid(sb.toString())) {\\n                res.add(sb.toString());\\n            }\\n            sb.deleteCharAt(i);\\n        }\\n        return res;\\n    }\\n    \\n    private boolean isValid(String str) {\\n        // System.out.println(\"checking: \" + str);\\n        if (str.charAt(0) == \\'.\\' ||\\n            str.charAt(str.length()-1) == \\'.\\' ||\\n            str.equals(\"0.0\")) {\\n            return false;\\n        }\\n        String[] parts = str.split(\"[\\\\\\\\.]\");\\n        if (parts.length == 1) {\\n            return str.length() == 1 || !isLeadingZero(str);\\n        }\\n        else {\\n            return (!isTrailingZero(parts[1]) &&\\n                    (parts[0].length() == 1 || !isLeadingZero(parts[0]))); \\n        }\\n    }\\n    \\n    private boolean isLeadingZero(String str) {\\n        return (str.length() > 0 && str.charAt(0) == \\'0\\');\\n    }\\n    \\n    private boolean isTrailingZero(String str) {\\n        return (str.length() > 0 && str.charAt(str.length()-1) == \\'0\\');\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> res = new ArrayList<>();\\n        if (s == null || s.length() == 0) return res;\\n        for (int i = 1; i < s.length()-2; i++) {\\n            List<String> left = getAllNums(s.substring(1, i+1));\\n            List<String> right = getAllNums(s.substring(i+1, s.length()-1));\\n            for (String l : left) {\\n                for (String r : right) {\\n                    res.add(\"(\" + l + \", \" + r + \")\");\\n                }\\n            }\\n        }\\n        return res;        \\n    }\\n\\n    private List<String> getAllNums(String str) {\\n        StringBuilder sb = new StringBuilder(str);\\n        List<String> res = new ArrayList<>();\\n        if (isValid(str)) {\\n            res.add(str);\\n        }\\n        for (int i = 1; i < str.length(); i++) {\\n            sb.insert(i, \\'.\\');\\n            if (isValid(sb.toString())) {\\n                res.add(sb.toString());\\n            }\\n            sb.deleteCharAt(i);\\n        }\\n        return res;\\n    }\\n    \\n    private boolean isValid(String str) {\\n        // System.out.println(\"checking: \" + str);\\n        if (str.charAt(0) == \\'.\\' ||\\n            str.charAt(str.length()-1) == \\'.\\' ||\\n            str.equals(\"0.0\")) {\\n            return false;\\n        }\\n        String[] parts = str.split(\"[\\\\\\\\.]\");\\n        if (parts.length == 1) {\\n            return str.length() == 1 || !isLeadingZero(str);\\n        }\\n        else {\\n            return (!isTrailingZero(parts[1]) &&\\n                    (parts[0].length() == 1 || !isLeadingZero(parts[0]))); \\n        }\\n    }\\n    \\n    private boolean isLeadingZero(String str) {\\n        return (str.length() > 0 && str.charAt(0) == \\'0\\');\\n    }\\n    \\n    private boolean isTrailingZero(String str) {\\n        return (str.length() > 0 && str.charAt(str.length()-1) == \\'0\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206867,
                "title": "beat-100-simple-javascript-regex-with-explanation",
                "content": "```\\nconst ambiguousCoordinates = function (s) {\\n\\n  const ans = [];\\n\\n  // outer for loop to create all combinations of numbers on left and right side\\n  for (let i = 2; i < s.length - 1; i++) {\\n    let lft = s.slice(1, i);\\n    let rght = s.slice(i, s.length - 1);\\n\\n    //  add combinations with no decimals\\n    const ls = [lft];\\n    const rs = [rght];\\n\\n    // inner for loop to find all combinations of left side with a decimal\\n    for (let i = 1; i < lft.length; i++) {\\n      temp1 = lft.slice(0, i);\\n      temp2 = lft.slice(i);\\n      ls.push(`${temp1}.${temp2}`);\\n    }\\n\\n    // inner for loop to find all combinations of right side with a decimal\\n    for (let i = 1; i < rght.length; i++) {\\n      temp1 = rght.slice(0, i);\\n      temp2 = rght.slice(i, rght.length);\\n      rs.push(`${temp1}.${temp2}`);\\n    }\\n\\n    // push in all valid answers that pass the regex\\n    for (let l of ls) {\\n      if (!/^([1-9]\\\\d*|0\\\\.\\\\d*[1-9]|[1-9]\\\\d*\\\\.\\\\d*[1-9]|0)$/i.test(l)) continue;\\n      for (let r of rs) {\\n        if (!/^([1-9]\\\\d*|0\\\\.\\\\d*[1-9]|[1-9]\\\\d*\\\\.\\\\d*[1-9]|0)$/i.test(r)) continue;\\n        ans.push(`(${l}, ${r})`);\\n      }\\n    }\\n  }\\n  return ans;\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/ba9a047a-783a-484c-b85f-af508df2be68_1620935777.2615383.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst ambiguousCoordinates = function (s) {\\n\\n  const ans = [];\\n\\n  // outer for loop to create all combinations of numbers on left and right side\\n  for (let i = 2; i < s.length - 1; i++) {\\n    let lft = s.slice(1, i);\\n    let rght = s.slice(i, s.length - 1);\\n\\n    //  add combinations with no decimals\\n    const ls = [lft];\\n    const rs = [rght];\\n\\n    // inner for loop to find all combinations of left side with a decimal\\n    for (let i = 1; i < lft.length; i++) {\\n      temp1 = lft.slice(0, i);\\n      temp2 = lft.slice(i);\\n      ls.push(`${temp1}.${temp2}`);\\n    }\\n\\n    // inner for loop to find all combinations of right side with a decimal\\n    for (let i = 1; i < rght.length; i++) {\\n      temp1 = rght.slice(0, i);\\n      temp2 = rght.slice(i, rght.length);\\n      rs.push(`${temp1}.${temp2}`);\\n    }\\n\\n    // push in all valid answers that pass the regex\\n    for (let l of ls) {\\n      if (!/^([1-9]\\\\d*|0\\\\.\\\\d*[1-9]|[1-9]\\\\d*\\\\.\\\\d*[1-9]|0)$/i.test(l)) continue;\\n      for (let r of rs) {\\n        if (!/^([1-9]\\\\d*|0\\\\.\\\\d*[1-9]|[1-9]\\\\d*\\\\.\\\\d*[1-9]|0)$/i.test(r)) continue;\\n        ans.push(`(${l}, ${r})`);\\n      }\\n    }\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1206823,
                "title": "python-break-it-down",
                "content": "```\\ndef ambiguousCoordinates(self, s: str) -> List[str]:\\n\\tresults = set()\\n\\tisvalid = lambda x: len(str(int(x))) == len(x)\\n\\n\\tdef getvalidnums(s):\\n\\t\\tnums = []\\n\\t\\tif isvalid(s): nums.append(s)\\n\\t\\tfor i in range(1, len(s)):\\n\\t\\t\\tif isvalid(s[:i]) and isvalid(s[i:][::-1]) and s[i:] != \\'0\\':\\n\\t\\t\\t\\tnums.append(f\\'{s[:i]}.{s[i:]}\\')\\n\\t\\treturn nums\\n\\n\\tfor i in range(2, len(s)-1):\\n\\t\\tlnums = getvalidnums(s[1:i])\\n\\t\\trnums = getvalidnums(s[i:-1])\\n\\t\\tfor x, y in product(lnums, rnums):\\n\\t\\t\\tresults.add(f\\'({x}, {y})\\')\\n\\n\\treturn results\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef ambiguousCoordinates(self, s: str) -> List[str]:\\n\\tresults = set()\\n\\tisvalid = lambda x: len(str(int(x))) == len(x)\\n\\n\\tdef getvalidnums(s):\\n\\t\\tnums = []\\n\\t\\tif isvalid(s): nums.append(s)\\n\\t\\tfor i in range(1, len(s)):\\n\\t\\t\\tif isvalid(s[:i]) and isvalid(s[i:][::-1]) and s[i:] != \\'0\\':\\n\\t\\t\\t\\tnums.append(f\\'{s[:i]}.{s[i:]}\\')\\n\\t\\treturn nums\\n\\n\\tfor i in range(2, len(s)-1):\\n\\t\\tlnums = getvalidnums(s[1:i])\\n\\t\\trnums = getvalidnums(s[i:-1])\\n\\t\\tfor x, y in product(lnums, rnums):\\n\\t\\t\\tresults.add(f\\'({x}, {y})\\')\\n\\n\\treturn results\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1206820,
                "title": "ruby-map-by-comma-position-then-by-floating-point-position",
                "content": "```ruby\\ndef ambiguous_coordinates(s)\\n  digits = s[1..-2]\\n  n = digits.size\\n  (1...n).flat_map do |comma_pos|\\n    x, y = digits[0...comma_pos], digits[comma_pos...n]\\n\\n    next([]) if x.size > 1 && x.start_with?(\\'0\\') && x.end_with?(\\'0\\') ||\\n                y.size > 1 && y.start_with?(\\'0\\') && y.end_with?(\\'0\\')\\n\\n    x_coords = if x.size == 1 || x.end_with?(\\'0\\')\\n                 [x]\\n               elsif x.start_with?(\\'0\\')\\n                 [\"0.#{x[1..-1]}\"]\\n               else\\n                 (0...x.size).map { |p| p.zero? ? x : \"#{x[0...p]}.#{x[p..-1]}\" }\\n               end\\n    y_coords = if y.size == 1 || y.end_with?(\\'0\\')\\n                 [y]\\n               elsif y.start_with?(\\'0\\')\\n                 [\"0.#{y[1..-1]}\"]\\n               else\\n                 (0...y.size).map { |p| p.zero? ? y : \"#{y[0...p]}.#{y[p..-1]}\" }\\n               end\\n    x_coords.product(y_coords).map do |xc, yc|\\n      \"(#{xc}, #{yc})\"\\n    end\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef ambiguous_coordinates(s)\\n  digits = s[1..-2]\\n  n = digits.size\\n  (1...n).flat_map do |comma_pos|\\n    x, y = digits[0...comma_pos], digits[comma_pos...n]\\n\\n    next([]) if x.size > 1 && x.start_with?(\\'0\\') && x.end_with?(\\'0\\') ||\\n                y.size > 1 && y.start_with?(\\'0\\') && y.end_with?(\\'0\\')\\n\\n    x_coords = if x.size == 1 || x.end_with?(\\'0\\')\\n                 [x]\\n               elsif x.start_with?(\\'0\\')\\n                 [\"0.#{x[1..-1]}\"]\\n               else\\n                 (0...x.size).map { |p| p.zero? ? x : \"#{x[0...p]}.#{x[p..-1]}\" }\\n               end\\n    y_coords = if y.size == 1 || y.end_with?(\\'0\\')\\n                 [y]\\n               elsif y.start_with?(\\'0\\')\\n                 [\"0.#{y[1..-1]}\"]\\n               else\\n                 (0...y.size).map { |p| p.zero? ? y : \"#{y[0...p]}.#{y[p..-1]}\" }\\n               end\\n    x_coords.product(y_coords).map do |xc, yc|\\n      \"(#{xc}, #{yc})\"\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1206753,
                "title": "simple-regex",
                "content": "The solution consist of two parts. 1) Split the original string into two non-empty substrings, 2) for each substring, exhaust position of decimal point.\\nUsing a regex to check if the substring (after adding decimal point) is valid.\\n```\\nimport (\\n  \"fmt\"\\n  \"regexp\"\\n)\\n\\nfunc ambiguousCoordinates(s string) []string {\\n  var res []string\\n  s = s[1:len(s)-1]\\n  for i := 0; i < len(s)-1; i++ {\\n    left := dec(s[:i+1])\\n    right := dec(s[i+1:])\\n    for _, l := range left {\\n      for _, r := range right {\\n        res = append(res, fmt.Sprintf(\"(%s, %s)\", l, r))\\n      }\\n    }\\n  }\\n  return res\\n}\\n\\nvar validNumber = regexp.MustCompile(\"^([1-9]\\\\\\\\d*|0)(\\\\\\\\.\\\\\\\\d*[1-9])?$\")\\n\\nfunc dec(s string) []string {\\n  var res []string\\n  for i := 0; i < len(s); i++ {\\n    t := s\\n    if i != 0 {\\n      t = fmt.Sprintf(\"%s.%s\", s[:i], s[i:])\\n    }\\n    if validNumber.MatchString(t) {\\n      res = append(res, t)\\n    }\\n  }\\n  return res\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimport (\\n  \"fmt\"\\n  \"regexp\"\\n)\\n\\nfunc ambiguousCoordinates(s string) []string {\\n  var res []string\\n  s = s[1:len(s)-1]\\n  for i := 0; i < len(s)-1; i++ {\\n    left := dec(s[:i+1])\\n    right := dec(s[i+1:])\\n    for _, l := range left {\\n      for _, r := range right {\\n        res = append(res, fmt.Sprintf(\"(%s, %s)\", l, r))\\n      }\\n    }\\n  }\\n  return res\\n}\\n\\nvar validNumber = regexp.MustCompile(\"^([1-9]\\\\\\\\d*|0)(\\\\\\\\.\\\\\\\\d*[1-9])?$\")\\n\\nfunc dec(s string) []string {\\n  var res []string\\n  for i := 0; i < len(s); i++ {\\n    t := s\\n    if i != 0 {\\n      t = fmt.Sprintf(\"%s.%s\", s[:i], s[i:])\\n    }\\n    if validNumber.MatchString(t) {\\n      res = append(res, t)\\n    }\\n  }\\n  return res\\n}\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1206720,
                "title": "python3-solution-for-reference-based-on-string-arrangement",
                "content": "The following template and refernce code below can help !\\n- Split the string into various substrings first ( 1234 -> 1 234, 12 34, 123 4 ) so that *left, right* are atleast 1 char long. \\n- If left or right starts with a \\'0\\' then the rest of the string can just only be a decimal as per the conditions. ( 0 0001 -> 0.0001; 0 123 -> 0.123)\\n- left and right choices cannot have decimal parts that end with \\'0\\' This one was revealed in tests. \\n- Among left and right strings insert \\'.\\' to make decimals. \\n- Collect all left items first and append each right item to all left ele to fill up output. \\n- Format strings comes in handy for the output formatting\\n\\nThere is scope for improvement for logic below by clubbng together, conditions.\\n\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        sp = [(s[:x], s[x:]) for x in range(1,len(s))]\\n        o = []\\n        for left, right in sp:\\n            la = []\\n            if left[0] == \\'0\\' and len(left) > 1 and set(left) != set([\"0\"]):\\n                if left[1:][-1] != \\'0\\':                \\n                    la.append((left[:1] + \\'.\\' + left[1:]))\\n            else:\\n                if (len(left) > 1 and set(left) != set([\"0\"])) or len(left) == 1:\\n                    la.append(left)\\n                    for y in range(1, len(left)):\\n                        if int(left[y:]) != 0 and left[y:][-1] != \\'0\\':\\n                            la.append((left[:y] + \\'.\\' + left[y:]))\\n                            \\n            ra = []\\n            if right[0] == \\'0\\' and len(right) > 1 and set(right) != set([\"0\"]):\\n                if right[1:][-1] != \\'0\\':\\n                    o += [\"(%s, %s)\"%(i, (right[:1] + \\'.\\' + right[1:])) for i in la]\\n            else:\\n                if (len(right) > 1 and set(right) != set([\"0\"])) or len(right) == 1:                 \\n                    o += [\"(%s, %s)\"%(i, right) for i in la]\\n                    for y in range(1, len(right)):\\n                        if int(right[y:]) != 0 and right[y:][-1] != \\'0\\':\\n                            rightside = right[:y] + \\'.\\' + right[y:]\\n                            o += [\"(%s, %s)\"%(i, rightside) for i in la]\\n                    \\n        return o",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "The following template and refernce code below can help !\\n- Split the string into various substrings first ( 1234 -> 1 234, 12 34, 123 4 ) so that *left, right* are atleast 1 char long. \\n- If left or right starts with a \\'0\\' then the rest of the string can just only be a decimal as per the conditions. ( 0 0001 -> 0.0001; 0 123 -> 0.123)\\n- left and right choices cannot have decimal parts that end with \\'0\\' This one was revealed in tests. \\n- Among left and right strings insert \\'.\\' to make decimals. \\n- Collect all left items first and append each right item to all left ele to fill up output. \\n- Format strings comes in handy for the output formatting\\n\\nThere is scope for improvement for logic below by clubbng together, conditions.\\n\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        sp = [(s[:x], s[x:]) for x in range(1,len(s))]\\n        o = []\\n        for left, right in sp:\\n            la = []\\n            if left[0] == \\'0\\' and len(left) > 1 and set(left) != set([\"0\"]):\\n                if left[1:][-1] != \\'0\\':                \\n                    la.append((left[:1] + \\'.\\' + left[1:]))\\n            else:\\n                if (len(left) > 1 and set(left) != set([\"0\"])) or len(left) == 1:\\n                    la.append(left)\\n                    for y in range(1, len(left)):\\n                        if int(left[y:]) != 0 and left[y:][-1] != \\'0\\':\\n                            la.append((left[:y] + \\'.\\' + left[y:]))\\n                            \\n            ra = []\\n            if right[0] == \\'0\\' and len(right) > 1 and set(right) != set([\"0\"]):\\n                if right[1:][-1] != \\'0\\':\\n                    o += [\"(%s, %s)\"%(i, (right[:1] + \\'.\\' + right[1:])) for i in la]\\n            else:\\n                if (len(right) > 1 and set(right) != set([\"0\"])) or len(right) == 1:                 \\n                    o += [\"(%s, %s)\"%(i, right) for i in la]\\n                    for y in range(1, len(right)):\\n                        if int(right[y:]) != 0 and right[y:][-1] != \\'0\\':\\n                            rightside = right[:y] + \\'.\\' + right[y:]\\n                            o += [\"(%s, %s)\"%(i, rightside) for i in la]\\n                    \\n        return o",
                "codeTag": "Java"
            },
            {
                "id": 1206681,
                "title": "easy-to-understand-java-solution-with-comments-explanation",
                "content": "```\\n public List<String> ambiguousCoordinates(String s) {\\n        s=s.substring(1,s.length()-1);\\n        List<String> list=new ArrayList<String>();\\n        \\n        for(int i=1; i<s.length(); i++){\\n    \\n        String leftSubstring=s.substring(0,i);\\n        String rightSubstring=s.substring(i,s.length());\\n            \\n        Set<String> leftPart=generate(leftSubstring);\\n        Set<String> rightPart=generate(rightSubstring);\\n        \\n        for(String left: leftPart){\\n            for(String right: rightPart){\\n                list.add(\"(\" + left + \", \"+ right + \")\");\\n            }\\n        }    \\n            \\n        }\\n        return list;\\n    }\\n    \\n    public Set<String> generate(String s){\\n        Set<String> hset=new HashSet<String>();\\n        int l=s.length();\\n        char c[]=s.toCharArray();\\n    \\n        //0XXXXX0 is Invalid unless a single zero.\\n        if(c[0]==\\'0\\' && c[l-1]==\\'0\\'){\\n            if(l==1){\\n                hset.add(\"0\");\\n            }\\n            return hset;\\n        }\\n        \\n        //0XXXX can be split like this 0.XXXX\\n        if(c[0]==\\'0\\'){\\n            hset.add(\"0.\"+s.substring(1));\\n            return hset;\\n        }\\n        \\n        //XXXX0 cannot be split\\n        if(c[l-1]==\\'0\\'){\\n            hset.add(s);\\n            return hset;\\n        }\\n        \\n        //Generating Substring for every case. XXXX => X.XXX, XX.XX, XXX.X \\n        for(int i=1; i<l; i++){\\n            hset.add(s.substring(0,i)+\".\"+s.substring(i));\\n        }\\n        hset.add(s);\\n        return hset;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n public List<String> ambiguousCoordinates(String s) {\\n        s=s.substring(1,s.length()-1);\\n        List<String> list=new ArrayList<String>();\\n        \\n        for(int i=1; i<s.length(); i++){\\n    \\n        String leftSubstring=s.substring(0,i);\\n        String rightSubstring=s.substring(i,s.length());\\n            \\n        Set<String> leftPart=generate(leftSubstring);\\n        Set<String> rightPart=generate(rightSubstring);\\n        \\n        for(String left: leftPart){\\n            for(String right: rightPart){\\n                list.add(\"(\" + left + \", \"+ right + \")\");\\n            }\\n        }    \\n            \\n        }\\n        return list;\\n    }\\n    \\n    public Set<String> generate(String s){\\n        Set<String> hset=new HashSet<String>();\\n        int l=s.length();\\n        char c[]=s.toCharArray();\\n    \\n        //0XXXXX0 is Invalid unless a single zero.\\n        if(c[0]==\\'0\\' && c[l-1]==\\'0\\'){\\n            if(l==1){\\n                hset.add(\"0\");\\n            }\\n            return hset;\\n        }\\n        \\n        //0XXXX can be split like this 0.XXXX\\n        if(c[0]==\\'0\\'){\\n            hset.add(\"0.\"+s.substring(1));\\n            return hset;\\n        }\\n        \\n        //XXXX0 cannot be split\\n        if(c[l-1]==\\'0\\'){\\n            hset.add(s);\\n            return hset;\\n        }\\n        \\n        //Generating Substring for every case. XXXX => X.XXX, XX.XX, XXX.X \\n        for(int i=1; i<l; i++){\\n            hset.add(s.substring(0,i)+\".\"+s.substring(i));\\n        }\\n        hset.add(s);\\n        return hset;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1206631,
                "title": "c-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<string> ambiguousCoordinates(string s) {\\n\\t\\t\\t//delete the \"()\"\\n\\t\\t\\tstring ori=s.substr(1,s.length()-2);\\n\\n\\t\\t\\t//the result variable vector\\n\\t\\t\\tvector<string>result;\\n\\n\\t\\t\\tfunction <void(vector<string>&, const string&)> helper=[&](vector<string>& ans, const string &s){\\n\\t\\t\\t\\t//if the string only has one char then push it into the vector (special case)\\n\\t\\t\\t\\tif(s.length()==1){\\n\\t\\t\\t\\t\\tans.push_back(s);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t//Find the the apparence of the 0 at the begining and end of the string:\\n\\t\\t\\t\\t//Considering the following cases:\\n\\t\\t\\t\\t//1) the begining and the end of the string does not contain any \"0\": meaning that you can put any \".\" inside the string; (ex: 23140432)\\n\\t\\t\\t\\t//2) the begining and the end of the string both have \"0\" meaing it cannot be used;(ex. 027600)\\n\\t\\t\\t\\t//3) the begining of the string has the \"0\": only 0.28510009659 one situation (ex. 000278)\\n\\t\\t\\t\\t//4) the end of the string has \"0\": only the entire string can be used (ex. 234000)\\n\\t\\t\\t\\tint startZero=s.find_first_not_of(\\'0\\');\\n\\t\\t\\t\\tint endZero=s.find_last_not_of(\\'0\\');\\n\\n\\t\\t\\t\\tif(startZero==0 && endZero==s.length()-1){            \\n\\t\\t\\t\\t\\tfor(int i=1;i<s.length();++i){\\n\\t\\t\\t\\t\\t\\tans.push_back(s.substr(0,i)+\".\"+s.substr(i));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tans.push_back(s);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(startZero==0 && endZero!=s.length()-1){\\n\\t\\t\\t\\t\\tans.push_back(s);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(startZero!=0 && endZero==s.length()-1){\\n\\t\\t\\t\\t\\tans.push_back(s.substr(0,1)+\".\"+s.substr(1));\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn;               \\n\\t\\t\\t};\\n\\n\\n\\n\\t\\t\\t//Go through every point (put \",\") of the string\\n\\t\\t\\tfor(int i=1;i<ori.length();++i){\\n\\t\\t\\t\\tstring firstHalf=ori.substr(0,i);\\n\\t\\t\\t\\tstring secondHalf=ori.substr(i);\\n\\n\\t\\t\\t\\tvector<string>first;\\n\\t\\t\\t\\tvector<string>second;\\n\\n\\t\\t\\t\\thelper(first,firstHalf);\\n\\t\\t\\t\\thelper(second,secondHalf);\\n\\n\\t\\t\\t\\tfor(int ii=0;ii<first.size();++ii){\\n\\t\\t\\t\\t\\tfor(int j=0;j<second.size();++j){\\n\\t\\t\\t\\t\\t\\tresult.emplace_back(\"(\"+first[ii]+\", \"+second[j]+\")\");\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\t\\t}  \\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<string> ambiguousCoordinates(string s) {\\n\\t\\t\\t//delete the \"()\"\\n\\t\\t\\tstring ori=s.substr(1,s.length()-2);\\n\\n\\t\\t\\t//the result variable vector\\n\\t\\t\\tvector<string>result;\\n\\n\\t\\t\\tfunction <void(vector<string>&, const string&)> helper=[&](vector<string>& ans, const string &s){\\n\\t\\t\\t\\t//if the string only has one char then push it into the vector (special case)\\n\\t\\t\\t\\tif(s.length()==1){\\n\\t\\t\\t\\t\\tans.push_back(s);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1206625,
                "title": "java-100-beat-solution",
                "content": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> out = new ArrayList<>();\\n        String numstring = s.substring(1, s.length() - 1);\\n        for (int div = 1; div < numstring.length(); div++) {\\n            String l = numstring.substring(0, div);\\n            String r = numstring.substring(div);\\n            List<String> leftNums = generate(l), rightNums = generate(r);\\n            combine(out, leftNums, rightNums);\\n        }\\n        return out;\\n    }\\n    \\n    private void combine(List<String> out, List<String> left, List<String> right) {\\n        for (String l: left) {\\n            for (String r: right) {\\n                StringBuilder sb = new StringBuilder();\\n                sb.append(\\'(\\').append(l).append(\", \").append(r).append(\\')\\');\\n                out.add(sb.toString());\\n            }\\n        }\\n    }\\n    \\n    private List<String> generate(String s) {\\n        List<String> out = new ArrayList<>();\\n        if (isValidInteger(s)) out.add(s);\\n        for (int i = 1; i < s.length(); i++) {\\n            if (isValidFloat(s, i)) {\\n                StringBuilder sb = new StringBuilder();\\n                sb.append(s.substring(0, i)).append(\\'.\\').append(s.substring(i));\\n                out.add(sb.toString());\\n            }\\n        }\\n        return out;\\n    }\\n    \\n    private boolean isValidInteger(String s) {\\n        return s.length() == 1 || s.charAt(0) != \\'0\\';\\n    }\\n    \\n    private boolean isValidFloat(String s, int floatPos) {\\n        boolean digitPortionValid = true;\\n        if (floatPos >= 2 && s.charAt(0) == \\'0\\') digitPortionValid = false;\\n        \\n        return digitPortionValid && s.charAt(s.length() - 1) != \\'0\\';\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> out = new ArrayList<>();\\n        String numstring = s.substring(1, s.length() - 1);\\n        for (int div = 1; div < numstring.length(); div++) {\\n            String l = numstring.substring(0, div);\\n            String r = numstring.substring(div);\\n            List<String> leftNums = generate(l), rightNums = generate(r);\\n            combine(out, leftNums, rightNums);\\n        }\\n        return out;\\n    }\\n    \\n    private void combine(List<String> out, List<String> left, List<String> right) {\\n        for (String l: left) {\\n            for (String r: right) {\\n                StringBuilder sb = new StringBuilder();\\n                sb.append(\\'(\\').append(l).append(\", \").append(r).append(\\')\\');\\n                out.add(sb.toString());\\n            }\\n        }\\n    }\\n    \\n    private List<String> generate(String s) {\\n        List<String> out = new ArrayList<>();\\n        if (isValidInteger(s)) out.add(s);\\n        for (int i = 1; i < s.length(); i++) {\\n            if (isValidFloat(s, i)) {\\n                StringBuilder sb = new StringBuilder();\\n                sb.append(s.substring(0, i)).append(\\'.\\').append(s.substring(i));\\n                out.add(sb.toString());\\n            }\\n        }\\n        return out;\\n    }\\n    \\n    private boolean isValidInteger(String s) {\\n        return s.length() == 1 || s.charAt(0) != \\'0\\';\\n    }\\n    \\n    private boolean isValidFloat(String s, int floatPos) {\\n        boolean digitPortionValid = true;\\n        if (floatPos >= 2 && s.charAt(0) == \\'0\\') digitPortionValid = false;\\n        \\n        return digitPortionValid && s.charAt(s.length() - 1) != \\'0\\';\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206621,
                "title": "c-816-ambiguous-coordinates",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n                \\n        auto fn = [](string&& s) {\\n            vector<string> ans; \\n            if (s.size() == 1) \\n                ans.push_back(s); \\n            else if (s.front() == \\'0\\' and s.back() == \\'0\\') ; \\n            else if (s.front() == \\'0\\') \\n                ans.push_back(\"0.\" + s.substr(1)); \\n            else if (s.back() == \\'0\\') \\n                ans.push_back(s); \\n            else {\\n                for (int i = 1; i < s.size(); ++i)\\n                    ans.push_back(s.substr(0, i) + \".\" + s.substr(i)); \\n                ans.push_back(s); \\n            }\\n            return ans;\\n        };\\n        \\n        vector<string> ans; \\n        for (int i = 2; i < s.size()-1; ++i) \\n            for (auto& x : fn(s.substr(1, i-1))) \\n                for (auto& y : fn(s.substr(i, s.size()-1-i))) \\n                    ans.push_back(\"(\" + x + \", \" + y + \")\"); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n                \\n        auto fn = [](string&& s) {\\n            vector<string> ans; \\n            if (s.size() == 1) \\n                ans.push_back(s); \\n            else if (s.front() == \\'0\\' and s.back() == \\'0\\') ; \\n            else if (s.front() == \\'0\\') \\n                ans.push_back(\"0.\" + s.substr(1)); \\n            else if (s.back() == \\'0\\') \\n                ans.push_back(s); \\n            else {\\n                for (int i = 1; i < s.size(); ++i)\\n                    ans.push_back(s.substr(0, i) + \".\" + s.substr(i)); \\n                ans.push_back(s); \\n            }\\n            return ans;\\n        };\\n        \\n        vector<string> ans; \\n        for (int i = 2; i < s.size()-1; ++i) \\n            for (auto& x : fn(s.substr(1, i-1))) \\n                for (auto& y : fn(s.substr(i, s.size()-1-i))) \\n                    ans.push_back(\"(\" + x + \", \" + y + \")\"); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206570,
                "title": "c-solution-and-explanation-in-detail-simple-and-clean",
                "content": "https://ccodingclub.blogspot.com/2021/05/ambiguous-coordinates.html\\n\\nsolution explained in detail in c++\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "https://ccodingclub.blogspot.com/2021/05/ambiguous-coordinates.html\\n\\nsolution explained in detail in c++\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)",
                "codeTag": "Unknown"
            },
            {
                "id": 1206567,
                "title": "traversal-the-string-with-explanation",
                "content": "Check the explanation embeded, just a straight forward solution :\\n\\n```\\nclass Solution {\\n    // if 0 is at the beginning, cannot have more than 1 zero\\n    // if 0 is at the end, should not contains dot\\n    \\n    private static String STR_COMMA_AND_SPACE = \", \";\\n    private static String STR_DOT = \".\";\\n    private static String STR_ZERO = \"0\";\\n    private static String STR_LEFT_BRACKET = \"(\";\\n    private static String STR_RIGHT_BRACKET = \")\";\\n    private static char CHAR_ZERO = \\'0\\';\\n    \\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> ret = new ArrayList<>();\\n        int len = s.length();\\n        \\n        //we need to skip the \\'(\\' and \\')\\'\\n        for (int i = 2; i < len - 1; i++) {\\n            checkSubString(s.substring(1, i), s.substring(i, len - 1), ret);\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    private void checkSubString(String s1, String s2, List<String> ret) {\\n        int len1 = s1.length();\\n        int len2 = s2.length();\\n        \\n        // base case check\\n        if (len1 == 0 || len2 == 0) {\\n            return;\\n        }\\n        \\n        //if string start with 0 and end with 0, just skip it (except the \"0\" itself)\\n        if ((s1.startsWith(STR_ZERO)  && s1.endsWith(STR_ZERO) && !s1.equals(STR_ZERO)) \\n            || (s2.startsWith(STR_ZERO) && s2.endsWith(STR_ZERO) && !s2.equals(STR_ZERO))) {\\n            return;\\n        } \\n        \\n        List<String> list1 = getValidSubString(s1);\\n        List<String> list2 = getValidSubString(s2);\\n\\n        //compose the new string list\\n        for (String l1 : list1) {\\n            for (String l2 : list2) {\\n                ret.add(STR_LEFT_BRACKET + l1 + STR_COMMA_AND_SPACE + l2 + STR_RIGHT_BRACKET);\\n            }\\n        }\\n    }\\n    \\n    private List<String> getValidSubString(String s) {\\n        List<String> ret = new ArrayList<>();\\n        int len = s.length();\\n        \\n        // check if the string s is a valid one or not\\n        if (s.equals(STR_ZERO) || !s.startsWith(STR_ZERO)) {\\n            ret.add(s);\\n        }\\n        \\n        for (int i = 1; i < len; i++) {\\n            String s1 = s.substring(0, i);\\n            String s2 = s.substring(i);\\n            \\n            // fraction part and not end with 0\\n            // integer part cannot start with zero unless it\\'s zero\\n            if ((s1.equals(STR_ZERO) || !s1.startsWith(STR_ZERO)) && !s2.endsWith(STR_ZERO)) {\\n                ret.add(s1 + STR_DOT + s2);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // if 0 is at the beginning, cannot have more than 1 zero\\n    // if 0 is at the end, should not contains dot\\n    \\n    private static String STR_COMMA_AND_SPACE = \", \";\\n    private static String STR_DOT = \".\";\\n    private static String STR_ZERO = \"0\";\\n    private static String STR_LEFT_BRACKET = \"(\";\\n    private static String STR_RIGHT_BRACKET = \")\";\\n    private static char CHAR_ZERO = \\'0\\';\\n    \\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> ret = new ArrayList<>();\\n        int len = s.length();\\n        \\n        //we need to skip the \\'(\\' and \\')\\'\\n        for (int i = 2; i < len - 1; i++) {\\n            checkSubString(s.substring(1, i), s.substring(i, len - 1), ret);\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    private void checkSubString(String s1, String s2, List<String> ret) {\\n        int len1 = s1.length();\\n        int len2 = s2.length();\\n        \\n        // base case check\\n        if (len1 == 0 || len2 == 0) {\\n            return;\\n        }\\n        \\n        //if string start with 0 and end with 0, just skip it (except the \"0\" itself)\\n        if ((s1.startsWith(STR_ZERO)  && s1.endsWith(STR_ZERO) && !s1.equals(STR_ZERO)) \\n            || (s2.startsWith(STR_ZERO) && s2.endsWith(STR_ZERO) && !s2.equals(STR_ZERO))) {\\n            return;\\n        } \\n        \\n        List<String> list1 = getValidSubString(s1);\\n        List<String> list2 = getValidSubString(s2);\\n\\n        //compose the new string list\\n        for (String l1 : list1) {\\n            for (String l2 : list2) {\\n                ret.add(STR_LEFT_BRACKET + l1 + STR_COMMA_AND_SPACE + l2 + STR_RIGHT_BRACKET);\\n            }\\n        }\\n    }\\n    \\n    private List<String> getValidSubString(String s) {\\n        List<String> ret = new ArrayList<>();\\n        int len = s.length();\\n        \\n        // check if the string s is a valid one or not\\n        if (s.equals(STR_ZERO) || !s.startsWith(STR_ZERO)) {\\n            ret.add(s);\\n        }\\n        \\n        for (int i = 1; i < len; i++) {\\n            String s1 = s.substring(0, i);\\n            String s2 = s.substring(i);\\n            \\n            // fraction part and not end with 0\\n            // integer part cannot start with zero unless it\\'s zero\\n            if ((s1.equals(STR_ZERO) || !s1.startsWith(STR_ZERO)) && !s2.endsWith(STR_ZERO)) {\\n                ret.add(s1 + STR_DOT + s2);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206539,
                "title": "c-enumeration-with-all-possible-combination",
                "content": "Approach 1: enumeration with all possible combination [1]\\nWe can split S to two parts for two coordinates.\\nThen we use sub function f to find all possible strings for each coordinate.\\n\\nIn sub functon f(S)\\nif S == \"\": return []\\nif S == \"0\": return [S]\\nif S == \"0XXX0\": return []\\nif S == \"0XXX\": return [\"0.XXX\"]\\nif S == \"XXX0\": return [S]\\nreturn [S, \"X.XXX\", \"XX.XX\", \"XXX.X\"...]\\n\\nThen we add the product of two lists to result.\\n\\nTime complexity\\nO(N^3) with N <= 10\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string S) {\\n        int n = S.size();\\n        vector<string> res;\\n        for (int i = 1; i < n - 2; ++i) {\\n            vector<string> A = f(S.substr(1, i)), B = f(S.substr(i + 1, n - 2 - i));\\n            for (auto & a : A) for (auto & b : B) res.push_back(\"(\" + a + \", \" + b + \")\");\\n        }\\n        return res;\\n    }\\n    vector<string> f(string S) {\\n        int n = S.size();\\n\\t\\t//case 2: other/corner cases\\n        if (n == 0 || (n > 1 && S[0] == \\'0\\' && S[n - 1] == \\'0\\')) return {}; // this is a trick\\n        if (n > 1 && S[0] == \\'0\\') return {\"0.\" + S.substr(1)};\\n        if (n == 1 || S[n - 1] == \\'0\\') return {S};\\n        vector<string> res = {S};\\n        for (int i = 1; i < n; ++i) res.push_back(S.substr(0, i) + \\'.\\' + S.substr(i)); // case 1: normal case\\n        return res;\\n    }\\n};\\n```\\nReference:\\n[1] https://leetcode.com/problems/ambiguous-coordinates/discuss/123851/C%2B%2BJavaPython-Solution-with-Explanation",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string S) {\\n        int n = S.size();\\n        vector<string> res;\\n        for (int i = 1; i < n - 2; ++i) {\\n            vector<string> A = f(S.substr(1, i)), B = f(S.substr(i + 1, n - 2 - i));\\n            for (auto & a : A) for (auto & b : B) res.push_back(\"(\" + a + \", \" + b + \")\");\\n        }\\n        return res;\\n    }\\n    vector<string> f(string S) {\\n        int n = S.size();\\n\\t\\t//case 2: other/corner cases\\n        if (n == 0 || (n > 1 && S[0] == \\'0\\' && S[n - 1] == \\'0\\')) return {}; // this is a trick\\n        if (n > 1 && S[0] == \\'0\\') return {\"0.\" + S.substr(1)};\\n        if (n == 1 || S[n - 1] == \\'0\\') return {S};\\n        vector<string> res = {S};\\n        for (int i = 1; i < n; ++i) res.push_back(S.substr(0, i) + \\'.\\' + S.substr(i)); // case 1: normal case\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206499,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn ambiguous_coordinates(s: String) -> Vec<String> {\\n        let s = s.chars().skip(1).take(s.len() - 2).collect::<Vec<_>>();\\n        let candidates = |v: &[char]| -> Vec<String> {\\n            (0..v.len())\\n                .filter_map(|i| {\\n                    let s: String = if i == 0 {\\n                        v.iter().collect()\\n                    } else {\\n                        v[..i]\\n                            .iter()\\n                            .chain(std::iter::once(&\\'.\\'))\\n                            .chain(v[i..].iter())\\n                            .collect()\\n                    };\\n                    if (s != \"0\" && s.starts_with(\\'0\\') && !s.starts_with(\"0.\"))\\n                        || (s.contains(\\'.\\') && s.ends_with(\\'0\\'))\\n                    {\\n                        None\\n                    } else {\\n                        Some(s)\\n                    }\\n                })\\n                .collect()\\n        };\\n        let mut answer = Vec::new();\\n        for i in 1..s.len() {\\n            for x in &candidates(&s[..i]) {\\n                for y in &candidates(&s[i..]) {\\n                    answer.push(format!(\"({}, {})\", x, y));\\n                }\\n            }\\n        }\\n        answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn ambiguous_coordinates(s: String) -> Vec<String> {\\n        let s = s.chars().skip(1).take(s.len() - 2).collect::<Vec<_>>();\\n        let candidates = |v: &[char]| -> Vec<String> {\\n            (0..v.len())\\n                .filter_map(|i| {\\n                    let s: String = if i == 0 {\\n                        v.iter().collect()\\n                    } else {\\n                        v[..i]\\n                            .iter()\\n                            .chain(std::iter::once(&\\'.\\'))\\n                            .chain(v[i..].iter())\\n                            .collect()\\n                    };\\n                    if (s != \"0\" && s.starts_with(\\'0\\') && !s.starts_with(\"0.\"))\\n                        || (s.contains(\\'.\\') && s.ends_with(\\'0\\'))\\n                    {\\n                        None\\n                    } else {\\n                        Some(s)\\n                    }\\n                })\\n                .collect()\\n        };\\n        let mut answer = Vec::new();\\n        for i in 1..s.len() {\\n            for x in &candidates(&s[..i]) {\\n                for y in &candidates(&s[i..]) {\\n                    answer.push(format!(\"({}, {})\", x, y));\\n                }\\n            }\\n        }\\n        answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1206489,
                "title": "scala-solution",
                "content": "```\\nimport scala.collection.mutable.ListBuffer\\nobject Solution {\\n    def ambiguousCoordinates(s: String): List[String] = {\\n        var n = s.length();\\n        var res = new ListBuffer[String]();\\n        (2 until n-1).foreach(i=> \\n            for(left <- genNumber(s.substring(1,i))){\\n                for(right <- genNumber(s.substring(i,n-1))){\\n                    res+=\"(\" + left + \", \" + right + \")\"\\n                }\\n            }                               \\n        )\\n        res.toList\\n    }\\n    \\n    def genNumber(s:String):List[String] = {\\n        var res = new ListBuffer[String]();\\n        var n = s.length();\\n        if(n==1||s(0)!=\\'0\\') res+=s;\\n        if(n>1&&s(n-1)!=\\'0\\'){\\n            if(s(0)==\\'0\\'){\\n                res+= s(0)+\".\"+s.substring(1,n);\\n            }else{\\n                (1 until n).foreach{i=>\\n                    res+=s.substring(0,i)+\".\"+s.substring(i,n);\\n                }\\n            }\\n        }\\n        res.toList\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport scala.collection.mutable.ListBuffer\\nobject Solution {\\n    def ambiguousCoordinates(s: String): List[String] = {\\n        var n = s.length();\\n        var res = new ListBuffer[String]();\\n        (2 until n-1).foreach(i=> \\n            for(left <- genNumber(s.substring(1,i))){\\n                for(right <- genNumber(s.substring(i,n-1))){\\n                    res+=\"(\" + left + \", \" + right + \")\"\\n                }\\n            }                               \\n        )\\n        res.toList\\n    }\\n    \\n    def genNumber(s:String):List[String] = {\\n        var res = new ListBuffer[String]();\\n        var n = s.length();\\n        if(n==1||s(0)!=\\'0\\') res+=s;\\n        if(n>1&&s(n-1)!=\\'0\\'){\\n            if(s(0)==\\'0\\'){\\n                res+= s(0)+\".\"+s.substring(1,n);\\n            }else{\\n                (1 until n).foreach{i=>\\n                    res+=s.substring(0,i)+\".\"+s.substring(i,n);\\n                }\\n            }\\n        }\\n        res.toList\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1206470,
                "title": "c-o-n-3-soln",
                "content": "```\\npublic class Solution {\\n    // Time = Space = O(n^3)\\n    public IList<string> AmbiguousCoordinates(string s) {\\n        List<string> validPair = new List<string>();\\n        for (int i = 2; i < s.Length - 1; i++)\\n            foreach (var first in Make(1, i))\\n                foreach (var second in Make(i, s.Length - 1))\\n                    validPair.Add(\"(\" + first + \", \" + second + \")\");\\n        return validPair;\\n        // local helper func\\n        IList<string> Make(int l, int r)\\n        {\\n            List<string> coordinates = new List<string>();\\n            string left, right;\\n            // Make valid coordinate from s.Substring(l, r)\\n            for (int d = 1; d <= r - l; d++)\\n            {\\n                left = s.Substring(l, d);\\n                right = s.Substring(l + d, r - (l + d));\\n                // left part doesnt start with \\'0\\' or if it than that the only digit && right doesnt ends with \\'0\\'\\n                if ((left[0] != \\'0\\' || left.Length == 1) && !right.EndsWith(\"0\"))\\n\\t\\t\\t\\t\\t// add dot operator if distance is less than total no of chars we have to play with\\n                    coordinates.Add(left + (d < r - l ? \".\" : \"\") + right);\\n            }\\n            return coordinates;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // Time = Space = O(n^3)\\n    public IList<string> AmbiguousCoordinates(string s) {\\n        List<string> validPair = new List<string>();\\n        for (int i = 2; i < s.Length - 1; i++)\\n            foreach (var first in Make(1, i))\\n                foreach (var second in Make(i, s.Length - 1))\\n                    validPair.Add(\"(\" + first + \", \" + second + \")\");\\n        return validPair;\\n        // local helper func\\n        IList<string> Make(int l, int r)\\n        {\\n            List<string> coordinates = new List<string>();\\n            string left, right;\\n            // Make valid coordinate from s.Substring(l, r)\\n            for (int d = 1; d <= r - l; d++)\\n            {\\n                left = s.Substring(l, d);\\n                right = s.Substring(l + d, r - (l + d));\\n                // left part doesnt start with \\'0\\' or if it than that the only digit && right doesnt ends with \\'0\\'\\n                if ((left[0] != \\'0\\' || left.Length == 1) && !right.EndsWith(\"0\"))\\n\\t\\t\\t\\t\\t// add dot operator if distance is less than total no of chars we have to play with\\n                    coordinates.Add(left + (d < r - l ? \".\" : \"\") + right);\\n            }\\n            return coordinates;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206468,
                "title": "ambiguous-coordinates",
                "content": "class Solution { \\n    public List<String> ambiguousCoordinates(String S) {\\n        List<String> ans = new ArrayList();\\n        for (int i = 2; i < S.length()-1; ++i)\\n            for (String left: make(S, 1, i))\\n                for (String right: make(S, i, S.length()-1))\\n                    ans.add(\"(\" + left + \", \" + right + \")\");\\n        return ans;\\n    }\\n\\n    public List<String> make(String S, int i, int j) {\\n        // Make on S.substring(i, j)\\n        List<String> ans = new ArrayList();\\n        for (int d = 1; d <= j-i; ++d) {\\n            String left = S.substring(i, i+d);\\n            String right = S.substring(i+d, j);\\n            if ((!left.startsWith(\"0\") || left.equals(\"0\"))\\n                    && !right.endsWith(\"0\"))\\n                ans.add(left + (d < j-i ? \".\" : \"\") + right);\\n        }\\n        return ans;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution { \\n    public List<String> ambiguousCoordinates(String S) {\\n        List<String> ans = new ArrayList();\\n        for (int i = 2; i < S.length()-1; ++i)\\n            for (String left: make(S, 1, i))\\n                for (String right: make(S, i, S.length()-1))\\n                    ans.add(\"(\" + left + \", \" + right + \")\");\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1206378,
                "title": "c-simple-tc-o-n-3",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string st){\\n        if(st.length() > 1 && st[0] == \\'0\\'){\\n            return false;\\n        }\\n        return st.length() > 0;\\n    }\\n    \\n    bool isValidDecimal(string st){\\n        if(st.length() > 0 && st[st.length()-1] == \\'0\\'){\\n            return false;\\n        }\\n        return st.length() > 0;\\n    }\\n\\n    vector<string> comma(string s){\\n        vector<string> commaS;\\n        int size = s.length();\\n        string st = \"\";\\n        for(int i = 0;i < size; ++i){\\n            string a = s.substr(0, i+1);\\n            string b = s.substr(i+1);\\n            if(isValid(a) && isValid(b)){\\n                commaS.push_back(a + \", \" + b);\\n            }\\n        }\\n        return commaS;\\n    }\\n    vector<string> decimal(string s){\\n        vector<string> decimalSep;\\n        int size = s.length();\\n        string st = \"\";\\n        for(int i = 0; i < size; ++i){\\n            string a = s.substr(0, i+1);\\n            string b = s.substr(i+1);\\n            for(int j = 0, m = a.size();j < m; ++j){\\n                string c = a.substr(0, j+1);\\n                string d = a.substr(j+1);\\n                if(isValid(c) && isValidDecimal(d)  && isValid(b)){\\n                    decimalSep.push_back(c + \".\" + d + \", \" + b);\\n                }\\n            }\\n            for(int j = 0, m = b.size();j < m; ++j){\\n                string c = b.substr(0, j+1);\\n                string d = b.substr(j+1);\\n                if(isValid(c) && isValidDecimal(d) && isValid(a)){\\n                    decimalSep.push_back(a +  \", \" + c + \".\" + d);\\n                }\\n            }\\n            for(int j = 0, m = a.size();j < m; ++j){\\n                string c = a.substr(0, j+1);\\n                string d = a.substr(j+1);\\n                if(isValid(c) && isValidDecimal(d)){\\n                    for(int k = 0, n = b.size(); k < n; ++k){\\n                        string e = b.substr(0, k+1);\\n                        string f = b.substr(k+1);\\n                        if(isValid(e) && isValidDecimal(f)){\\n                            decimalSep.push_back(c + \".\" + d + \", \" + e + \".\" + f);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return decimalSep;\\n    }\\n    \\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        string new_s = \"\";\\n        for(char a : s){\\n            if(a!=\\')\\' && a!=\\'(\\'){\\n                new_s += a;\\n            }\\n        }\\n        \\n        int n = new_s.length();\\n        \\n        vector<string> commaSeparated = comma(new_s);\\n        vector<string> decimalSeparated = decimal(new_s);\\n        vector<string> sol;\\n        for(string a : commaSeparated){\\n            sol.push_back(\"(\" + a + \")\");\\n        }\\n        for(string b: decimalSeparated){\\n            sol.push_back(\"(\" + b + \")\");\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string st){\\n        if(st.length() > 1 && st[0] == \\'0\\'){\\n            return false;\\n        }\\n        return st.length() > 0;\\n    }\\n    \\n    bool isValidDecimal(string st){\\n        if(st.length() > 0 && st[st.length()-1] == \\'0\\'){\\n            return false;\\n        }\\n        return st.length() > 0;\\n    }\\n\\n    vector<string> comma(string s){\\n        vector<string> commaS;\\n        int size = s.length();\\n        string st = \"\";\\n        for(int i = 0;i < size; ++i){\\n            string a = s.substr(0, i+1);\\n            string b = s.substr(i+1);\\n            if(isValid(a) && isValid(b)){\\n                commaS.push_back(a + \", \" + b);\\n            }\\n        }\\n        return commaS;\\n    }\\n    vector<string> decimal(string s){\\n        vector<string> decimalSep;\\n        int size = s.length();\\n        string st = \"\";\\n        for(int i = 0; i < size; ++i){\\n            string a = s.substr(0, i+1);\\n            string b = s.substr(i+1);\\n            for(int j = 0, m = a.size();j < m; ++j){\\n                string c = a.substr(0, j+1);\\n                string d = a.substr(j+1);\\n                if(isValid(c) && isValidDecimal(d)  && isValid(b)){\\n                    decimalSep.push_back(c + \".\" + d + \", \" + b);\\n                }\\n            }\\n            for(int j = 0, m = b.size();j < m; ++j){\\n                string c = b.substr(0, j+1);\\n                string d = b.substr(j+1);\\n                if(isValid(c) && isValidDecimal(d) && isValid(a)){\\n                    decimalSep.push_back(a +  \", \" + c + \".\" + d);\\n                }\\n            }\\n            for(int j = 0, m = a.size();j < m; ++j){\\n                string c = a.substr(0, j+1);\\n                string d = a.substr(j+1);\\n                if(isValid(c) && isValidDecimal(d)){\\n                    for(int k = 0, n = b.size(); k < n; ++k){\\n                        string e = b.substr(0, k+1);\\n                        string f = b.substr(k+1);\\n                        if(isValid(e) && isValidDecimal(f)){\\n                            decimalSep.push_back(c + \".\" + d + \", \" + e + \".\" + f);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return decimalSep;\\n    }\\n    \\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        string new_s = \"\";\\n        for(char a : s){\\n            if(a!=\\')\\' && a!=\\'(\\'){\\n                new_s += a;\\n            }\\n        }\\n        \\n        int n = new_s.length();\\n        \\n        vector<string> commaSeparated = comma(new_s);\\n        vector<string> decimalSeparated = decimal(new_s);\\n        vector<string> sol;\\n        for(string a : commaSeparated){\\n            sol.push_back(\"(\" + a + \")\");\\n        }\\n        for(string b: decimalSeparated){\\n            sol.push_back(\"(\" + b + \")\");\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206352,
                "title": "python-generate-all-and-validate",
                "content": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        def invalid(s):\\n            if \\'.\\' in s:\\n                if s[-1] == \\'0\\':\\n                    return True\\n                # verify the integer part\\n                return invalid(s.split(\\'.\\')[0])\\n            else:\\n                return len(s) > 1 and s[0] == \\'0\\'\\n\\n        def get_combination(s, is_root):\\n            res = []\\n            if is_root:\\n                # add comma\\n                for i in range(1, len(s)):\\n                    first_half_com = get_combination(s[:i], False)\\n                    second_half_com = get_combination(s[i:], False)\\n                    \\n                    for first_half in first_half_com:\\n                        for second_half in second_half_com:\\n                            if invalid(first_half) or invalid(second_half): continue\\n                            res.append(f\"({first_half}, {second_half})\")\\n            else:\\n                # no dot\\n                res.append(s)\\n                # with dot\\n                for i in range(1, len(s)):\\n                    res.append(f\"{s[:i]}.{s[i:]}\")\\n            return res\\n        \\n        s = s[1:-1]\\n        return get_combination(s, True)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        def invalid(s):\\n            if \\'.\\' in s:\\n                if s[-1] == \\'0\\':\\n                    return True\\n                # verify the integer part\\n                return invalid(s.split(\\'.\\')[0])\\n            else:\\n                return len(s) > 1 and s[0] == \\'0\\'\\n\\n        def get_combination(s, is_root):\\n            res = []\\n            if is_root:\\n                # add comma\\n                for i in range(1, len(s)):\\n                    first_half_com = get_combination(s[:i], False)\\n                    second_half_com = get_combination(s[i:], False)\\n                    \\n                    for first_half in first_half_com:\\n                        for second_half in second_half_com:\\n                            if invalid(first_half) or invalid(second_half): continue\\n                            res.append(f\"({first_half}, {second_half})\")\\n            else:\\n                # no dot\\n                res.append(s)\\n                # with dot\\n                for i in range(1, len(s)):\\n                    res.append(f\"{s[:i]}.{s[i:]}\")\\n            return res\\n        \\n        s = s[1:-1]\\n        return get_combination(s, True)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206333,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n\\nInspired by [this](https://leetcode.com/problems/ambiguous-coordinates/discuss/123875/Really-clear-Java-code) solution\\n```\\nfunc ambiguousCoordinates(s string) []string {\\n\\tvar res []string\\n\\ts = s[1:len(s)-1]\\n\\tfor i := 1; i < len(s); i++ {\\n\\t\\tleft, right := valid(s[0:i]), valid(s[i:])\\n\\t\\tfor _, l:= range left {\\n\\t\\t\\tfor _, r := range right {\\n\\t\\t\\t\\tres = append(res, \"(\" + l + \", \" + r + \")\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn res\\n}\\n\\nfunc valid(s string) []string {\\n\\tn := len(s)\\n\\tvar res []string\\n\\tif s[0] == \\'0\\' && s[n-1] == \\'0\\' {\\n\\t\\tif n == 1 {\\n\\t\\t\\tres = append(res, \"0\")\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\t\\n\\tif s[0] == \\'0\\' {\\n\\t\\tres = append(res, \"0.\"+s[1:])\\n\\t\\treturn res\\n\\t}\\n\\tif s[n-1] == \\'0\\' {\\n\\t\\tres = append(res, s)\\n\\t\\treturn res\\n\\t}\\n\\tres = append(res, s)\\n\\tfor i:= 1; i < n; i++ {\\n\\t\\tres = append(res, s[0:i] + \".\" + s[i:])\\n\\t}\\n\\t\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc ambiguousCoordinates(s string) []string {\\n\\tvar res []string\\n\\ts = s[1:len(s)-1]\\n\\tfor i := 1; i < len(s); i++ {\\n\\t\\tleft, right := valid(s[0:i]), valid(s[i:])\\n\\t\\tfor _, l:= range left {\\n\\t\\t\\tfor _, r := range right {\\n\\t\\t\\t\\tres = append(res, \"(\" + l + \", \" + r + \")\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn res\\n}\\n\\nfunc valid(s string) []string {\\n\\tn := len(s)\\n\\tvar res []string\\n\\tif s[0] == \\'0\\' && s[n-1] == \\'0\\' {\\n\\t\\tif n == 1 {\\n\\t\\t\\tres = append(res, \"0\")\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\t\\n\\tif s[0] == \\'0\\' {\\n\\t\\tres = append(res, \"0.\"+s[1:])\\n\\t\\treturn res\\n\\t}\\n\\tif s[n-1] == \\'0\\' {\\n\\t\\tres = append(res, s)\\n\\t\\treturn res\\n\\t}\\n\\tres = append(res, s)\\n\\tfor i:= 1; i < n; i++ {\\n\\t\\tres = append(res, s[0:i] + \".\" + s[i:])\\n\\t}\\n\\t\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1206325,
                "title": "java-clean-concise-optimal-code-3ms-time-100-beats-java-solution",
                "content": "```\\nclass Solution {\\n    \\n    public List<String> helper (String s) {\\n        \\n        List<String> answer = new ArrayList<> ();\\n        \\n        if (s.length () == 1) {\\n            answer.add (s);\\n            return answer;\\n        }\\n        else if (s.charAt (0) == \\'0\\' && s.charAt (s.length () - 1) == \\'0\\') {\\n            return answer;\\n        }\\n        else if (s.charAt (0) == \\'0\\') {\\n            StringBuilder sb = new StringBuilder ();\\n            sb.append (s.charAt (0)).append (\".\").append (s.substring (1));\\n            answer.add (sb.toString ());\\n            return answer;\\n        }\\n        else if (s.charAt (s.length () - 1) == \\'0\\') {\\n            answer.add (s);\\n            return answer;\\n        }\\n        \\n        answer.add (s);\\n        \\n        for (int i = 1; i < s.length (); i++) {\\n            StringBuilder sb = new StringBuilder ();\\n            sb.append (s.substring (0, i)).append (\".\").append (s.substring (i));\\n            answer.add (sb.toString ());\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        List<String> answer = new ArrayList<> ();\\n        \\n        for (int i = 2; i < s.length () - 1; i++) {\\n            List<String> leftLists = helper (s.substring (1, i));\\n            List<String> rightLists = helper (s.substring (i, s.length () - 1));\\n            \\n            for (String leftString : leftLists) {\\n                for (String rightString : rightLists) {\\n                    StringBuilder sb = new StringBuilder ();\\n                    sb.append (\"(\").append (leftString).append (\", \").append (rightString).append (\")\");\\n                    answer.add (sb.toString ());\\n                }\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<String> helper (String s) {\\n        \\n        List<String> answer = new ArrayList<> ();\\n        \\n        if (s.length () == 1) {\\n            answer.add (s);\\n            return answer;\\n        }\\n        else if (s.charAt (0) == \\'0\\' && s.charAt (s.length () - 1) == \\'0\\') {\\n            return answer;\\n        }\\n        else if (s.charAt (0) == \\'0\\') {\\n            StringBuilder sb = new StringBuilder ();\\n            sb.append (s.charAt (0)).append (\".\").append (s.substring (1));\\n            answer.add (sb.toString ());\\n            return answer;\\n        }\\n        else if (s.charAt (s.length () - 1) == \\'0\\') {\\n            answer.add (s);\\n            return answer;\\n        }\\n        \\n        answer.add (s);\\n        \\n        for (int i = 1; i < s.length (); i++) {\\n            StringBuilder sb = new StringBuilder ();\\n            sb.append (s.substring (0, i)).append (\".\").append (s.substring (i));\\n            answer.add (sb.toString ());\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        List<String> answer = new ArrayList<> ();\\n        \\n        for (int i = 2; i < s.length () - 1; i++) {\\n            List<String> leftLists = helper (s.substring (1, i));\\n            List<String> rightLists = helper (s.substring (i, s.length () - 1));\\n            \\n            for (String leftString : leftLists) {\\n                for (String rightString : rightLists) {\\n                    StringBuilder sb = new StringBuilder ();\\n                    sb.append (\"(\").append (leftString).append (\", \").append (rightString).append (\")\");\\n                    answer.add (sb.toString ());\\n                }\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206323,
                "title": "swift-solution",
                "content": "```swift\\nclass Solution {\\n    func ambiguousCoordinates(_ s: String) -> [String] {\\n        var sArr = Array(s)\\n        sArr.removeLast()\\n        sArr.removeFirst()\\n        \\n        func gen(_ s: String) -> [String] {\\n\\n            let sArr = Array(s)\\n            if sArr.endIndex == 1 {return [s]}\\n            var res = [String]()\\n            next: for i in 1...sArr.endIndex {\\n                var left = String(sArr[0..<i])\\n                var right = String(sArr[i...])\\n                if right == \"\" {\\n                    let leftNum = Int(left)!\\n                    if Array(left)[0] == \"0\" {continue next}\\n                    res.append(String(left))\\n                } else {\\n                    let leftNum = Int(left)!, rightNum = Int(right)!\\n                    if leftNum == 0 && left.count > 1 {continue next}\\n                    if rightNum == 0 {continue next}\\n                    if Array(right)[right.count-1] == \"0\" {continue next}\\n                    if Array(left)[0] == \"0\" && leftNum > 0 {continue next}\\n                    \\n                    res.append(left+\".\"+right) \\n                }\\n\\n            }\\n            return res\\n        }\\n        var res = [String]()\\n        for i in 1..<sArr.endIndex {\\n            let w1 = String(sArr[0..<i])\\n            let w2 = String(sArr[i...])\\n            let w1list = gen(w1), w2list = gen(w2)\\n            for left in w1list {\\n                for right in w2list {\\n                    \\n                    res.append(\"(\\\\(left), \\\\(right))\")\\n                }\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func ambiguousCoordinates(_ s: String) -> [String] {\\n        var sArr = Array(s)\\n        sArr.removeLast()\\n        sArr.removeFirst()\\n        \\n        func gen(_ s: String) -> [String] {\\n\\n            let sArr = Array(s)\\n            if sArr.endIndex == 1 {return [s]}\\n            var res = [String]()\\n            next: for i in 1...sArr.endIndex {\\n                var left = String(sArr[0..<i])\\n                var right = String(sArr[i...])\\n                if right == \"\" {\\n                    let leftNum = Int(left)!\\n                    if Array(left)[0] == \"0\" {continue next}\\n                    res.append(String(left))\\n                } else {\\n                    let leftNum = Int(left)!, rightNum = Int(right)!\\n                    if leftNum == 0 && left.count > 1 {continue next}\\n                    if rightNum == 0 {continue next}\\n                    if Array(right)[right.count-1] == \"0\" {continue next}\\n                    if Array(left)[0] == \"0\" && leftNum > 0 {continue next}\\n                    \\n                    res.append(left+\".\"+right) \\n                }\\n\\n            }\\n            return res\\n        }\\n        var res = [String]()\\n        for i in 1..<sArr.endIndex {\\n            let w1 = String(sArr[0..<i])\\n            let w2 = String(sArr[i...])\\n            let w1list = gen(w1), w2list = gen(w2)\\n            for left in w1list {\\n                for right in w2list {\\n                    \\n                    res.append(\"(\\\\(left), \\\\(right))\")\\n                }\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206320,
                "title": "c-clean-and-commented-with-examples-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPair(const string& a, const string& b) {\\n        return \"(\" + a + \", \" + b + \")\";\\n    }\\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1, s.length()-2);\\n        int n = s.length();\\n        \\n        vector<string> result;\\n        \\n        for(int i = 1; i<n; i++) {\\n            string a = s.substr(0, i);\\n            string b = s.substr(i);\\n            \\n            vector<string> left  = helper(a);\\n            vector<string> right = helper(b);\\n            \\n            for(const string& s1 : left) {\\n                for(const string& s2 : right) {\\n                    result.push_back(getPair(s1, s2));\\n                }\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n    \\n    vector<string> helper(string& s) {\\n        int n = s.length();\\n        vector<string> result;\\n\\t\\t//starts with \\'0\\' and ends with \\'0\\'\\n        if(s[0] == \\'0\\' && s[n-1] == \\'0\\') {\\n\\t\\t /*\\n\\t\\t\\t we can\\'t process strings like \"0120\" because we will\\n\\t\\t\\t have 0 in beginngin and end as well. Also, we can\\n\\t\\t\\t only allow \"0\" in this scenario\\n\\t\\t*/\\n            if(n == 1)\\n                result.push_back(\"0\");\\n            return result;\\n        }\\n        \\n\\t\\t//starts with \\'0\\'\\n        if(s[0] == \\'0\\') {\\n            //example : 012 or 0012\\n            //we can only do 0.12 or 0.012 and no other way\\n            result.push_back(\"0.\" + s.substr(1));\\n            return result;\\n        }\\n        \\n\\t\\t//ends with \\'0\\'\\n        if(s[n-1] == \\'0\\') {\\n            //example : 120: we have no option because 1.20 no allowed, 12.0 not allowed\\n            result.push_back(s);\\n            return result;\\n        }\\n        \\n\\t\\t//no \\'0\\' in start or end\\n\\t\\t//example : 123 -> {1.23, 12.3}\\n        result.push_back(s);\\n        for(int i = 1; i<n; i++) {\\n            string temp = s.substr(0, i) + \".\" + s.substr(i);\\n            result.push_back(temp);\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPair(const string& a, const string& b) {\\n        return \"(\" + a + \", \" + b + \")\";\\n    }\\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1, s.length()-2);\\n        int n = s.length();\\n        \\n        vector<string> result;\\n        \\n        for(int i = 1; i<n; i++) {\\n            string a = s.substr(0, i);\\n            string b = s.substr(i);\\n            \\n            vector<string> left  = helper(a);\\n            vector<string> right = helper(b);\\n            \\n            for(const string& s1 : left) {\\n                for(const string& s2 : right) {\\n                    result.push_back(getPair(s1, s2));\\n                }\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n    \\n    vector<string> helper(string& s) {\\n        int n = s.length();\\n        vector<string> result;\\n\\t\\t//starts with \\'0\\' and ends with \\'0\\'\\n        if(s[0] == \\'0\\' && s[n-1] == \\'0\\') {\\n\\t\\t /*\\n\\t\\t\\t we can\\'t process strings like \"0120\" because we will\\n\\t\\t\\t have 0 in beginngin and end as well. Also, we can\\n\\t\\t\\t only allow \"0\" in this scenario\\n\\t\\t*/\\n            if(n == 1)\\n                result.push_back(\"0\");\\n            return result;\\n        }\\n        \\n\\t\\t//starts with \\'0\\'\\n        if(s[0] == \\'0\\') {\\n            //example : 012 or 0012\\n            //we can only do 0.12 or 0.012 and no other way\\n            result.push_back(\"0.\" + s.substr(1));\\n            return result;\\n        }\\n        \\n\\t\\t//ends with \\'0\\'\\n        if(s[n-1] == \\'0\\') {\\n            //example : 120: we have no option because 1.20 no allowed, 12.0 not allowed\\n            result.push_back(s);\\n            return result;\\n        }\\n        \\n\\t\\t//no \\'0\\' in start or end\\n\\t\\t//example : 123 -> {1.23, 12.3}\\n        result.push_back(s);\\n        for(int i = 1; i<n; i++) {\\n            string temp = s.substr(0, i) + \".\" + s.substr(i);\\n            result.push_back(temp);\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206181,
                "title": "ambiguous-coordinates-python-simple-solution",
                "content": "\\n\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n\\t\\t\\n        def poss_combs(t: str):\\n            if len(t) == 1:\\n                return [t]\\n            elif t[0]==\"0\":\\n                return [] if t[-1] == \"0\" else [\"0.\"+t[1:]]\\n            elif t[-1]==\"0\":\\n                return [t]\\n            else:\\n                return [t[:idx_] + \".\" + t[idx_:] for idx_ in range(1, len(t))] + [t]\\n\\n        list_ = []\\n        for idx_ in range(1, len(s)):\\n            # first we split the string into two halves\\n            s1 = s[:idx_]\\n            s2 = s[idx_:]\\n        \\n            # compute the possible permutations for the given substrings\\n            c1 = poss_combs(s1)\\n            if len(c1) > 0:\\n                c2 = poss_combs(s2)\\n                if len(c2) > 0:\\n\\t\\t\\t\\t\\t# create a list of all possible combinations\\n                    list_ += [f\"({a1}, {a2})\" for a1 in c1 for a2 in c2]\\n                \\n        return list_\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n\\t\\t\\n        def poss_combs(t: str):\\n            if len(t) == 1:\\n                return [t]\\n            elif t[0]==\"0\":\\n                return [] if t[-1] == \"0\" else [\"0.\"+t[1:]]\\n            elif t[-1]==\"0\":\\n                return [t]\\n            else:\\n                return [t[:idx_] + \".\" + t[idx_:] for idx_ in range(1, len(t))] + [t]\\n\\n        list_ = []\\n        for idx_ in range(1, len(s)):\\n            # first we split the string into two halves\\n            s1 = s[:idx_]\\n            s2 = s[idx_:]\\n        \\n            # compute the possible permutations for the given substrings\\n            c1 = poss_combs(s1)\\n            if len(c1) > 0:\\n                c2 = poss_combs(s2)\\n                if len(c2) > 0:\\n\\t\\t\\t\\t\\t# create a list of all possible combinations\\n                    list_ += [f\"({a1}, {a2})\" for a1 in c1 for a2 in c2]\\n                \\n        return list_\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206178,
                "title": "java-3ms-bruceforce",
                "content": "divide 2 part and \\ncreate all possible string from each part\\n\\n```\\nclass Solution {\\n    List<String> res = new ArrayList();\\n    \\n    public List<String> ambiguousCoordinates(String s) {\\n        int n=s.length();\\n        for (int i = 2;i<n-1;i++){\\n            List<String> l = help(s.substring(1,i));\\n            List<String> r = help(s.substring(i,n-1));\\n            if (l.size()!=0&&r.size()!=0) result(l,r);\\n        }\\n        return res;\\n    }\\n    \\n    private void result(List<String> l,List<String> r){\\n        for (String str1:l){\\n            for (String str2:r){\\n                StringBuilder sb = new StringBuilder();\\n                sb.append(\\'(\\');\\n                sb.append(str1);\\n                sb.append(\", \");\\n                sb.append(str2);\\n                sb.append(\\')\\');\\n                res.add(sb.toString());\\n            }\\n        }\\n    }\\n    \\n    private List<String> help(String str){\\n        List<String> list = new ArrayList();\\n        int n = str.length();\\n        if (n==1){\\n            list.add(str);\\n            return list;\\n        }\\n        if (str.charAt(n-1)==\\'0\\'){\\n            if (str.charAt(0)==\\'0\\') return list;\\n            else{\\n                list.add(str);\\n                return list;\\n            }\\n        }else if (str.charAt(0)!=\\'0\\') list.add(str);\\n        for (int i=1;i<n;i++){\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(str.substring(0,i));\\n            sb.append(\\'.\\');\\n        sb.append(str.substring(i,n));\\n                list.add(sb.toString());\\n            if (str.charAt(0)==\\'0\\') break;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<String> res = new ArrayList();\\n    \\n    public List<String> ambiguousCoordinates(String s) {\\n        int n=s.length();\\n        for (int i = 2;i<n-1;i++){\\n            List<String> l = help(s.substring(1,i));\\n            List<String> r = help(s.substring(i,n-1));\\n            if (l.size()!=0&&r.size()!=0) result(l,r);\\n        }\\n        return res;\\n    }\\n    \\n    private void result(List<String> l,List<String> r){\\n        for (String str1:l){\\n            for (String str2:r){\\n                StringBuilder sb = new StringBuilder();\\n                sb.append(\\'(\\');\\n                sb.append(str1);\\n                sb.append(\", \");\\n                sb.append(str2);\\n                sb.append(\\')\\');\\n                res.add(sb.toString());\\n            }\\n        }\\n    }\\n    \\n    private List<String> help(String str){\\n        List<String> list = new ArrayList();\\n        int n = str.length();\\n        if (n==1){\\n            list.add(str);\\n            return list;\\n        }\\n        if (str.charAt(n-1)==\\'0\\'){\\n            if (str.charAt(0)==\\'0\\') return list;\\n            else{\\n                list.add(str);\\n                return list;\\n            }\\n        }else if (str.charAt(0)!=\\'0\\') list.add(str);\\n        for (int i=1;i<n;i++){\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(str.substring(0,i));\\n            sb.append(\\'.\\');\\n        sb.append(str.substring(i,n));\\n                list.add(sb.toString());\\n            if (str.charAt(0)==\\'0\\') break;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206143,
                "title": "java-solution-with-explanation-4ms-beats-100",
                "content": "I\\'m dividing the given string into two parts and for each part I\\'m generating the possible numbers for that part. If any pair formed by doing so has the first and second number valid, I\\'m adding it to answer.\\n\\n```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s)\\n    {\\n        int divide = 1;\\n        List<String> ans = new ArrayList<String>();\\n        s = s.substring(1,s.length()-1);\\n        while(divide < s.length())\\n        {\\n            List<String> first = gen(s.substring(0,divide));\\n            List<String> second = gen(s.substring(divide));\\n            for(String f : first)\\n            {\\n                for(String se : second)\\n                {\\n                    //System.out.println(f+\" \"+se);\\n                    if(valid(f) && valid(se))\\n                    {\\n                        StringBuilder sb = new StringBuilder();\\n                        sb.append(\"(\");\\n                        sb.append(f);\\n                        sb.append(\", \");\\n                        sb.append(se);\\n                        sb.append(\")\");\\n                        ans.add(sb.toString());\\n                    }\\n                }\\n            }\\n            divide++;\\n        }\\n        return ans;\\n    }\\n    public static List<String> gen(String s)\\n    {\\n        int divide = 1;\\n        List<String> toret = new ArrayList<String>();\\n        if(s.length() == 1)\\n        {\\n            toret.add(s);\\n            return toret;\\n        }\\n        toret.add(s);\\n        while(divide < s.length())\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(s.substring(0,divide));\\n            sb.append(\".\");\\n            sb.append(s.substring(divide));\\n            toret.add(sb.toString());\\n            divide++;\\n        }\\n        return toret;\\n    }\\n    public static Boolean valid(String s)\\n    {\\n        if(s.length() == 1)\\n            return true;\\n        if(s.charAt(0)==\\'0\\' && s.charAt(1)!=\\'.\\')\\n            return false;\\n        if(s.contains(\".\") && s.charAt(s.length()-1)==\\'0\\')\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s)\\n    {\\n        int divide = 1;\\n        List<String> ans = new ArrayList<String>();\\n        s = s.substring(1,s.length()-1);\\n        while(divide < s.length())\\n        {\\n            List<String> first = gen(s.substring(0,divide));\\n            List<String> second = gen(s.substring(divide));\\n            for(String f : first)\\n            {\\n                for(String se : second)\\n                {\\n                    //System.out.println(f+\" \"+se);\\n                    if(valid(f) && valid(se))\\n                    {\\n                        StringBuilder sb = new StringBuilder();\\n                        sb.append(\"(\");\\n                        sb.append(f);\\n                        sb.append(\", \");\\n                        sb.append(se);\\n                        sb.append(\")\");\\n                        ans.add(sb.toString());\\n                    }\\n                }\\n            }\\n            divide++;\\n        }\\n        return ans;\\n    }\\n    public static List<String> gen(String s)\\n    {\\n        int divide = 1;\\n        List<String> toret = new ArrayList<String>();\\n        if(s.length() == 1)\\n        {\\n            toret.add(s);\\n            return toret;\\n        }\\n        toret.add(s);\\n        while(divide < s.length())\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(s.substring(0,divide));\\n            sb.append(\".\");\\n            sb.append(s.substring(divide));\\n            toret.add(sb.toString());\\n            divide++;\\n        }\\n        return toret;\\n    }\\n    public static Boolean valid(String s)\\n    {\\n        if(s.length() == 1)\\n            return true;\\n        if(s.charAt(0)==\\'0\\' && s.charAt(1)!=\\'.\\')\\n            return false;\\n        if(s.contains(\".\") && s.charAt(s.length()-1)==\\'0\\')\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206133,
                "title": "python-2-simple-solutions",
                "content": "Solution 1: simply generate all possible number strings.\\nAt each number string, check valid by converting to number, then to string again. For example: \"004\" is not a valid number string, since len(\"004\") != len(str(int(\"004\"))\\nFor floats, use decimal.Decimal for accuracy.\\n```\\nfrom decimal import Decimal\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        \\n        def get_valid_nums(base):\\n            result = [fpnum for i in range(1, len(base)) if int(base[i:]) != 0 and len(str(Decimal(fpnum := f\\'{base[:i]}.{base[i:]}\\').normalize())) == len(fpnum)]\\n            if len(str(int(base))) == len(base): result += [base]\\n            return result\\n            \\n        result = []\\n        for i in range(1, len(s)):\\n            result.extend([f\\'({x}, {y})\\' for x, y in product(get_valid_nums(s[:i]), get_valid_nums(s[i:]))])\\n            \\n        return result\\n```\\n---\\nSolution 2:\\nIf base string starts with 0 and ends with 0, string is not a valid number\\nIf base string ends with 0, return base string\\nIf base string starts with 0, return 0.rest\\nIf base string starts and ends with not 0, return any possible float from base string\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        \\n        def get_valid_nums(base):\\n            if len(base) > 1 and base[0] == base[-1] == \\'0\\': return []\\n            elif base[-1] == \\'0\\': return [base]\\n            elif base[0] == \\'0\\': return [base[0] + \\'.\\' + base[1:]]\\n            else: return [f\\'{base[:i]}.{base[i:]}\\' for i in range(1, len(base))] + [base]\\n        \\n        result = []\\n        for i in range(1, len(s)):\\n            result.extend([f\\'({x}, {y})\\' for x, y in product(get_valid_nums(s[:i]), get_valid_nums(s[i:]))])\\n            \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nfrom decimal import Decimal\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        \\n        def get_valid_nums(base):\\n            result = [fpnum for i in range(1, len(base)) if int(base[i:]) != 0 and len(str(Decimal(fpnum := f\\'{base[:i]}.{base[i:]}\\').normalize())) == len(fpnum)]\\n            if len(str(int(base))) == len(base): result += [base]\\n            return result\\n            \\n        result = []\\n        for i in range(1, len(s)):\\n            result.extend([f\\'({x}, {y})\\' for x, y in product(get_valid_nums(s[:i]), get_valid_nums(s[i:]))])\\n            \\n        return result\\n```\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        \\n        def get_valid_nums(base):\\n            if len(base) > 1 and base[0] == base[-1] == \\'0\\': return []\\n            elif base[-1] == \\'0\\': return [base]\\n            elif base[0] == \\'0\\': return [base[0] + \\'.\\' + base[1:]]\\n            else: return [f\\'{base[:i]}.{base[i:]}\\' for i in range(1, len(base))] + [base]\\n        \\n        result = []\\n        for i in range(1, len(s)):\\n            result.extend([f\\'({x}, {y})\\' for x, y in product(get_valid_nums(s[:i]), get_valid_nums(s[i:]))])\\n            \\n        return result\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1670388,
                "content": [
                    {
                        "username": "zhengweix",
                        "content": "why new look????"
                    },
                    {
                        "username": "vivek_-_kr",
                        "content": "Yes "
                    }
                ]
            }
        ]
    }
]