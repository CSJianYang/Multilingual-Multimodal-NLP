[
    {
        "title": "Dungeon Game",
        "question_content": "The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through dungeon to rescue the princess.\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\nSome of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).\nTo reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.\nReturn the knight's minimum initial health so that he can rescue the princess.\nNote that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.\n&nbsp;\nExample 1:\n\nInput: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]\nOutput: 7\nExplanation: The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.\n\nExample 2:\n\nInput: dungeon = [[0]]\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\tm == dungeon.length\n\tn == dungeon[i].length\n\t1 <= m, n <= 200\n\t-1000 <= dungeon[i][j] <= 1000",
        "solutions": [
            {
                "id": 745340,
                "title": "post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start",
                "content": "**before starting with DP one must master the art of recursion**\\nmost of the post shows you the optimal solution, briefly explains how it works, but doesn\\'t tell you how to arive at that solution. it goes as \"give man a fish, he can eat it whole day, tell then how to catch one, he can have it whole life\".\\nhere is how you should approach these recurrsive/Dp problems. hopefully you will learn something.\\n\\n**step1 : understand the problem**\\nhere we have been given a matrix we need to start from top and find a way to get to bottom right, we need the min cost that is required to do this\\n\\n**step 2: logic building and deriving recurence relation**\\n\\n**1st sub step : asking questions**\\n1. At any point if our health gets zero of below we dies, athem so :  we need 1 + (-mat[i][j]) for our health to be one.\\n2. What if we get some health if we arrive at some cell ? my guess is we still need 1 health in first case to arrive at that cell - cases like these need to be figure out by yourself.\\n3. at any cell what health do we need ? - since we can go only down and right therefore min health required will be minimun health required if we go right or down, ( futher explained in arriving at recurrance relation heading )\\n\\nfor brief answers/explanation for above point 1 and 2 , assume a 1D matrix this is what is ment by 1st and 2nd point.\\n```\\n[[-10]]                     : ans  = 1 + (-(-10)) = 11 (explanation to first point mentioned)\\n[[10]]                      : ans  = 1 as we still need 1 health at first place to get there (explanation to second point mentioned)\\n[[-2,-3,3,-5,-10]]          : ans = 1 + (-(-17)) = 18 same as 1st case\\n[[2,3,3,5,10]]              : ans = 1 same as 2nd test case, explanation to second point mentioned to asking question\\n```\\n\\n**2nd sub step : Ariving at recurence relation**\\nrecurrence relation is pretty straight forward at any cell ,if we are at any particular cell we must ask should we go right or down ? if we know the answer for min health req if we go right vs we go down, then we can easily choose\\n![image](https://assets.leetcode.com/users/images/cd28d2d9-256b-4d72-a875-ea82880bd8e3_1595226474.6431954.png)\\n\\n**step 3: code recursive solution - (TLE)**\\n```\\nint getVal(vector<vector<int>> &mat, int i=0, int j=0)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        // Base case : we have crossed the matrix, ie. out of bound\\n        /// if current row crosses then my row is below the princess or \\n        /// if current column crosses then my column is ahead the column of princess\\n        /// and beacause we can go only down and right so we wont be able reach princess\\n        if(i == n || j == m)    return 1e9; \\n        \\n\\t\\t// Base Case : we have reached our destination ie. last cell\\n        /// we reached princess , cheers return this cost;\\n        if(i == n-1 and j == m-1)   \\n            return (mat[i][j] <= 0) ? -mat[i][j] + 1 : 1;\\n        \\n        /// now we must try all possible paths , we ask our right and and down cell\\n        int IfWeGoRight = getVal(mat , i , j+1);\\n        int IfWeGoDown = getVal(mat , i+1 , j);\\n        \\n        /// min of either values and then cost of this cell\\n        int minHealthRequired =  min(IfWeGoRight , IfWeGoDown) -mat[i][j];\\n        \\n        /// point 2 as explained \\n        return ( minHealthRequired <= 0 ) ? 1 : minHealthRequired;      \\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        return getVal(dungeon);     \\n    }\\n```\\nNow you know how to solve this recurssively, lets now observe time complexity ...  ... yep its exponential ! . but luckily we are doing same task over and over again. ( for example we are asking 6 times the last cell its cost in 3X3 matrix), we can overcome this task by storing the values of cost at each cell ( aka memoization ).\\n\\n**step4 : memoization-top-down**\\nlets maintain a DP matrix which will store the calculated values for its cell. next time if we arrive at this cell we will return this calculated value to save recurrsive calls.\\n```\\nint getVal(vector<vector<int>> &mat, vector<vector<int>> &dp , int i=0, int j=0)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();    \\n        \\n        if(i == n || j == m)    return 1e9; \\n        \\n        if(i == n-1 and j == m-1)\\n            return (mat[i][j] <= 0) ? -mat[i][j] + 1 : 1;\\n        \\n        /// if we know the answer for this cell then no need to recalculate those, simply return those values \\n        if( dp[i][j] != 1e9)\\n            return dp[i][j];\\n        \\n        int IfWeGoRight = getVal(mat , dp , i , j+1);\\n        int IfWeGoDown = getVal(mat , dp , i+1 , j);\\n        \\n        int minHealthRequired =  min(IfWeGoRight , IfWeGoDown) -mat[i][j];\\n        \\n        /// before returning the values, we must store the answers for this cell which we hacve calculated\\n        /// in next recurssive call this value will be used to save some computation, aka repetative work which we are doing.\\n        dp[i][j] = ( minHealthRequired <= 0 ) ? 1 : minHealthRequired;      \\n        return dp[i][j];\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        \\n        int n = dungeon.size();\\n        int m = dungeon[0].size();\\n        \\n        vector<vector<int>> dp(n , vector<int>(m , 1e9));\\n        \\n        return getVal(dungeon, dp);     \\n    }\\n```\\nso now you know the recursive solution , you have also tried memoization, so try coming up with bottomUp solution yourself, HINT : as you might have observed final destination is the last cell, so why dont we start with the bottom cell itself. then work all the way up to first cell.\\n\\n**step 5 :  You know the base casses , you know the sub problems so try coming up with bottom up solution yourself ( hint in above paragraph )**\\n```\\nint calculateMinimumHP(vector<vector<int> > &dungeon) {\\n\\n        int n = dungeon.size();\\n        int m = dungeon[0].size();\\n\\n        vector<vector<int> > dp(n + 1, vector<int>(m + 1, 1e9));\\n        dp[n][m - 1] = 1;\\n        dp[n - 1][m] = 1;\\n        \\n        for (int i = n - 1; i >= 0; i--) \\n        {\\n            for (int j = m - 1; j >= 0; j--) \\n            {\\n                int need = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];                \\n                // store this value\\n                dp[i][j] = need <= 0 ? 1 : need;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```\\n\\n**it takes a lots of time and effort to write post like these, if you learned something then, then consider upvoting, so that this post reach beginners.\\nHappy coding**\\n\\nprevious tutorial on DP\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/discuss/630868/explanation-from-someone-who-took-2-hours-to-solve/\\nhttps://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/discuss/642422/Lets-solve-it-together-%3A-step-by-step\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n[[-10]]                     : ans  = 1 + (-(-10)) = 11 (explanation to first point mentioned)\\n[[10]]                      : ans  = 1 as we still need 1 health at first place to get there (explanation to second point mentioned)\\n[[-2,-3,3,-5,-10]]          : ans = 1 + (-(-17)) = 18 same as 1st case\\n[[2,3,3,5,10]]              : ans = 1 same as 2nd test case, explanation to second point mentioned to asking question\\n```\n```\\nint getVal(vector<vector<int>> &mat, int i=0, int j=0)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        // Base case : we have crossed the matrix, ie. out of bound\\n        /// if current row crosses then my row is below the princess or \\n        /// if current column crosses then my column is ahead the column of princess\\n        /// and beacause we can go only down and right so we wont be able reach princess\\n        if(i == n || j == m)    return 1e9; \\n        \\n\\t\\t// Base Case : we have reached our destination ie. last cell\\n        /// we reached princess , cheers return this cost;\\n        if(i == n-1 and j == m-1)   \\n            return (mat[i][j] <= 0) ? -mat[i][j] + 1 : 1;\\n        \\n        /// now we must try all possible paths , we ask our right and and down cell\\n        int IfWeGoRight = getVal(mat , i , j+1);\\n        int IfWeGoDown = getVal(mat , i+1 , j);\\n        \\n        /// min of either values and then cost of this cell\\n        int minHealthRequired =  min(IfWeGoRight , IfWeGoDown) -mat[i][j];\\n        \\n        /// point 2 as explained \\n        return ( minHealthRequired <= 0 ) ? 1 : minHealthRequired;      \\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        return getVal(dungeon);     \\n    }\\n```\n```\\nint getVal(vector<vector<int>> &mat, vector<vector<int>> &dp , int i=0, int j=0)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();    \\n        \\n        if(i == n || j == m)    return 1e9; \\n        \\n        if(i == n-1 and j == m-1)\\n            return (mat[i][j] <= 0) ? -mat[i][j] + 1 : 1;\\n        \\n        /// if we know the answer for this cell then no need to recalculate those, simply return those values \\n        if( dp[i][j] != 1e9)\\n            return dp[i][j];\\n        \\n        int IfWeGoRight = getVal(mat , dp , i , j+1);\\n        int IfWeGoDown = getVal(mat , dp , i+1 , j);\\n        \\n        int minHealthRequired =  min(IfWeGoRight , IfWeGoDown) -mat[i][j];\\n        \\n        /// before returning the values, we must store the answers for this cell which we hacve calculated\\n        /// in next recurssive call this value will be used to save some computation, aka repetative work which we are doing.\\n        dp[i][j] = ( minHealthRequired <= 0 ) ? 1 : minHealthRequired;      \\n        return dp[i][j];\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        \\n        int n = dungeon.size();\\n        int m = dungeon[0].size();\\n        \\n        vector<vector<int>> dp(n , vector<int>(m , 1e9));\\n        \\n        return getVal(dungeon, dp);     \\n    }\\n```\n```\\nint calculateMinimumHP(vector<vector<int> > &dungeon) {\\n\\n        int n = dungeon.size();\\n        int m = dungeon[0].size();\\n\\n        vector<vector<int> > dp(n + 1, vector<int>(m + 1, 1e9));\\n        dp[n][m - 1] = 1;\\n        dp[n - 1][m] = 1;\\n        \\n        for (int i = n - 1; i >= 0; i--) \\n        {\\n            for (int j = m - 1; j >= 0; j--) \\n            {\\n                int need = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];                \\n                // store this value\\n                dp[i][j] = need <= 0 ? 1 : need;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52774,
                "title": "c-dp-solution",
                "content": "Use hp[i][j] to store the min hp needed at position (i, j), then do the calculation from right-bottom to left-up.\\n\\nNote: adding dummy row and column would make the code cleaner.\\n\\n    class Solution {\\n    public:\\n        int calculateMinimumHP(vector<vector<int> > &dungeon) {\\n            int M = dungeon.size();\\n            int N = dungeon[0].size();\\n            // hp[i][j] represents the min hp needed at position (i, j)\\n            // Add dummy row and column at bottom and right side\\n            vector<vector<int> > hp(M + 1, vector<int>(N + 1, INT_MAX));\\n            hp[M][N - 1] = 1;\\n            hp[M - 1][N] = 1;\\n            for (int i = M - 1; i >= 0; i--) {\\n                for (int j = N - 1; j >= 0; j--) {\\n                    int need = min(hp[i + 1][j], hp[i][j + 1]) - dungeon[i][j];\\n                    hp[i][j] = need <= 0 ? 1 : need;\\n                }\\n            }\\n            return hp[0][0];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int calculateMinimumHP(vector<vector<int> > &dungeon) {\\n            int M = dungeon.size();\\n            int N = dungeon[0].size();\\n            // hp[i][j] represents the min hp needed at position (i, j)\\n            // Add dummy row and column at bottom and right side\\n            vector<vector<int> > hp(M + 1, vector<int>(N + 1, INT_MAX));\\n            hp[M][N - 1] = 1;\\n            hp[M - 1][N] = 1;\\n            for (int i = M - 1; i >= 0; i--) {\\n                for (int j = N - 1; j >= 0; j--) {\\n                    int need = min(hp[i + 1][j], hp[i][j + 1]) - dungeon[i][j];\\n                    hp[i][j] = need <= 0 ? 1 : need;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 698271,
                "title": "python-short-dp-7-lines-o-mn-top-down-explained",
                "content": "Probably when you see this problem and you have some experience in this type of problems you can guess, that this is **dynamic programming** problem. However even if you understand this, it is not easy to solve it. Let us use top-down dp, that is `Let dp[i][j]` be the minimum **hp** we need to reach the **princess** if we start from point `(i,j)`. Let us consider the following example:\\n\\n| -2  | -3  | +3 |\\n|---------|---------|--------|\\n| **-5**  | **-10** | **+1** |\\n| **+10** | **+30** | **-5** |\\n\\nLet us add bottom dummy row and right dummy column to handle border cases more easy. We fill it with infinities, except two ones - neibours of our princess. I will explain it a bit later.\\n\\nHow we can evaluate `dp[i][j]`? We need to look at two cells: `dp[i+1][j]` and `dp[i][j+1]` and evaluate two possible candidates: `dp[i+1][j]-dungeon[i][j]` and `dp[i][j+1]-dungeon[i][j]`.\\n1. If at least one of these two numbers is negative, it means that we can survive just with `1` hp: (look at number `+30` in our table for example)\\n2. If both this numbers are positive, we need to take the mimumum of them, see for example number `-10` in our table: to survive we need either `5- -10 = 15` if we go right and `1- -10 = 11` if we go down, of course we choose `11`.\\n3. This conditions can be written in one a bit ugly line: `dp[i][j] = max(min(dp[i+1][j],dp[i][j+1])-dungeon[i][j],1)`.\\n4. Finally, why I put `1` to two neibors of princess? To make this formula valid for princess cell: if we have negative number like `-5` in this cell, we need `6` hp to survive, if we have non-negative number in this cell, we need `1` hp to survive.\\n\\n| 7  | 5   | 2 | inf |\\n|---------|---------|-------|---------|\\n| **6**   | **11**  | **5** | **inf** |\\n| **1**   | **1**   | **6** | **1**   |\\n| **inf** | **inf** | **1** | **#**   |\\n\\n**Complexity**: both time and space is `O(mn)`. Space complexity can be reduced to `O(min(m,n))` as usual, because we look only to neibour cells. However code becomes a bit more difficult to follow.\\n\\n```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon):\\n        m, n = len(dungeon), len(dungeon[0])\\n        dp = [[float(\"inf\")]*(n+1) for _ in range(m+1)]\\n        dp[m-1][n], dp[m][n-1] = 1, 1\\n            \\n        for i in range(m-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                dp[i][j] = max(min(dp[i+1][j],dp[i][j+1])-dungeon[i][j],1)\\n        \\n        return dp[0][0]\\n```\\n\\n**Further discussion** It is possible to do it with down-top dp as well, howerer in this case you need to use **binary search**, because you do not know in advance if you survive starting say `1000` hp or not. Complexity will be `O(nm log(MAX_INT))` in this case.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon):\\n        m, n = len(dungeon), len(dungeon[0])\\n        dp = [[float(\"inf\")]*(n+1) for _ in range(m+1)]\\n        dp[m-1][n], dp[m][n-1] = 1, 1\\n            \\n        for i in range(m-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                dp[i][j] = max(min(dp[i+1][j],dp[i][j+1])-dungeon[i][j],1)\\n        \\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52790,
                "title": "my-ac-java-version-suggestions-are-welcome",
                "content": "    public int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) return 0;\\n        \\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        \\n        int[][] health = new int[m][n];\\n\\n        health[m - 1][n - 1] = Math.max(1 - dungeon[m - 1][n - 1], 1);\\n\\n        for (int i = m - 2; i >= 0; i--) {            \\n            health[i][n - 1] = Math.max(health[i + 1][n - 1] - dungeon[i][n - 1], 1);\\n        }\\n\\n        for (int j = n - 2; j >= 0; j--) {\\n            health[m - 1][j] = Math.max(health[m - 1][j + 1] - dungeon[m - 1][j], 1);\\n        }\\n\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                int down = Math.max(health[i + 1][j] - dungeon[i][j], 1);\\n                int right = Math.max(health[i][j + 1] - dungeon[i][j], 1);\\n                health[i][j] = Math.min(right, down);\\n            }\\n        }\\n\\n        return health[0][0];\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) return 0;\\n        \\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        \\n        int[][] health = new int[m][n];\\n\\n        health[m - 1][n - 1] = Math.max(1 - dungeon[m - 1][n - 1], 1);\\n\\n        for (int i = m - 2; i >= 0; i--) {            \\n            health[i][n - 1] = Math.max(health[i + 1][n - 1] - dungeon[i][n - 1], 1);\\n        }\\n\\n        for (int j = n - 2; j >= 0; j--) {\\n            health[m - 1][j] = Math.max(health[m - 1][j + 1] - dungeon[m - 1][j], 1);\\n        }\\n\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                int down = Math.max(health[i + 1][j] - dungeon[i][j], 1);\\n                int right = Math.max(health[i][j + 1] - dungeon[i][j], 1);\\n                health[i][j] = Math.min(right, down);\\n            }\\n        }\\n\\n        return health[0][0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52805,
                "title": "best-solution-i-have-found-with-explanations",
                "content": "\\n\\nhttp://leetcodesolution.blogspot.com/2015/01/leetcode-dungeon-game.html\\n\\nseems pretty simple... and easy to understand explanations...\\n\\n\\nIt is easy to know that at grid P, since \" at any point his health point drops to 0 or below, he dies immediately\", the remaining health value should be at least 1,  that is, initialHealth + dungeon >= 1, we have initialHealth = max(1, 1 - dungeon[i][j]).  (Notice, at any grid, the initial health should be at least 1 (for example,  test case [1,0,0] require initial health 1 even though it has positive remaining health at grid[0][1] and grid[0][2])\\nSimilarly, to satisfy the initial health of dungeon[i][j], the initial health of dungeon[i-1][j] (or dungeon[i][j-1]) should be at least initialHealth[i-1][j] + dungeon[i-1][j] = initialHealth[i][j], that is, initialHealth[i][j] = initialHealth[i][j] - dungeon[i-1][j]. \\nIn addition, if grid[i][j] can go both grid[i+1][j] and grid[i][j+1] to P,  we should choose a path with less initial health between grid[i+1][j] and grid[i][j+1] since it require less initial health of grid[i][j].\\nWe can simply code the solution by having the dynamic programming equations. \\n\\n\\n         int calculateMinimumHP(vector &dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector minInitHealth(m, vector<int>(n,0));\\n        for(int i=m-1; i>=0; i--)\\n        {\\n            for (int j=n-1; j>=0; j--)\\n            {\\n                if (i == m-1 && j == n-1)\\n                {\\n                    minInitHealth[i][j] = max(1, 1 - dungeon[i][j]);\\n                }  \\n                else if (i == m-1)\\n                {\\n                    minInitHealth[i][j] = max(1, minInitHealth[i][j+1] - dungeon[i][j]);\\n                }  \\n                else if (j == n-1)\\n                {\\n                    minInitHealth[i][j] = max(1, minInitHealth[i+1][j] - dungeon[i][j]);\\n                }  \\n                else\\n                {\\n                    minInitHealth[i][j] = max(1, min(minInitHealth[i+1][j],minInitHealth[i][j+1]) - dungeon[i][j]);\\n                }  \\n            }\\n        }\\n        \\n        return  minInitHealth[0][0];\\n    }",
                "solutionTags": [],
                "code": "\\n\\nhttp://leetcodesolution.blogspot.com/2015/01/leetcode-dungeon-game.html\\n\\nseems pretty simple... and easy to understand explanations...\\n\\n\\nIt is easy to know that at grid P, since \" at any point his health point drops to 0 or below, he dies immediately\", the remaining health value should be at least 1,  that is, initialHealth + dungeon >= 1, we have initialHealth = max(1, 1 - dungeon[i][j]).  (Notice, at any grid, the initial health should be at least 1 (for example,  test case [1,0,0] require initial health 1 even though it has positive remaining health at grid[0][1] and grid[0][2])\\nSimilarly, to satisfy the initial health of dungeon[i][j], the initial health of dungeon[i-1][j] (or dungeon[i][j-1]) should be at least initialHealth[i-1][j] + dungeon[i-1][j] = initialHealth[i][j], that is, initialHealth[i][j] = initialHealth[i][j] - dungeon[i-1][j]. \\nIn addition, if grid[i][j] can go both grid[i+1][j] and grid[i][j+1] to P,  we should choose a path with less initial health between grid[i+1][j] and grid[i][j+1] since it require less initial health of grid[i][j].\\nWe can simply code the solution by having the dynamic programming equations. \\n\\n\\n         int calculateMinimumHP(vector &dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector minInitHealth(m, vector<int>(n,0));\\n        for(int i=m-1; i>=0; i--)\\n        {\\n            for (int j=n-1; j>=0; j--)\\n            {\\n                if (i == m-1 && j == n-1)\\n                {\\n                    minInitHealth[i][j] = max(1, 1 - dungeon[i][j]);\\n                }  \\n                else if (i == m-1)\\n                {\\n                    minInitHealth[i][j] = max(1, minInitHealth[i][j+1] - dungeon[i][j]);\\n                }  \\n                else if (j == n-1)\\n                {\\n                    minInitHealth[i][j] = max(1, minInitHealth[i+1][j] - dungeon[i][j]);\\n                }  \\n                else\\n                {\\n                    minInitHealth[i][j] = max(1, min(minInitHealth[i+1][j],minInitHealth[i][j+1]) - dungeon[i][j]);\\n                }  \\n            }\\n        }\\n        \\n        return  minInitHealth[0][0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52826,
                "title": "a-very-clean-and-intuitive-solution-with-explanation",
                "content": "**Dynamic Programming**\\nFirst, we need to define the subproblem somewhat a little clever. If we define: \\n*dp[i][j] = minimum cost from (0, 0) to (i, j)*\\nIt won't help solving the problem, because the result of dp[i + 1][j + 1] does not depends only on previous solve subproblems, but also future unsolved subproblems. So, how about let's define the subproblem from the other end of the puzzle?\\n***dp[i][j] = minimum health level required to reach the princess when entering (i, j)***\\n\\nSo, what is dp[i + 1][j + 1] then? It depends on the minimum between dp[i][j + 1] and dp[i + 1][j], because we want to choose the cheapest way to go. Of course we also need to add or deduct the value from dungeon matrix. But be careful, if we find that the minimum required health level is less that 0, we need to set it to 0, because we are not allowed to overdraft health. With that said:\\n***dp[i + 1][j + 1] = max(min(dp[i][j + 1], dp[i + 1][j]) - dungeon[i + 1][j + 1], 0);***\\n\\n**Implementation**\\nTo get the code cleaner, I created the dp matrix 1 row and 1 column bigger that the original input. But we need to be careful when initializing the extra row and column, everything is initialized to Infinite except cell (m, n - 1) and (m - 1, n), which should be initialized to 0.\\nI attached a picture to illustrate the idea (based on the test case given in the problem statement). Then code becomes very readable.\\n\\n![0_1470070141386_dungeon.png](/uploads/files/1470070031420-dungeon.png) \\n\\n\\n```\\npublic class Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n\\t\\tint m = dungeon.length;\\n\\t\\tint n = m == 0 ? 0 : dungeon[0].length;\\n\\t\\tint[][] minRequred = new int[m + 1][n + 1];\\n\\n\\t\\tfor (int i = 0; i < m + 1; i++) {\\n\\t\\t\\tminRequred[i][n] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < n + 1; j++) {\\n\\t\\t\\tminRequred[m][j] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tminRequred[m][n - 1] = 0;\\n\\t\\tminRequred[m - 1][n] = 0;\\n\\t\\t\\n                for (int i = m - 1; i >= 0; i--) {\\n\\t\\t\\tfor (int j = n - 1; j >= 0; j--) {\\n\\t\\t\\t\\tminRequred[i][j] = Math.max(\\n\\t\\t\\t\\t\\t\\tMath.min(minRequred[i + 1][j], minRequred[i][j + 1]) - dungeon[i][j], 0);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn minRequred[0][0] + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n\\t\\tint m = dungeon.length;\\n\\t\\tint n = m == 0 ? 0 : dungeon[0].length;\\n\\t\\tint[][] minRequred = new int[m + 1][n + 1];\\n\\n\\t\\tfor (int i = 0; i < m + 1; i++) {\\n\\t\\t\\tminRequred[i][n] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < n + 1; j++) {\\n\\t\\t\\tminRequred[m][j] = Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\tminRequred[m][n - 1] = 0;\\n\\t\\tminRequred[m - 1][n] = 0;\\n\\t\\t\\n                for (int i = m - 1; i >= 0; i--) {\\n\\t\\t\\tfor (int j = n - 1; j >= 0; j--) {\\n\\t\\t\\t\\tminRequred[i][j] = Math.max(\\n\\t\\t\\t\\t\\t\\tMath.min(minRequred[i + 1][j], minRequred[i][j + 1]) - dungeon[i][j], 0);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn minRequred[0][0] + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698376,
                "title": "c-beginner-friendly-dp-explanation-and-idea",
                "content": "We want to reach the last cell of the dungeon which means that our health should be greater than 1 when we reach there. So the best way to calculate the minimum health required is by checking for the last cell and going our way upwards. The answer will be the value we get on arriving at the first cell;\\n```\\n-2 \\t -3\\t   3\\n-5\\t -10   1\\n10\\t  30  -5  <-  when we arrive here our health will be reduced by 5.\\n\\t\\t\\t\\tSo we need minimum 6 health to survive when we reach here. val = (1- (-5) = 6)\\n\\nIf this value was positive we dont need to worry and the minimum energy we need is 1. \\nSuppose the value was +5 then 1-5 = -4.  -4<1 => so ans is 1. i.e max(1,val).\\n```\\nNow for simplicity and to avoid the checks on the border we can create our dp with 1 additional bottom row and 1 additional rightmost column. (Similar to the dp we use in LCS and other problem).\\n\\nAlso what  values should we fill our dp with?\\nWell the answer is quite obvious the maximum possible value. For c++ we can use INT_MAX;\\nOur dp looks like this:\\n```\\n-2  -3   3  m      m -> denotes max \\n-5  10   1  m\\n10  30  -5  1   -> note: we have two value as 1 for the last element (I will explain this as we proceed)\\n m   m   1 m\\n \\n suppose the dimensions of dungeon matirx was \"r x c\", for our dp will be \" r+1 x c+1\".\\n We will start our iteration \\n from the value -5 that is the cell our princess is located.\\n We first have to see which value is minimum from that cell (the one on the right or bottom).\\n i.e. which cell requres less health to travel to\\n for this cell is (one which holds the princess):\\n val = min of dp[i+1][j] and dp[i][j+1] (min of bottom and right).\\n so val = min(1,1) = 1;\\n Also we have to reduce the health required to stay in the current cell.\\n val = val - dungeon[i][j] = 1 - (-5) = 6;\\n Now as i explained earlier:\\n dp[i][j] = max(1,val)   => if val is negetive that means we dont have to spend health on this cell so it should be kept minimum i.e. 1.\\n \\n So we had to keep both values 1 as instead of max as for calculating the health for princess\\' cell we only need 1 health minimum. \\n \\n Now let\\'s see for 2nd row 3rd column (one above the princess)\\n val = min(m,6) - 1;   (6 because the dp holds value 6 for princess\\' cell which was calculated earlier)\\n val = 5.\\n dp[1][2] = 5; So when we are at this cell we need health atleast 5. \\n As we will gain 1 health and then move on to the princess\\'s cell giving up  5  health and thus in this way we can calculate all the values. Code contains further explanation.\\n```\\n\\nC++ code: \\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int r = dungeon.size();   // no of rows\\n        if(r == 0) return 0; // if empty then return 0\\n        int c = dungeon[0].size();  // no of columns\\n\\t\\t// DP with r+1 x c+1 dimension and all values initialized to INT_MAX\\n        vector<vector<int>>dp(r+1,vector<int>(c+1,INT_MAX));\\n\\t\\t// Initializing the cell to the bottom and right of princess\\' cell with value 1.\\n        dp[r-1][c] = 1;\\n        dp[r][c-1] = 1;\\n\\t\\tIterating over dp excluding the additional row and column we added.\\n        for(int i=r-1;i>=0;i--){\\n            for(int j=c-1;j>=0;j--){\\n                int val = min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j];  // value is minimum health to land on next - health need to stay\\n                dp[i][j] = max(1,val); // minimum value required is 1. maximum is the +ve value we calculated.\\n            }\\n        }\\n        \\n        return dp[0][0];  // The first element contains the minimum health needed to rescue the princess.\\n    }\\n};\\n```\\n\\nHope you enjoyed the explanation. If any point was not clear feel free to comment below.\\nThank you!",
                "solutionTags": [],
                "code": "```\\n-2 \\t -3\\t   3\\n-5\\t -10   1\\n10\\t  30  -5  <-  when we arrive here our health will be reduced by 5.\\n\\t\\t\\t\\tSo we need minimum 6 health to survive when we reach here. val = (1- (-5) = 6)\\n\\nIf this value was positive we dont need to worry and the minimum energy we need is 1. \\nSuppose the value was +5 then 1-5 = -4.  -4<1 => so ans is 1. i.e max(1,val).\\n```\n```\\n-2  -3   3  m      m -> denotes max \\n-5  10   1  m\\n10  30  -5  1   -> note: we have two value as 1 for the last element (I will explain this as we proceed)\\n m   m   1 m\\n \\n suppose the dimensions of dungeon matirx was \"r x c\", for our dp will be \" r+1 x c+1\".\\n We will start our iteration \\n from the value -5 that is the cell our princess is located.\\n We first have to see which value is minimum from that cell (the one on the right or bottom).\\n i.e. which cell requres less health to travel to\\n for this cell is (one which holds the princess):\\n val = min of dp[i+1][j] and dp[i][j+1] (min of bottom and right).\\n so val = min(1,1) = 1;\\n Also we have to reduce the health required to stay in the current cell.\\n val = val - dungeon[i][j] = 1 - (-5) = 6;\\n Now as i explained earlier:\\n dp[i][j] = max(1,val)   => if val is negetive that means we dont have to spend health on this cell so it should be kept minimum i.e. 1.\\n \\n So we had to keep both values 1 as instead of max as for calculating the health for princess\\' cell we only need 1 health minimum. \\n \\n Now let\\'s see for 2nd row 3rd column (one above the princess)\\n val = min(m,6) - 1;   (6 because the dp holds value 6 for princess\\' cell which was calculated earlier)\\n val = 5.\\n dp[1][2] = 5; So when we are at this cell we need health atleast 5. \\n As we will gain 1 health and then move on to the princess\\'s cell giving up  5  health and thus in this way we can calculate all the values. Code contains further explanation.\\n```\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int r = dungeon.size();   // no of rows\\n        if(r == 0) return 0; // if empty then return 0\\n        int c = dungeon[0].size();  // no of columns\\n\\t\\t// DP with r+1 x c+1 dimension and all values initialized to INT_MAX\\n        vector<vector<int>>dp(r+1,vector<int>(c+1,INT_MAX));\\n\\t\\t// Initializing the cell to the bottom and right of princess\\' cell with value 1.\\n        dp[r-1][c] = 1;\\n        dp[r][c-1] = 1;\\n\\t\\tIterating over dp excluding the additional row and column we added.\\n        for(int i=r-1;i>=0;i--){\\n            for(int j=c-1;j>=0;j--){\\n                int val = min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j];  // value is minimum health to land on next - health need to stay\\n                dp[i][j] = max(1,val); // minimum value required is 1. maximum is the +ve value we calculated.\\n            }\\n        }\\n        \\n        return dp[0][0];  // The first element contains the minimum health needed to rescue the princess.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500016,
                "title": "why-you-can-t-go-from-top-left-to-bottom-right-explained",
                "content": "Many solutions have eloquently explained how you need to solve this (going from bottom right to top left). However, I could not find a clear explanation for why you can\\'t go the other way around, as one would typically do in dp solutions. So I did a little digging and here\\'s what I found.\\n\\nFirst, how would a top-to-bottom solution work? Consider you\\'re at dp[i][j]. To calculate it, the states you would consider are dp[i - 1][j] and dp[i][j - 1] (i.e. one cell up, or one cell to your left) and add the current value nums[i][j] to max(dp[i - 1][j], dp[i][j - 1]) to get dp[i][j]. Howver, this is incorrect since dp[i][j] only tells you the best health at the *current* point. \\n\\nConsider an example, nums (also sample 1 of problem) :\\n[-2,\\t-3,\\t3]\\n[-5,\\t-10,\\t1]\\n[10,\\t30,\\t-5]\\n\\nThe optimal path is shown below (which gives the correct answer, 7) :\\n[**-2**,\\t**-3**,\\t**3**]\\n[-5,\\t-10,\\t**1**]\\n[10,\\t30,\\t**-5**]\\n\\nHowever, if you build a top->down dp, you\\'d get the following path:\\n\\n[**-2**,\\t-3,\\t3]\\n[**-5**,\\t-10,\\t1]\\n[**10**,\\t**30**,\\t**-5**]\\n\\nHere, the final health will be -2 + -5 + 10 + 30 + -5 = 28. And since you\\'re already adding 28 along this path, you might\\'ve as well started with the smallest positive value, namely 1 (which is incorrect)\\n\\nHowever, the problem statement states that at no point can the health be negative or 0 (i.e. it always has to be positive). So even if dp[i][j] is positive, if a previous element in its path was negative, then the current dp value is incorrect. Hence, we need to track the lowest health seen along the most optimal path.\\n\\nIn other words, we need to track the minimum value seen along each *path* leading up to dp[i][j]. Let\\'s do this - define another 2D array called minimum_in_path[][]. minimum_in_path[i][j] tracks the lowest health value that was seen reaching in the path leading up to dp[i][j]. So now instead of considering dp[i - 1][j] and dp[i][j - 1] to calculate dp[i][j], we would use minimum_in_path[i - 1][j], minimum_in_path[i][j - 1] and dp[i][j] to calculate minimum_in_path[i][j]. In other words, we would do the following:\\n```\\nif (minimum_in_path[i - 1][j] >= minimum_in_path[i][j - 1]) {\\n\\tdp[i][j] = dp[i - 1][j] + nums[i][j];\\n\\tminimum_in_path[i][j] = min(minimum_in_path[i - 1][j], dp[i][j]);\\n}\\nelse {\\n\\t// Same as above but use indexes [i][j - 1] instead of [i - 1][j]\\n\\tdp[i][j] = dp[i][j - 1] + nums[i][j];\\n\\tminimum_in_path[i][j] = min(minimum_in_path[i][j - 1], dp[i][j]);\\n}\\n```\\n\\nHowever, even using minimum_in_path[i][j] does not work. This is because you could make a local decision on the path seen so far based on the current minimum values and realize that afterwards the minimum goes down a lot more. So had you known earlier on that the minimum would drop a lot lower, you would\\'ve selected a different path to maximize dp. This is best illustrated with an example.\\n\\nConsider this 3x3 array, nums:\\n[1,  -3,  3]\\n[0,  -2,  0]\\n[-3, -3, -3]\\n\\nHere the right solution is shown in bold (this results in an answer of 3) :\\n[**1**,  **-3**,  **3**]\\n[  0,   -2,  **0**]\\n[-3,   -3, **-3**]\\n\\nHowever, if you choose the path with the maximized minimum value, so as to speak, you\\'d get this path (with an incorrect answer of 5) :\\n[**1**,  -3,  3]\\n[**0**,  **-2**,  **0**]\\n[-3, -3, **-3**]\\n\\nTo understand where this is flawed, consider row 2 and column 3 (1-indexed). minimum_in_path[1][1] is -1, while minimum_in_path[0][2] is -2. dp[1][1] is -1 and dp[0][2] is 1. However, since we are using minimum_in_path to make a decision, dp[1][2] consequently becomes -1 (i.e. dp[1][1] + nums[1][2]) instead of 1 (i.e. dp[0][2] + nums[1][2]). Note that as soon as you go to dp[2][2] (the bottom right node), the minimum along the path goes to -4 (since dp[2][2] = dp[0][2] + nums[2][2] = -1 + (-3) = -4). And since the new minimum is now lower than anything we\\'ve seen, we had unfortunately ignored some better paths that we saw earlier, just because their minimum was low *at that point*.",
                "solutionTags": [],
                "code": "```\\nif (minimum_in_path[i - 1][j] >= minimum_in_path[i][j - 1]) {\\n\\tdp[i][j] = dp[i - 1][j] + nums[i][j];\\n\\tminimum_in_path[i][j] = min(minimum_in_path[i - 1][j], dp[i][j]);\\n}\\nelse {\\n\\t// Same as above but use indexes [i][j - 1] instead of [i - 1][j]\\n\\tdp[i][j] = dp[i][j - 1] + nums[i][j];\\n\\tminimum_in_path[i][j] = min(minimum_in_path[i][j - 1], dp[i][j]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 464716,
                "title": "diego-s-understandable-explanations-c",
                "content": "Hi, I\\'m trying to make easily understandable explanations for everyone. Hopefully I did a good job here.\\n*Please upvote if this post helped you, so that others can find it.*\\n\\n**Why this problem is tricky**\\nIf you\\'ve done a lot of dynamic programming problems, looking at this problem probably immediately set off a few bulbs in your head for how to go about solving it. This is a really good thing, because that means that your instincts are working properly! However, it\\'s possible that they led you nowhere useful, because this problem pushes a little on the formulaic form of dynamic programming problems. Let\\'s see why.\\n\\n**The bigger picture insight**\\nThe problem has start and end locations, and you have to find some start property to meet an end criterion. By far the largest insight of this problem is recognizing that it is better to tackle the problem by starting from what you know, which is the end criterion you must meet, and working towards what you don\\'t know, the start property.\\n\\nThis is important because, usually, simpler dynamic problems are best solved by starting from the start and ending at the end, but that is not the case here. The larger idea is that you should start from what you know and work towards what you don\\'t know, and that it just so happens that in simpler dynamic programming problems those tend to coincide with the start and end, respectively.\\n\\nWith that out of the way, let\\'s talk more about the problem.\\n\\n**The insight**\\nThe problem insight comes from recognizing that it is useful to remember the minimum health you need to exist at a particular location.\\n\\nWhen you\\'re in some room in the dungeon, you need enough health to do two things...\\n* survive the health cost of the room, and\\n* have enough health left over to move to a different room, either right or down.\\n\\nIf we add these two together, the sum represents the amount of health we need to *exist* at a particular location. Luckily, we already know one of these: the amount of health we need to survive the health cost of the room. What about the second one? Let\\'s think about it some more...\\n\\nThe amount of health we need to move to a different room is simply the amount of health we need to *exist* in another room, which is the exact kind of thing we\\'re calculating! This means that we can work backwards from the end, where the princess is, up to the start to get our answers.\\n\\nRemember that since we want to minimize the health we need at the start, of the two actions we can take, going right or down, we will take the one that requires the less amount of health.\\n\\n**But what about the end? You can\\'t move to a different room once you hit the end!**\\nYes, this is correct! That\\'s why we\\'ll have to do something special for the end, and pretend that the cost we need to \"move to a different room\" is 1. This works perfectly because it is the exact same thing as saying that, once we hit the end and paid the associated health cost, we must have at least 1 health left over to be alive! This is the end criterion we need to meet, which we know from the get-go.\\n\\n**Wrapping up**\\nNow that you know to start from the end and to work backwards, you have everything you need to know to arrive at the answer. One more important detail is that if you\\'re at a location where the room itself has a *health benefit* that is high enough that it **pays** for your cost of existence in the less health-demanding, different room, then you know that you only need at least 1 health to exist in that room!\\n\\n**A solution**\\nThis solution can be optimized in some ways for improved performance, but I leave that exercise to the reader.\\n```\\nint calculateMinimumHP(vector<vector<int>>& dungeon) {\\n    int m = dungeon.size(), n = dungeon.front().size();\\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX)); // Maximum penalty so you don\\'t go out of bounds!\\n\\t\\n\\t// The requirement to \"move to a different room\" at the end: you must be alive!\\n    dp[m][n - 1] = 1; dp[m - 1][n] = 1;\\n    for (int i = m - 1; i >= 0; i--) {\\n        for (int j = n - 1; j >= 0; j--) {\\n\\t\\t\\t// Give me the less costly room and add the cost of the current room,\\n\\t\\t\\t// or 1 if the cost for this room (which is actually a benefit) covers the next room!\\n            dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);\\n        }\\n    }\\n\\n    return dp.front().front();\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint calculateMinimumHP(vector<vector<int>>& dungeon) {\\n    int m = dungeon.size(), n = dungeon.front().size();\\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX)); // Maximum penalty so you don\\'t go out of bounds!\\n\\t\\n\\t// The requirement to \"move to a different room\" at the end: you must be alive!\\n    dp[m][n - 1] = 1; dp[m - 1][n] = 1;\\n    for (int i = m - 1; i >= 0; i--) {\\n        for (int j = n - 1; j >= 0; j--) {\\n\\t\\t\\t// Give me the less costly room and add the cost of the current room,\\n\\t\\t\\t// or 1 if the cost for this room (which is actually a benefit) covers the next room!\\n            dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);\\n        }\\n    }\\n\\n    return dp.front().front();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1498367,
                "title": "c-python-2-solutions-binary-search-dp-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Binary Search & DP**\\n- Binary search to choose a `initHealth` of the knight which can survive and reach to the bottom left cell.\\n\\t- Minimum value `left = 1`, maximum value `right = (m+n) * 1000 + 1`  (because in the worst case, value of all cells in the grid is -1000).\\n\\t- `mid = (left + right) / 2`.\\n\\t- If `isGood(mid)` then:\\n\\t\\t- `ans = mid`\\n\\t\\t- `right = mid - 1` // Minimize init health as much as possible\\n\\t- Else:\\n\\t\\t- `left = mid + 1` // Increasing init health\\n- To check `isGood(initHealth)`\\n\\t- The knight has an initial health point in cell (0, 0).\\n\\t- Let `dp[r][c]` denote the maximum health we can get and we can reach from cell (0, 0) to cell (r, c).\\n\\t- Finally, if we found a path which `dp[m-1][n-1] > 0` means the knight can survive successfully which this `initHealth`. \\n\\n<iframe src=\"https://leetcode.com/playground/FGZt54hw/shared\" frameBorder=\"0\" width=\"100%\" height=\"580\"></iframe>\\n\\n**Complexity**\\n- Time: `O(M * N * logR)`, where `M <= 200` is the number of rows, `N <= 200` is the number of columns, `R = 1000 * (m+n)` is the binary search range.\\n- Space: `O(M * N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: DP From Bottom Right cell to Top Left cell**\\n- Let `dpNeedHP[r][c]` denote the amount of HP we need before jumping into cell `(r, c)`.\\n```python\\nclass Solution:\\n    def calculateMinimumHP(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dpNeedHP = [[math.inf] * (n+1) for _ in range(m+1)]\\n        dpNeedHP[m][n-1] = 1\\n        dpNeedHP[m-1][n] = 1\\n        for r in range(m-1, -1, -1):\\n            for c in range(n-1, -1, -1):\\n                need = min(dpNeedHP[r+1][c], dpNeedHP[r][c+1]) - grid[r][c]\\n                dpNeedHP[r][c] = 1 if need <= 0 else need\\n        return dpNeedHP[0][0]\\n```\\n**Complexity**\\n- Time: `O(M * N`, where `M <= 200` is the number of rows, `N <= 200` is the number of columns\\n- Space: `O(M * N)`, we can reuse input `grid` matrix to achieve in O(1) Space.\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def calculateMinimumHP(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dpNeedHP = [[math.inf] * (n+1) for _ in range(m+1)]\\n        dpNeedHP[m][n-1] = 1\\n        dpNeedHP[m-1][n] = 1\\n        for r in range(m-1, -1, -1):\\n            for c in range(n-1, -1, -1):\\n                need = min(dpNeedHP[r+1][c], dpNeedHP[r][c+1]) - grid[r][c]\\n                dpNeedHP[r][c] = 1 if need <= 0 else need\\n        return dpNeedHP[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52897,
                "title": "my-java-solution-with-explanation-in-detail",
                "content": "With a health array to store each grid's health, we should get the result at [0][0].\\n\\nNow the question become to how to create a health array using dungeon.\\n\\ndungeon\\n\\n    -2,-3,3\\n    -5,-10,1\\n    10,30,-5\\n\\nFrom the Dungeon grid, we can simply compute health for the [last row][last column].\\n\\nNow we get\\n\\n    ?,?,?\\n    ?,?,?\\n    ?,?,6\\n\\nNow because the knight can only move rightward or downward in each step, we can compute all the health value for last row from right to left using its rightward neighbor. we can also compute all the health value for last column from bottom to up using its downward neighbor.\\n\\n    ?,?,2\\n    ?,?,5\\n    1,1,6\\n\\nNow, we can compute all the health value using its downward neighbor and rightward neighbor(we use the min value of these 2 health value).\\n\\n    7,5,2\\n    6,11,5\\n    1,1,6\\n\\nNow we get the answer [0][0], which is 7.\\n\\n\\n\\n        public int calculateMinimumHP(int[][] dungeon) {\\n\\n            int row = dungeon.length;\\n            int column = dungeon[0].length;\\n\\n            int[][] tem = new int[row][];\\n            for (int i = 0; i < tem.length; i++) {\\n                tem[i] = new int[column];\\n            }\\n\\n            if (dungeon[row - 1][column - 1] >= 0) {\\n                tem[row - 1][column - 1] = 1;\\n            } else {\\n                tem[row - 1][column - 1] = 1 - dungeon[row - 1][column - 1];\\n            }\\n\\n            for (int i = row - 2; i >= 0; i--) {\\n                tem[i][column - 1] = c(dungeon[i][column - 1],\\n                        tem[i + 1][column - 1]);\\n            }\\n\\n            for (int j = column - 2; j >= 0; j--) {\\n                tem[row - 1][j] = c(dungeon[row - 1][j], tem[row - 1][j + 1]);\\n            }\\n\\n            for (int i = row - 2; i >= 0; i--) {\\n                for (int j = column - 2; j >= 0; j--) {\\n                    tem[i][j] = Math.min(c(dungeon[i][j], tem[i + 1][j]),\\n                            c(dungeon[i][j], tem[i][j + 1]));\\n                }\\n            }\\n\\n            return tem[0][0];\\n        }\\n\\n        private int c(int value, int preResult) {\\n            if (value == 0)\\n                return preResult;\\n\\n            if (value > 0) {\\n                if (value >= preResult)\\n                    return 1;\\n                return preResult - value;\\n            }\\n\\n            return preResult - value;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "With a health array to store each grid's health, we should get the result at [0][0].\\n\\nNow the question become to how to create a health array using dungeon.\\n\\ndungeon\\n\\n    -2,-3,3\\n    -5,-10,1\\n    10,30,-5\\n\\nFrom the Dungeon grid, we can simply compute health for the [last row][last column].\\n\\nNow we get\\n\\n    ?,?,?\\n    ?,?,?\\n    ?,?,6\\n\\nNow because the knight can only move rightward or downward in each step, we can compute all the health value for last row from right to left using its rightward neighbor. we can also compute all the health value for last column from bottom to up using its downward neighbor.\\n\\n    ?,?,2\\n    ?,?,5\\n    1,1,6\\n\\nNow, we can compute all the health value using its downward neighbor and rightward neighbor(we use the min value of these 2 health value).\\n\\n    7,5,2\\n    6,11,5\\n    1,1,6\\n\\nNow we get the answer [0][0], which is 7.\\n\\n\\n\\n        public int calculateMinimumHP(int[][] dungeon) {\\n\\n            int row = dungeon.length;\\n            int column = dungeon[0].length;\\n\\n            int[][] tem = new int[row][];\\n            for (int i = 0; i < tem.length; i++) {\\n                tem[i] = new int[column];\\n            }\\n\\n            if (dungeon[row - 1][column - 1] >= 0) {\\n                tem[row - 1][column - 1] = 1;\\n            } else {\\n                tem[row - 1][column - 1] = 1 - dungeon[row - 1][column - 1];\\n            }\\n\\n            for (int i = row - 2; i >= 0; i--) {\\n                tem[i][column - 1] = c(dungeon[i][column - 1],\\n                        tem[i + 1][column - 1]);\\n            }\\n\\n            for (int j = column - 2; j >= 0; j--) {\\n                tem[row - 1][j] = c(dungeon[row - 1][j], tem[row - 1][j + 1]);\\n            }\\n\\n            for (int i = row - 2; i >= 0; i--) {\\n                for (int j = column - 2; j >= 0; j--) {\\n                    tem[i][j] = Math.min(c(dungeon[i][j], tem[i + 1][j]),\\n                            c(dungeon[i][j], tem[i][j + 1]));\\n                }\\n            }\\n\\n            return tem[0][0];\\n        }\\n\\n        private int c(int value, int preResult) {\\n            if (value == 0)\\n                return preResult;\\n\\n            if (value > 0) {\\n                if (value >= preResult)\\n                    return 1;\\n                return preResult - value;\\n            }\\n\\n            return preResult - value;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 192590,
                "title": "my-intuitive-dp-solution-with-text-and-video-explanation",
                "content": "## LeetCode 174. Dungeon Game\\n### Note\\nIf you prefer video over text, please check out this link: https://www.youtube.com/watch?v=Ir8ePM_gDUk\\nwhich has the same content as follows.\\n### Explanation\\n```java\\n// given the example dungeon, lets label cells as follows: \\n// +-+-+-+\\n// |1|2|3|\\n// +-+-+-+\\n// |4|5|6|\\n// +-+-+-+\\n// |7|8|9|\\n// +-+-+-+\\n\\nThe dungeon:                              Initial HP knight needed:       \\n+-------+-------+-------+                 +-------+-------+-------+\\n|       |       |       |                 |       |       |       |\\n|  -2   |  -3   |   3   |                 |   7   |   5   |   2   |\\n|       |       |       |                 |       |       |       |\\n+-------+-------+-------+                 +-------+-------+-------+\\n|       |       |       |                 |       |       |       |\\n|  -5   |  -10  |   1   |                 |   6   |   11  |   5   |\\n|       |       |       |                 |       |       |       |\\n+-------+-------+-------+                 +-------+-------+-------+\\n|       |       |       |                 |       |       |       |\\n|  10   |  30   |  -5(P)|                 |   1   |   1   |   6   |\\n|       |       |       |                 |       |       |       |\\n+-------+-------+-------+                 +-------+-------+-------+\\n\\nKnight HP: \\n\\n// To solve this problem, we can start with the simpliest cases.\\n// Les\\'s say,\\n\\n// If the knight starts from cell 9.\\nInitial HP: 6 (6 - 5 = 1), which means as long as the knight has 6 HP when reaching cell 9, he would be fine.\\n\\n// If the knight starts from cell 6.\\nInitial HP: 5 (5 + 1 = 6), which means as long as the knight has 5 HP when reaching cell 6, he would be fine.\\n\\n// If the knight starts from cell 8.\\nInitial HP: 1 (1 + 30 >= 6, HP needs to be at least 1, 0 means the knight is already dead), \\nwhich means as long as the kinght has 1 HP when reaching cell 7, he would be fine.\\n\\n// If the knight starts from cell 5.\\nEmm... the knight now has two options, going right or going down.\\nIf go right (5 --> 6 --> 9), Initial HP(R): 15 (15 - 10 = 5)\\nIf go down (5 --> 8 --> 9), Initial HP(D): 11 (11 - 10 = 1)\\nHence, Initial HP = MIN(HP(R), HP(D)) = 11\\n\\n// Sub-problems and state: \\nLet dp[i][j] denote Initial HP needed if the knight starts from dungeon[i][j].\\n\\n// recurrence relation:\\ndp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];\\nif(dp[i][j] <= 0) dp[i][j] = 1;\\n```\\n### Code\\n```java\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if(dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) return 1;\\n        \\n        int N = dungeon.length;\\n        int M = dungeon[0].length;\\n        int[][] dp = new int[N][M];\\n        dp[N - 1][M - 1] = 1 - dungeon[N - 1][M - 1];\\n        dp[N - 1][M - 1] = dp[N - 1][M - 1] <= 0 ? 1 : dp[N - 1][M - 1];\\n            \\n        for(int i = N - 1; i >= 0; --i){\\n            for(int j = M - 1; j >= 0; --j){\\n                if(i == N - 1 && j == M - 1) continue;\\n                int HP_D = i + 1 == N ? Integer.MAX_VALUE : dp[i + 1][j] - dungeon[i][j];\\n                int HP_R = j + 1 == M ? Integer.MAX_VALUE : dp[i][j + 1] - dungeon[i][j];\\n                int HP = Math.min(HP_D, HP_R);\\n                dp[i][j] = HP <= 0 ? 1 : HP;\\n            }    \\n        }\\n        \\n        return dp[0][0] ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n// given the example dungeon, lets label cells as follows: \\n// +-+-+-+\\n// |1|2|3|\\n// +-+-+-+\\n// |4|5|6|\\n// +-+-+-+\\n// |7|8|9|\\n// +-+-+-+\\n\\nThe dungeon:                              Initial HP knight needed:       \\n+-------+-------+-------+                 +-------+-------+-------+\\n|       |       |       |                 |       |       |       |\\n|  -2   |  -3   |   3   |                 |   7   |   5   |   2   |\\n|       |       |       |                 |       |       |       |\\n+-------+-------+-------+                 +-------+-------+-------+\\n|       |       |       |                 |       |       |       |\\n|  -5   |  -10  |   1   |                 |   6   |   11  |   5   |\\n|       |       |       |                 |       |       |       |\\n+-------+-------+-------+                 +-------+-------+-------+\\n|       |       |       |                 |       |       |       |\\n|  10   |  30   |  -5(P)|                 |   1   |   1   |   6   |\\n|       |       |       |                 |       |       |       |\\n+-------+-------+-------+                 +-------+-------+-------+\\n\\nKnight HP: \\n\\n// To solve this problem, we can start with the simpliest cases.\\n// Les\\'s say,\\n\\n// If the knight starts from cell 9.\\nInitial HP: 6 (6 - 5 = 1), which means as long as the knight has 6 HP when reaching cell 9, he would be fine.\\n\\n// If the knight starts from cell 6.\\nInitial HP: 5 (5 + 1 = 6), which means as long as the knight has 5 HP when reaching cell 6, he would be fine.\\n\\n// If the knight starts from cell 8.\\nInitial HP: 1 (1 + 30 >= 6, HP needs to be at least 1, 0 means the knight is already dead), \\nwhich means as long as the kinght has 1 HP when reaching cell 7, he would be fine.\\n\\n// If the knight starts from cell 5.\\nEmm... the knight now has two options, going right or going down.\\nIf go right (5 --> 6 --> 9), Initial HP(R): 15 (15 - 10 = 5)\\nIf go down (5 --> 8 --> 9), Initial HP(D): 11 (11 - 10 = 1)\\nHence, Initial HP = MIN(HP(R), HP(D)) = 11\\n\\n// Sub-problems and state: \\nLet dp[i][j] denote Initial HP needed if the knight starts from dungeon[i][j].\\n\\n// recurrence relation:\\ndp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];\\nif(dp[i][j] <= 0) dp[i][j] = 1;\\n```\n```java\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if(dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) return 1;\\n        \\n        int N = dungeon.length;\\n        int M = dungeon[0].length;\\n        int[][] dp = new int[N][M];\\n        dp[N - 1][M - 1] = 1 - dungeon[N - 1][M - 1];\\n        dp[N - 1][M - 1] = dp[N - 1][M - 1] <= 0 ? 1 : dp[N - 1][M - 1];\\n            \\n        for(int i = N - 1; i >= 0; --i){\\n            for(int j = M - 1; j >= 0; --j){\\n                if(i == N - 1 && j == M - 1) continue;\\n                int HP_D = i + 1 == N ? Integer.MAX_VALUE : dp[i + 1][j] - dungeon[i][j];\\n                int HP_R = j + 1 == M ? Integer.MAX_VALUE : dp[i][j + 1] - dungeon[i][j];\\n                int HP = Math.min(HP_D, HP_R);\\n                dp[i][j] = HP <= 0 ? 1 : HP;\\n            }    \\n        }\\n        \\n        return dp[0][0] ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698961,
                "title": "python-simple-in-place-dp-solution-o-1-space",
                "content": "Traversing from bottom-right to top-left, we calculate how much hp is required to reach the princess from the current cell.\\n\\nThe first step is to calculate how much hp is required to save the princess upon reaching `dungeon[m-1][n-1]`:\\n`dungeon[i][j] = min(dungeon[i][j], 0) * -1 + 1`\\nFor example:\\nIf `dungeon[m-1][n-1] == -5`, then we need 6 hp.\\nIf `dungeon[m-1][n-1] >= 0` then we only need 1 hp.\\n\\nFor every other cell we find the minimum hp required to reach the princess by going either down or right.\\nWe subtract this minimum hp from the current cell\\'s value to find how much hp would be needed to reach the princess from the current cell.\\nIf this value is <=0, we change it to 1 because that means there is an abundance of hp in this cell and our minimum hp can never be <=0.\\n\\n```\\ndef calculateMinimumHP(self, dungeon):\\n\\tm, n = len(dungeon), len(dungeon[0])\\n\\tfor i in range(m-1, -1, -1):\\n\\t\\tfor j in range(n-1, -1, -1):\\n\\t\\t\\tif i == m-1 and j == n-1:\\n\\t\\t\\t\\tdungeon[i][j] = min(dungeon[i][j], 0) * -1 + 1\\n\\t\\t\\telif i == m-1:\\n\\t\\t\\t\\tdungeon[i][j] = max(dungeon[i][j+1] - dungeon[i][j], 1)\\n\\t\\t\\telif j == n-1:\\n\\t\\t\\t\\tdungeon[i][j] = max(dungeon[i+1][j] - dungeon[i][j], 1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdungeon[i][j] = max(min(dungeon[i][j+1], dungeon[i+1][j]) - dungeon[i][j], 1)\\n\\treturn dungeon[0][0]\\n```\\n\\nInspired by [suryan0800\\'s comment](https://leetcode.com/problems/dungeon-game/discuss/698271/Python-Short-DP-7-lines-O(mn)-top-down-explained/588576) and [DBabichev\\'s great explanation](https://leetcode.com/problems/dungeon-game/discuss/698271/Python-Short-DP-7-lines-O(mn)-top-down-explained).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef calculateMinimumHP(self, dungeon):\\n\\tm, n = len(dungeon), len(dungeon[0])\\n\\tfor i in range(m-1, -1, -1):\\n\\t\\tfor j in range(n-1, -1, -1):\\n\\t\\t\\tif i == m-1 and j == n-1:\\n\\t\\t\\t\\tdungeon[i][j] = min(dungeon[i][j], 0) * -1 + 1\\n\\t\\t\\telif i == m-1:\\n\\t\\t\\t\\tdungeon[i][j] = max(dungeon[i][j+1] - dungeon[i][j], 1)\\n\\t\\t\\telif j == n-1:\\n\\t\\t\\t\\tdungeon[i][j] = max(dungeon[i+1][j] - dungeon[i][j], 1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdungeon[i][j] = max(min(dungeon[i][j+1], dungeon[i+1][j]) - dungeon[i][j], 1)\\n\\treturn dungeon[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 52887,
                "title": "sharing-my-solution-with-o-n-space-o-mn-runtime",
                "content": "Here is my solution using dp and rolling array --Dungeon Game:\\n\\n    int calculateMinimumHP(vector<vector<int> > &dungeon) {\\n        const int m = dungeon.size();\\n        const int n = dungeon[0].size();\\n        vector<int> dp(n + 1, INT_MAX);\\n        dp[n - 1] = 1; \\n        for(int i = m - 1; i >= 0; --i)\\n            for(int j = n - 1; j >= 0; --j)\\n                dp[j] = getMin(min(dp[j], dp[j + 1]) - dungeon[i][j]);\\n        return dp[0];\\n    }\\n    int getMin(int n){\\n        return n <= 0 ? 1 : n;\\n    }\\n\\nNote: Update from right to left and from bottom up.",
                "solutionTags": [],
                "code": "Here is my solution using dp and rolling array --Dungeon Game:\\n\\n    int calculateMinimumHP(vector<vector<int> > &dungeon) {\\n        const int m = dungeon.size();\\n        const int n = dungeon[0].size();\\n        vector<int> dp(n + 1, INT_MAX);\\n        dp[n - 1] = 1; \\n        for(int i = m - 1; i >= 0; --i)\\n            for(int j = n - 1; j >= 0; --j)\\n                dp[j] = getMin(min(dp[j], dp[j + 1]) - dungeon[i][j]);\\n        return dp[0];\\n    }\\n    int getMin(int n){\\n        return n <= 0 ? 1 : n;\\n    }\\n\\nNote: Update from right to left and from bottom up.",
                "codeTag": "Unknown"
            },
            {
                "id": 3055960,
                "title": "handwritten-step-by-step-in-detail-dry-run-fully-commented-recursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![Screenshot_20230116_004830.png](https://assets.leetcode.com/users/images/b31c29d9-b217-45a1-95cb-73368eb4d077_1673810770.2499864.png)\\n![Screenshot_20230116_004905.png](https://assets.leetcode.com/users/images/d9521ce1-cf60-4f84-ac86-fa5cbb071c18_1673810784.8820758.png)\\n![Screenshot_20230116_004918.png](https://assets.leetcode.com/users/images/b9d9f8a6-b62e-4148-ac02-cef4ba42a3b8_1673810798.7564626.png)\\n![Screenshot_20230116_004927.png](https://assets.leetcode.com/users/images/a31b74a2-2b6f-4db8-9f4b-1a2de346e11c_1673810815.7368083.png)\\n![Screenshot_20230116_005814.png](https://assets.leetcode.com/users/images/20f8a03b-5229-451f-87ce-ce76f5824c95_1673810910.7959452.png)\\n\\n# Complexity\\n- Time complexity: O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(M*N) + Stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //this recursive fuction will return the min amount of health that the knight needs in the future\\n    //to rescue the queen\\n    int future(int row,int col,vector<vector<int>>& arr,vector<vector<int>>&dp)\\n    {\\n        int r=arr.size();\\n        int c=arr[0].size();\\n        //base case: if the knight goes out of the dungeon\\n        if(row>=r || col>=c)\\n            return 1e9;//very large number so that the knight does not choose this future health\\n\\n        if(row==r-1 && col==c-1)//knight has reached the queen\\n        {\\n            if(arr[row][col]>=0)//knight will not recure any additional health as he will gain health\\n                return dp[row][col]= 1;\\n            else //knight must enter this cell with additional health of +1 to survive\\n                return dp[row][col]= abs(arr[row][col])+1;\\n        }\\n        if(dp[row][col]!=-1)\\n            return dp[row][col];\\n        int future_health_left=future(row,col+1,arr,dp);//the min amount of health he will need to survive the left path\\n        int future_health_down=future(row+1,col,arr,dp);//the min amount of health he will need to survive the down path\\n        int future_health=min(future_health_down,future_health_left);//he will go to the path that will require the minimum health\\n        int health_gain=arr[row][col];//the health he gained or lost in this cell\\n        int health_needed=future_health-health_gain;//the min health he requires to survive cell as well as his chosen path\\n        if(health_needed>0)//he needed additional health to survive this cell as well as this chosen future path\\n            return dp[row][col]= health_needed;\\n        else//he gained health in this cell and he did not require health \\n            return dp[row][col]= 1;\\n    }\\n    int calculateMinimumHP(vector<vector<int>>&arr) \\n    {\\n        int r=arr.size();\\n        int c=arr[0].size();\\n        vector<vector<int>>dp(r,vector<int>(c,-1));//stores the future required health\\n        return future(0,0,arr,dp);\\n    }\\n};\\n```\\n**Please upvote. It takes a lot of effort to make such solutions :)**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //this recursive fuction will return the min amount of health that the knight needs in the future\\n    //to rescue the queen\\n    int future(int row,int col,vector<vector<int>>& arr,vector<vector<int>>&dp)\\n    {\\n        int r=arr.size();\\n        int c=arr[0].size();\\n        //base case: if the knight goes out of the dungeon\\n        if(row>=r || col>=c)\\n            return 1e9;//very large number so that the knight does not choose this future health\\n\\n        if(row==r-1 && col==c-1)//knight has reached the queen\\n        {\\n            if(arr[row][col]>=0)//knight will not recure any additional health as he will gain health\\n                return dp[row][col]= 1;\\n            else //knight must enter this cell with additional health of +1 to survive\\n                return dp[row][col]= abs(arr[row][col])+1;\\n        }\\n        if(dp[row][col]!=-1)\\n            return dp[row][col];\\n        int future_health_left=future(row,col+1,arr,dp);//the min amount of health he will need to survive the left path\\n        int future_health_down=future(row+1,col,arr,dp);//the min amount of health he will need to survive the down path\\n        int future_health=min(future_health_down,future_health_left);//he will go to the path that will require the minimum health\\n        int health_gain=arr[row][col];//the health he gained or lost in this cell\\n        int health_needed=future_health-health_gain;//the min health he requires to survive cell as well as his chosen path\\n        if(health_needed>0)//he needed additional health to survive this cell as well as this chosen future path\\n            return dp[row][col]= health_needed;\\n        else//he gained health in this cell and he did not require health \\n            return dp[row][col]= 1;\\n    }\\n    int calculateMinimumHP(vector<vector<int>>&arr) \\n    {\\n        int r=arr.size();\\n        int c=arr[0].size();\\n        vector<vector<int>>dp(r,vector<int>(c,-1));//stores the future required health\\n        return future(0,0,arr,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52859,
                "title": "simple-java-dp-code",
                "content": "     public int calculateMinimumHP(int[][] dungeon) {\\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        //dp[i][j] represents the minimum health points needed at position (i,j) and\\n        //the last row or column is just dummy (outside of the range).\\n        int[][] dp = new int[m+1][n+1];\\n        \\n        //Initialize the matrix to maximum possible.\\n        for (int i = 0; i <= m; i++)\\n        \\tArrays.fill(dp[i], Integer.MAX_VALUE);\\n        \\n        //initializing the boundary.\\n        dp[m][n-1] = 1; dp[m-1][n] = 1; \\n        \\n        for (int i = m-1; i >= 0; i--) {\\n        \\tfor (int j = n-1; j >= 0; j--) {\\n        \\t\\tint minHp = Math.min(dp[i+1][j], dp[i][j+1])  - dungeon[i][j];\\n        \\t\\tdp[i][j] = (minHp <= 0) ? 1 : minHp;\\n        \\t}\\n        }\\n        return dp[0][0];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "     public int calculateMinimumHP(int[][] dungeon) {\\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        //dp[i][j] represents the minimum health points needed at position (i,j) and\\n        //the last row or column is just dummy (outside of the range).\\n        int[][] dp = new int[m+1][n+1];\\n        \\n        //Initialize the matrix to maximum possible.\\n        for (int i = 0; i <= m; i++)\\n        \\tArrays.fill(dp[i], Integer.MAX_VALUE);\\n        \\n        //initializing the boundary.\\n        dp[m][n-1] = 1; dp[m-1][n] = 1; \\n        \\n        for (int i = m-1; i >= 0; i--) {\\n        \\tfor (int j = n-1; j >= 0; j--) {\\n        \\t\\tint minHp = Math.min(dp[i+1][j], dp[i][j+1])  - dungeon[i][j];\\n        \\t\\tdp[i][j] = (minHp <= 0) ? 1 : minHp;\\n        \\t}\\n        }\\n        return dp[0][0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2704445,
                "title": "100-best-solution-explained-c-c-recursion-dp-memoization-dp-tabulation",
                "content": "if you like the solution please remember to upvote this blog \\uD83E\\uDD7A\\n\\n![image](https://assets.leetcode.com/users/images/49afdc7c-c5af-4330-bb30-26a6fe4ebba7_1665935047.5086565.gif)\\n\\n```\\n// TODO : Dungeon Game\\n    // brute force : TLE\\n        class Solution {\\n        public:\\n            int pre(int i,int j,int n,int m,vector<vector<int>>& arr){\\n                if(i >= n+1 or j >= m+1) return 1e9;\\n                if(i == n and j == m) return arr[i][j] > 0 ? 1 : 1 - arr[i][j];\\n\\n                int down = pre(i+1,j,n,m,arr);\\n                int right = pre(i,j+1,n,m,arr);\\n                int res = min(down,right)-arr[i][j];\\n                return res > 0 ? res : 1;\\n            }\\n            int calculateMinimumHP(vector<vector<int>>& arr) {\\n                int n = arr.size(), m = arr[0].size();\\n                vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n                return pre(0,0,n-1,m-1,arr);\\n            }\\n        };\\n\\n    // memorization\\n        class Solution {\\n        public:\\n            int pre(int i,int j,int n,int m,vector<vector<int>>& arr,vector<vector<int>> &dp){\\n                if(i >= n+1 or j >= m+1) return 1e9;\\n                if(i == n and j == m) return arr[i][j] > 0 ? 1 : 1 - arr[i][j];\\n                if(dp[i][j] != -1) return dp[i][j];\\n                \\n                int down = pre(i+1,j,n,m,arr,dp);\\n                int right = pre(i,j+1,n,m,arr,dp);\\n                int res = min(down,right)-arr[i][j];\\n                return dp[i][j] = res > 0 ? res : 1;\\n            }\\n            int calculateMinimumHP(vector<vector<int>>& arr) {\\n                int n = arr.size(), m = arr[0].size();\\n                vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n                return pre(0,0,n-1,m-1,arr,dp);\\n            }\\n        };\\n\\n    // Tabulation    \\n        class Solution {\\n        public:\\n            int calculateMinimumHP(vector<vector<int>>& arr) {\\n                int n = arr.size(), m = arr[0].size();\\n                vector<vector<int>> dp(n+1,vector<int> (m+1,0));\\n                \\n                for(int i=n;i>=0;i--){ dp[i][m] = 1e9; }\\n                for(int j=m;j>=0;j--){ dp[n][j] = 1e9; }\\n                \\n                for(int i=n-1;i>=0;i--){\\n                    for(int j=m-1;j>=0;j--){\\n                        if(i == n-1 and j==m-1){\\n                            dp[i][j] = arr[i][j] > 0 ? 1 : 1 - arr[i][j];\\n                            continue;\\n                        }\\n                        int down = dp[i+1][j];\\n                        int right = dp[i][j+1];\\n                        int res = min(down,right) - arr[i][j];\\n                        dp[i][j] = res > 0 ? res : 1;\\n                    }\\n                }\\n                \\n                return dp[0][0];\\n            }\\n        };\\n\\n    // optimize 2d\\n        class Solution {\\n        public:\\n            int calculateMinimumHP(vector<vector<int>>& arr) {\\n                int n = arr.size(), m = arr[0].size();\\n                vector<int> dp(m+1,1e9),curr(m+1,0);\\n                curr[m] = 1e9;\\n                \\n                for(int i=n-1;i>=0;i--){\\n                    for(int j=m-1;j>=0;j--){\\n                        if(i == n-1 and j==m-1){\\n                            curr[j] = arr[i][j] > 0 ? 1 : 1 - arr[i][j];\\n                            continue;\\n                        }\\n                        int down = dp[j];\\n                        int right = curr[j+1];\\n                        int res = min(down,right) - arr[i][j];\\n                        curr[j] = res > 0 ? res : 1;\\n                    }\\n                    dp = curr;\\n                }\\n                \\n                return dp[0];\\n            }\\n        };\\n\\n    // optimize 1d\\n        class Solution {\\n        public:\\n            int calculateMinimumHP(vector<vector<int>>& arr) {\\n                int n = arr.size(), m = arr[0].size();\\n                vector<int> dp(m+1,1e9);\\n                \\n                for(int i=n-1;i>=0;i--){\\n                    for(int j=m-1;j>=0;j--){\\n                        if(i == n-1 and j==m-1){\\n                            dp[j] = arr[i][j] > 0 ? 1 : 1 - arr[i][j];\\n                            continue;\\n                        }\\n                        int down = dp[j];\\n                        int right = dp[j+1];\\n                        int res = min(down,right) - arr[i][j];\\n                        dp[j] = res > 0 ? res : 1;\\n                    }\\n                }\\n                \\n                return dp[0];\\n            }\\n        };\\n```\\n\\nThank u for Upvoting\\n\\n![image](https://assets.leetcode.com/users/images/9b9093f9-0191-490e-b14d-891b5a933ffb_1665935057.2284648.gif)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// TODO : Dungeon Game\\n    // brute force : TLE\\n        class Solution {\\n        public:\\n            int pre(int i,int j,int n,int m,vector<vector<int>>& arr){\\n                if(i >= n+1 or j >= m+1) return 1e9;\\n                if(i == n and j == m) return arr[i][j] > 0 ? 1 : 1 - arr[i][j];\\n\\n                int down = pre(i+1,j,n,m,arr);\\n                int right = pre(i,j+1,n,m,arr);\\n                int res = min(down,right)-arr[i][j];\\n                return res > 0 ? res : 1;\\n            }\\n            int calculateMinimumHP(vector<vector<int>>& arr) {\\n                int n = arr.size(), m = arr[0].size();\\n                vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n                return pre(0,0,n-1,m-1,arr);\\n            }\\n        };\\n\\n    // memorization\\n        class Solution {\\n        public:\\n            int pre(int i,int j,int n,int m,vector<vector<int>>& arr,vector<vector<int>> &dp){\\n                if(i >= n+1 or j >= m+1) return 1e9;\\n                if(i == n and j == m) return arr[i][j] > 0 ? 1 : 1 - arr[i][j];\\n                if(dp[i][j] != -1) return dp[i][j];\\n                \\n                int down = pre(i+1,j,n,m,arr,dp);\\n                int right = pre(i,j+1,n,m,arr,dp);\\n                int res = min(down,right)-arr[i][j];\\n                return dp[i][j] = res > 0 ? res : 1;\\n            }\\n            int calculateMinimumHP(vector<vector<int>>& arr) {\\n                int n = arr.size(), m = arr[0].size();\\n                vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n                return pre(0,0,n-1,m-1,arr,dp);\\n            }\\n        };\\n\\n    // Tabulation    \\n        class Solution {\\n        public:\\n            int calculateMinimumHP(vector<vector<int>>& arr) {\\n                int n = arr.size(), m = arr[0].size();\\n                vector<vector<int>> dp(n+1,vector<int> (m+1,0));\\n                \\n                for(int i=n;i>=0;i--){ dp[i][m] = 1e9; }\\n                for(int j=m;j>=0;j--){ dp[n][j] = 1e9; }\\n                \\n                for(int i=n-1;i>=0;i--){\\n                    for(int j=m-1;j>=0;j--){\\n                        if(i == n-1 and j==m-1){\\n                            dp[i][j] = arr[i][j] > 0 ? 1 : 1 - arr[i][j];\\n                            continue;\\n                        }\\n                        int down = dp[i+1][j];\\n                        int right = dp[i][j+1];\\n                        int res = min(down,right) - arr[i][j];\\n                        dp[i][j] = res > 0 ? res : 1;\\n                    }\\n                }\\n                \\n                return dp[0][0];\\n            }\\n        };\\n\\n    // optimize 2d\\n        class Solution {\\n        public:\\n            int calculateMinimumHP(vector<vector<int>>& arr) {\\n                int n = arr.size(), m = arr[0].size();\\n                vector<int> dp(m+1,1e9),curr(m+1,0);\\n                curr[m] = 1e9;\\n                \\n                for(int i=n-1;i>=0;i--){\\n                    for(int j=m-1;j>=0;j--){\\n                        if(i == n-1 and j==m-1){\\n                            curr[j] = arr[i][j] > 0 ? 1 : 1 - arr[i][j];\\n                            continue;\\n                        }\\n                        int down = dp[j];\\n                        int right = curr[j+1];\\n                        int res = min(down,right) - arr[i][j];\\n                        curr[j] = res > 0 ? res : 1;\\n                    }\\n                    dp = curr;\\n                }\\n                \\n                return dp[0];\\n            }\\n        };\\n\\n    // optimize 1d\\n        class Solution {\\n        public:\\n            int calculateMinimumHP(vector<vector<int>>& arr) {\\n                int n = arr.size(), m = arr[0].size();\\n                vector<int> dp(m+1,1e9);\\n                \\n                for(int i=n-1;i>=0;i--){\\n                    for(int j=m-1;j>=0;j--){\\n                        if(i == n-1 and j==m-1){\\n                            dp[j] = arr[i][j] > 0 ? 1 : 1 - arr[i][j];\\n                            continue;\\n                        }\\n                        int down = dp[j];\\n                        int right = dp[j+1];\\n                        int res = min(down,right) - arr[i][j];\\n                        dp[j] = res > 0 ? res : 1;\\n                    }\\n                }\\n                \\n                return dp[0];\\n            }\\n        };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52843,
                "title": "6-lines-16-ms-c-o-mn-time-o-n-space",
                "content": "    struct Solution {\\n        int calculateMinimumHP(vector<vector<int>>& d) {\\n            vector<int> dp(d.size() + 1, INT_MAX);\\n            dp[d.size() - 1] = 1;\\n            for (int i = d[0].size() - 1; i >= 0; --i)\\n                for (int j = d.size() - 1; j >= 0; --j)\\n                    dp[j] = max(1, min(dp[j + 1], dp[j]) - d[j][i]);\\n            return dp[0];\\n        }\\n    };",
                "solutionTags": [],
                "code": "    struct Solution {\\n        int calculateMinimumHP(vector<vector<int>>& d) {\\n            vector<int> dp(d.size() + 1, INT_MAX);\\n            dp[d.size() - 1] = 1;\\n            for (int i = d[0].size() - 1; i >= 0; --i)\\n                for (int j = d.size() - 1; j >= 0; --j)\\n                    dp[j] = max(1, min(dp[j + 1], dp[j]) - d[j][i]);\\n            return dp[0];\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 52792,
                "title": "6-lines-python-8-lines-ruby",
                "content": "Just some DP.\\n\\n---\\n\\n**Python**\\n\\n    def calculateMinimumHP(self, dungeon):\\n        n = len(dungeon[0])\\n        need = [2**31] * (n-1) + [1]\\n        for row in dungeon[::-1]:\\n            for j in range(n)[::-1]:\\n                need[j] = max(min(need[j:j+2]) - row[j], 1)\\n        return need[0]\\n\\nGot accepted in 52 ms, faster than all other recent Python submissions (best was 56 ms, achieved by 5.7692%).\\n\\n---\\n\\n**Ruby**\\n\\n    def calculate_minimum_hp(dungeon)\\n        n = dungeon[0].size - 1\\n        need = [1/0.0] * n + [1]\\n        dungeon.reverse_each do |row|\\n            n.downto(0) do |j|\\n                need[j] = [need[j..j+1].min - row[j], 1].max\\n            end\\n        end\\n        need[0]\\n    end",
                "solutionTags": [
                    "Python",
                    "Ruby"
                ],
                "code": "Just some DP.\\n\\n---\\n\\n**Python**\\n\\n    def calculateMinimumHP(self, dungeon):\\n        n = len(dungeon[0])\\n        need = [2**31] * (n-1) + [1]\\n        for row in dungeon[::-1]:\\n            for j in range(n)[::-1]:\\n                need[j] = max(min(need[j:j+2]) - row[j], 1)\\n        return need[0]\\n\\nGot accepted in 52 ms, faster than all other recent Python submissions (best was 56 ms, achieved by 5.7692%).\\n\\n---\\n\\n**Ruby**\\n\\n    def calculate_minimum_hp(dungeon)\\n        n = dungeon[0].size - 1\\n        need = [1/0.0] * n + [1]\\n        dungeon.reverse_each do |row|\\n            n.downto(0) do |j|\\n                need[j] = [need[j..j+1].min - row[j], 1].max\\n            end\\n        end\\n        need[0]\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 1498636,
                "title": "c-solution-with-image-explaination",
                "content": "# Logic behind\\nEx. `dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]`\\nWe know that we start from left-top of the grid and we can only go right on down\\n![image](https://assets.leetcode.com/users/images/ad58c7dd-e805-43cb-a36e-29bfa3849456_1633168629.339159.png)\\nsame for each cell\\n![image](https://assets.leetcode.com/users/images/f801f1c8-4f17-482c-a722-b45ee6dfc671_1633168672.6553586.png)\\nNow if we think in the opposite way (so from the end point). since it is the end point we don\\'t need to go right or bottom, we just need to take this value\\n![image](https://assets.leetcode.com/users/images/adbd7e6e-9bc3-40b9-abe4-159942ed6b08_1633169767.3472998.png)\\nThen we go to the cell beside that end point and find the max(right and bottom cell) (**remember that we have to take the cell that gives more health, or lose less health)**, we have to do it for each cell (**remember we are doing it in opposite way, so last cell then second-last and so on**)\\n![image](https://assets.leetcode.com/users/images/e20bee0d-626a-42ea-923f-7eba1adbd382_1633169279.014217.png)\\nWe notice that in our case for `30` `10` we can\\'t take any value from bottom (It\\'s out of range) to avoid this error we set our dp bigger that dungeon and set them equal to INT_MIN (so it will never take those value). **Yellow cells are cells that I add to avoid error**\\n![image](https://assets.leetcode.com/users/images/babbabd3-e593-4fc6-a708-20f714666bb1_1633170411.4298382.png)\\nWe have to set the end point of dungeon to our dp (because as I said for the end point we don\\'t need to find the max(right,bottom), what we have to do is take this value)![image](https://assets.leetcode.com/users/images/b2ad905e-51cf-441d-bdeb-dafbc2b5a4d3_1633171035.4803393.png)\\n![image](https://assets.leetcode.com/users/images/73a9782a-a5e7-42a0-915b-d28d07ca37e3_1633170932.9055116.png)+\\nGo to the next (second-last) and find the max(right,bottom) + the value of current cell in dungeon\\n![image](https://assets.leetcode.com/users/images/6bc4ce05-7ba9-4de5-a48f-131d568f3721_1633171097.4836278.png)\\nThe result of this cell is 30 - 5 =25. But since we are doing in the opposite way we have to keep in mind that these \"healths\" it\\'s valid only for this cell and next one (the end point) so it means that we can\\'t use these healths for the cell on the left and top. So, we have to change it to 0 (means that from this cell to the end point I don\\'t need to lost any health).\\n![image](https://assets.leetcode.com/users/images/548fe008-f25d-4fa6-9d14-9cc7c4feecbc_1633171283.567383.png)\\nApply the same login with each cell \\n![image](https://assets.leetcode.com/users/images/23d5fb90-b704-4063-acaa-6c34cd21569e_1633171357.4401152.png)\\nSet to 0 (same concept as mentio before)\\n![image](https://assets.leetcode.com/users/images/108ebb14-1b39-481b-b03b-f84759b677f8_1633171373.5899377.png)\\nmin(right,bottom)\\n![image](https://assets.leetcode.com/users/images/05fb74a2-9f3e-4a3b-ad81-5bf8b63c3791_1633171482.341811.png)\\nThis time we don\\'t neet to set to 0 because in this case we have -4 which means that from this cell to the end point we have to lose 4 health\\n![image](https://assets.leetcode.com/users/images/f4e7cd0e-bf16-4539-adde-cb2a1d484e9d_1633171609.94062.png)\\nmax(right,bottom)\\n![image](https://assets.leetcode.com/users/images/7299fcf3-8b53-446f-b9df-b823689d361e_1633171720.3263557.png)\\n![image](https://assets.leetcode.com/users/images/9f6526e5-0bdd-45c0-9292-1fee25eec2f8_1633171771.464397.png)\\n![image](https://assets.leetcode.com/users/images/a5730df3-bced-48ce-b12d-8388009657ae_1633171811.8350272.png)\\n![image](https://assets.leetcode.com/users/images/414621dc-9402-4fb3-a7c1-616594480f87_1633171914.3503778.png)\\n![image](https://assets.leetcode.com/users/images/f6d6fb12-08cb-4ff0-be8a-89f2b8936dc2_1633172073.7771344.png)\\n![image](https://assets.leetcode.com/users/images/44f17f58-d0f3-47e7-9c34-57b24e865174_1633172170.1919072.png)\\n![image](https://assets.leetcode.com/users/images/12e7e3f5-c0d7-412c-bf08-d0cbc7b0f430_1633172199.5677192.png)\\n**We have to lost at least 6 health to reach the end point.** But remember that we need at least 1health, otherwise the knight dies. So we need to have health that we will lost + 1 = 6 + 1 = 7\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size(), n = dungeon[0].size();\\n\\n        //set the size of dp bigger thatn dungeon (to avoid error when I need d[[i+1][j] or dp[i][j+1])\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MIN));\\n\\n        //initialize the dp[m - 1][n - 1] which is the last value of dungeon\\n        //we have to initialize it because this value is the unique value which you don\\'t need to \"take\" from other\\n        //we just have to take the value that is in dungeon  \\n        dp[m - 1][n - 1] = dungeon[m - 1][n - 1];\\n        if (dp[m - 1][n - 1] > 0)dp[m - 1][n - 1] = 0;\\n\\n        //start to fill the dp\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (i == m - 1 && j == n - 1)continue;\\n                dp[i][j] = max(dp[i][j + 1], dp[i + 1][j]) + dungeon[i][j];\\n                if (dp[i][j] > 0)dp[i][j] = 0;\\n            }\\n        }\\n\\n        //since in dp we saved how many health we spent to arrive to the end point in negative we have to change it in positive\\n        //to make sure that we don\\'t die we need at least 1 health, so health that we have to spent + 1\\n        return (dp[0][0] * -1) + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size(), n = dungeon[0].size();\\n\\n        //set the size of dp bigger thatn dungeon (to avoid error when I need d[[i+1][j] or dp[i][j+1])\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MIN));\\n\\n        //initialize the dp[m - 1][n - 1] which is the last value of dungeon\\n        //we have to initialize it because this value is the unique value which you don\\'t need to \"take\" from other\\n        //we just have to take the value that is in dungeon  \\n        dp[m - 1][n - 1] = dungeon[m - 1][n - 1];\\n        if (dp[m - 1][n - 1] > 0)dp[m - 1][n - 1] = 0;\\n\\n        //start to fill the dp\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (i == m - 1 && j == n - 1)continue;\\n                dp[i][j] = max(dp[i][j + 1], dp[i + 1][j]) + dungeon[i][j];\\n                if (dp[i][j] > 0)dp[i][j] = 0;\\n            }\\n        }\\n\\n        //since in dp we saved how many health we spent to arrive to the end point in negative we have to change it in positive\\n        //to make sure that we don\\'t die we need at least 1 health, so health that we have to spent + 1\\n        return (dp[0][0] * -1) + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404174,
                "title": "easy-python3-solution",
                "content": "Not pretending for unique solution, but I hope that my code will be easy to understand.\\n\\nThe main idea is that we go reversed and compare ``max(1, min(previous_cells_values))``. That\\'s the key. \\n\\nWhy do we compare max with 1? Because we don\\'t need extra 30 hp, only 1 to be alive.\\n\\n\\n```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        \\n        rows, columns = len(dungeon), len(dungeon[0])\\n        hp = [[0]*columns for i in range(rows)]\\n        \\n        \\n        # We will start at endpoint:\\n        hp[-1][-1] = max(1, 1-dungeon[-1][-1]) # in example we will need 6 HP to cover -5 loss\\n        \\n        # Completing the border lines. Excluding endpoint everywhere\\n        for i in range(rows-2, -1,-1):\\n            hp[i][-1] = max(1, \\n                            hp[i+1][-1] - dungeon[i][-1])  \\n        for j in range(columns-2, -1, -1): \\n            hp[-1][j] = max(1, \\n                            hp[-1][j+1] - dungeon[-1][j])\\n        \\n        # print(hp) to see our HealthPoint table\\n        \\n\\t\\t\\n        # Next we complete the remaining table\\n        for i in range(rows-2, -1, -1):\\n            for j in range(columns-2, -1, -1):                \\n                hp[i][j] = max(1, min(hp[i+1][j] - dungeon[i][j], \\n                                      hp[i][j+1] - dungeon[i][j]) )\\n        \\n        return hp[0][0]\\n```\\n\\nRuntime: 80 ms, faster than 89.23% of Python3 online submissions for Dungeon Game.\\nMemory Usage: 15 MB, less than 11.11% of Python3 online submissions for Dungeon Game.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        \\n        rows, columns = len(dungeon), len(dungeon[0])\\n        hp = [[0]*columns for i in range(rows)]\\n        \\n        \\n        # We will start at endpoint:\\n        hp[-1][-1] = max(1, 1-dungeon[-1][-1]) # in example we will need 6 HP to cover -5 loss\\n        \\n        # Completing the border lines. Excluding endpoint everywhere\\n        for i in range(rows-2, -1,-1):\\n            hp[i][-1] = max(1, \\n                            hp[i+1][-1] - dungeon[i][-1])  \\n        for j in range(columns-2, -1, -1): \\n            hp[-1][j] = max(1, \\n                            hp[-1][j+1] - dungeon[-1][j])\\n        \\n        # print(hp) to see our HealthPoint table\\n        \\n\\t\\t\\n        # Next we complete the remaining table\\n        for i in range(rows-2, -1, -1):\\n            for j in range(columns-2, -1, -1):                \\n                hp[i][j] = max(1, min(hp[i+1][j] - dungeon[i][j], \\n                                      hp[i][j+1] - dungeon[i][j]) )\\n        \\n        return hp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52857,
                "title": "a-12-ms-c-solution-dp",
                "content": "This problem is quite like #64 Minimum Path Sum.\\n\\nThe trick is where is the Starting point. This problem ask us to find the least hp in top-left. So in the most optimistic situation, bottom-right value can be determined as 1. Then bottom-right is the starting point.\\n\\n    int calculateMinimumHP(vector<vector<int>>& dun) \\n    {\\n    \\tif (!dun.size() || !dun[0].size())\\n    \\t\\treturn 1;\\n    \\tint nrow = dun.size();\\n    \\tint ncol = dun[0].size();\\n    \\tvector<int> row(ncol + 1, INT_MAX);\\n    \\trow[ncol - 1] = 1;\\n    \\tint i, j, t;\\n    \\tfor (i = nrow - 1; i >= 0; --i)\\n    \\t{\\n    \\t\\tfor (j = ncol - 1; j >= 0; --j)\\n    \\t\\t{\\n    \\t\\t\\tt = min(row[j], row[j + 1]) - dun[i][j];\\n    \\t\\t\\trow[j] = max(t, 1); //row[j]=smaller value from below and right, but no smaller than 1.\\n    \\t\\t}\\n    \\t}\\n    \\treturn row[0];\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "This problem is quite like #64 Minimum Path Sum.\\n\\nThe trick is where is the Starting point. This problem ask us to find the least hp in top-left. So in the most optimistic situation, bottom-right value can be determined as 1. Then bottom-right is the starting point.\\n\\n    int calculateMinimumHP(vector<vector<int>>& dun) \\n    {\\n    \\tif (!dun.size() || !dun[0].size())\\n    \\t\\treturn 1;\\n    \\tint nrow = dun.size();\\n    \\tint ncol = dun[0].size();\\n    \\tvector<int> row(ncol + 1, INT_MAX);\\n    \\trow[ncol - 1] = 1;\\n    \\tint i, j, t;\\n    \\tfor (i = nrow - 1; i >= 0; --i)\\n    \\t{\\n    \\t\\tfor (j = ncol - 1; j >= 0; --j)\\n    \\t\\t{\\n    \\t\\t\\tt = min(row[j], row[j + 1]) - dun[i][j];\\n    \\t\\t\\trow[j] = max(t, 1); //row[j]=smaller value from below and right, but no smaller than 1.\\n    \\t\\t}\\n    \\t}\\n    \\treturn row[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52899,
                "title": "a-simple-c-solution-using-binary-search",
                "content": "<code> \\n  \\n    class Solution {\\n    public:\\n        int calculateMinimumHP(vector<vector<int> > &dungeon) {\\n            int N = dungeon.size();\\n            int M = dungeon[0].size();\\n    \\n            // just pick a simple path through the dungeon to obtain an upperbound\\n            int lowerbound = 0;\\n            int upperbound = 1;\\n            for (int i = 0; i < M; i++) {\\n                int val = dungeon[0][i];\\n                if (val < 0) upperbound += (-val);\\n            }\\n            for (int i = 0; i < N; i++) {\\n                int val = dungeon[i][M - 1];\\n                if (val < 0) upperbound += (-val);\\n            }\\n    \\n            // A number so small impossible to come back alive from\\n            static const int64_t dead = numeric_limits<int64_t>::min() / 3;\\n    \\n            // Binary search looking for the smallest starting health which we\\n            // survive from. Invariant we maintain is lowerbound dies and\\n            // upperbound survives\\n            while (lowerbound < upperbound - 1) {\\n                int mid = (upperbound - lowerbound) / 2 + lowerbound;\\n    \\n                // create a buffer N + 1 and M + 1 size so we have sentinal values\\n                // padding the first row and column.\\n                auto cur_health = vector<vector<int64_t> >(N + 1);\\n                for (int n = 0; n <= N; n++) {\\n                    cur_health[n].resize(M + 1, dead);\\n                }\\n    \\n                // Seed in our starting health\\n                cur_health[0][1] = cur_health[1][0] = mid;\\n                for (int n = 1; n <= N; n++) {\\n                    for (int m = 1; m <= M; m++) {\\n                        cur_health[n][m] = max(cur_health[n-1][m], cur_health[n][m-1]) + dungeon[n-1][m-1];\\n                        if (cur_health[n][m] < 1) {\\n                            // Once we are dead, ensure we stay dead\\n                            cur_health[n][m] = dead;\\n                        }\\n                    }\\n                }\\n    \\n                // If we have positive health at the end we survived!\\n                if (cur_health[N][M] > 0) {\\n                    upperbound = mid;\\n                } else {\\n                    lowerbound = mid;\\n                }\\n            }\\n            return upperbound;\\n        }\\n    };\\n</code>",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        int calculateMinimumHP(vector<vector<int> > &dungeon) {\\n            int N = dungeon.size();\\n            int M = dungeon[0].size();\\n    \\n            // just pick a simple path through the dungeon to obtain an upperbound\\n            int lowerbound = 0;\\n            int upperbound = 1;\\n            for (int i = 0; i < M; i++) {\\n                int val = dungeon[0][i];\\n                if (val < 0) upperbound += (-val);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1497653,
                "title": "python-iterative-dp-solution-o-1-space-utilizing-given-matrix",
                "content": "We\\'ll denote the dungeon d.\\nThe intuition for the solution is as such:\\nIf we start at position (m-1, n-1), the amount of hp needed is the maximum between 1 and -d[m-1][n-1] + 1. \\nThis is because if d[m-1][n-1] is negative, we need to sustain the effect of the cell and add 1 so we won\\'t get to 0 hp (hence -d[m-1][n-1] +1). Otherwise, if d[m-1][n-1] isn\\'t negative, we only need 1 hp.\\n\\nIf we start at position (i, j), the amount of hp needed is the maximum between 1 and the minimum between d[i-1][j]-d[i][j] and d[i][j-1]-d[i][j].\\nThis is because we need to sustain the effects of our current cell, as well as add the needs of either the cell below or the cell to the right. We take the minimal between them because we want the minimal required hp.\\n\\nThe solution has O(1) space complexity because we overwrite the given cell\\'s values.\\n\\n```\\ndef calculateMinimumHP(self, d: List[List[int]]) -> int:\\n        m, n = len(d), len(d[0])\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if i == m-1 and j == n-1:\\n                    d[i][j] = max(1, -d[i][j] + 1)\\n                elif i < m-1 and j < n-1:\\n                    d[i][j] = max(1, min(-d[i][j] + d[i+1][j], -d[i][j] + d[i][j+1]))\\n                elif i < m-1:\\n                    d[i][j] = max(1, -d[i][j] + d[i+1][j])\\n                else:\\n                    d[i][j] = max(1, -d[i][j] + d[i][j+1])\\n        return d[0][0]\\n```\\n\\nHope this helps.",
                "solutionTags": [],
                "code": "```\\ndef calculateMinimumHP(self, d: List[List[int]]) -> int:\\n        m, n = len(d), len(d[0])\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if i == m-1 and j == n-1:\\n                    d[i][j] = max(1, -d[i][j] + 1)\\n                elif i < m-1 and j < n-1:\\n                    d[i][j] = max(1, min(-d[i][j] + d[i+1][j], -d[i][j] + d[i][j+1]))\\n                elif i < m-1:\\n                    d[i][j] = max(1, -d[i][j] + d[i+1][j])\\n                else:\\n                    d[i][j] = max(1, -d[i][j] + d[i][j+1])\\n        return d[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 52841,
                "title": "1ms-beat-100-java-dp-memorization-solution",
                "content": "DP + Memorization\\n\\n\\n    public class DungeonGame {\\n        public int calculateMinimumHP(int[][] dungeon) {\\n            if(dungeon == null || dungeon.length == 0 || dungeon[0].length == 0){//[],[[]]\\n                return 0;\\n            }\\n            int[][] flag = new int[dungeon.length][dungeon[0].length];\\n            int min = dfs(dungeon, flag, 0, 0);\\n            return min;\\n        }\\n        \\n        private int dfs(int[][] dungeon, int[][] flag, int x, int y){\\n            if(flag[x][y] != 0){\\n                return flag[x][y];\\n            }\\n            if(x == dungeon.length - 1 && y == dungeon[0].length - 1){//The down-right corner\\n                flag[x][y] = dungeon[x][y] < 0 ? -dungeon[x][y] + 1 : 1; //The minimum is 1\\n                return flag[x][y];\\n            }\\n            int min = Integer.MAX_VALUE;\\n            //go down\\n            if(x < dungeon.length - 1){\\n                int down = dfs(dungeon, flag, x + 1, y);\\n                min = min < down ? min : down; \\n            }\\n            //go right\\n            if(y < dungeon[0].length - 1){\\n                int right = dfs(dungeon, flag, x, y + 1);\\n                min = min < right ? min : right;\\n            }\\n            if(dungeon[x][y] >= min){//If min is 6, dungeon[x][y] if 10, then min should be updated to 1\\n                min = 1;\\n            }else{//If min is 6, dungeon[x][y] is 3 or -3, then min should be updated to 3 or 9\\n                min = min - dungeon[x][y];\\n            }\\n            flag[x][y] = min;\\n            return min;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "DP + Memorization\\n\\n\\n    public class DungeonGame {\\n        public int calculateMinimumHP(int[][] dungeon) {\\n            if(dungeon == null || dungeon.length == 0 || dungeon[0].length == 0){//[],[[]]\\n                return 0;\\n            }\\n            int[][] flag = new int[dungeon.length][dungeon[0].length];\\n            int min = dfs(dungeon, flag, 0, 0);\\n            return min;\\n        }\\n        \\n        private int dfs(int[][] dungeon, int[][] flag, int x, int y){\\n            if(flag[x][y] != 0){\\n                return flag[x][y];\\n            }\\n            if(x == dungeon.length - 1 && y == dungeon[0].length - 1){//The down-right corner\\n                flag[x][y] = dungeon[x][y] < 0 ? -dungeon[x][y] + 1 : 1; //The minimum is 1\\n                return flag[x][y];\\n            }\\n            int min = Integer.MAX_VALUE;\\n            //go down\\n            if(x < dungeon.length - 1){\\n                int down = dfs(dungeon, flag, x + 1, y);\\n                min = min < down ? min : down; \\n            }\\n            //go right\\n            if(y < dungeon[0].length - 1){\\n                int right = dfs(dungeon, flag, x, y + 1);\\n                min = min < right ? min : right;\\n            }\\n            if(dungeon[x][y] >= min){//If min is 6, dungeon[x][y] if 10, then min should be updated to 1\\n                min = 1;\\n            }else{//If min is 6, dungeon[x][y] is 3 or -3, then min should be updated to 3 or 9\\n                min = min - dungeon[x][y];\\n            }\\n            flag[x][y] = min;\\n            return min;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 698423,
                "title": "c-easy-dp-solution-with-clear-comments-and-example",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) { \\n        int m = dungeon.size(), n = dungeon[0].size();\\n\\n        // dp[i][j] means min hp needed at point (i, j) to survive (it cannot be 0 and has to be at least 1 at any point)\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, INT_MAX));     // pad matrix with extra row and column for shorter code\\n        dp[m][n-1] = dp[m-1][n] = 1;\\n\\n        // since we need min hp when starting out (top left), we fill table from bottom right (princess) to top left (knight)\\n        for(int i = m-1; i >= 0; i--) {\\n            for(int j = n-1; j >= 0; j--) {\\n                // at any cell check cell below and on right\\n                int need = min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j];\\n                dp[i][j] = need > 0 ? need : 1;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n\\n/*\\n\\n-2  -3  3           7   5   2   \\u221E\\n-5  -10 1   --->    6   11  5   \\u221E\\n10  30  -5          1   1   6   1\\n                    \\u221E   \\u221E   1   \\u221E\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) { \\n        int m = dungeon.size(), n = dungeon[0].size();\\n\\n        // dp[i][j] means min hp needed at point (i, j) to survive (it cannot be 0 and has to be at least 1 at any point)\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, INT_MAX));     // pad matrix with extra row and column for shorter code\\n        dp[m][n-1] = dp[m-1][n] = 1;\\n\\n        // since we need min hp when starting out (top left), we fill table from bottom right (princess) to top left (knight)\\n        for(int i = m-1; i >= 0; i--) {\\n            for(int j = n-1; j >= 0; j--) {\\n                // at any cell check cell below and on right\\n                int need = min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j];\\n                dp[i][j] = need > 0 ? need : 1;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n\\n/*\\n\\n-2  -3  3           7   5   2   \\u221E\\n-5  -10 1   --->    6   11  5   \\u221E\\n10  30  -5          1   1   6   1\\n                    \\u221E   \\u221E   1   \\u221E\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698227,
                "title": "my-c-dp-solution-i-think-it-s-easy-to-understand",
                "content": "`dp[i][j]` is the damage from `(i, j)` to `(m-1, n-1)`, and it\\'s a non-positive number. `-dp[i][j]+1` is the minimum health if knight stands on  `(i, j)`.\\n\\nDo dynamic programming from bottom-right to top-left. `-dp[0][0] + 1` is the answer.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if (dungeon.empty() || dungeon[0].empty()) return 0;  // invalid\\n        int rows = dungeon.size(), cols = dungeon[0].size();\\n        vector<vector<int>> dp(rows, vector<int>(cols, 0));\\n        for (int i=rows-1; i >= 0; --i) {\\n            for (int j=cols-1; j >= 0; --j) {\\n                if (i == rows - 1 && j == cols - 1) {\\n                    dp[i][j] = min(0, dungeon[i][j]);\\n                }\\n                else if (i == rows - 1) {\\n                    dp[i][j] = min(0, dungeon[i][j] + dp[i][j+1]);\\n                }\\n                else if (j == cols - 1) {\\n                    dp[i][j] = min(0, dungeon[i][j] + dp[i+1][j]);\\n                }\\n                else {\\n                    dp[i][j] = min(0, dungeon[i][j] + max(dp[i][j+1], dp[i+1][j]));\\n                }\\n            }\\n        }\\n        return -dp[0][0] + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if (dungeon.empty() || dungeon[0].empty()) return 0;  // invalid\\n        int rows = dungeon.size(), cols = dungeon[0].size();\\n        vector<vector<int>> dp(rows, vector<int>(cols, 0));\\n        for (int i=rows-1; i >= 0; --i) {\\n            for (int j=cols-1; j >= 0; --j) {\\n                if (i == rows - 1 && j == cols - 1) {\\n                    dp[i][j] = min(0, dungeon[i][j]);\\n                }\\n                else if (i == rows - 1) {\\n                    dp[i][j] = min(0, dungeon[i][j] + dp[i][j+1]);\\n                }\\n                else if (j == cols - 1) {\\n                    dp[i][j] = min(0, dungeon[i][j] + dp[i+1][j]);\\n                }\\n                else {\\n                    dp[i][j] = min(0, dungeon[i][j] + max(dp[i][j+1], dp[i+1][j]));\\n                }\\n            }\\n        }\\n        return -dp[0][0] + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340111,
                "title": "c-recursive-memoization-tabulation",
                "content": "## **1) RECURSIVE**\\n\\n**Gives TLE\\n41 / 45 test cases passed with this solution**\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, int m , int n, vector<vector<int>> &grid)\\n    {\\n        // if we come out of the grid simply return a large value\\n        if(i >= m || j >= n)\\n            return INT_MAX;\\n        \\n        // calucate health by the 2 possible ways\\n        int down = solve(i + 1, j, m, n, grid);\\n        int right = solve(i, j + 1, m, n, grid);\\n        \\n\\t\\t// take the min both both\\n        int health = min(down, right);\\n        \\n        // we reach the destination when both the sides return INT_MAX\\n        if(health == INT_MAX)\\n        {\\n            health = 1; // both are +ve large integers so min health required = 1\\n        }\\n        \\n        int ans = 0;\\n        if(health - grid[i][j] > 0)\\n        {\\n            ans = health - grid[i][j];\\n        }\\n        else\\n        {\\n            ans = 1;\\n        }\\n             \\n        return ans;\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) \\n    {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        \\n        return solve(0, 0, m, n, dungeon);\\n    }\\n};\\n```\\n\\n\\n## **2) MEMOIZATION**\\n\\n**ALL TEST CASES PASSED!** \\uD83E\\uDD73 \\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, int m , int n, vector<vector<int>> &grid, vector<vector<int>> &dp)\\n    {\\n        // if we come out of the grid simply return a large value\\n        if(i >= m || j >= n)\\n            return INT_MAX;\\n        \\n        if(dp[i][j] != INT_MAX)\\n            return dp[i][j];\\n        \\n        // calucate health by the 2 possible ways\\n        int down = solve(i + 1, j, m, n, grid, dp);\\n        int right = solve(i, j + 1, m, n, grid, dp);\\n        \\n        int health = min(down, right);\\n        \\n        // we reach the destination when both the sides return INT_MAX\\n        if(health == INT_MAX)\\n        {\\n            health = 1; // both are +ve large integers so min health required = 1\\n        }\\n        \\n        int ans = 0;\\n        if(health - grid[i][j] > 0)\\n        {\\n            ans = health - grid[i][j];\\n        }\\n        else\\n        {\\n            ans = 1;\\n        }\\n             \\n        return dp[i][j] = ans;\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) \\n    {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        \\n        vector<vector<int>> dp(m + 1, vector<int> (n + 1, INT_MAX));\\n        \\n        return solve(0, 0, m, n, dungeon, dp);\\n    }\\n};\\n```\\n\\n## **3) TABULATION**\\n\\n**ALL TEST CASES PASSED!** \\uD83E\\uDD73 \\n\\n```\\nclass Solution {\\npublic:    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) \\n    {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        \\n        vector<vector<int>> dp(m + 1, vector<int> (n + 1, INT_MAX));\\n        \\n        for(int i = m - 1; i >= 0; i--)\\n        {\\n            for(int j = n - 1; j >= 0; j--)\\n            {\\n                int right = dp[i + 1][j];\\n                int down = dp[i][j + 1];\\n                \\n                int health = min(down, right);\\n                \\n                // we reach the destination when both the sides return INT_MAX\\n                if(health == INT_MAX)\\n                {\\n                    health = 1; // both are +ve large integers so min health required = 1\\n                }\\n                \\n                int ans = 0;\\n                if(health - dungeon[i][j] > 0)\\n                {\\n                    ans = health - dungeon[i][j];\\n                }\\n                else\\n                {\\n                    ans = 1;\\n                }\\n             \\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, int m , int n, vector<vector<int>> &grid)\\n    {\\n        // if we come out of the grid simply return a large value\\n        if(i >= m || j >= n)\\n            return INT_MAX;\\n        \\n        // calucate health by the 2 possible ways\\n        int down = solve(i + 1, j, m, n, grid);\\n        int right = solve(i, j + 1, m, n, grid);\\n        \\n\\t\\t// take the min both both\\n        int health = min(down, right);\\n        \\n        // we reach the destination when both the sides return INT_MAX\\n        if(health == INT_MAX)\\n        {\\n            health = 1; // both are +ve large integers so min health required = 1\\n        }\\n        \\n        int ans = 0;\\n        if(health - grid[i][j] > 0)\\n        {\\n            ans = health - grid[i][j];\\n        }\\n        else\\n        {\\n            ans = 1;\\n        }\\n             \\n        return ans;\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) \\n    {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        \\n        return solve(0, 0, m, n, dungeon);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, int m , int n, vector<vector<int>> &grid, vector<vector<int>> &dp)\\n    {\\n        // if we come out of the grid simply return a large value\\n        if(i >= m || j >= n)\\n            return INT_MAX;\\n        \\n        if(dp[i][j] != INT_MAX)\\n            return dp[i][j];\\n        \\n        // calucate health by the 2 possible ways\\n        int down = solve(i + 1, j, m, n, grid, dp);\\n        int right = solve(i, j + 1, m, n, grid, dp);\\n        \\n        int health = min(down, right);\\n        \\n        // we reach the destination when both the sides return INT_MAX\\n        if(health == INT_MAX)\\n        {\\n            health = 1; // both are +ve large integers so min health required = 1\\n        }\\n        \\n        int ans = 0;\\n        if(health - grid[i][j] > 0)\\n        {\\n            ans = health - grid[i][j];\\n        }\\n        else\\n        {\\n            ans = 1;\\n        }\\n             \\n        return dp[i][j] = ans;\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) \\n    {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        \\n        vector<vector<int>> dp(m + 1, vector<int> (n + 1, INT_MAX));\\n        \\n        return solve(0, 0, m, n, dungeon, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) \\n    {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        \\n        vector<vector<int>> dp(m + 1, vector<int> (n + 1, INT_MAX));\\n        \\n        for(int i = m - 1; i >= 0; i--)\\n        {\\n            for(int j = n - 1; j >= 0; j--)\\n            {\\n                int right = dp[i + 1][j];\\n                int down = dp[i][j + 1];\\n                \\n                int health = min(down, right);\\n                \\n                // we reach the destination when both the sides return INT_MAX\\n                if(health == INT_MAX)\\n                {\\n                    health = 1; // both are +ve large integers so min health required = 1\\n                }\\n                \\n                int ans = 0;\\n                if(health - dungeon[i][j] > 0)\\n                {\\n                    ans = health - dungeon[i][j];\\n                }\\n                else\\n                {\\n                    ans = 1;\\n                }\\n             \\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206373,
                "title": "c-recursion-memoization-fastest-0ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[205][205];\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        memset(dp, -1, sizeof(dp));\\n        return recur(0, 0, dungeon.size(), dungeon[0].size(), dungeon);\\n    }\\n    \\n    long recur(int i, int j, int n, int m, vector<vector<int>>& d){\\n        if(i >= n || j >= m){\\n            return INT_MAX;\\n        }\\n        \\n        if(i == n-1 && j == m-1){\\n            return d[i][j] <= 0 ? abs(d[i][j]) + 1 : 1;\\n        }\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        int op1 = recur(i+1, j, n, m, d);\\n        int op2 = recur(i, j+1, n, m, d);\\n        \\n        int minHealthRequired = min(op1, op2) - d[i][j];\\n        return dp[i][j] = (minHealthRequired <= 0) ? 1 : minHealthRequired;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[205][205];\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        memset(dp, -1, sizeof(dp));\\n        return recur(0, 0, dungeon.size(), dungeon[0].size(), dungeon);\\n    }\\n    \\n    long recur(int i, int j, int n, int m, vector<vector<int>>& d){\\n        if(i >= n || j >= m){\\n            return INT_MAX;\\n        }\\n        \\n        if(i == n-1 && j == m-1){\\n            return d[i][j] <= 0 ? abs(d[i][j]) + 1 : 1;\\n        }\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        int op1 = recur(i+1, j, n, m, d);\\n        int op2 = recur(i, j+1, n, m, d);\\n        \\n        int minHealthRequired = min(op1, op2) - d[i][j];\\n        return dp[i][j] = (minHealthRequired <= 0) ? 1 : minHealthRequired;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699180,
                "title": "top-down-dp-java",
                "content": "simple case of \\n-2, 13 \\n-5, -6 \\n\\nwhen we reach -6(princess), we return Math.abs(6) +1, if it were positive just return 1 \\nbecause we need atleast 1 health in every cell, so if we were going to lose -6 health we should have 7 health atleast.\\n\\nin the recursive tree 7 is returned to -5 and we do Math.max(1, 7-(-5))) and return 12 to -2 \\n\\nsimilarly the recursive tree starting from 13 gives 1  and we pick min(1,12) which is 1 \\nand do Math.max(1,1-(-2)) \\nwhich gives ans = 3\\n\\nlook how 7-13 = -6 but we need atleast 1 health to survive so we return 1 to the parent call saying hey 1 health is enough to reach me.\\n\\nalso we need same i,j in multiple recursive calls so HashMap is used to cache those subproblems.\\n\\n![image](https://assets.leetcode.com/users/images/09d6daf1-9d77-42f5-b865-c4e64f254464_1592774107.280481.png)\\n\\n\\n```\\n public int calculateMinimumHP(int[][] dungeon) {                \\n        Map<String, Integer> cache = new HashMap<>();   \\n        int m = dungeon.length, n = dungeon[0].length; \\n        return dfs(dungeon, 0, 0, cache, m, n);        \\n    }   \\n    \\n    private int dfs(int[][] dungeon, int i, int j, Map<String, Integer> cache, int m, int n) {       \\n        String key = i + \"_\" + j;\\n        if (cache.containsKey(key))\\n            return cache.get(key);\\n        \\n        if (i==m-1 && j==n-1)\\n            return dungeon[i][j]>0 ? 1 : Math.abs(dungeon[i][j]) + 1;\\n        \\n        if (i>=m || j>=n)\\n            return Integer.MAX_VALUE;     \\n        \\n        int rightPath = dfs(dungeon, i, j+1, cache, m, n);\\n        int downPath = dfs(dungeon, i+1, j, cache, m, n);\\n        \\n        int health = Math.max(1, Math.min(rightPath, downPath) - dungeon[i][j]);\\n        \\n        cache.put(key, health);\\n        \\n        return cache.get(key);        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int calculateMinimumHP(int[][] dungeon) {                \\n        Map<String, Integer> cache = new HashMap<>();   \\n        int m = dungeon.length, n = dungeon[0].length; \\n        return dfs(dungeon, 0, 0, cache, m, n);        \\n    }   \\n    \\n    private int dfs(int[][] dungeon, int i, int j, Map<String, Integer> cache, int m, int n) {       \\n        String key = i + \"_\" + j;\\n        if (cache.containsKey(key))\\n            return cache.get(key);\\n        \\n        if (i==m-1 && j==n-1)\\n            return dungeon[i][j]>0 ? 1 : Math.abs(dungeon[i][j]) + 1;\\n        \\n        if (i>=m || j>=n)\\n            return Integer.MAX_VALUE;     \\n        \\n        int rightPath = dfs(dungeon, i, j+1, cache, m, n);\\n        int downPath = dfs(dungeon, i+1, j, cache, m, n);\\n        \\n        int health = Math.max(1, Math.min(rightPath, downPath) - dungeon[i][j]);\\n        \\n        cache.put(key, health);\\n        \\n        return cache.get(key);        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698231,
                "title": "java-dp-solution-explained-o-n-m-time-and-o-m-space",
                "content": "We can iterate from end to the start end keep tracking minimum initial value for each cell.\\n\\n* `dp[n][m] = max(1, 1 - dungeon[n][m]);` For example: if value in cell is positive, we can have `1 hp`, else we should have `1 - dungeon[n][m]` points.\\n* `dp[i][j] = min(max(1, dp[i][j + 1] - dungeon[i][j]), max(1, dp[i+1][j] - dungeon[i][j]));`. We should take best value from bottom or from right\\n\\nSolution runs in `O(n m)` time and uses `O(n m)` space\\n\\n```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int n = dungeon.length;\\n        int m = dungeon[0].length;\\n        int[][] dp = new int[n][m];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = m - 1; j >= 0; j--) {\\n                if (i + 1 == n && j + 1 == m) {\\n                    dp[i][j] = Math.max(1 - dungeon[i][j], 1);\\n                    continue;\\n                }\\n                \\n                if (i + 1 == n) {\\n                    dp[i][j] = Math.max(dp[i][j + 1] - dungeon[i][j], 1);\\n                } else if (j + 1 == m) {\\n                    dp[i][j] = Math.max(dp[i + 1][j] - dungeon[i][j], 1);\\n                } else {\\n                    int right = Math.max(dp[i][j + 1] - dungeon[i][j], 1);\\n                    int down = Math.max(dp[i + 1][j] - dungeon[i][j], 1);\\n                    dp[i][j] = Math.min(right, down);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n}\\n```\\n\\nWe can reduce to `O(m)` space. To calculate row `dp[i]` we only need results from `dp[i+1]`, so we can use same array\\n\\n```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int n = dungeon.length;\\n        int m = dungeon[0].length;\\n        int[] dp = new int[m];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = m - 1; j >= 0; j--) {\\n                if (i + 1 == n && j + 1 == m) {\\n                    dp[j] = Math.max(1 - dungeon[i][j], 1);\\n                    continue;\\n                }\\n                \\n                if (i + 1 == n) {\\n                    dp[j] = Math.max(dp[j + 1] - dungeon[i][j], 1);\\n                } else if (j + 1 == m) {\\n                    dp[j] = Math.max(dp[j] - dungeon[i][j], 1);\\n                } else {\\n                    int right = Math.max(dp[j + 1] - dungeon[i][j], 1);\\n                    int down = Math.max(dp[j] - dungeon[i][j], 1);\\n                    dp[j] = Math.min(right, down);\\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int n = dungeon.length;\\n        int m = dungeon[0].length;\\n        int[][] dp = new int[n][m];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = m - 1; j >= 0; j--) {\\n                if (i + 1 == n && j + 1 == m) {\\n                    dp[i][j] = Math.max(1 - dungeon[i][j], 1);\\n                    continue;\\n                }\\n                \\n                if (i + 1 == n) {\\n                    dp[i][j] = Math.max(dp[i][j + 1] - dungeon[i][j], 1);\\n                } else if (j + 1 == m) {\\n                    dp[i][j] = Math.max(dp[i + 1][j] - dungeon[i][j], 1);\\n                } else {\\n                    int right = Math.max(dp[i][j + 1] - dungeon[i][j], 1);\\n                    int down = Math.max(dp[i + 1][j] - dungeon[i][j], 1);\\n                    dp[i][j] = Math.min(right, down);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int n = dungeon.length;\\n        int m = dungeon[0].length;\\n        int[] dp = new int[m];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = m - 1; j >= 0; j--) {\\n                if (i + 1 == n && j + 1 == m) {\\n                    dp[j] = Math.max(1 - dungeon[i][j], 1);\\n                    continue;\\n                }\\n                \\n                if (i + 1 == n) {\\n                    dp[j] = Math.max(dp[j + 1] - dungeon[i][j], 1);\\n                } else if (j + 1 == m) {\\n                    dp[j] = Math.max(dp[j] - dungeon[i][j], 1);\\n                } else {\\n                    int right = Math.max(dp[j + 1] - dungeon[i][j], 1);\\n                    int down = Math.max(dp[j] - dungeon[i][j], 1);\\n                    dp[j] = Math.min(right, down);\\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879082,
                "title": "c-very-very-easy-simple-9-line-code-tc-o-n-m-sc-o-1",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\n\\tint calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int n=dungeon.size(),m=dungeon[0].size();\\n        for(int i=n-1;i>=0;--i){\\n            for(int j=m-1;j>=0;--j){\\n                if(i==n-1 && j==m-1) dungeon[i][j]=dungeon[i][j];\\n                else if(i==n-1) dungeon[i][j]+=dungeon[i][j+1];\\n                else if(j==m-1) dungeon[i][j]+=dungeon[i+1][j];\\n                else dungeon[i][j]+=max(dungeon[i][j+1],dungeon[i+1][j]);\\n                \\n                if(dungeon[i][j]>0) dungeon[i][j]=0;\\n            }\\n        }\\n        return abs(dungeon[0][0])+1;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\n\\tint calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int n=dungeon.size(),m=dungeon[0].size();\\n        for(int i=n-1;i>=0;--i){\\n            for(int j=m-1;j>=0;--j){\\n                if(i==n-1 && j==m-1) dungeon[i][j]=dungeon[i][j];\\n                else if(i==n-1) dungeon[i][j]+=dungeon[i][j+1];\\n                else if(j==m-1) dungeon[i][j]+=dungeon[i+1][j];\\n                else dungeon[i][j]+=max(dungeon[i][j+1],dungeon[i+1][j]);\\n                \\n                if(dungeon[i][j]>0) dungeon[i][j]=0;\\n            }\\n        }\\n        return abs(dungeon[0][0])+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 982750,
                "title": "lol-beat-5-dp-binary-search-solution",
                "content": "Apparently there are better solutions out there but I found this one interesting when I saw the tag for the problem is DP + Binary Search. \\n\\nBasically, we can try all the possible health values to find the minimal viable health value. To make it faster, we know the upper bound needed for health is the negate of the sum of all the negative values in the dungeon - 1. Then we can use binary search to find the minimal viable health value, ranging from 1 to upper_bound. \\nuse DP to figure out given a particular health value, if it is viable to get to the princess. \\n\\nThis passes the OJ although it is pretty slow. It is fun ;) \\n\\n```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        upper_bound = sum([value for row in dungeon for value in row if value < 0]) - 1\\n        \\n        def isViable(health):\\n            dp = [[float(\\'-inf\\')] * len(dungeon[0]) for _ in range(len(dungeon))]\\n            \\n            for i in range(len(dp)):\\n                for j in range(len(dp[0])):\\n                    if i == 0 and j == 0:\\n                        dp[i][j] = health + dungeon[i][j]\\n                    elif i == 0:\\n                        dp[i][j] = dp[i][j-1] + dungeon[i][j]\\n                    elif j == 0:\\n                        dp[i][j] = dp[i-1][j] + dungeon[i][j]\\n                    else:\\n                        dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + dungeon[i][j]\\n                    \\n                    if dp[i][j] <= 0:\\n                        dp[i][j] = float(\\'-inf\\')\\n                                        \\n            return dp[-1][-1] != float(\\'-inf\\')\\n    \\n        l, r = 1, abs(upper_bound)\\n        while l < r:\\n            mid = l + (r-l) // 2\\n            viable = isViable(mid)\\n            if viable:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        \\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        upper_bound = sum([value for row in dungeon for value in row if value < 0]) - 1\\n        \\n        def isViable(health):\\n            dp = [[float(\\'-inf\\')] * len(dungeon[0]) for _ in range(len(dungeon))]\\n            \\n            for i in range(len(dp)):\\n                for j in range(len(dp[0])):\\n                    if i == 0 and j == 0:\\n                        dp[i][j] = health + dungeon[i][j]\\n                    elif i == 0:\\n                        dp[i][j] = dp[i][j-1] + dungeon[i][j]\\n                    elif j == 0:\\n                        dp[i][j] = dp[i-1][j] + dungeon[i][j]\\n                    else:\\n                        dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + dungeon[i][j]\\n                    \\n                    if dp[i][j] <= 0:\\n                        dp[i][j] = float(\\'-inf\\')\\n                                        \\n            return dp[-1][-1] != float(\\'-inf\\')\\n    \\n        l, r = 1, abs(upper_bound)\\n        while l < r:\\n            mid = l + (r-l) // 2\\n            viable = isViable(mid)\\n            if viable:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        \\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52920,
                "title": "share-my-c-dp-solution-with-explanation",
                "content": "###dp[i][j] means start from point (i,j) end at point (n-1,m-1) need at least dp[i][j] health.###\\n***dp[i][j] = min(  max( dp[i+1][j] - dungeon[i][j], 1),\\n                       max( dp[i][j+1] - dungeon[i][j], 1) );***\\n\\n\\n\\n\\n    class Solution { \\n    public:\\n        int calculateMinimumHP(vector<vector<int> > &dungeon) {\\n            int n = dungeon.size();\\n            int m = dungeon[0].size();\\n            int dp[n][m];\\n            memset(dp,0,sizeof(dp));\\n            for(int i=n-1;i>=0;--i){\\n                for(int j=m-1; j>=0; --j){\\n                    if(i+1==n && j+1 == m){\\n                        dp[i][j] = max(1-dungeon[i][j],1);\\n                        continue;\\n                    }\\n                    if(j+1<m){\\n                        dp[i][j] = max(dp[i][j+1] - dungeon[i][j],1);\\n                    }\\n                    if(i+1<n){\\n                        if(dp[i][j])\\n                            dp[i][j] = min(dp[i][j],max(dp[i+1][j] - dungeon[i][j],1));\\n                        else \\n                            dp[i][j] = max(dp[i+1][j]-dungeon[i][j],1);\\n                    }\\n                }\\n            }\\n    \\n            return dp[0][0];\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution { \\n    public:\\n        int calculateMinimumHP(vector<vector<int> > &dungeon) {\\n            int n = dungeon.size();\\n            int m = dungeon[0].size();\\n            int dp[n][m];\\n            memset(dp,0,sizeof(dp));\\n            for(int i=n-1;i>=0;--i){\\n                for(int j=m-1; j>=0; --j){\\n                    if(i+1==n && j+1 == m){\\n                        dp[i][j] = max(1-dungeon[i][j],1);\\n                        continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2303535,
                "title": "c-challenge-most-simple-intuitive",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int n, m;\\n    int dfs(int x, int y, vector<vector<int>>& nums, vector<vector<int>> &dp)\\n    {\\n        if(x >= n || x < 0 || y >= m || y < 0)\\n            return INT_MIN;\\n        if(x == n-1 && y == m-1) return nums[x][y];\\n        if(dp[x][y] != -1) return  dp[x][y];\\n        int ans = nums[x][y];\\n        int val = nums[x][y]+max(dfs(x+1, y, nums, dp), dfs(x, y+1, nums, dp));\\n        return dp[x][y] = min(ans, val);\\n    }\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        n = dungeon.size();\\n        m = dungeon[0].size();\\n        vector<vector<int>> dp(n+1, vector<int> (m+1, -1));\\n        int val = dfs(0, 0, dungeon, dp);\\n        if(val >= 0)\\n            return 1;\\n        else\\n        {\\n            val = -1*val;\\n            return val + 1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int n, m;\\n    int dfs(int x, int y, vector<vector<int>>& nums, vector<vector<int>> &dp)\\n    {\\n        if(x >= n || x < 0 || y >= m || y < 0)\\n            return INT_MIN;\\n        if(x == n-1 && y == m-1) return nums[x][y];\\n        if(dp[x][y] != -1) return  dp[x][y];\\n        int ans = nums[x][y];\\n        int val = nums[x][y]+max(dfs(x+1, y, nums, dp), dfs(x, y+1, nums, dp));\\n        return dp[x][y] = min(ans, val);\\n    }\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        n = dungeon.size();\\n        m = dungeon[0].size();\\n        vector<vector<int>> dp(n+1, vector<int> (m+1, -1));\\n        int val = dfs(0, 0, dungeon, dp);\\n        if(val >= 0)\\n            return 1;\\n        else\\n        {\\n            val = -1*val;\\n            return val + 1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498834,
                "title": "c-dp-with-explanation-in-depth",
                "content": "\\tdp[i][j] represents the minimum amount of health i should have when i enter the cell (i, j) in order to reach the bottom-right cell\\n\\t\\t\\tso i assume that the right and bottom values are already known , so my conditin reduces to the following \\n        \\n        x represents the answer for the current cell (dp[i][j] (the minimum health i need to have before entering this cell, for me to reach the destination))\\n        \\n        the change in my health after entering the cell (i, j) will be : x + dungeon[i][j] \\n         x + dp[i][j] is the amount of health that i will have after i enter this cell\\n        \\n          if i want to enter the cell (i+1, j) (below cell)\\n          as per the state of the dp, i should have a health at least dp[i+1][j] before entering the cell (i+1, j)\\n          also, x + dungeon[i][j] is the amount of health i will be left with after entering the cell (i ,j)\\n          \\n          so x + dungeon[i][j] >= dp[i+1][j]\\n            => x >= dp[i+1][j] - dungeon[i][j]\\n            \\n            as i need the limiting case x = dp[i+1][j] - dungeon[i][j]\\n            \\n            \\n          we can carry out the same analysis for the cell (i , j+1)\\n          \\n            this will yield x = dp[i][j+1] - dungeon[i][j]\\n            \\n            the minimum value of the above two will be taken \\n            \\n            in case x turns out to be negative, it just means that dungeon[i][j] is greater than dp[i][j+1], which just means that the health \\n            i am going to pick up at this point is greater than what i need to complete the task starting from the next cell, so even if i dont have any energy i can win, but as per the problem statement, the minimum health should be one\\n            \\n            so in case the answer for any cell turns out to be negative, just fill it with 1\\n            \\n            so the final equation reduces to \\n            \\n                dp[i][j] = min(dp[i+1][j] - dungeon[i][j], dp[i][j+1] - dungeon[i][j]);\\n        \\n```\\nclass Solution {\\npublic:\\n\\tint dirs[2][2] = {{0, 1}, {1, 0}};\\n\\tint calculateMinimumHP(vector<vector<int>>& b) {\\n\\t\\tint r = b.size();\\n\\t\\tint c = b[0].size();\\n    \\n\\t\\tvector<vector<int>> dp(r, vector<int>(c, INT_MAX));\\n   \\n\\t\\t// dp[r - 1][c - 1] = b[r - 1][c - 1] <= 0 ? -b[r - 1][c - 1] + 1 : 1;\\n\\t\\t\\n\\t\\tdp[r-1][c-1] = max(1, 1 - b[r-1][c-1]);\\n\\n\\n\\t\\tfor (int i = r - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tfor (int j = c - 1; j >= 0; j--) {\\n\\t\\t\\t\\tif (i == r - 1 && j == c - 1) continue;\\n\\n\\t\\t\\t\\tfor (auto d : dirs) {\\n\\t\\t\\t\\t\\tint ni = i + d[0];\\n\\t\\t\\t\\t\\tint nj = j + d[1];\\n\\n\\t\\t\\t\\t\\tif (ni >= 0 &&  ni < r && nj >= 0 && nj < c) {\\n\\n\\t\\t\\t\\t\\t\\tdp[i][j] = max(min(dp[ni][nj] - b[i][j] , dp[i][j]), 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[0][0];\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint dirs[2][2] = {{0, 1}, {1, 0}};\\n\\tint calculateMinimumHP(vector<vector<int>>& b) {\\n\\t\\tint r = b.size();\\n\\t\\tint c = b[0].size();\\n    \\n\\t\\tvector<vector<int>> dp(r, vector<int>(c, INT_MAX));\\n   \\n\\t\\t// dp[r - 1][c - 1] = b[r - 1][c - 1] <= 0 ? -b[r - 1][c - 1] + 1 : 1;\\n\\t\\t\\n\\t\\tdp[r-1][c-1] = max(1, 1 - b[r-1][c-1]);\\n\\n\\n\\t\\tfor (int i = r - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tfor (int j = c - 1; j >= 0; j--) {\\n\\t\\t\\t\\tif (i == r - 1 && j == c - 1) continue;\\n\\n\\t\\t\\t\\tfor (auto d : dirs) {\\n\\t\\t\\t\\t\\tint ni = i + d[0];\\n\\t\\t\\t\\t\\tint nj = j + d[1];\\n\\n\\t\\t\\t\\t\\tif (ni >= 0 &&  ni < r && nj >= 0 && nj < c) {\\n\\n\\t\\t\\t\\t\\t\\tdp[i][j] = max(min(dp[ni][nj] - b[i][j] , dp[i][j]), 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[0][0];\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498373,
                "title": "python-easy-top-down-solution-memoization-and-detailed-explanation-which-is-easy-to-follow",
                "content": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        m,n = len(dungeon), len(dungeon[0])\\n        \\n        # cache the states\\n        @lru_cache(None)\\n        def dp(x,y):\\n            \\n            # FOR BASE CASE:\\n            if x == m-1 and y==n-1:\\n                # if last element is negative, then i\\'ve to be one more than its abs value\\n                # else if its positive, i\\'ve to be 1 because that\\'s the least health i can have\\n                return max(1, -dungeon[x][y] + 1)\\n            \\n            # FOR THE CURRENT STATE I\\'M IN i.e., (x,y):\\n            \\n            # initially set answer to infinity for the (x,y) state that we\\'ll find out\\n            ans = float(\"inf\")\\n            \\n            # there are two moves possible, \\n            # so get answers from both the directions i.e., left and down\\n            # take the minimum answer from both of them in each direction\\n            \\n            # DOWN:\\n            if x+1 < m:\\n                ans = min(ans, dp(x+1, y))\\n            # LEFT:\\n            if y+1 < n:\\n                ans = min(ans, dp(x, y+1))\\n                \\n            # now you\\'ve the minimum answer required to go to left or down, \\n            # so we now calculate the total answer required by considering the state we are \\n            # currently in\\n            \\n            # since you are currently at a point, you\\'d have to add the negative of current value \\n            # to simulate the value i should have before hand to enter this current point\\n            # so negate the value and add (subracting basically)\\n            \\n            # for example if current value is -6 then i need 7 to come to this point\\n            # but if the current value is 8 then i virtually need 0 to come to this point\\n            \\n            ans += -dungeon[x][y]\\n            \\n            # again if your ans is +ve, then it means you\\'d need atleast *ans* health to enter \\n            # this current point\\n            # else if its negative, then it means you actually need no health to even enter because \\n            # of the positive orbs in the subsequent points.\\n            # so since i added the negative, i need to return the max of 1 and the ans at the end\\n            return max(1, ans)\\n            \\n        # start the recursion from top\\n        return dp(0,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        m,n = len(dungeon), len(dungeon[0])\\n        \\n        # cache the states\\n        @lru_cache(None)\\n        def dp(x,y):\\n            \\n            # FOR BASE CASE:\\n            if x == m-1 and y==n-1:\\n                # if last element is negative, then i\\'ve to be one more than its abs value\\n                # else if its positive, i\\'ve to be 1 because that\\'s the least health i can have\\n                return max(1, -dungeon[x][y] + 1)\\n            \\n            # FOR THE CURRENT STATE I\\'M IN i.e., (x,y):\\n            \\n            # initially set answer to infinity for the (x,y) state that we\\'ll find out\\n            ans = float(\"inf\")\\n            \\n            # there are two moves possible, \\n            # so get answers from both the directions i.e., left and down\\n            # take the minimum answer from both of them in each direction\\n            \\n            # DOWN:\\n            if x+1 < m:\\n                ans = min(ans, dp(x+1, y))\\n            # LEFT:\\n            if y+1 < n:\\n                ans = min(ans, dp(x, y+1))\\n                \\n            # now you\\'ve the minimum answer required to go to left or down, \\n            # so we now calculate the total answer required by considering the state we are \\n            # currently in\\n            \\n            # since you are currently at a point, you\\'d have to add the negative of current value \\n            # to simulate the value i should have before hand to enter this current point\\n            # so negate the value and add (subracting basically)\\n            \\n            # for example if current value is -6 then i need 7 to come to this point\\n            # but if the current value is 8 then i virtually need 0 to come to this point\\n            \\n            ans += -dungeon[x][y]\\n            \\n            # again if your ans is +ve, then it means you\\'d need atleast *ans* health to enter \\n            # this current point\\n            # else if its negative, then it means you actually need no health to even enter because \\n            # of the positive orbs in the subsequent points.\\n            # so since i added the negative, i need to return the max of 1 and the ans at the end\\n            return max(1, ans)\\n            \\n        # start the recursion from top\\n        return dp(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417313,
                "title": "7-liner-python-solution-48ms-javascript-solution-56ms-java-solution-1ms",
                "content": "dp[r][c]: min health required to reach bottom right\\n\\n**Python(48ms)**\\n```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n\\t\\tnrows, ncols = len(dungeon), len(dungeon[0])\\n        dp = [[float(\\'inf\\')]*(ncols+1) for _ in range(nrows+1)]\\n        dp[nrows-1][ncols] = dp[nrows][ncols-1] = 1\\n        for r in range(nrows-1, -1, -1):\\n            for c in range(ncols-1, -1, -1):\\n                dp[r][c] = max(1, min(dp[r+1][c], dp[r][c+1]) - dungeon[r][c])\\n        return dp[0][0]\\n```\\n\\n**JavaScript(56ms)**\\n```\\n/**\\n * @param {number[][]} dungeon\\n * @return {number}\\n */\\nvar calculateMinimumHP = function(dungeon) {\\n    var nrows = dungeon.length;\\n    var ncols = dungeon[0].length;\\n    \\n    var dp = [];\\n    for (var r=0; r<nrows+1; r++) {\\n        dp[r] = [];\\n        for (var c=0;c<ncols+1;c++) {\\n            dp[r][c] = Number.MAX_SAFE_INTEGER;\\n        }\\n    }\\n    dp[nrows-1][ncols] = dp[nrows][ncols-1] = 1;\\n    \\n    for (var r=nrows-1;r>=0;r--) {\\n        for (var c=ncols-1;c>=0;c--) {\\n            dp[r][c] = Math.max(1, Math.min(dp[r+1][c], dp[r][c+1])-dungeon[r][c]);\\n        }\\n    }\\n    return dp[0][0];\\n};\\n```\\n\\n**Java(1ms)**\\n```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int nrows = dungeon.length;\\n        int ncols = dungeon[0].length;\\n        int[][] dp = new int[nrows+1][ncols+1];\\n        for(int[] r:dp){\\n            Arrays.fill(r, Integer.MAX_VALUE);\\n        }\\n        dp[nrows-1][ncols] = dp[nrows][ncols-1] = 1;\\n        for(int r=nrows-1;r>=0;r--){\\n            for(int c=ncols-1;c>=0;c--){\\n                dp[r][c] = Math.max(1, Math.min(dp[r+1][c], dp[r][c+1])-dungeon[r][c]);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n\\t\\tnrows, ncols = len(dungeon), len(dungeon[0])\\n        dp = [[float(\\'inf\\')]*(ncols+1) for _ in range(nrows+1)]\\n        dp[nrows-1][ncols] = dp[nrows][ncols-1] = 1\\n        for r in range(nrows-1, -1, -1):\\n            for c in range(ncols-1, -1, -1):\\n                dp[r][c] = max(1, min(dp[r+1][c], dp[r][c+1]) - dungeon[r][c])\\n        return dp[0][0]\\n```\n```\\n/**\\n * @param {number[][]} dungeon\\n * @return {number}\\n */\\nvar calculateMinimumHP = function(dungeon) {\\n    var nrows = dungeon.length;\\n    var ncols = dungeon[0].length;\\n    \\n    var dp = [];\\n    for (var r=0; r<nrows+1; r++) {\\n        dp[r] = [];\\n        for (var c=0;c<ncols+1;c++) {\\n            dp[r][c] = Number.MAX_SAFE_INTEGER;\\n        }\\n    }\\n    dp[nrows-1][ncols] = dp[nrows][ncols-1] = 1;\\n    \\n    for (var r=nrows-1;r>=0;r--) {\\n        for (var c=ncols-1;c>=0;c--) {\\n            dp[r][c] = Math.max(1, Math.min(dp[r+1][c], dp[r][c+1])-dungeon[r][c]);\\n        }\\n    }\\n    return dp[0][0];\\n};\\n```\n```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int nrows = dungeon.length;\\n        int ncols = dungeon[0].length;\\n        int[][] dp = new int[nrows+1][ncols+1];\\n        for(int[] r:dp){\\n            Arrays.fill(r, Integer.MAX_VALUE);\\n        }\\n        dp[nrows-1][ncols] = dp[nrows][ncols-1] = 1;\\n        for(int r=nrows-1;r>=0;r--){\\n            for(int c=ncols-1;c>=0;c--){\\n                dp[r][c] = Math.max(1, Math.min(dp[r+1][c], dp[r][c+1])-dungeon[r][c]);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546206,
                "title": "java-bottom-up-easy-completely-explained",
                "content": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n\\n    // if power required to reach a cell is positive then we place zero there instead of the positive number\\n   // this is to calculate the max negative number we should tackle during the path and we only take the negative value\\n        int r = dungeon.length;\\n        int c = dungeon[0].length;\\n        int [][] dp = new int[r][c];\\n        \\n        for(int i= r-1; i>=0;i--)\\n        {\\n            for(int j= c-1; j>=0;j--)\\n            {\\n\\t\\t\\t// for where the princess is located, if negative value then take the negative value else if positive then take zero\\n                if(i==r-1 && j==c-1)// princess is located\\n                {\\n                    dp[i][j]= Math.min(0,dungeon[i][j] );\\n                }\\n                   // last row move right and check and follow the same process as above  i. e add the value first of the dungeon matrix first and check\\n\\t\\t\\t\\t   // if positive or negative and process as above\\n                else if(i== r-1) // last row\\n                {\\n                    dp[i][j] = Math.min(0, dungeon[i][j] + dp[i][j+1]);\\n                }\\n                // same as above\\n                 else if(j == c-1) // last column\\n                {\\n                    dp[i][j] = Math.min(0, dungeon[i][j] + dp[i+1][j]);\\n                }\\n                // for choosing between down and right direction get the max value as we need the max negative value for the knight to safely travel\\n\\t\\t\\t\\t// and process the whole as same as above \\n                else \\n                {\\n                    dp[i][j] = Math.min(0, dungeon[i][j] + Math.max(dp[i][j+1], dp[i+1][j]));\\n                }\\n            \\n            }\\n        }\\n         return Math.abs(dp[0][0]) +1;                                  \\n  }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n\\n    // if power required to reach a cell is positive then we place zero there instead of the positive number\\n   // this is to calculate the max negative number we should tackle during the path and we only take the negative value\\n        int r = dungeon.length;\\n        int c = dungeon[0].length;\\n        int [][] dp = new int[r][c];\\n        \\n        for(int i= r-1; i>=0;i--)\\n        {\\n            for(int j= c-1; j>=0;j--)\\n            {\\n\\t\\t\\t// for where the princess is located, if negative value then take the negative value else if positive then take zero\\n                if(i==r-1 && j==c-1)// princess is located\\n                {\\n                    dp[i][j]= Math.min(0,dungeon[i][j] );\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1445373,
                "title": "c-brute-force-thinking-choose-maximum-energy-path",
                "content": "Just a brute force thinking , choose maximum energy path\\n```\\n\\nint calculateMinimumHP(vector<vector<int>>& v) {\\n        int n = v.size() , m = v[0].size();\\n        int dp[n][m];\\n\\t\\t//dp[i][j] denotes nothing but sum of the min energy requriment to reach goal with just 0 energy\\n\\t\\t//will add 1 later for the condition\\n\\t\\t\\n\\t\\t//intialisation\\n        dp[n-1][m-1] = v[n-1][m-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n\\t\\t//will take neg or max 0 value of ahead nodes as we need to maintain minimum 0 energy at every cell\\n            dp[i][m-1] = min(0,dp[i+1][m-1])+v[i][m-1];\\n        }\\n        for(int i=m-2;i>=0;i--)\\n        {\\n            dp[n-1][i] = min(0,dp[n-1][i+1])+v[n-1][i];\\n        }\\n        \\n\\t\\t\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=m-2;j>=0;j--)\\n            {\\n\\t\\t\\t  // just simply will check which of two dirction cell have maximum energy to go\\n                dp[i][j] = v[i][j] + max(min(0,dp[i+1][j]), min(0,dp[i][j+1]));\\n            }\\n        }\\n        \\n\\t\\t//will return minimum energy rrequirement > 0  add 1 for condition\\n        return max(0,-1 * dp[0][0])+1;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\nint calculateMinimumHP(vector<vector<int>>& v) {\\n        int n = v.size() , m = v[0].size();\\n        int dp[n][m];\\n\\t\\t//dp[i][j] denotes nothing but sum of the min energy requriment to reach goal with just 0 energy\\n\\t\\t//will add 1 later for the condition\\n\\t\\t\\n\\t\\t//intialisation\\n        dp[n-1][m-1] = v[n-1][m-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n\\t\\t//will take neg or max 0 value of ahead nodes as we need to maintain minimum 0 energy at every cell\\n            dp[i][m-1] = min(0,dp[i+1][m-1])+v[i][m-1];\\n        }\\n        for(int i=m-2;i>=0;i--)\\n        {\\n            dp[n-1][i] = min(0,dp[n-1][i+1])+v[n-1][i];\\n        }\\n        \\n\\t\\t\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=m-2;j>=0;j--)\\n            {\\n\\t\\t\\t  // just simply will check which of two dirction cell have maximum energy to go\\n                dp[i][j] = v[i][j] + max(min(0,dp[i+1][j]), min(0,dp[i][j+1]));\\n            }\\n        }\\n        \\n\\t\\t//will return minimum energy rrequirement > 0  add 1 for condition\\n        return max(0,-1 * dp[0][0])+1;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1362586,
                "title": "python-simple-dijkstra-with-explanation-and-visuals",
                "content": "---------------------------------------------------------------------------------\\n# [2] Dijktsra | 60 ms, faster than 99.19% of Python3\\n---------------------------------------------------------------------------------\\n     \\n- What is the **minimum initial health** required for the knight to survive the journey (aka. **bare minimum health points**)?\\n- The **bare minimum health points** corresponds with the **healthiest path (aka. most energy preserving path)**\\n- To achive the healthiest path, the knight needs to constantly choose:\\n\\t-  the cell that consumes the least energy of all available cells (aka. the cell with the least powerful demon)**\\n\\t-  or even better, **choose cells that provides the knight with more energy (aka. cells containing magical orbs)**. \\n-  This behaviour can be achived with **Dijsktra\\'s algortihm with a maximum heap** as our frontier for exploring the grid.\\n- Dijkstra\\'s algortihm will surely spit out the best path, however, we still need an additional step.\\n-  We need to examine the optimal path and look at our knight\\'s health at each step along the journey. The lowest health points is the worst health condition that our knight had to endure during the journey. That value should be the basis upon which the minimum initial health is to be calculated.\\n\\n\\n\\t`minimum initial health points required = worst( best( all paths ) ) + 1`\\n\\n- We could have attempted to find the most optimal (healthiest path) via: DFS or a greedy search, however, Dijkstra is faster than brute-force DFS and more stable than heuristic/greedy (aka. guaranteed correctness)\\n\\n\\n![image](https://assets.leetcode.com/users/images/9c2a3756-470a-4540-a0ee-77d97a21e554_1638648477.109243.png)\\n\\n\\n```\\ndef calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n\\tgrid = dungeon\\n\\ttrgtX, trgtY = len(grid)-1, len(grid[0])-1\\n\\n\\tif trgtX == trgtY == 0:\\n\\t\\tif grid[0][0] > 0:\\n\\t\\t\\treturn 1\\n\\t\\telse:\\n\\t\\t\\treturn abs(grid[0][0])+1\\n\\n\\th = []\\n\\tfrom heapq import heappush, heappop\\n\\n\\tstartNode = (-1*grid[0][0], (0,0)) # max heap to give priority to least cost \\n\\theappush(h, startNode) \\n\\tdirs = [(1,0), (0,1)]\\n\\tcost_so_far = {(0,0): grid[0][0]}\\n\\n\\tlowestHealth = max(0, -grid[0][0]) # --- NOTE [1] \\n\\n\\twhile h:\\n\\t\\tcost, node = heappop(h)\\n\\t\\tx, y = node\\n\\n\\t\\tlowestHealth = max(cost, neededHealth) # --- NOTE [2]\\n\\n\\t\\tif (x,y) == (trgtX, trgtY):\\n\\t\\t\\tbreak\\n\\n\\t\\tfor dir in dirs:\\n\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\tif newX <= len(grid)-1 and newY <= len(grid[0])-1:\\n\\t\\t\\t\\tedgeCost = -1*grid[newX][newY]\\n\\t\\t\\t\\tnewCost = cost + edgeCost\\n\\t\\t\\t\\tif (newX, newY) not in cost_so_far or ( (newX, newY) in cost_so_far and cost_so_far[(newX, newY)] > newCost ):\\n\\t\\t\\t\\t\\tcost_so_far[(newX, newY)] = newCost\\n\\t\\t\\t\\t\\theappush(h, ((newCost, (newX, newY))))\\n\\n\\t# print(cost_so_far)\\n\\t# return cost_so_far[(trgtX, trgtY)] + 1\\n\\treturn lowestHealth + 1  # ----- NOTE [3]\\n\\n\\n\\t# NOTE [1]\\n\\t# -------\\n\\t# if 0,0 cell is +ve -> then starting value of lowest health = 0\\n\\t# if 0,0 cell is -ve -> starting value of lowest health = the +ve value of grid[0][0])\\n\\t\\n\\t# lowestHealth = max(0, -grid[0][0])  \\n\\t\\n\\t# -- OR --\\n\\t\\n\\t# lowestHealth = 0\\n        if grid[0][0] < 0:\\n            lowestHealth = abs(grid[0][0])\\n\\t\\t\\t\\n\\t# if value of cell is +ve -> i don\\'t need health points\\n\\t# neededHealth is always going to be a +ve number\\n\\t# we need to do this because initialHeath has to be determined based on\\n\\t# ->   the highest damage encountered along the way\\n\\t# ->   not the the overall pathCost by the time we reach target\\n\\n\\t# we could have used DFS with a reqular stack and we wouldve arrived to the solution (slower)\\n\\t# Disjktra is to speed up the search while making sure optimality is gauaranteed\\n\\t# pure greedy is not gauarnteed\\n\\n\\t# NOTE [2]\\n\\t# ---------\\n\\t# We use max() bcuz our heap is a max-heap (costs are with opp sign) (by taking max() \\n\\t# -> we are in reality choosing the lowest health points)\\n\\t\\n\\t\\n\\t\\n\\t# NOTE [3]\\n\\t# --------\\n\\t# If at any point his health point drops to 0 or below, he dies immediately.\\n\\t# neededhealth is either a:\\n\\t#   a) optimal pathCost is +ve -> zero ->                but we add 1 because min allowed health points = 1 (otherwise knight dies)  \\n\\t#   b) optimal pathCost is -ve -> abs(that -ve value) -> but we add 1 to stay above 0 by the time we reach the princess at the end of the quest\\n```\\n\\n---------------------------------------------------------------------------------\\n# [1] DP (Bottom up) | 68 ms, faster than 90.49% of Python3\\n---------------------------------------------------------------------------------\\n\\n\\n```\\ndef calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n\\tgrid = dungeon\\n\\tm, n = len(grid), len(grid[0])\\n\\tfor i in range(m-1, -1, -1):\\n\\t\\tfor j in range(n-1, -1, -1):\\n\\n\\t\\t\\tif i == m-1 and j == n-1:\\n\\t\\t\\t\\tif grid[i][j] < 0:\\n\\t\\t\\t\\t\\tgrid[i][j] = abs(1-grid[i][j])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tgrid[i][j] = 1\\n\\n\\t\\t\\telif i == m-1:\\n\\t\\t\\t\\tif grid[i][j+1] > grid[i][j]:\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j+1] - grid[i][j]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tgrid[i][j] = 1\\n\\n\\t\\t\\telif j == n-1:\\n\\t\\t\\t\\tif grid[i+1][j] > grid[i][j]:\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i+1][j] - grid[i][j]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tgrid[i][j] = 1\\n\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif grid[i][j+1] > grid[i][j] and grid[i+1][j] > grid[i][j]:\\n\\t\\t\\t\\t\\tgrid[i][j] = min(grid[i][j+1], grid[i+1][j]) - grid[i][j]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tgrid[i][j] = 1\\n\\n\\treturn grid[0][0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n\\tgrid = dungeon\\n\\ttrgtX, trgtY = len(grid)-1, len(grid[0])-1\\n\\n\\tif trgtX == trgtY == 0:\\n\\t\\tif grid[0][0] > 0:\\n\\t\\t\\treturn 1\\n\\t\\telse:\\n\\t\\t\\treturn abs(grid[0][0])+1\\n\\n\\th = []\\n\\tfrom heapq import heappush, heappop\\n\\n\\tstartNode = (-1*grid[0][0], (0,0)) # max heap to give priority to least cost \\n\\theappush(h, startNode) \\n\\tdirs = [(1,0), (0,1)]\\n\\tcost_so_far = {(0,0): grid[0][0]}\\n\\n\\tlowestHealth = max(0, -grid[0][0]) # --- NOTE [1] \\n\\n\\twhile h:\\n\\t\\tcost, node = heappop(h)\\n\\t\\tx, y = node\\n\\n\\t\\tlowestHealth = max(cost, neededHealth) # --- NOTE [2]\\n\\n\\t\\tif (x,y) == (trgtX, trgtY):\\n\\t\\t\\tbreak\\n\\n\\t\\tfor dir in dirs:\\n\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\tif newX <= len(grid)-1 and newY <= len(grid[0])-1:\\n\\t\\t\\t\\tedgeCost = -1*grid[newX][newY]\\n\\t\\t\\t\\tnewCost = cost + edgeCost\\n\\t\\t\\t\\tif (newX, newY) not in cost_so_far or ( (newX, newY) in cost_so_far and cost_so_far[(newX, newY)] > newCost ):\\n\\t\\t\\t\\t\\tcost_so_far[(newX, newY)] = newCost\\n\\t\\t\\t\\t\\theappush(h, ((newCost, (newX, newY))))\\n\\n\\t# print(cost_so_far)\\n\\t# return cost_so_far[(trgtX, trgtY)] + 1\\n\\treturn lowestHealth + 1  # ----- NOTE [3]\\n\\n\\n\\t# NOTE [1]\\n\\t# -------\\n\\t# if 0,0 cell is +ve -> then starting value of lowest health = 0\\n\\t# if 0,0 cell is -ve -> starting value of lowest health = the +ve value of grid[0][0])\\n\\t\\n\\t# lowestHealth = max(0, -grid[0][0])  \\n\\t\\n\\t# -- OR --\\n\\t\\n\\t# lowestHealth = 0\\n        if grid[0][0] < 0:\\n            lowestHealth = abs(grid[0][0])\\n\\t\\t\\t\\n\\t# if value of cell is +ve -> i don\\'t need health points\\n\\t# neededHealth is always going to be a +ve number\\n\\t# we need to do this because initialHeath has to be determined based on\\n\\t# ->   the highest damage encountered along the way\\n\\t# ->   not the the overall pathCost by the time we reach target\\n\\n\\t# we could have used DFS with a reqular stack and we wouldve arrived to the solution (slower)\\n\\t# Disjktra is to speed up the search while making sure optimality is gauaranteed\\n\\t# pure greedy is not gauarnteed\\n\\n\\t# NOTE [2]\\n\\t# ---------\\n\\t# We use max() bcuz our heap is a max-heap (costs are with opp sign) (by taking max() \\n\\t# -> we are in reality choosing the lowest health points)\\n\\t\\n\\t\\n\\t\\n\\t# NOTE [3]\\n\\t# --------\\n\\t# If at any point his health point drops to 0 or below, he dies immediately.\\n\\t# neededhealth is either a:\\n\\t#   a) optimal pathCost is +ve -> zero ->                but we add 1 because min allowed health points = 1 (otherwise knight dies)  \\n\\t#   b) optimal pathCost is -ve -> abs(that -ve value) -> but we add 1 to stay above 0 by the time we reach the princess at the end of the quest\\n```\n```\\ndef calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n\\tgrid = dungeon\\n\\tm, n = len(grid), len(grid[0])\\n\\tfor i in range(m-1, -1, -1):\\n\\t\\tfor j in range(n-1, -1, -1):\\n\\n\\t\\t\\tif i == m-1 and j == n-1:\\n\\t\\t\\t\\tif grid[i][j] < 0:\\n\\t\\t\\t\\t\\tgrid[i][j] = abs(1-grid[i][j])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tgrid[i][j] = 1\\n\\n\\t\\t\\telif i == m-1:\\n\\t\\t\\t\\tif grid[i][j+1] > grid[i][j]:\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j+1] - grid[i][j]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tgrid[i][j] = 1\\n\\n\\t\\t\\telif j == n-1:\\n\\t\\t\\t\\tif grid[i+1][j] > grid[i][j]:\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i+1][j] - grid[i][j]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tgrid[i][j] = 1\\n\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif grid[i][j+1] > grid[i][j] and grid[i+1][j] > grid[i][j]:\\n\\t\\t\\t\\t\\tgrid[i][j] = min(grid[i][j+1], grid[i+1][j]) - grid[i][j]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tgrid[i][j] = 1\\n\\n\\treturn grid[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1116248,
                "title": "c-dp-recursion-memonization-bottom-up-with-explanation",
                "content": "```\\n/*\\n * TopDown Approach or Recursive Solution\\n *\\n * The solution is to find the minimum health that is required by knight to save Queen\\n * If incase the kinight and Queen at the same point in the dungeon, then to save Queen\\n * the knight requires\\n * For Eg: [[-3]] or [[3]] ie.., Knight and Queen are same point\\n *     . If there is a demons, then the health required is min 4, so that Knight can fight\\n *        with daemon and save the queen i.e.., 4 - 3 = 1\\n *     . If there a magic orbs, then health is required is min 1 bcz knight should be alive\\n *       to save the queen.\\n *\\n *  From above it is clear that min health needed is 1 and in case of dameon it is\\n *             1 + abs(dameon health) => 1 -(dameon health)\\n *\\n *  In general health = std::max(1, 1-value at gird) if both queen and Knigth at same position\\n\\n * The Knight can only have two ways to go from top to botomm either right or down ie.., there\\n * will 2 subproblems for each problem.\\n * Starting at index 0,0 to m-1, n-1\\n *\\n *                     (0,0)\\n *                       |\\n *            ------------------------\\n *           |                        |\\n *         (1,0)                     (0,1)\\n *           |\\n *     -------------\\n *    |             |\\n *  (2,0)          (1,1)\\n *\\n * ie..,\\n * std::max(1, min(calcminHealth(row+1, col), calcminHealth(row, col+1)) - grid[row][col])\\n *\\n * Base cases:\\n * If the row and column reaches queen, then the result will be -current + 1 if there is a\\n * demon else 1.\\n * If the row reaches the tail, then knight can only move right\\n * If the col reaches the tail, then knight can only move down\\n *\\n */\\nint calculateMinHP(vector<vector<int>>& d, int row, int col) {\\n\\tif (row >= d.size() - 1 && col >= d[row].size() - 1) {\\n\\t\\t// Both Knight and Queen are at same position, then min health required is\\n\\t\\t// 1 -(dameon health) or 1 if dameon or magic orb is present at that grid\\n\\t\\treturn d[row][col] < 0 ? 1 - d[row][col] : 1;\\n\\t}\\n\\n\\tif (col == d[row].size() - 1) {\\n\\t\\t// knight reaches end of the columns in a row, it can move only down\\n\\t\\treturn std::max(1, calculateMinHP(d, row + 1, col) - d[row][col]);\\n\\t}\\n\\n\\tif (row == d.size() - 1) {\\n\\t\\t// Knight reaches the end of the row in column, it can only move right\\n\\t\\treturn std::max(1, calculateMinHP(d, row, col + 1) - d[row][col]);\\n\\t}\\n\\n\\t// Else Knight can move either down or right\\n\\treturn std::max(1, std::min(calculateMinHP(d, row + 1, col),\\n\\t\\t                        calculateMinHP(d, row, col + 1)) - d[row][col]);\\n}\\n\\nint calculateMinimumHP(vector<vector<int>>& dungeon) {\\n\\treturn calculateMinHP(dungeon, 0, 0);\\n}\\n\\t/*\\n     * CalculateMinHealth BottomUp solution\\n     * Since there are many overlapping subproblems in Recursive solution, and the\\n     * Solution for the main problem can ba attained if there are solutions for\\n     * suproblems, Dynamic Programming can be applied.\\n     *\\n     * Dynamic Programming Bottom up solution, conditions are similar to recursive\\n     * but the intemediate results are stored in a dp table. Bottom up is to find\\n     * bottom solutions first to yield the top solution i.e.., solution of the problem\\n     *\\n     * As there are 2 subproblems for each problem i.e.., one can move to either\\n     * Right or Bottom the solution from row & col is\\n     *    dp[row][col] = max(1, min(dp[row-1][col], dp[row][col-1]) - d[row][col])\\n     *\\n     * If the Knight and Queen are at end, then\\n     *    dp[m-1][n-1] = d[m-1][n-1] > 0 ? 1 : 1 - d[m-1][n-1]\\n     *\\n     */\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if (dungeon.empty()) {\\n            // If the dungeon is empty, return zero\\n            return 0;\\n        }\\n\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        // dp array to store the cummulative sum of each subproblem\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n\\n        // If the knight and Queen are at the end ie.., last cell\\n        dp[m - 1][n - 1] = dungeon[m - 1][n - 1] > 0 ? 1 : 1 - dungeon[m - 1][n - 1];\\n\\n        // fill last column cell only\\n        for (int i = m - 2; i >= 0; i--) {\\n            dp[i][n - 1] = std::max(1, dp[i + 1][n - 1] - dungeon[i][n - 1]);\\n        }\\n\\n        // fill last row cell only\\n        for (int j = n - 2; j >= 0; j--) {\\n            dp[m - 1][j] = std::max(1, dp[m - 1][j + 1] - dungeon[m - 1][j]);\\n        }\\n\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                dp[i][j] = std::max(1,\\n                    std::min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n * TopDown Approach or Recursive Solution\\n *\\n * The solution is to find the minimum health that is required by knight to save Queen\\n * If incase the kinight and Queen at the same point in the dungeon, then to save Queen\\n * the knight requires\\n * For Eg: [[-3]] or [[3]] ie.., Knight and Queen are same point\\n *     . If there is a demons, then the health required is min 4, so that Knight can fight\\n *        with daemon and save the queen i.e.., 4 - 3 = 1\\n *     . If there a magic orbs, then health is required is min 1 bcz knight should be alive\\n *       to save the queen.\\n *\\n *  From above it is clear that min health needed is 1 and in case of dameon it is\\n *             1 + abs(dameon health) => 1 -(dameon health)\\n *\\n *  In general health = std::max(1, 1-value at gird) if both queen and Knigth at same position\\n\\n * The Knight can only have two ways to go from top to botomm either right or down ie.., there\\n * will 2 subproblems for each problem.\\n * Starting at index 0,0 to m-1, n-1\\n *\\n *                     (0,0)\\n *                       |\\n *            ------------------------\\n *           |                        |\\n *         (1,0)                     (0,1)\\n *           |\\n *     -------------\\n *    |             |\\n *  (2,0)          (1,1)\\n *\\n * ie..,\\n * std::max(1, min(calcminHealth(row+1, col), calcminHealth(row, col+1)) - grid[row][col])\\n *\\n * Base cases:\\n * If the row and column reaches queen, then the result will be -current + 1 if there is a\\n * demon else 1.\\n * If the row reaches the tail, then knight can only move right\\n * If the col reaches the tail, then knight can only move down\\n *\\n */\\nint calculateMinHP(vector<vector<int>>& d, int row, int col) {\\n\\tif (row >= d.size() - 1 && col >= d[row].size() - 1) {\\n\\t\\t// Both Knight and Queen are at same position, then min health required is\\n\\t\\t// 1 -(dameon health) or 1 if dameon or magic orb is present at that grid\\n\\t\\treturn d[row][col] < 0 ? 1 - d[row][col] : 1;\\n\\t}\\n\\n\\tif (col == d[row].size() - 1) {\\n\\t\\t// knight reaches end of the columns in a row, it can move only down\\n\\t\\treturn std::max(1, calculateMinHP(d, row + 1, col) - d[row][col]);\\n\\t}\\n\\n\\tif (row == d.size() - 1) {\\n\\t\\t// Knight reaches the end of the row in column, it can only move right\\n\\t\\treturn std::max(1, calculateMinHP(d, row, col + 1) - d[row][col]);\\n\\t}\\n\\n\\t// Else Knight can move either down or right\\n\\treturn std::max(1, std::min(calculateMinHP(d, row + 1, col),\\n\\t\\t                        calculateMinHP(d, row, col + 1)) - d[row][col]);\\n}\\n\\nint calculateMinimumHP(vector<vector<int>>& dungeon) {\\n\\treturn calculateMinHP(dungeon, 0, 0);\\n}\\n\\t/*\\n     * CalculateMinHealth BottomUp solution\\n     * Since there are many overlapping subproblems in Recursive solution, and the\\n     * Solution for the main problem can ba attained if there are solutions for\\n     * suproblems, Dynamic Programming can be applied.\\n     *\\n     * Dynamic Programming Bottom up solution, conditions are similar to recursive\\n     * but the intemediate results are stored in a dp table. Bottom up is to find\\n     * bottom solutions first to yield the top solution i.e.., solution of the problem\\n     *\\n     * As there are 2 subproblems for each problem i.e.., one can move to either\\n     * Right or Bottom the solution from row & col is\\n     *    dp[row][col] = max(1, min(dp[row-1][col], dp[row][col-1]) - d[row][col])\\n     *\\n     * If the Knight and Queen are at end, then\\n     *    dp[m-1][n-1] = d[m-1][n-1] > 0 ? 1 : 1 - d[m-1][n-1]\\n     *\\n     */\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if (dungeon.empty()) {\\n            // If the dungeon is empty, return zero\\n            return 0;\\n        }\\n\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        // dp array to store the cummulative sum of each subproblem\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n\\n        // If the knight and Queen are at the end ie.., last cell\\n        dp[m - 1][n - 1] = dungeon[m - 1][n - 1] > 0 ? 1 : 1 - dungeon[m - 1][n - 1];\\n\\n        // fill last column cell only\\n        for (int i = m - 2; i >= 0; i--) {\\n            dp[i][n - 1] = std::max(1, dp[i + 1][n - 1] - dungeon[i][n - 1]);\\n        }\\n\\n        // fill last row cell only\\n        for (int j = n - 2; j >= 0; j--) {\\n            dp[m - 1][j] = std::max(1, dp[m - 1][j + 1] - dungeon[m - 1][j]);\\n        }\\n\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                dp[i][j] = std::max(1,\\n                    std::min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698800,
                "title": "c-2d-dp-slightly-easier-alternative-approach-bottom-up-12-ms-explained",
                "content": "Every post on here uses DP rather non-intuitively (for me). I made it a simpler solution with different logic.\\n\\nHere we try to obtain the lowest value along the chosen path and ensure that our life will be >0 at that point.\\nOur metric for the best path is one on which the lowest value at any point is maximum.\\n\\nOur DP table tries to ascertain that if we started at (i, j), what would be the lowest life in the best path from (i, j) to P.\\n\\nThe logic:\\nLets consider an array [1, 2, -5, 3, 4] representing a path. Consider array [-5, 3, 4] where the lowest life is -5, if we started with 0 life right before jumping into it. If we add another number making it [2, -5, 3, 4], we raise the \"life-sum\" at each point in [-5,3,4] by 2 points. Therefore, the point of lowest life will still remain the same in [-5, 3, 4] except the lowest life is raised by 2 points(= -3).\\nBUT lowest life for the whole array may occur at [2] itself. Thus we need to find the minimum between [2](=2) and jumping into [-5,3,4] with 2 initially (=-3). Thus the minimization is as follows:\\n\\n```\\ndp[i][j] = min(dungeon[i][j],  dungeon[i][j] + lowest in the further path)\\n```\\n\\nWe need to optimize paths too(which is the maximum of the two options right and down). Thus:\\n\\n```\\ndp[i][j] = min(dungeon[i][j], dungeon[i][j] + max(dp[i+1][j], dp[i][j+1]));\\n```\\n\\nFurther if the lowest we go in the most optimum path is >0, then we need only 1 life. Otherwise, we return:\\n```\\n1 + (-dp[0][0]);\\n```\\nMy AC code:\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if(dungeon.size()==0){\\n            return 0;\\n        }\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n));\\n        dp[m-1][n-1] = dungeon[m-1][n-1];\\n        for(int i=m-2;i>=0;i--){\\n            dp[i][n-1] = min(dungeon[i][n-1], dungeon[i][n-1] + dp[i+1][n-1]);\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            dp[m-1][i] = min(dungeon[m-1][i], dungeon[m-1][i] + dp[m-1][i+1]);\\n        }\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[i][j] = min(dungeon[i][j], dungeon[i][j] + max(dp[i+1][j], dp[i][j+1]));\\n            }\\n        }\\n        return 1 + max(-dp[0][0], 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[i][j] = min(dungeon[i][j],  dungeon[i][j] + lowest in the further path)\\n```\n```\\ndp[i][j] = min(dungeon[i][j], dungeon[i][j] + max(dp[i+1][j], dp[i][j+1]));\\n```\n```\\n1 + (-dp[0][0]);\\n```\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if(dungeon.size()==0){\\n            return 0;\\n        }\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n));\\n        dp[m-1][n-1] = dungeon[m-1][n-1];\\n        for(int i=m-2;i>=0;i--){\\n            dp[i][n-1] = min(dungeon[i][n-1], dungeon[i][n-1] + dp[i+1][n-1]);\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            dp[m-1][i] = min(dungeon[m-1][i], dungeon[m-1][i] + dp[m-1][i+1]);\\n        }\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[i][j] = min(dungeon[i][j], dungeon[i][j] + max(dp[i+1][j], dp[i][j+1]));\\n            }\\n        }\\n        return 1 + max(-dp[0][0], 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447899,
                "title": "python-straightforward-memoization",
                "content": "```python\\ndef calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n\\tm, n = len(dungeon), len(dungeon[0])\\n\\t# returns minimum possible amount of health required at position (i, j)\\n\\tdef calculate(i, j):\\n\\t\\tif i == m or j == n:\\n\\t\\t\\treturn float(\\'inf\\')\\n\\t\\telif i == m-1 and j == n-1:\\n\\t\\t\\treturn max(1,  1 - dungeon[i][j])\\n\\t\\telif (i, j) in memory:\\n\\t\\t\\treturn memory[i, j]\\n\\t\\tdown = calculate(i+1, j) # min health required to go down and survive\\n\\t\\tright = calculate(i, j+1) # min health required to go right and survive\\n\\t\\tcur = min(max(down - dungeon[i][j], 1), max(right - dungeon[i][j], 1))\\n\\t\\tmemory[i, j] = cur\\n\\t\\treturn cur\\n\\tmemory = {}\\n\\treturn calculate(0, 0)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n\\tm, n = len(dungeon), len(dungeon[0])\\n\\t# returns minimum possible amount of health required at position (i, j)\\n\\tdef calculate(i, j):\\n\\t\\tif i == m or j == n:\\n\\t\\t\\treturn float(\\'inf\\')\\n\\t\\telif i == m-1 and j == n-1:\\n\\t\\t\\treturn max(1,  1 - dungeon[i][j])\\n\\t\\telif (i, j) in memory:\\n\\t\\t\\treturn memory[i, j]\\n\\t\\tdown = calculate(i+1, j) # min health required to go down and survive\\n\\t\\tright = calculate(i, j+1) # min health required to go right and survive\\n\\t\\tcur = min(max(down - dungeon[i][j], 1), max(right - dungeon[i][j], 1))\\n\\t\\tmemory[i, j] = cur\\n\\t\\treturn cur\\n\\tmemory = {}\\n\\treturn calculate(0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 376060,
                "title": "java-100-dp-top-down-bottom-up-space-optimzied",
                "content": "```\\nThis question is extension of https://leetcode.com/problems/minimum-path-sum/\\n```\\n\\nWe\\'ll apply same logic as above question. Lets first understand the algorithm.\\n\\n In order to find the minimum health that  knight should have, is all depends how he is able to reach at the Princes.\\n  In case we need to find a number that make sure knight should alive at the end, then we can assign any big number\\n  that is enough to reach from (0,0) to (m-1,n-1)\\n  \\n  Since we need to find `\\'minimum\\'` health to be, we need to traverse back from princes (m-1,n-1)  to (0,0)\\n  and see, what is the minimum value expected to be.\\n  Example:\\n  \\n        -2 (K)\\t    -3\\t    3\\n        -5\\t        -10\\t    1\\n         10\\t        30\\t   -5 (P)\\n\\n  -5 -> 1 -> 3 -> -3 -> -2 = -6 means with health 6, knight will reach prices but he\\'ll get die as health become zero. Hence answer is 7\\n  \\n```\\n  -8, -6, 3\\n   2, 8, -10\\n  -8,-12,-6\\n```\\n  -6 -> -10 -> 8 -> 2 -> -8 = -14 => 15 is our answer\\n  \\n  Hence, we need to see the optimal path from bottom-to-top. \\n  \\n```\\n minHealth(i, j)  = Min ( minHealth(i+1,j), minHealth(i,j+1) )  - grid[i][j]\\nreturn minHealth[i][j] <= 0 ? 1 : minHealth[i][j]  {power-ups}\\n\\nBase case: When there is only one cell, and you are at princes. \\nThen if grid[m-1][n-1] > 0 Means you don\\'t need extra health, as no one is proteting princies {but has power-ups} Hence \\'1\\'\\notherwise -grid[m-1][n-1] +1 because at least that much blood will be taken by that guard. \\n\\n```\\n\\n\\n**Top - Down implemenation **\\n* Runtime: 0 ms, faster than 100.00% of Java online submissions for Dungeon Game.\\n * Memory Usage: 36.2 MB, less than 100.00% of Java online submissions for Dungeon Game.\\n \\n```\\npublic int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n\\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        int dp[][] = new int[m][n];\\n\\n        //when you are at princes . m-1,n-1\\n        dp[m - 1][n - 1] = dungeon[m - 1][n - 1] >= 0 ? 1 : -dungeon[m - 1][n - 1] + 1;\\n\\n        return calculateMinimumHP(dungeon, 0, 0, dp);\\n\\n\\n    }\\n\\n    private int calculateMinimumHP(int[][] dungeon, int i, int j, int[][] dp) {\\n        if (i >= dungeon.length || j >= dungeon[0].length)\\n            return Integer.MAX_VALUE;\\n\\n        if (dp[i][j] != 0)\\n            return dp[i][j];\\n\\n\\n        int down = calculateMinimumHP(dungeon, i + 1, j, dp);\\n        int right = calculateMinimumHP(dungeon, i, j + 1, dp);\\n\\n        int min = Math.min(down, right);\\n\\n\\n        final int hp = min - dungeon[i][j];\\n\\n        dp[i][j] = hp <= 0 ? 1 : hp;\\n\\n\\n        return dp[i][j];\\n    }\\n```\\n\\n\\nTranslate above to Bottom up dp\\n```\\ndp[i][j] Minimum health by coming from either [i+1][j] or [i][j+1]\\ndp[i][j] = {    dungeon[i][j] > 0 ? 1 : -dungeon[i][j] + 1; ; i==m-1, j==n-1\\n\\t\\t\\t\\t\\tMin{dp[i+1][j] , dp[i][j+1]} - grid[i][j] ; i < m-1 && j<n-1;\\n\\t\\t\\t\\t\\tdp[i][j+1] - grid[i][j] ; i==m-1 && j<n-1\\n\\t\\t\\t\\t\\tdp[i + 1][j] - dungeon[i][j];  j == n-1; i<m-1\\n\\t\\t\\t\\t\\t\\ndp[i][j] <= 0 ? 1 : dp[i][j]\\n\\nSolution dp[0][0]\\n```\\n * Runtime: 2 ms, faster than 47.89% of Java online submissions for Dungeon Game.\\n * Memory Usage: 42.5 MB, less than 58.82% of Java online submissions for Dungeon Game.\\n```\\n public int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n\\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        int dp[][] = new int[m][n];\\n\\n        for (int i = m - 1; i >= 0; i--) {\\n\\n            for (int j = n - 1; j >= 0; j--) {\\n\\n                //when you are at princes . m-1,n-1\\n                if (i == m - 1 && j == n - 1)\\n                    dp[i][j] = dungeon[i][j] > 0 ? 1 : -dungeon[i][j] + 1;\\n                else if (i == m - 1)\\n                    dp[i][j] = dp[i][j + 1] - dungeon[i][j];\\n                else if (j == n - 1)\\n                    dp[i][j] = dp[i + 1][j] - dungeon[i][j];\\n                else {\\n\\n                    dp[i][j] = Math.min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];\\n                }\\n\\n                dp[i][j] = dp[i][j] <= 0 ? 1 : dp[i][j];\\n\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n```\\n\\nSpace optimization:\\n * Only two rows are used at a time\\n```\\n  dp[i+1][j] => dp[j]\\n  dp[i][j+1] => dp[j+1]\\n```\\n\\n * Runtime: 1 ms, faster than 96.34% of Java online submissions for Dungeon Game.\\n * Memory Usage: 42.3 MB, less than 58.82% of Java online submissions for Dungeon Game.\\n \\n```\\npublic int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n\\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        int dp[] = new int[n];\\n\\n        for (int i = m - 1; i >= 0; i--) {\\n\\n            for (int j = n - 1; j >= 0; j--) {\\n\\n                //when you are at princes . m-1,n-1\\n                if (i == m - 1 && j == n - 1)\\n                    dp[j] = dungeon[i][j] > 0 ? 1 : -dungeon[i][j] + 1;\\n                else if (i == m - 1)\\n                    dp[j] = dp[j + 1] - dungeon[i][j];\\n                else if (j == n - 1)\\n                    dp[j] = dp[j] - dungeon[i][j];\\n                else {\\n\\n                    dp[j] = Math.min(dp[j], dp[j + 1]) - dungeon[i][j];\\n                }\\n\\n                dp[j] = dp[j] <= 0 ? 1 : dp[j];\\n\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nThis question is extension of https://leetcode.com/problems/minimum-path-sum/\\n```\n```\\n  -8, -6, 3\\n   2, 8, -10\\n  -8,-12,-6\\n```\n```\\n minHealth(i, j)  = Min ( minHealth(i+1,j), minHealth(i,j+1) )  - grid[i][j]\\nreturn minHealth[i][j] <= 0 ? 1 : minHealth[i][j]  {power-ups}\\n\\nBase case: When there is only one cell, and you are at princes. \\nThen if grid[m-1][n-1] > 0 Means you don\\'t need extra health, as no one is proteting princies {but has power-ups} Hence \\'1\\'\\notherwise -grid[m-1][n-1] +1 because at least that much blood will be taken by that guard. \\n\\n```\n```\\npublic int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n\\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        int dp[][] = new int[m][n];\\n\\n        //when you are at princes . m-1,n-1\\n        dp[m - 1][n - 1] = dungeon[m - 1][n - 1] >= 0 ? 1 : -dungeon[m - 1][n - 1] + 1;\\n\\n        return calculateMinimumHP(dungeon, 0, 0, dp);\\n\\n\\n    }\\n\\n    private int calculateMinimumHP(int[][] dungeon, int i, int j, int[][] dp) {\\n        if (i >= dungeon.length || j >= dungeon[0].length)\\n            return Integer.MAX_VALUE;\\n\\n        if (dp[i][j] != 0)\\n            return dp[i][j];\\n\\n\\n        int down = calculateMinimumHP(dungeon, i + 1, j, dp);\\n        int right = calculateMinimumHP(dungeon, i, j + 1, dp);\\n\\n        int min = Math.min(down, right);\\n\\n\\n        final int hp = min - dungeon[i][j];\\n\\n        dp[i][j] = hp <= 0 ? 1 : hp;\\n\\n\\n        return dp[i][j];\\n    }\\n```\n```\\ndp[i][j] Minimum health by coming from either [i+1][j] or [i][j+1]\\ndp[i][j] = {    dungeon[i][j] > 0 ? 1 : -dungeon[i][j] + 1; ; i==m-1, j==n-1\\n\\t\\t\\t\\t\\tMin{dp[i+1][j] , dp[i][j+1]} - grid[i][j] ; i < m-1 && j<n-1;\\n\\t\\t\\t\\t\\tdp[i][j+1] - grid[i][j] ; i==m-1 && j<n-1\\n\\t\\t\\t\\t\\tdp[i + 1][j] - dungeon[i][j];  j == n-1; i<m-1\\n\\t\\t\\t\\t\\t\\ndp[i][j] <= 0 ? 1 : dp[i][j]\\n\\nSolution dp[0][0]\\n```\n```\\n public int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n\\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        int dp[][] = new int[m][n];\\n\\n        for (int i = m - 1; i >= 0; i--) {\\n\\n            for (int j = n - 1; j >= 0; j--) {\\n\\n                //when you are at princes . m-1,n-1\\n                if (i == m - 1 && j == n - 1)\\n                    dp[i][j] = dungeon[i][j] > 0 ? 1 : -dungeon[i][j] + 1;\\n                else if (i == m - 1)\\n                    dp[i][j] = dp[i][j + 1] - dungeon[i][j];\\n                else if (j == n - 1)\\n                    dp[i][j] = dp[i + 1][j] - dungeon[i][j];\\n                else {\\n\\n                    dp[i][j] = Math.min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];\\n                }\\n\\n                dp[i][j] = dp[i][j] <= 0 ? 1 : dp[i][j];\\n\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n```\n```\\n  dp[i+1][j] => dp[j]\\n  dp[i][j+1] => dp[j+1]\\n```\n```\\npublic int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n\\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        int dp[] = new int[n];\\n\\n        for (int i = m - 1; i >= 0; i--) {\\n\\n            for (int j = n - 1; j >= 0; j--) {\\n\\n                //when you are at princes . m-1,n-1\\n                if (i == m - 1 && j == n - 1)\\n                    dp[j] = dungeon[i][j] > 0 ? 1 : -dungeon[i][j] + 1;\\n                else if (i == m - 1)\\n                    dp[j] = dp[j + 1] - dungeon[i][j];\\n                else if (j == n - 1)\\n                    dp[j] = dp[j] - dungeon[i][j];\\n                else {\\n\\n                    dp[j] = Math.min(dp[j], dp[j + 1]) - dungeon[i][j];\\n                }\\n\\n                dp[j] = dp[j] <= 0 ? 1 : dp[j];\\n\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52869,
                "title": "python-easy-to-understand-solutions-o-m-n-o-n-space",
                "content": "        \\n    # O(m*n) space\\n    def calculateMinimumHP1(self, dungeon):\\n        if not dungeon:\\n            return \\n        r, c = len(dungeon), len(dungeon[0])\\n        dp = [[0 for _ in xrange(c)] for _ in xrange(r)]\\n        dp[-1][-1] = max(1, 1-dungeon[-1][-1])\\n        for i in xrange(c-2, -1, -1):\\n            dp[-1][i] = max(1, dp[-1][i+1]-dungeon[-1][i])\\n        for i in xrange(r-2, -1, -1):\\n            dp[i][-1] = max(1, dp[i+1][-1]-dungeon[i][-1])\\n        for i in xrange(r-2, -1, -1):\\n            for j in xrange(c-2, -1, -1):\\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1])-dungeon[i][j])\\n        return dp[0][0]\\n        \\n    # O(n) space\\n    def calculateMinimumHP(self, dungeon):\\n        if not dungeon:\\n            return \\n        r, c = len(dungeon), len(dungeon[0])\\n        dp = [0 for _ in xrange(c)]\\n        dp[-1] = max(1, 1-dungeon[-1][-1])\\n        for i in xrange(c-2, -1, -1):\\n            dp[i] = max(1, dp[i+1]-dungeon[-1][i])\\n        for i in xrange(r-2, -1, -1):\\n            dp[-1] = max(1, dp[-1]-dungeon[i][-1])\\n            for j in xrange(c-2, -1, -1):\\n                dp[j] = max(1, min(dp[j], dp[j+1])-dungeon[i][j])\\n        return dp[0]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "        \\n    # O(m*n) space\\n    def calculateMinimumHP1(self, dungeon):\\n        if not dungeon:\\n            return \\n        r, c = len(dungeon), len(dungeon[0])\\n        dp = [[0 for _ in xrange(c)] for _ in xrange(r)]\\n        dp[-1][-1] = max(1, 1-dungeon[-1][-1])\\n        for i in xrange(c-2, -1, -1):\\n            dp[-1][i] = max(1, dp[-1][i+1]-dungeon[-1][i])\\n        for i in xrange(r-2, -1, -1):\\n            dp[i][-1] = max(1, dp[i+1][-1]-dungeon[i][-1])\\n        for i in xrange(r-2, -1, -1):\\n            for j in xrange(c-2, -1, -1):\\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1])-dungeon[i][j])\\n        return dp[0][0]\\n        \\n    # O(n) space\\n    def calculateMinimumHP(self, dungeon):\\n        if not dungeon:\\n            return \\n        r, c = len(dungeon), len(dungeon[0])\\n        dp = [0 for _ in xrange(c)]\\n        dp[-1] = max(1, 1-dungeon[-1][-1])\\n        for i in xrange(c-2, -1, -1):\\n            dp[i] = max(1, dp[i+1]-dungeon[-1][i])\\n        for i in xrange(r-2, -1, -1):\\n            dp[-1] = max(1, dp[-1]-dungeon[i][-1])\\n            for j in xrange(c-2, -1, -1):\\n                dp[j] = max(1, min(dp[j], dp[j+1])-dungeon[i][j])\\n        return dp[0]",
                "codeTag": "Python3"
            },
            {
                "id": 2433560,
                "title": "easy-bottom-up-dp-solution-c",
                "content": "*important*\\n\\nIn this problem, we need to use bottom up DP approach but in a reverse way. That is, we start from the end of matrix.\\n\\n```\\n    int calculateMinimumHP(vector<vector<int>>& dun) {\\n        \\n        int n = dun.size();\\n        int m = dun[0].size();\\n        \\n        int dp[n][m];\\n        memset(dp,0,sizeof(dp));\\n        \\n        for(int i=n-1; i>=0; i--){\\n            for(int j=m-1;j>=0;j-- ){\\n                \\n                if(i==n-1 and j==m-1)\\n                    dp[i][j] = dun[i][j];                \\n                else if(i==n-1)\\n                    dp[i][j] = dun[i][j] + dp[i][j+1];                  \\n                else if( j==m-1)\\n                    dp[i][j] = dun[i][j] + dp[i+1][j];  \\n                else\\n                    dp[i][j] = dun[i][j] + max(dp[i+1][j], dp[i][j+1]);                    \\n                \\n                \\n                //to make positive values zero\\n                if(dp[i][j]>0)\\n                        dp[i][j] = 0;\\n            }\\n        }\\n        \\n        \\n        if(dp[0][0]>=0)\\n            return 1;\\n        else \\n            return (abs(dp[0][0])+1);\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int calculateMinimumHP(vector<vector<int>>& dun) {\\n        \\n        int n = dun.size();\\n        int m = dun[0].size();\\n        \\n        int dp[n][m];\\n        memset(dp,0,sizeof(dp));\\n        \\n        for(int i=n-1; i>=0; i--){\\n            for(int j=m-1;j>=0;j-- ){\\n                \\n                if(i==n-1 and j==m-1)\\n                    dp[i][j] = dun[i][j];                \\n                else if(i==n-1)\\n                    dp[i][j] = dun[i][j] + dp[i][j+1];                  \\n                else if( j==m-1)\\n                    dp[i][j] = dun[i][j] + dp[i+1][j];  \\n                else\\n                    dp[i][j] = dun[i][j] + max(dp[i+1][j], dp[i][j+1]);                    \\n                \\n                \\n                //to make positive values zero\\n                if(dp[i][j]>0)\\n                        dp[i][j] = 0;\\n            }\\n        }\\n        \\n        \\n        if(dp[0][0]>=0)\\n            return 1;\\n        else \\n            return (abs(dp[0][0])+1);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2174366,
                "title": "c-dp-with-image-explanation",
                "content": "* Consider the image below for explanation. The answer is implemented using recursion considering the approach explained in the image. Matrix DP is used to optimize it by memoization.\\n* Answer could be completely converted without recursion as well, by using bottom up DP matrix\\n\\n![image](https://assets.leetcode.com/users/images/827425ee-c868-466c-9c68-3261475069d9_1655725663.4921842.jpeg)\\n\\n```\\nclass Solution {\\n    int dp[201][201];\\nprivate:\\n    int Calculate_DP(int i, int j, vector<vector<int>> &dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        if(i == m || j == n)\\n            return INT_MAX;\\n        \\n        if(i == (m - 1) && j == (n - 1))\\n            return dungeon[i][j] < 0 ? -dungeon[i][j] + 1 : 1;\\n        \\n        int right_val = Calculate_DP(i, j + 1, dungeon); // Answer for the right cell if we move right\\n        int down_val = Calculate_DP(i + 1, j, dungeon); // Answer for the below cell if we move down\\n        \\n        int min_health_required = min(right_val, down_val) - dungeon[i][j];\\n        \\n        return dp[i][j] = min_health_required <= 0 ? 1: min_health_required;\\n    }\\n    \\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        memset(dp, -1, sizeof dp);\\n        return Calculate_DP(0, 0, dungeon);\\n    }\\n};\\n```\\n\\nFeel free to ask doubts",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int dp[201][201];\\nprivate:\\n    int Calculate_DP(int i, int j, vector<vector<int>> &dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        if(i == m || j == n)\\n            return INT_MAX;\\n        \\n        if(i == (m - 1) && j == (n - 1))\\n            return dungeon[i][j] < 0 ? -dungeon[i][j] + 1 : 1;\\n        \\n        int right_val = Calculate_DP(i, j + 1, dungeon); // Answer for the right cell if we move right\\n        int down_val = Calculate_DP(i + 1, j, dungeon); // Answer for the below cell if we move down\\n        \\n        int min_health_required = min(right_val, down_val) - dungeon[i][j];\\n        \\n        return dp[i][j] = min_health_required <= 0 ? 1: min_health_required;\\n    }\\n    \\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        memset(dp, -1, sizeof dp);\\n        return Calculate_DP(0, 0, dungeon);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941108,
                "title": "c-recursion-memorization",
                "content": "a typical board traversal problem. We can use a recursive function to return the min health needed when starting from i,j position\\n\\n```\\nclass Solution {\\n    // enter i,j, min health to reach last cell\\n    \\n    int solve (vector<vector<int>>& dungeon, int i, int j)\\n    {\\n        // out of bounds, return max cost to avoid choosing it\\n        if (i==row || j==col) return INT_MAX;  \\n        \\n        if (i==row-1 && j==col-1)\\n        {\\n            if (dungeon[i][j]<0)\\n                return 1-dungeon[i][j];\\n            else \\n                return 1; \\n        }\\n        \\n        if (memo[i][j]!=INT_MAX)\\n            return memo[i][j]; \\n        // now we enter other cell:\\n        // we have two choice\\n        int right_min = solve (dungeon, i,j+1);\\n        int down_min = solve (dungeon, i+1, j);\\n        \\n        // -3  5 // two \\n        //  4\\n        \\n        //  2  5  // min_next - cell if (cell)\\n        //  4\\n        int min_next = min (right_min, down_min);\\n        // to reach min_next\\n        \\n        int ret; \\n        if (dungeon[i][j]>=min_next)\\n            ret= 1; //\\n        else\\n            ret = min_next - dungeon[i][j];\\n        \\n        memo[i][j]=ret; \\n        return memo[i][j];\\n        \\n    }\\n    int row, col; \\n    // do I need memo? yes\\n    vector<vector<int>> memo; \\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        row=dungeon.size(); \\n        if (!row) return 1; \\n        col=dungeon[0].size();\\n        memo.resize(row, vector<int>(col, INT_MAX)); \\n        \\n        return solve (dungeon, 0,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // enter i,j, min health to reach last cell\\n    \\n    int solve (vector<vector<int>>& dungeon, int i, int j)\\n    {\\n        // out of bounds, return max cost to avoid choosing it\\n        if (i==row || j==col) return INT_MAX;  \\n        \\n        if (i==row-1 && j==col-1)\\n        {\\n            if (dungeon[i][j]<0)\\n                return 1-dungeon[i][j];\\n            else \\n                return 1; \\n        }\\n        \\n        if (memo[i][j]!=INT_MAX)\\n            return memo[i][j]; \\n        // now we enter other cell:\\n        // we have two choice\\n        int right_min = solve (dungeon, i,j+1);\\n        int down_min = solve (dungeon, i+1, j);\\n        \\n        // -3  5 // two \\n        //  4\\n        \\n        //  2  5  // min_next - cell if (cell)\\n        //  4\\n        int min_next = min (right_min, down_min);\\n        // to reach min_next\\n        \\n        int ret; \\n        if (dungeon[i][j]>=min_next)\\n            ret= 1; //\\n        else\\n            ret = min_next - dungeon[i][j];\\n        \\n        memo[i][j]=ret; \\n        return memo[i][j];\\n        \\n    }\\n    int row, col; \\n    // do I need memo? yes\\n    vector<vector<int>> memo; \\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        row=dungeon.size(); \\n        if (!row) return 1; \\n        col=dungeon[0].size();\\n        memo.resize(row, vector<int>(col, INT_MAX)); \\n        \\n        return solve (dungeon, 0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772663,
                "title": "recursion-with-memoization-top-down-solution-in-java-beats-100-in-runtime",
                "content": "```\\nclass Solution {    \\n    public static int[][] dp;\\n    \\n    public int calculateMinimumHP(int[][] dungeon) {        \\n        dp = new int[dungeon.length][dungeon[0].length];\\n        \\n        for (int i = 0; i < dungeon.length; i++)\\n            Arrays.fill(dp[i], -1);\\n        \\n        return f(dungeon, 0, 0);\\n    }\\n    \\n    public int f(int[][] dungeon, int n, int m) {\\n        if (n >= dungeon.length || m >= dungeon[0].length)\\n            return Integer.MAX_VALUE;\\n        \\n        if (n == dungeon.length - 1 && m == dungeon[0].length - 1)\\n            return Math.max(1, 1 - dungeon[n][m]);\\n        \\n        if (dp[n][m] != -1)\\n            return dp[n][m];\\n        \\n        int res = Math.min(f(dungeon, n + 1, m), f(dungeon, n, m + 1)) - dungeon[n][m];\\n        res = Math.max(1, res);\\n        \\n        return dp[n][m] = res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {    \\n    public static int[][] dp;\\n    \\n    public int calculateMinimumHP(int[][] dungeon) {        \\n        dp = new int[dungeon.length][dungeon[0].length];\\n        \\n        for (int i = 0; i < dungeon.length; i++)\\n            Arrays.fill(dp[i], -1);\\n        \\n        return f(dungeon, 0, 0);\\n    }\\n    \\n    public int f(int[][] dungeon, int n, int m) {\\n        if (n >= dungeon.length || m >= dungeon[0].length)\\n            return Integer.MAX_VALUE;\\n        \\n        if (n == dungeon.length - 1 && m == dungeon[0].length - 1)\\n            return Math.max(1, 1 - dungeon[n][m]);\\n        \\n        if (dp[n][m] != -1)\\n            return dp[n][m];\\n        \\n        int res = Math.min(f(dungeon, n + 1, m), f(dungeon, n, m + 1)) - dungeon[n][m];\\n        res = Math.max(1, res);\\n        \\n        return dp[n][m] = res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 771711,
                "title": "c-dp-easy-fast-o-m-n-tc",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        // dp[i][j]: hp needed at dungeon[i][j]\\n        int m = dungeon.size(), n = dungeon[0].size();\\n        vector<vector<int>> dp (m+1,vector<int>(n+1,INT_MAX));\\n        dp[m][n-1] = dp[m-1][n] = 1;\\n        for(int i=m-1;i>=0;--i){\\n            for(int j=n-1;j>=0;--j){\\n                dp[i][j] = max(1,min(dp[i+1][j],dp[i][j+1])-dungeon[i][j]);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        // dp[i][j]: hp needed at dungeon[i][j]\\n        int m = dungeon.size(), n = dungeon[0].size();\\n        vector<vector<int>> dp (m+1,vector<int>(n+1,INT_MAX));\\n        dp[m][n-1] = dp[m-1][n] = 1;\\n        for(int i=m-1;i>=0;--i){\\n            for(int j=n-1;j>=0;--j){\\n                dp[i][j] = max(1,min(dp[i+1][j],dp[i][j+1])-dungeon[i][j]);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761905,
                "title": "c-dp-solution-by-codeforces-red-coder",
                "content": "**DP State-** dp[i][j] is the amount of health required by the knight before entering the dungeon(i, j) cell.\\n\\nInitialize dp[n-1][m-1] with the value required based on a few facts.\\nThe health of the knight before entering any cell should be at least 1. So if the value of the last dungeon cell is +ve, we need at least 1 health before entering.\\nThe health of the knight after going into the cell should also be at least 1. So if the value of the last dungeon cell is -ve, we need at least 1-(dungeon[n-1][m-1] before entering the cell.\\n\\nWe build the the DP table bottom up. \\nThe health required before entering a cell is the minimum of the health required in it\\'s neighbouring cells +- the value of the cell (positive or negative accordingly).\\n\\n```\\nconst int inf = 1e9+7;\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& v) {\\n        int n = v.size();\\n        int m = v[0].size();\\n        \\n        vector<vector<int> > dp(n, vector<int> (m, inf));\\n        \\n        dp[n-1][m-1] = v[n-1][m-1]>0 ? 1 : 1-v[n-1][m-1];\\n        \\n        for(int i=n-1; i>=0; i--){\\n            for(int j=m-1; j>=0; j--){\\n                if(i<n-1){\\n                    dp[i][j] = min(dp[i][j], dp[i+1][j]);\\n                }\\n                if(j<m-1){\\n                    dp[i][j] = min(dp[i][j], dp[i][j+1]);\\n                }\\n                if(i!=n-1 || j!=m-1){\\n                    dp[i][j]-=v[i][j];\\n                    if(dp[i][j]<=0){\\n                        dp[i][j] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        // for(int i=0; i<n; i++){\\n        //     for(int j=0; j<m; j++){\\n        //         cout<<dp[i][j]<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        \\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int inf = 1e9+7;\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& v) {\\n        int n = v.size();\\n        int m = v[0].size();\\n        \\n        vector<vector<int> > dp(n, vector<int> (m, inf));\\n        \\n        dp[n-1][m-1] = v[n-1][m-1]>0 ? 1 : 1-v[n-1][m-1];\\n        \\n        for(int i=n-1; i>=0; i--){\\n            for(int j=m-1; j>=0; j--){\\n                if(i<n-1){\\n                    dp[i][j] = min(dp[i][j], dp[i+1][j]);\\n                }\\n                if(j<m-1){\\n                    dp[i][j] = min(dp[i][j], dp[i][j+1]);\\n                }\\n                if(i!=n-1 || j!=m-1){\\n                    dp[i][j]-=v[i][j];\\n                    if(dp[i][j]<=0){\\n                        dp[i][j] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        // for(int i=0; i<n; i++){\\n        //     for(int j=0; j<m; j++){\\n        //         cout<<dp[i][j]<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        \\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 423092,
                "title": "clean-clear-java-dp-solution-top-down-and-bottom-up-with-explanation-0ms-beat-100",
                "content": "bottom-up implementation bases on happygirlzt\\'s video on youtube\\n\\n```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        // health array store the min hp require when reaching the current point (before beating the obstacle)\\n        // condtion: as least 1 hp at each tile before and after\\n        // to get to the current tile at the require hp: health[cur] = health[prev] - dungeon[prev] (obstacle)\\n        //\\n        // building the health array: need to satisfy 2 things:\\n        // * in the recursive loop, every location, we can move right or down\\n        // * ending condition: last tile move would end with 1hp\\n        // * edge cases: cannot go out of bound \\n        // 2 similar ways:\\n        // * [rNum][cNum] & process 3 cases (last tile, last row, last col) before the main loop\\n        // * [rNum+1][cNum+1] make 1 extra unit each side. Then set the ending condition tiles (right/down from [rNum-1][cNum-1]) to 1 & set the edges to maxInt to avoid going out of bound\\n        //\\n        // recurive move:\\n        // at evevery tile we can either move down or right, find the minimum hp required to come in this tile and survive at least 1 of those moves.\\n        // since we start with the end goal, this guarrantees that both moves would get us to the goal as long as we end this tile with health[nextTile]\\n        \\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n        \\n        int rNum = dungeon.length, cNum = dungeon[0].length;\\n\\n        int[][] health = new int[rNum+1][cNum+1];\\n        // block borders: can fill the whole array, since only the last column and row use these values\\n        for (int[] row : health)\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        // ending condition:\\n        health[rNum][cNum-1] = 1;\\n        health[rNum-1][cNum] = 1;\\n        // recursive move\\n        for (int r = rNum - 1; r >= 0; r--) {\\n            for (int c = cNum - 1; c >= 0; c--) {\\n                int next = Math.min(health[r+1][c], health[r][c+1]);\\n                health[r][c] = Math.max(next - dungeon[r][c], 1);\\n            }\\n        }\\n        return health[0][0];\\n    }\\n}\\n```\\n\\n\\ntop-down memoization bases on the same idea:\\n\\n```\\nclass Solution {\\n    int[][] cache;\\n    int[][] dungeon;\\n    \\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n        this.cache = new int[dungeon.length][dungeon[0].length];\\n        this.dungeon = dungeon;\\n        return dfs(0, 0);\\n    }\\n    \\n    private int dfs(int r, int c) {\\n        // out of bound\\n        if(r >= dungeon.length || c >= dungeon[0].length)\\n            return Integer.MAX_VALUE;\\n        // check cache\\n        if (cache[r][c] > 0) return cache[r][c];\\n        // recursive move\\n        int next = Math.min(dfs(r+1,c), dfs(r,c+1));\\n        // the only location that both right and down move leads to out-of-bound is the end state\\n        next = next == Integer.MAX_VALUE ? 1 : next;\\n        int res = Math.max(next - dungeon[r][c], 1);\\n        cache[r][c] = res;\\n        return cache[r][c];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        // health array store the min hp require when reaching the current point (before beating the obstacle)\\n        // condtion: as least 1 hp at each tile before and after\\n        // to get to the current tile at the require hp: health[cur] = health[prev] - dungeon[prev] (obstacle)\\n        //\\n        // building the health array: need to satisfy 2 things:\\n        // * in the recursive loop, every location, we can move right or down\\n        // * ending condition: last tile move would end with 1hp\\n        // * edge cases: cannot go out of bound \\n        // 2 similar ways:\\n        // * [rNum][cNum] & process 3 cases (last tile, last row, last col) before the main loop\\n        // * [rNum+1][cNum+1] make 1 extra unit each side. Then set the ending condition tiles (right/down from [rNum-1][cNum-1]) to 1 & set the edges to maxInt to avoid going out of bound\\n        //\\n        // recurive move:\\n        // at evevery tile we can either move down or right, find the minimum hp required to come in this tile and survive at least 1 of those moves.\\n        // since we start with the end goal, this guarrantees that both moves would get us to the goal as long as we end this tile with health[nextTile]\\n        \\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n        \\n        int rNum = dungeon.length, cNum = dungeon[0].length;\\n\\n        int[][] health = new int[rNum+1][cNum+1];\\n        // block borders: can fill the whole array, since only the last column and row use these values\\n        for (int[] row : health)\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        // ending condition:\\n        health[rNum][cNum-1] = 1;\\n        health[rNum-1][cNum] = 1;\\n        // recursive move\\n        for (int r = rNum - 1; r >= 0; r--) {\\n            for (int c = cNum - 1; c >= 0; c--) {\\n                int next = Math.min(health[r+1][c], health[r][c+1]);\\n                health[r][c] = Math.max(next - dungeon[r][c], 1);\\n            }\\n        }\\n        return health[0][0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[][] cache;\\n    int[][] dungeon;\\n    \\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n        this.cache = new int[dungeon.length][dungeon[0].length];\\n        this.dungeon = dungeon;\\n        return dfs(0, 0);\\n    }\\n    \\n    private int dfs(int r, int c) {\\n        // out of bound\\n        if(r >= dungeon.length || c >= dungeon[0].length)\\n            return Integer.MAX_VALUE;\\n        // check cache\\n        if (cache[r][c] > 0) return cache[r][c];\\n        // recursive move\\n        int next = Math.min(dfs(r+1,c), dfs(r,c+1));\\n        // the only location that both right and down move leads to out-of-bound is the end state\\n        next = next == Integer.MAX_VALUE ? 1 : next;\\n        int res = Math.max(next - dungeon[r][c], 1);\\n        cache[r][c] = res;\\n        return cache[r][c];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 275325,
                "title": "python-concise-dp",
                "content": "We can use ```dp[i][j]``` to store the minimal health we need at ```dungeon[i][j]```. And knight needs at least 1 health wherever it is. \\nSince knight should either go right or down, ```dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)```. \\nTo avoid special handle for border cell, I introduce a pivot row and column at bottom and rightmost in my dp array. The cells are filled with ```inf``` so knight will never choose to go to there. While I set right-bottom corner cells to ```1```s, indicating knight should eventully **pass** ```dungeon[-1][-1] ``` with at least health 1. That\\'s our recurrence base.\\nSo after recurrence, ```dp[0][0]``` will have the minimal health knight needs to walk to princess.\\n```\\ndef calculateMinimumHP(dungeon):\\n\\tm, n = len(dungeon), len(dungeon[0])\\n\\tdp = [[0]*n + [float(\\'inf\\')] for _ in range(m)] + [[float(\\'inf\\')]*(n-1)+[1,1]]\\n\\tfor i in range(m)[::-1]:\\n\\t\\tfor j in range(n)[::-1]:\\n\\t\\t\\tdp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)\\n\\treturn dp[0][0]\\n```",
                "solutionTags": [],
                "code": "```dp[i][j]```\n```dungeon[i][j]```\n```dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)```\n```inf```\n```1```\n```dungeon[-1][-1] ```\n```dp[0][0]```\n```\\ndef calculateMinimumHP(dungeon):\\n\\tm, n = len(dungeon), len(dungeon[0])\\n\\tdp = [[0]*n + [float(\\'inf\\')] for _ in range(m)] + [[float(\\'inf\\')]*(n-1)+[1,1]]\\n\\tfor i in range(m)[::-1]:\\n\\t\\tfor j in range(n)[::-1]:\\n\\t\\t\\tdp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)\\n\\treturn dp[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 52801,
                "title": "generic-idea-for-board-movement-problems-java-solution",
                "content": "All these \"Move from top left to bottom right by only moving rightward or downward\" problems can be solved using the same DP idea which can be extended to multiple problems.\\n\\nStart from the end point (bottom right) and work backward (top left).\\n\\nHere's a solution to \"Unique Paths\".\\nhttps://leetcode.com/problems/unique-paths/\\n```\\n        for(int i = m - 1; i >= 0; i--)\\n        {\\n            for(int j = n - 1; j >= 0; j--)\\n            {\\n                if(i == m-1 && j != n-1)\\n                {\\n                    dp[i][j] = dp[i][j+1];\\n                }\\n                else if( i != m-1 && j == n-1)\\n                {\\n                    dp[i][j] = dp[i+1][j];\\n                }\\n                else if(i != m-1 && j != n-1)\\n                {\\n                    dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n```\\n\\nHere's a solution to \"Minimum Path Sum\" which is very similar:\\nhttps://leetcode.com/problems/minimum-path-sum/\\n\\n```\\n        for(int i = rows - 1; i >= 0; i--)\\n        {\\n            for(int j = cols - 1; j >= 0; j--)\\n            {\\n                if(i == rows-1 && j != cols-1)\\n                {\\n                    dp[i][j] = grid[i][j] + dp[i][j+1];\\n                }\\n                \\n                else if(i != rows-1 && j == cols-1)\\n                {\\n                    dp[i][j] = grid[i][j] + dp[i+1][j];\\n                }\\n                \\n                else if(i != rows-1 && j != cols-1)\\n                {\\n                    dp[i][j] = grid[i][j] + Math.min(dp[i][j+1], dp[i+1][j]);\\n                }\\n                \\n                else\\n                {\\n                    dp[i][j] = grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n```\\nThis method can be extended to the \"Dungeon Game\" as well:\\n\\n```\\npublic class Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        \\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        \\n        int[][] dp = new int[m][n];\\n        \\n        for(int i = m - 1; i >= 0; i--)\\n        {\\n            for(int j = n - 1; j >= 0; j--)\\n            {\\n                if(i == m-1 && j != n-1)\\n                {\\n                    dp[i][j] = Math.max(1, dp[i][j+1] - dungeon[i][j]);\\n                }\\n                else if(i != m-1 && j == n-1)\\n                {\\n                    dp[i][j] = Math.max(1, dp[i+1][j] - dungeon[i][j]);\\n                }\\n                else if(i != m-1 && j != n-1)\\n                {\\n                    dp[i][j] = Math.max(1, Math.min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);\\n                }\\n                else\\n                {\\n                    dp[i][j] = Math.max(1, 1 - dungeon[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n        for(int i = m - 1; i >= 0; i--)\\n        {\\n            for(int j = n - 1; j >= 0; j--)\\n            {\\n                if(i == m-1 && j != n-1)\\n                {\\n                    dp[i][j] = dp[i][j+1];\\n                }\\n                else if( i != m-1 && j == n-1)\\n                {\\n                    dp[i][j] = dp[i+1][j];\\n                }\\n                else if(i != m-1 && j != n-1)\\n                {\\n                    dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n```\n```\\n        for(int i = rows - 1; i >= 0; i--)\\n        {\\n            for(int j = cols - 1; j >= 0; j--)\\n            {\\n                if(i == rows-1 && j != cols-1)\\n                {\\n                    dp[i][j] = grid[i][j] + dp[i][j+1];\\n                }\\n                \\n                else if(i != rows-1 && j == cols-1)\\n                {\\n                    dp[i][j] = grid[i][j] + dp[i+1][j];\\n                }\\n                \\n                else if(i != rows-1 && j != cols-1)\\n                {\\n                    dp[i][j] = grid[i][j] + Math.min(dp[i][j+1], dp[i+1][j]);\\n                }\\n                \\n                else\\n                {\\n                    dp[i][j] = grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n```\n```\\npublic class Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        \\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        \\n        int[][] dp = new int[m][n];\\n        \\n        for(int i = m - 1; i >= 0; i--)\\n        {\\n            for(int j = n - 1; j >= 0; j--)\\n            {\\n                if(i == m-1 && j != n-1)\\n                {\\n                    dp[i][j] = Math.max(1, dp[i][j+1] - dungeon[i][j]);\\n                }\\n                else if(i != m-1 && j == n-1)\\n                {\\n                    dp[i][j] = Math.max(1, dp[i+1][j] - dungeon[i][j]);\\n                }\\n                else if(i != m-1 && j != n-1)\\n                {\\n                    dp[i][j] = Math.max(1, Math.min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);\\n                }\\n                else\\n                {\\n                    dp[i][j] = Math.max(1, 1 - dungeon[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52848,
                "title": "accepted-python-dp-solution",
                "content": "    class Solution:\\n        # @param dungeon, a list of lists of integers\\n        # @return a integer\\n        def calculateMinimumHP(self, dungeon):\\n        #If at any point his health point drops to 0 or below, he dies immediately.\\n        #have to make sure at any point health is > 0\\n        #dp[i][j] is minimum health needed when arriving at this grid\\n        #dp[i][j] = min(max(1, dp[right]-right_grid_value), max(1, dp[down]-down_grid_value))\\n            row, col = len(dungeon), len(dungeon[0])\\n            dp = [[0 for x in range(col)] for x in range(row)]\\n            dp[row-1][col-1] = 1\\n            for i in range(row-2, -1, -1):\\n                dp[i][col-1] = max(1, dp[i+1][col-1]-dungeon[i+1][col-1])\\n            for i in range(col-2, -1, -1):\\n                dp[row-1][i] = max(1, dp[row-1][i+1]-dungeon[row-1][i+1])\\n            for i in range(row-2, -1, -1):\\n                for j in range(col-2, -1, -1):\\n                    right = max(1, dp[i][j+1]-dungeon[i][j+1])\\n                    down = max(1, dp[i+1][j]-dungeon[i+1][j])\\n                    dp[i][j] = min(right, down)\\n            return max(1, dp[0][0]-dungeon[0][0])",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @param dungeon, a list of lists of integers\\n        # @return a integer\\n        def calculateMinimumHP(self, dungeon):\\n        #If at any point his health point drops to 0 or below, he dies immediately.\\n        #have to make sure at any point health is > 0\\n        #dp[i][j] is minimum health needed when arriving at this grid\\n        #dp[i][j] = min(max(1, dp[right]-right_grid_value), max(1, dp[down]-down_grid_value))\\n            row, col = len(dungeon), len(dungeon[0])\\n            dp = [[0 for x in range(col)] for x in range(row)]\\n            dp[row-1][col-1] = 1\\n            for i in range(row-2, -1, -1):\\n                dp[i][col-1] = max(1, dp[i+1][col-1]-dungeon[i+1][col-1])\\n            for i in range(col-2, -1, -1):\\n                dp[row-1][i] = max(1, dp[row-1][i+1]-dungeon[row-1][i+1])\\n            for i in range(row-2, -1, -1):\\n                for j in range(col-2, -1, -1):\\n                    right = max(1, dp[i][j+1]-dungeon[i][j+1])\\n                    down = max(1, dp[i+1][j]-dungeon[i+1][j])\\n                    dp[i][j] = min(right, down)\\n            return max(1, dp[0][0]-dungeon[0][0])",
                "codeTag": "Java"
            },
            {
                "id": 3850671,
                "title": "c-2d-1d-dynamic-programming-beats-100",
                "content": "We can only go down or to the right, thus we know that we can construct an optimal solution beginning `dungeon[i][j]` by using the optimal solution for starting from `dungeon[i + 1][j]` and `dungeon[i][j + 1]`. If `dp[i][j]` denotes the minimum initial health needed to travel from `dungeon[i][j]` to `dungeon[m - 1][n - 1]`, `dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])`. If we travel through `dungeon[i][j]`, we lose `-dungeon[i][j]` health points, which is why we have `- dungeon[i][j]`. Additionally, we want to minimize the starting health for the path beginning at  `dungeon[i][j]`, which is why we have `min(dp[i + 1][j], dp[i][j + 1])`. It is possible, however, that `min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j] < 1` because we don\\'t necessarily lose health points at each `dungeon[i][j]`, however, to begin traveling from any `dungeon[i][j]`, we need at least `1` health point, which is why we have `max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])`.\\n\\n# 2D Dynamic Programming\\n\\n## Time Complexity\\n- Time complexity: $$O(m \\\\cdot n)$$\\n\\n- Space complexity: $$O(m \\\\cdot n)$$\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n\\n        int m = dungeon.size(), n = dungeon[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n));\\n\\n        // dp[i][j] denotes the minimum initial health needed to travel from dungeon[i][j] to\\n        // the dungeon dungeon[m - 1][n - 1] \\n\\n        dp[m - 1][n - 1] = max(1, 1 - dungeon[m - 1][n - 1]);\\n        \\n        for (int i = n - 2; i > -1; --i)\\n            dp[m - 1][i] = max(1, dp[m - 1][i + 1] - dungeon[m - 1][i]);\\n\\n        for (int i = m - 2; i > -1; --i)\\n        {\\n            dp[i][n - 1] = max(1, dp[i + 1][n - 1] - dungeon[i][n - 1]);\\n            for (int j = n - 2; j > -1; --j)\\n                dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);\\n        }\\n\\n        return dp[0][0];\\n    }\\n};\\n```\\n\\n# 1D Dynamic Programming \\n\\n## Time Complexity\\n- Time complexity: $$O(m \\\\cdot n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n## Code \\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n\\n        int m = dungeon.size(), n = dungeon[0].size();\\n        vector<int> dp(n);\\n        \\n        dp[n - 1] = max(1, 1 - dungeon[m - 1][n - 1]);\\n        \\n        for (int i = n - 2; i > -1; --i)\\n            dp[i] = max(1, dp[i + 1] - dungeon[m - 1][i]);\\n\\n        for (int i = m - 2; i > -1; --i)\\n        {\\n            dp[n - 1] = max(1, dp[n - 1] - dungeon[i][n - 1]);\\n            for (int j = n - 2; j > -1; --j)\\n                dp[j] = max(1, min(dp[j], dp[j + 1]) - dungeon[i][j]);\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n\\n        int m = dungeon.size(), n = dungeon[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n));\\n\\n        // dp[i][j] denotes the minimum initial health needed to travel from dungeon[i][j] to\\n        // the dungeon dungeon[m - 1][n - 1] \\n\\n        dp[m - 1][n - 1] = max(1, 1 - dungeon[m - 1][n - 1]);\\n        \\n        for (int i = n - 2; i > -1; --i)\\n            dp[m - 1][i] = max(1, dp[m - 1][i + 1] - dungeon[m - 1][i]);\\n\\n        for (int i = m - 2; i > -1; --i)\\n        {\\n            dp[i][n - 1] = max(1, dp[i + 1][n - 1] - dungeon[i][n - 1]);\\n            for (int j = n - 2; j > -1; --j)\\n                dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);\\n        }\\n\\n        return dp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n\\n        int m = dungeon.size(), n = dungeon[0].size();\\n        vector<int> dp(n);\\n        \\n        dp[n - 1] = max(1, 1 - dungeon[m - 1][n - 1]);\\n        \\n        for (int i = n - 2; i > -1; --i)\\n            dp[i] = max(1, dp[i + 1] - dungeon[m - 1][i]);\\n\\n        for (int i = m - 2; i > -1; --i)\\n        {\\n            dp[n - 1] = max(1, dp[n - 1] - dungeon[i][n - 1]);\\n            for (int j = n - 2; j > -1; --j)\\n                dp[j] = max(1, min(dp[j], dp[j + 1]) - dungeon[i][j]);\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101565,
                "title": "intutive-recursive-approach",
                "content": "# Intuition\\nthe approach is dp as we have to see all the possible ways we can go down because greedy approach is not valid due to lack of uniformity \\n\\n# Approach\\ndynamic programming (recursive approach)\\n\\n# Complexity\\n- Time complexity:\\no(mn)\\n\\n- Space complexity:\\no(mn)+stack space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n \\nint f(int i ,int j,vector<vector<int>>&d,vector<vector<int>>&dp){\\n    if(i==d.size()||j==d[0].size()){\\n        return 1e9;\\n    }\\n    if(i==d.size()-1&&j==d[0].size()-1){\\n        if(d[i][j]<0){\\n            return abs(d[i][j])+1;\\n        }\\n        else{\\n            return 1;\\n        }\\n    }\\n    if(dp[i][j]!=-1)return dp[i][j];\\n    if(d[i][j]<0){\\n        int r=abs(d[i][j])+f(i,j+1,d,dp);\\n        int l=abs(d[i][j])+f(i+1,j,d,dp);\\n        return dp[i][j]= min(l,r);\\n    }\\n    else{\\n        int r=d[i][j]-f(i,j+1,d,dp);\\n        int l=d[i][j]-f(i+1,j,d,dp);\\n        if(r>=0||l>=0) return dp[i][j]=1;\\n        else{\\n            return dp[i][j]=min(abs(l),abs(r));\\n        }\\n    }\\n}\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n     vector<vector<int>>dp(dungeon.size(),vector<int>(dungeon[0].size(),-1));\\n       return f(0,0,dungeon,dp); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\nint f(int i ,int j,vector<vector<int>>&d,vector<vector<int>>&dp){\\n    if(i==d.size()||j==d[0].size()){\\n        return 1e9;\\n    }\\n    if(i==d.size()-1&&j==d[0].size()-1){\\n        if(d[i][j]<0){\\n            return abs(d[i][j])+1;\\n        }\\n        else{\\n            return 1;\\n        }\\n    }\\n    if(dp[i][j]!=-1)return dp[i][j];\\n    if(d[i][j]<0){\\n        int r=abs(d[i][j])+f(i,j+1,d,dp);\\n        int l=abs(d[i][j])+f(i+1,j,d,dp);\\n        return dp[i][j]= min(l,r);\\n    }\\n    else{\\n        int r=d[i][j]-f(i,j+1,d,dp);\\n        int l=d[i][j]-f(i+1,j,d,dp);\\n        if(r>=0||l>=0) return dp[i][j]=1;\\n        else{\\n            return dp[i][j]=min(abs(l),abs(r));\\n        }\\n    }\\n}\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n     vector<vector<int>>dp(dungeon.size(),vector<int>(dungeon[0].size(),-1));\\n       return f(0,0,dungeon,dp); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644408,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Bottom Up Dp***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        // declare a dp\\n        \\n        vector<vector<int>> dp(n, vector<int> (m, 0));\\n        \\n        // fill the dp table\\n        \\n        // dp[i][j] will store the minimum initial energy required from (i, j) to (n - 1, m - 1)\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            for(int j = m - 1; j >= 0; j--)\\n            {\\n                if(i == n - 1 && j == m - 1)\\n                {\\n                    dp[i][j] = grid[i][j] >= 0 ? 0 : grid[i][j];\\n                }\\n                else if(j == m - 1)\\n                {\\n                    dp[i][j] = grid[i][j] + dp[i + 1][j] >= 0 ? 0 : (grid[i][j] + dp[i + 1][j]);\\n                }\\n                else if(i == n - 1)\\n                {\\n                    dp[i][j] = grid[i][j] + dp[i][j + 1] >= 0 ? 0 : (grid[i][j] + dp[i][j + 1]);\\n                }\\n                else\\n                {\\n                    int right = grid[i][j] + dp[i][j + 1] >= 0 ? 0 : (grid[i][j] + dp[i][j + 1]);\\n                    \\n                    int down = grid[i][j] + dp[i + 1][j] >= 0 ? 0 : (grid[i][j] + dp[i + 1][j]);\\n                    \\n                    dp[i][j] = max(right, down);\\n                }\\n            }\\n        }\\n        \\n        return -dp[0][0] + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        // declare a dp\\n        \\n        vector<vector<int>> dp(n, vector<int> (m, 0));\\n        \\n        // fill the dp table\\n        \\n        // dp[i][j] will store the minimum initial energy required from (i, j) to (n - 1, m - 1)\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            for(int j = m - 1; j >= 0; j--)\\n            {\\n                if(i == n - 1 && j == m - 1)\\n                {\\n                    dp[i][j] = grid[i][j] >= 0 ? 0 : grid[i][j];\\n                }\\n                else if(j == m - 1)\\n                {\\n                    dp[i][j] = grid[i][j] + dp[i + 1][j] >= 0 ? 0 : (grid[i][j] + dp[i + 1][j]);\\n                }\\n                else if(i == n - 1)\\n                {\\n                    dp[i][j] = grid[i][j] + dp[i][j + 1] >= 0 ? 0 : (grid[i][j] + dp[i][j + 1]);\\n                }\\n                else\\n                {\\n                    int right = grid[i][j] + dp[i][j + 1] >= 0 ? 0 : (grid[i][j] + dp[i][j + 1]);\\n                    \\n                    int down = grid[i][j] + dp[i + 1][j] >= 0 ? 0 : (grid[i][j] + dp[i + 1][j]);\\n                    \\n                    dp[i][j] = max(right, down);\\n                }\\n            }\\n        }\\n        \\n        return -dp[0][0] + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562360,
                "title": "cpp-dp-memoization-tabulation-space-optimization-easy-explanation",
                "content": "/*\\n    Here, we have 3 Solutions:\\n    \\n    1. Top down DP (Memoization)\\n    2. Bottom Up DP (Tabulation)\\n    3. Tabulation with Space optimisation (Space optimised)\\n    \\n    Intuition:\\n    \\n    ** The idea is to find out minimum strength needed at any node to reach the bottom right corner\\n    ** Strength needed to reach bottom right corner if we are at bottom right corner \\n        -> Will be = 1 if it has an energy booster ( +ve value )\\n        -> Will be 1 - value if it is astrength\\n    ** We can either move right or down\\n    ** Now here we need to understand one important thing, i.e.\\n        -> The value we get as return from right or down is the amount of energy needed if we move in either direction\\n        -> Now, once we get that value, we need to find out the minimum amount of energy needed from current node to bottom\\n            right\\n        -> To do that, we consider the direction through which minimum energy is needed\\n        -> Now, there are two scenarios \\n            1. Current cell contains a booster\\n            2. Energy decrementer\\n        -> Here, we simply subtract the current value from minimum of moving in both the directions\\n            because this will give us the amount of energy needed from current node to reach bottom right node\\n        -> If this value is positive, we simply return that\\n        -> Otherwise we return 1 if the result is negative as that means we need only 1 if we start from this point\\n            -> This is the case when energy booster at this node is greater than the energy needed from it\\'s predecessors to                reach bottom right node\\n            \\n    \\n    Step 1: Express everything in terms of indexes\\n    Dungeon is a matrix so we express things in terms of rows and columns and traverse through the matrix \\n    row -> rInd,\\n    col -> cInd\\n    \\n    Step 2: Find boundary conditions\\n    Edge cases will be \\n    1. We go out of matrix\\n    2. We reach the end\\n    3. It\\'s an overlapping subproblem which we already solved (We have the solution in our DP array)\\n    \\n    Step 3: Explore all posibilities\\n    1. Explore right index from current \\n    2. Explore down index from current\\n    \\n    Step 4: Find minimum of both and subtract current from that and return value if it is positive else return 1 if value is        negative\\n    \\n    \\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    int pathVal(int rInd, int cInd, int m, int n, vector<vector<int>> &dungeon, vector<vector<int>> &dp)\\n    {\\n        if(rInd >= m || cInd >= n)\\n            return 1e9;\\n        \\n        if(rInd == m - 1 && cInd == n - 1)\\n            return dungeon[rInd][cInd] > 0 ? 1 : 1 - dungeon[rInd][cInd];\\n        \\n        if(dp[rInd][cInd] != -1)\\n            return dp[rInd][cInd];\\n        \\n        int right = pathVal(rInd, cInd + 1, m, n, dungeon, dp);\\n        int down = pathVal(rInd + 1, cInd, m, n, dungeon, dp);\\n        \\n        int res = min(right, down) - dungeon[rInd][cInd];\\n        return dp[rInd][cInd] = res > 0 ? res : 1;\\n    }\\n    \\n    int tabulation(int m, int n, vector<vector<int>> &dungeon)\\n    {\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));  \\n        \\n        for(int cInd = 0; cInd < n + 1; cInd++)\\n            dp[m][cInd] = 1e9;\\n\\n        for(int rInd = 0; rInd < m + 1; rInd++)\\n            dp[rInd][n] = 1e9;\\n\\n        dp[m - 1][n - 1] = dungeon[m - 1][n - 1] > 0 ? 1 : 1 - dungeon[m - 1][n - 1];\\n        \\n        for(int rInd = m - 1; rInd >= 0; rInd--)\\n        {\\n            for(int cInd = n - 1; cInd >= 0; cInd--)\\n            {\\n                int right = dp[rInd][cInd + 1];\\n                int down = dp[rInd + 1][cInd];\\n\\n                int res = min(right, down) - dungeon[rInd][cInd];\\n\\n                if(rInd == m - 1 && cInd == n -1)\\n                    dp[m - 1][n - 1] = dungeon[m - 1][n - 1] > 0 ? 1 : 1 - dungeon[m - 1][n - 1];\\n                else\\n                    dp[rInd][cInd] = res > 0 ? res : 1;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n    \\n    int tabulationSpaceOptimised(int m, int n, vector<vector<int>> &dungeon)\\n    {\\n        vector<int> dp(n + 1, 0);  \\n        \\n        for(int cInd = 0; cInd < n + 1; cInd++)\\n            dp[cInd] = 1e9;\\n                \\n        for(int rInd = m - 1; rInd >= 0; rInd--)\\n        {        \\n            vector<int> temp(n + 1, 0);  \\n            temp[n] = 1e9; \\n            for(int cInd = n - 1; cInd >= 0; cInd--)\\n            {\\n                int right = temp[cInd + 1];\\n                int down = dp[cInd];\\n\\n                int res = min(right, down) - dungeon[rInd][cInd];\\n\\n                if(rInd == m - 1 && cInd == n - 1)\\n                    temp[n - 1] = dungeon[m - 1][n - 1] > 0 ? 1 : 1 - dungeon[m - 1][n - 1];\\n                else\\n                    temp[cInd] = res > 0 ? res : 1;\\n            }\\n            dp = temp;\\n        }\\n        return dp[0];\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) \\n    {\\n        int m = dungeon.size(), n = dungeon[0].size();\\n\\n        // vector<vector<int>> dp(m + 1, vector<int>(n + 1, -1));\\n        // return pathVal(0, 0, m, n, dungeon, dp);\\n        \\n        // return tabulation(m, n, dungeon);\\n        \\n        return tabulationSpaceOptimised(m, n, dungeon);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int pathVal(int rInd, int cInd, int m, int n, vector<vector<int>> &dungeon, vector<vector<int>> &dp)\\n    {\\n        if(rInd >= m || cInd >= n)\\n            return 1e9;\\n        \\n        if(rInd == m - 1 && cInd == n - 1)\\n            return dungeon[rInd][cInd] > 0 ? 1 : 1 - dungeon[rInd][cInd];\\n        \\n        if(dp[rInd][cInd] != -1)\\n            return dp[rInd][cInd];\\n        \\n        int right = pathVal(rInd, cInd + 1, m, n, dungeon, dp);\\n        int down = pathVal(rInd + 1, cInd, m, n, dungeon, dp);\\n        \\n        int res = min(right, down) - dungeon[rInd][cInd];\\n        return dp[rInd][cInd] = res > 0 ? res : 1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2186275,
                "title": "c-simplest-dp-solution-w-easiest-explanation",
                "content": "We need to return the **minimum** initail health that the knight needs to save the princess.\\n\\n* Before getting into the algorithm, we need to understand:\\n\\t* To stay alive in any cell / move to the next right/down cell, the minimum health needed is ```1``` (Becuase the knight would die if it drops to ```0``` or low).\\n\\n\\t * So, if a cell is guarded by demons and the knight would lose  (*say*) ```5```health points to them, the minimum health for him to stay alive in that cell is ```6```.\\n\\n\\t* After understanding this, there\\'s one more thing to notice: This question has  start and end locations, and you have to find some ```start``` property to meet an end criterion. So we\\'ll start from the ```end``` location because we know the end criterion (Min ```1``` health point is needed tp leave from the last cell) and work our way up to the start cell.\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& d) {\\n        int m = d.size(), n = d[0].size();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(n+1, INT_MAX));\\n        dp[m][n-1] = dp[m-1][n] = 1;    //the DOWN and RIGHT cells from the end cell (As explained above, the minimum cost needed to move to the next cells)\\n        \\n        for(int i=m-1; i>=0; i--) {\\n            for(int j=n-1; j>=0; j--) {    //start filling from the bottom-right corner \\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - d[i][j]);     //We need to see that the health point doesn\\'t drop to 0 or low. Hence --> max(1, ...). Now this \"...\" is the strength that\\'s needed for this cell + that needed to travel to the next cell.  //d[i][j] is the strength provided by this cell and the strength needed to travel to the next cell is min(dp[i+1][j], dp[i][j+1])\\n            }\\n        }\\n        return dp[0][0];    //return the health needed in the first cell\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```1```\n```0```\n```5```\n```6```\n```start```\n```end```\n```1```\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& d) {\\n        int m = d.size(), n = d[0].size();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(n+1, INT_MAX));\\n        dp[m][n-1] = dp[m-1][n] = 1;    //the DOWN and RIGHT cells from the end cell (As explained above, the minimum cost needed to move to the next cells)\\n        \\n        for(int i=m-1; i>=0; i--) {\\n            for(int j=n-1; j>=0; j--) {    //start filling from the bottom-right corner \\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - d[i][j]);     //We need to see that the health point doesn\\'t drop to 0 or low. Hence --> max(1, ...). Now this \"...\" is the strength that\\'s needed for this cell + that needed to travel to the next cell.  //d[i][j] is the strength provided by this cell and the strength needed to travel to the next cell is min(dp[i+1][j], dp[i][j+1])\\n            }\\n        }\\n        return dp[0][0];    //return the health needed in the first cell\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108535,
                "title": "explained-solution-comprehensible-for-begineer-of-dp-also",
                "content": "```\\n//dp[i][j] means that how much minimum life needed so that from this cell,we can reach destination and remain alive\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>> &dungeon,vector<vector<int>> &dp,int &row,int &cols)\\n    {\\n        if(i<0 || i>=row || j<0 || j>=cols) return INT_MAX;//infinite life needed to reach to destination from outside dungeon\\n        if(i==row-1 && j==cols-1) return dungeon[i][j]<0?(-dungeon[i][j]+1):1;\\n        \\t\\t\\t\\t\\t\\t\\t//if reached dungeon then it should be alive. So if final cell has negative point then one more point\\n        \\t\\t\\t\\t\\t\\t\\t//than absoulute value of it will be needed so that it remains alive. Otherwise it should just come alive\\n        \\t\\t\\t\\t\\t\\t\\t//with life = 1 and it will remain alive in the destination cell\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int right = solve(i,j+1,dungeon,dp,row,cols);//minimum life required when going on right path\\n        int down = solve(i+1,j,dungeon,dp,row,cols);//minimum life required when going on down path\\n        \\n        //No DFS call will fall in infinite loop as movement is restricted to right and down direction only\\n        \\n        int lifeReqFromThisCell = min(right,down) - dungeon[i][j];//after getting answers from right and left path, we have to subtract value\\n        \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//at this cell because for e.g., suppose this cell has value 4 so it will boost\\n        \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//life by 4 hence in order to get minimum life required, we have to subtract 4\\n        \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//similarily if this cell is -4 hence it will add (-(-4)) as this cell itself \\n        \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//will consume life of 4 points\\n        return dp[i][j] = lifeReqFromThisCell<=0 ? 1 : lifeReqFromThisCell;\\n        \\t\\t\\t\\t//if lifeReqFromThisCell is somehow coming to be -ve or 0 it means there is no additional life required to boost \\n        \\t\\t\\t\\t//from this cell because all the cells in the path are positive hence in such case it is just required that we\\n        \\t\\t\\t\\t//land up at this cell with minimum life of 1 point\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int row = dungeon.size(), cols = dungeon[0].size();\\n        vector<vector<int>> dp(row,vector<int>(cols,-1));\\n        return solve(0,0,dungeon,dp,row,cols);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//dp[i][j] means that how much minimum life needed so that from this cell,we can reach destination and remain alive\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>> &dungeon,vector<vector<int>> &dp,int &row,int &cols)\\n    {\\n        if(i<0 || i>=row || j<0 || j>=cols) return INT_MAX;//infinite life needed to reach to destination from outside dungeon\\n        if(i==row-1 && j==cols-1) return dungeon[i][j]<0?(-dungeon[i][j]+1):1;\\n        \\t\\t\\t\\t\\t\\t\\t//if reached dungeon then it should be alive. So if final cell has negative point then one more point\\n        \\t\\t\\t\\t\\t\\t\\t//than absoulute value of it will be needed so that it remains alive. Otherwise it should just come alive\\n        \\t\\t\\t\\t\\t\\t\\t//with life = 1 and it will remain alive in the destination cell\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int right = solve(i,j+1,dungeon,dp,row,cols);//minimum life required when going on right path\\n        int down = solve(i+1,j,dungeon,dp,row,cols);//minimum life required when going on down path\\n        \\n        //No DFS call will fall in infinite loop as movement is restricted to right and down direction only\\n        \\n        int lifeReqFromThisCell = min(right,down) - dungeon[i][j];//after getting answers from right and left path, we have to subtract value\\n        \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//at this cell because for e.g., suppose this cell has value 4 so it will boost\\n        \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//life by 4 hence in order to get minimum life required, we have to subtract 4\\n        \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//similarily if this cell is -4 hence it will add (-(-4)) as this cell itself \\n        \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//will consume life of 4 points\\n        return dp[i][j] = lifeReqFromThisCell<=0 ? 1 : lifeReqFromThisCell;\\n        \\t\\t\\t\\t//if lifeReqFromThisCell is somehow coming to be -ve or 0 it means there is no additional life required to boost \\n        \\t\\t\\t\\t//from this cell because all the cells in the path are positive hence in such case it is just required that we\\n        \\t\\t\\t\\t//land up at this cell with minimum life of 1 point\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int row = dungeon.size(), cols = dungeon[0].size();\\n        vector<vector<int>> dp(row,vector<int>(cols,-1));\\n        return solve(0,0,dungeon,dp,row,cols);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052055,
                "title": "clean-and-clear-dp-solution-in-python-easy-to-understand",
                "content": "A great **DP** question that requires some time to understand!\\n\\n**Initiate** a DP matrix.\\nUse dp to keep the **minimum health point** that the knight needs **when arriving** at each cell!\\n**At each cell**, we should **compute the health point we need** to be able to reach its right connecting cell and down connecting cell (using helper function getHealth()). Then take the minimum of the right one and down one, insert into the dp matrix.\\n**Order to fill:**\\nUpwards and leftwards.\\n\\n**Time:** O(mn)\\n**Space:** O(mn)\\n\\n```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        \\n        rows, cols = len(dungeon), len(dungeon[0])\\n        dp = [[float(\\'inf\\')] * cols for _ in range(rows)]\\n        \\n        dp[rows - 1][cols - 1] = 1 if dungeon[rows - 1][cols - 1] >= 0 else (1 - dungeon[rows - 1][cols - 1])\\n        \\n        for row in reversed(range(rows)):\\n            for col in reversed(range(cols)):\\n                if row == rows - 1 and col == cols - 1:\\n                    continue\\n                \\n                curr_cell = dungeon[row][col]\\n\\n                right_health = self.getHealth(curr_cell, row, col + 1, rows, cols, dp)\\n                down_health = self.getHealth(curr_cell, row + 1, col, rows, cols, dp)\\n                next_health = min(right_health, down_health)\\n\\n                dp[row][col] = next_health\\n\\n        return dp[0][0]\\n    \\n    def getHealth(self, curr_cell, next_row, next_col, rows, cols, dp):\\n        \\n        if next_row >= rows or next_col >= cols:\\n            return float(\\'inf\\')\\n        next_cell = dp[next_row][next_col]\\n        # note that the knight needs at least 1 point at any cell\\n        return max(1, next_cell - curr_cell)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        \\n        rows, cols = len(dungeon), len(dungeon[0])\\n        dp = [[float(\\'inf\\')] * cols for _ in range(rows)]\\n        \\n        dp[rows - 1][cols - 1] = 1 if dungeon[rows - 1][cols - 1] >= 0 else (1 - dungeon[rows - 1][cols - 1])\\n        \\n        for row in reversed(range(rows)):\\n            for col in reversed(range(cols)):\\n                if row == rows - 1 and col == cols - 1:\\n                    continue\\n                \\n                curr_cell = dungeon[row][col]\\n\\n                right_health = self.getHealth(curr_cell, row, col + 1, rows, cols, dp)\\n                down_health = self.getHealth(curr_cell, row + 1, col, rows, cols, dp)\\n                next_health = min(right_health, down_health)\\n\\n                dp[row][col] = next_health\\n\\n        return dp[0][0]\\n    \\n    def getHealth(self, curr_cell, next_row, next_col, rows, cols, dp):\\n        \\n        if next_row >= rows or next_col >= cols:\\n            return float(\\'inf\\')\\n        next_cell = dp[next_row][next_col]\\n        # note that the knight needs at least 1 point at any cell\\n        return max(1, next_cell - curr_cell)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582288,
                "title": "easy-to-understand-in-c-amazing-approach",
                "content": "class Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>& dungeon,int n,int m){\\n        vector<vector<int>> hp(n+1,vector<int>(m+1,INT_MAX));\\n        hp[n][m-1]=1;\\n        hp[n-1][m]=1;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                int need=min(hp[i+1][j],hp[i][j+1])-dungeon[i][j];\\n                hp[i][j]=need<=0?1:need;\\n            }\\n        }\\n        return hp[0][0];\\n    }\\n        \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int n=dungeon.size();\\n        int m=dungeon[0].size();\\n        return solve(dungeon,n,m);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>& dungeon,int n,int m){\\n        vector<vector<int>> hp(n+1,vector<int>(m+1,INT_MAX));\\n        hp[n][m-1]=1;\\n        hp[n-1][m]=1;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                int need=min(hp[i+1][j],hp[i][j+1])-dungeon[i][j];\\n                hp[i][j]=need<=0?1:need;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1528466,
                "title": "c-using-dynamic-programming",
                "content": "**Please Upvote if you like the Solution!**\\n\\n    class Solution {\\n    public:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon)\\n    {\\n        int rows=dungeon.size();//row size\\n        int cols=dungeon[0].size();//column size\\n        \\n        vector<vector<int>> dp(rows,vector<int> (cols,0));//creating dp table same as size of dungeon\\n        \\n        //Using Bottom-Up Approach\\n        \\n        for(int i=rows-1;i>=0;i--)\\n        {\\n            for(int j=cols-1;j>=0;j--)\\n            {\\n                if(i==rows-1 && j==cols-1)\\n                {\\n                    dp[i][j]=min(0,dungeon[i][j]);//we don\\'t take positive values\\n                }\\n                else if(i==rows-1)//whenever we are in last row\\n                {\\n                    dp[i][j]=min(0,dungeon[i][j]+dp[i][j+1]);//adding current dungeon value and adjacent right value\\n                }\\n                else if(j==cols-1)//whenever we are in last column\\n                {\\n                    dp[i][j]=min(0,dungeon[i][j]+dp[i+1][j]);//add current dungeon value and adjacent down value\\n                }\\n                else\\n                {\\n                    dp[i][j]=min(0,dungeon[i][j]+max(dp[i+1][j],dp[i][j+1]));//taking current dungeon value and maximum of adjacent down and adjacent right\\n                }\\n                \\n            }\\n        }\\n        return abs(dp[0][0])+1;//taking absolute of dp[0][0] and adding 1 to it as minimum 1 positive energy is required to alive for a knight\\n    }\\n    };\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon)\\n    {\\n        int rows=dungeon.size();//row size\\n        int cols=dungeon[0].size();//column size\\n        \\n        vector<vector<int>> dp(rows,vector<int> (cols,0));//creating dp table same as size of dungeon\\n        \\n        //Using Bottom-Up Approach\\n        \\n        for(int i=rows-1;i>=0;i--)\\n        {\\n            for(int j=cols-1;j>=0;j--)\\n            {\\n                if(i==rows-1 && j==cols-1)\\n                {\\n                    dp[i][j]=min(0,dungeon[i][j]);//we don\\'t take positive values\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1498650,
                "title": "c-binary-search-and-dp",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:** Since knight will hold some initial energy, so we can add some enrgy to it from ( 1 --> 1e6 ) and check for minimum possible energy to given such that there exisits at least 1 path from (0,0) --> (n-1,m-1) with values of each cell > 0\\n\\n**Binary Search Sollution**\\n```\\nclass Solution {\\npublic:\\n    \\n    bool possible(vector<vector<int>>& grid, int val) {\\n        int n=grid.size(), m=grid[0].size();\\n        \\n        int dp[n][m];\\n        memset(dp,INT_MIN,sizeof(dp));\\n        dp[0][0]=grid[0][0]+val;\\n\\t\\t\\n\\t\\t// we can move to next cell only if previous cell value > 0\\n        for(int i=0,j=1;j<m;j++) if(dp[i][j-1]>0) dp[i][j]=dp[i][j-1]+grid[i][j];\\n        for(int i=1,j=0;i<n;i++) if(dp[i-1][j]>0) dp[i][j]=dp[i-1][j]+grid[i][j];\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(dp[i-1][j]>0) dp[i][j]=dp[i-1][j]+grid[i][j];\\n                if(dp[i][j-1]>0) dp[i][j]=max(dp[i][j],dp[i][j-1]+grid[i][j]);\\n            }\\n        }\\n        return (dp[n-1][m-1]>0);\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        \\n        int l=1, r=1e6;\\n        while(l<r){\\n            int m=l+(r-l)/2;\\n            if(possible(grid,m)){\\n                r=m;\\n            }else{\\n                l=m+1;\\n            }\\n        } \\n        return l;\\n    }\\n};\\n```\\n\\n**DP Sollution**\\n```\\nclass Solution {\\npublic:\\n    \\n    int calculateMinimumHP(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        \\n        int dp[n][m];\\n        dp[n-1][m-1]=min(0,grid[n-1][m-1]);\\n        for(int i=n-1,j=m-2;j>=0;j--) dp[i][j]=min(0,dp[i][j+1]+grid[i][j]);\\n        for(int i=n-2,j=m-1;i>=0;i--) dp[i][j]=min(0,dp[i+1][j]+grid[i][j]);\\n        \\n        for(int i=n-2;i>=0;i--){\\n            for(int j=m-2;j>=0;j--){\\n                dp[i][j]=min(0,max(dp[i+1][j],dp[i][j+1])+grid[i][j]);\\n            }\\n        }\\n        return 1-dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool possible(vector<vector<int>>& grid, int val) {\\n        int n=grid.size(), m=grid[0].size();\\n        \\n        int dp[n][m];\\n        memset(dp,INT_MIN,sizeof(dp));\\n        dp[0][0]=grid[0][0]+val;\\n\\t\\t\\n\\t\\t// we can move to next cell only if previous cell value > 0\\n        for(int i=0,j=1;j<m;j++) if(dp[i][j-1]>0) dp[i][j]=dp[i][j-1]+grid[i][j];\\n        for(int i=1,j=0;i<n;i++) if(dp[i-1][j]>0) dp[i][j]=dp[i-1][j]+grid[i][j];\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(dp[i-1][j]>0) dp[i][j]=dp[i-1][j]+grid[i][j];\\n                if(dp[i][j-1]>0) dp[i][j]=max(dp[i][j],dp[i][j-1]+grid[i][j]);\\n            }\\n        }\\n        return (dp[n-1][m-1]>0);\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        \\n        int l=1, r=1e6;\\n        while(l<r){\\n            int m=l+(r-l)/2;\\n            if(possible(grid,m)){\\n                r=m;\\n            }else{\\n                l=m+1;\\n            }\\n        } \\n        return l;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int calculateMinimumHP(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        \\n        int dp[n][m];\\n        dp[n-1][m-1]=min(0,grid[n-1][m-1]);\\n        for(int i=n-1,j=m-2;j>=0;j--) dp[i][j]=min(0,dp[i][j+1]+grid[i][j]);\\n        for(int i=n-2,j=m-1;i>=0;i--) dp[i][j]=min(0,dp[i+1][j]+grid[i][j]);\\n        \\n        for(int i=n-2;i>=0;i--){\\n            for(int j=m-2;j>=0;j--){\\n                dp[i][j]=min(0,max(dp[i+1][j],dp[i][j+1])+grid[i][j]);\\n            }\\n        }\\n        return 1-dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498134,
                "title": "c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[200][200];\\n    int solve(vector<vector<int>> &grid, int n, int m, int i, int j) \\n    {\\n        if(i >= n || j >= m) \\n            return INT_MAX;\\n        if(i == n-1 && j == m-1) \\n            return grid[i][j] <= 0 ? abs(grid[i][j]) + 1 : 1;\\n        if (dp[i][j] != -1) \\n            return dp[i][j];\\n        int right = solve(grid, n, m, i, j+1);\\n        int down = solve(grid, n, m, i+1, j);\\n        int ans = min(right, down) - grid[i][j];\\n        return dp[i][j] = ans <=0 ? 1 : ans;\\n    }\\n    int calculateMinimumHP(vector<vector<int>> &dungeon) \\n    {\\n        if(dungeon.size() == 0) \\n            return 0;\\n        memset(dp, -1, sizeof(dp));\\n        return solve(dungeon, dungeon.size(), dungeon[0].size(), 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[200][200];\\n    int solve(vector<vector<int>> &grid, int n, int m, int i, int j) \\n    {\\n        if(i >= n || j >= m) \\n            return INT_MAX;\\n        if(i == n-1 && j == m-1) \\n            return grid[i][j] <= 0 ? abs(grid[i][j]) + 1 : 1;\\n        if (dp[i][j] != -1) \\n            return dp[i][j];\\n        int right = solve(grid, n, m, i, j+1);\\n        int down = solve(grid, n, m, i+1, j);\\n        int ans = min(right, down) - grid[i][j];\\n        return dp[i][j] = ans <=0 ? 1 : ans;\\n    }\\n    int calculateMinimumHP(vector<vector<int>> &dungeon) \\n    {\\n        if(dungeon.size() == 0) \\n            return 0;\\n        memset(dp, -1, sizeof(dp));\\n        return solve(dungeon, dungeon.size(), dungeon[0].size(), 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498123,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public int calculateMinimumHP(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int dp[][] = new int[n][m];\\n        for(int i=n-1; i>=0; i--){\\n            for(int j=m-1; j>=0; j--){\\n                if(i==n-1 && j==m-1){\\n                    dp[i][j] = Math.max(1, 1 - grid[i][j]);\\n                }\\n                else if(i==n-1){\\n                    dp[i][j] = Math.max(1, dp[i][j+1] - grid[i][j]);\\n                }\\n                else if(j==m-1){\\n                    dp[i][j] = Math.max(1, dp[i+1][j] - grid[i][j]);\\n                }\\n                else{\\n                    dp[i][j] = Math.max(1, Math.min(dp[i][j+1], dp[i+1][j]) - grid[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int calculateMinimumHP(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int dp[][] = new int[n][m];\\n        for(int i=n-1; i>=0; i--){\\n            for(int j=m-1; j>=0; j--){\\n                if(i==n-1 && j==m-1){\\n                    dp[i][j] = Math.max(1, 1 - grid[i][j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1401190,
                "title": "c-recursion-memoization",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>dp;\\n    \\n    \\tint recurs(vector<vector<int>>&arr, int n, int m,int i,int j)\\n\\t{\\n\\t    \\n            if(i>=n||j>=m)\\n                 return  1000000;\\n            \\n\\n                \\n            if(i==n-1&&j==m-1)\\n            {\\n                if(arr[i][j]>0)\\n                     return dp[i][j]= 1;\\n                \\n                return dp[i][j]=abs(arr[i][j])+1;\\n            }\\n            \\n            if(dp[i][j]!=-1)\\n                 return dp[i][j];\\n                \\n            \\n            \\n            int a=recurs(arr,n,m,i+1,j);\\n            int b=recurs(arr,n,m,i,j+1);\\n            \\n            if(arr[i][j]>=min(a,b))\\n                return dp[i][j]=1;\\n            \\n            return dp[i][j]=min(a,b)-arr[i][j];\\n\\t}\\n    \\n    int calculateMinimumHP(vector<vector<int>>& points) {\\n       \\n         int n=points.size(),m=points[0].size();\\n         dp.clear();\\n         dp.resize(n,vector<int>(m,-1));\\n        \\n        int k=recurs(points,n,m,0,0);\\n        \\n          if(k<=0)\\n               k=1;\\n\\t     return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>dp;\\n    \\n    \\tint recurs(vector<vector<int>>&arr, int n, int m,int i,int j)\\n\\t{\\n\\t    \\n            if(i>=n||j>=m)\\n                 return  1000000;\\n            \\n\\n                \\n            if(i==n-1&&j==m-1)\\n            {\\n                if(arr[i][j]>0)\\n                     return dp[i][j]= 1;\\n                \\n                return dp[i][j]=abs(arr[i][j])+1;\\n            }\\n            \\n            if(dp[i][j]!=-1)\\n                 return dp[i][j];\\n                \\n            \\n            \\n            int a=recurs(arr,n,m,i+1,j);\\n            int b=recurs(arr,n,m,i,j+1);\\n            \\n            if(arr[i][j]>=min(a,b))\\n                return dp[i][j]=1;\\n            \\n            return dp[i][j]=min(a,b)-arr[i][j];\\n\\t}\\n    \\n    int calculateMinimumHP(vector<vector<int>>& points) {\\n       \\n         int n=points.size(),m=points[0].size();\\n         dp.clear();\\n         dp.resize(n,vector<int>(m,-1));\\n        \\n        int k=recurs(points,n,m,0,0);\\n        \\n          if(k<=0)\\n               k=1;\\n\\t     return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114660,
                "title": "java-dp-1ms",
                "content": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] D) {\\n        int r = D.length;\\n        int c = D[0].length;\\n        \\n        // Padding on the right and the bottom of the Dungeon\\n        // dp[i][j] meas the least HP needed if knight want to reach the room(i, j)\\n        int[][] dp = new int[r + 1][c + 1];\\n        for (int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);\\n        // It means if the knight want to reach the right or the bottom room of the princess,\\n        // He needs at least 1 HP\\n        dp[r][c - 1] = dp[r - 1][c] = 1;\\n        \\n        for (int i = r - 1; i >= 0; i--) {\\n            for (int j = c - 1; j >= 0; j--) {\\n                // Now the kight is in the room(i, j), he wants to go room(i+1, j) or room(i, j+1)\\n                // Before the knight goes into room(i+1, j), he needs at least dp[i + 1][j] - D[i][j].\\n                // Same as room(i, j+1)\\n                int need = Math.min(dp[i + 1][j], dp[i][j + 1]) - D[i][j];\\n                dp[i][j] = Math.max(1, need);\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] D) {\\n        int r = D.length;\\n        int c = D[0].length;\\n        \\n        // Padding on the right and the bottom of the Dungeon\\n        // dp[i][j] meas the least HP needed if knight want to reach the room(i, j)\\n        int[][] dp = new int[r + 1][c + 1];\\n        for (int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);\\n        // It means if the knight want to reach the right or the bottom room of the princess,\\n        // He needs at least 1 HP\\n        dp[r][c - 1] = dp[r - 1][c] = 1;\\n        \\n        for (int i = r - 1; i >= 0; i--) {\\n            for (int j = c - 1; j >= 0; j--) {\\n                // Now the kight is in the room(i, j), he wants to go room(i+1, j) or room(i, j+1)\\n                // Before the knight goes into room(i+1, j), he needs at least dp[i + 1][j] - D[i][j].\\n                // Same as room(i, j+1)\\n                int need = Math.min(dp[i + 1][j], dp[i][j + 1]) - D[i][j];\\n                dp[i][j] = Math.max(1, need);\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989558,
                "title": "concise-java-solution-using-bellman-ford-bfs-priority-queue",
                "content": "```\\nclass Solution {\\n    \\n    private int[] dr = new int[]{0, 1};\\n    private int[] dc = new int[]{1, 0};\\n    \\n    public int calculateMinimumHP(int[][] dungeon) {\\n        \\n        int M = dungeon.length, N = dungeon[0].length;\\n        int[][] maxHealthSum = new int[M][N]; // maxHealthSum[i][j] means the max health sum at (i, j)\\n        \\n        for (int i = 0; i < M; i++)\\n            for (int j = 0; j < N; j++)\\n                maxHealthSum[i][j] = Integer.MIN_VALUE;\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[3] - a[3]); // [x, y, sum value on the path, min sum]\\n        \\n        pq.offer(new int[]{0, 0, dungeon[0][0], dungeon[0][0]});\\n        \\n        while (!pq.isEmpty())\\n        {\\n            int[] vals = pq.poll();\\n            int x = vals[0], y = vals[1], sum = vals[2], minSum = vals[3];\\n            \\n            if (sum < maxHealthSum[x][y])\\n                continue;\\n            else\\n                maxHealthSum[x][y] = sum;\\n            \\n            if (x == M-1 && y == N-1)\\n            {\\n                if (minSum < 0)\\n                    return 1 - minSum;\\n                else\\n                    return 1;\\n            }\\n            \\n            for (int k = 0; k < 2; k++)\\n            {\\n                int r = x + dr[k], c = y + dc[k];\\n                \\n                if (r >= 0 && r < M && c >= 0 && c < N)\\n                    pq.offer(new int[]{r, c, sum + dungeon[r][c], Math.min(minSum, sum + dungeon[r][c])});\\n            }\\n        }\\n        \\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int[] dr = new int[]{0, 1};\\n    private int[] dc = new int[]{1, 0};\\n    \\n    public int calculateMinimumHP(int[][] dungeon) {\\n        \\n        int M = dungeon.length, N = dungeon[0].length;\\n        int[][] maxHealthSum = new int[M][N]; // maxHealthSum[i][j] means the max health sum at (i, j)\\n        \\n        for (int i = 0; i < M; i++)\\n            for (int j = 0; j < N; j++)\\n                maxHealthSum[i][j] = Integer.MIN_VALUE;\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[3] - a[3]); // [x, y, sum value on the path, min sum]\\n        \\n        pq.offer(new int[]{0, 0, dungeon[0][0], dungeon[0][0]});\\n        \\n        while (!pq.isEmpty())\\n        {\\n            int[] vals = pq.poll();\\n            int x = vals[0], y = vals[1], sum = vals[2], minSum = vals[3];\\n            \\n            if (sum < maxHealthSum[x][y])\\n                continue;\\n            else\\n                maxHealthSum[x][y] = sum;\\n            \\n            if (x == M-1 && y == N-1)\\n            {\\n                if (minSum < 0)\\n                    return 1 - minSum;\\n                else\\n                    return 1;\\n            }\\n            \\n            for (int k = 0; k < 2; k++)\\n            {\\n                int r = x + dr[k], c = y + dc[k];\\n                \\n                if (r >= 0 && r < M && c >= 0 && c < N)\\n                    pq.offer(new int[]{r, c, sum + dungeon[r][c], Math.min(minSum, sum + dungeon[r][c])});\\n            }\\n        }\\n        \\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 704443,
                "title": "javascript-clean-dp-table",
                "content": "```javascript\\nvar calculateMinimumHP = function(dungeon) {\\n    const rowNum = dungeon.length, colNum = dungeon[0].length;\\n    const dp = Array.from({length: rowNum+1}, () => Array(colNum+1).fill(Infinity));\\n    dp[rowNum][colNum-1] = 1;\\n    \\n    for(let r = rowNum-1; r >= 0; r--) {\\n        for(let c = colNum-1; c >= 0; c--) {\\n            const minPath = Math.min(dp[r+1][c], dp[r][c+1]) - dungeon[r][c];\\n            dp[r][c] = Math.max(1, minPath);\\n        }\\n    }\\n    return dp[0][0];  \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```javascript\\nvar calculateMinimumHP = function(dungeon) {\\n    const rowNum = dungeon.length, colNum = dungeon[0].length;\\n    const dp = Array.from({length: rowNum+1}, () => Array(colNum+1).fill(Infinity));\\n    dp[rowNum][colNum-1] = 1;\\n    \\n    for(let r = rowNum-1; r >= 0; r--) {\\n        for(let c = colNum-1; c >= 0; c--) {\\n            const minPath = Math.min(dp[r+1][c], dp[r][c+1]) - dungeon[r][c];\\n            dp[r][c] = Math.max(1, minPath);\\n        }\\n    }\\n    return dp[0][0];  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52796,
                "title": "6-lines-python-dp-o-mn-time-o-n-space-and-my-thinking-process",
                "content": "First, the 6lines final 1-dimentsional DP version as attached. \\n```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(dungeon), len(dungeon[0]) if dungeon else 0\\n        dp = [float('inf')] * (n-1) + [1]\\n        for i in range(m)[::-1]:\\n            for j in range(n)[::-1]:\\n                dp[j] = max(1, min(dp[j:j+2]) - dungeon[i][j])\\n        return dp[0]\\n```\\nOkay, now let me share my thinking process and hope it can help someone who is still struggling with this problem. (I'm just a guy who started to learn CS myself several months ago, so any comments are welcome!)\\n\\nWhen I saw this problem, **```BFS```** came to my mind first. Since we can only move downward or rightward at each step, it's pretty clear what we have is a directional graph. But wait a second, in order to keep the efficiency, we'd better have a ```memo``` (dictionary in Python) and it needs some extra space and syntax. Do we have a better way?\\n\\nThe answer is **YES** and let's do **```DP```** instead. Build 2-dimensional DP is pretty straight forward. We build a matrix called ```dp``` whose size is exactly the same as ```dungeon```. Since what we want is the minimum hp we need at the starting point ```dp[0][0]``` and our destination is ```dp[m-1][n-1]```, let's update our ```dp[i][j]``` from bottom right. Attached is my first 2-dimensional DP version.\\n```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(dungeon), len(dungeon[0]) if dungeon else 0\\n        dp = [[0] * n for _ in range(m)]\\n        dp[-1][-1] = max(1, 1 - dungeon[-1][-1])\\n        for i in range(m)[::-1]:\\n            for j in range(n)[::-1]:\\n                dp[i][j] = max(1, min([dp[x][y] for x, y in ((i+1, j), (i, j+1)) \\\\\\n                               if x < m and y < n] or [1]) - dungeon[i][j])\\n        return dp[0][0]\\n```\\nSince I'm only using ```dp[i+1][j]``` and ```dp[i][j+1]``` to calculate ```dp[i][j]```, I realized we can transform the 2-dimensional DP to 1-dimensional version and the corresponding space complexity drops from O(mn) to O(n). Attached is the 1-d O(n) DP. Instead of storing O(mn) ```dp```, we only need ```dp``` for current row and the previous result ```pre``` we just got. Thus, O(n) space achieved.\\n```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(dungeon), len(dungeon[0]) if dungeon else 0\\n        dp, pre = [1] * n, [0] * n\\n        neigh = []\\n        for i in range(m)[::-1]:\\n            for j in range(n)[::-1]:\\n                neigh = dp[j+1:j+2] if i == m-1 else pre[j:j+1] + dp[j+1:j+2]\\n                dp[j] = max(1, min(neigh or [1]) - dungeon[i][j])\\n            pre[:] = dp[:]\\n        return dp[0]\\n```\\nCan we do better? Yes we can. After a little observation, I realized that we don't even need ```pre```. Because ```dp[i]``` == ```pre[i]``` indeed! Finally I got the final 1-dimensional DP version on the top of this post. (Of course I made some adjustment to the initial condition for ```dp``` to make the code more concise.) And that's all my thinking process for this problem, hope it can help and any comments are welcome!\\n\\n**EDIT**: I just found my idol @StefanPochmann has a post [here](https://discuss.leetcode.com/topic/19179/6-lines-python-8-lines-ruby) and my final version DP is almost the same as his. Haha, I'm so excited!",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(dungeon), len(dungeon[0]) if dungeon else 0\\n        dp = [float('inf')] * (n-1) + [1]\\n        for i in range(m)[::-1]:\\n            for j in range(n)[::-1]:\\n                dp[j] = max(1, min(dp[j:j+2]) - dungeon[i][j])\\n        return dp[0]\\n```\n```BFS```\n```memo```\n```DP```\n```dp```\n```dungeon```\n```dp[0][0]```\n```dp[m-1][n-1]```\n```dp[i][j]```\n```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(dungeon), len(dungeon[0]) if dungeon else 0\\n        dp = [[0] * n for _ in range(m)]\\n        dp[-1][-1] = max(1, 1 - dungeon[-1][-1])\\n        for i in range(m)[::-1]:\\n            for j in range(n)[::-1]:\\n                dp[i][j] = max(1, min([dp[x][y] for x, y in ((i+1, j), (i, j+1)) \\\\\\n                               if x < m and y < n] or [1]) - dungeon[i][j])\\n        return dp[0][0]\\n```\n```dp[i+1][j]```\n```dp[i][j+1]```\n```dp[i][j]```\n```dp```\n```dp```\n```pre```\n```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(dungeon), len(dungeon[0]) if dungeon else 0\\n        dp, pre = [1] * n, [0] * n\\n        neigh = []\\n        for i in range(m)[::-1]:\\n            for j in range(n)[::-1]:\\n                neigh = dp[j+1:j+2] if i == m-1 else pre[j:j+1] + dp[j+1:j+2]\\n                dp[j] = max(1, min(neigh or [1]) - dungeon[i][j])\\n            pre[:] = dp[:]\\n        return dp[0]\\n```\n```pre```\n```dp[i]```\n```pre[i]```\n```dp```",
                "codeTag": "Java"
            },
            {
                "id": 52863,
                "title": "java-dp-solution",
                "content": "    public int calculateMinimumHP(int[][] dungeon) {\\n        if(dungeon == null || dungeon.length == 0) return 0;\\n        int m = dungeon.length, n = dungeon[0].length;\\n        int dp[][] = new int[m][n];\\n        for(int i = m - 1; i >= 0; --i){\\n            for(int j = n - 1; j >= 0; --j){\\n                if(i == m - 1 && j == n - 1) dp[i][j] = Math.max(1, 1 - dungeon[i][j]);\\n                else if(i == m - 1) dp[i][j] = Math.max(1, dp[i][j + 1] - dungeon[i][j]);\\n                else if(j == n - 1) dp[i][j] = Math.max(1, dp[i + 1][j] - dungeon[i][j]);\\n                else dp[i][j] = Math.max(1, Math.min(dp[i][j + 1], dp[i + 1][j]) - dungeon[i][j]);\\n            }\\n        }\\n        return dp[0][0];\\n    }",
                "solutionTags": [],
                "code": "    public int calculateMinimumHP(int[][] dungeon) {\\n        if(dungeon == null || dungeon.length == 0) return 0;\\n        int m = dungeon.length, n = dungeon[0].length;\\n        int dp[][] = new int[m][n];\\n        for(int i = m - 1; i >= 0; --i){\\n            for(int j = n - 1; j >= 0; --j){\\n                if(i == m - 1 && j == n - 1) dp[i][j] = Math.max(1, 1 - dungeon[i][j]);\\n                else if(i == m - 1) dp[i][j] = Math.max(1, dp[i][j + 1] - dungeon[i][j]);\\n                else if(j == n - 1) dp[i][j] = Math.max(1, dp[i + 1][j] - dungeon[i][j]);\\n                else dp[i][j] = Math.max(1, Math.min(dp[i][j + 1], dp[i + 1][j]) - dungeon[i][j]);\\n            }\\n        }\\n        return dp[0][0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52923,
                "title": "my-java-ac-solution-with-dp-and-o-1-space",
                "content": "Start from the destination, we can calculate the minimum HP required then store it in the cell since we won't be needing it later. This way we can achieve constant space.\\n\\nIf we care not allowed to change the matrix, then we need at least a 1-D array.\\n\\n\\n\\n    public class Solution {\\n        public int calculateMinimumHP(int[][] dungeon) {\\n            // return 0 if dungeon does not exist\\n            if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) return 0;\\n            int m = dungeon.length -1, n = dungeon[0].length -1;\\n            //make sure alive after rescue\\n            dungeon[m][n] = setHp(1-dungeon[m][n]);\\n            \\n            //fill bottom row and right-most column\\n            for (int i = m-1; i >= 0; i--)\\n                dungeon[i][n] = setHp(dungeon[i+1][n] - dungeon[i][n]);\\n            for (int j = n-1; j >= 0; j--)\\n                dungeon[m][j] = setHp(dungeon[m][j+1] - dungeon[m][j]);\\n            \\n            //fill the rest\\n            for (int i = m-1; i >= 0; i--)\\n                for (int j = n-1; j >= 0; j--)\\n                    //pick minimum hp needed after this cell\\n                    dungeon[i][j] = setHp(Math.min(dungeon[i+1][j],dungeon[i][j+1])-dungeon[i][j]);\\n            \\n            return dungeon[0][0];\\n        }\\n        //if needed Hp is negative set hp to 1, otherwise positive\\n        private int setHp (int hp) {\\n            return hp <= 0 ? 1: hp;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int calculateMinimumHP(int[][] dungeon) {\\n            // return 0 if dungeon does not exist\\n            if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) return 0;\\n            int m = dungeon.length -1, n = dungeon[0].length -1;\\n            //make sure alive after rescue\\n            dungeon[m][n] = setHp(1-dungeon[m][n]);\\n            \\n            //fill bottom row and right-most column\\n            for (int i = m-1; i >= 0; i--)\\n                dungeon[i][n] = setHp(dungeon[i+1][n] - dungeon[i][n]);\\n            for (int j = n-1; j >= 0; j--)\\n                dungeon[m][j] = setHp(dungeon[m][j+1] - dungeon[m][j]);\\n            \\n            //fill the rest\\n            for (int i = m-1; i >= 0; i--)\\n                for (int j = n-1; j >= 0; j--)\\n                    //pick minimum hp needed after this cell\\n                    dungeon[i][j] = setHp(Math.min(dungeon[i+1][j],dungeon[i][j+1])-dungeon[i][j]);\\n            \\n            return dungeon[0][0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3212862,
                "title": "174-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses dynamic programming to solve the problem. The main idea is to build a 2D array dp to store the minimum initial health required at each position to reach the bottom-right corner. We start from the bottom-right corner and work our way backwards to the top-left corner.\\n\\nAt each position, we take the minimum of the minimum initial health required at the position below and the position to the right, and subtract the dungeon value at the current position. If the result is less than or equal to 0, we set it to 1 (since the knight needs to have at least 1 health point to be alive). Finally, we return the value at the top-left corner of the dp array.\\n\\nTo handle the boundary cases, we add an extra row and an extra column to the dp array, and set them all to infinity except for dp[m-1][n] and dp[m][n-1], which are set to 1.\\n\\nThis solution has a time complexity of O(mn) and a space complexity of O(mn).\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n68.28%\\n\\n- Space complexity:\\nBeats\\n97.32%\\n\\n# Code\\n```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        m, n = len(dungeon), len(dungeon[0])\\n        dp = [[float(\\'inf\\')] * (n+1) for _ in range(m+1)]\\n        dp[m-1][n] = dp[m][n-1] = 1\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)\\n        return dp[0][0]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        m, n = len(dungeon), len(dungeon[0])\\n        dp = [[float(\\'inf\\')] * (n+1) for _ in range(m+1)]\\n        dp[m-1][n] = dp[m][n-1] = 1\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)\\n        return dp[0][0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180049,
                "title": "beginner-friendly-recursion-c-dp-memoization",
                "content": "# Intuition\\nas in question it mentioned that that knight can reach any specific grid if he has some positive health so what we will have to keep in mind is if grid[i][j]>=0 then the minimum health he must have will be equql to 1\\n\\nif grid[i][j]<0 then knight must have minimum health =abs(grid[i][j])+1\\n\\n# Approach\\nfun(i,j)--->will tell us mininum health required to reach  grid[i][j]\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint fun(int i,int j,vector<vector<int>>& dungeon,vector<vector<int>> &dp){\\n    if(i>=dp.size()||j>=dp[0].size()) return 5e5;\\n    if(i==dp.size()-1&&j==dp[0].size()-1) {\\n        if(dungeon[i][j]<=0) return abs(dungeon[i][j])+1;\\n        else return 1;\\n    } \\n    if(dp[i][j]!=-1) return dp[i][j];\\n    int up=fun(i+1,j,dungeon,dp);\\n    int down=fun(i,j+1,dungeon,dp);\\n    int minhealthreq=min(up,down)-dungeon[i][j];\\n    return dp[i][j]=(minhealthreq<=0)?1:minhealthreq;\\n}\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m=dungeon.size(),n=dungeon[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n       return fun(0,0,dungeon,dp); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint fun(int i,int j,vector<vector<int>>& dungeon,vector<vector<int>> &dp){\\n    if(i>=dp.size()||j>=dp[0].size()) return 5e5;\\n    if(i==dp.size()-1&&j==dp[0].size()-1) {\\n        if(dungeon[i][j]<=0) return abs(dungeon[i][j])+1;\\n        else return 1;\\n    } \\n    if(dp[i][j]!=-1) return dp[i][j];\\n    int up=fun(i+1,j,dungeon,dp);\\n    int down=fun(i,j+1,dungeon,dp);\\n    int minhealthreq=min(up,down)-dungeon[i][j];\\n    return dp[i][j]=(minhealthreq<=0)?1:minhealthreq;\\n}\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m=dungeon.size(),n=dungeon[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n       return fun(0,0,dungeon,dp); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983069,
                "title": "intuitive-2-d-dp-in-the-table-python-beats-97-on-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuitive DP in 2-D graph, we calculate DP for each point in the dungeon table.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- dp[ i ][ j ] indicates the minimum life requirement to reach the finish point.\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n\\n        # the minimum life needed to survive to the finish point\\n        m = len(dungeon)\\n        n = len(dungeon[0])\\n        dp = dungeon\\n\\n        dp[m-1][n-1] = max(1, -dp[m-1][n-1]+1)\\n\\n        for i in range(n-2, -1, -1):\\n            dp[m-1][i] = max(1, -dp[m-1][i] + dp[m-1][i+1])\\n        for j in range(m-2, -1, -1):\\n            dp[j][n-1] = max(1, -dp[j][n-1] + dp[j+1][n-1]) \\n \\n        for j in range(m-2, -1, -1):\\n            for i in range(n-2, -1, -1):\\n                dp[j][i] = max(1, -dp[j][i] + min(dp[j+1][i], dp[j][i+1]))\\n        \\n        return dp[0][0]\\n\\n\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n\\n        # the minimum life needed to survive to the finish point\\n        m = len(dungeon)\\n        n = len(dungeon[0])\\n        dp = dungeon\\n\\n        dp[m-1][n-1] = max(1, -dp[m-1][n-1]+1)\\n\\n        for i in range(n-2, -1, -1):\\n            dp[m-1][i] = max(1, -dp[m-1][i] + dp[m-1][i+1])\\n        for j in range(m-2, -1, -1):\\n            dp[j][n-1] = max(1, -dp[j][n-1] + dp[j+1][n-1]) \\n \\n        for j in range(m-2, -1, -1):\\n            for i in range(n-2, -1, -1):\\n                dp[j][i] = max(1, -dp[j][i] + min(dp[j+1][i], dp[j][i+1]))\\n        \\n        return dp[0][0]\\n\\n\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567313,
                "title": "explanation-from-scratch-frequenty-asked-in-interviews-c",
                "content": "```\\nint calculateMinimumHP(vector<vector<int>>& grid) {\\n        \\n        int m=grid.size(),n=grid[0].size();\\n        int dp[m][n];\\n        memset(dp,-1,sizeof dp);\\n\\n        //main logic --> hum top se bottom ki trf jaa rhe to total path ka sum nahi krna calculate kya pta path sum >0 ho aur hum ans=1 krde par pehle cell me hi -4 ho kaise cross kroge . dp[i][j] ye return krega ki use kitni energy chiye (-ve me) agar koi cell (20 lets say) apne down wle cell ki negative(-7) ko compensate kr skta to vo dp[i][j] me 0 likhega ki bhai dp[i][j] wli subproblem b 0 energy chiye hume ab baaki problem solve krlo tum\\n        \\n        for(int i=m-1;i>=0;i--)\\n        {\\n            for(int j=n-1;j>=0;j--)\\n            {    \\n                if(i==m-1 and j==n-1)                          //yaha aane ke liye\\n                    dp[i][j]=grid[i][j]>=0?0:grid[i][j];  // hi mujhe itni energy chiye\\n                \\n                else if(i==m-1)\\n                    dp[i][j]=(grid[i][j]+dp[i][j+1])>=0? 0:grid[i][j]+dp[i][j+1];\\n                \\n                else if(j==n-1)\\n                    dp[i][j]=(grid[i][j]+dp[i+1][j])>=0? 0:grid[i][j]+dp[i+1][j];\\n                else\\n                {\\n                    int val=grid[i][j]+max(dp[i+1][j],dp[i][j+1]);\\n                    dp[i][j]=(val>=0)? 0:val;\\n                }\\n                    \\n            }\\n        }\\n        return dp[0][0]==0?1:abs(dp[0][0])+1;\\n    }",
                "solutionTags": [],
                "code": "```\\nint calculateMinimumHP(vector<vector<int>>& grid) {\\n        \\n        int m=grid.size(),n=grid[0].size();\\n        int dp[m][n];\\n        memset(dp,-1,sizeof dp);\\n\\n        //main logic --> hum top se bottom ki trf jaa rhe to total path ka sum nahi krna calculate kya pta path sum >0 ho aur hum ans=1 krde par pehle cell me hi -4 ho kaise cross kroge . dp[i][j] ye return krega ki use kitni energy chiye (-ve me) agar koi cell (20 lets say) apne down wle cell ki negative(-7) ko compensate kr skta to vo dp[i][j] me 0 likhega ki bhai dp[i][j] wli subproblem b 0 energy chiye hume ab baaki problem solve krlo tum\\n        \\n        for(int i=m-1;i>=0;i--)\\n        {\\n            for(int j=n-1;j>=0;j--)\\n            {    \\n                if(i==m-1 and j==n-1)                          //yaha aane ke liye\\n                    dp[i][j]=grid[i][j]>=0?0:grid[i][j];  // hi mujhe itni energy chiye\\n                \\n                else if(i==m-1)\\n                    dp[i][j]=(grid[i][j]+dp[i][j+1])>=0? 0:grid[i][j]+dp[i][j+1];\\n                \\n                else if(j==n-1)\\n                    dp[i][j]=(grid[i][j]+dp[i+1][j])>=0? 0:grid[i][j]+dp[i+1][j];\\n                else\\n                {\\n                    int val=grid[i][j]+max(dp[i+1][j],dp[i][j+1]);\\n                    dp[i][j]=(val>=0)? 0:val;\\n                }\\n                    \\n            }\\n        }\\n        return dp[0][0]==0?1:abs(dp[0][0])+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1912920,
                "title": "c-solution-recursive-memoization-tabulation",
                "content": "```\\n// RECURSIVE APPROACH\\nclass Solution {\\npublic:\\n    int helper(int i,int j,int m,int n,vector<vector<int>> &dungeon){\\n        if(i>=m || j>=n) return INT_MAX;\\n        int right=helper(i,j+1,m,n,dungeon);\\n        int down=helper(i+1,j,m,n,dungeon);\\n        int health=min(right,down);\\n        if(health==INT_MAX){\\n            health=1;\\n        }\\n        \\n        int res=0;\\n        if(health-dungeon[i][j]>0){\\n            res=health-dungeon[i][j];\\n        }\\n        else{\\n            res=1;\\n        }\\n        return res;\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        return helper(0,0,dungeon.size(),dungeon[0].size(),dungeon);\\n    }\\n};\\n\\n// MEMOIZATION\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int helper(int i,int j,int m,int n,vector<vector<int>> &dungeon){\\n        if(i>=m || j>=n) return INT_MAX;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int right=helper(i,j+1,m,n,dungeon);\\n        int down=helper(i+1,j,m,n,dungeon);\\n        int health=min(right,down);\\n        if(health==INT_MAX){\\n            health=1;\\n        }\\n        \\n        int res=0;\\n        if(health-dungeon[i][j]>0){\\n            res=health-dungeon[i][j];\\n        }\\n        else{\\n            res=1;\\n        }\\n        return dp[i][j]=res;\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,0,dungeon.size(),dungeon[0].size(),dungeon);\\n    }\\n};\\n\\n// TABULATION\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m=dungeon.size();\\n        int n=dungeon[0].size();\\n        vector<vector<int>> dp(m+1,vector<int> (n+1,INT_MAX));\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                int right=dp[i][j+1];\\n                int down=dp[i+1][j];\\n                int health=min(right,down);\\n                if(health==INT_MAX){\\n                    health=1;\\n                }\\n                int res=0;\\n                if(health-dungeon[i][j]>0){\\n                    res=health-dungeon[i][j];\\n                }\\n                else{\\n                    res=1;\\n                }\\n                dp[i][j]=res;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\nPLEASE UPVOTE IF YOU LIKE THE POST :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// RECURSIVE APPROACH\\nclass Solution {\\npublic:\\n    int helper(int i,int j,int m,int n,vector<vector<int>> &dungeon){\\n        if(i>=m || j>=n) return INT_MAX;\\n        int right=helper(i,j+1,m,n,dungeon);\\n        int down=helper(i+1,j,m,n,dungeon);\\n        int health=min(right,down);\\n        if(health==INT_MAX){\\n            health=1;\\n        }\\n        \\n        int res=0;\\n        if(health-dungeon[i][j]>0){\\n            res=health-dungeon[i][j];\\n        }\\n        else{\\n            res=1;\\n        }\\n        return res;\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        return helper(0,0,dungeon.size(),dungeon[0].size(),dungeon);\\n    }\\n};\\n\\n// MEMOIZATION\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int helper(int i,int j,int m,int n,vector<vector<int>> &dungeon){\\n        if(i>=m || j>=n) return INT_MAX;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int right=helper(i,j+1,m,n,dungeon);\\n        int down=helper(i+1,j,m,n,dungeon);\\n        int health=min(right,down);\\n        if(health==INT_MAX){\\n            health=1;\\n        }\\n        \\n        int res=0;\\n        if(health-dungeon[i][j]>0){\\n            res=health-dungeon[i][j];\\n        }\\n        else{\\n            res=1;\\n        }\\n        return dp[i][j]=res;\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,0,dungeon.size(),dungeon[0].size(),dungeon);\\n    }\\n};\\n\\n// TABULATION\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m=dungeon.size();\\n        int n=dungeon[0].size();\\n        vector<vector<int>> dp(m+1,vector<int> (n+1,INT_MAX));\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                int right=dp[i][j+1];\\n                int down=dp[i+1][j];\\n                int health=min(right,down);\\n                if(health==INT_MAX){\\n                    health=1;\\n                }\\n                int res=0;\\n                if(health-dungeon[i][j]>0){\\n                    res=health-dungeon[i][j];\\n                }\\n                else{\\n                    res=1;\\n                }\\n                dp[i][j]=res;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755117,
                "title": "dp-solution-easy-to-understand-o-n-m",
                "content": "This problem can be easily solved by the approach of DP on grid. \\nIdea:\\n  We will start from the index (0,0) and on each index we have two choices i.e either move to down or move to right. \\n  As mentioned in the question we have to find the minimum value of health such that knight reaches the queen,\\n  therefore for this purpose we have to find the path such that the minimum of (health on particular index, total sum of health from that index to (n-1,m-1) ) should be maximum.\\n  The subproblem of this question will be minimum value of health  knight requires such that he starts at the index (i,j) and reaches the queen situated at index (n-1,m-1) and this subproblem will be stored in the dp grid.\\n  \\n\\n```class Solution {\\npublic:\\n    \\n    // here n= number of rows and m=number of column\\n    \\n    \\n bool check(int row, int col, int n, int m)  // checking if the index is out of bound or not\\n{\\n\\tif (row < 0 || col < 0 || row >= n || col >= m)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn true;\\n}\\n\\nint solve(int row, int col, vector<vector<int>>& dungeon, vector<vector<int>>&dp)\\n{\\n\\tint n = dungeon.size();\\n\\tint m = dungeon[0].size();\\n\\n\\tif (row == n - 1 && col == m - 1) // base condition i.e if the  knight reaches the princess then return the value as stated below\\n\\t{\\n\\t\\treturn dp[row][col] = dungeon[row][col];\\n\\t}\\n// if the subproblem is already calculated then return the ans stored of that particular subproblem\\n\\tif (dp[row][col] != -1e6)\\n\\t{\\n\\t\\treturn dp[row][col];\\n\\t}\\n\\t// calculating the value of particular subproblem\\n\\tint ans = -1e6;\\n\\n\\tif (check(row, col + 1, n, m))\\n\\t{\\n\\t\\tans = max(ans, min(dungeon[row][col], solve(row, col + 1, dungeon, dp) + dungeon[row][col]));\\n\\t}\\n\\tif (check(row + 1, col, n, m))\\n\\t{\\n\\t\\tans = max(ans, min(dungeon[row][col], solve(row + 1, col, dungeon, dp) + dungeon[row][col]));\\n\\t}\\n// storing the ans of the subproblem (row,col) in the grid\\n\\treturn dp[row][col] = ans;\\n\\n\\n}\\n\\nint calculateMinimumHP(vector<vector<int>>& dungeon) {\\n\\tint n = dungeon.size();\\n\\tint m = dungeon[0].size();\\n\\tvector<vector<int>>dp(n, vector<int>(m, -1e6));\\n\\n\\tint ans = solve(0, 0, dungeon, dp);\\n\\tif (ans > 0)\\n\\t{\\n\\t\\treturn 1;\\n\\n\\t}\\n\\n\\n\\n\\treturn 1 - ans;\\n\\n}\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    // here n= number of rows and m=number of column\\n    \\n    \\n bool check(int row, int col, int n, int m)  // checking if the index is out of bound or not\\n{\\n\\tif (row < 0 || col < 0 || row >= n || col >= m)\\n\\t{\\n\\t\\treturn false;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1502316,
                "title": "c-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    int calculateMinimumHP(vector<vector<int>> &dungeon)\\n    {\\n        vector<int> dp(dungeon.size() + 1, INT_MAX);\\n        dp[dungeon.size() - 1] = 1;\\n        for (int i = dungeon[0].size() - 1; i >= 0; i--)\\n        {\\n            for (int j = dungeon.size() - 1; j >= 0; j--)\\n            {\\n                dp[j] = max(1, min(dp[j + 1], dp[j]) - dungeon[j][i]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    int calculateMinimumHP(vector<vector<int>> &dungeon)\\n    {\\n        vector<int> dp(dungeon.size() + 1, INT_MAX);\\n        dp[dungeon.size() - 1] = 1;\\n        for (int i = dungeon[0].size() - 1; i >= 0; i--)\\n        {\\n            for (int j = dungeon.size() - 1; j >= 0; j--)\\n            {\\n                dp[j] = max(1, min(dp[j + 1], dp[j]) - dungeon[j][i]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498811,
                "title": "python-using-dp",
                "content": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        row = len(dungeon)\\n        col = len(dungeon[0])\\n        dp = [[ 0 for _ in range(col)] for _ in range(row)]\\n        for i in range(row - 1,-1,-1):\\n            for j in range(col - 1,-1,-1):\\n                if i == row - 1 and j == col - 1:\\n                    dp[i][j] = min(0, dungeon[i][j])\\n                elif i == row - 1:\\n                    dp[i][j] = min(0, dungeon[i][j] + dp[i][j + 1])\\n                elif j == col - 1:\\n                    dp[i][j] = min(0,dungeon[i][j] + dp[i + 1][j]) \\n                else:\\n                    dp[i][j] = min(0,dungeon[i][j] + max(dp[i + 1][j], dp[i][j + 1]))\\n        print(dp)\\n        return abs(dp[0][0]) + 1\\n```\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        row = len(dungeon)\\n        col = len(dungeon[0])\\n        dp = [[ 0 for _ in range(col)] for _ in range(row)]\\n        for i in range(row - 1,-1,-1):\\n            for j in range(col - 1,-1,-1):\\n                if i == row - 1 and j == col - 1:\\n                    dp[i][j] = min(0, dungeon[i][j])\\n                elif i == row - 1:\\n                    dp[i][j] = min(0, dungeon[i][j] + dp[i][j + 1])\\n                elif j == col - 1:\\n                    dp[i][j] = min(0,dungeon[i][j] + dp[i + 1][j]) \\n                else:\\n                    dp[i][j] = min(0,dungeon[i][j] + max(dp[i + 1][j], dp[i][j + 1]))\\n        print(dp)\\n        return abs(dp[0][0]) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498591,
                "title": "c-solution",
                "content": "class Solution\\n{\\npublic:\\n\\n    int calculateMinimumHP(vector<vector<int>> &dungeon)\\n    {\\n        vector<int> dp(dungeon.size() + 1, INT_MAX);\\n        dp[dungeon.size() - 1] = 1;\\n\\n        for (int i = dungeon[0].size() - 1; i >= 0; i--)\\n        {\\n            for (int j = dungeon.size() - 1; j >= 0; j--)\\n            {\\n                dp[j] = max(1, min(dp[j + 1], dp[j]) - dungeon[j][i]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\npublic:\\n\\n    int calculateMinimumHP(vector<vector<int>> &dungeon)\\n    {\\n        vector<int> dp(dungeon.size() + 1, INT_MAX);\\n        dp[dungeon.size() - 1] = 1;\\n\\n        for (int i = dungeon[0].size() - 1; i >= 0; i--)\\n        {\\n            for (int j = dungeon.size() - 1; j >= 0; j--)\\n            {\\n                dp[j] = max(1, min(dp[j + 1], dp[j]) - dungeon[j][i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1382683,
                "title": "dungeon-game-all-3-approaches-c",
                "content": "# Recursion\\n\\n```\\n   \\tint solve(int i, int j,vector<vector<int>> &p, int M, int N)\\n\\t{\\n\\t    if(i>=M || j>=N) return INT_MAX;\\n            \\n        if(i==M-1 && j==N-1)\\n\\t    return p[i][j]<=0 ? 1+abs(p[i][j]) : 1;\\n            \\n\\t    int right = solve(i,j+1,p,M,N);\\n        int left  = solve(i+1,j,p,M,N);\\n        \\n        int minEnergy = min(left,right)-p[i][j];\\n        \\n        return (minEnergy<=0) ? 1: minEnergy;\\n            \\n \\n\\t}\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int M=dungeon.size(),N=dungeon[0].size();\\n        return solve(0,0,dungeon,M,N);\\n    }\\n```\\n\\n# Memoization\\n```\\n   \\tint solve(int i, int j,vector<vector<int>> &p, int M, int N,vector<vector<int>> &dp)\\n\\t{\\n\\t    if(i>=M || j>=N) return INT_MAX;\\n            \\n        if(i==M-1 && j==N-1)\\n\\t    return p[i][j]<=0 ? 1+abs(p[i][j]) : 1;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n            \\n\\t    int right = solve(i,j+1,p,M,N,dp);\\n        int left  = solve(i+1,j,p,M,N,dp);\\n        \\n        int minEnergy = min(left,right)-p[i][j];\\n        \\n        return dp[i][j] = (minEnergy<=0) ? 1: minEnergy;\\n            \\n \\n\\t}\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int M=dungeon.size(),N=dungeon[0].size();\\n        vector<vector<int>>dp(M,vector<int>(N,-1));\\n        return solve(0,0,dungeon,M,N,dp);\\n    }\\n```\\n\\n# Pure DP:\\n```\\n int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int M=dungeon.size(),N=dungeon[0].size();\\n        \\n        // we have to start from top 2 bottom as we require previous knowledge\\n        // for bottom to top its not possible as we require future knowledge\\n        \\n        vector<vector<int> > dp(M + 1, vector<int>(N + 1, INT_MAX));\\n        // reduntant rows\\n        dp[M-1][N]=1;\\n        dp[M][N-1]=1; \\n        \\n        for(int i=M-1;i>=0;i--)\\n        {\\n            for(int j=N-1;j>=0;j--)\\n            {\\n                int minEnergy = min(dp[i+1][j],dp[i][j+1])-dungeon[i][j];\\n                dp[i][j] = (minEnergy<=0) ? 1 : minEnergy;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   \\tint solve(int i, int j,vector<vector<int>> &p, int M, int N)\\n\\t{\\n\\t    if(i>=M || j>=N) return INT_MAX;\\n            \\n        if(i==M-1 && j==N-1)\\n\\t    return p[i][j]<=0 ? 1+abs(p[i][j]) : 1;\\n            \\n\\t    int right = solve(i,j+1,p,M,N);\\n        int left  = solve(i+1,j,p,M,N);\\n        \\n        int minEnergy = min(left,right)-p[i][j];\\n        \\n        return (minEnergy<=0) ? 1: minEnergy;\\n            \\n \\n\\t}\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int M=dungeon.size(),N=dungeon[0].size();\\n        return solve(0,0,dungeon,M,N);\\n    }\\n```\n```\\n   \\tint solve(int i, int j,vector<vector<int>> &p, int M, int N,vector<vector<int>> &dp)\\n\\t{\\n\\t    if(i>=M || j>=N) return INT_MAX;\\n            \\n        if(i==M-1 && j==N-1)\\n\\t    return p[i][j]<=0 ? 1+abs(p[i][j]) : 1;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n            \\n\\t    int right = solve(i,j+1,p,M,N,dp);\\n        int left  = solve(i+1,j,p,M,N,dp);\\n        \\n        int minEnergy = min(left,right)-p[i][j];\\n        \\n        return dp[i][j] = (minEnergy<=0) ? 1: minEnergy;\\n            \\n \\n\\t}\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int M=dungeon.size(),N=dungeon[0].size();\\n        vector<vector<int>>dp(M,vector<int>(N,-1));\\n        return solve(0,0,dungeon,M,N,dp);\\n    }\\n```\n```\\n int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int M=dungeon.size(),N=dungeon[0].size();\\n        \\n        // we have to start from top 2 bottom as we require previous knowledge\\n        // for bottom to top its not possible as we require future knowledge\\n        \\n        vector<vector<int> > dp(M + 1, vector<int>(N + 1, INT_MAX));\\n        // reduntant rows\\n        dp[M-1][N]=1;\\n        dp[M][N-1]=1; \\n        \\n        for(int i=M-1;i>=0;i--)\\n        {\\n            for(int j=N-1;j>=0;j--)\\n            {\\n                int minEnergy = min(dp[i+1][j],dp[i][j+1])-dungeon[i][j];\\n                dp[i][j] = (minEnergy<=0) ? 1 : minEnergy;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1342157,
                "title": "faster-easy",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n      int m = dungeon.size(), n = dungeon[0].size();\\n      vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX)); \\n      dp[m][n - 1] = 1; \\n      dp[m - 1][n] = 1;\\n      for (int i = m - 1; i >= 0; i--) \\n     {\\n        for (int j = n - 1; j >= 0; j--) \\n      {     \\n          dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);\\n      }\\n     }\\n       return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n      int m = dungeon.size(), n = dungeon[0].size();\\n      vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX)); \\n      dp[m][n - 1] = 1; \\n      dp[m - 1][n] = 1;\\n      for (int i = m - 1; i >= 0; i--) \\n     {\\n        for (int j = n - 1; j >= 0; j--) \\n      {     \\n          dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);\\n      }\\n     }\\n       return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916283,
                "title": "java-recursive-tle-memoization-2d-bottom-up-1d-bottom-up",
                "content": "```\\n- It will be difficult to determine the initial health of the knight\\n\\t- But, we can predict the amount the health that the knight should end on AFTER he has saved the princess\\n\\t\\t- If the princess is located at \\'m - 1, n - 1\\'\\n\\t\\t\\t- Then if the knight continues to move rightward or downward\\n\\t\\t\\t\\t- The knight\\'s hp at \\'m - 1, n\\' or \\'m, n - 1\\' should be equal to 1\\n- We will implement a recursive approach starting from the top left\\n\\t- In each of the recursive call\\n\\t\\t- We will move downward or rightward\\n\\t\\t\\t- We will pick the choice that will give us the least amount of hp\\n\\t\\t- In order to stay at the current cell at \\'r,c\\'\\n\\t\\t\\t- The minimum health needs to be \\'min health of going rightward or downward - dungeon[r][c]\\'\\n\\t\\t\\t- We should note that if min health goes below 0\\n\\t\\t\\t\\t- We have to default the min health to 1\\n```\\n```\\npublic class DungeonGameRecursiveApproach {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon.length == 0) return 0;\\n\\n        return calculateMinimumHP(0, 0, dungeon, dungeon.length, dungeon[0].length);\\n    }\\n\\n    private int calculateMinimumHP(int r, int c, int[][] dungeon, int m, int n) {\\n        if ((r == m && c == n - 1) || (r == m - 1 && c == n)) return 1;\\n        if (r == m || c == n) return Integer.MAX_VALUE;\\n\\n        int health1 = calculateMinimumHP(r, c + 1, dungeon, m, n);\\n        int health2 = calculateMinimumHP(r + 1, c, dungeon, m, n);\\n        int minHealth = Math.min(health1, health2) - dungeon[r][c];\\n\\n        return Math.max(1, minHealth);\\n    }\\n}\\n```\\n```\\npublic class DungeonGameMemoizationApproach {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon.length == 0) return 0;\\n\\n        int m = dungeon.length, n = dungeon[0].length;\\n        return calculateMinimumHP(0, 0, dungeon, m, n, new int[m + 1][n + 1]);\\n    }\\n\\n    private int calculateMinimumHP(int r, int c, int[][] dungeon, int m, int n, int[][] memo) {\\n        if ((r == m && c == n - 1) || (r == m - 1 && c == n)) return 1;\\n        if (r == m || c == n) return Integer.MAX_VALUE;\\n        if (memo[r][c] != 0) return memo[r][c];\\n\\n        int health1 = calculateMinimumHP(r, c + 1, dungeon, m, n, memo);\\n        int health2 = calculateMinimumHP(r + 1, c, dungeon, m, n, memo);\\n        int minHealth = Math.min(health1, health2) - dungeon[r][c];\\n\\n        return memo[r][c] = Math.max(1, minHealth);\\n    }\\n}\\n```\\n```\\npublic class DungeonGameBottomUp2DApproach {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int m = dungeon.length, n = dungeon[0].length;\\n        int[][] minHealth = new int[m + 1][n + 1];\\n\\n        for (int r = m; r >= 0; r--) {\\n            for (int c = n; c >= 0; c--) {\\n                if ((r == m && c == n - 1) || (r == m - 1 && c == n)) {\\n                    minHealth[r][c] = 1;\\n                    continue;\\n                }\\n\\n                if (r == m || c == n) {\\n                    minHealth[r][c] = Integer.MAX_VALUE;\\n                    continue;\\n                }\\n\\n                minHealth[r][c] = Math.max(1, Math.min(minHealth[r + 1][c], minHealth[r][c + 1]) - dungeon[r][c]);\\n            }\\n        }\\n\\n        return minHealth[0][0];\\n    }\\n}\\n```\\n```\\npublic class DungeonGameBottomUp1DApproach {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int m = dungeon.length, n = dungeon[0].length;\\n        int[] minHealth = new int[n + 1];\\n\\n        for (int r = m; r >= 0; r--) {\\n            for (int c = n; c >= 0; c--) {\\n                if ((r == m && c == n - 1) || (r == m - 1 && c == n)) {\\n                    minHealth[c] = 1;\\n                    continue;\\n                }\\n\\n                if (r == m || c == n) {\\n                    minHealth[c] = Integer.MAX_VALUE;\\n                    continue;\\n                }\\n\\n                minHealth[c] = Math.max(1, Math.min(minHealth[c], minHealth[c + 1]) - dungeon[r][c]);\\n            }\\n        }\\n\\n        return minHealth[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n- It will be difficult to determine the initial health of the knight\\n\\t- But, we can predict the amount the health that the knight should end on AFTER he has saved the princess\\n\\t\\t- If the princess is located at \\'m - 1, n - 1\\'\\n\\t\\t\\t- Then if the knight continues to move rightward or downward\\n\\t\\t\\t\\t- The knight\\'s hp at \\'m - 1, n\\' or \\'m, n - 1\\' should be equal to 1\\n- We will implement a recursive approach starting from the top left\\n\\t- In each of the recursive call\\n\\t\\t- We will move downward or rightward\\n\\t\\t\\t- We will pick the choice that will give us the least amount of hp\\n\\t\\t- In order to stay at the current cell at \\'r,c\\'\\n\\t\\t\\t- The minimum health needs to be \\'min health of going rightward or downward - dungeon[r][c]\\'\\n\\t\\t\\t- We should note that if min health goes below 0\\n\\t\\t\\t\\t- We have to default the min health to 1\\n```\n```\\npublic class DungeonGameRecursiveApproach {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon.length == 0) return 0;\\n\\n        return calculateMinimumHP(0, 0, dungeon, dungeon.length, dungeon[0].length);\\n    }\\n\\n    private int calculateMinimumHP(int r, int c, int[][] dungeon, int m, int n) {\\n        if ((r == m && c == n - 1) || (r == m - 1 && c == n)) return 1;\\n        if (r == m || c == n) return Integer.MAX_VALUE;\\n\\n        int health1 = calculateMinimumHP(r, c + 1, dungeon, m, n);\\n        int health2 = calculateMinimumHP(r + 1, c, dungeon, m, n);\\n        int minHealth = Math.min(health1, health2) - dungeon[r][c];\\n\\n        return Math.max(1, minHealth);\\n    }\\n}\\n```\n```\\npublic class DungeonGameMemoizationApproach {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if (dungeon.length == 0) return 0;\\n\\n        int m = dungeon.length, n = dungeon[0].length;\\n        return calculateMinimumHP(0, 0, dungeon, m, n, new int[m + 1][n + 1]);\\n    }\\n\\n    private int calculateMinimumHP(int r, int c, int[][] dungeon, int m, int n, int[][] memo) {\\n        if ((r == m && c == n - 1) || (r == m - 1 && c == n)) return 1;\\n        if (r == m || c == n) return Integer.MAX_VALUE;\\n        if (memo[r][c] != 0) return memo[r][c];\\n\\n        int health1 = calculateMinimumHP(r, c + 1, dungeon, m, n, memo);\\n        int health2 = calculateMinimumHP(r + 1, c, dungeon, m, n, memo);\\n        int minHealth = Math.min(health1, health2) - dungeon[r][c];\\n\\n        return memo[r][c] = Math.max(1, minHealth);\\n    }\\n}\\n```\n```\\npublic class DungeonGameBottomUp2DApproach {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int m = dungeon.length, n = dungeon[0].length;\\n        int[][] minHealth = new int[m + 1][n + 1];\\n\\n        for (int r = m; r >= 0; r--) {\\n            for (int c = n; c >= 0; c--) {\\n                if ((r == m && c == n - 1) || (r == m - 1 && c == n)) {\\n                    minHealth[r][c] = 1;\\n                    continue;\\n                }\\n\\n                if (r == m || c == n) {\\n                    minHealth[r][c] = Integer.MAX_VALUE;\\n                    continue;\\n                }\\n\\n                minHealth[r][c] = Math.max(1, Math.min(minHealth[r + 1][c], minHealth[r][c + 1]) - dungeon[r][c]);\\n            }\\n        }\\n\\n        return minHealth[0][0];\\n    }\\n}\\n```\n```\\npublic class DungeonGameBottomUp1DApproach {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int m = dungeon.length, n = dungeon[0].length;\\n        int[] minHealth = new int[n + 1];\\n\\n        for (int r = m; r >= 0; r--) {\\n            for (int c = n; c >= 0; c--) {\\n                if ((r == m && c == n - 1) || (r == m - 1 && c == n)) {\\n                    minHealth[c] = 1;\\n                    continue;\\n                }\\n\\n                if (r == m || c == n) {\\n                    minHealth[c] = Integer.MAX_VALUE;\\n                    continue;\\n                }\\n\\n                minHealth[c] = Math.max(1, Math.min(minHealth[c], minHealth[c + 1]) - dungeon[r][c]);\\n            }\\n        }\\n\\n        return minHealth[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882429,
                "title": "java-0ms-100-time-and-95-99-space-memoization",
                "content": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int r = findMin(dungeon, 0, 0, new Integer[dungeon.length][dungeon[0].length]);\\n        return r <= 0 ? -r+1 : 1;\\n    }\\n    \\n    int findMin(int[][] dn, int i, int j, Integer[][] memo){\\n        if(i == dn.length-1 && j == dn[0].length-1) return dn[i][j];\\n        if(i>=dn.length || j>=dn[0].length) return Integer.MIN_VALUE;\\n        \\n        if(memo[i][j] != null) return memo[i][j];\\n        \\n        int r1 = findMin(dn, i, j+1, memo);\\n        int r2 = findMin(dn, i+1, j, memo);\\n        int r = Math.max(r1, r2);\\n        r = Math.min(dn[i][j], r+dn[i][j]);\\n        memo[i][j] = r;\\n        return memo[i][j];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int r = findMin(dungeon, 0, 0, new Integer[dungeon.length][dungeon[0].length]);\\n        return r <= 0 ? -r+1 : 1;\\n    }\\n    \\n    int findMin(int[][] dn, int i, int j, Integer[][] memo){\\n        if(i == dn.length-1 && j == dn[0].length-1) return dn[i][j];\\n        if(i>=dn.length || j>=dn[0].length) return Integer.MIN_VALUE;\\n        \\n        if(memo[i][j] != null) return memo[i][j];\\n        \\n        int r1 = findMin(dn, i, j+1, memo);\\n        int r2 = findMin(dn, i+1, j, memo);\\n        int r = Math.max(r1, r2);\\n        r = Math.min(dn[i][j], r+dn[i][j]);\\n        memo[i][j] = r;\\n        return memo[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779712,
                "title": "python-top-down-bottom-up-soln-dp",
                "content": "**Top-Down**\\n\\n```\\nclass Solution:\\n    def dp(self, A, i, j, dp):\\n        m = len(A)\\n        n = len(A[0])\\n        if dp[i][j] != float(\\'inf\\'):\\n            return dp[i][j]\\n\\n        if i == m or j == n:\\n            return float(\\'inf\\')\\n\\n        if i == m-1 and j == n-1:\\n            hp = 1 - A[i][j] if A[i][j] <= 0 else 1\\n        else:\\n            hp = min(self.dp(A,i+1,j,dp), self.dp(A,i,j+1,dp)) - A[i][j]\\n\\n        dp[i][j] = 1 if hp <= 0 else hp\\n        return dp[i][j]\\n    \\n    def calculateMinimumHP(self, A: List[List[int]]) -> int:\\n        m = len(A)\\n        n = len(A[0])\\n        dp = [[float(\\'inf\\')]*(n+1) for _ in range(m+1)]\\n        return self.dp(A,0,0,dp)\\n```\\n\\n**Bottom-Up**\\n\\n```\\nclass Solution:\\n    def calculateMinimumHP(self, A: List[List[int]]) -> int:\\n        m = len(A)\\n        n = len(A[0])\\n        dp = [[float(\\'inf\\')]*(n+1) for _ in range(m+1)]\\n        \\n        dp[m][n-1] = 1\\n        dp[m-1][n] = 1\\n\\n        for i in reversed(range(m)):\\n            for j in reversed(range(n)):\\n                dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - A[i][j], 1)\\n                \\n        return dp[0][0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def dp(self, A, i, j, dp):\\n        m = len(A)\\n        n = len(A[0])\\n        if dp[i][j] != float(\\'inf\\'):\\n            return dp[i][j]\\n\\n        if i == m or j == n:\\n            return float(\\'inf\\')\\n\\n        if i == m-1 and j == n-1:\\n            hp = 1 - A[i][j] if A[i][j] <= 0 else 1\\n        else:\\n            hp = min(self.dp(A,i+1,j,dp), self.dp(A,i,j+1,dp)) - A[i][j]\\n\\n        dp[i][j] = 1 if hp <= 0 else hp\\n        return dp[i][j]\\n    \\n    def calculateMinimumHP(self, A: List[List[int]]) -> int:\\n        m = len(A)\\n        n = len(A[0])\\n        dp = [[float(\\'inf\\')]*(n+1) for _ in range(m+1)]\\n        return self.dp(A,0,0,dp)\\n```\n```\\nclass Solution:\\n    def calculateMinimumHP(self, A: List[List[int]]) -> int:\\n        m = len(A)\\n        n = len(A[0])\\n        dp = [[float(\\'inf\\')]*(n+1) for _ in range(m+1)]\\n        \\n        dp[m][n-1] = 1\\n        dp[m-1][n] = 1\\n\\n        for i in reversed(range(m)):\\n            for j in reversed(range(n)):\\n                dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - A[i][j], 1)\\n                \\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699902,
                "title": "a-solution-easy-on-eyes-of-programming-noobs-like-us",
                "content": "**Approach** \\n    this question is similar to questions like \"Number of ways to reach Home\" or \"Minimum number of moves to reach destination\"\\n    Now for dp\\n    First Question\\n   **what will every cell in dp represent?**\\n    every cell should represent the minimum power required to reach the cell\\n    \\n**how to find the minimum power for each cell?**\\n Minimum of power \"magnitude wise\" required to reach the cell +value of current cell \\n\\nmore formally \\n   \\n   currpow=dungeon[i][j]+\\n\\t**(if both right and down possible)**\\n\\t\\n   ```\\n /*if magnitude(right)<magnitude(down)\\n     currpow+=right\\n         else\\n       currpow+=down */ \\n```    \\n    so if power for a cell comes out to be positive what should be the minimum number required to reach the cell?\\n    it should be zero\\n    for negative power the value should be stored as it is in the table\\n    also the health should  be atleast 1\\nclass Solution {\\n  \\n    public int calculateMinimumHP(int[][] dungeon) {\\n     int n=dungeon.length,m=dungeon[0].length;\\n       int [][] dp=new int[n][m];\\n       //start filling up table in top down manner\\n        dp[n-1][m-1]=dungeon[n-1][m-1]>0?0:dungeon[n-1][m-1];\\n        //for last row only right moves possible\\n       for(int i=m-2;i>=0;i--)\\n           dp[n-1][i]=dungeon[n-1][i]+dp[n-1][i+1]>0?0:dungeon[n-1][i]+dp[n-1][i+1];\\n        //for last column only down moves possible\\n      for(int i=n-2;i>=0;i--)\\n          dp[i][m-1]=dungeon[i][m-1]+dp[i+1][m-1]>0?0:dungeon[i][m-1]+dp[i+1][m-1];\\n          for(int i=n-2;i>=0;i--)\\n          {\\n              for(int j=m-2;j>=0;j--)\\n              {\\n                  int temp=dungeon[i][j];\\n                  //both down and right moves are possible\\n                  //why abs?\\n\\t\\t\\t\\t  \\n                  //think of it like this \"-\" only denotes that we have to give power\\n\\t\\t\\t\\t  \\n                  //so only magnitude is relevant to determine the optimal move\\n\\t\\t\\t\\t \\n                  if(Math.abs(dp[i+1][j])<Math.abs(dp[i][j+1]))\\n                  {\\n                      temp+=dp[i+1][j];\\n                  }\\n                  else\\n                  {\\n                      temp+=dp[i][j+1];\\n                  }\\n                  //don\\'t do something like below\\n                  //bcoz we need to add negative value in case both are negative\\n                  //like -2 and -3 we need to add 2 and not 3\\n                  //int temp=dungeon[i][j]+Math.min(Math.abs(dp[i+1][j]),Math.abs(dp[i][j+1]));\\n                  dp[i][j]=temp>0?0:temp;\\n              }\\n          }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                System.out.print(dp[i][j]+\" \");\\n            }\\n            System.out.println();\\n        }\\n        //why abs?\\n        //we care for magnitude only\\n        // +1 bcoz we need atleast 1 health\\n       return Math.abs(dp[0][0])+1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n /*if magnitude(right)<magnitude(down)\\n     currpow+=right\\n         else\\n       currpow+=down */ \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698935,
                "title": "python-3-dp-solution-easy-to-understand-explanation-o-m-n",
                "content": "### **Preface**\\n\\nMany of the solutions I\\'ve seen have made it really difficult to understand what it is we are trying to solve for and how we build an optimal solution, so this post aims to remedy that. A quick look at the problem seems to indicate that DP is a good approach to solving this problem and this is indeed the case.\\n\\n### **First Attempt**\\n\\nYou might try to solve this by building up from the beginning of the maze and trying to find out the minimal health required along the way. The problem is that we cannot make a locally optimal choice in this way because which path we depends on how much health we will need in the future! This brings us to an important observation: we can solve the problem if we build the solution in reverse.\\n\\n### **Solution**\\n\\n* Let `M` denote the number of rows.\\n* Let `N` denote the number of columns.\\n* Let `dp` denote an `M` by `N` 2D list.\\n\\n##### **Princess cell**\\n\\nFor each cell in `dp` we want to know what is the minimal health we need in that cell to survive. If we look at just the subproblem of just the last square we see that we can determine how much health we need with the following choice:\\n* if `dungeon[M-1][N-1] < 0` then `1 - dungeon[M-1][N-1]` is the amount of health we need to survive.\\n* if `dungeon[M-1][N-1] >= 0` then `1` is the amount of health we need to survive.\\n\\nThis brings us to the first step: `dp[M-1][N-1] = max(1, 1 - dungeon[M-1][N-1])`\\n\\n##### **Last row and column**\\n\\nFor the subproblem of just the Mth row we can build the minimum health required to survive by working in reverse. Starting with index `i = M-2` and working backward to index `i = 0` we have the following choices to make:\\n* if `dp[i+1][N-1] - dungeon[i][N-1] < 0` then we have enough health to survive and could use the minimal amount.\\n* if `dp[i+1][N-1] - dungeon[i][N-1] >= 0` then we need more health to survive and calculate how much we were short by.\\n\\nThis gives us our row iteration: `dp[i][N - 1] = max(1, dp[i + 1][N - 1] - dungeon[i][N - 1])`\\n\\nSimilar steps to the row logic give use our column iteration: `dp[M - 1][j] = max(1, dp[M - 1][j + 1] - dungeon[M - 1][j])`\\n\\n##### **All other cells**\\n\\nFinally, now that we\\'ve figure out the cells where there isn\\'t a choice in path, we start to look at the cells where there is and come up with a way to decide how much health we will need if we start at those cells. For a given cell `dp[i][j]` we need to do the following:\\n1. Determine which of the cells to the bottom (`dp[i + 1][j]`) or to the right (`dp[i][j + 1]`) requires the least amount of health when entered.\\n2. Subtract the current cell\\'s damage value (`dungeon[i][j]`) from the minimal value in step 1 to determine how much health we need to have to survive.\\n3. Set the health to 1 if the value in step 3 is less than 1 because we know 1 health is sufficient.\\n\\nThese steps can be written as:\\n\\n```\\nhealth_required = min(dp[i + 1][j], dp[i][j + 1])\\nhealth_required -= dungeon[i][j]\\ndp[i][j] = max(1, health_required)\\n```\\n\\nCombining these steps gives us our final step: `dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])`\\n\\n### **Code**\\n\\nCombining the steps we just derived we get the DP solution below. If you have any questions or suggestions for improvements please comment below!\\n\\n```\\ndef calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n    M = len(dungeon)\\n    if M == 0:\\n        return 0\\n    N = len(dungeon[0])\\n    if N == 0:\\n        return 0\\n    dp = [[0 for _ in row] for row in dungeon]\\n    # Set health for last cell\\n    dp[M - 1][N - 1] = max(1, 1 - dungeon[M - 1][N - 1])\\n    # There\\'s no choice for health on the Mth row and Nth column\\n    for i in reversed(range(0, M - 1)):\\n        dp[i][N - 1] = max(1, dp[i + 1][N - 1] - dungeon[i][N - 1])\\n    for j in reversed(range(0, N - 1)):\\n        dp[M - 1][j] = max(1, dp[M - 1][j + 1] - dungeon[M - 1][j])\\n    # Our goal is to minimize the health required, but clamp this value by the smallest health value\\n    for i in reversed(range(M - 1)):\\n        for j in reversed(range(N - 1)):\\n            dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])\\n    return dp[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\nhealth_required = min(dp[i + 1][j], dp[i][j + 1])\\nhealth_required -= dungeon[i][j]\\ndp[i][j] = max(1, health_required)\\n```\n```\\ndef calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n    M = len(dungeon)\\n    if M == 0:\\n        return 0\\n    N = len(dungeon[0])\\n    if N == 0:\\n        return 0\\n    dp = [[0 for _ in row] for row in dungeon]\\n    # Set health for last cell\\n    dp[M - 1][N - 1] = max(1, 1 - dungeon[M - 1][N - 1])\\n    # There\\'s no choice for health on the Mth row and Nth column\\n    for i in reversed(range(0, M - 1)):\\n        dp[i][N - 1] = max(1, dp[i + 1][N - 1] - dungeon[i][N - 1])\\n    for j in reversed(range(0, N - 1)):\\n        dp[M - 1][j] = max(1, dp[M - 1][j + 1] - dungeon[M - 1][j])\\n    # Our goal is to minimize the health required, but clamp this value by the smallest health value\\n    for i in reversed(range(M - 1)):\\n        for j in reversed(range(N - 1)):\\n            dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])\\n    return dp[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 698212,
                "title": "java-binary-search-on-answer-and-check-if-true",
                "content": "We can binary search on answer in `O(log K)` where K is maximum possible value\\nTo check we need `O(n m)` time.\\nOverall `O(n m log k)`\\n\\n```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int left = 1;\\n        int right = Integer.MAX_VALUE;\\n        \\n        while (left < right) {\\n            int middle = left + ((right - left) >> 1);\\n            \\n            if (isReachable(dungeon, middle)) {\\n                right = middle;\\n            } else {\\n                left = middle + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private boolean isReachable(int[][] dungeon, int initialValue) {\\n        int n = dungeon.length;\\n        int m = dungeon[0].length;\\n        int[][] matrix = new int[n][m];\\n        matrix[0][0] = dungeon[0][0] + initialValue;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (i == 0 && j == 0) {\\n                    matrix[0][0] = dungeon[0][0] + initialValue;\\n                    continue;\\n                }\\n                \\n                if (j > 0 && matrix[i][j - 1] > 0) {\\n                    matrix[i][j] = Math.max(matrix[i][j], matrix[i][j - 1] + dungeon[i][j]);\\n                }\\n                \\n                if (i > 0 && matrix[i - 1][j] > 0) {\\n                    matrix[i][j] = Math.max(matrix[i][j], matrix[i - 1][j] + dungeon[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return matrix[n - 1][m - 1] > 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int left = 1;\\n        int right = Integer.MAX_VALUE;\\n        \\n        while (left < right) {\\n            int middle = left + ((right - left) >> 1);\\n            \\n            if (isReachable(dungeon, middle)) {\\n                right = middle;\\n            } else {\\n                left = middle + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private boolean isReachable(int[][] dungeon, int initialValue) {\\n        int n = dungeon.length;\\n        int m = dungeon[0].length;\\n        int[][] matrix = new int[n][m];\\n        matrix[0][0] = dungeon[0][0] + initialValue;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (i == 0 && j == 0) {\\n                    matrix[0][0] = dungeon[0][0] + initialValue;\\n                    continue;\\n                }\\n                \\n                if (j > 0 && matrix[i][j - 1] > 0) {\\n                    matrix[i][j] = Math.max(matrix[i][j], matrix[i][j - 1] + dungeon[i][j]);\\n                }\\n                \\n                if (i > 0 && matrix[i - 1][j] > 0) {\\n                    matrix[i][j] = Math.max(matrix[i][j], matrix[i - 1][j] + dungeon[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return matrix[n - 1][m - 1] > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537454,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    int m, n;\\npublic:\\n    bool savePricess(vector<vector<int>> d, int health) {\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int prev = -1;\\n                if (i == 0 && j == 0) {\\n                    d[i][j] += health;\\n                    continue;\\n                } else if (i == 0) {\\n                    prev = d[i][j-1];\\n                } else if (j == 0) {\\n                    prev = d[i-1][j];\\n                } else {\\n                    prev = max(d[i-1][j], d[i][j-1]);\\n                }\\n                if (prev <= 0) d[i][j] = -1;\\n                else d[i][j] += prev;\\n            }\\n        }\\n        return d[m-1][n-1] > 0;\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        m = dungeon.size(), n = dungeon[0].size();\\n        int lo = 1, hi = INT_MAX;\\n        while (lo < hi) {\\n            int mid = lo + (hi-lo)/2;\\n            if (savePricess(dungeon, mid)) {\\n                hi = mid;\\n            } else {\\n                lo = mid+1;\\n            }\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int m, n;\\npublic:\\n    bool savePricess(vector<vector<int>> d, int health) {\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int prev = -1;\\n                if (i == 0 && j == 0) {\\n                    d[i][j] += health;\\n                    continue;\\n                } else if (i == 0) {\\n                    prev = d[i][j-1];\\n                } else if (j == 0) {\\n                    prev = d[i-1][j];\\n                } else {\\n                    prev = max(d[i-1][j], d[i][j-1]);\\n                }\\n                if (prev <= 0) d[i][j] = -1;\\n                else d[i][j] += prev;\\n            }\\n        }\\n        return d[m-1][n-1] > 0;\\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        m = dungeon.size(), n = dungeon[0].size();\\n        int lo = 1, hi = INT_MAX;\\n        while (lo < hi) {\\n            int mid = lo + (hi-lo)/2;\\n            if (savePricess(dungeon, mid)) {\\n                hi = mid;\\n            } else {\\n                lo = mid+1;\\n            }\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517679,
                "title": "java-memozied-beats-100-0ms-contains-tabulated-approach-as-well",
                "content": "The Memoized Approach took 0 ms and beat 100%. The Tabulated approach took 2ms.\\nUncomment to run bottom up approach \\n```\\n\\nclass Solution \\n{\\n    \\n    \\n    //Top Down - Memoized\\n    \\n    int[][] dp; int rows, cols;\\n    public int calculateMinimumHP(int[][] A)\\n    {\\n        rows = A.length; cols = A[0].length;\\n        dp = new int[rows][cols];\\n        \\n        calculateMinimumHPHelper(A, 0, 0);\\n        return dp[0][0];\\n    }\\n    \\n    public int calculateMinimumHPHelper(int[][] A, int i, int j)\\n    {\\n        if(i >= rows || j >= cols)\\n            return Integer.MAX_VALUE;\\n       \\n        if(dp[i][j] > 0)\\n            return dp[i][j];\\n            \\n        int leftPath = calculateMinimumHPHelper(A, i, j+ 1);\\n        int rightPath = calculateMinimumHPHelper(A, i + 1, j);\\n        \\n        \\n        // Handling the only case which is the right bottom seperately.\\n        if(leftPath == Integer.MAX_VALUE && rightPath == Integer.MAX_VALUE)\\n        {\\n            dp[i][j] = A[i][j] > 0 ? 1 : Math.abs(A[i][j]) + 1;\\n            return dp[i][j];\\n        }\\n            \\n        int bestPath = Math.min(leftPath, rightPath);\\n        \\n        if(A[i][j] > 0)\\n            dp[i][j] = Math.max(bestPath - A[i][j], 1);\\n            \\n        else\\n            dp[i][j] = Math.abs(A[i][j]) + bestPath;\\n        \\n        return dp[i][j];\\n    }\\n   \\n    \\n    \\n    \\n    /*\\n    //Bottom Up - Tabulated\\n    public int calculateMinimumHP(int[][] A)\\n    {\\n        int rows = A.length - 1, cols = A[0].length - 1;\\n        int[][] dp = new int[rows + 1][cols + 1];\\n\\n        dp[rows][cols] = A[rows][cols] >= 0 ? 1 :  Math.abs(A[rows][cols]) + 1;\\n\\n        for(int i = rows - 1; i >= 0; i--)\\n        {\\n            if(dp[i + 1][cols] > A[i][cols])\\n                dp[i][cols] = dp[i+1][cols]- A[i][cols];\\n\\n            else\\n                dp[i][cols] = 1;\\n        }\\n\\n        for(int j = cols - 1; j >= 0; j--)\\n        {\\n            if(dp[rows][j + 1] > A[rows][j])\\n                dp[rows][j] = dp[rows][j + 1] - A[rows][j];\\n\\n            else\\n                dp[rows][j] = 1;\\n        }\\n        \\n\\n        for(int i = rows - 1; i >= 0; i--)\\n        {\\n            for(int j = cols - 1; j >= 0; j--)\\n            {\\n                if( A[i][j] < 0)\\n                    dp[i][j] = Math.abs(A[i][j]) + Math.min(dp[i+1][j], dp[i][j+1]);\\n\\n                else if(Math.min(dp[i+1][j], dp[i][j+1]) > A[i][j])\\n                    dp[i][j] = Math.min(dp[i+1][j], dp[i][j+1]) - A[i][j];\\n                    \\n                else\\n                    dp[i][j] = 1;\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n    */\\n    \\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution \\n{\\n    \\n    \\n    //Top Down - Memoized\\n    \\n    int[][] dp; int rows, cols;\\n    public int calculateMinimumHP(int[][] A)\\n    {\\n        rows = A.length; cols = A[0].length;\\n        dp = new int[rows][cols];\\n        \\n        calculateMinimumHPHelper(A, 0, 0);\\n        return dp[0][0];\\n    }\\n    \\n    public int calculateMinimumHPHelper(int[][] A, int i, int j)\\n    {\\n        if(i >= rows || j >= cols)\\n            return Integer.MAX_VALUE;\\n       \\n        if(dp[i][j] > 0)\\n            return dp[i][j];\\n            \\n        int leftPath = calculateMinimumHPHelper(A, i, j+ 1);\\n        int rightPath = calculateMinimumHPHelper(A, i + 1, j);\\n        \\n        \\n        // Handling the only case which is the right bottom seperately.\\n        if(leftPath == Integer.MAX_VALUE && rightPath == Integer.MAX_VALUE)\\n        {\\n            dp[i][j] = A[i][j] > 0 ? 1 : Math.abs(A[i][j]) + 1;\\n            return dp[i][j];\\n        }\\n            \\n        int bestPath = Math.min(leftPath, rightPath);\\n        \\n        if(A[i][j] > 0)\\n            dp[i][j] = Math.max(bestPath - A[i][j], 1);\\n            \\n        else\\n            dp[i][j] = Math.abs(A[i][j]) + bestPath;\\n        \\n        return dp[i][j];\\n    }\\n   \\n    \\n    \\n    \\n    /*\\n    //Bottom Up - Tabulated\\n    public int calculateMinimumHP(int[][] A)\\n    {\\n        int rows = A.length - 1, cols = A[0].length - 1;\\n        int[][] dp = new int[rows + 1][cols + 1];\\n\\n        dp[rows][cols] = A[rows][cols] >= 0 ? 1 :  Math.abs(A[rows][cols]) + 1;\\n\\n        for(int i = rows - 1; i >= 0; i--)\\n        {\\n            if(dp[i + 1][cols] > A[i][cols])\\n                dp[i][cols] = dp[i+1][cols]- A[i][cols];\\n\\n            else\\n                dp[i][cols] = 1;\\n        }\\n\\n        for(int j = cols - 1; j >= 0; j--)\\n        {\\n            if(dp[rows][j + 1] > A[rows][j])\\n                dp[rows][j] = dp[rows][j + 1] - A[rows][j];\\n\\n            else\\n                dp[rows][j] = 1;\\n        }\\n        \\n\\n        for(int i = rows - 1; i >= 0; i--)\\n        {\\n            for(int j = cols - 1; j >= 0; j--)\\n            {\\n                if( A[i][j] < 0)\\n                    dp[i][j] = Math.abs(A[i][j]) + Math.min(dp[i+1][j], dp[i][j+1]);\\n\\n                else if(Math.min(dp[i+1][j], dp[i][j+1]) > A[i][j])\\n                    dp[i][j] = Math.min(dp[i+1][j], dp[i][j+1]) - A[i][j];\\n                    \\n                else\\n                    dp[i][j] = 1;\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n    */\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491281,
                "title": "short-java-dp-bottom-up-solution-beat-95",
                "content": "To build a dynamic programming solution need to take care two important things,\\n* The init values for each state, in this solution, set all start state values to MAX_VALUE, only set the target one to 1, because the state values should not less or equal to zero. \\n* The state transfer function, i.e, tranfer from last state to current state, and the state transfer function can conclude from examples. Below is the example, note that caculate from bottom to up and right to left, the value in () are state values. (M) stands for MAX_VALUE\\n\\n-2 (7)  -3 (5)    3 (2)\\n-5 (6) -10 (11) 1 (5)\\n10 (1)  30 (1)  -5 (6)\\n. (M)    . (M)        . (1)  . (M)\\n\\nThe caculation could have two steps, \\n* Minium target value, t = min(dp[i], dp[i+1]), which is the opptimize the better path and select the requires lesser starting life\\n* Update current dp[i] value based on t and current cell value num, as requires dp[i] + num >= t, and also requires dp[i] >= 1, so setting the state transfer function to max(1, t-num)\\n\\nWrite out to code implementation. \\n\\nThe time complexity is O(n*m), which n is the length of colum and m is the width of the row. \\n\\n```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if(dungeon==null || dungeon.length==0 || dungeon[0]==null || dungeon[0].length==0) return 0;\\n        \\n        int n = dungeon[0].length;\\n        int dp[] = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[n-1] = 1;\\n        \\n        for(int row=dungeon.length-1; row>=0; row--) {\\n            for(int col=n-1; col>=0; col--) {\\n                int t = Math.min(dp[col], dp[col+1]);\\n                dp[col] = Math.max(1, t - dungeon[row][col]);\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if(dungeon==null || dungeon.length==0 || dungeon[0]==null || dungeon[0].length==0) return 0;\\n        \\n        int n = dungeon[0].length;\\n        int dp[] = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[n-1] = 1;\\n        \\n        for(int row=dungeon.length-1; row>=0; row--) {\\n            for(int col=n-1; col>=0; col--) {\\n                int t = Math.min(dp[col], dp[col+1]);\\n                dp[col] = Math.max(1, t - dungeon[row][col]);\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464519,
                "title": "c-solution-time-98-with-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/dungeon-game/submissions/\\n*/\\n\\nclass Solution {\\npublic:\\n    /*\\n        Since the objective is to find the min val such that\\n        path never sees a negative value, so if we start from top,\\n        we can\\'t guarantee of finding a value which is min such that -ve\\n        never happens, at most we can a +ve val that can make that possible\\n        So we start from the destination cell and go towards the start.\\n        For each cell we find the min value that is needed if we have to reach the destination\\n        from that cell. Also each cell contribute to its right and down cells.\\n        So that value is simply the min value req to make \\n        dungeon(i, j) + min(dungeon(i,j+1), dungeon(i+1, j)) = +ve\\n        Since we start from destination cell we can have an initial value for the health, \\n        which is 1 in best case scenario. \\n    */\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if(dungeon.empty())\\n            return 0;\\n        \\n        const int M = dungeon.size(), N = dungeon.front().size();\\n        vector<vector<int>> dp(M, vector<int>(N, INT_MAX));\\n        \\n        for(int i = M - 1; i >= 0; i--) {\\n            for(int j = N - 1; j >= 0; j--) {\\n                // if current dungeon value is +ve then, then below becomes negative so we can take\\n                // 1(min value for survival), if current dungeon val is negative then we calculate \\n                // the additional value req for current cell on top of min health for the contributing cells.\\n                if(i == M - 1 && j == N - 1)\\n                    dp[i][j] = max(1, 1 - dungeon[i][j]);\\n                else if(i == M - 1) // last row, each cell can allow movement towards right\\n                    dp[i][j] = max(1, dp[i][j+1] - dungeon[i][j]);\\n                else if(j == N - 1) // last column, each cell can allow movement towards bottom\\n                    dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j]);\\n                else    // select the cell in left or right which requires least value \\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    https://leetcode.com/problems/dungeon-game/submissions/\\n*/\\n\\nclass Solution {\\npublic:\\n    /*\\n        Since the objective is to find the min val such that\\n        path never sees a negative value, so if we start from top,\\n        we can\\'t guarantee of finding a value which is min such that -ve\\n        never happens, at most we can a +ve val that can make that possible\\n        So we start from the destination cell and go towards the start.\\n        For each cell we find the min value that is needed if we have to reach the destination\\n        from that cell. Also each cell contribute to its right and down cells.\\n        So that value is simply the min value req to make \\n        dungeon(i, j) + min(dungeon(i,j+1), dungeon(i+1, j)) = +ve\\n        Since we start from destination cell we can have an initial value for the health, \\n        which is 1 in best case scenario. \\n    */\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if(dungeon.empty())\\n            return 0;\\n        \\n        const int M = dungeon.size(), N = dungeon.front().size();\\n        vector<vector<int>> dp(M, vector<int>(N, INT_MAX));\\n        \\n        for(int i = M - 1; i >= 0; i--) {\\n            for(int j = N - 1; j >= 0; j--) {\\n                // if current dungeon value is +ve then, then below becomes negative so we can take\\n                // 1(min value for survival), if current dungeon val is negative then we calculate \\n                // the additional value req for current cell on top of min health for the contributing cells.\\n                if(i == M - 1 && j == N - 1)\\n                    dp[i][j] = max(1, 1 - dungeon[i][j]);\\n                else if(i == M - 1) // last row, each cell can allow movement towards right\\n                    dp[i][j] = max(1, dp[i][j+1] - dungeon[i][j]);\\n                else if(j == N - 1) // last column, each cell can allow movement towards bottom\\n                    dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j]);\\n                else    // select the cell in left or right which requires least value \\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321561,
                "title": "java-memorization",
                "content": "Suck at sloving this problem. Just rewrite into recursion from [this DP answer](https://leetcode.com/problems/dungeon-game/discuss/52859/Simple-Java-DP-code.) :P\\n\\n```java\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        // boundary check\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) return 0;\\n\\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        // init cache\\n        int[][] cache = new int[m + 1][n + 1];\\n        return dfs(0, 0, dungeon, cache);\\n    }\\n    \\n    public static int dfs(int m, int n, int[][] dungeon, int[][] cache) {\\n        if (m == dungeon.length - 1 && n > dungeon[0].length - 1) return 1;\\n        if (m > dungeon.length - 1 && n == dungeon[0].length - 1) return 1;\\n        if (m > dungeon.length - 1 || n > dungeon[0].length - 1) return Integer.MAX_VALUE;\\n        if (cache[m][n] == 0) {\\n            int minHP = Math.min(dfs(m + 1, n, dungeon, cache), dfs(m, n + 1, dungeon, cache)) - dungeon[m][n];\\n            cache[m][n] = (minHP <= 0) ? 1 : minHP;\\n        }\\n        return cache[m][n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        // boundary check\\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) return 0;\\n\\n        int m = dungeon.length;\\n        int n = dungeon[0].length;\\n        // init cache\\n        int[][] cache = new int[m + 1][n + 1];\\n        return dfs(0, 0, dungeon, cache);\\n    }\\n    \\n    public static int dfs(int m, int n, int[][] dungeon, int[][] cache) {\\n        if (m == dungeon.length - 1 && n > dungeon[0].length - 1) return 1;\\n        if (m > dungeon.length - 1 && n == dungeon[0].length - 1) return 1;\\n        if (m > dungeon.length - 1 || n > dungeon[0].length - 1) return Integer.MAX_VALUE;\\n        if (cache[m][n] == 0) {\\n            int minHP = Math.min(dfs(m + 1, n, dungeon, cache), dfs(m, n + 1, dungeon, cache)) - dungeon[m][n];\\n            cache[m][n] = (minHP <= 0) ? 1 : minHP;\\n        }\\n        return cache[m][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52785,
                "title": "dfs-cache-beat-98-8-including-transfer-to-dp-space-optimize",
                "content": "DFS+Cache:\\n```\\npublic class Solution {\\n    int[][] cache;\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        cache = new int[dungeon.length][dungeon[0].length];\\n        int ret = search(dungeon, 0, 0);\\n        return ret > 0 ? 1 : -ret + 1;\\n    }\\n    private int search(int[][] matrix, int x, int y) {\\n        if (x == matrix.length - 1 && y == matrix[0].length - 1) return matrix[x][y] > 0 ? 0 : matrix[x][y];\\n        if (x < 0 || y < 0 || x >= matrix.length || y >= matrix[0].length) return Integer.MIN_VALUE;\\n        if (cache[x][y] != 0) return cache[x][y] == -1 ? 0 : cache[x][y];\\n        \\n        int left = search(matrix, x + 1, y);\\n        int right = search(matrix, x, y + 1);\\n        int cur = matrix[x][y] + Math.max(left, right);\\n        \\n        cache[x][y] = cur > 0 ? -1 : cur;\\n        return cur > 0 ? 0 : cur;\\n    }\\n}\\n```\\nDP:\\n```\\npublic class Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int row = dungeon.length, col = dungeon[0].length;\\n        int[][] F = new int[row][col];\\n        for (int i = row - 1; i >= 0; i--) {\\n            for (int j = col - 1; j >= 0; j--) {\\n                if (i == row - 1 && j == col - 1) F[i][j] = dungeon[i][j] > 0 ? 0 : dungeon[i][j];\\n                else {\\n                    int left = i + 1 >= row ? Integer.MIN_VALUE : F[i + 1][j];\\n                    int right = j + 1 >= col ? Integer.MIN_VALUE : F[i][j + 1];\\n                    int cur = dungeon[i][j] + Math.max(left, right);\\n                    F[i][j] = cur > 0 ? 0 : cur;\\n                }\\n            }\\n        }\\n        return F[0][0] > 0 ? 1 : -F[0][0] + 1;\\n    }\\n}\\n```\\nSpace optimize to O(n):\\n```\\npublic class Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int row = dungeon.length, col = dungeon[0].length;\\n        int[][] F = new int[2][col];\\n        for (int i = row - 1; i >= 0; i--) {\\n            for (int j = col - 1; j >= 0; j--) {\\n                if (i == row - 1 && j == col - 1) F[i % 2][j] = dungeon[i][j] > 0 ? 0 : dungeon[i][j];\\n                else {\\n                    int left = i + 1 >= row ? Integer.MIN_VALUE : F[(i + 1) % 2][j];\\n                    int right = j + 1 >= col ? Integer.MIN_VALUE : F[i % 2][j + 1];\\n                    int cur = dungeon[i][j] + Math.max(left, right);\\n                    F[i % 2][j] = cur > 0 ? 0 : cur;\\n                }\\n            }\\n        }\\n        return F[0][0] > 0 ? 1 : -F[0][0] + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int[][] cache;\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        cache = new int[dungeon.length][dungeon[0].length];\\n        int ret = search(dungeon, 0, 0);\\n        return ret > 0 ? 1 : -ret + 1;\\n    }\\n    private int search(int[][] matrix, int x, int y) {\\n        if (x == matrix.length - 1 && y == matrix[0].length - 1) return matrix[x][y] > 0 ? 0 : matrix[x][y];\\n        if (x < 0 || y < 0 || x >= matrix.length || y >= matrix[0].length) return Integer.MIN_VALUE;\\n        if (cache[x][y] != 0) return cache[x][y] == -1 ? 0 : cache[x][y];\\n        \\n        int left = search(matrix, x + 1, y);\\n        int right = search(matrix, x, y + 1);\\n        int cur = matrix[x][y] + Math.max(left, right);\\n        \\n        cache[x][y] = cur > 0 ? -1 : cur;\\n        return cur > 0 ? 0 : cur;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int row = dungeon.length, col = dungeon[0].length;\\n        int[][] F = new int[row][col];\\n        for (int i = row - 1; i >= 0; i--) {\\n            for (int j = col - 1; j >= 0; j--) {\\n                if (i == row - 1 && j == col - 1) F[i][j] = dungeon[i][j] > 0 ? 0 : dungeon[i][j];\\n                else {\\n                    int left = i + 1 >= row ? Integer.MIN_VALUE : F[i + 1][j];\\n                    int right = j + 1 >= col ? Integer.MIN_VALUE : F[i][j + 1];\\n                    int cur = dungeon[i][j] + Math.max(left, right);\\n                    F[i][j] = cur > 0 ? 0 : cur;\\n                }\\n            }\\n        }\\n        return F[0][0] > 0 ? 1 : -F[0][0] + 1;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int row = dungeon.length, col = dungeon[0].length;\\n        int[][] F = new int[2][col];\\n        for (int i = row - 1; i >= 0; i--) {\\n            for (int j = col - 1; j >= 0; j--) {\\n                if (i == row - 1 && j == col - 1) F[i % 2][j] = dungeon[i][j] > 0 ? 0 : dungeon[i][j];\\n                else {\\n                    int left = i + 1 >= row ? Integer.MIN_VALUE : F[(i + 1) % 2][j];\\n                    int right = j + 1 >= col ? Integer.MIN_VALUE : F[i % 2][j + 1];\\n                    int cur = dungeon[i][j] + Math.max(left, right);\\n                    F[i % 2][j] = cur > 0 ? 0 : cur;\\n                }\\n            }\\n        }\\n        return F[0][0] > 0 ? 1 : -F[0][0] + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52839,
                "title": "my-short-c-solution",
                "content": "It is a typical DP question. The only trick is that we need to do search from the bottom right to the top left corner. The reason is that: if we do search in a normal top-left to bottom-right way, then at a middle point (i,j), we can not do local \"greedy\" decision (i.e. only keep the local optimal path and discard all the other paths) since there are two metrics here: one is the minimum points needed to reach the current point from the top-left corner and the other is the current left points that can be used for future move. We have to consider both to define \"optimal path\". However, if we do search in a reverse order, we only need to consider only one metric, which is the minimum points needed at (i,j) that enables us to move to the destination. We don't care how many points left at (i,j) when it moves from the top-left point, >=1 is enough. \\nThe recursion relationship is dp[i][j] = max(1, min(dp[i-1][j], dp[i][j+1]) - dungeon[i][j]) (here max(1,) is to guarantee that at least 1 point left when entering into [i][j]). Since dp[i][j] is only related to dp[i-1][j] and dp[i][j+1], so we can reduce dp to a one-dimensional array and do the recursion in a reverse order.\\n\\n    class Solution {\\n    public:\\n        int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n            int row = dungeon.size(), col= dungeon[0].size(),  i, j;\\n            vector<int> dp(col+1,INT_MAX);\\n    \\n            for(i=row-1, dp[col-1] = 1; i>=0;--i)\\n            for(j=col-1; j>=0; --j)\\n                dp[j] = max(1, min(dp[j], dp[j+1]) - dungeon[i][j]);\\n            \\n            return dp[0];    \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n            int row = dungeon.size(), col= dungeon[0].size(),  i, j;\\n            vector<int> dp(col+1,INT_MAX);\\n    \\n            for(i=row-1, dp[col-1] = 1; i>=0;--i)\\n            for(j=col-1; j>=0; --j)\\n                dp[j] = max(1, min(dp[j], dp[j+1]) - dungeon[i][j]);\\n            \\n            return dp[0];    \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 52850,
                "title": "ac-solution-code",
                "content": "**Solutino1. Bottom-Up DP - Runtime = O(nm); Space = O(nm)**\\n\\n    Iterate from last row to first row:\\n    2-D table for the minimum DP.\\n    h[i][j] is the minimum helth to enter (i, j) \\n    h[0][0] is the anwser.\\t\\n\\n**JAVA Code:**\\n\\n    public int calculateMinimumHP(int[][] A) {\\n    \\tint n = A.length, m = A[0].length;\\n    \\tint dp[][] = new int[n][m];// dp[i][j]: minimum hp to enter (i, j) \\n    \\t\\n    \\tdp[n-1][m-1] = Math.max(-A[n-1][m-1], 0) + 1;// right-bottom node    \\t\\n    \\tfor (int i = n - 2; i >= 0; i--) // last row\\n    \\t\\tdp[i][m-1] = Math.max(1, dp[i+1][m-1] - A[i][m-1]);    \\t\\n    \\tfor (int j = m - 2; j >= 0; j--) // last column\\n    \\t\\tdp[n-1][j] = Math.max(1, dp[n-1][j+1] - A[n-1][j]);\\n    \\t\\n    \\tfor (int i = n - 2; i >= 0; i--) {// calculate dp table\\n    \\t\\tfor (int j = m - 2; j >= 0; j--) {\\n    \\t\\t\\tdp[i][j] = Math.min(dp[i][j+1], dp[i+1][j]);// right, down\\n    \\t\\t\\tdp[i][j] = Math.max(1, dp[i][j] - A[i][j]);\\n    \\t\\t}\\n    \\t}     \\t\\n        return dp[0][0];\\n    }\\n\\n**Solution2. Memorized DFS**\\n\\nRegular DFS without memorization will cause TLE error.\\n \\n    public int calculateMinimumHP(int[][] A) {\\n    \\tint maxDamages[][] = new int[A.length][A[0].length];// KEY optimization: Memorization for the previous results\\n    \\tfor (int i = 0; i < A.length; i++) Arrays.fill(maxDamages[i], Integer.MAX_VALUE);\\n    \\t\\n    \\tint maxDamage = DFS(A, 0, 0, maxDamages);\\n        return Math.max(0, -maxDamage) + 1;\\n    }\\n    \\n    int DFS(int[][] A, int i, int j, int maxDamages[][]) {// Total damage for one path\\n    \\tif (i > A.length - 1 || j > A[0].length - 1) return Integer.MIN_VALUE;    \\t\\n    \\tif (maxDamages[i][j] != Integer.MAX_VALUE) return maxDamages[i][j];// **Return the memorized result, to avoid duplicated DFS\\n    \\t\\n    \\tint maxDamage;\\n    \\tif (i == A.length - 1 && j == A[0].length - 1) {// Right-bottom node \\t\\n    \\t\\tmaxDamage = A[i][j];\\n    \\t} else {\\n    \\t\\tint right = DFS(A, i, j+1, maxDamages);\\n    \\t\\tint down =  DFS(A, i+1, j, maxDamages);    \\t\\n    \\t\\tmaxDamage = Math.max(right, down) + A[i][j];// Choose the path with less damage: rightward, downward\\n    \\t}\\t\\t\\n    \\tmaxDamages[i][j] = Math.min(0, maxDamage);\\t\\t\\t\\n    \\treturn maxDamages[i][j];\\n    }",
                "solutionTags": [],
                "code": "**Solutino1. Bottom-Up DP - Runtime = O(nm); Space = O(nm)**\\n\\n    Iterate from last row to first row:\\n    2-D table for the minimum DP.\\n    h[i][j] is the minimum helth to enter (i, j) \\n    h[0][0] is the anwser.\\t\\n\\n**JAVA Code:**\\n\\n    public int calculateMinimumHP(int[][] A) {\\n    \\tint n = A.length, m = A[0].length;\\n    \\tint dp[][] = new int[n][m];// dp[i][j]: minimum hp to enter (i, j) \\n    \\t\\n    \\tdp[n-1][m-1] = Math.max(-A[n-1][m-1], 0) + 1;// right-bottom node    \\t\\n    \\tfor (int i = n - 2; i >= 0; i--) // last row\\n    \\t\\tdp[i][m-1] = Math.max(1, dp[i+1][m-1] - A[i][m-1]);    \\t\\n    \\tfor (int j = m - 2; j >= 0; j--) // last column\\n    \\t\\tdp[n-1][j] = Math.max(1, dp[n-1][j+1] - A[n-1][j]);\\n    \\t\\n    \\tfor (int i = n - 2; i >= 0; i--) {// calculate dp table\\n    \\t\\tfor (int j = m - 2; j >= 0; j--) {\\n    \\t\\t\\tdp[i][j] = Math.min(dp[i][j+1], dp[i+1][j]);// right, down\\n    \\t\\t\\tdp[i][j] = Math.max(1, dp[i][j] - A[i][j]);\\n    \\t\\t}\\n    \\t}     \\t\\n        return dp[0][0];\\n    }\\n\\n**Solution2. Memorized DFS**\\n\\nRegular DFS without memorization will cause TLE error.\\n \\n    public int calculateMinimumHP(int[][] A) {\\n    \\tint maxDamages[][] = new int[A.length][A[0].length];// KEY optimization: Memorization for the previous results\\n    \\tfor (int i = 0; i < A.length; i++) Arrays.fill(maxDamages[i], Integer.MAX_VALUE);\\n    \\t\\n    \\tint maxDamage = DFS(A, 0, 0, maxDamages);\\n        return Math.max(0, -maxDamage) + 1;\\n    }\\n    \\n    int DFS(int[][] A, int i, int j, int maxDamages[][]) {// Total damage for one path\\n    \\tif (i > A.length - 1 || j > A[0].length - 1) return Integer.MIN_VALUE;    \\t\\n    \\tif (maxDamages[i][j] != Integer.MAX_VALUE) return maxDamages[i][j];// **Return the memorized result, to avoid duplicated DFS\\n    \\t\\n    \\tint maxDamage;\\n    \\tif (i == A.length - 1 && j == A[0].length - 1) {// Right-bottom node \\t\\n    \\t\\tmaxDamage = A[i][j];\\n    \\t} else {\\n    \\t\\tint right = DFS(A, i, j+1, maxDamages);\\n    \\t\\tint down =  DFS(A, i+1, j, maxDamages);    \\t\\n    \\t\\tmaxDamage = Math.max(right, down) + A[i][j];// Choose the path with less damage: rightward, downward\\n    \\t}\\t\\t\\n    \\tmaxDamages[i][j] = Math.min(0, maxDamage);\\t\\t\\t\\n    \\treturn maxDamages[i][j];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52855,
                "title": "java-dp-solution-3ms",
                "content": "    public class Solution {\\n    public int calculateMinimumHP(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[m-1][n-1] = Math.max(1 - grid[m-1][n-1], 1);\\n        //fill out the last row\\n        for(int j = n-2; j >= 0; j--) {\\n            dp[m-1][j] = Math.max(dp[m-1][j+1] - grid[m-1][j], 1);\\n        }\\n        //fill out the last column\\n        for(int i = m-2; i >= 0; i--) {\\n            dp[i][n-1] = Math.max(dp[i+1][n-1] - grid[i][n-1], 1);\\n        }\\n        //fill out the rest of the dp\\n        for(int i = m-2; i >= 0; i--) {\\n            for(int j = n-2; j >= 0; j--) {\\n                int next = Math.min(dp[i+1][j], dp[i][j+1]);\\n                dp[i][j] = Math.max(next - grid[i][j], 1);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int calculateMinimumHP(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[m-1][n-1] = Math.max(1 - grid[m-1][n-1], 1);\\n        //fill out the last row\\n        for(int j = n-2; j >= 0; j--) {\\n            dp[m-1][j] = Math.max(dp[m-1][j+1] - grid[m-1][j], 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 52865,
                "title": "simple-c-solution-with-o-1-space-complexity",
                "content": "    class Solution {\\n    public:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n\\t\\tint m = dungeon.size() - 1;\\n\\t\\tint n = dungeon[0].size() - 1;\\n\\n\\t\\tdungeon[m][n] = dungeon[m][n]>0 ? 0 : dungeon[m][n];\\n\\n\\t\\tfor (int i = m; i >= 0; i--) {\\n\\t\\t\\tfor (int j = n; j >= 0; j--) {\\n\\t\\t\\t\\tif (i < m && j < n)\\n\\t\\t\\t\\t\\tdungeon[i][j] = max(dungeon[i + 1][j], dungeon[i][j + 1]) + dungeon[i][j];\\n\\t\\t\\t\\telse if (i < m)\\n\\t\\t\\t\\t\\tdungeon[i][j] = dungeon[i + 1][j] + dungeon[i][j];\\n\\t\\t\\t\\telse if (j < n)\\n\\t\\t\\t\\t\\tdungeon[i][j] = dungeon[i][j + 1] + dungeon[i][j];\\n\\n\\t\\t\\t\\tdungeon[i][j] = dungeon[i][j] > 0 ? 0 : dungeon[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dungeon[0][0] > 0 ? 1 : abs(dungeon[0][0]) + 1;\\n\\t  }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n\\t\\tint m = dungeon.size() - 1;\\n\\t\\tint n = dungeon[0].size() - 1;\\n\\n\\t\\tdungeon[m][n] = dungeon[m][n]>0 ? 0 : dungeon[m][n];\\n\\n\\t\\tfor (int i = m; i >= 0; i--) {\\n\\t\\t\\tfor (int j = n; j >= 0; j--) {\\n\\t\\t\\t\\tif (i < m && j < n)\\n\\t\\t\\t\\t\\tdungeon[i][j] = max(dungeon[i + 1][j], dungeon[i][j + 1]) + dungeon[i][j];\\n\\t\\t\\t\\telse if (i < m)\\n\\t\\t\\t\\t\\tdungeon[i][j] = dungeon[i + 1][j] + dungeon[i][j];\\n\\t\\t\\t\\telse if (j < n)\\n\\t\\t\\t\\t\\tdungeon[i][j] = dungeon[i][j + 1] + dungeon[i][j];\\n\\n\\t\\t\\t\\tdungeon[i][j] = dungeon[i][j] > 0 ? 0 : dungeon[i][j];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3542962,
                "title": "memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int i , int j ,vector<vector<int>>& d,int n,int m,vector<vector<int>> &dp) {\\n       if(i>=n || j >=m)\\n           return INT_MAX;\\n        \\n        if(i==n-1 && j == m-1)\\n        {\\n            return dp[i][j] = ((d[i][j]>0) ? 1 : -d[i][j]+1);\\n        }\\n        \\n         \\n        if(dp[i][j]!=INT_MAX)\\n            return dp[i][j];\\n       \\n        \\n        int a  = solve(i+1,j,d,n,m,dp);\\n        int b  = solve(i,j+1,d,n,m,dp);\\n        \\n        int c = min(a,b) - d[i][j];\\n        return dp[i][j] = ((c>0)?c:1);\\n        \\n    }\\n    int calculateMinimumHP(vector<vector<int>>& d) {\\n        \\n        int n = d.size();\\n        int m = d[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,INT_MAX)); \\n        return solve(0,0,d,n,m,dp);\\n    }\\n};```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int i , int j ,vector<vector<int>>& d,int n,int m,vector<vector<int>> &dp) {\\n       if(i>=n || j >=m)\\n           return INT_MAX;\\n        \\n        if(i==n-1 && j == m-1)\\n        {\\n            return dp[i][j] = ((d[i][j]>0) ? 1 : -d[i][j]+1);\\n        }\\n        \\n         \\n        if(dp[i][j]!=INT_MAX)\\n            return dp[i][j];\\n       \\n        \\n        int a  = solve(i+1,j,d,n,m,dp);\\n        int b  = solve(i,j+1,d,n,m,dp);\\n        \\n        int c = min(a,b) - d[i][j];\\n        return dp[i][j] = ((c>0)?c:1);\\n        \\n    }\\n    int calculateMinimumHP(vector<vector<int>>& d) {\\n        \\n        int n = d.size();\\n        int m = d[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,INT_MAX)); \\n        return solve(0,0,d,n,m,dp);\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3393340,
                "title": "174-dungeon-game",
                "content": "- Time complexity:\\nO(mn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int row = dungeon.size(), col = dungeon[0].size();\\n        vector<int> HP(col + 1, 1e5);\\n        HP[col - 1] = HP[col] = 1;\\n        for(int i = row - 1; i >= 0; --i) {\\n            vector<int> temp(col + 1, 1e5);\\n            for(int j = col - 1; j >= 0; --j) {\\n                int minHP = -dungeon[i][j] + min(temp[j + 1], HP[j]);\\n                temp[j] = minHP <= 0 ? 1 : minHP;\\n            }\\n            HP = temp;\\n        }\\n        return HP[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int row = dungeon.size(), col = dungeon[0].size();\\n        vector<int> HP(col + 1, 1e5);\\n        HP[col - 1] = HP[col] = 1;\\n        for(int i = row - 1; i >= 0; --i) {\\n            vector<int> temp(col + 1, 1e5);\\n            for(int j = col - 1; j >= 0; --j) {\\n                int minHP = -dungeon[i][j] + min(temp[j + 1], HP[j]);\\n                temp[j] = minHP <= 0 ? 1 : minHP;\\n            }\\n            HP = temp;\\n        }\\n        return HP[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367443,
                "title": "a-try-to-explain-in-an-easy-way",
                "content": "So what is the Problem basically \\nUnderstand\\n\\nThere is  a King \\uD83E\\uDEC5 and his princess was kidnapped by a gang and the gang leader is at bottom right and king has to save him. During his journey he found two types of either they give boon i.e. health or they take bribe i.e. health.\\n\\nSo King has to think before start journey that how much life he had to hold before start the journey. Because in the journey if at any moment the life becomes 0 or becomes negative then the Gang leader would marry the Princess\\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31\\n\\nSo as a King he had to think of the journey and he can think like if he start from the life needed to fight with leader if suppose -5 life lose at leader so at that king needed minimum of 6 life  no matter it comes from upper block or following the left side block.\\nThis approach King has to follow recursively to all spots available.\\n\\nAs same if we consider the left block and if there is demon that would need -2 health so our total required at that block would be 6-(-2). and if instead of demon if there is healer so our health at that block would be 6-(2);\\nWe follow this for that particular row and column in which princess is there.\\n\\nBut for remaining matrix we have to first find from below and right block that which is giving minimum health and after that apply the same operation.\\nSo in this we start from the adjacent diagonal block of princess and after that traverse the whole remaining array.\\nAnd entry for that block would be max ( min(below block value,right block value) - dungeon diagonal block , 1);\\n\\nAnd At last we return the value at newMatrix[0][0];\\n\\nSo code is \\n\\nC++ Code\\n```\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n     \\n        int m=dungeon.size(),n=dungeon[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,0));\\n        \\n        dp[m-1][n-1]= dungeon[m-1][n-1]>0?1:1-dungeon[m-1][n-1];\\n        \\n        for(int i=m-2;i>=0;i--){\\n            dp[i][n-1]=max(dp[i+1][n-1]-dungeon[i][n-1],1);\\n        }\\n         for(int j=n-2;j>=0;j--){\\n            dp[m-1][j]=max(dp[m-1][j+1]-dungeon[m-1][j],1);\\n        }\\n        \\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[i][j]=max(min(dp[i+1][j],dp[i][j+1])-dungeon[i][j],1);\\n            }\\n        }\\n        return dp[0][0];\\n        \\n        \\n    }\\n\\t```\\n\\t\\n\\tJAVA CODE\\n\\t```\\n\\t    public int calculateMinimumHP(int[][] dungeon) {\\n        \\n        int m=dungeon.length,n=dungeon[0].length;\\n        int [][]dp=new int[m][n];\\n        dp[m-1][n-1]=dungeon[m-1][n-1]>0?1:1-dungeon[m-1][n-1];\\n        \\n        for(int i=m-2;i>=0;i--)\\n            dp[i][n-1]=Math.max(dp[i+1][n-1]-dungeon[i][n-1],1);\\n        for(int j=n-2;j>=0;j--)\\n            dp[m-1][j]=Math.max(dp[m-1][j+1]-dungeon[m-1][j],1);\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[i][j]=Math.max(Math.min(dp[i][j+1],dp[i+1][j])-dungeon[i][j],1);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\t```\\n\\t\\n\\tA Try that may help, If helped please upvote if not for me but for Prince and Princess you helped by saving from Kidnappers \\uD83D\\uDE09\\uD83D\\uDE09 Let them marry and give your wishes in form of upvotes\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n     \\n        int m=dungeon.size(),n=dungeon[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,0));\\n        \\n        dp[m-1][n-1]= dungeon[m-1][n-1]>0?1:1-dungeon[m-1][n-1];\\n        \\n        for(int i=m-2;i>=0;i--){\\n            dp[i][n-1]=max(dp[i+1][n-1]-dungeon[i][n-1],1);\\n        }\\n         for(int j=n-2;j>=0;j--){\\n            dp[m-1][j]=max(dp[m-1][j+1]-dungeon[m-1][j],1);\\n        }\\n        \\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[i][j]=max(min(dp[i+1][j],dp[i][j+1])-dungeon[i][j],1);\\n            }\\n        }\\n        return dp[0][0];\\n        \\n        \\n    }\\n\\t```\n```\\n\\t    public int calculateMinimumHP(int[][] dungeon) {\\n        \\n        int m=dungeon.length,n=dungeon[0].length;\\n        int [][]dp=new int[m][n];\\n        dp[m-1][n-1]=dungeon[m-1][n-1]>0?1:1-dungeon[m-1][n-1];\\n        \\n        for(int i=m-2;i>=0;i--)\\n            dp[i][n-1]=Math.max(dp[i+1][n-1]-dungeon[i][n-1],1);\\n        for(int j=n-2;j>=0;j--)\\n            dp[m-1][j]=Math.max(dp[m-1][j+1]-dungeon[m-1][j],1);\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[i][j]=Math.max(Math.min(dp[i][j+1],dp[i+1][j])-dungeon[i][j],1);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3065468,
                "title": "easy-soln-adobe",
                "content": "# Please Upvote if you found the solution helpful\\uD83D\\uDE0A\\n**#ReviseWithArsh #6Companies30Days Challenge 2023\\nChallenge Company 3 : Adobe\\nQ13. Game of Dungeon**\\n\\n# Complexity\\n- Time complexity: O(mn), where m is the number of rows in the dungeon matrix and n is the number of columns\\n\\n- Space complexity: O(mn), as we are using a 2D dp array to store the minimum health points required for each cell.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n    int rows = dungeon.size(), cols = dungeon[0].size();\\n    vector<vector<int>> dp(rows, vector<int>(cols, INT_MAX)); // Initialize dp array with maximum value\\n    dp[rows-1][cols-1] = max(1, 1 - dungeon[rows-1][cols-1]); // Initialize last cell of dp array\\n    for(int i = rows-2; i >= 0; i--) {\\ndp[i][cols-1] = max(1, dp[i+1][cols-1] - dungeon[i][cols-1]); // Initialize last column of dp array\\n    }\\n    for(int i = cols-2; i >= 0; i--) {\\ndp[rows-1][i] = max(1, dp[rows-1][i+1] - dungeon[rows-1][i]); // Initialize last row of dp array\\n    }\\n    // fill the dp array\\n    for(int i=rows-2; i>=0; i--) {\\n        for(int j=cols-2; j>=0; j--) {\\n            dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);\\n        }\\n    }\\n    \\n    return dp[0][0];\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n    int rows = dungeon.size(), cols = dungeon[0].size();\\n    vector<vector<int>> dp(rows, vector<int>(cols, INT_MAX)); // Initialize dp array with maximum value\\n    dp[rows-1][cols-1] = max(1, 1 - dungeon[rows-1][cols-1]); // Initialize last cell of dp array\\n    for(int i = rows-2; i >= 0; i--) {\\ndp[i][cols-1] = max(1, dp[i+1][cols-1] - dungeon[i][cols-1]); // Initialize last column of dp array\\n    }\\n    for(int i = cols-2; i >= 0; i--) {\\ndp[rows-1][i] = max(1, dp[rows-1][i+1] - dungeon[rows-1][i]); // Initialize last row of dp array\\n    }\\n    // fill the dp array\\n    for(int i=rows-2; i>=0; i--) {\\n        for(int j=cols-2; j>=0; j--) {\\n            dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);\\n        }\\n    }\\n    \\n    return dp[0][0];\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876312,
                "title": "clean-golang-dp-explained-solution-complexity",
                "content": "# Approach\\nLet\\'s use dynamic programming approach here, going from the bottom right cell to the top left one.\\n\\nFirst, we need to create the dp array.\\n```dp[i][j]``` would store the **minimum** HP needed to get to the ```dungeon[i][j]``` and survive the whole dungeon assuming that we\\'ve chosen the best path.\\n\\n## The bottom right cell of dp\\nHow do we decide what to put in ```dp[lastRow][lastCol]```? Let\\'s see two cases:\\n1. ```Dungeon[lastRow][lastCol] > 0```. Then we are not getting damaged at this cell and we can safely step inside this dungeon with the minimum HP of $1$.\\n2. ```Dungeon[lastRow][lastCol] <= 0```. Then we are getting damaged and to survive we need to give some extra HP to our hero. Suppose that there is value of $-5$ in the dungeon. Then the knight must have **at least** $6$ HP to survive this room.\\n\\nA simple solution without any if-statements would look like this:\\n```\\ndp[lastRow][lastCol] = max(1, 1 - dungeon[lastRow][lastCol])\\n```\\n\\n## Filling the right column and the bottom row of dp\\nTo fill the rest of the table, we need to calculate the right column and the bottom row of the dp table.\\nLet\\'s start with the right column:\\n```\\nfor i := lastRow - 1; i >= 0; i-- {\\n    dp[i][lastCol] = max(1, dp[i+1][lastCol] - dungeon[i][lastCol])\\n}\\n```\\nWe are looping from the bottom cell to the top one. If the character comes from the dungeon where he got additional HP, then we would want to lower the mininum HP we gave him at the start. Otherwise, if the current dungeon cell takes a lot of HP from him, then ```dp[i+1][lastCol] - dungeon[i][lastCol]``` would be a big number, so we give the knight additional HP to survive this dungeon.\\n\\nThe logic for the bottom row is the same, we just swap the indices:\\n\\n```\\n// Fill the bottom row of dp.\\nfor i := lastCol - 1; i >= 0; i-- {\\n    dp[lastRow][i] = max(1, dp[lastRow][i+1] - dungeon[lastRow][i])\\n}\\n```\\n\\n## Filling the rest of the matrix\\n\\nNow we can fill the rest of the matrix:\\n```\\nfor i := lastRow - 1; i >= 0; i-- {\\n    for j := lastCol - 1; j >= 0; j-- {\\n        minRightBottom := min(dp[i+1][j], dp[i][j+1])\\n        dp[i][j] = max(1, minRightBottom - dungeon[i][j])\\n    }\\n}\\n```\\nThe ```minRightBottom``` variable is calculated in order to decide whether it\\'s less painful for our hero to go down or to go right after the current ```dp[i][j]``` cell. Then the same logic is applied: if the current dungeon cell damages the knight, then we increase the value of ```dp[i][j]```, otherwise we see if we could go even lower than HP we gave him before.\\n\\n## The answer\\n```dp[0][0]``` would be the minimum health required step into ```dungeon[0][0]``` and go through the best path and be alive at the end.\\n\\n# Complexity\\n$m$ - number of rows in the dungeon table, $n$ - number of cols.\\n- Time complexity: $O(m\\\\cdot n)$ - we go through every cell of the dungeon matrix.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(m\\\\cdot n)$ - we create a dp array with the size of the dungeon matrix.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc calculateMinimumHP(dungeon [][]int) int {\\n    // Let\\'s say that dp[i][j] is the minimum HP needed to get to room [i][j]\\n    // and still be alive after passing the dungeon via the best path.\\n    dp := make([][]int, len(dungeon))\\n    for i := range dp {\\n        dp[i] = make([]int, len(dungeon[0]))\\n    }\\n\\n    // For convenience\\n    lastCol := len(dungeon[0]) - 1\\n    lastRow := len(dungeon) - 1\\n\\n    // Fill the bottom right dp cell.\\n    dp[lastRow][lastCol] = max(1, 1 - dungeon[lastRow][lastCol])\\n\\n    // Fill the right column of dp.\\n    for i := lastRow - 1; i >= 0; i-- {\\n        dp[i][lastCol] = max(1, dp[i+1][lastCol] - dungeon[i][lastCol])\\n    }\\n    // Fill the bottom row of dp.\\n    for i := lastCol - 1; i >= 0; i-- {\\n        dp[lastRow][i] = max(1, dp[lastRow][i+1] - dungeon[lastRow][i])\\n    }\\n\\n    // Calculate the rest of the dp matrix.\\n    for i := lastRow - 1; i >= 0; i-- {\\n        for j := lastCol - 1; j >= 0; j-- {\\n            minRightBottom := min(dp[i+1][j], dp[i][j+1])\\n            dp[i][j] = max(1, minRightBottom - dungeon[i][j])\\n        }\\n    }\\n\\n    // dp[0][0] would be the min health required step into dungeon[0][0]\\n    // and go through the best path and be alive at the end.\\n    return dp[0][0]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```dp[i][j]```\n```dungeon[i][j]```\n```dp[lastRow][lastCol]```\n```Dungeon[lastRow][lastCol] > 0```\n```Dungeon[lastRow][lastCol] <= 0```\n```\\ndp[lastRow][lastCol] = max(1, 1 - dungeon[lastRow][lastCol])\\n```\n```\\nfor i := lastRow - 1; i >= 0; i-- {\\n    dp[i][lastCol] = max(1, dp[i+1][lastCol] - dungeon[i][lastCol])\\n}\\n```\n```dp[i+1][lastCol] - dungeon[i][lastCol]```\n```\\n// Fill the bottom row of dp.\\nfor i := lastCol - 1; i >= 0; i-- {\\n    dp[lastRow][i] = max(1, dp[lastRow][i+1] - dungeon[lastRow][i])\\n}\\n```\n```\\nfor i := lastRow - 1; i >= 0; i-- {\\n    for j := lastCol - 1; j >= 0; j-- {\\n        minRightBottom := min(dp[i+1][j], dp[i][j+1])\\n        dp[i][j] = max(1, minRightBottom - dungeon[i][j])\\n    }\\n}\\n```\n```minRightBottom```\n```dp[i][j]```\n```dp[i][j]```\n```dp[0][0]```\n```dungeon[0][0]```\n```\\nfunc calculateMinimumHP(dungeon [][]int) int {\\n    // Let\\'s say that dp[i][j] is the minimum HP needed to get to room [i][j]\\n    // and still be alive after passing the dungeon via the best path.\\n    dp := make([][]int, len(dungeon))\\n    for i := range dp {\\n        dp[i] = make([]int, len(dungeon[0]))\\n    }\\n\\n    // For convenience\\n    lastCol := len(dungeon[0]) - 1\\n    lastRow := len(dungeon) - 1\\n\\n    // Fill the bottom right dp cell.\\n    dp[lastRow][lastCol] = max(1, 1 - dungeon[lastRow][lastCol])\\n\\n    // Fill the right column of dp.\\n    for i := lastRow - 1; i >= 0; i-- {\\n        dp[i][lastCol] = max(1, dp[i+1][lastCol] - dungeon[i][lastCol])\\n    }\\n    // Fill the bottom row of dp.\\n    for i := lastCol - 1; i >= 0; i-- {\\n        dp[lastRow][i] = max(1, dp[lastRow][i+1] - dungeon[lastRow][i])\\n    }\\n\\n    // Calculate the rest of the dp matrix.\\n    for i := lastRow - 1; i >= 0; i-- {\\n        for j := lastCol - 1; j >= 0; j-- {\\n            minRightBottom := min(dp[i+1][j], dp[i][j+1])\\n            dp[i][j] = max(1, minRightBottom - dungeon[i][j])\\n        }\\n    }\\n\\n    // dp[0][0] would be the min health required step into dungeon[0][0]\\n    // and go through the best path and be alive at the end.\\n    return dp[0][0]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2676478,
                "title": "easy-c-dp-solution-explained-o-m-n",
                "content": "# Intuition\\nLet us consider a matrix M $$(m * n)$$, which indicates minimum health required at $$(m,n)$$ to reach the princess. \\nAfter reaching the princess, the knight must have atleast health 1.\\n\\nStarting from the last cell $$M[m-1, n-1]$$, down to $M[0, 0]$.\\nWe can calculate $$M[i, j]$$ as least health loss from bottom or right cell.\\n\\nBut we cannot make the health become zero or lesser. So for each cell, min health should be 1.\\n\\nSo, $$M[i, j] = min(M[i+1, j], M[i, j+1])-dungeon[i, j]$$ or 1, whichever is higher.\\n\\nTherefore, \\n$$M[i, j] = max(1, min(M[i+1, j], M[i, j+1])-dungeon[i, j])$$\\n\\n# Approach\\nUsing the final equation of $$M[i, j]$$, we can tabulate the matrix using **Top-Down Dynamic Programming**\\n\\nFor edge cases, we dont have to consider the out-lying cells or we can consider them to be **INFINITY**.\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m=dungeon.size(), n=dungeon[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 11111111));\\n        for(int i=m-1; i>=0; i--) {\\n            for(int j=n-1; j>=0; j--) {\\n                if(i==m-1 && j==n-1)\\n                    dp[i][j] = max(1, 1 - dungeon[i][j]);\\n                else if(i==m-1)\\n                    dp[i][j] = max(1, dp[i][j+1] - dungeon[i][j]);\\n                else if(j==n-1)\\n                    dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j]);\\n                else\\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m=dungeon.size(), n=dungeon[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 11111111));\\n        for(int i=m-1; i>=0; i--) {\\n            for(int j=n-1; j>=0; j--) {\\n                if(i==m-1 && j==n-1)\\n                    dp[i][j] = max(1, 1 - dungeon[i][j]);\\n                else if(i==m-1)\\n                    dp[i][j] = max(1, dp[i][j+1] - dungeon[i][j]);\\n                else if(j==n-1)\\n                    dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j]);\\n                else\\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344431,
                "title": "dynamic-programming",
                "content": "```\\n int calculateMinimumHP(vector<vector<int>>&arr) {\\n        int n=arr.size();\\n        int m=arr[0].size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,INT_MAX));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 && j==m-1){\\n                    dp[i][j]=1-arr[i][j];\\n                    dp[i][j]=(dp[i][j]<=0)?1:dp[i][j];\\n                    continue;\\n                }\\n                dp[i][j]=min(dp[i+1][j],dp[i][j+1])-arr[i][j];\\n                  dp[i][j]=(dp[i][j]<=0)?1:dp[i][j];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\n int calculateMinimumHP(vector<vector<int>>&arr) {\\n        int n=arr.size();\\n        int m=arr[0].size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,INT_MAX));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 && j==m-1){\\n                    dp[i][j]=1-arr[i][j];\\n                    dp[i][j]=(dp[i][j]<=0)?1:dp[i][j];\\n                    continue;\\n                }\\n                dp[i][j]=min(dp[i+1][j],dp[i][j+1])-arr[i][j];\\n                  dp[i][j]=(dp[i][j]<=0)?1:dp[i][j];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2242126,
                "title": "c-dp-memoization-little-catch",
                "content": "# At first glance this problem looks similar to minium path problem but after you realise one thing that if you apply bottom to up approch (like every problem in recursion) then it is wrong coz king is moving up to bottom and while moving this way the ans is always be total of values in thats but we need the prefix -ve required health in this problem .\\n# For that at every instance of recursive call we dont have to return the extra health which we got while coming from the bottom to the function , we have to return only required health (if required) otherwise return zero .\\n# (if the health is regitive then it considered as a required health and if it is positive then it means that while coming to this position from the bottom we got / we have that much of extra health , in actual problem we cannot use that extra health coz in actual problem we are moving up to bottom)\\n```\\nclass Solution {\\npublic:\\n    int minpath(vector<vector<int>>& grid ,int h, int v,int n ,int m, vector<vector<int>>& dp)\\n    {\\n        if(h==n-1 and v==m-1) \\n        {\\n            if(grid[v][h]>0) return dp[v][h]=0;\\n            return dp[v][h]=grid[v][h];\\n        }\\n        if(h>n-1 or v>m-1) return INT_MIN;\\n        \\n        if(dp[v][h]!=-1) return dp[v][h];\\n        \\n        int right = minpath(grid,h+1,v,n,m,dp);\\n        int left = minpath(grid,h,v+1,n,m,dp);\\n        \\n        if(max(right,left)+grid[v][h]>0)   // while moving bottom to up, if the health till includeing current grid is positive then pass 0 otherwise if it negitive then (that mod value is required health) return it.\\n            return dp[v][h]=0;\\n        else\\n        return dp[v][h]=max(right,left)+grid[v][h]; \\n    }\\n    \\n    int calculateMinimumHP(vector<vector<int>>& dungeon) \\n    {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        \\n        int call = minpath(dungeon,0,0,n,m,dp);\\n        if(call<0) return -1*call+1;\\n        else\\n        return 1; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minpath(vector<vector<int>>& grid ,int h, int v,int n ,int m, vector<vector<int>>& dp)\\n    {\\n        if(h==n-1 and v==m-1) \\n        {\\n            if(grid[v][h]>0) return dp[v][h]=0;\\n            return dp[v][h]=grid[v][h];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2187361,
                "title": "java-2ms-solution-bottom-up-dp-approach",
                "content": "\\n\\t\\n\\tclass Solution {\\n \\n    public int calculateMinimumHP(int[][] dungeon) {\\n        \\n        int health[][] = new int[dungeon.length][dungeon[0].length];\\n        int targethealth=1;\\n        for(int i=dungeon.length-1;i>=0;i--){\\n            for(int j=dungeon[0].length-1;j>=0;j--){\\n                \\n                if(i==dungeon.length-1 && j==dungeon[0].length-1){\\n                    targethealth=targethealth-dungeon[i][j];\\n                    if(targethealth<=0)\\n                        health[i][j]=1;\\n                    else\\n                        health[i][j]=targethealth;\\n                }\\n                \\n                else if(i==dungeon.length-1){\\n                    targethealth=health[i][j+1]-dungeon[i][j];\\n                    if(targethealth<=0)\\n                        health[i][j]=1;\\n                    else\\n                        health[i][j]=targethealth;\\n                }\\n                else if(j==dungeon[0].length-1){\\n                    targethealth=health[i+1][j]-dungeon[i][j];\\n                    if(targethealth<=0)\\n                        health[i][j]=1;\\n                    else\\n                        health[i][j]=targethealth;\\n                }\\n                else\\n                {\\n                    \\n                    targethealth = Math.min(health[i+1][j]-dungeon[i][j],\\n                                      health[i][j+1]-dungeon[i][j]);\\n                    if(targethealth<=0)\\n                        health[i][j]=1;\\n                    else\\n                        health[i][j]=targethealth;\\n                }\\n                    \\n            }\\n        }\\n        \\n        return health[0][0];    \\n    }\\n    }\\n",
                "solutionTags": [],
                "code": "class Solution {\\n \\n    public int calculateMinimumHP(int[][] dungeon) {\\n        \\n        int health[][] = new int[dungeon.length][dungeon[0].length];\\n        int targethealth=1;\\n        for(int i=dungeon.length-1;i>=0;i--){\\n            for(int j=dungeon[0].length-1;j>=0;j--){\\n                \\n                if(i==dungeon.length-1 && j==dungeon[0].length-1){\\n                    targethealth=targethealth-dungeon[i][j];\\n                    if(targethealth<=0)\\n                        health[i][j]=1;\\n                    else\\n                        health[i][j]=targethealth;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2103067,
                "title": "python-2-solutions-top-down-bottom-up-dp",
                "content": "1st Solution (Top Down):\\n\\n```\\nclass Solution:\\n    def calculateMinimumHP(self, arr: List[List[int]]) -> int:\\n        m,n=len(arr),len(arr[0])\\n        directions=((0,1),(1,0))\\n        @lru_cache(None)\\n        def dp(i,j):\\n            if i==m-1 and j==n-1:\\n                return arr[i][j] if arr[i][j]<0 else 0\\n            ans=-sys.maxsize\\n            for d in directions:\\n                ni,nj=d[0]+i,d[1]+j\\n                if 0<=ni<m and 0<=nj<n:\\n                    ans=max(ans,dp(ni,nj)+arr[i][j])\\n            print(i,j,ans)\\n            return ans if ans<0 else 0\\n        return abs(dp(0,0))+1\\n```\\n\\n2nd Solution (Bottom Up):\\n\\n```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        m=len(dungeon)\\n        n=len(dungeon[0])\\n        t=[[0]*(n) for _ in range(m)]\\n        for i in range(m-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                if i==(m-1) and j==(n-1):\\n                    t[i][j]=min(0,dungeon[i][j])\\n                elif i==(m-1):\\n                    t[i][j]=min(0,dungeon[i][j]+t[i][j+1])\\n                elif j==(n-1):\\n                    t[i][j]=min(0,dungeon[i][j]+t[i+1][j])\\n                else:\\n                    a=max(dungeon[i][j]+t[i+1][j],dungeon[i][j]+t[i][j+1])\\n                    t[i][j]=min(0,a)\\n        if t[0][0]>=0 and dungeon[0][0]<0:\\n            return abs(dungeon[0][0])+1\\n        elif t[0][0]>=0:\\n            return 1\\n        else:\\n            return abs(min(t[0][0],dungeon[0][0]))+1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def calculateMinimumHP(self, arr: List[List[int]]) -> int:\\n        m,n=len(arr),len(arr[0])\\n        directions=((0,1),(1,0))\\n        @lru_cache(None)\\n        def dp(i,j):\\n            if i==m-1 and j==n-1:\\n                return arr[i][j] if arr[i][j]<0 else 0\\n            ans=-sys.maxsize\\n            for d in directions:\\n                ni,nj=d[0]+i,d[1]+j\\n                if 0<=ni<m and 0<=nj<n:\\n                    ans=max(ans,dp(ni,nj)+arr[i][j])\\n            print(i,j,ans)\\n            return ans if ans<0 else 0\\n        return abs(dp(0,0))+1\\n```\n```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        m=len(dungeon)\\n        n=len(dungeon[0])\\n        t=[[0]*(n) for _ in range(m)]\\n        for i in range(m-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                if i==(m-1) and j==(n-1):\\n                    t[i][j]=min(0,dungeon[i][j])\\n                elif i==(m-1):\\n                    t[i][j]=min(0,dungeon[i][j]+t[i][j+1])\\n                elif j==(n-1):\\n                    t[i][j]=min(0,dungeon[i][j]+t[i+1][j])\\n                else:\\n                    a=max(dungeon[i][j]+t[i+1][j],dungeon[i][j]+t[i][j+1])\\n                    t[i][j]=min(0,a)\\n        if t[0][0]>=0 and dungeon[0][0]<0:\\n            return abs(dungeon[0][0])+1\\n        elif t[0][0]>=0:\\n            return 1\\n        else:\\n            return abs(min(t[0][0],dungeon[0][0]))+1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024999,
                "title": "dp-top-down-approach-recursive",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int dp[1000][1000];\\n\\n    int solve(int i, int j, vector<vector<int>> &dungeon)\\n    {\\n        int n = dungeon.size(), m = dungeon[0].size();\\n        if (i >= n or j >= m)\\n            return INT_MIN;\\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        if (i == n - 1 and j == m - 1)\\n            return min(0, dungeon[i][j]);\\n        return dp[i][j] = min(0, max(solve(i, j + 1, dungeon), solve(i + 1, j, dungeon)) + dungeon[i][j]);\\n    }\\n\\n    int calculateMinimumHP(vector<vector<int>> &dungeon)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        return abs(solve(0, 0, dungeon)) + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int dp[1000][1000];\\n\\n    int solve(int i, int j, vector<vector<int>> &dungeon)\\n    {\\n        int n = dungeon.size(), m = dungeon[0].size();\\n        if (i >= n or j >= m)\\n            return INT_MIN;\\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        if (i == n - 1 and j == m - 1)\\n            return min(0, dungeon[i][j]);\\n        return dp[i][j] = min(0, max(solve(i, j + 1, dungeon), solve(i + 1, j, dungeon)) + dungeon[i][j]);\\n    }\\n\\n    int calculateMinimumHP(vector<vector<int>> &dungeon)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        return abs(solve(0, 0, dungeon)) + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023298,
                "title": "100-faster-memoization",
                "content": "First we fill the bottommost row... and then the rightmost coloumn and start filling our DP array using memoization.\\n\\n```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] A) {\\n        int n = A.length;\\n        int m = A[0].length;\\n        int[][] dp = new int[A.length][A[0].length];\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        if(1-A[n-1][m-1] > 0)\\n            dp[n-1][m-1] = 1-A[n-1][m-1];\\n        else\\n            dp[n-1][m-1] =1;\\n        for (int j = m-2; j >= 0; j--) {\\n            if(dp[n-1][j+1]-A[n-1][j] > 0)\\n                dp[n-1][j] = dp[n-1][j+1]-A[n-1][j];\\n            else\\n                dp[n-1][j] =1;\\n        }\\n        for (int i = n-2; i >= 0 ; i--) {\\n            if(dp[i+1][m-1]-A[i][m-1] > 0)\\n                dp[i][m-1] = dp[i+1][m-1]-A[i][m-1];\\n            else\\n                dp[i][m-1] = 1;\\n        }\\n        int ans = life(dp, A, 0, 0);\\n        return ans;\\n    }\\n    \\n    public int life(int[][] dp, int[][] A, int i, int j){\\n        if(i>=A.length || j>=A[0].length) return 0;\\n        if(dp[i][j] == -1){\\n            int a1 = life(dp, A, i+1,j);\\n            int a2 = life(dp, A, i, j+1);\\n            int temp = Math.min(a1,a2) - A[i][j];\\n            if(temp>0){\\n                dp[i][j] = temp;\\n            }else{\\n                dp[i][j] = 1;\\n            }\\n        }\\n        return dp[i][j];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] A) {\\n        int n = A.length;\\n        int m = A[0].length;\\n        int[][] dp = new int[A.length][A[0].length];\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        if(1-A[n-1][m-1] > 0)\\n            dp[n-1][m-1] = 1-A[n-1][m-1];\\n        else\\n            dp[n-1][m-1] =1;\\n        for (int j = m-2; j >= 0; j--) {\\n            if(dp[n-1][j+1]-A[n-1][j] > 0)\\n                dp[n-1][j] = dp[n-1][j+1]-A[n-1][j];\\n            else\\n                dp[n-1][j] =1;\\n        }\\n        for (int i = n-2; i >= 0 ; i--) {\\n            if(dp[i+1][m-1]-A[i][m-1] > 0)\\n                dp[i][m-1] = dp[i+1][m-1]-A[i][m-1];\\n            else\\n                dp[i][m-1] = 1;\\n        }\\n        int ans = life(dp, A, 0, 0);\\n        return ans;\\n    }\\n    \\n    public int life(int[][] dp, int[][] A, int i, int j){\\n        if(i>=A.length || j>=A[0].length) return 0;\\n        if(dp[i][j] == -1){\\n            int a1 = life(dp, A, i+1,j);\\n            int a2 = life(dp, A, i, j+1);\\n            int temp = Math.min(a1,a2) - A[i][j];\\n            if(temp>0){\\n                dp[i][j] = temp;\\n            }else{\\n                dp[i][j] = 1;\\n            }\\n        }\\n        return dp[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940592,
                "title": "c-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    int dp[201][201];\\n    int calculateMinimumHP(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int ans;\\n        int l=1,h=1e9;\\n        memset(dp ,-1,sizeof dp);\\n        int x=solve(mat,0,0,n,m);\\n        return abs(x)+1;\\n    }\\n    int solve(vector<vector<int>>&mat ,int i,int j,int n,int m){\\n      if(i<0 || j<0 || i>=n || j>=m)\\n      return INT_MIN;\\n      if(dp[i][j]!=-1)\\n        return dp[i][j];\\n      int ans=0;\\n      if(i==n-1 && j==m-1){\\n        return min(0,ans+mat[i][j]); \\n      }\\n      ans=min(0,mat[i][j]+max(solve(mat,i+1,j,n,m) , solve(mat,i,j+1,n,m)));\\n      return dp[i][j]=ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int dp[201][201];\\n    int calculateMinimumHP(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int ans;\\n        int l=1,h=1e9;\\n        memset(dp ,-1,sizeof dp);\\n        int x=solve(mat,0,0,n,m);\\n        return abs(x)+1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1706481,
                "title": "95-accuracy-solution-in-java-step-by-step-explanation",
                "content": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int r=dungeon.length;// rows\\n        int c= dungeon[0].length;//cols\\n        int [][] alt = new int [r][c];//alternate matrix to store\\n        if(dungeon[r-1][c-1]<0)//if last element is negative\\n            alt[r-1][c-1]=1-dungeon[r-1][c-1];// make it positive store in alternate matrix.. \\n        else//if positive..\\n            alt[r-1][c-1]=1;// assuming 1 as minimum health required..\\n        for(int i=r-2;i>=0;i--)// checking for last col excluding last element.\\n            //diff= alternate matrix last element - current value in dungeon matrix..\\n            alt[i][c-1]=Math.max(alt[i+1][c-1]-dungeon[i][c-1],1);// taking max because the diff might be negative.. \\n        for(int j=c-2;j>=0;j--)--)// checking for last row excluding last element..\\n            //diff= alternate matrix last element - current value in dungeon matrix..\\n            alt[r-1][j]=Math.max(alt[r-1][j+1]-dungeon[r-1][j],1);// taking max because the diff might be negative.. \\n        for(int i=r-2;i>=0;i--)// rest elements.. excluding last row \\n            for(int j=c-2;j>=0;j--)//rest elements.. excluding last col\\n                //firstly taking the minimum of adjacent alternate matrix so as to get min health.. diff= min of adjacent alt matrix - current value in dungeon..\\n                alt[i][j]=Math.max(Math.min(alt[i][j+1],alt[i+1][j])-dungeon[i][j],1););// taking max because the diff might be negative.. if negative ,1 will be given to alt matrix..\\n        return alt[0][0];// bottom to top approach.. so the first element will return the minimum health required..\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int r=dungeon.length;// rows\\n        int c= dungeon[0].length;//cols\\n        int [][] alt = new int [r][c];//alternate matrix to store\\n        if(dungeon[r-1][c-1]<0)//if last element is negative\\n            alt[r-1][c-1]=1-dungeon[r-1][c-1];// make it positive store in alternate matrix.. \\n        else//if positive..\\n            alt[r-1][c-1]=1;// assuming 1 as minimum health required..\\n        for(int i=r-2;i>=0;i--)// checking for last col excluding last element.\\n            //diff= alternate matrix last element - current value in dungeon matrix..\\n            alt[i][c-1]=Math.max(alt[i+1][c-1]-dungeon[i][c-1],1);// taking max because the diff might be negative.. \\n        for(int j=c-2;j>=0;j--)--)// checking for last row excluding last element..\\n            //diff= alternate matrix last element - current value in dungeon matrix..\\n            alt[r-1][j]=Math.max(alt[r-1][j+1]-dungeon[r-1][j],1);// taking max because the diff might be negative.. \\n        for(int i=r-2;i>=0;i--)// rest elements.. excluding last row \\n            for(int j=c-2;j>=0;j--)//rest elements.. excluding last col\\n                //firstly taking the minimum of adjacent alternate matrix so as to get min health.. diff= min of adjacent alt matrix - current value in dungeon..\\n                alt[i][j]=Math.max(Math.min(alt[i][j+1],alt[i+1][j])-dungeon[i][j],1););// taking max because the diff might be negative.. if negative ,1 will be given to alt matrix..\\n        return alt[0][0];// bottom to top approach.. so the first element will return the minimum health required..\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705490,
                "title": "simplest-solution-like-minimum-path-only-two-loops-very-understandable-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& vec) {\\n   vector<vector<int>> vec2(vec.size(),vector<int> (vec[0].size(),0));\\n    \\n    for(int i=vec.size()-1;i>=0;i--)\\n    {\\n        for(int j=vec[0].size()-1;j>=0;j--)\\n        {\\n            if(i==vec.size()-1 && j==vec[0].size()-1)\\n            vec2[i][j]=vec[i][j]>=0?1:abs(vec[i][j])+1;\\n            else if(j==vec[0].size()-1)\\n            vec2[i][j]=max(1,vec2[i+1][j]-vec[i][j]);\\n            else if(i==vec.size()-1)\\n            vec2[i][j]=max(1,vec2[i][j+1]-vec[i][j]);\\n            else\\n            vec2[i][j]=max(1,min(vec2[i][j+1],vec2[i+1][j])-vec[i][j]);\\n        }\\n    }\\n    return vec2[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& vec) {\\n   vector<vector<int>> vec2(vec.size(),vector<int> (vec[0].size(),0));\\n    \\n    for(int i=vec.size()-1;i>=0;i--)\\n    {\\n        for(int j=vec[0].size()-1;j>=0;j--)\\n        {\\n            if(i==vec.size()-1 && j==vec[0].size()-1)\\n            vec2[i][j]=vec[i][j]>=0?1:abs(vec[i][j])+1;\\n            else if(j==vec[0].size()-1)\\n            vec2[i][j]=max(1,vec2[i+1][j]-vec[i][j]);\\n            else if(i==vec.size()-1)\\n            vec2[i][j]=max(1,vec2[i][j+1]-vec[i][j]);\\n            else\\n            vec2[i][j]=max(1,min(vec2[i][j+1],vec2[i+1][j])-vec[i][j]);\\n        }\\n    }\\n    return vec2[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625593,
                "title": "java-dijkstra-shortest-path-using-heap-priorityqueue-slow",
                "content": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int rows = dungeon.length;\\n        int cols = dungeon[0].length;\\n        int[][] healthForCell = new int[rows][cols];\\n        healthForCell[0][0] = dungeon[0][0];\\n        for (int i = 0; i < rows; i++) {\\n            Arrays.fill(healthForCell[i], Integer.MIN_VALUE);\\n        }\\n        // max heap, save [row, column, health]\\n        Queue<int[]> q = new PriorityQueue<>((a, b) -> {\\n            return b[2] - a[2];\\n        });\\n        q.add(new int[]{0, 0, dungeon[0][0]});\\n        // to get min health needed for cell with negative current health\\n        int minHealthForCell = Integer.MAX_VALUE;\\n        while (!q.isEmpty()) {\\n            int[] curr = q.poll();\\n            minHealthForCell = Math.min(curr[2], minHealthForCell);\\n            if (curr[0] == rows - 1 && curr[1] == cols - 1) {\\n                // if result health is positive, return 1\\n                int healthAtPathEnd = (curr[2] >= 0) ? 1 : -curr[2] + 1;\\n                // e.g if first cell is with negative health, need to return it\\'s value +1,\\n                // even if next cell in the path will increase the health\\n                minHealthForCell = minHealthForCell >= 0 ? 1 : -minHealthForCell + 1;\\n                return Math.max(healthAtPathEnd, minHealthForCell);\\n            }\\n            // add to heap next cell if it gives more health than we discovered already in a different path\\n            int nextR = curr[0] + 1;\\n            if (nextR < rows && healthForCell[nextR][curr[1]] < curr[2] + dungeon[nextR][curr[1]]) {\\n                healthForCell[nextR][curr[1]] = curr[2] + dungeon[nextR][curr[1]];\\n                q.add(new int[]{nextR, curr[1], healthForCell[nextR][curr[1]]});\\n            }\\n            int nextC = curr[1] + 1;\\n            if (nextC < cols && healthForCell[curr[0]][nextC] < curr[2] + dungeon[curr[0]][nextC]) {\\n                healthForCell[curr[0]][nextC] = curr[2] + dungeon[curr[0]][nextC];\\n                q.add(new int[]{curr[0], nextC, curr[2] + dungeon[curr[0]][nextC]});\\n            }\\n        }\\n        return Integer.MAX_VALUE;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int rows = dungeon.length;\\n        int cols = dungeon[0].length;\\n        int[][] healthForCell = new int[rows][cols];\\n        healthForCell[0][0] = dungeon[0][0];\\n        for (int i = 0; i < rows; i++) {\\n            Arrays.fill(healthForCell[i], Integer.MIN_VALUE);\\n        }\\n        // max heap, save [row, column, health]\\n        Queue<int[]> q = new PriorityQueue<>((a, b) -> {\\n            return b[2] - a[2];\\n        });\\n        q.add(new int[]{0, 0, dungeon[0][0]});\\n        // to get min health needed for cell with negative current health\\n        int minHealthForCell = Integer.MAX_VALUE;\\n        while (!q.isEmpty()) {\\n            int[] curr = q.poll();\\n            minHealthForCell = Math.min(curr[2], minHealthForCell);\\n            if (curr[0] == rows - 1 && curr[1] == cols - 1) {\\n                // if result health is positive, return 1\\n                int healthAtPathEnd = (curr[2] >= 0) ? 1 : -curr[2] + 1;\\n                // e.g if first cell is with negative health, need to return it\\'s value +1,\\n                // even if next cell in the path will increase the health\\n                minHealthForCell = minHealthForCell >= 0 ? 1 : -minHealthForCell + 1;\\n                return Math.max(healthAtPathEnd, minHealthForCell);\\n            }\\n            // add to heap next cell if it gives more health than we discovered already in a different path\\n            int nextR = curr[0] + 1;\\n            if (nextR < rows && healthForCell[nextR][curr[1]] < curr[2] + dungeon[nextR][curr[1]]) {\\n                healthForCell[nextR][curr[1]] = curr[2] + dungeon[nextR][curr[1]];\\n                q.add(new int[]{nextR, curr[1], healthForCell[nextR][curr[1]]});\\n            }\\n            int nextC = curr[1] + 1;\\n            if (nextC < cols && healthForCell[curr[0]][nextC] < curr[2] + dungeon[curr[0]][nextC]) {\\n                healthForCell[curr[0]][nextC] = curr[2] + dungeon[curr[0]][nextC];\\n                q.add(new int[]{curr[0], nextC, curr[2] + dungeon[curr[0]][nextC]});\\n            }\\n        }\\n        return Integer.MAX_VALUE;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588446,
                "title": "python-dp-space-optimization-with-detailed-explanation",
                "content": "The basic idea is, we calculate the minimum health we need for the current cell based on the already calculated right and bottom cell. This is more efficient than DFS because we will calculate a cell mutiple times if we do this with DFS. For example, consider two possible paths: -2 -> -3 -> -10 -> 1 -> -5 and -2 -> -5 -> -10 -> 1 -> -5,  here we go through -10 -> 1 -> -5 twice, if the dungeon is huge, we\\'ll have many duplicate caculations. So we go backwards, every cell will be calculated just once.\\n\\n<img src=\"https://assets.leetcode.com/users/images/ad4f6ae7-55e5-4532-a63b-3ad34b645707_1637428662.0373414.png\" alt=\"dungeon\" width=\"150\"/>\\n\\n**1. We start from the bottom right cell, it\\'s simple, two cases:**\\n```\\nif dungeon[-1][-1] <= 0:\\n\\thealth = 1 - dungeon[-1][-1]\\nelse:\\n\\thealth = 1\\n```\\n\\ncan be written as:\\n```\\nhealth = 1 + max(0, -dungeon[-1][-1])\\n```\\n\\n**2. For each cell, assume we already know the optimal value for `right` and `down`, the health for this cell will be:**\\n```\\nnxt = min(right, down)\\nif dungeon[i][j] <= 0:\\n\\thealth = nxt - dungeon[i][j]\\nelse:\\n\\t# we can reduce the initial health if we can get some orbs here\\n\\thealth = nxt - dungeon[i][j]\\n\\t# if we have a large enough positive value here, we just need to have a health 1\\n\\tif health < 0:\\n\\t\\thealth = 1\\n```\\nthe above can be simply written as:\\n```\\nhealth = max(min(right, down) - dungeon[i][j], 1)\\n```\\n\\n**Implementation O(MN) time + O(N) space**\\n```\\ndef calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        m, n = len(dungeon), len(dungeon[0])\\n\\t\\t\\n\\t\\t# we only need to memorize the whole next row and one right cell\\n\\t\\t# initialize the row, note that we don\\'t actually need two rows, just\\n\\t\\t# keep updating the same row \\n        health = [math.inf] * n\\n\\t\\t# initialize the bottom right cell\\n        health[-1] = 1 + max(0, -dungeon[-1][-1])\\n\\t\\t\\n\\t\\t# Iterate each cell row by row and caculate the minimun health\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n\\t\\t\\t\\t# skip the last cell as we\\'ve already initialized it\\n                if i == m - 1 and j == n - 1:\\n                    continue\\n                # the right cell of the current row, need to consider the boundary\\n                right = health[j + 1] if j < n - 1 else math.inf\\n\\t\\t\\t\\t# the down cell of the previous row\\n                down = health[j]\\n                health[j] = max(1, min(right, down) - dungeon[i][j])\\n        return health[0]\\n```\\n\\nWe can further optimize the space complexity by only keeping track of the smaller dimention. Say if n << m, we can use ` health = [math.inf] * m` instead, and iterate column by column.",
                "solutionTags": [],
                "code": "```\\nif dungeon[-1][-1] <= 0:\\n\\thealth = 1 - dungeon[-1][-1]\\nelse:\\n\\thealth = 1\\n```\n```\\nhealth = 1 + max(0, -dungeon[-1][-1])\\n```\n```\\nnxt = min(right, down)\\nif dungeon[i][j] <= 0:\\n\\thealth = nxt - dungeon[i][j]\\nelse:\\n\\t# we can reduce the initial health if we can get some orbs here\\n\\thealth = nxt - dungeon[i][j]\\n\\t# if we have a large enough positive value here, we just need to have a health 1\\n\\tif health < 0:\\n\\t\\thealth = 1\\n```\n```\\nhealth = max(min(right, down) - dungeon[i][j], 1)\\n```\n```\\ndef calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        m, n = len(dungeon), len(dungeon[0])\\n\\t\\t\\n\\t\\t# we only need to memorize the whole next row and one right cell\\n\\t\\t# initialize the row, note that we don\\'t actually need two rows, just\\n\\t\\t# keep updating the same row \\n        health = [math.inf] * n\\n\\t\\t# initialize the bottom right cell\\n        health[-1] = 1 + max(0, -dungeon[-1][-1])\\n\\t\\t\\n\\t\\t# Iterate each cell row by row and caculate the minimun health\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n\\t\\t\\t\\t# skip the last cell as we\\'ve already initialized it\\n                if i == m - 1 and j == n - 1:\\n                    continue\\n                # the right cell of the current row, need to consider the boundary\\n                right = health[j + 1] if j < n - 1 else math.inf\\n\\t\\t\\t\\t# the down cell of the previous row\\n                down = health[j]\\n                health[j] = max(1, min(right, down) - dungeon[i][j])\\n        return health[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1566160,
                "title": "recursion-memo-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n//     RECURSIVE\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& dungeon){\\n        if(i>=n || j>=m) return INT_MAX;\\n        if(i==n-1 && j==m-1) return dungeon[i][j]<=0 ? abs(dungeon[i][j])+1 : 1;\\n        int down = solve(i+1,j,n,m,dungeon);\\n        int right = solve(i,j+1,n,m,dungeon);\\n        int ans = min(down,right) - dungeon[i][j]; //neg ans rep sufficiency pos rep required energy\\n        return ans<=0?1:ans; //if we are suff,we at least req 1 to survive and if we are short we need the req energy i.e. ans\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int n = dungeon.size();\\n        int m = dungeon[0].size();\\n        return solve(0,0,n,m,dungeon);\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n//     MEMO\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& dungeon,vector<vector<int>>& dp){\\n        if(i>=n || j>=m) return INT_MAX;\\n        if(i==n-1 && j==m-1) return dungeon[i][j]<=0 ? abs(dungeon[i][j])+1 : 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int down = solve(i+1,j,n,m,dungeon,dp);\\n        int right = solve(i,j+1,n,m,dungeon,dp);\\n        int ans = min(down,right) - dungeon[i][j]; //neg ans rep sufficiency pos rep required energy\\n        return dp[i][j] = ans<=0?1:ans; //if we are suff,we at least req 1 to survive and if we are short we need the req energy i.e. ans\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int n = dungeon.size();\\n        int m = dungeon[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return solve(0,0,n,m,dungeon,dp);\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n//     DYNAMIC PROG.\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 && j==m-1)\\n                    dp[i][j] = min(0,dungeon[i][j]);\\n                else if(i==n-1)\\n                    dp[i][j] = min(0,dungeon[i][j]+dp[i][j+1]);\\n                else if(j==m-1)\\n                    dp[i][j] = min(0,dungeon[i][j]+dp[i+1][j]);\\n                else\\n                    dp[i][j] = min(0,dungeon[i][j]+max(dp[i+1][j],dp[i][j+1]));\\n            }\\n        }\\n        return abs(dp[0][0])+1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//     RECURSIVE\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& dungeon){\\n        if(i>=n || j>=m) return INT_MAX;\\n        if(i==n-1 && j==m-1) return dungeon[i][j]<=0 ? abs(dungeon[i][j])+1 : 1;\\n        int down = solve(i+1,j,n,m,dungeon);\\n        int right = solve(i,j+1,n,m,dungeon);\\n        int ans = min(down,right) - dungeon[i][j]; //neg ans rep sufficiency pos rep required energy\\n        return ans<=0?1:ans; //if we are suff,we at least req 1 to survive and if we are short we need the req energy i.e. ans\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int n = dungeon.size();\\n        int m = dungeon[0].size();\\n        return solve(0,0,n,m,dungeon);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n//     MEMO\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& dungeon,vector<vector<int>>& dp){\\n        if(i>=n || j>=m) return INT_MAX;\\n        if(i==n-1 && j==m-1) return dungeon[i][j]<=0 ? abs(dungeon[i][j])+1 : 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int down = solve(i+1,j,n,m,dungeon,dp);\\n        int right = solve(i,j+1,n,m,dungeon,dp);\\n        int ans = min(down,right) - dungeon[i][j]; //neg ans rep sufficiency pos rep required energy\\n        return dp[i][j] = ans<=0?1:ans; //if we are suff,we at least req 1 to survive and if we are short we need the req energy i.e. ans\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int n = dungeon.size();\\n        int m = dungeon[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return solve(0,0,n,m,dungeon,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n//     DYNAMIC PROG.\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 && j==m-1)\\n                    dp[i][j] = min(0,dungeon[i][j]);\\n                else if(i==n-1)\\n                    dp[i][j] = min(0,dungeon[i][j]+dp[i][j+1]);\\n                else if(j==m-1)\\n                    dp[i][j] = min(0,dungeon[i][j]+dp[i+1][j]);\\n                else\\n                    dp[i][j] = min(0,dungeon[i][j]+max(dp[i+1][j],dp[i][j+1]));\\n            }\\n        }\\n        return abs(dp[0][0])+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552743,
                "title": "python3-clean-implementation",
                "content": "```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.dungeon = None\\n        self.n = None\\n        self.m = None\\n        self.dp = None\\n    \\n    def helper_func(self, position):\\n        \\n        x, y = position\\n        if x >= self.n or y >= self.m or x < 0 or y < 0:\\n            return sys.maxsize\\n        elif x == self.n-1 and y == self.m-1:\\n            return -self.dungeon[x][y] if self.dungeon[x][y] < 0 else 0\\n        \\n        elif position in self.dp:\\n            return self.dp[position]\\n        \\n        else:\\n            right_init = self.helper_func((x, y+1))\\n            down_init = self.helper_func((x+1, y))\\n            curr_init = min(right_init, down_init) - self.dungeon[x][y]\\n            if curr_init < 0: curr_init = 0\\n            self.dp[position] = curr_init \\n            return self.dp[position]         \\n    \\n    \\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        \\n        self.dungeon = dungeon\\n        self.dp = {}\\n        self.n = len(dungeon)\\n        self.m = len(dungeon[0])\\n        \\n        return self.helper_func((0,0)) + 1\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.dungeon = None\\n        self.n = None\\n        self.m = None\\n        self.dp = None\\n    \\n    def helper_func(self, position):\\n        \\n        x, y = position\\n        if x >= self.n or y >= self.m or x < 0 or y < 0:\\n            return sys.maxsize\\n        elif x == self.n-1 and y == self.m-1:\\n            return -self.dungeon[x][y] if self.dungeon[x][y] < 0 else 0\\n        \\n        elif position in self.dp:\\n            return self.dp[position]\\n        \\n        else:\\n            right_init = self.helper_func((x, y+1))\\n            down_init = self.helper_func((x+1, y))\\n            curr_init = min(right_init, down_init) - self.dungeon[x][y]\\n            if curr_init < 0: curr_init = 0\\n            self.dp[position] = curr_init \\n            return self.dp[position]         \\n    \\n    \\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        \\n        self.dungeon = dungeon\\n        self.dp = {}\\n        self.n = len(dungeon)\\n        self.m = len(dungeon[0])\\n        \\n        return self.helper_func((0,0)) + 1\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499387,
                "title": "java-100-fast-reallly-eassssy-self-explanatory-solution",
                "content": "lets take this way\\n\\narr=[[-2,-3,3],[-5,-10,1],[10,30,-5]]\\n\\nif you observe health always will be most -ve value in path\\nand another thing if you gain health take eg of 30 -> -5 we donot need 25 health so we save dp value to 0 as furthure we donot need extra health it will take care of rest path \\nso we have to return\\n\\nmin(0,arr[i][j]+Math.max(right,down));\\n\\nmax because we need maximum of power gain and health loss\\n\\nlook below digram you will understand logic \\n\\n![image](https://assets.leetcode.com/users/images/2a45dc35-2974-4e4c-adc1-312a5b1dfe47_1633197382.4547212.png)\\n\\n\\n# here is code\\n\\n```\\nclass Solution {\\n    Integer[][] memo;\\n    public int calculateMinimumHP(int[][] arr) \\n    {\\n        \\n        int n=arr.length;\\n        int m=arr[0].length;\\n        \\n        memo=new Integer[n][m];\\n        \\n        int answ=f(arr,0,0,n,m);\\n        \\n        return Math.abs(answ)+1;\\n        \\n    }\\n    \\n    int f(int[][] arr,int i,int j,int n,int m)\\n    {\\n        \\n        if(i>=n || j>=m)\\n        return Integer.MIN_VALUE;\\n        \\n        if(memo[i][j]!=null)\\n        return memo[i][j];\\n        \\n        if(i==n-1 && j==m-1)\\n        return Math.min(0,arr[i][j]);\\n        \\n        int down=f(arr,i+1,j,n,m);\\n        int right=f(arr,i,j+1,n,m);\\n        \\n        int max=Math.max(right,down);\\n        \\n        return memo[i][j]=Math.min(0,max+arr[i][j]);\\n        \\n        \\n    }\\n    \\n    \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Integer[][] memo;\\n    public int calculateMinimumHP(int[][] arr) \\n    {\\n        \\n        int n=arr.length;\\n        int m=arr[0].length;\\n        \\n        memo=new Integer[n][m];\\n        \\n        int answ=f(arr,0,0,n,m);\\n        \\n        return Math.abs(answ)+1;\\n        \\n    }\\n    \\n    int f(int[][] arr,int i,int j,int n,int m)\\n    {\\n        \\n        if(i>=n || j>=m)\\n        return Integer.MIN_VALUE;\\n        \\n        if(memo[i][j]!=null)\\n        return memo[i][j];\\n        \\n        if(i==n-1 && j==m-1)\\n        return Math.min(0,arr[i][j]);\\n        \\n        int down=f(arr,i+1,j,n,m);\\n        int right=f(arr,i,j+1,n,m);\\n        \\n        int max=Math.max(right,down);\\n        \\n        return memo[i][j]=Math.min(0,max+arr[i][j]);\\n        \\n        \\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499253,
                "title": "java-dp-o-n-2",
                "content": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int rows = dungeon.length;\\n        int cols = dungeon[0].length;\\n        \\n        int[][] memo = new int[rows + 1][cols + 1];\\n        for (int[] m : memo) {\\n            Arrays.fill(m, Integer.MAX_VALUE);\\n        }\\n        // the positions behind the princess.\\n        memo[rows][cols - 1] = 1;\\n        memo[rows - 1][cols] = 1;\\n        \\n        for (int r = rows - 1; r >= 0; r--) {\\n            for (int c = cols - 1; c >= 0; c--) {\\n                memo[r][c] = Math.max(1, Math.min(memo[r + 1][c], memo[r][c + 1]) - dungeon[r][c]);\\n            }\\n        }\\n        return memo[0][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int rows = dungeon.length;\\n        int cols = dungeon[0].length;\\n        \\n        int[][] memo = new int[rows + 1][cols + 1];\\n        for (int[] m : memo) {\\n            Arrays.fill(m, Integer.MAX_VALUE);\\n        }\\n        // the positions behind the princess.\\n        memo[rows][cols - 1] = 1;\\n        memo[rows - 1][cols] = 1;\\n        \\n        for (int r = rows - 1; r >= 0; r--) {\\n            for (int c = cols - 1; c >= 0; c--) {\\n                memo[r][c] = Math.max(1, Math.min(memo[r + 1][c], memo[r][c + 1]) - dungeon[r][c]);\\n            }\\n        }\\n        return memo[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476571,
                "title": "c-dp-recursion-only-for-those-who-like-memorization",
                "content": "```\\nint dp[201][201];\\n    int helper(vector<vector<int>> &dungeon ,int i,int j){\\n        if(i>=dungeon.size() || j>= dungeon[0].size())\\n            return INT_MAX;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int health=min(helper(dungeon,i+1,j),helper(dungeon,i,j+1));\\n        if(health==INT_MAX)\\n            health=1;\\n        int res=0;\\n        if(health-dungeon[i][j]>0){\\n            res=health-dungeon[i][j];\\n        }\\n        else res=1;\\n        return dp[i][j]=res;\\n\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(dungeon,0,0);\\n    }",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint dp[201][201];\\n    int helper(vector<vector<int>> &dungeon ,int i,int j){\\n        if(i>=dungeon.size() || j>= dungeon[0].size())\\n            return INT_MAX;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int health=min(helper(dungeon,i+1,j),helper(dungeon,i,j+1));\\n        if(health==INT_MAX)\\n            health=1;\\n        int res=0;\\n        if(health-dungeon[i][j]>0){\\n            res=health-dungeon[i][j];\\n        }\\n        else res=1;\\n        return dp[i][j]=res;\\n\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(dungeon,0,0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1247263,
                "title": "c-recursion-memoisation",
                "content": "```\\nclass Solution {\\nprivate:\\n    int n;\\n    int m;\\n    int dp[202][202];\\n    \\npublic:\\n    int dfs(vector<vector<int>>& d,int x,int y)\\n    {\\n        if(x==n || y==m)return INT_MAX;\\n        if(x==n-1 && y==m-1)\\n        {\\n           return (d[x][y] <= 0) ? -d[x][y] + 1 : 1;\\n        }\\n        if(dp[x][y]!=-1)return dp[x][y];\\n        int a=dfs(d,x+1,y);\\n        int b=dfs(d,x,y+1);\\n        int ans= min(a,b);\\n        if(d[x][y]>=ans)ans=1;\\n        else\\n        {\\n            ans=ans-d[x][y];\\n        }\\n        return dp[x][y]=ans;\\n        \\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        n=dungeon.size();\\n        m=dungeon[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return dfs(dungeon,0,0);\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int n;\\n    int m;\\n    int dp[202][202];\\n    \\npublic:\\n    int dfs(vector<vector<int>>& d,int x,int y)\\n    {\\n        if(x==n || y==m)return INT_MAX;\\n        if(x==n-1 && y==m-1)\\n        {\\n           return (d[x][y] <= 0) ? -d[x][y] + 1 : 1;\\n        }\\n        if(dp[x][y]!=-1)return dp[x][y];\\n        int a=dfs(d,x+1,y);\\n        int b=dfs(d,x,y+1);\\n        int ans= min(a,b);\\n        if(d[x][y]>=ans)ans=1;\\n        else\\n        {\\n            ans=ans-d[x][y];\\n        }\\n        return dp[x][y]=ans;\\n        \\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        n=dungeon.size();\\n        m=dungeon[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return dfs(dungeon,0,0);\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1091495,
                "title": "c-no-extra-space-dp-solution-short-simple",
                "content": "0-> *We will approach this problem from the end;*\\n\\n1-> He can enter that room from either above or from left; \\n2-> We can know minimum health needed to enter the room to reach the end;\\n3-> In any position his health should never be less than 1;\\n\\n4-> **DP state is the minimum health requried to reach the end from given room[i,j];**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& DG) {\\n        \\n        int m=DG.size(),n=DG[0].size();\\n        //0\\n        DG[m-1][n-1]=DG[m-1][n-1]<1?1-DG[m-1][n-1]:1;\\n        //2,3\\n        for(int i=m-2;i>=0;i--) {int t=DG[i+1][n-1]-DG[i][n-1];     DG[i][n-1]= t<1?1:t;}\\n        //2,3\\n        for(int j=n-2;j>=0;j--) {int t=DG[m-1][j+1]-DG[m-1][j];     DG[m-1][j]= t<1?1:t;}\\n        \\n        for(int i=m-2;i>=0;i--)\\n            for(int j=n-2;j>=0;j--)\\n            {\\n\\t\\t\\t//1,2,3\\n                int t=min(DG[i+1][j]-DG[i][j],DG[i][j+1]-DG[i][j]);\\n                DG[i][j]=t<1?1:t;\\n            }\\n        //4\\n        return DG[0][0];\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& DG) {\\n        \\n        int m=DG.size(),n=DG[0].size();\\n        //0\\n        DG[m-1][n-1]=DG[m-1][n-1]<1?1-DG[m-1][n-1]:1;\\n        //2,3\\n        for(int i=m-2;i>=0;i--) {int t=DG[i+1][n-1]-DG[i][n-1];     DG[i][n-1]= t<1?1:t;}",
                "codeTag": "Java"
            },
            {
                "id": 1046406,
                "title": "python-dijkstra-and-dp-solutions",
                "content": "Another possible solution is to binary search all the possible values of starting health and see if exists a path in the matrix with that starting point.\\n```\\nfrom heapq import heappush, heappop\\n\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        \\n        n = len(dungeon)\\n        m = len(dungeon[0])\\n        q = [(-dungeon[0][0], 0, 0)]\\n        vis = {}\\n        valid = lambda x, y: 0 <= x < n and 0 <= y < m\\n        needed = max(0, -dungeon[0][0])\\n        \\n        while q:\\n            h, x, y = heappop(q) # pop all values, the h is negative\\n            vis[(x,y)] = h\\n            needed = max(needed, h) # evaluate if we need to worsen our estimate\\n            \\n            if x == n - 1 and y == m - 1:\\n                return needed + 1\\n                \\n            if valid(x + 1, y):\\n                if (x + 1, y) not in vis or vis[(x + 1, y)] > h - dungeon[x + 1][y]: \\n                    heappush(q, (h - dungeon[x + 1][y], x + 1, y))\\n            if valid(x, y + 1):\\n                if (x, y + 1) not in vis or vis[(x, y + 1)] > h - dungeon[x][y + 1]: \\n                    heappush(q, (h - dungeon[x][y + 1], x, y + 1))\\n        \\n        return needed\\n    \\n    \\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        \\n        n = len(dungeon)\\n        m = len(dungeon[0])\\n        dp = [[inf for _ in range(m + 1)] for _ in range(n + 1)]\\n        dp[n-1][m] = 1\\n        dp[n][m-1] = 1\\n        \\n        for r in range(n - 1, -1, -1):\\n            for c in range(m - 1, -1, -1):\\n                dp[r][c] = max(min(dp[r + 1][c], dp[r][c + 1]) - dungeon[r][c], 1)\\n                \\n        return dp[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush, heappop\\n\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        \\n        n = len(dungeon)\\n        m = len(dungeon[0])\\n        q = [(-dungeon[0][0], 0, 0)]\\n        vis = {}\\n        valid = lambda x, y: 0 <= x < n and 0 <= y < m\\n        needed = max(0, -dungeon[0][0])\\n        \\n        while q:\\n            h, x, y = heappop(q) # pop all values, the h is negative\\n            vis[(x,y)] = h\\n            needed = max(needed, h) # evaluate if we need to worsen our estimate\\n            \\n            if x == n - 1 and y == m - 1:\\n                return needed + 1\\n                \\n            if valid(x + 1, y):\\n                if (x + 1, y) not in vis or vis[(x + 1, y)] > h - dungeon[x + 1][y]: \\n                    heappush(q, (h - dungeon[x + 1][y], x + 1, y))\\n            if valid(x, y + 1):\\n                if (x, y + 1) not in vis or vis[(x, y + 1)] > h - dungeon[x][y + 1]: \\n                    heappush(q, (h - dungeon[x][y + 1], x, y + 1))\\n        \\n        return needed\\n    \\n    \\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        \\n        n = len(dungeon)\\n        m = len(dungeon[0])\\n        dp = [[inf for _ in range(m + 1)] for _ in range(n + 1)]\\n        dp[n-1][m] = 1\\n        dp[n][m-1] = 1\\n        \\n        for r in range(n - 1, -1, -1):\\n            for c in range(m - 1, -1, -1):\\n                dp[r][c] = max(min(dp[r + 1][c], dp[r][c + 1]) - dungeon[r][c], 1)\\n                \\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981943,
                "title": "java-precise-dp-approach",
                "content": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int[][] dp = new int [dungeon.length + 1][dungeon[0].length+1]; //memoization is needed to store the output of the repeatitive parts\\n        for(int i=0;i<=dungeon.length;i++) Arrays.fill(dp[i],-1); //initialise the dp matrix with -1\\n\\t    return minHealth(dungeon,0,0,dp); //pass the starting positions\\n    }\\n    \\n    public int minHealth(int[][] arr,int i,int j,int[][] dp){\\n        if(dp[i][j] != -1) return dp[i][j]; //\\n        if(i==arr.length-1 && j==arr[0].length-1) return arr[i][j] > 0 ? 1 : Math.abs(arr[i][j]) + 1;\\n        if(i==arr.length || j==arr[0].length) return Integer.MAX_VALUE;\\n        return dp[i][j] = Math.max(1,Math.min(minHealth(arr,i+1,j,dp),minHealth(arr,i,j+1,dp))-arr[i][j]);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int[][] dp = new int [dungeon.length + 1][dungeon[0].length+1]; //memoization is needed to store the output of the repeatitive parts\\n        for(int i=0;i<=dungeon.length;i++) Arrays.fill(dp[i],-1); //initialise the dp matrix with -1\\n\\t    return minHealth(dungeon,0,0,dp); //pass the starting positions\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 704711,
                "title": "top-down-approach-2-state-dp",
                "content": "class Solution {\\n    \\n    static int inf=Integer.MAX_VALUE;\\n    \\n    public int calculateMinimumHP(int[][] dungeon) {\\n        \\n        int[][] dp=new int[dungeon.length][dungeon[0].length];\\n        \\n        return go(dungeon,0,0,dungeon.length,dungeon[0].length,dp);\\n        \\n    }\\n    static int go(int[][] ar,int i,int j,int n,int m,int[][] dp){\\n        \\n        if(i>=n || j>=m){\\n            return inf;\\n        }\\n        \\n        if(dp[i][j]!=0){\\n            return dp[i][j];\\n        }\\n        \\n        int down =go(ar,i+1,j,n,m,dp);\\n        int right=go(ar,i,j+1,n,m,dp);\\n        \\n        if(right==inf && down==inf){\\n           return ar[i][j]>0?1:Math.abs(ar[i][j])+1;\\n        }\\n        \\n        int best=Math.min(down,right);\\n        if(ar[i][j]>0){\\n            dp[i][j]=Math.max(best-ar[i][j],1);\\n        }else{\\n            dp[i][j]=Math.abs(ar[i][j])+best;\\n        }\\n        \\n        return dp[i][j];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    static int inf=Integer.MAX_VALUE;\\n    \\n    public int calculateMinimumHP(int[][] dungeon) {\\n        \\n        int[][] dp=new int[dungeon.length][dungeon[0].length];\\n        \\n        return go(dungeon,0,0,dungeon.length,dungeon[0].length,dp);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 701595,
                "title": "similar-to-max-path-sum-from-top-left-to-right-bottom",
                "content": "```\\n\\n//when the maximum path sum greater than 0 return 0,\\n//because from that point we can reach to princess easily...\\n\\nint findmin(vector<vector<int>> &dungeon,int row,int col,vector<vector<int>> &dp)\\n    {\\n        if(row==dungeon.size()-1 && col==dungeon[0].size()-1 )\\n        {   \\n            if(dungeon[row][col] < 0)\\n                return dungeon[row][col];\\n            else\\n                return 0;\\n        }\\n        else if(row>=dungeon.size() || col>=dungeon[0].size())\\n            return INT_MIN;\\n        if(dp[row][col]!=-1)\\n            return dp[row][col];\\n        int x= dungeon[row][col]+max(findmin(dungeon,row,col+1,dp),\\n                                     findmin(dungeon,row+1,col,dp));\\n        if(x<0)\\n            return dp[row][col]=x;\\n        else\\n            return dp[row][col]=0;\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) \\n    {\\n        if(dungeon.size()==0)\\n            return 0;\\n        vector<vector<int>> dp(dungeon.size()+1,vector<int>(dungeon[0].size()+1,-1));\\n        return abs(findmin(dungeon,0,0,dp))+1;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\n//when the maximum path sum greater than 0 return 0,\\n//because from that point we can reach to princess easily...\\n\\nint findmin(vector<vector<int>> &dungeon,int row,int col,vector<vector<int>> &dp)\\n    {\\n        if(row==dungeon.size()-1 && col==dungeon[0].size()-1 )\\n        {   \\n            if(dungeon[row][col] < 0)\\n                return dungeon[row][col];\\n            else\\n                return 0;\\n        }\\n        else if(row>=dungeon.size() || col>=dungeon[0].size())\\n            return INT_MIN;\\n        if(dp[row][col]!=-1)\\n            return dp[row][col];\\n        int x= dungeon[row][col]+max(findmin(dungeon,row,col+1,dp),\\n                                     findmin(dungeon,row+1,col,dp));\\n        if(x<0)\\n            return dp[row][col]=x;\\n        else\\n            return dp[row][col]=0;\\n    }\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) \\n    {\\n        if(dungeon.size()==0)\\n            return 0;\\n        vector<vector<int>> dp(dungeon.size()+1,vector<int>(dungeon[0].size()+1,-1));\\n        return abs(findmin(dungeon,0,0,dp))+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 699219,
                "title": "java-recursion-memoization-minimum-deficit-0-ms-beats-100",
                "content": "Slightly different approach to given solutions I\\'ve seen. Instead I keep track of minimum deficit, and if there\\'s no deficit (deficit is greater than 0), we set deficit to 0. So at the end, we either have a deficit (result is negative) or we have no deficit (result is 0). If negative, we take Math.abs() and add 1 to get required health. If no deficit, we just return 1 since that is the minimum health required.\\n```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        return recursionMemo(dungeon);\\n    }\\n\\t\\n\\tprivate Integer[][] memo;\\n    \\n    public int recursionMemo(int[][] dungeon) {\\n        memo = new Integer[dungeon.length][dungeon[0].length];\\n\\n        int result = dfs(dungeon, 0, 0);\\n        if (result < 0) {\\n            result = Math.abs(result) + 1;\\n        } else {\\n            result = 1;\\n        }\\n        return result;\\n    }\\n    \\n    private int dfs(int[][] dungeon, int i, int j) {\\n        if (i == dungeon.length - 1 && j == dungeon[0].length - 1) {\\n            return dungeon[i][j] > 0 ? 0 : dungeon[i][j];\\n        } else if (memo[i][j] != null) {\\n            return memo[i][j];\\n        }\\n        \\n        int down = Integer.MIN_VALUE;\\n        int right = Integer.MIN_VALUE;\\n        if (isValid(i + 1, j, dungeon)) {\\n            down = dfs(dungeon, i + 1, j);\\n        }\\n        if (isValid(i, j + 1, dungeon)) {\\n            right = dfs(dungeon, i, j + 1);\\n        }\\n\\n        int deficit = dungeon[i][j] + Math.max(down, right);\\n\\t\\tdeficit = (deficit > 0) ? 0 : deficit;\\n\\n        memo[i][j] = deficit;\\n        \\n        return memo[i][j];\\n    }\\n    \\n    private boolean isValid(int i, int j, int[][] dungeon) {\\n        return i >= 0 && i < dungeon.length && j >= 0 && j < dungeon[0].length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        return recursionMemo(dungeon);\\n    }\\n\\t\\n\\tprivate Integer[][] memo;\\n    \\n    public int recursionMemo(int[][] dungeon) {\\n        memo = new Integer[dungeon.length][dungeon[0].length];\\n\\n        int result = dfs(dungeon, 0, 0);\\n        if (result < 0) {\\n            result = Math.abs(result) + 1;\\n        } else {\\n            result = 1;\\n        }\\n        return result;\\n    }\\n    \\n    private int dfs(int[][] dungeon, int i, int j) {\\n        if (i == dungeon.length - 1 && j == dungeon[0].length - 1) {\\n            return dungeon[i][j] > 0 ? 0 : dungeon[i][j];\\n        } else if (memo[i][j] != null) {\\n            return memo[i][j];\\n        }\\n        \\n        int down = Integer.MIN_VALUE;\\n        int right = Integer.MIN_VALUE;\\n        if (isValid(i + 1, j, dungeon)) {\\n            down = dfs(dungeon, i + 1, j);\\n        }\\n        if (isValid(i, j + 1, dungeon)) {\\n            right = dfs(dungeon, i, j + 1);\\n        }\\n\\n        int deficit = dungeon[i][j] + Math.max(down, right);\\n\\t\\tdeficit = (deficit > 0) ? 0 : deficit;\\n\\n        memo[i][j] = deficit;\\n        \\n        return memo[i][j];\\n    }\\n    \\n    private boolean isValid(int i, int j, int[][] dungeon) {\\n        return i >= 0 && i < dungeon.length && j >= 0 && j < dungeon[0].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698986,
                "title": "top-down-python-solution",
                "content": "```python\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        n = len(dungeon)\\n        m = len(dungeon[0])\\n        INF = float(\"inf\")\\n        dp = [[-1 for i in range(m+1)] for j in range(n+1)]\\n        \\n        def dfs(i,j):\\n            if (i,j) == (n-1,m-1):\\n                return 1 if (dungeon[i][j] > 0) else abs(dungeon[i][j]) + 1\\n            \\n            if i > (n-1) or j > (m-1):\\n                return INF\\n           \\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            \\n            dp[i][j] = max(1, min(dfs(i+1,j) , dfs(i,j+1)) - dungeon[i][j]) \\n            return dp[i][j]\\n        \\n        return dfs(0,0)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        n = len(dungeon)\\n        m = len(dungeon[0])\\n        INF = float(\"inf\")\\n        dp = [[-1 for i in range(m+1)] for j in range(n+1)]\\n        \\n        def dfs(i,j):\\n            if (i,j) == (n-1,m-1):\\n                return 1 if (dungeon[i][j] > 0) else abs(dungeon[i][j]) + 1\\n            \\n            if i > (n-1) or j > (m-1):\\n                return INF\\n           \\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            \\n            dp[i][j] = max(1, min(dfs(i+1,j) , dfs(i,j+1)) - dungeon[i][j]) \\n            return dp[i][j]\\n        \\n        return dfs(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698571,
                "title": "rust-dp-bottom-up-0ms-explanation-by-example",
                "content": "Well, let\\'s take this dungeon as an example for demonstration purpose:\\n```\\n[-2,  -3,  3]\\n[-5, -10, -1]\\n[10,  30, -5]\\n```\\nAt right bottom, meaning position `(2,2)`, the hero must have at least 1 HP. So our dp table will look like this:\\n```\\n[_,_,_]\\n[_,_,_]\\n[_,_,1]\\n```\\nNow we begin to fill in the table. Because at `(2,2)` the hero loses 5 HP, so at `(1,2)` and `(2,1)` he must have at least 6 HP.\\n```\\n[_,_,_]\\n[_,_,6]\\n[_,6,1]\\n```\\nAt `(2,1)`, he gains 30 HP so `dp[2][0]` and `dp[1,1]` can be `-24`, but again, the hero would die if that happened so we put in `1` instead.\\n```\\n[_,_,_]\\n[_,1,6]\\n[1,6,1]\\n```\\nAt `(1,2)` he gains `1` HP so `dp[0][2]` and `dp[1][1]` can be `5`. But `dp[1][1]` is already `1`, so which one should we choose? Let\\'s remember, we need the hero to have minimum possible HP at the beginning, so of course we would choose whichever is less. The dp table become\\n```\\n[_,_,5]\\n[_,1,6]\\n[1,6,1]\\n```\\nNow you got the general idea, let\\'s quickly fill all the blanks\\n```\\n[5,2,5]\\n[1,1,6]\\n[1,6,1]\\n```\\nWe can see the hero must have at least `5` HP at `(0,0)`, but at that position he loses `2` HP. Therefore, from the beginning, the hero must have at least `7` HP, and that\\'s the answer.\\n```rust\\nuse std::cmp::{min, max};\\nimpl Solution {\\n    pub fn calculate_minimum_hp(dungeon: Vec<Vec<i32>>) -> i32 {\\n        let m = dungeon.len();\\n        let n = dungeon[0].len();\\n        let mut dp = vec![vec![std::i32::MAX;n];m];\\n        dp[m-1][n-1] = 1;\\n        for i in (0..m).rev() {\\n            for j in (0..n).rev() {\\n                if i > 0 {\\n                    dp[i-1][j] = min(max(dp[i][j]-dungeon[i][j], 1), dp[i-1][j]);\\n                }\\n                if j > 0 {\\n                    dp[i][j-1] = min(max(dp[i][j]-dungeon[i][j], 1), dp[i][j-1]);\\n                }\\n            }\\n        }\\n        max(dp[0][0] - dungeon[0][0], 1)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n[-2,  -3,  3]\\n[-5, -10, -1]\\n[10,  30, -5]\\n```\n```\\n[_,_,_]\\n[_,_,_]\\n[_,_,1]\\n```\n```\\n[_,_,_]\\n[_,_,6]\\n[_,6,1]\\n```\n```\\n[_,_,_]\\n[_,1,6]\\n[1,6,1]\\n```\n```\\n[_,_,5]\\n[_,1,6]\\n[1,6,1]\\n```\n```\\n[5,2,5]\\n[1,1,6]\\n[1,6,1]\\n```\n```rust\\nuse std::cmp::{min, max};\\nimpl Solution {\\n    pub fn calculate_minimum_hp(dungeon: Vec<Vec<i32>>) -> i32 {\\n        let m = dungeon.len();\\n        let n = dungeon[0].len();\\n        let mut dp = vec![vec![std::i32::MAX;n];m];\\n        dp[m-1][n-1] = 1;\\n        for i in (0..m).rev() {\\n            for j in (0..n).rev() {\\n                if i > 0 {\\n                    dp[i-1][j] = min(max(dp[i][j]-dungeon[i][j], 1), dp[i-1][j]);\\n                }\\n                if j > 0 {\\n                    dp[i][j-1] = min(max(dp[i][j]-dungeon[i][j], 1), dp[i][j-1]);\\n                }\\n            }\\n        }\\n        max(dp[0][0] - dungeon[0][0], 1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698264,
                "title": "java-dp-solution",
                "content": "This problem is a reversed process of classic DP problem to find the shortest path in 2D matrix. We start the process from the destination to the source. \\n\\nExplaination of DP rules:\\n1. `hp[i][j]` represent the minimum health point to reach point `(i, j)`. \\n2. At least 1 point needed for each position. The destination need 1 after reduce or bonus in the final position: `Math.max(1, 1 - dungeon[m-1][n-1])`. \\n3. The minimum `hp` needed from current position `hp[i][j]` to reach one of the next hops (`hp[i+1][j] or hp[i][j+1]`) is `Math.max(1, hp[i+1][j] - dungeon[i][j])` or `Math.max(1, hp[i][j+1] - dungeon[i][j])`. Choose the smaller one. \\n\\n```java\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int m = dungeon.length, n = dungeon[0].length;\\n        \\n        int[][] hp = new int[m][n];\\n        \\n        hp[m-1][n-1] = Math.max(1, 1 - dungeon[m-1][n-1]);\\n        \\n        for (int i = m - 2; i >= 0; i--)\\n            hp[i][n-1] = Math.max(1, hp[i+1][n-1] - dungeon[i][n-1]);\\n        \\n        for (int i = n - 2; i >= 0; i--)\\n            hp[m-1][i] = Math.max(1, hp[m-1][i+1] - dungeon[m-1][i]);\\n        \\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                int opt1 = Math.max(1, hp[i+1][j] - dungeon[i][j]);\\n                int opt2 = Math.max(1, hp[i][j+1] - dungeon[i][j]);\\n                hp[i][j] = Math.min(opt1, opt2);\\n            }\\n        }\\n        \\n        return hp[0][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int m = dungeon.length, n = dungeon[0].length;\\n        \\n        int[][] hp = new int[m][n];\\n        \\n        hp[m-1][n-1] = Math.max(1, 1 - dungeon[m-1][n-1]);\\n        \\n        for (int i = m - 2; i >= 0; i--)\\n            hp[i][n-1] = Math.max(1, hp[i+1][n-1] - dungeon[i][n-1]);\\n        \\n        for (int i = n - 2; i >= 0; i--)\\n            hp[m-1][i] = Math.max(1, hp[m-1][i+1] - dungeon[m-1][i]);\\n        \\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                int opt1 = Math.max(1, hp[i+1][j] - dungeon[i][j]);\\n                int opt2 = Math.max(1, hp[i][j+1] - dungeon[i][j]);\\n                hp[i][j] = Math.min(opt1, opt2);\\n            }\\n        }\\n        \\n        return hp[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 692055,
                "title": "python-simple-dp-solution-with-dp-table",
                "content": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        ## RC ##\\n\\t\\t## APPROACH : DP ##\\n\\t\\t## TIME COMPLEXICITY : O(M*N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(M*N) ##\\n\\t\\n\\t\\t## EXAMPLE ##\\n\\t\\t# [\\n\\t\\t# [-2,-3,3],\\n\\t\\t# [-5,-10,1],\\n\\t\\t# [10,30,-5]\\n\\t\\t# ]\\n\\t\\t## STACK TRACE ##\\n\\t\\t# [\\n\\t\\t# [7, 5, 2], \\n\\t\\t# [6, 11, 5], \\n\\t\\t# [1, 1, 6]\\n\\t\\t# ]\\n\\n        m, n = len(dungeon), len(dungeon[0])\\n        dp = [[0] * n for _ in range(m)]\\n        \\n        # base case, start\\n        dp[-1][-1] = max( 1, 1 - dungeon[-1][-1] )\\n        \\n        # borders first, base case\\n        for j in range(n-1, 0, -1):\\n            dp[-1][j-1] = max( 1, dp[-1][j] - dungeon[-1][j-1] )\\n        \\n        for i in range(m-1, 0, -1):\\n            dp[i-1][-1] = max( 1, dp[i][-1] - dungeon[i-1][-1] )\\n        \\n        for i in range(m-2, -1, -1):\\n            for j in range(n-2, -1, -1):\\n                dp[i][j] = min( max( 1, dp[i+1][j] - dungeon[i][j] ), max( 1, dp[i][j+1] - dungeon[i][j] ))        \\n        return dp[0][0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        ## RC ##\\n\\t\\t## APPROACH : DP ##\\n\\t\\t## TIME COMPLEXICITY : O(M*N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(M*N) ##\\n\\t\\n\\t\\t## EXAMPLE ##\\n\\t\\t# [\\n\\t\\t# [-2,-3,3],\\n\\t\\t# [-5,-10,1],\\n\\t\\t# [10,30,-5]\\n\\t\\t# ]\\n\\t\\t## STACK TRACE ##\\n\\t\\t# [\\n\\t\\t# [7, 5, 2], \\n\\t\\t# [6, 11, 5], \\n\\t\\t# [1, 1, 6]\\n\\t\\t# ]\\n\\n        m, n = len(dungeon), len(dungeon[0])\\n        dp = [[0] * n for _ in range(m)]\\n        \\n        # base case, start\\n        dp[-1][-1] = max( 1, 1 - dungeon[-1][-1] )\\n        \\n        # borders first, base case\\n        for j in range(n-1, 0, -1):\\n            dp[-1][j-1] = max( 1, dp[-1][j] - dungeon[-1][j-1] )\\n        \\n        for i in range(m-1, 0, -1):\\n            dp[i-1][-1] = max( 1, dp[i][-1] - dungeon[i-1][-1] )\\n        \\n        for i in range(m-2, -1, -1):\\n            for j in range(n-2, -1, -1):\\n                dp[i][j] = min( max( 1, dp[i+1][j] - dungeon[i][j] ), max( 1, dp[i][j+1] - dungeon[i][j] ))        \\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642054,
                "title": "c-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if (dungeon.empty()) return 0;\\n        \\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, INT_MAX));\\n        \\n        dp[m][n-1] = 1; dp[m-1][n] = 1;\\n        for (int i = m-1; i >= 0; i--) {\\n            for (int j = n-1; j >= 0; j--) {\\n                int need = min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j];\\n                dp[i][j] = (need <= 0) ? 1 : need;\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if (dungeon.empty()) return 0;\\n        \\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, INT_MAX));\\n        \\n        dp[m][n-1] = 1; dp[m-1][n] = 1;\\n        for (int i = m-1; i >= 0; i--) {\\n            for (int j = n-1; j >= 0; j--) {\\n                int need = min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j];\\n                dp[i][j] = (need <= 0) ? 1 : need;\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590024,
                "title": "ez-dp-question-javascript-solution-with-simple-explanation",
                "content": "```javascript\\n/**\\n * @param {number[][]} dungeon\\n * @return {number}\\n */\\nvar calculateMinimumHP = function(dungeon) {\\n    // first, lets allow knight\\'s health can be zero\\n    // A[i][j] shows the min health that knight needs to rescue the pricess from dungeon[i][j]\\n    // then we get the following DP formular\\n    //\\n    // A[i][j] = max{ min{A[i][j+1], A[i+1][j]} - dungeon[i][j], 0}\\n    //\\n    // explanation:\\n    // 1. min{A[i][j+1], A[i+1][j]}-dungeon[i][j] \\n    // find the min health required and add the health cost at current position \\n    // 2. max{ min{A[i][j+1], A[i+1][j]} - dungeon[i][j], 0}\\n    // if the min health required is negative, we set it as 0! \\n    // (this is because that knight\\'s health can not be negative)\\n    // 3. return A[0][0] + 1 (question does not allow 0 health, so we add 1)\\n    \\n    let m = dungeon.length\\n    let n = dungeon[0].length\\n    \\n\\n    let A = new Array(m)\\n    for(let i=0; i<m; i++){\\n        A[i] = new Array(n)\\n    }\\n\\n    \\n    for(let i = m-1; i>=0; i--) {\\n        for(let j = n-1; j>=0; j--) {\\n            let goLeft=Infinity, goDown=Infinity\\n            if(i+1>=m && j+1>=n){\\n                goLeft=0\\n                goDown=0\\n            }else if(i+1<m && j+1 <n){\\n                goLeft = A[i][j+1]\\n                goDown = A[i+1][j]\\n            } else if(j+1<n){\\n                goLeft = A[i][j+1]\\n            } else {\\n                goDown = A[i+1][j]\\n            }\\n\\n            A[i][j] = Math.max(Math.min(goLeft,goDown)-dungeon[i][j], 0)\\n\\n        }  \\n    }\\n    return A[0][0]+1\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {number[][]} dungeon\\n * @return {number}\\n */\\nvar calculateMinimumHP = function(dungeon) {\\n    // first, lets allow knight\\'s health can be zero\\n    // A[i][j] shows the min health that knight needs to rescue the pricess from dungeon[i][j]\\n    // then we get the following DP formular\\n    //\\n    // A[i][j] = max{ min{A[i][j+1], A[i+1][j]} - dungeon[i][j], 0}\\n    //\\n    // explanation:\\n    // 1. min{A[i][j+1], A[i+1][j]}-dungeon[i][j] \\n    // find the min health required and add the health cost at current position \\n    // 2. max{ min{A[i][j+1], A[i+1][j]} - dungeon[i][j], 0}\\n    // if the min health required is negative, we set it as 0! \\n    // (this is because that knight\\'s health can not be negative)\\n    // 3. return A[0][0] + 1 (question does not allow 0 health, so we add 1)\\n    \\n    let m = dungeon.length\\n    let n = dungeon[0].length\\n    \\n\\n    let A = new Array(m)\\n    for(let i=0; i<m; i++){\\n        A[i] = new Array(n)\\n    }\\n\\n    \\n    for(let i = m-1; i>=0; i--) {\\n        for(let j = n-1; j>=0; j--) {\\n            let goLeft=Infinity, goDown=Infinity\\n            if(i+1>=m && j+1>=n){\\n                goLeft=0\\n                goDown=0\\n            }else if(i+1<m && j+1 <n){\\n                goLeft = A[i][j+1]\\n                goDown = A[i+1][j]\\n            } else if(j+1<n){\\n                goLeft = A[i][j+1]\\n            } else {\\n                goDown = A[i+1][j]\\n            }\\n\\n            A[i][j] = Math.max(Math.min(goLeft,goDown)-dungeon[i][j], 0)\\n\\n        }  \\n    }\\n    return A[0][0]+1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 558798,
                "title": "from-recursion-to-efficient-dp-solution",
                "content": "**Recursion Solution** *Time Limit* :\\n\\n```\\npublic int Solution(int[][] dungeon)\\n{\\n\\tif (dungeon.Length == 0) return 0;\\n\\treturn Help(dungeon, dungeon.Length - 1, dungeon[0].Length - 1, 0, 0, 0, 0);\\n}\\n\\nprivate int Help(int[][] matrix, int m, int n, int hp, int need, int i, int j)\\n{\\n\\thp += matrix[i][j];\\n\\tneed = Math.Min(need, hp);\\n\\tif (i == m && j == n) return need >= 0 ? 1 : 1 - need;\\n\\n\\tif (i == m)// last line\\n\\t\\treturn Help(matrix, m, n, hp, need, i, j + 1);\\n\\n\\tif (j == n)// last column\\n\\t\\treturn Help(matrix, m, n, hp, need, i + 1, j);\\n\\n\\treturn Math.Min(Help(matrix, m, n, hp, need, i, j + 1), Help(matrix, m, n, hp, need, i + 1, j));\\n\\n}\\n```\\n\\n**Dp Solution** *Efficient*\\n\\nnote: from The last element not The first element begin\\n\\n```\\npublic int DpSolution4(int[][] dungeon)// dungeon ==> dp\\n{\\n\\tif (dungeon.Length == 0) return 0;\\n\\tint m = dungeon.Length, n = dungeon[0].Length;\\n\\n\\tfor (int i = m - 2; i >= 0; i--)// last column\\n\\t\\tdungeon[i][n-1] = Math.Min(dungeon[i][n - 1], dungeon[i][n - 1] + dungeon[i + 1][n - 1]);\\n\\n\\tfor (int i = n - 2; i >= 0; i--)// last line\\n\\t\\tdungeon[m-1][i] = Math.Min(dungeon[m - 1][i], dungeon[m - 1][i] + dungeon[m - 1][i + 1]);\\n\\n\\tfor (int i = m - 2; i >= 0; i--)\\n\\t\\tfor (int j = n - 2; j >= 0; j--)\\n\\t\\t    // down or right\\n\\t\\t\\tdungeon[i][j] = Math.Max(Math.Min(dungeon[i][j], dungeon[i][j] + dungeon[i][j + 1]), Math.Min(dungeon[i][j], dungeon[i][j] + dungeon[i + 1][j]));\\n\\n\\treturn dungeon[0][0] >= 0 ? 1 : 1 - dungeon[0][0];\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int Solution(int[][] dungeon)\\n{\\n\\tif (dungeon.Length == 0) return 0;\\n\\treturn Help(dungeon, dungeon.Length - 1, dungeon[0].Length - 1, 0, 0, 0, 0);\\n}\\n\\nprivate int Help(int[][] matrix, int m, int n, int hp, int need, int i, int j)\\n{\\n\\thp += matrix[i][j];\\n\\tneed = Math.Min(need, hp);\\n\\tif (i == m && j == n) return need >= 0 ? 1 : 1 - need;\\n\\n\\tif (i == m)// last line\\n\\t\\treturn Help(matrix, m, n, hp, need, i, j + 1);\\n\\n\\tif (j == n)// last column\\n\\t\\treturn Help(matrix, m, n, hp, need, i + 1, j);\\n\\n\\treturn Math.Min(Help(matrix, m, n, hp, need, i, j + 1), Help(matrix, m, n, hp, need, i + 1, j));\\n\\n}\\n```\n```\\npublic int DpSolution4(int[][] dungeon)// dungeon ==> dp\\n{\\n\\tif (dungeon.Length == 0) return 0;\\n\\tint m = dungeon.Length, n = dungeon[0].Length;\\n\\n\\tfor (int i = m - 2; i >= 0; i--)// last column\\n\\t\\tdungeon[i][n-1] = Math.Min(dungeon[i][n - 1], dungeon[i][n - 1] + dungeon[i + 1][n - 1]);\\n\\n\\tfor (int i = n - 2; i >= 0; i--)// last line\\n\\t\\tdungeon[m-1][i] = Math.Min(dungeon[m - 1][i], dungeon[m - 1][i] + dungeon[m - 1][i + 1]);\\n\\n\\tfor (int i = m - 2; i >= 0; i--)\\n\\t\\tfor (int j = n - 2; j >= 0; j--)\\n\\t\\t    // down or right\\n\\t\\t\\tdungeon[i][j] = Math.Max(Math.Min(dungeon[i][j], dungeon[i][j] + dungeon[i][j + 1]), Math.Min(dungeon[i][j], dungeon[i][j] + dungeon[i + 1][j]));\\n\\n\\treturn dungeon[0][0] >= 0 ? 1 : 1 - dungeon[0][0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 508267,
                "title": "python-solution-91-time",
                "content": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        if not dungeon:\\n            return 1\\n        tmp_int = len(dungeon[0])+1\\n        dp = []\\n        for i in range(len(dungeon)+1):\\n            dp.append([10000000000] * tmp_int) # max int\\n        dp[-1][-2],dp[-2][-1],dp[-1][-1] = 1,1,1\\n        #print(dp)\\n        for i in range(len(dungeon)-1,-1,-1):\\n            for j in range(len(dungeon[0])-1,-1,-1):\\n                dp[i][j] = max(1,min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j])\\n        #print(dp)\\n        return dp[0][0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        if not dungeon:\\n            return 1\\n        tmp_int = len(dungeon[0])+1\\n        dp = []\\n        for i in range(len(dungeon)+1):\\n            dp.append([10000000000] * tmp_int) # max int\\n        dp[-1][-2],dp[-2][-1],dp[-1][-1] = 1,1,1\\n        #print(dp)\\n        for i in range(len(dungeon)-1,-1,-1):\\n            for j in range(len(dungeon[0])-1,-1,-1):\\n                dp[i][j] = max(1,min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j])\\n        #print(dp)\\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440230,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int CalculateMinimumHP(int[][] d)\\n    {\\n        int c = d.Length, r = d[0].Length;\\n        int[] dp = Enumerable.Repeat(int.MaxValue, r + 1).ToArray();\\n        dp[r - 1] = 1;\\n        for (int i = c - 1; i >= 0; i--)\\n            for (int j = r - 1; j >= 0; j--)\\n                dp[j] = Math.Max(1 , Math.Min(dp[j], dp[j + 1]) - d[i][j]);\\n\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int CalculateMinimumHP(int[][] d)\\n    {\\n        int c = d.Length, r = d[0].Length;\\n        int[] dp = Enumerable.Repeat(int.MaxValue, r + 1).ToArray();\\n        dp[r - 1] = 1;\\n        for (int i = c - 1; i >= 0; i--)\\n            for (int j = r - 1; j >= 0; j--)\\n                dp[j] = Math.Max(1 , Math.Min(dp[j], dp[j + 1]) - d[i][j]);\\n\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 412324,
                "title": "dfs-memorization-easy-to-think-in-terms-of-memorization-as-compared-to-bottom-up",
                "content": "Let us talk about in terms of memorization.\\n(IE = initial energy, CBV = current block value)\\nBasically there are only 2 ways possible:\\n1) Dungeon moves to block having -ve value\\n2) Dungeon moves to block having +ve value\\n\\nSo, if dungeon moves to block with -ve value, it must have IE>=abs(cbv)+1 and if CBV>=0, IE=1.\\nSo in general if we go to right then we check for minimum required IE recurrsively using formula\\nInitial Energy required for any general block (i,j) when next move is right:\\nint tmp = g[i][j]>=0 ? -1*g[i][j] : abs(g[i][j])\\nright = max(tmp, tmp+dfs(i, j+1))\\nInitial Energy required for any general block (i,j) when next move is left:\\ndown = max(tmp, tmp+dfs(i+1, j))\\n\\nSo, dp[i][j] = min(right, left)\\n\\nBase conditions:\\ni==n-1, j==m-1 return g[i][j]>=0 ? -1*g[i][j] : abs(g[i][j])\\n\\nval = dfs(g, dp, 0, 0);\\nans = val>=0 ? ans+1:1;\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    typedef vector<vector<int>> vvi;\\n    typedef vector<int> vi;   \\n    int n,m;\\n    \\n    int dfs(vvi &g, vvi &dp, int i, int j){\\n        if(i==n-1 && j==m-1)\\n            return g[i][j]>=0 ? -1*g[i][j]:abs(g[i][j]);\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        ll r=INT_MAX, d=INT_MAX, tmp;\\n        tmp = g[i][j]>=0 ? -1*g[i][j]:abs(g[i][j]);\\n        \\n        if((j+1)<m) r = max(tmp, tmp+dfs(g, dp, i, j+1));\\n        if((i+1)<n) d = max(tmp, tmp+dfs(g, dp, i+1, j));\\n        \\n        dp[i][j] = min(r, d);\\n        return dp[i][j];\\n        \\n    }\\n      \\n    int calculateMinimumHP(vvi& g) {\\n        n=g.size();\\n        m=g[0].size();\\n        vvi dp(n, vi(m, -1));\\n        ll ans = dfs(g, dp, 0, 0);\\n        return ans>=0 ? ans+1:1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    typedef vector<vector<int>> vvi;\\n    typedef vector<int> vi;   \\n    int n,m;\\n    \\n    int dfs(vvi &g, vvi &dp, int i, int j){\\n        if(i==n-1 && j==m-1)\\n            return g[i][j]>=0 ? -1*g[i][j]:abs(g[i][j]);\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        ll r=INT_MAX, d=INT_MAX, tmp;\\n        tmp = g[i][j]>=0 ? -1*g[i][j]:abs(g[i][j]);\\n        \\n        if((j+1)<m) r = max(tmp, tmp+dfs(g, dp, i, j+1));\\n        if((i+1)<n) d = max(tmp, tmp+dfs(g, dp, i+1, j));\\n        \\n        dp[i][j] = min(r, d);\\n        return dp[i][j];\\n        \\n    }\\n      \\n    int calculateMinimumHP(vvi& g) {\\n        n=g.size();\\n        m=g[0].size();\\n        vvi dp(n, vi(m, -1));\\n        ll ans = dfs(g, dp, 0, 0);\\n        return ans>=0 ? ans+1:1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355341,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if(dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n        \\n        int m = dungeon.length, n = dungeon[0].length;\\n        int[][] health = new int[m][n];\\n        health[m - 1][n - 1] = Math.max(1 - dungeon[m - 1][n - 1], 1);\\n        \\n        //Initialize health matrix\\n        for(int i = m - 2; i >= 0; i--)\\n            health[i][n - 1] = Math.max(health[i + 1][n - 1] - dungeon[i][n - 1], 1);\\n        \\n        for(int j = n - 2; j >= 0; j--)\\n            health[m - 1][j] = Math.max(health[m - 1][j + 1] - dungeon[m - 1][j], 1);\\n        \\n        //Update the rest of health matrix\\n        for(int i = m - 2; i >= 0; i--){\\n            for(int j = n - 2; j >= 0; j--){\\n                int down = Math.max(health[i + 1][j] - dungeon[i][j], 1);\\n                int right = Math.max(health[i][j + 1] - dungeon[i][j], 1);\\n                health[i][j] = Math.min(down, right);\\n            }\\n        }\\n        \\n        return health[0][0];\\n        \\n    }\\n}\\n```\\n\\nRuntime: 3 ms, faster than 6.69% of Java online submissions for Dungeon Game.\\nMemory Usage: 39.9 MB, less than 82.35% of Java online submissions for Dungeon Game.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        if(dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)\\n            return 0;\\n        \\n        int m = dungeon.length, n = dungeon[0].length;\\n        int[][] health = new int[m][n];\\n        health[m - 1][n - 1] = Math.max(1 - dungeon[m - 1][n - 1], 1);\\n        \\n        //Initialize health matrix\\n        for(int i = m - 2; i >= 0; i--)\\n            health[i][n - 1] = Math.max(health[i + 1][n - 1] - dungeon[i][n - 1], 1);\\n        \\n        for(int j = n - 2; j >= 0; j--)\\n            health[m - 1][j] = Math.max(health[m - 1][j + 1] - dungeon[m - 1][j], 1);\\n        \\n        //Update the rest of health matrix\\n        for(int i = m - 2; i >= 0; i--){\\n            for(int j = n - 2; j >= 0; j--){\\n                int down = Math.max(health[i + 1][j] - dungeon[i][j], 1);\\n                int right = Math.max(health[i][j + 1] - dungeon[i][j], 1);\\n                health[i][j] = Math.min(down, right);\\n            }\\n        }\\n        \\n        return health[0][0];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330370,
                "title": "go-4ms-dynamic-programming-submission-beating-100",
                "content": "Deduction: you need to start from the last room.\\n\\nWhen you fall into the last room (M,N), you need to have at least `1 - room[M][N]` health points.\\n\\nWhen you fall into a room (r,c), you need at least enough life to jump into this room and to jump into the right or bottom room, whichever requires the less health points.\\n\\nAlso, each jump into a room needs to be normalized to 1 if the calculated required life is <0.\\n\\n```golang\\nfunc calculateMinimumHP(dungeon [][]int) int {\\n\\tM := len(dungeon) - 1    // rows\\n\\tN := len(dungeon[0]) - 1 // columns\\n\\n\\tfor r := M; r >= 0; r-- {\\n\\t\\tfor c := N; c >= 0; c-- {\\n\\t\\t\\tif r == M && c == N { // bottom-right room\\n\\t\\t\\t\\tdungeon[r][c] = max(1, 1-dungeon[r][c])\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif r == M { // bottom-margin room\\n\\t\\t\\t\\tdungeon[r][c] = max(1, dungeon[r][c+1]-dungeon[r][c])\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif c == N { // right-margin room\\n\\t\\t\\t\\tdungeon[r][c] = max(1, dungeon[r+1][c]-dungeon[r][c])\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n       // any other room\\n\\t\\t\\tdungeon[r][c] = max(1, min(dungeon[r+1][c], dungeon[r][c+1])-dungeon[r][c])\\n\\t\\t}\\n\\t}\\n\\n\\treturn dungeon[0][0]\\n}\\n\\nfunc min(i, j int) int {\\n\\tif i < j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n\\nfunc max(i, j int) int {\\n\\tif i > j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```golang\\nfunc calculateMinimumHP(dungeon [][]int) int {\\n\\tM := len(dungeon) - 1    // rows\\n\\tN := len(dungeon[0]) - 1 // columns\\n\\n\\tfor r := M; r >= 0; r-- {\\n\\t\\tfor c := N; c >= 0; c-- {\\n\\t\\t\\tif r == M && c == N { // bottom-right room\\n\\t\\t\\t\\tdungeon[r][c] = max(1, 1-dungeon[r][c])\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif r == M { // bottom-margin room\\n\\t\\t\\t\\tdungeon[r][c] = max(1, dungeon[r][c+1]-dungeon[r][c])\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif c == N { // right-margin room\\n\\t\\t\\t\\tdungeon[r][c] = max(1, dungeon[r+1][c]-dungeon[r][c])\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n       // any other room\\n\\t\\t\\tdungeon[r][c] = max(1, min(dungeon[r+1][c], dungeon[r][c+1])-dungeon[r][c])\\n\\t\\t}\\n\\t}\\n\\n\\treturn dungeon[0][0]\\n}\\n\\nfunc min(i, j int) int {\\n\\tif i < j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n\\nfunc max(i, j int) int {\\n\\tif i > j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 272589,
                "title": "dp-and-binary-search-solution",
                "content": "**DP solution:**\\n\\nThe idea of dp is simple. We will start from last cell. Then for every cell from the last cell we will calculate what is the minimum power needed to reach the last cell from current cell.\\nWhen we are calculating minimum power for cell (i,j), we will only onsider cell (i+1,j)=x and (i, j+1)=y. If max(x,y) is positive then we will need 0 extra power for reaching last cell, but we might need extrapower for current cell if current cell is negative.\\nBut if max(x,y) is negative then we need to add it with the current cell to calculate the minimum cost needed to reach from current cell.\\n\\nAfter the iteration if (0,0) cell has power>=0 then answer will be 1.\\nIf (0,0) cell has power<0 then answer will be abs((0,0))+1.\\n\\n```\\n#define LL long long\\n\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& grid) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        for(int i=r-1; i>=0; i--){\\n            for(int j=c-1; j>=0; j--){\\n                if(i==r-1 && j==c-1)continue;\\n                int a = INT_MIN;\\n                int b = INT_MIN;\\n                if(i+1<r){\\n                    a = min(0, grid[i+1][j]);\\n                }\\n                if(j+1<c){\\n                    b = min(0, grid[i][j+1]);\\n                }\\n                grid[i][j] = grid[i][j] + max(a, b);\\n            }\\n        }\\n        if(grid[0][0]>=0)return 1;\\n        return abs(grid[0][0])+1;\\n    }\\n    \\n};\\n```\\nTime complexity: ```O(r*c)```\\nspace complexity: ```O(1)```\\n\\n**Binary Search solution:**\\nBinary search idea is more simpler. First we will start from a range. Then in each iteration we will check if we can reach (r-1,c-1) cell with this initial cost.\\nIf we can reach the end cell we will set the range_end = cur_mid\\notherwise we will set range_start = cur_mid+1\\n\\n```\\n#define LL long long\\n\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& grid) {\\n        LL start = 1;\\n        LL end = INT_MAX;\\n        while(start<end){\\n            LL mid = (start + end)/2;\\n            if(can_cross(grid, mid)==true){\\n                end = mid;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n    \\n    \\n    bool can_cross(vector<vector<int>> &grid, int start){\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        vector<vector<int>> mat(grid.size(), vector<int>(grid[0].size(), 0));\\n        for(int i=0; i<mat.size(); i++){\\n            for(int j=0; j<mat[i].size(); j++){\\n                if(i==0 && j==0){\\n                    mat[i][j] = start + grid[0][0];\\n                }else{\\n                    int a = INT_MIN;\\n                    int b = INT_MIN;\\n                    if(i>0 && mat[i-1][j]>0){\\n                        a = mat[i-1][j] + grid[i][j];\\n                    }\\n                    if(j>0 && mat[i][j-1]>0){\\n                        b = mat[i][j-1] + grid[i][j];\\n                    }\\n                    mat[i][j] = max(a, b);\\n                }\\n            }\\n        }\\n        return mat[r-1][c-1]>0;\\n    }\\n    \\n};\\n```\\n\\nTime Complexity: ```O(r*c*log(INT_MAX))```\\nSpace Complexity: ```O(r*c)```",
                "solutionTags": [],
                "code": "```\\n#define LL long long\\n\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& grid) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        for(int i=r-1; i>=0; i--){\\n            for(int j=c-1; j>=0; j--){\\n                if(i==r-1 && j==c-1)continue;\\n                int a = INT_MIN;\\n                int b = INT_MIN;\\n                if(i+1<r){\\n                    a = min(0, grid[i+1][j]);\\n                }\\n                if(j+1<c){\\n                    b = min(0, grid[i][j+1]);\\n                }\\n                grid[i][j] = grid[i][j] + max(a, b);\\n            }\\n        }\\n        if(grid[0][0]>=0)return 1;\\n        return abs(grid[0][0])+1;\\n    }\\n    \\n};\\n```\n```O(r*c)```\n```O(1)```\n```\\n#define LL long long\\n\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& grid) {\\n        LL start = 1;\\n        LL end = INT_MAX;\\n        while(start<end){\\n            LL mid = (start + end)/2;\\n            if(can_cross(grid, mid)==true){\\n                end = mid;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n    \\n    \\n    bool can_cross(vector<vector<int>> &grid, int start){\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        vector<vector<int>> mat(grid.size(), vector<int>(grid[0].size(), 0));\\n        for(int i=0; i<mat.size(); i++){\\n            for(int j=0; j<mat[i].size(); j++){\\n                if(i==0 && j==0){\\n                    mat[i][j] = start + grid[0][0];\\n                }else{\\n                    int a = INT_MIN;\\n                    int b = INT_MIN;\\n                    if(i>0 && mat[i-1][j]>0){\\n                        a = mat[i-1][j] + grid[i][j];\\n                    }\\n                    if(j>0 && mat[i][j-1]>0){\\n                        b = mat[i][j-1] + grid[i][j];\\n                    }\\n                    mat[i][j] = max(a, b);\\n                }\\n            }\\n        }\\n        return mat[r-1][c-1]>0;\\n    }\\n    \\n};\\n```\n```O(r*c*log(INT_MAX))```\n```O(r*c)```",
                "codeTag": "Java"
            },
            {
                "id": 230589,
                "title": "binary-search-top-left-to-bottom-right-dp-beats-100-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int l = 1, r = findMax(dungeon);\\n        while (l < r) {\\n            int m = l+(r-l)/2;\\n            if (canWin(dungeon, m)) {\\n                r = m;\\n            } else {\\n                l = m+1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\nprivate:\\n    bool canWin(vector<vector<int>>& dungeon, int init) {\\n        const int m = dungeon.size(), n = dungeon[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (i == 0 && j == 0) {\\n                    dp[i][j] = init+dungeon[i][j];\\n                } else {\\n                    int prev_max = -1;\\n                    if (i > 0) {\\n                        prev_max = dp[i-1][j];\\n                    }\\n                    if (j > 0) {\\n                        prev_max = max(prev_max, dp[i][j-1]);\\n                    }\\n                    if (prev_max <= 0) {\\n                        dp[i][j] = -1;\\n                    } else {\\n                        dp[i][j] = dungeon[i][j]+prev_max;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1] > 0;\\n    }\\n    \\n    // Go all the way down, and then right, to find an upperbound of neccessary initial hp.\\n    int findMax(const vector<vector<int>>& dungeon) {\\n        const int m = dungeon.size(), n = dungeon[0].size();\\n        int r = 0, bottom = 0;\\n        for (int i = 0; i < m; ++i) {\\n            r += dungeon[i][0];\\n            bottom = min(bottom, r);\\n        }\\n        for (int j = 1; j < n; ++j) {\\n            r += dungeon[m-1][j];\\n            bottom = min(bottom, r);\\n        }\\n        return bottom > 0 ? 1 : -bottom+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int l = 1, r = findMax(dungeon);\\n        while (l < r) {\\n            int m = l+(r-l)/2;\\n            if (canWin(dungeon, m)) {\\n                r = m;\\n            } else {\\n                l = m+1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\nprivate:\\n    bool canWin(vector<vector<int>>& dungeon, int init) {\\n        const int m = dungeon.size(), n = dungeon[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (i == 0 && j == 0) {\\n                    dp[i][j] = init+dungeon[i][j];\\n                } else {\\n                    int prev_max = -1;\\n                    if (i > 0) {\\n                        prev_max = dp[i-1][j];\\n                    }\\n                    if (j > 0) {\\n                        prev_max = max(prev_max, dp[i][j-1]);\\n                    }\\n                    if (prev_max <= 0) {\\n                        dp[i][j] = -1;\\n                    } else {\\n                        dp[i][j] = dungeon[i][j]+prev_max;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1] > 0;\\n    }\\n    \\n    // Go all the way down, and then right, to find an upperbound of neccessary initial hp.\\n    int findMax(const vector<vector<int>>& dungeon) {\\n        const int m = dungeon.size(), n = dungeon[0].size();\\n        int r = 0, bottom = 0;\\n        for (int i = 0; i < m; ++i) {\\n            r += dungeon[i][0];\\n            bottom = min(bottom, r);\\n        }\\n        for (int j = 1; j < n; ++j) {\\n            r += dungeon[m-1][j];\\n            bottom = min(bottom, r);\\n        }\\n        return bottom > 0 ? 1 : -bottom+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184638,
                "title": "swift-awesome-cool-solution-backwards-walk-dp-dynamic-winz-kool",
                "content": "```\\nclass Solution {\\n    func calculateMinimumHP(_ dungeon: [[Int]]) -> Int {\\n        \\n        var h = dungeon.count\\n        if h <= 0 { return 0 }\\n        \\n        var w = dungeon[0].count\\n        if w <= 0 { return 0 }\\n        \\n        var health:[[Int]] = [[Int]](repeating: [Int](repeating: 0, count: w), count: h)\\n        \\n        health[h-1][w-1] = max(1, 1-dungeon[h-1][w-1])\\n        \\n        var i: Int = w-2\\n        while i >= 0 {\\n            health[h-1][i] = max(1, health[h-1][i+1] - dungeon[h-1][i])\\n            i -= 1\\n        }\\n        \\n        var n: Int = h-2\\n        while n >= 0 {\\n            health[n][w-1] = max(1, health[n+1][w-1] - dungeon[n][w-1])\\n            n -= 1\\n        }\\n        \\n        n = h-2\\n        while n >= 0 {\\n            i = w-2\\n            while i >= 0 {\\n                var c1 = max(1, health[n+1][i] - dungeon[n][i])\\n                var c2 = max(1, health[n][i+1] - dungeon[n][i])\\n                health[n][i] = min(c1, c2)\\n                i -= 1\\n            }\\n            n -= 1\\n        }\\n        \\n        return health[0][0]\\n    }\\n}\\n```\\n\\nNo rules, just right. Outback Steakhouse.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func calculateMinimumHP(_ dungeon: [[Int]]) -> Int {\\n        \\n        var h = dungeon.count\\n        if h <= 0 { return 0 }\\n        \\n        var w = dungeon[0].count\\n        if w <= 0 { return 0 }\\n        \\n        var health:[[Int]] = [[Int]](repeating: [Int](repeating: 0, count: w), count: h)\\n        \\n        health[h-1][w-1] = max(1, 1-dungeon[h-1][w-1])\\n        \\n        var i: Int = w-2\\n        while i >= 0 {\\n            health[h-1][i] = max(1, health[h-1][i+1] - dungeon[h-1][i])\\n            i -= 1\\n        }\\n        \\n        var n: Int = h-2\\n        while n >= 0 {\\n            health[n][w-1] = max(1, health[n+1][w-1] - dungeon[n][w-1])\\n            n -= 1\\n        }\\n        \\n        n = h-2\\n        while n >= 0 {\\n            i = w-2\\n            while i >= 0 {\\n                var c1 = max(1, health[n+1][i] - dungeon[n][i])\\n                var c2 = max(1, health[n][i+1] - dungeon[n][i])\\n                health[n][i] = min(c1, c2)\\n                i -= 1\\n            }\\n            n -= 1\\n        }\\n        \\n        return health[0][0]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 144264,
                "title": "java-dp-solution-o-n-space-and-from-top-left-to-bottom-right-traversal",
                "content": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int [] health = new int[dungeon[0].length];\\n        int [] cost = new int[health.length]; \\n        for(int i = 0; i < dungeon.length; ++i){\\n            int [] healthTemp = new int[dungeon[0].length]; \\n            int [] costTemp = new int[health.length]; \\n            for(int j = 0; j < dungeon[i].length; ++j){\\n                if(i == 0 && j == 0){\\n                    healthTemp[j] = dungeon[i][j];\\n                    costTemp[j] = Math.min(0, dungeon[i][j]);\\n                }else if( j == 0){\\n                    healthTemp[j] = health[j] + dungeon[i][j];\\n                    costTemp[j] = Math.min(healthTemp[j], cost[j]);\\n                }else if(i == 0){\\n                    healthTemp[j] = healthTemp[j-1] + dungeon[i][j];\\n                    costTemp[j] = Math.min(costTemp[j-1], healthTemp[j]);\\n                }else{\\n                    healthTemp[j] = Math.max(healthTemp[j-1], health[j]) + dungeon[i][j];\\n                    costTemp[j] = Math.max(Math.min(costTemp[j-1], Math.min(0, (healthTemp[j-1] == 0 ? costTemp[j-1] : healthTemp[j-1]) + dungeon[i][j])),\\n                                           Math.min(cost[j], Math.min(0, (health[j] == 0 ? cost[j]: health[j])  + dungeon[i][j])));\\n                }   \\n            }\\n            \\n            cost = costTemp; health = healthTemp; \\n        }\\n        return Math.abs(cost[cost.length-1]) + 1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calculateMinimumHP(int[][] dungeon) {\\n        int [] health = new int[dungeon[0].length];\\n        int [] cost = new int[health.length]; \\n        for(int i = 0; i < dungeon.length; ++i){\\n            int [] healthTemp = new int[dungeon[0].length]; \\n            int [] costTemp = new int[health.length]; \\n            for(int j = 0; j < dungeon[i].length; ++j){\\n                if(i == 0 && j == 0){\\n                    healthTemp[j] = dungeon[i][j];\\n                    costTemp[j] = Math.min(0, dungeon[i][j]);\\n                }else if( j == 0){\\n                    healthTemp[j] = health[j] + dungeon[i][j];\\n                    costTemp[j] = Math.min(healthTemp[j], cost[j]);\\n                }else if(i == 0){\\n                    healthTemp[j] = healthTemp[j-1] + dungeon[i][j];\\n                    costTemp[j] = Math.min(costTemp[j-1], healthTemp[j]);\\n                }else{\\n                    healthTemp[j] = Math.max(healthTemp[j-1], health[j]) + dungeon[i][j];\\n                    costTemp[j] = Math.max(Math.min(costTemp[j-1], Math.min(0, (healthTemp[j-1] == 0 ? costTemp[j-1] : healthTemp[j-1]) + dungeon[i][j])),\\n                                           Math.min(cost[j], Math.min(0, (health[j] == 0 ? cost[j]: health[j])  + dungeon[i][j])));\\n                }   \\n            }\\n            \\n            cost = costTemp; health = healthTemp; \\n        }\\n        return Math.abs(cost[cost.length-1]) + 1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 136983,
                "title": "python-dp-soultion",
                "content": "After observing the problem, we can find that there is one requirement.  **knight\\'s health must >= 1**. since the goal is to find the minimum health. A intuitive thought is to traverse from destination, from each cell compute the minimum health required to enter such cell. then back propagate to top will get us muimum health required\\n ```\\ndef calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\\'\\n        \\n        R, C = len(dungeon), len(dungeon[0])\\n        dp = [[0] * C for _ in range(R)]\\n        dp[-1][-1] = max(1 - dungeon[-1][-1], 1)\\n        for i in range(R - 2, -1, -1):\\n            dp[i][C - 1] = max(dp[i + 1][C - 1] - dungeon[i][C - 1], 1)\\n        for i in range(C - 2, -1, -1):\\n            dp[R - 1][i] = max(dp[R - 1][i + 1] - dungeon[R - 1][i], 1)\\n        \\n        for i in range(R - 2, -1, -1):\\n            for j in range(C - 2, -1, -1):\\n                # if adding health is much larger than health required, set it to 1\\n                dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1)\\n        \\n        return dp[0][0]\\n                \\n        \\n       \\n```",
                "solutionTags": [],
                "code": "```\\ndef calculateMinimumHP(self, dungeon):\\n        \"\"\"\\n        :type dungeon: List[List[int]]\\n        :rtype: int\\n        \"\"\\'\\n        \\n        R, C = len(dungeon), len(dungeon[0])\\n        dp = [[0] * C for _ in range(R)]\\n        dp[-1][-1] = max(1 - dungeon[-1][-1], 1)\\n        for i in range(R - 2, -1, -1):\\n            dp[i][C - 1] = max(dp[i + 1][C - 1] - dungeon[i][C - 1], 1)\\n        for i in range(C - 2, -1, -1):\\n            dp[R - 1][i] = max(dp[R - 1][i + 1] - dungeon[R - 1][i], 1)\\n        \\n        for i in range(R - 2, -1, -1):\\n            for j in range(C - 2, -1, -1):\\n                # if adding health is much larger than health required, set it to 1\\n                dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1)\\n        \\n        return dp[0][0]\\n                \\n        \\n       \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 52811,
                "title": "c-solution-with-explanation",
                "content": "```\\npublic class Solution {\\n    public int CalculateMinimumHP(int[,] dungeon) {\\n        int rows = dungeon.GetLength(0);\\n        int cols = dungeon.GetLength(1);\\n        \\n        // save partial solutions in a matrix\\n        int[,] solutions = new int[rows, cols];\\n        \\n        // start with last room in the dungeon and ask the following question:\\n        // what would the minimum health of the Knight need to be so he can survive the last room?\\n        // Answer: if the room has a devil (negative value) than his health needs to be at least 1 above\\n        // the devil's strength. Otherwise (room is empty or has a magic orb) his health only needs to be equal to 1\\n        // Therefore, we can set his health to the max value between 1 and 1 - dungeon[rows - 1, cols - 1]\\n        int bottomRow = rows - 1;\\n        int rightCol = cols - 1;\\n        solutions[bottomRow, rightCol] = Math.Max(1, 1 - dungeon[bottomRow, rightCol]);\\n        \\n        // now that we know the Knight's minimal health required in the last room, we can compute his minimal health\\n        // in other rooms. For each room he enters, he needs to be strong enough to survie that room AND meet the minimum\\n        // health required in the next room immediately after that. Since there are two rooms immediately after (except\\n        // for when his is at the borders), we compute both of those health values and keep the smaller one (because we want the \\n        // minumum health required)\\n        \\n        // first, we take care of the borders (bottom row and right column)\\n        \\n        // right column: traverse the rooms from the bottom to the top and make sure the Knight is strong enough to survive the room\\n        // AND arrive at the next room (on its bottom side) with a health greater than or equal to solutions[i + 1, rightCol]\\n        for (int i = bottomRow - 1; i >= 0; i--) {\\n            solutions[i, rightCol] = Math.Max(1, solutions[i + 1, rightCol] - dungeon[i, rightCol]);\\n        }\\n        \\n        // bottom row: traverse the rooms from right to left and make sure the Knight is strong enough to survive the room AND arrive\\n        // at the next room (on its right side) with a health greater than or equal to solutions[bottomRow, j + 1]\\n        for (int j = rightCol - 1; j >= 0; j--) {\\n            solutions[bottomRow, j] = Math.Max(1, solutions[bottomRow, j + 1] - dungeon[bottomRow, j]);\\n        }\\n        \\n        // now, take care of the inner dungeon. Each room has now two neighboring rooms (to the right and down), so we need\\n        // to compute the minimum health with respect to each of them. We then take the minimum value.\\n        for (int i = bottomRow - 1; i >= 0; i--) {\\n            for (int j = rightCol - 1; j >= 0; j--) {\\n                \\n                //compute min health to survive this room AND room to the right\\n                int minRight = Math.Max(1, solutions[i, j + 1] - dungeon[i, j]);\\n                \\n                //compute min health to survie this room AND room down to the bottom\\n                int minDown = Math.Max(1, solutions[i + 1, j] - dungeon[i, j]);\\n                \\n                //take min of the two\\n                solutions[i, j] = Math.Min(minRight, minDown);\\n            }\\n        }\\n        \\n        // our solution is the minimal health the Knight needs to have in the very first room (0,0)\\n        return solutions[0, 0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int CalculateMinimumHP(int[,] dungeon) {\\n        int rows = dungeon.GetLength(0);\\n        int cols = dungeon.GetLength(1);\\n        \\n        // save partial solutions in a matrix\\n        int[,] solutions = new int[rows, cols];\\n        \\n        // start with last room in the dungeon and ask the following question:\\n        // what would the minimum health of the Knight need to be so he can survive the last room?\\n        // Answer: if the room has a devil (negative value) than his health needs to be at least 1 above\\n        // the devil's strength. Otherwise (room is empty or has a magic orb) his health only needs to be equal to 1\\n        // Therefore, we can set his health to the max value between 1 and 1 - dungeon[rows - 1, cols - 1]\\n        int bottomRow = rows - 1;\\n        int rightCol = cols - 1;\\n        solutions[bottomRow, rightCol] = Math.Max(1, 1 - dungeon[bottomRow, rightCol]);\\n        \\n        // now that we know the Knight's minimal health required in the last room, we can compute his minimal health\\n        // in other rooms. For each room he enters, he needs to be strong enough to survie that room AND meet the minimum\\n        // health required in the next room immediately after that. Since there are two rooms immediately after (except\\n        // for when his is at the borders), we compute both of those health values and keep the smaller one (because we want the \\n        // minumum health required)\\n        \\n        // first, we take care of the borders (bottom row and right column)\\n        \\n        // right column: traverse the rooms from the bottom to the top and make sure the Knight is strong enough to survive the room\\n        // AND arrive at the next room (on its bottom side) with a health greater than or equal to solutions[i + 1, rightCol]\\n        for (int i = bottomRow - 1; i >= 0; i--) {\\n            solutions[i, rightCol] = Math.Max(1, solutions[i + 1, rightCol] - dungeon[i, rightCol]);\\n        }\\n        \\n        // bottom row: traverse the rooms from right to left and make sure the Knight is strong enough to survive the room AND arrive\\n        // at the next room (on its right side) with a health greater than or equal to solutions[bottomRow, j + 1]\\n        for (int j = rightCol - 1; j >= 0; j--) {\\n            solutions[bottomRow, j] = Math.Max(1, solutions[bottomRow, j + 1] - dungeon[bottomRow, j]);\\n        }\\n        \\n        // now, take care of the inner dungeon. Each room has now two neighboring rooms (to the right and down), so we need\\n        // to compute the minimum health with respect to each of them. We then take the minimum value.\\n        for (int i = bottomRow - 1; i >= 0; i--) {\\n            for (int j = rightCol - 1; j >= 0; j--) {\\n                \\n                //compute min health to survive this room AND room to the right\\n                int minRight = Math.Max(1, solutions[i, j + 1] - dungeon[i, j]);\\n                \\n                //compute min health to survie this room AND room down to the bottom\\n                int minDown = Math.Max(1, solutions[i + 1, j] - dungeon[i, j]);\\n                \\n                //take min of the two\\n                solutions[i, j] = Math.Min(minRight, minDown);\\n            }\\n        }\\n        \\n        // our solution is the minimal health the Knight needs to have in the very first room (0,0)\\n        return solutions[0, 0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52817,
                "title": "knight-to-princess-and-not-reverse-direction-solution-using-binary-search",
                "content": "Since most solutions solve it in reverse (which is actually pretty neat), what I cam up with is a front to back (and not back to front) solution that uses binary search to find the smallest HP required to rescue. Running time is O(n^2 log(D)), where D is the maximum value of an integer.\\n\\n```\\nclass Solution {\\n    bool canSolve(vector<vector<int>> &dungeon, int guess) {\\n        dungeon[0][0] += guess;\\n        if (dungeon[0][0] <= 0) return false;\\n        for (int i = 1; i < dungeon.size(); ++i) {\\n            dungeon[i][0] += dungeon[i-1][0];\\n            if (dungeon[i][0] <= 0) {\\n                dungeon[i][0] = INT_MIN / 2;\\n            }\\n        }\\n        for (int i = 1; i < dungeon[0].size(); ++i) {\\n            dungeon[0][i] += dungeon[0][i-1];\\n            if (dungeon[0][i] <= 0) {\\n                dungeon[0][i] = INT_MIN / 2;\\n            }\\n        }\\n        for (int i = 1; i < dungeon.size(); ++i) {\\n            for (int j = 1; j < dungeon[0].size(); ++j) {\\n                dungeon[i][j] += std::max(dungeon[i-1][j], dungeon[i][j-1]);\\n                if (dungeon[i][j] <= 0) {\\n                    dungeon[i][j] = INT_MIN / 2;\\n                }\\n            }\\n        }\\n        return dungeon.back().back() != INT_MIN / 2;\\n    }\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if (dungeon.empty() || dungeon[0].empty()) return 1;\\n        int lo = 1, hi = INT_MAX;\\n        int guess = hi;\\n        int mid = lo + (hi - lo) / 2;\\n        while (lo != hi) {\\n            auto dcopy = dungeon;\\n            bool cs = canSolve(dcopy, mid);\\n            if (cs) {\\n                guess = mid;\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n            mid = lo + (hi - lo) / 2;\\n        }\\n        return guess;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool canSolve(vector<vector<int>> &dungeon, int guess) {\\n        dungeon[0][0] += guess;\\n        if (dungeon[0][0] <= 0) return false;\\n        for (int i = 1; i < dungeon.size(); ++i) {\\n            dungeon[i][0] += dungeon[i-1][0];\\n            if (dungeon[i][0] <= 0) {\\n                dungeon[i][0] = INT_MIN / 2;\\n            }\\n        }\\n        for (int i = 1; i < dungeon[0].size(); ++i) {\\n            dungeon[0][i] += dungeon[0][i-1];\\n            if (dungeon[0][i] <= 0) {\\n                dungeon[0][i] = INT_MIN / 2;\\n            }\\n        }\\n        for (int i = 1; i < dungeon.size(); ++i) {\\n            for (int j = 1; j < dungeon[0].size(); ++j) {\\n                dungeon[i][j] += std::max(dungeon[i-1][j], dungeon[i][j-1]);\\n                if (dungeon[i][j] <= 0) {\\n                    dungeon[i][j] = INT_MIN / 2;\\n                }\\n            }\\n        }\\n        return dungeon.back().back() != INT_MIN / 2;\\n    }\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        if (dungeon.empty() || dungeon[0].empty()) return 1;\\n        int lo = 1, hi = INT_MAX;\\n        int guess = hi;\\n        int mid = lo + (hi - lo) / 2;\\n        while (lo != hi) {\\n            auto dcopy = dungeon;\\n            bool cs = canSolve(dcopy, mid);\\n            if (cs) {\\n                guess = mid;\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n            mid = lo + (hi - lo) / 2;\\n        }\\n        return guess;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564963,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1565596,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1566099,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1568690,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1566484,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1568361,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1571382,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1570594,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1573955,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1568998,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1564963,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1565596,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1566099,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1568690,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1566484,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1568361,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1571382,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1570594,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1573955,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 1568998,
                "content": [
                    {
                        "username": "hhzsls",
                        "content": "Why we fill the table from the bottom right corner to left top?"
                    },
                    {
                        "username": "Msey",
                        "content": "These crafty Australians...!"
                    },
                    {
                        "username": "kmathur68",
                        "content": "If you start from top left to bottom right, then at every point you need to make a decision whether you are going right or down. \\nIn order to do that you need to know what is the minimum health required if you start from i+1,j and i,j+1 positions. \\n\\nYou can actually implement in this way, but they will have to be recursive calls. \\nSee more on here -> https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/"
                    },
                    {
                        "username": "clue",
                        "content": "As we all know the typical solution is via DP, which is also the given solution. I can't think of how it can relate to binary search, any ideas?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could set the lower bound to 0 and the upper bound to 20,000 and than do binary search to see if for a certain amount of health you can find a path. It was what I first thought of, but DP is a much better approach here I think. \\n\\n1970. Last Day Where You Can Still Cross \\nis a somewhat similar problem (also traversing a matrix) where Binary search is useful: https://leetcode.com/problems/last-day-where-you-can-still-cross/"
                    },
                    {
                        "username": "packle",
                        "content": "[@shivasaineelam](/shivasaineelam) \\n\\nneat problem - reminds me of minimum path sum (dp), trapping rain water (variant Dijkstra), and safest path in grid (binary search). the max of the search could probably be tightened with some graph algorithm but above my pay grade. I set it to the sum of all negative values and similarly TLEd"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can think of a search space \na particular health and every health greater than that can save the princess \nwe need the minimum one\nbut mine got tle at 42 test case:)"
                    },
                    {
                        "username": "mmontgomery",
                        "content": "Submitting my answer, I\\'m told my code gets the wrong answer for a very simple input `[[0,0]]`, but when I run a custom testcase with this same input, I get the correct answer. What gives? \\n\\n![image](https://assets.leetcode.com/users/mmontgomery/image_1538528784.png)\\n\\nThis isn\\'t the first time this has happened to me on Leetcode problems. "
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "I used global static variable without mentioning the scope of the variable.\n\n```\nstatic int minHP = Integer.MAX_VALUE;\n```\n\nAfter i changed it to, \n\n```\npublic int minHP = Integer.MAX_VALUE;\n```\n\n#### Detailed explaination:\n<a>https://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-</a>"
                    },
                    {
                        "username": "Bloody_Marry",
                        "content": "you may be using global variables."
                    },
                    {
                        "username": "david500",
                        "content": "I started this question trying to start from the top left, couldn\\'t sovle it and realized it\\'s best to solve it from the bottom right corner instead. Now I\\'m wondering if it\\'s even possible to do it from the top left, if anyone knows, please share"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "[@bizco8](/bizco8)  Too confusing mate. I started from bottom right, and after some brainstorming it went smooth\\n\\n"
                    },
                    {
                        "username": "bizco8",
                        "content": "yes we can do it starting from the top left:\\n \\nclass Solution {\\n  int N;\\n  int M;\\n  Integer[][] cache;\\n  public int calculateMinimumHP(int[][] dungeon) {\\n    N = dungeon.length;\\n    M = dungeon[0].length;\\n    cache = new Integer[N][M];\\n    int res = Math.abs(helper(dungeon, 0, 0));\\n    return  res + 1;\\n  }\\n\\n  public int helper(int[][] dungeon, int i, int j){\\n    if(i >= N || i < 0 || j >= M || j < 0) return Integer.MIN_VALUE;\\n    if(cache[i][j] != null) return cache[i][j];\\n    if(i == N - 1 && j == M - 1){\\n      cache[i][j] = Math.min(0, dungeon[i][j]);\\n      return cache[i][j];\\n    }\\n    int minRight = helper(dungeon, i, j + 1);\\n    int minDown =  helper(dungeon, i + 1, j);\\n    if(minRight != Integer.MIN_VALUE) minRight = Math.min(0, dungeon[i][j] +  minRight);\\n    if(minDown != Integer.MIN_VALUE) minDown = Math.min(0, dungeon[i][j] +  minDown);\\n    cache[i][j] = Math.max(minDown, minRight);\\n    return cache[i][j];\\n  }\\n}"
                    },
                    {
                        "username": "kimeshgupta",
                        "content": "Can we solve this by start from dungeon[0][0] instead of dungeon[row-1][column-1] and get final result at dungeon[row-1][column-1] using same or another dp approach??? Please help."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "As usual I like to provide hints,  albeit this one is slightly less of a hint and more of a reassurance.\\n\\nThis is a pure DP question. The difficulty lies in defining your subproblems/recursion. Some special trick is _not_ necessary to solve the question.\\n\\n### Further Hint:\\nI can\\'t say much more without entering spoiler territory, but just think about how you can figure out the minimum health at (i,j) assuming you have the (i+1,j) and (i,j+1) solutions."
                    },
                    {
                        "username": "bingcoder",
                        "content": "in this case [[100]] , why the correct output is 1? I think it should be 0."
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "[@abacusrehan](/abacusrehan) yes at any point health should be minimum 1 even before starting."
                    },
                    {
                        "username": "abacusrehan",
                        "content": "too late, but still\\n> The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\\n\\n"
                    },
                    {
                        "username": "god_like",
                        "content": "The description didn\\'t mention if the health could boost exceed the knight\\'s initial health, which would make a whole lot difference if that\\'s considered.\\n\\nImaging this: \\n[[0, 100, -98]] \\n\\nthe answer could be either 1 or 99."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was also confused, because a typical video game logic would put a cap on the max health you can have.\nHowever, if you just read the solution, you do realize that nothing is mentionned relative to that, that the wording never implies a maximum health cap, and that you would only be making things up by implementing a limit for health.\nBasically, the problem description is correct, we just confused ourselves by making nerdy assumptions. Just gotta learn to read more carefully!"
                    },
                    {
                        "username": "aboulmagd",
                        "content": "So why does bottom up DP work when started from the bottom right cell, and not from the top left cell?\\n\\nAny intuition/visuals would really help.\\nI was only able to solve this problem using the former approach, but why is the DP not symmetrical as with other problems (i.e maximum subarray)?"
                    },
                    {
                        "username": "hebele",
                        "content": "Start from bottom right (not from top left)"
                    }
                ]
            },
            {
                "id": 2069973,
                "content": [
                    {
                        "username": "jrmurro",
                        "content": "How does [[-3,5]] require a mininum health of 4 when we can just use a health value of 1 from the beginning?"
                    },
                    {
                        "username": "jrmurro",
                        "content": "[@Akashdeep_Gupta](/Akashdeep_Gupta) That makes sense!"
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "if you start with health =1 and got to -3 then your health will become -2 (-3+1) hence you die, because every time the health should be greater than 0 that is minimum 1, so to tackle -3 you have to start with health =4. so when you land on -3 your health will be 1 (-3+4) means you are alive."
                    },
                    {
                        "username": "makSyak",
                        "content": "My first hard :)"
                    },
                    {
                        "username": "docentovich",
                        "content": "We must start from the end because we calculate the starting position parameter. The health parameter from which we should start, not end. We don\\'t know the beginning. We know that as a result of the path sum, the health at the end must be greater than or equal to 1. (The additional condition that the health should not be zeroed on the way is essentially an additional condition). We do not know from which parameter the health should start. We minimize the health parameter to the start. Therefore, we need to calculate it to the start because the already calculated values will be closer to the end from the current position."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "After hitting a wall when trying to build dp from the start to the end, I was very surprised that doing it the other way just magically solves all problem. However, I am still confused how you could clearly realize that right away when looking at the problem?\\nCould anyone explain me what is the characterstic of this problem that makes it a \"one-way DP\"? Like what general property does this problem have that makes it easier to solve from one way rather than the other?"
                    },
                    {
                        "username": "ttaylor27",
                        "content": "For me when solving, what led me to immediately realize that I had to start at the bottom right (end) was the idea that I needed to figure out the minimum health needed to reach the end at every given point. The easiest way to build up for the whole traversal is to start at the end, where you know the minimum health you'd need for the final square is simply however much is required for that one square. From there, as you traverse, you can find the minimum from any previous paths you have built, and eventually your minimum will be at the start once you finish your traversal. Basically, start with the minimum health required for the end square, then find the minimum required for the last 2 squares, then last 3 squares, etc. and eventually you will be back at the start with your path fully constructed. (For clarity, I used a tabulation method)"
                    },
                    {
                        "username": "Manashi",
                        "content": "You need to maintain both minimum values and sum along a path, which is not possible in O(NM). O(NM * log(INT_MAX)) will work, which uses binary search on the knight\\'s initial health, and checking if the knight can reach the princess with that initial health, and choosing left or right branch of binary search based on that."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi,\\nfor me, it is always hard to think bottom-up, and i am looking for a top-down DP solution for this question, I could not find one in the discussions, I wonder if one could submit one, I tried to do it myself, however, for me it gets timelimit, I wonder if one could submit  a working top-down DP version as reference for others?\\n\\nthanks"
                    },
                    {
                        "username": "FinalTheory",
                        "content": "Is there any rules that I should comply with? For example, how the input data is generated and so on?"
                    },
                    {
                        "username": "xu4",
                        "content": "otherwise, in the example, if the knight has 5 initially and he can move right->right->down->up->down->down"
                    },
                    {
                        "username": "tushargupta9800",
                        "content": "![image](https://assets.leetcode.com/users/images/d82d73af-4f79-4a2f-814b-b38542a17c1e_1634581073.285247.png)\\n\\nPassed all test cases still TLE"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "From the discussion it seems the accepted approach is DP; I first started to approach this with DFS, modeling the grid as a directed graph and trying to find the min cost path from top left to bottom right. I am still trying to see if DFS is a sensible approach or a dead end.\\n\\nDid anyone else try to do this using some method besides DP/recursion?"
                    }
                ]
            },
            {
                "id": 1925915,
                "content": [
                    {
                        "username": "jrmurro",
                        "content": "How does [[-3,5]] require a mininum health of 4 when we can just use a health value of 1 from the beginning?"
                    },
                    {
                        "username": "jrmurro",
                        "content": "[@Akashdeep_Gupta](/Akashdeep_Gupta) That makes sense!"
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "if you start with health =1 and got to -3 then your health will become -2 (-3+1) hence you die, because every time the health should be greater than 0 that is minimum 1, so to tackle -3 you have to start with health =4. so when you land on -3 your health will be 1 (-3+4) means you are alive."
                    },
                    {
                        "username": "makSyak",
                        "content": "My first hard :)"
                    },
                    {
                        "username": "docentovich",
                        "content": "We must start from the end because we calculate the starting position parameter. The health parameter from which we should start, not end. We don\\'t know the beginning. We know that as a result of the path sum, the health at the end must be greater than or equal to 1. (The additional condition that the health should not be zeroed on the way is essentially an additional condition). We do not know from which parameter the health should start. We minimize the health parameter to the start. Therefore, we need to calculate it to the start because the already calculated values will be closer to the end from the current position."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "After hitting a wall when trying to build dp from the start to the end, I was very surprised that doing it the other way just magically solves all problem. However, I am still confused how you could clearly realize that right away when looking at the problem?\\nCould anyone explain me what is the characterstic of this problem that makes it a \"one-way DP\"? Like what general property does this problem have that makes it easier to solve from one way rather than the other?"
                    },
                    {
                        "username": "ttaylor27",
                        "content": "For me when solving, what led me to immediately realize that I had to start at the bottom right (end) was the idea that I needed to figure out the minimum health needed to reach the end at every given point. The easiest way to build up for the whole traversal is to start at the end, where you know the minimum health you'd need for the final square is simply however much is required for that one square. From there, as you traverse, you can find the minimum from any previous paths you have built, and eventually your minimum will be at the start once you finish your traversal. Basically, start with the minimum health required for the end square, then find the minimum required for the last 2 squares, then last 3 squares, etc. and eventually you will be back at the start with your path fully constructed. (For clarity, I used a tabulation method)"
                    },
                    {
                        "username": "Manashi",
                        "content": "You need to maintain both minimum values and sum along a path, which is not possible in O(NM). O(NM * log(INT_MAX)) will work, which uses binary search on the knight\\'s initial health, and checking if the knight can reach the princess with that initial health, and choosing left or right branch of binary search based on that."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi,\\nfor me, it is always hard to think bottom-up, and i am looking for a top-down DP solution for this question, I could not find one in the discussions, I wonder if one could submit one, I tried to do it myself, however, for me it gets timelimit, I wonder if one could submit  a working top-down DP version as reference for others?\\n\\nthanks"
                    },
                    {
                        "username": "FinalTheory",
                        "content": "Is there any rules that I should comply with? For example, how the input data is generated and so on?"
                    },
                    {
                        "username": "xu4",
                        "content": "otherwise, in the example, if the knight has 5 initially and he can move right->right->down->up->down->down"
                    },
                    {
                        "username": "tushargupta9800",
                        "content": "![image](https://assets.leetcode.com/users/images/d82d73af-4f79-4a2f-814b-b38542a17c1e_1634581073.285247.png)\\n\\nPassed all test cases still TLE"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "From the discussion it seems the accepted approach is DP; I first started to approach this with DFS, modeling the grid as a directed graph and trying to find the min cost path from top left to bottom right. I am still trying to see if DFS is a sensible approach or a dead end.\\n\\nDid anyone else try to do this using some method besides DP/recursion?"
                    }
                ]
            },
            {
                "id": 1870212,
                "content": [
                    {
                        "username": "jrmurro",
                        "content": "How does [[-3,5]] require a mininum health of 4 when we can just use a health value of 1 from the beginning?"
                    },
                    {
                        "username": "jrmurro",
                        "content": "[@Akashdeep_Gupta](/Akashdeep_Gupta) That makes sense!"
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "if you start with health =1 and got to -3 then your health will become -2 (-3+1) hence you die, because every time the health should be greater than 0 that is minimum 1, so to tackle -3 you have to start with health =4. so when you land on -3 your health will be 1 (-3+4) means you are alive."
                    },
                    {
                        "username": "makSyak",
                        "content": "My first hard :)"
                    },
                    {
                        "username": "docentovich",
                        "content": "We must start from the end because we calculate the starting position parameter. The health parameter from which we should start, not end. We don\\'t know the beginning. We know that as a result of the path sum, the health at the end must be greater than or equal to 1. (The additional condition that the health should not be zeroed on the way is essentially an additional condition). We do not know from which parameter the health should start. We minimize the health parameter to the start. Therefore, we need to calculate it to the start because the already calculated values will be closer to the end from the current position."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "After hitting a wall when trying to build dp from the start to the end, I was very surprised that doing it the other way just magically solves all problem. However, I am still confused how you could clearly realize that right away when looking at the problem?\\nCould anyone explain me what is the characterstic of this problem that makes it a \"one-way DP\"? Like what general property does this problem have that makes it easier to solve from one way rather than the other?"
                    },
                    {
                        "username": "ttaylor27",
                        "content": "For me when solving, what led me to immediately realize that I had to start at the bottom right (end) was the idea that I needed to figure out the minimum health needed to reach the end at every given point. The easiest way to build up for the whole traversal is to start at the end, where you know the minimum health you'd need for the final square is simply however much is required for that one square. From there, as you traverse, you can find the minimum from any previous paths you have built, and eventually your minimum will be at the start once you finish your traversal. Basically, start with the minimum health required for the end square, then find the minimum required for the last 2 squares, then last 3 squares, etc. and eventually you will be back at the start with your path fully constructed. (For clarity, I used a tabulation method)"
                    },
                    {
                        "username": "Manashi",
                        "content": "You need to maintain both minimum values and sum along a path, which is not possible in O(NM). O(NM * log(INT_MAX)) will work, which uses binary search on the knight\\'s initial health, and checking if the knight can reach the princess with that initial health, and choosing left or right branch of binary search based on that."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi,\\nfor me, it is always hard to think bottom-up, and i am looking for a top-down DP solution for this question, I could not find one in the discussions, I wonder if one could submit one, I tried to do it myself, however, for me it gets timelimit, I wonder if one could submit  a working top-down DP version as reference for others?\\n\\nthanks"
                    },
                    {
                        "username": "FinalTheory",
                        "content": "Is there any rules that I should comply with? For example, how the input data is generated and so on?"
                    },
                    {
                        "username": "xu4",
                        "content": "otherwise, in the example, if the knight has 5 initially and he can move right->right->down->up->down->down"
                    },
                    {
                        "username": "tushargupta9800",
                        "content": "![image](https://assets.leetcode.com/users/images/d82d73af-4f79-4a2f-814b-b38542a17c1e_1634581073.285247.png)\\n\\nPassed all test cases still TLE"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "From the discussion it seems the accepted approach is DP; I first started to approach this with DFS, modeling the grid as a directed graph and trying to find the min cost path from top left to bottom right. I am still trying to see if DFS is a sensible approach or a dead end.\\n\\nDid anyone else try to do this using some method besides DP/recursion?"
                    }
                ]
            },
            {
                "id": 1862120,
                "content": [
                    {
                        "username": "jrmurro",
                        "content": "How does [[-3,5]] require a mininum health of 4 when we can just use a health value of 1 from the beginning?"
                    },
                    {
                        "username": "jrmurro",
                        "content": "[@Akashdeep_Gupta](/Akashdeep_Gupta) That makes sense!"
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "if you start with health =1 and got to -3 then your health will become -2 (-3+1) hence you die, because every time the health should be greater than 0 that is minimum 1, so to tackle -3 you have to start with health =4. so when you land on -3 your health will be 1 (-3+4) means you are alive."
                    },
                    {
                        "username": "makSyak",
                        "content": "My first hard :)"
                    },
                    {
                        "username": "docentovich",
                        "content": "We must start from the end because we calculate the starting position parameter. The health parameter from which we should start, not end. We don\\'t know the beginning. We know that as a result of the path sum, the health at the end must be greater than or equal to 1. (The additional condition that the health should not be zeroed on the way is essentially an additional condition). We do not know from which parameter the health should start. We minimize the health parameter to the start. Therefore, we need to calculate it to the start because the already calculated values will be closer to the end from the current position."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "After hitting a wall when trying to build dp from the start to the end, I was very surprised that doing it the other way just magically solves all problem. However, I am still confused how you could clearly realize that right away when looking at the problem?\\nCould anyone explain me what is the characterstic of this problem that makes it a \"one-way DP\"? Like what general property does this problem have that makes it easier to solve from one way rather than the other?"
                    },
                    {
                        "username": "ttaylor27",
                        "content": "For me when solving, what led me to immediately realize that I had to start at the bottom right (end) was the idea that I needed to figure out the minimum health needed to reach the end at every given point. The easiest way to build up for the whole traversal is to start at the end, where you know the minimum health you'd need for the final square is simply however much is required for that one square. From there, as you traverse, you can find the minimum from any previous paths you have built, and eventually your minimum will be at the start once you finish your traversal. Basically, start with the minimum health required for the end square, then find the minimum required for the last 2 squares, then last 3 squares, etc. and eventually you will be back at the start with your path fully constructed. (For clarity, I used a tabulation method)"
                    },
                    {
                        "username": "Manashi",
                        "content": "You need to maintain both minimum values and sum along a path, which is not possible in O(NM). O(NM * log(INT_MAX)) will work, which uses binary search on the knight\\'s initial health, and checking if the knight can reach the princess with that initial health, and choosing left or right branch of binary search based on that."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi,\\nfor me, it is always hard to think bottom-up, and i am looking for a top-down DP solution for this question, I could not find one in the discussions, I wonder if one could submit one, I tried to do it myself, however, for me it gets timelimit, I wonder if one could submit  a working top-down DP version as reference for others?\\n\\nthanks"
                    },
                    {
                        "username": "FinalTheory",
                        "content": "Is there any rules that I should comply with? For example, how the input data is generated and so on?"
                    },
                    {
                        "username": "xu4",
                        "content": "otherwise, in the example, if the knight has 5 initially and he can move right->right->down->up->down->down"
                    },
                    {
                        "username": "tushargupta9800",
                        "content": "![image](https://assets.leetcode.com/users/images/d82d73af-4f79-4a2f-814b-b38542a17c1e_1634581073.285247.png)\\n\\nPassed all test cases still TLE"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "From the discussion it seems the accepted approach is DP; I first started to approach this with DFS, modeling the grid as a directed graph and trying to find the min cost path from top left to bottom right. I am still trying to see if DFS is a sensible approach or a dead end.\\n\\nDid anyone else try to do this using some method besides DP/recursion?"
                    }
                ]
            },
            {
                "id": 1573024,
                "content": [
                    {
                        "username": "jrmurro",
                        "content": "How does [[-3,5]] require a mininum health of 4 when we can just use a health value of 1 from the beginning?"
                    },
                    {
                        "username": "jrmurro",
                        "content": "[@Akashdeep_Gupta](/Akashdeep_Gupta) That makes sense!"
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "if you start with health =1 and got to -3 then your health will become -2 (-3+1) hence you die, because every time the health should be greater than 0 that is minimum 1, so to tackle -3 you have to start with health =4. so when you land on -3 your health will be 1 (-3+4) means you are alive."
                    },
                    {
                        "username": "makSyak",
                        "content": "My first hard :)"
                    },
                    {
                        "username": "docentovich",
                        "content": "We must start from the end because we calculate the starting position parameter. The health parameter from which we should start, not end. We don\\'t know the beginning. We know that as a result of the path sum, the health at the end must be greater than or equal to 1. (The additional condition that the health should not be zeroed on the way is essentially an additional condition). We do not know from which parameter the health should start. We minimize the health parameter to the start. Therefore, we need to calculate it to the start because the already calculated values will be closer to the end from the current position."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "After hitting a wall when trying to build dp from the start to the end, I was very surprised that doing it the other way just magically solves all problem. However, I am still confused how you could clearly realize that right away when looking at the problem?\\nCould anyone explain me what is the characterstic of this problem that makes it a \"one-way DP\"? Like what general property does this problem have that makes it easier to solve from one way rather than the other?"
                    },
                    {
                        "username": "ttaylor27",
                        "content": "For me when solving, what led me to immediately realize that I had to start at the bottom right (end) was the idea that I needed to figure out the minimum health needed to reach the end at every given point. The easiest way to build up for the whole traversal is to start at the end, where you know the minimum health you'd need for the final square is simply however much is required for that one square. From there, as you traverse, you can find the minimum from any previous paths you have built, and eventually your minimum will be at the start once you finish your traversal. Basically, start with the minimum health required for the end square, then find the minimum required for the last 2 squares, then last 3 squares, etc. and eventually you will be back at the start with your path fully constructed. (For clarity, I used a tabulation method)"
                    },
                    {
                        "username": "Manashi",
                        "content": "You need to maintain both minimum values and sum along a path, which is not possible in O(NM). O(NM * log(INT_MAX)) will work, which uses binary search on the knight\\'s initial health, and checking if the knight can reach the princess with that initial health, and choosing left or right branch of binary search based on that."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi,\\nfor me, it is always hard to think bottom-up, and i am looking for a top-down DP solution for this question, I could not find one in the discussions, I wonder if one could submit one, I tried to do it myself, however, for me it gets timelimit, I wonder if one could submit  a working top-down DP version as reference for others?\\n\\nthanks"
                    },
                    {
                        "username": "FinalTheory",
                        "content": "Is there any rules that I should comply with? For example, how the input data is generated and so on?"
                    },
                    {
                        "username": "xu4",
                        "content": "otherwise, in the example, if the knight has 5 initially and he can move right->right->down->up->down->down"
                    },
                    {
                        "username": "tushargupta9800",
                        "content": "![image](https://assets.leetcode.com/users/images/d82d73af-4f79-4a2f-814b-b38542a17c1e_1634581073.285247.png)\\n\\nPassed all test cases still TLE"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "From the discussion it seems the accepted approach is DP; I first started to approach this with DFS, modeling the grid as a directed graph and trying to find the min cost path from top left to bottom right. I am still trying to see if DFS is a sensible approach or a dead end.\\n\\nDid anyone else try to do this using some method besides DP/recursion?"
                    }
                ]
            },
            {
                "id": 1571380,
                "content": [
                    {
                        "username": "jrmurro",
                        "content": "How does [[-3,5]] require a mininum health of 4 when we can just use a health value of 1 from the beginning?"
                    },
                    {
                        "username": "jrmurro",
                        "content": "[@Akashdeep_Gupta](/Akashdeep_Gupta) That makes sense!"
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "if you start with health =1 and got to -3 then your health will become -2 (-3+1) hence you die, because every time the health should be greater than 0 that is minimum 1, so to tackle -3 you have to start with health =4. so when you land on -3 your health will be 1 (-3+4) means you are alive."
                    },
                    {
                        "username": "makSyak",
                        "content": "My first hard :)"
                    },
                    {
                        "username": "docentovich",
                        "content": "We must start from the end because we calculate the starting position parameter. The health parameter from which we should start, not end. We don\\'t know the beginning. We know that as a result of the path sum, the health at the end must be greater than or equal to 1. (The additional condition that the health should not be zeroed on the way is essentially an additional condition). We do not know from which parameter the health should start. We minimize the health parameter to the start. Therefore, we need to calculate it to the start because the already calculated values will be closer to the end from the current position."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "After hitting a wall when trying to build dp from the start to the end, I was very surprised that doing it the other way just magically solves all problem. However, I am still confused how you could clearly realize that right away when looking at the problem?\\nCould anyone explain me what is the characterstic of this problem that makes it a \"one-way DP\"? Like what general property does this problem have that makes it easier to solve from one way rather than the other?"
                    },
                    {
                        "username": "ttaylor27",
                        "content": "For me when solving, what led me to immediately realize that I had to start at the bottom right (end) was the idea that I needed to figure out the minimum health needed to reach the end at every given point. The easiest way to build up for the whole traversal is to start at the end, where you know the minimum health you'd need for the final square is simply however much is required for that one square. From there, as you traverse, you can find the minimum from any previous paths you have built, and eventually your minimum will be at the start once you finish your traversal. Basically, start with the minimum health required for the end square, then find the minimum required for the last 2 squares, then last 3 squares, etc. and eventually you will be back at the start with your path fully constructed. (For clarity, I used a tabulation method)"
                    },
                    {
                        "username": "Manashi",
                        "content": "You need to maintain both minimum values and sum along a path, which is not possible in O(NM). O(NM * log(INT_MAX)) will work, which uses binary search on the knight\\'s initial health, and checking if the knight can reach the princess with that initial health, and choosing left or right branch of binary search based on that."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi,\\nfor me, it is always hard to think bottom-up, and i am looking for a top-down DP solution for this question, I could not find one in the discussions, I wonder if one could submit one, I tried to do it myself, however, for me it gets timelimit, I wonder if one could submit  a working top-down DP version as reference for others?\\n\\nthanks"
                    },
                    {
                        "username": "FinalTheory",
                        "content": "Is there any rules that I should comply with? For example, how the input data is generated and so on?"
                    },
                    {
                        "username": "xu4",
                        "content": "otherwise, in the example, if the knight has 5 initially and he can move right->right->down->up->down->down"
                    },
                    {
                        "username": "tushargupta9800",
                        "content": "![image](https://assets.leetcode.com/users/images/d82d73af-4f79-4a2f-814b-b38542a17c1e_1634581073.285247.png)\\n\\nPassed all test cases still TLE"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "From the discussion it seems the accepted approach is DP; I first started to approach this with DFS, modeling the grid as a directed graph and trying to find the min cost path from top left to bottom right. I am still trying to see if DFS is a sensible approach or a dead end.\\n\\nDid anyone else try to do this using some method besides DP/recursion?"
                    }
                ]
            },
            {
                "id": 1571381,
                "content": [
                    {
                        "username": "jrmurro",
                        "content": "How does [[-3,5]] require a mininum health of 4 when we can just use a health value of 1 from the beginning?"
                    },
                    {
                        "username": "jrmurro",
                        "content": "[@Akashdeep_Gupta](/Akashdeep_Gupta) That makes sense!"
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "if you start with health =1 and got to -3 then your health will become -2 (-3+1) hence you die, because every time the health should be greater than 0 that is minimum 1, so to tackle -3 you have to start with health =4. so when you land on -3 your health will be 1 (-3+4) means you are alive."
                    },
                    {
                        "username": "makSyak",
                        "content": "My first hard :)"
                    },
                    {
                        "username": "docentovich",
                        "content": "We must start from the end because we calculate the starting position parameter. The health parameter from which we should start, not end. We don\\'t know the beginning. We know that as a result of the path sum, the health at the end must be greater than or equal to 1. (The additional condition that the health should not be zeroed on the way is essentially an additional condition). We do not know from which parameter the health should start. We minimize the health parameter to the start. Therefore, we need to calculate it to the start because the already calculated values will be closer to the end from the current position."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "After hitting a wall when trying to build dp from the start to the end, I was very surprised that doing it the other way just magically solves all problem. However, I am still confused how you could clearly realize that right away when looking at the problem?\\nCould anyone explain me what is the characterstic of this problem that makes it a \"one-way DP\"? Like what general property does this problem have that makes it easier to solve from one way rather than the other?"
                    },
                    {
                        "username": "ttaylor27",
                        "content": "For me when solving, what led me to immediately realize that I had to start at the bottom right (end) was the idea that I needed to figure out the minimum health needed to reach the end at every given point. The easiest way to build up for the whole traversal is to start at the end, where you know the minimum health you'd need for the final square is simply however much is required for that one square. From there, as you traverse, you can find the minimum from any previous paths you have built, and eventually your minimum will be at the start once you finish your traversal. Basically, start with the minimum health required for the end square, then find the minimum required for the last 2 squares, then last 3 squares, etc. and eventually you will be back at the start with your path fully constructed. (For clarity, I used a tabulation method)"
                    },
                    {
                        "username": "Manashi",
                        "content": "You need to maintain both minimum values and sum along a path, which is not possible in O(NM). O(NM * log(INT_MAX)) will work, which uses binary search on the knight\\'s initial health, and checking if the knight can reach the princess with that initial health, and choosing left or right branch of binary search based on that."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi,\\nfor me, it is always hard to think bottom-up, and i am looking for a top-down DP solution for this question, I could not find one in the discussions, I wonder if one could submit one, I tried to do it myself, however, for me it gets timelimit, I wonder if one could submit  a working top-down DP version as reference for others?\\n\\nthanks"
                    },
                    {
                        "username": "FinalTheory",
                        "content": "Is there any rules that I should comply with? For example, how the input data is generated and so on?"
                    },
                    {
                        "username": "xu4",
                        "content": "otherwise, in the example, if the knight has 5 initially and he can move right->right->down->up->down->down"
                    },
                    {
                        "username": "tushargupta9800",
                        "content": "![image](https://assets.leetcode.com/users/images/d82d73af-4f79-4a2f-814b-b38542a17c1e_1634581073.285247.png)\\n\\nPassed all test cases still TLE"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "From the discussion it seems the accepted approach is DP; I first started to approach this with DFS, modeling the grid as a directed graph and trying to find the min cost path from top left to bottom right. I am still trying to see if DFS is a sensible approach or a dead end.\\n\\nDid anyone else try to do this using some method besides DP/recursion?"
                    }
                ]
            },
            {
                "id": 1571383,
                "content": [
                    {
                        "username": "jrmurro",
                        "content": "How does [[-3,5]] require a mininum health of 4 when we can just use a health value of 1 from the beginning?"
                    },
                    {
                        "username": "jrmurro",
                        "content": "[@Akashdeep_Gupta](/Akashdeep_Gupta) That makes sense!"
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "if you start with health =1 and got to -3 then your health will become -2 (-3+1) hence you die, because every time the health should be greater than 0 that is minimum 1, so to tackle -3 you have to start with health =4. so when you land on -3 your health will be 1 (-3+4) means you are alive."
                    },
                    {
                        "username": "makSyak",
                        "content": "My first hard :)"
                    },
                    {
                        "username": "docentovich",
                        "content": "We must start from the end because we calculate the starting position parameter. The health parameter from which we should start, not end. We don\\'t know the beginning. We know that as a result of the path sum, the health at the end must be greater than or equal to 1. (The additional condition that the health should not be zeroed on the way is essentially an additional condition). We do not know from which parameter the health should start. We minimize the health parameter to the start. Therefore, we need to calculate it to the start because the already calculated values will be closer to the end from the current position."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "After hitting a wall when trying to build dp from the start to the end, I was very surprised that doing it the other way just magically solves all problem. However, I am still confused how you could clearly realize that right away when looking at the problem?\\nCould anyone explain me what is the characterstic of this problem that makes it a \"one-way DP\"? Like what general property does this problem have that makes it easier to solve from one way rather than the other?"
                    },
                    {
                        "username": "ttaylor27",
                        "content": "For me when solving, what led me to immediately realize that I had to start at the bottom right (end) was the idea that I needed to figure out the minimum health needed to reach the end at every given point. The easiest way to build up for the whole traversal is to start at the end, where you know the minimum health you'd need for the final square is simply however much is required for that one square. From there, as you traverse, you can find the minimum from any previous paths you have built, and eventually your minimum will be at the start once you finish your traversal. Basically, start with the minimum health required for the end square, then find the minimum required for the last 2 squares, then last 3 squares, etc. and eventually you will be back at the start with your path fully constructed. (For clarity, I used a tabulation method)"
                    },
                    {
                        "username": "Manashi",
                        "content": "You need to maintain both minimum values and sum along a path, which is not possible in O(NM). O(NM * log(INT_MAX)) will work, which uses binary search on the knight\\'s initial health, and checking if the knight can reach the princess with that initial health, and choosing left or right branch of binary search based on that."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi,\\nfor me, it is always hard to think bottom-up, and i am looking for a top-down DP solution for this question, I could not find one in the discussions, I wonder if one could submit one, I tried to do it myself, however, for me it gets timelimit, I wonder if one could submit  a working top-down DP version as reference for others?\\n\\nthanks"
                    },
                    {
                        "username": "FinalTheory",
                        "content": "Is there any rules that I should comply with? For example, how the input data is generated and so on?"
                    },
                    {
                        "username": "xu4",
                        "content": "otherwise, in the example, if the knight has 5 initially and he can move right->right->down->up->down->down"
                    },
                    {
                        "username": "tushargupta9800",
                        "content": "![image](https://assets.leetcode.com/users/images/d82d73af-4f79-4a2f-814b-b38542a17c1e_1634581073.285247.png)\\n\\nPassed all test cases still TLE"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "From the discussion it seems the accepted approach is DP; I first started to approach this with DFS, modeling the grid as a directed graph and trying to find the min cost path from top left to bottom right. I am still trying to see if DFS is a sensible approach or a dead end.\\n\\nDid anyone else try to do this using some method besides DP/recursion?"
                    }
                ]
            },
            {
                "id": 1575872,
                "content": [
                    {
                        "username": "jrmurro",
                        "content": "How does [[-3,5]] require a mininum health of 4 when we can just use a health value of 1 from the beginning?"
                    },
                    {
                        "username": "jrmurro",
                        "content": "[@Akashdeep_Gupta](/Akashdeep_Gupta) That makes sense!"
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "if you start with health =1 and got to -3 then your health will become -2 (-3+1) hence you die, because every time the health should be greater than 0 that is minimum 1, so to tackle -3 you have to start with health =4. so when you land on -3 your health will be 1 (-3+4) means you are alive."
                    },
                    {
                        "username": "makSyak",
                        "content": "My first hard :)"
                    },
                    {
                        "username": "docentovich",
                        "content": "We must start from the end because we calculate the starting position parameter. The health parameter from which we should start, not end. We don\\'t know the beginning. We know that as a result of the path sum, the health at the end must be greater than or equal to 1. (The additional condition that the health should not be zeroed on the way is essentially an additional condition). We do not know from which parameter the health should start. We minimize the health parameter to the start. Therefore, we need to calculate it to the start because the already calculated values will be closer to the end from the current position."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "After hitting a wall when trying to build dp from the start to the end, I was very surprised that doing it the other way just magically solves all problem. However, I am still confused how you could clearly realize that right away when looking at the problem?\\nCould anyone explain me what is the characterstic of this problem that makes it a \"one-way DP\"? Like what general property does this problem have that makes it easier to solve from one way rather than the other?"
                    },
                    {
                        "username": "ttaylor27",
                        "content": "For me when solving, what led me to immediately realize that I had to start at the bottom right (end) was the idea that I needed to figure out the minimum health needed to reach the end at every given point. The easiest way to build up for the whole traversal is to start at the end, where you know the minimum health you'd need for the final square is simply however much is required for that one square. From there, as you traverse, you can find the minimum from any previous paths you have built, and eventually your minimum will be at the start once you finish your traversal. Basically, start with the minimum health required for the end square, then find the minimum required for the last 2 squares, then last 3 squares, etc. and eventually you will be back at the start with your path fully constructed. (For clarity, I used a tabulation method)"
                    },
                    {
                        "username": "Manashi",
                        "content": "You need to maintain both minimum values and sum along a path, which is not possible in O(NM). O(NM * log(INT_MAX)) will work, which uses binary search on the knight\\'s initial health, and checking if the knight can reach the princess with that initial health, and choosing left or right branch of binary search based on that."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi,\\nfor me, it is always hard to think bottom-up, and i am looking for a top-down DP solution for this question, I could not find one in the discussions, I wonder if one could submit one, I tried to do it myself, however, for me it gets timelimit, I wonder if one could submit  a working top-down DP version as reference for others?\\n\\nthanks"
                    },
                    {
                        "username": "FinalTheory",
                        "content": "Is there any rules that I should comply with? For example, how the input data is generated and so on?"
                    },
                    {
                        "username": "xu4",
                        "content": "otherwise, in the example, if the knight has 5 initially and he can move right->right->down->up->down->down"
                    },
                    {
                        "username": "tushargupta9800",
                        "content": "![image](https://assets.leetcode.com/users/images/d82d73af-4f79-4a2f-814b-b38542a17c1e_1634581073.285247.png)\\n\\nPassed all test cases still TLE"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "From the discussion it seems the accepted approach is DP; I first started to approach this with DFS, modeling the grid as a directed graph and trying to find the min cost path from top left to bottom right. I am still trying to see if DFS is a sensible approach or a dead end.\\n\\nDid anyone else try to do this using some method besides DP/recursion?"
                    }
                ]
            },
            {
                "id": 2049722,
                "content": [
                    {
                        "username": "jrmurro",
                        "content": "How does [[-3,5]] require a mininum health of 4 when we can just use a health value of 1 from the beginning?"
                    },
                    {
                        "username": "jrmurro",
                        "content": "[@Akashdeep_Gupta](/Akashdeep_Gupta) That makes sense!"
                    },
                    {
                        "username": "Akashdeep_Gupta",
                        "content": "if you start with health =1 and got to -3 then your health will become -2 (-3+1) hence you die, because every time the health should be greater than 0 that is minimum 1, so to tackle -3 you have to start with health =4. so when you land on -3 your health will be 1 (-3+4) means you are alive."
                    },
                    {
                        "username": "makSyak",
                        "content": "My first hard :)"
                    },
                    {
                        "username": "docentovich",
                        "content": "We must start from the end because we calculate the starting position parameter. The health parameter from which we should start, not end. We don\\'t know the beginning. We know that as a result of the path sum, the health at the end must be greater than or equal to 1. (The additional condition that the health should not be zeroed on the way is essentially an additional condition). We do not know from which parameter the health should start. We minimize the health parameter to the start. Therefore, we need to calculate it to the start because the already calculated values will be closer to the end from the current position."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "After hitting a wall when trying to build dp from the start to the end, I was very surprised that doing it the other way just magically solves all problem. However, I am still confused how you could clearly realize that right away when looking at the problem?\\nCould anyone explain me what is the characterstic of this problem that makes it a \"one-way DP\"? Like what general property does this problem have that makes it easier to solve from one way rather than the other?"
                    },
                    {
                        "username": "ttaylor27",
                        "content": "For me when solving, what led me to immediately realize that I had to start at the bottom right (end) was the idea that I needed to figure out the minimum health needed to reach the end at every given point. The easiest way to build up for the whole traversal is to start at the end, where you know the minimum health you'd need for the final square is simply however much is required for that one square. From there, as you traverse, you can find the minimum from any previous paths you have built, and eventually your minimum will be at the start once you finish your traversal. Basically, start with the minimum health required for the end square, then find the minimum required for the last 2 squares, then last 3 squares, etc. and eventually you will be back at the start with your path fully constructed. (For clarity, I used a tabulation method)"
                    },
                    {
                        "username": "Manashi",
                        "content": "You need to maintain both minimum values and sum along a path, which is not possible in O(NM). O(NM * log(INT_MAX)) will work, which uses binary search on the knight\\'s initial health, and checking if the knight can reach the princess with that initial health, and choosing left or right branch of binary search based on that."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi,\\nfor me, it is always hard to think bottom-up, and i am looking for a top-down DP solution for this question, I could not find one in the discussions, I wonder if one could submit one, I tried to do it myself, however, for me it gets timelimit, I wonder if one could submit  a working top-down DP version as reference for others?\\n\\nthanks"
                    },
                    {
                        "username": "FinalTheory",
                        "content": "Is there any rules that I should comply with? For example, how the input data is generated and so on?"
                    },
                    {
                        "username": "xu4",
                        "content": "otherwise, in the example, if the knight has 5 initially and he can move right->right->down->up->down->down"
                    },
                    {
                        "username": "tushargupta9800",
                        "content": "![image](https://assets.leetcode.com/users/images/d82d73af-4f79-4a2f-814b-b38542a17c1e_1634581073.285247.png)\\n\\nPassed all test cases still TLE"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "From the discussion it seems the accepted approach is DP; I first started to approach this with DFS, modeling the grid as a directed graph and trying to find the min cost path from top left to bottom right. I am still trying to see if DFS is a sensible approach or a dead end.\\n\\nDid anyone else try to do this using some method besides DP/recursion?"
                    }
                ]
            },
            {
                "id": 2046467,
                "content": [
                    {
                        "username": "layyy",
                        "content": "hint : start from the bottom right"
                    },
                    {
                        "username": "dhruv-1010",
                        "content": "why top-down slower?\\n"
                    },
                    {
                        "username": "guavacannes",
                        "content": " `class Solution {\\n    typedef vector<vector<int>> vv;\\n    int m, n;\\n    vector<vector<int>> mv;\\n\\n    int f(vv &dun, vv &dp, int i, int j, int a) {\\n        if(i == m - 1 && j == n - 1) return (a + dun[i][j] > 0)? 1 : 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(a + dun[i][j] <= 0) return dp[i][j] = 0;\\n\\n        int flag = 0;\\n        for(int k = 0; k < 2; k++) {\\n\\n            int dx = i + mv[k][0], dy = j + mv[k][1];\\n            if(dx < m && dy < n) {\\n                if( f(dun, dp, dx, dy, a + dun[i][j]) )\\n                    flag = 1;      \\n            }   \\n\\n        }\\n\\n        return dp[i][j] = flag;\\n    }\\npublic:\\n    int calculateMinimumHP(vv& dun) {\\n        m = dun.size(), n = dun[0].size();\\n        mv = {{0, 1}, {1, 0}};\\n        int l = 1, r = 1e3 + 1;\\n        while(l < r) {\\n            vv dp(m, vector<int>(n, -1));\\n            int mid = l + (r - l) / 2;\\n            if(f(dun, dp, 0, 0, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};`\\n\\nPlease help me understand why this logic cannot give the right solution\\n\\nI make use of the dp values as a true or false (or not computed)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this is good type of dp problem, a little different"
                    },
                    {
                        "username": "ayush_way",
                        "content": "int solve(int i, int j, int req,vector<vector<int> > &nums,vector<vector<int>> &dp){\\n    //base cases\\n    if(i==0 && j==0)\\n    {\\n     int t=req-nums[0][0];\\n     if(t<=0) \\n     {        \\n         return 1;\\n     }  \\n    return t;\\n    }\\n    if(i<0 || j<0) return INT_MAX;\\n\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n   \\n    int s= req-nums[i][j];\\n    if(s<=0){\\n         int  up=solve(i-1,j,1,nums,dp);\\n       int   left=solve(i,j-1,1,nums,dp);\\n         return dp[i][j] = min(up,left);\\n    }\\n    else \\n    {\\n       int up=solve(i-1,j,req-nums[i][j],nums,dp);\\n       int  left=solve(i,j-1,req-nums[i][j],nums,dp);\\n          return dp[i][j] = min(up,left);\\n    }\\n   \\n    \\n    \\n}\\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n int n=dungeon.size(),m=dungeon[0].size();\\n    vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n    return solve(n-1,m-1,1,dungeon,dp);\\n \\n\\n\\nPlease help me !!\\n[[3,0,-3],[-3,-2,-2],[3,1,-3]] for this test case my code gives 6 but ans is 1 i dont know why is this happening please find fault in the code . Its the 31st test case out of 45.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "This problem is pain in the ass problem. Took me few months to crack it (the problem haha but who knows what is better)"
                    },
                    {
                        "username": "sonder7",
                        "content": "we should inversely visit the array for dp instead of visiting sequently. Otherwise, we should keep the first blood and can\\'t find the logic for dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> f(m, vector<int>(n, 0x3f3f3f3f));\\n        if (dungeon[m - 1][n - 1] > 0) {\\n            f[m - 1][n - 1] = 1;\\n        } else {\\n            f[m - 1][n - 1] = 1 - dungeon[m - 1][n - 1];\\n        }\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1;j >= 0; j--) {\\n                if (i < m - 1) f[i][j] = max(1, f[i + 1][j] - dungeon[i][j]);\\n                if (j < n - 1) f[i][j] = min(f[i][j], max(1, f[i][j + 1] - dungeon[i][j]));\\n            }\\n        }\\n        return f[0][0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mahendramaism",
                        "content": "Please check this test case and correct me if i am wrong. \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/10846 "
                    },
                    {
                        "username": "user2049D",
                        "content": "Good solution for your test case ([[-5, 1, 3],[30, -10, -3],[10, -5, -2]]) is 6.\\nDOWN, DOWN, RIGHT, RIGHT is the good path."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "This might help understanding the overlapping subproblems. I have explained it better [here](https://leetcode.com/problems/dungeon-game/solutions/3011638/python3-calculate-extrahealth-needed-at-each-cell/)\n\n![image.png](https://assets.leetcode.com/users/images/0d90a36f-f760-48a9-8173-5a34c17da3b7_1673065577.0750911.png)"
                    }
                ]
            },
            {
                "id": 2042294,
                "content": [
                    {
                        "username": "layyy",
                        "content": "hint : start from the bottom right"
                    },
                    {
                        "username": "dhruv-1010",
                        "content": "why top-down slower?\\n"
                    },
                    {
                        "username": "guavacannes",
                        "content": " `class Solution {\\n    typedef vector<vector<int>> vv;\\n    int m, n;\\n    vector<vector<int>> mv;\\n\\n    int f(vv &dun, vv &dp, int i, int j, int a) {\\n        if(i == m - 1 && j == n - 1) return (a + dun[i][j] > 0)? 1 : 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(a + dun[i][j] <= 0) return dp[i][j] = 0;\\n\\n        int flag = 0;\\n        for(int k = 0; k < 2; k++) {\\n\\n            int dx = i + mv[k][0], dy = j + mv[k][1];\\n            if(dx < m && dy < n) {\\n                if( f(dun, dp, dx, dy, a + dun[i][j]) )\\n                    flag = 1;      \\n            }   \\n\\n        }\\n\\n        return dp[i][j] = flag;\\n    }\\npublic:\\n    int calculateMinimumHP(vv& dun) {\\n        m = dun.size(), n = dun[0].size();\\n        mv = {{0, 1}, {1, 0}};\\n        int l = 1, r = 1e3 + 1;\\n        while(l < r) {\\n            vv dp(m, vector<int>(n, -1));\\n            int mid = l + (r - l) / 2;\\n            if(f(dun, dp, 0, 0, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};`\\n\\nPlease help me understand why this logic cannot give the right solution\\n\\nI make use of the dp values as a true or false (or not computed)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this is good type of dp problem, a little different"
                    },
                    {
                        "username": "ayush_way",
                        "content": "int solve(int i, int j, int req,vector<vector<int> > &nums,vector<vector<int>> &dp){\\n    //base cases\\n    if(i==0 && j==0)\\n    {\\n     int t=req-nums[0][0];\\n     if(t<=0) \\n     {        \\n         return 1;\\n     }  \\n    return t;\\n    }\\n    if(i<0 || j<0) return INT_MAX;\\n\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n   \\n    int s= req-nums[i][j];\\n    if(s<=0){\\n         int  up=solve(i-1,j,1,nums,dp);\\n       int   left=solve(i,j-1,1,nums,dp);\\n         return dp[i][j] = min(up,left);\\n    }\\n    else \\n    {\\n       int up=solve(i-1,j,req-nums[i][j],nums,dp);\\n       int  left=solve(i,j-1,req-nums[i][j],nums,dp);\\n          return dp[i][j] = min(up,left);\\n    }\\n   \\n    \\n    \\n}\\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n int n=dungeon.size(),m=dungeon[0].size();\\n    vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n    return solve(n-1,m-1,1,dungeon,dp);\\n \\n\\n\\nPlease help me !!\\n[[3,0,-3],[-3,-2,-2],[3,1,-3]] for this test case my code gives 6 but ans is 1 i dont know why is this happening please find fault in the code . Its the 31st test case out of 45.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "This problem is pain in the ass problem. Took me few months to crack it (the problem haha but who knows what is better)"
                    },
                    {
                        "username": "sonder7",
                        "content": "we should inversely visit the array for dp instead of visiting sequently. Otherwise, we should keep the first blood and can\\'t find the logic for dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> f(m, vector<int>(n, 0x3f3f3f3f));\\n        if (dungeon[m - 1][n - 1] > 0) {\\n            f[m - 1][n - 1] = 1;\\n        } else {\\n            f[m - 1][n - 1] = 1 - dungeon[m - 1][n - 1];\\n        }\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1;j >= 0; j--) {\\n                if (i < m - 1) f[i][j] = max(1, f[i + 1][j] - dungeon[i][j]);\\n                if (j < n - 1) f[i][j] = min(f[i][j], max(1, f[i][j + 1] - dungeon[i][j]));\\n            }\\n        }\\n        return f[0][0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mahendramaism",
                        "content": "Please check this test case and correct me if i am wrong. \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/10846 "
                    },
                    {
                        "username": "user2049D",
                        "content": "Good solution for your test case ([[-5, 1, 3],[30, -10, -3],[10, -5, -2]]) is 6.\\nDOWN, DOWN, RIGHT, RIGHT is the good path."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "This might help understanding the overlapping subproblems. I have explained it better [here](https://leetcode.com/problems/dungeon-game/solutions/3011638/python3-calculate-extrahealth-needed-at-each-cell/)\n\n![image.png](https://assets.leetcode.com/users/images/0d90a36f-f760-48a9-8173-5a34c17da3b7_1673065577.0750911.png)"
                    }
                ]
            },
            {
                "id": 2042160,
                "content": [
                    {
                        "username": "layyy",
                        "content": "hint : start from the bottom right"
                    },
                    {
                        "username": "dhruv-1010",
                        "content": "why top-down slower?\\n"
                    },
                    {
                        "username": "guavacannes",
                        "content": " `class Solution {\\n    typedef vector<vector<int>> vv;\\n    int m, n;\\n    vector<vector<int>> mv;\\n\\n    int f(vv &dun, vv &dp, int i, int j, int a) {\\n        if(i == m - 1 && j == n - 1) return (a + dun[i][j] > 0)? 1 : 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(a + dun[i][j] <= 0) return dp[i][j] = 0;\\n\\n        int flag = 0;\\n        for(int k = 0; k < 2; k++) {\\n\\n            int dx = i + mv[k][0], dy = j + mv[k][1];\\n            if(dx < m && dy < n) {\\n                if( f(dun, dp, dx, dy, a + dun[i][j]) )\\n                    flag = 1;      \\n            }   \\n\\n        }\\n\\n        return dp[i][j] = flag;\\n    }\\npublic:\\n    int calculateMinimumHP(vv& dun) {\\n        m = dun.size(), n = dun[0].size();\\n        mv = {{0, 1}, {1, 0}};\\n        int l = 1, r = 1e3 + 1;\\n        while(l < r) {\\n            vv dp(m, vector<int>(n, -1));\\n            int mid = l + (r - l) / 2;\\n            if(f(dun, dp, 0, 0, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};`\\n\\nPlease help me understand why this logic cannot give the right solution\\n\\nI make use of the dp values as a true or false (or not computed)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this is good type of dp problem, a little different"
                    },
                    {
                        "username": "ayush_way",
                        "content": "int solve(int i, int j, int req,vector<vector<int> > &nums,vector<vector<int>> &dp){\\n    //base cases\\n    if(i==0 && j==0)\\n    {\\n     int t=req-nums[0][0];\\n     if(t<=0) \\n     {        \\n         return 1;\\n     }  \\n    return t;\\n    }\\n    if(i<0 || j<0) return INT_MAX;\\n\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n   \\n    int s= req-nums[i][j];\\n    if(s<=0){\\n         int  up=solve(i-1,j,1,nums,dp);\\n       int   left=solve(i,j-1,1,nums,dp);\\n         return dp[i][j] = min(up,left);\\n    }\\n    else \\n    {\\n       int up=solve(i-1,j,req-nums[i][j],nums,dp);\\n       int  left=solve(i,j-1,req-nums[i][j],nums,dp);\\n          return dp[i][j] = min(up,left);\\n    }\\n   \\n    \\n    \\n}\\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n int n=dungeon.size(),m=dungeon[0].size();\\n    vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n    return solve(n-1,m-1,1,dungeon,dp);\\n \\n\\n\\nPlease help me !!\\n[[3,0,-3],[-3,-2,-2],[3,1,-3]] for this test case my code gives 6 but ans is 1 i dont know why is this happening please find fault in the code . Its the 31st test case out of 45.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "This problem is pain in the ass problem. Took me few months to crack it (the problem haha but who knows what is better)"
                    },
                    {
                        "username": "sonder7",
                        "content": "we should inversely visit the array for dp instead of visiting sequently. Otherwise, we should keep the first blood and can\\'t find the logic for dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> f(m, vector<int>(n, 0x3f3f3f3f));\\n        if (dungeon[m - 1][n - 1] > 0) {\\n            f[m - 1][n - 1] = 1;\\n        } else {\\n            f[m - 1][n - 1] = 1 - dungeon[m - 1][n - 1];\\n        }\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1;j >= 0; j--) {\\n                if (i < m - 1) f[i][j] = max(1, f[i + 1][j] - dungeon[i][j]);\\n                if (j < n - 1) f[i][j] = min(f[i][j], max(1, f[i][j + 1] - dungeon[i][j]));\\n            }\\n        }\\n        return f[0][0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mahendramaism",
                        "content": "Please check this test case and correct me if i am wrong. \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/10846 "
                    },
                    {
                        "username": "user2049D",
                        "content": "Good solution for your test case ([[-5, 1, 3],[30, -10, -3],[10, -5, -2]]) is 6.\\nDOWN, DOWN, RIGHT, RIGHT is the good path."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "This might help understanding the overlapping subproblems. I have explained it better [here](https://leetcode.com/problems/dungeon-game/solutions/3011638/python3-calculate-extrahealth-needed-at-each-cell/)\n\n![image.png](https://assets.leetcode.com/users/images/0d90a36f-f760-48a9-8173-5a34c17da3b7_1673065577.0750911.png)"
                    }
                ]
            },
            {
                "id": 2016848,
                "content": [
                    {
                        "username": "layyy",
                        "content": "hint : start from the bottom right"
                    },
                    {
                        "username": "dhruv-1010",
                        "content": "why top-down slower?\\n"
                    },
                    {
                        "username": "guavacannes",
                        "content": " `class Solution {\\n    typedef vector<vector<int>> vv;\\n    int m, n;\\n    vector<vector<int>> mv;\\n\\n    int f(vv &dun, vv &dp, int i, int j, int a) {\\n        if(i == m - 1 && j == n - 1) return (a + dun[i][j] > 0)? 1 : 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(a + dun[i][j] <= 0) return dp[i][j] = 0;\\n\\n        int flag = 0;\\n        for(int k = 0; k < 2; k++) {\\n\\n            int dx = i + mv[k][0], dy = j + mv[k][1];\\n            if(dx < m && dy < n) {\\n                if( f(dun, dp, dx, dy, a + dun[i][j]) )\\n                    flag = 1;      \\n            }   \\n\\n        }\\n\\n        return dp[i][j] = flag;\\n    }\\npublic:\\n    int calculateMinimumHP(vv& dun) {\\n        m = dun.size(), n = dun[0].size();\\n        mv = {{0, 1}, {1, 0}};\\n        int l = 1, r = 1e3 + 1;\\n        while(l < r) {\\n            vv dp(m, vector<int>(n, -1));\\n            int mid = l + (r - l) / 2;\\n            if(f(dun, dp, 0, 0, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};`\\n\\nPlease help me understand why this logic cannot give the right solution\\n\\nI make use of the dp values as a true or false (or not computed)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this is good type of dp problem, a little different"
                    },
                    {
                        "username": "ayush_way",
                        "content": "int solve(int i, int j, int req,vector<vector<int> > &nums,vector<vector<int>> &dp){\\n    //base cases\\n    if(i==0 && j==0)\\n    {\\n     int t=req-nums[0][0];\\n     if(t<=0) \\n     {        \\n         return 1;\\n     }  \\n    return t;\\n    }\\n    if(i<0 || j<0) return INT_MAX;\\n\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n   \\n    int s= req-nums[i][j];\\n    if(s<=0){\\n         int  up=solve(i-1,j,1,nums,dp);\\n       int   left=solve(i,j-1,1,nums,dp);\\n         return dp[i][j] = min(up,left);\\n    }\\n    else \\n    {\\n       int up=solve(i-1,j,req-nums[i][j],nums,dp);\\n       int  left=solve(i,j-1,req-nums[i][j],nums,dp);\\n          return dp[i][j] = min(up,left);\\n    }\\n   \\n    \\n    \\n}\\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n int n=dungeon.size(),m=dungeon[0].size();\\n    vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n    return solve(n-1,m-1,1,dungeon,dp);\\n \\n\\n\\nPlease help me !!\\n[[3,0,-3],[-3,-2,-2],[3,1,-3]] for this test case my code gives 6 but ans is 1 i dont know why is this happening please find fault in the code . Its the 31st test case out of 45.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "This problem is pain in the ass problem. Took me few months to crack it (the problem haha but who knows what is better)"
                    },
                    {
                        "username": "sonder7",
                        "content": "we should inversely visit the array for dp instead of visiting sequently. Otherwise, we should keep the first blood and can\\'t find the logic for dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> f(m, vector<int>(n, 0x3f3f3f3f));\\n        if (dungeon[m - 1][n - 1] > 0) {\\n            f[m - 1][n - 1] = 1;\\n        } else {\\n            f[m - 1][n - 1] = 1 - dungeon[m - 1][n - 1];\\n        }\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1;j >= 0; j--) {\\n                if (i < m - 1) f[i][j] = max(1, f[i + 1][j] - dungeon[i][j]);\\n                if (j < n - 1) f[i][j] = min(f[i][j], max(1, f[i][j + 1] - dungeon[i][j]));\\n            }\\n        }\\n        return f[0][0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mahendramaism",
                        "content": "Please check this test case and correct me if i am wrong. \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/10846 "
                    },
                    {
                        "username": "user2049D",
                        "content": "Good solution for your test case ([[-5, 1, 3],[30, -10, -3],[10, -5, -2]]) is 6.\\nDOWN, DOWN, RIGHT, RIGHT is the good path."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "This might help understanding the overlapping subproblems. I have explained it better [here](https://leetcode.com/problems/dungeon-game/solutions/3011638/python3-calculate-extrahealth-needed-at-each-cell/)\n\n![image.png](https://assets.leetcode.com/users/images/0d90a36f-f760-48a9-8173-5a34c17da3b7_1673065577.0750911.png)"
                    }
                ]
            },
            {
                "id": 1966404,
                "content": [
                    {
                        "username": "layyy",
                        "content": "hint : start from the bottom right"
                    },
                    {
                        "username": "dhruv-1010",
                        "content": "why top-down slower?\\n"
                    },
                    {
                        "username": "guavacannes",
                        "content": " `class Solution {\\n    typedef vector<vector<int>> vv;\\n    int m, n;\\n    vector<vector<int>> mv;\\n\\n    int f(vv &dun, vv &dp, int i, int j, int a) {\\n        if(i == m - 1 && j == n - 1) return (a + dun[i][j] > 0)? 1 : 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(a + dun[i][j] <= 0) return dp[i][j] = 0;\\n\\n        int flag = 0;\\n        for(int k = 0; k < 2; k++) {\\n\\n            int dx = i + mv[k][0], dy = j + mv[k][1];\\n            if(dx < m && dy < n) {\\n                if( f(dun, dp, dx, dy, a + dun[i][j]) )\\n                    flag = 1;      \\n            }   \\n\\n        }\\n\\n        return dp[i][j] = flag;\\n    }\\npublic:\\n    int calculateMinimumHP(vv& dun) {\\n        m = dun.size(), n = dun[0].size();\\n        mv = {{0, 1}, {1, 0}};\\n        int l = 1, r = 1e3 + 1;\\n        while(l < r) {\\n            vv dp(m, vector<int>(n, -1));\\n            int mid = l + (r - l) / 2;\\n            if(f(dun, dp, 0, 0, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};`\\n\\nPlease help me understand why this logic cannot give the right solution\\n\\nI make use of the dp values as a true or false (or not computed)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this is good type of dp problem, a little different"
                    },
                    {
                        "username": "ayush_way",
                        "content": "int solve(int i, int j, int req,vector<vector<int> > &nums,vector<vector<int>> &dp){\\n    //base cases\\n    if(i==0 && j==0)\\n    {\\n     int t=req-nums[0][0];\\n     if(t<=0) \\n     {        \\n         return 1;\\n     }  \\n    return t;\\n    }\\n    if(i<0 || j<0) return INT_MAX;\\n\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n   \\n    int s= req-nums[i][j];\\n    if(s<=0){\\n         int  up=solve(i-1,j,1,nums,dp);\\n       int   left=solve(i,j-1,1,nums,dp);\\n         return dp[i][j] = min(up,left);\\n    }\\n    else \\n    {\\n       int up=solve(i-1,j,req-nums[i][j],nums,dp);\\n       int  left=solve(i,j-1,req-nums[i][j],nums,dp);\\n          return dp[i][j] = min(up,left);\\n    }\\n   \\n    \\n    \\n}\\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n int n=dungeon.size(),m=dungeon[0].size();\\n    vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n    return solve(n-1,m-1,1,dungeon,dp);\\n \\n\\n\\nPlease help me !!\\n[[3,0,-3],[-3,-2,-2],[3,1,-3]] for this test case my code gives 6 but ans is 1 i dont know why is this happening please find fault in the code . Its the 31st test case out of 45.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "This problem is pain in the ass problem. Took me few months to crack it (the problem haha but who knows what is better)"
                    },
                    {
                        "username": "sonder7",
                        "content": "we should inversely visit the array for dp instead of visiting sequently. Otherwise, we should keep the first blood and can\\'t find the logic for dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> f(m, vector<int>(n, 0x3f3f3f3f));\\n        if (dungeon[m - 1][n - 1] > 0) {\\n            f[m - 1][n - 1] = 1;\\n        } else {\\n            f[m - 1][n - 1] = 1 - dungeon[m - 1][n - 1];\\n        }\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1;j >= 0; j--) {\\n                if (i < m - 1) f[i][j] = max(1, f[i + 1][j] - dungeon[i][j]);\\n                if (j < n - 1) f[i][j] = min(f[i][j], max(1, f[i][j + 1] - dungeon[i][j]));\\n            }\\n        }\\n        return f[0][0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mahendramaism",
                        "content": "Please check this test case and correct me if i am wrong. \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/10846 "
                    },
                    {
                        "username": "user2049D",
                        "content": "Good solution for your test case ([[-5, 1, 3],[30, -10, -3],[10, -5, -2]]) is 6.\\nDOWN, DOWN, RIGHT, RIGHT is the good path."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "This might help understanding the overlapping subproblems. I have explained it better [here](https://leetcode.com/problems/dungeon-game/solutions/3011638/python3-calculate-extrahealth-needed-at-each-cell/)\n\n![image.png](https://assets.leetcode.com/users/images/0d90a36f-f760-48a9-8173-5a34c17da3b7_1673065577.0750911.png)"
                    }
                ]
            },
            {
                "id": 1833523,
                "content": [
                    {
                        "username": "layyy",
                        "content": "hint : start from the bottom right"
                    },
                    {
                        "username": "dhruv-1010",
                        "content": "why top-down slower?\\n"
                    },
                    {
                        "username": "guavacannes",
                        "content": " `class Solution {\\n    typedef vector<vector<int>> vv;\\n    int m, n;\\n    vector<vector<int>> mv;\\n\\n    int f(vv &dun, vv &dp, int i, int j, int a) {\\n        if(i == m - 1 && j == n - 1) return (a + dun[i][j] > 0)? 1 : 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(a + dun[i][j] <= 0) return dp[i][j] = 0;\\n\\n        int flag = 0;\\n        for(int k = 0; k < 2; k++) {\\n\\n            int dx = i + mv[k][0], dy = j + mv[k][1];\\n            if(dx < m && dy < n) {\\n                if( f(dun, dp, dx, dy, a + dun[i][j]) )\\n                    flag = 1;      \\n            }   \\n\\n        }\\n\\n        return dp[i][j] = flag;\\n    }\\npublic:\\n    int calculateMinimumHP(vv& dun) {\\n        m = dun.size(), n = dun[0].size();\\n        mv = {{0, 1}, {1, 0}};\\n        int l = 1, r = 1e3 + 1;\\n        while(l < r) {\\n            vv dp(m, vector<int>(n, -1));\\n            int mid = l + (r - l) / 2;\\n            if(f(dun, dp, 0, 0, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};`\\n\\nPlease help me understand why this logic cannot give the right solution\\n\\nI make use of the dp values as a true or false (or not computed)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this is good type of dp problem, a little different"
                    },
                    {
                        "username": "ayush_way",
                        "content": "int solve(int i, int j, int req,vector<vector<int> > &nums,vector<vector<int>> &dp){\\n    //base cases\\n    if(i==0 && j==0)\\n    {\\n     int t=req-nums[0][0];\\n     if(t<=0) \\n     {        \\n         return 1;\\n     }  \\n    return t;\\n    }\\n    if(i<0 || j<0) return INT_MAX;\\n\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n   \\n    int s= req-nums[i][j];\\n    if(s<=0){\\n         int  up=solve(i-1,j,1,nums,dp);\\n       int   left=solve(i,j-1,1,nums,dp);\\n         return dp[i][j] = min(up,left);\\n    }\\n    else \\n    {\\n       int up=solve(i-1,j,req-nums[i][j],nums,dp);\\n       int  left=solve(i,j-1,req-nums[i][j],nums,dp);\\n          return dp[i][j] = min(up,left);\\n    }\\n   \\n    \\n    \\n}\\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n int n=dungeon.size(),m=dungeon[0].size();\\n    vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n    return solve(n-1,m-1,1,dungeon,dp);\\n \\n\\n\\nPlease help me !!\\n[[3,0,-3],[-3,-2,-2],[3,1,-3]] for this test case my code gives 6 but ans is 1 i dont know why is this happening please find fault in the code . Its the 31st test case out of 45.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "This problem is pain in the ass problem. Took me few months to crack it (the problem haha but who knows what is better)"
                    },
                    {
                        "username": "sonder7",
                        "content": "we should inversely visit the array for dp instead of visiting sequently. Otherwise, we should keep the first blood and can\\'t find the logic for dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> f(m, vector<int>(n, 0x3f3f3f3f));\\n        if (dungeon[m - 1][n - 1] > 0) {\\n            f[m - 1][n - 1] = 1;\\n        } else {\\n            f[m - 1][n - 1] = 1 - dungeon[m - 1][n - 1];\\n        }\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1;j >= 0; j--) {\\n                if (i < m - 1) f[i][j] = max(1, f[i + 1][j] - dungeon[i][j]);\\n                if (j < n - 1) f[i][j] = min(f[i][j], max(1, f[i][j + 1] - dungeon[i][j]));\\n            }\\n        }\\n        return f[0][0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mahendramaism",
                        "content": "Please check this test case and correct me if i am wrong. \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/10846 "
                    },
                    {
                        "username": "user2049D",
                        "content": "Good solution for your test case ([[-5, 1, 3],[30, -10, -3],[10, -5, -2]]) is 6.\\nDOWN, DOWN, RIGHT, RIGHT is the good path."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "This might help understanding the overlapping subproblems. I have explained it better [here](https://leetcode.com/problems/dungeon-game/solutions/3011638/python3-calculate-extrahealth-needed-at-each-cell/)\n\n![image.png](https://assets.leetcode.com/users/images/0d90a36f-f760-48a9-8173-5a34c17da3b7_1673065577.0750911.png)"
                    }
                ]
            },
            {
                "id": 1802751,
                "content": [
                    {
                        "username": "layyy",
                        "content": "hint : start from the bottom right"
                    },
                    {
                        "username": "dhruv-1010",
                        "content": "why top-down slower?\\n"
                    },
                    {
                        "username": "guavacannes",
                        "content": " `class Solution {\\n    typedef vector<vector<int>> vv;\\n    int m, n;\\n    vector<vector<int>> mv;\\n\\n    int f(vv &dun, vv &dp, int i, int j, int a) {\\n        if(i == m - 1 && j == n - 1) return (a + dun[i][j] > 0)? 1 : 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(a + dun[i][j] <= 0) return dp[i][j] = 0;\\n\\n        int flag = 0;\\n        for(int k = 0; k < 2; k++) {\\n\\n            int dx = i + mv[k][0], dy = j + mv[k][1];\\n            if(dx < m && dy < n) {\\n                if( f(dun, dp, dx, dy, a + dun[i][j]) )\\n                    flag = 1;      \\n            }   \\n\\n        }\\n\\n        return dp[i][j] = flag;\\n    }\\npublic:\\n    int calculateMinimumHP(vv& dun) {\\n        m = dun.size(), n = dun[0].size();\\n        mv = {{0, 1}, {1, 0}};\\n        int l = 1, r = 1e3 + 1;\\n        while(l < r) {\\n            vv dp(m, vector<int>(n, -1));\\n            int mid = l + (r - l) / 2;\\n            if(f(dun, dp, 0, 0, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};`\\n\\nPlease help me understand why this logic cannot give the right solution\\n\\nI make use of the dp values as a true or false (or not computed)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this is good type of dp problem, a little different"
                    },
                    {
                        "username": "ayush_way",
                        "content": "int solve(int i, int j, int req,vector<vector<int> > &nums,vector<vector<int>> &dp){\\n    //base cases\\n    if(i==0 && j==0)\\n    {\\n     int t=req-nums[0][0];\\n     if(t<=0) \\n     {        \\n         return 1;\\n     }  \\n    return t;\\n    }\\n    if(i<0 || j<0) return INT_MAX;\\n\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n   \\n    int s= req-nums[i][j];\\n    if(s<=0){\\n         int  up=solve(i-1,j,1,nums,dp);\\n       int   left=solve(i,j-1,1,nums,dp);\\n         return dp[i][j] = min(up,left);\\n    }\\n    else \\n    {\\n       int up=solve(i-1,j,req-nums[i][j],nums,dp);\\n       int  left=solve(i,j-1,req-nums[i][j],nums,dp);\\n          return dp[i][j] = min(up,left);\\n    }\\n   \\n    \\n    \\n}\\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n int n=dungeon.size(),m=dungeon[0].size();\\n    vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n    return solve(n-1,m-1,1,dungeon,dp);\\n \\n\\n\\nPlease help me !!\\n[[3,0,-3],[-3,-2,-2],[3,1,-3]] for this test case my code gives 6 but ans is 1 i dont know why is this happening please find fault in the code . Its the 31st test case out of 45.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "This problem is pain in the ass problem. Took me few months to crack it (the problem haha but who knows what is better)"
                    },
                    {
                        "username": "sonder7",
                        "content": "we should inversely visit the array for dp instead of visiting sequently. Otherwise, we should keep the first blood and can\\'t find the logic for dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> f(m, vector<int>(n, 0x3f3f3f3f));\\n        if (dungeon[m - 1][n - 1] > 0) {\\n            f[m - 1][n - 1] = 1;\\n        } else {\\n            f[m - 1][n - 1] = 1 - dungeon[m - 1][n - 1];\\n        }\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1;j >= 0; j--) {\\n                if (i < m - 1) f[i][j] = max(1, f[i + 1][j] - dungeon[i][j]);\\n                if (j < n - 1) f[i][j] = min(f[i][j], max(1, f[i][j + 1] - dungeon[i][j]));\\n            }\\n        }\\n        return f[0][0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mahendramaism",
                        "content": "Please check this test case and correct me if i am wrong. \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/10846 "
                    },
                    {
                        "username": "user2049D",
                        "content": "Good solution for your test case ([[-5, 1, 3],[30, -10, -3],[10, -5, -2]]) is 6.\\nDOWN, DOWN, RIGHT, RIGHT is the good path."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "This might help understanding the overlapping subproblems. I have explained it better [here](https://leetcode.com/problems/dungeon-game/solutions/3011638/python3-calculate-extrahealth-needed-at-each-cell/)\n\n![image.png](https://assets.leetcode.com/users/images/0d90a36f-f760-48a9-8173-5a34c17da3b7_1673065577.0750911.png)"
                    }
                ]
            },
            {
                "id": 1756387,
                "content": [
                    {
                        "username": "layyy",
                        "content": "hint : start from the bottom right"
                    },
                    {
                        "username": "dhruv-1010",
                        "content": "why top-down slower?\\n"
                    },
                    {
                        "username": "guavacannes",
                        "content": " `class Solution {\\n    typedef vector<vector<int>> vv;\\n    int m, n;\\n    vector<vector<int>> mv;\\n\\n    int f(vv &dun, vv &dp, int i, int j, int a) {\\n        if(i == m - 1 && j == n - 1) return (a + dun[i][j] > 0)? 1 : 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(a + dun[i][j] <= 0) return dp[i][j] = 0;\\n\\n        int flag = 0;\\n        for(int k = 0; k < 2; k++) {\\n\\n            int dx = i + mv[k][0], dy = j + mv[k][1];\\n            if(dx < m && dy < n) {\\n                if( f(dun, dp, dx, dy, a + dun[i][j]) )\\n                    flag = 1;      \\n            }   \\n\\n        }\\n\\n        return dp[i][j] = flag;\\n    }\\npublic:\\n    int calculateMinimumHP(vv& dun) {\\n        m = dun.size(), n = dun[0].size();\\n        mv = {{0, 1}, {1, 0}};\\n        int l = 1, r = 1e3 + 1;\\n        while(l < r) {\\n            vv dp(m, vector<int>(n, -1));\\n            int mid = l + (r - l) / 2;\\n            if(f(dun, dp, 0, 0, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};`\\n\\nPlease help me understand why this logic cannot give the right solution\\n\\nI make use of the dp values as a true or false (or not computed)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this is good type of dp problem, a little different"
                    },
                    {
                        "username": "ayush_way",
                        "content": "int solve(int i, int j, int req,vector<vector<int> > &nums,vector<vector<int>> &dp){\\n    //base cases\\n    if(i==0 && j==0)\\n    {\\n     int t=req-nums[0][0];\\n     if(t<=0) \\n     {        \\n         return 1;\\n     }  \\n    return t;\\n    }\\n    if(i<0 || j<0) return INT_MAX;\\n\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n   \\n    int s= req-nums[i][j];\\n    if(s<=0){\\n         int  up=solve(i-1,j,1,nums,dp);\\n       int   left=solve(i,j-1,1,nums,dp);\\n         return dp[i][j] = min(up,left);\\n    }\\n    else \\n    {\\n       int up=solve(i-1,j,req-nums[i][j],nums,dp);\\n       int  left=solve(i,j-1,req-nums[i][j],nums,dp);\\n          return dp[i][j] = min(up,left);\\n    }\\n   \\n    \\n    \\n}\\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n int n=dungeon.size(),m=dungeon[0].size();\\n    vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n    return solve(n-1,m-1,1,dungeon,dp);\\n \\n\\n\\nPlease help me !!\\n[[3,0,-3],[-3,-2,-2],[3,1,-3]] for this test case my code gives 6 but ans is 1 i dont know why is this happening please find fault in the code . Its the 31st test case out of 45.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "This problem is pain in the ass problem. Took me few months to crack it (the problem haha but who knows what is better)"
                    },
                    {
                        "username": "sonder7",
                        "content": "we should inversely visit the array for dp instead of visiting sequently. Otherwise, we should keep the first blood and can\\'t find the logic for dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> f(m, vector<int>(n, 0x3f3f3f3f));\\n        if (dungeon[m - 1][n - 1] > 0) {\\n            f[m - 1][n - 1] = 1;\\n        } else {\\n            f[m - 1][n - 1] = 1 - dungeon[m - 1][n - 1];\\n        }\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1;j >= 0; j--) {\\n                if (i < m - 1) f[i][j] = max(1, f[i + 1][j] - dungeon[i][j]);\\n                if (j < n - 1) f[i][j] = min(f[i][j], max(1, f[i][j + 1] - dungeon[i][j]));\\n            }\\n        }\\n        return f[0][0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mahendramaism",
                        "content": "Please check this test case and correct me if i am wrong. \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/10846 "
                    },
                    {
                        "username": "user2049D",
                        "content": "Good solution for your test case ([[-5, 1, 3],[30, -10, -3],[10, -5, -2]]) is 6.\\nDOWN, DOWN, RIGHT, RIGHT is the good path."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "This might help understanding the overlapping subproblems. I have explained it better [here](https://leetcode.com/problems/dungeon-game/solutions/3011638/python3-calculate-extrahealth-needed-at-each-cell/)\n\n![image.png](https://assets.leetcode.com/users/images/0d90a36f-f760-48a9-8173-5a34c17da3b7_1673065577.0750911.png)"
                    }
                ]
            },
            {
                "id": 1747631,
                "content": [
                    {
                        "username": "layyy",
                        "content": "hint : start from the bottom right"
                    },
                    {
                        "username": "dhruv-1010",
                        "content": "why top-down slower?\\n"
                    },
                    {
                        "username": "guavacannes",
                        "content": " `class Solution {\\n    typedef vector<vector<int>> vv;\\n    int m, n;\\n    vector<vector<int>> mv;\\n\\n    int f(vv &dun, vv &dp, int i, int j, int a) {\\n        if(i == m - 1 && j == n - 1) return (a + dun[i][j] > 0)? 1 : 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(a + dun[i][j] <= 0) return dp[i][j] = 0;\\n\\n        int flag = 0;\\n        for(int k = 0; k < 2; k++) {\\n\\n            int dx = i + mv[k][0], dy = j + mv[k][1];\\n            if(dx < m && dy < n) {\\n                if( f(dun, dp, dx, dy, a + dun[i][j]) )\\n                    flag = 1;      \\n            }   \\n\\n        }\\n\\n        return dp[i][j] = flag;\\n    }\\npublic:\\n    int calculateMinimumHP(vv& dun) {\\n        m = dun.size(), n = dun[0].size();\\n        mv = {{0, 1}, {1, 0}};\\n        int l = 1, r = 1e3 + 1;\\n        while(l < r) {\\n            vv dp(m, vector<int>(n, -1));\\n            int mid = l + (r - l) / 2;\\n            if(f(dun, dp, 0, 0, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};`\\n\\nPlease help me understand why this logic cannot give the right solution\\n\\nI make use of the dp values as a true or false (or not computed)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this is good type of dp problem, a little different"
                    },
                    {
                        "username": "ayush_way",
                        "content": "int solve(int i, int j, int req,vector<vector<int> > &nums,vector<vector<int>> &dp){\\n    //base cases\\n    if(i==0 && j==0)\\n    {\\n     int t=req-nums[0][0];\\n     if(t<=0) \\n     {        \\n         return 1;\\n     }  \\n    return t;\\n    }\\n    if(i<0 || j<0) return INT_MAX;\\n\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n   \\n    int s= req-nums[i][j];\\n    if(s<=0){\\n         int  up=solve(i-1,j,1,nums,dp);\\n       int   left=solve(i,j-1,1,nums,dp);\\n         return dp[i][j] = min(up,left);\\n    }\\n    else \\n    {\\n       int up=solve(i-1,j,req-nums[i][j],nums,dp);\\n       int  left=solve(i,j-1,req-nums[i][j],nums,dp);\\n          return dp[i][j] = min(up,left);\\n    }\\n   \\n    \\n    \\n}\\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n int n=dungeon.size(),m=dungeon[0].size();\\n    vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n    return solve(n-1,m-1,1,dungeon,dp);\\n \\n\\n\\nPlease help me !!\\n[[3,0,-3],[-3,-2,-2],[3,1,-3]] for this test case my code gives 6 but ans is 1 i dont know why is this happening please find fault in the code . Its the 31st test case out of 45.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "This problem is pain in the ass problem. Took me few months to crack it (the problem haha but who knows what is better)"
                    },
                    {
                        "username": "sonder7",
                        "content": "we should inversely visit the array for dp instead of visiting sequently. Otherwise, we should keep the first blood and can\\'t find the logic for dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> f(m, vector<int>(n, 0x3f3f3f3f));\\n        if (dungeon[m - 1][n - 1] > 0) {\\n            f[m - 1][n - 1] = 1;\\n        } else {\\n            f[m - 1][n - 1] = 1 - dungeon[m - 1][n - 1];\\n        }\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1;j >= 0; j--) {\\n                if (i < m - 1) f[i][j] = max(1, f[i + 1][j] - dungeon[i][j]);\\n                if (j < n - 1) f[i][j] = min(f[i][j], max(1, f[i][j + 1] - dungeon[i][j]));\\n            }\\n        }\\n        return f[0][0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mahendramaism",
                        "content": "Please check this test case and correct me if i am wrong. \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/10846 "
                    },
                    {
                        "username": "user2049D",
                        "content": "Good solution for your test case ([[-5, 1, 3],[30, -10, -3],[10, -5, -2]]) is 6.\\nDOWN, DOWN, RIGHT, RIGHT is the good path."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "This might help understanding the overlapping subproblems. I have explained it better [here](https://leetcode.com/problems/dungeon-game/solutions/3011638/python3-calculate-extrahealth-needed-at-each-cell/)\n\n![image.png](https://assets.leetcode.com/users/images/0d90a36f-f760-48a9-8173-5a34c17da3b7_1673065577.0750911.png)"
                    }
                ]
            },
            {
                "id": 1745676,
                "content": [
                    {
                        "username": "layyy",
                        "content": "hint : start from the bottom right"
                    },
                    {
                        "username": "dhruv-1010",
                        "content": "why top-down slower?\\n"
                    },
                    {
                        "username": "guavacannes",
                        "content": " `class Solution {\\n    typedef vector<vector<int>> vv;\\n    int m, n;\\n    vector<vector<int>> mv;\\n\\n    int f(vv &dun, vv &dp, int i, int j, int a) {\\n        if(i == m - 1 && j == n - 1) return (a + dun[i][j] > 0)? 1 : 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(a + dun[i][j] <= 0) return dp[i][j] = 0;\\n\\n        int flag = 0;\\n        for(int k = 0; k < 2; k++) {\\n\\n            int dx = i + mv[k][0], dy = j + mv[k][1];\\n            if(dx < m && dy < n) {\\n                if( f(dun, dp, dx, dy, a + dun[i][j]) )\\n                    flag = 1;      \\n            }   \\n\\n        }\\n\\n        return dp[i][j] = flag;\\n    }\\npublic:\\n    int calculateMinimumHP(vv& dun) {\\n        m = dun.size(), n = dun[0].size();\\n        mv = {{0, 1}, {1, 0}};\\n        int l = 1, r = 1e3 + 1;\\n        while(l < r) {\\n            vv dp(m, vector<int>(n, -1));\\n            int mid = l + (r - l) / 2;\\n            if(f(dun, dp, 0, 0, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};`\\n\\nPlease help me understand why this logic cannot give the right solution\\n\\nI make use of the dp values as a true or false (or not computed)"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this is good type of dp problem, a little different"
                    },
                    {
                        "username": "ayush_way",
                        "content": "int solve(int i, int j, int req,vector<vector<int> > &nums,vector<vector<int>> &dp){\\n    //base cases\\n    if(i==0 && j==0)\\n    {\\n     int t=req-nums[0][0];\\n     if(t<=0) \\n     {        \\n         return 1;\\n     }  \\n    return t;\\n    }\\n    if(i<0 || j<0) return INT_MAX;\\n\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n   \\n    int s= req-nums[i][j];\\n    if(s<=0){\\n         int  up=solve(i-1,j,1,nums,dp);\\n       int   left=solve(i,j-1,1,nums,dp);\\n         return dp[i][j] = min(up,left);\\n    }\\n    else \\n    {\\n       int up=solve(i-1,j,req-nums[i][j],nums,dp);\\n       int  left=solve(i,j-1,req-nums[i][j],nums,dp);\\n          return dp[i][j] = min(up,left);\\n    }\\n   \\n    \\n    \\n}\\n  int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n int n=dungeon.size(),m=dungeon[0].size();\\n    vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n    return solve(n-1,m-1,1,dungeon,dp);\\n \\n\\n\\nPlease help me !!\\n[[3,0,-3],[-3,-2,-2],[3,1,-3]] for this test case my code gives 6 but ans is 1 i dont know why is this happening please find fault in the code . Its the 31st test case out of 45.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "This problem is pain in the ass problem. Took me few months to crack it (the problem haha but who knows what is better)"
                    },
                    {
                        "username": "sonder7",
                        "content": "we should inversely visit the array for dp instead of visiting sequently. Otherwise, we should keep the first blood and can\\'t find the logic for dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\\n        int m = dungeon.size();\\n        int n = dungeon[0].size();\\n        vector<vector<int>> f(m, vector<int>(n, 0x3f3f3f3f));\\n        if (dungeon[m - 1][n - 1] > 0) {\\n            f[m - 1][n - 1] = 1;\\n        } else {\\n            f[m - 1][n - 1] = 1 - dungeon[m - 1][n - 1];\\n        }\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1;j >= 0; j--) {\\n                if (i < m - 1) f[i][j] = max(1, f[i + 1][j] - dungeon[i][j]);\\n                if (j < n - 1) f[i][j] = min(f[i][j], max(1, f[i][j + 1] - dungeon[i][j]));\\n            }\\n        }\\n        return f[0][0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mahendramaism",
                        "content": "Please check this test case and correct me if i am wrong. \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/10846 "
                    },
                    {
                        "username": "user2049D",
                        "content": "Good solution for your test case ([[-5, 1, 3],[30, -10, -3],[10, -5, -2]]) is 6.\\nDOWN, DOWN, RIGHT, RIGHT is the good path."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "This might help understanding the overlapping subproblems. I have explained it better [here](https://leetcode.com/problems/dungeon-game/solutions/3011638/python3-calculate-extrahealth-needed-at-each-cell/)\n\n![image.png](https://assets.leetcode.com/users/images/0d90a36f-f760-48a9-8173-5a34c17da3b7_1673065577.0750911.png)"
                    }
                ]
            }
        ]
    }
]