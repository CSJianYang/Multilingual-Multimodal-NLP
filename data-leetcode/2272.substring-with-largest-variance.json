[
    {
        "title": "Substring With Largest Variance",
        "question_content": "The variance of a string is defined as the largest difference between the number of occurrences of any 2 characters present in the string. Note the two characters may or may not be the same.\nGiven a string s consisting of lowercase English letters only, return the largest variance possible among all substrings of s.\nA substring is a contiguous sequence of characters within a string.\n&nbsp;\nExample 1:\n\nInput: s = \"aababbb\"\nOutput: 3\nExplanation:\nAll possible variances along with their respective substrings are listed below:\n- Variance 0 for substrings \"a\", \"aa\", \"ab\", \"abab\", \"aababb\", \"ba\", \"b\", \"bb\", and \"bbb\".\n- Variance 1 for substrings \"aab\", \"aba\", \"abb\", \"aabab\", \"ababb\", \"aababbb\", and \"bab\".\n- Variance 2 for substrings \"aaba\", \"ababbb\", \"abbb\", and \"babb\".\n- Variance 3 for substring \"babbb\".\nSince the largest possible variance is 3, we return it.\n\nExample 2:\n\nInput: s = \"abcde\"\nOutput: 0\nExplanation:\nNo letter occurs more than once in s, so the variance of every substring is 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 104\n\ts consists of lowercase English letters.",
        "solutions": [
            {
                "id": 2039178,
                "title": "weird-kadane",
                "content": "We solve it independently for each combination of `2` characters. We use variables `a` and `b` below, and their values could be any character. We go left-to-right, and:\\n- For `a`, we increase our variance (`+1`).\\n- For `b` - decrease ( `-1`).\\n\\t- When the variance goes negative, we restart.\\n\\nThis is Kadane\\'s algorithm. Hower, we need to make sure that the substring includes at least one `b` character. Therefore, we update the result only if  `has_b` is true.\\n\\nAnother trick is that we need to track whether our substring starts with `b`.  If we encounter another `b` - we can trim the first one (no change to the variance).\\n\\nHowever, when the variance goes negative, the next substring will start with `b` again (`first_b = true`).\\n\\n> The lowest the variance can go is `-1`. Thus, we would never have a situation when substring starts with more than one `b`.\\n\\nThis example demonstrates the running variance, and how `first_b` affects it for the \"aabbbbaabbbaaaaba\" test case:\\n\\n![image](https://assets.leetcode.com/users/images/2011fd12-ec1d-4f0a-ba7a-1444d2514279_1652570779.202012.png)\\n\\n**C++**\\n```cpp\\nint largestVariance(string s) {\\n    int res = 0;\\n    unordered_set<char> unique(begin(s), end(s));\\n    for (char a : unique)\\n        for (char b : unique) {\\n            int var = 0, has_b = 0, first_b = 0;\\n            for (auto ch : s) {\\n                var += ch == a;\\n                if (ch == b) {\\n                    has_b = true;\\n                    if (first_b && var >= 0)\\n                        first_b = false;\\n                    else if (--var < 0) {\\n                        first_b = true;\\n                        var = -1;\\n                    }\\n                }\\n                res = max(res, has_b ? var : 0);\\n            }\\n        }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint largestVariance(string s) {\\n    int res = 0;\\n    unordered_set<char> unique(begin(s), end(s));\\n    for (char a : unique)\\n        for (char b : unique) {\\n            int var = 0, has_b = 0, first_b = 0;\\n            for (auto ch : s) {\\n                var += ch == a;\\n                if (ch == b) {\\n                    has_b = true;\\n                    if (first_b && var >= 0)\\n                        first_b = false;\\n                    else if (--var < 0) {\\n                        first_b = true;\\n                        var = -1;\\n                    }\\n                }\\n                res = max(res, has_b ? var : 0);\\n            }\\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038222,
                "title": "kadanes-algorithm-solution-java",
                "content": "Time = O(26\\\\*26*n)\\n\\nFor every possible character pair a(min freq) & b(max freq), \\nfind the substring with the max differenct between the freq of a & b which can be done using kadanes algorithm.\\n\\nWe can think about it as finding the maximum subarray with a = -1 and b = 1 and other characters = 0. But we should have at least one occurrence of a.\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/) \\n```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        \\n        int [] freq = new int[26];\\n        for(int i = 0 ; i < s.length() ; i++)\\n            freq[(int)(s.charAt(i) - \\'a\\')]++;\\n        \\n        int maxVariance = 0;\\n        for(int a = 0 ; a < 26 ; a++){\\n            for(int b = 0 ; b < 26 ; b++){\\n                int remainingA = freq[a];\\n                int remainingB = freq[b];\\n                if(a == b || remainingA == 0 || remainingB == 0) continue;\\n                \\n\\t\\t\\t\\t// run kadanes on each possible character pairs (A & B)\\n                int currBFreq = 0, currAFreq = 0;\\n                for(int i = 0 ; i < s.length() ; i++){\\n                    int c =  (int)(s.charAt(i) - \\'a\\');\\n                    \\n                    if(c == b) currBFreq++;\\n                    if(c == a) {\\n                        currAFreq++;\\n                        remainingA--;\\n                    }\\n                    \\n                    if(currAFreq > 0)\\n                        maxVariance = Math.max(maxVariance, currBFreq - currAFreq);\\n                    \\n                    if(currBFreq < currAFreq &&  remainingA >= 1){\\n                        currBFreq = 0;\\n                        currAFreq = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return maxVariance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        \\n        int [] freq = new int[26];\\n        for(int i = 0 ; i < s.length() ; i++)\\n            freq[(int)(s.charAt(i) - \\'a\\')]++;\\n        \\n        int maxVariance = 0;\\n        for(int a = 0 ; a < 26 ; a++){\\n            for(int b = 0 ; b < 26 ; b++){\\n                int remainingA = freq[a];\\n                int remainingB = freq[b];\\n                if(a == b || remainingA == 0 || remainingB == 0) continue;\\n                \\n\\t\\t\\t\\t// run kadanes on each possible character pairs (A & B)\\n                int currBFreq = 0, currAFreq = 0;\\n                for(int i = 0 ; i < s.length() ; i++){\\n                    int c =  (int)(s.charAt(i) - \\'a\\');\\n                    \\n                    if(c == b) currBFreq++;\\n                    if(c == a) {\\n                        currAFreq++;\\n                        remainingA--;\\n                    }\\n                    \\n                    if(currAFreq > 0)\\n                        maxVariance = Math.max(maxVariance, currBFreq - currAFreq);\\n                    \\n                    if(currBFreq < currAFreq &&  remainingA >= 1){\\n                        currBFreq = 0;\\n                        currAFreq = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return maxVariance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579146,
                "title": "weird-kadane-intuition-solution-explained",
                "content": "> **Note you can find the finalised Python3 Code at the very bottom. This post describes how you can start from a standard Kadane\\'s Algorithm and end up at the solution [@votrubac describes in his post](https://leetcode.com/problems/substring-with-largest-variance/discuss/2039178/weird-kadane).** @NeosDeus suggested I make this a stand-alone post as this was initially a comment on that solution.\\n>\\n>Furthermore [this idea also really helped understand how you can solve this using @votrubac\\'s approach](https://leetcode.com/problems/substring-with-largest-variance/discuss/2491331/Insights-into-Votrubac-soln)\\n\\n**The Solution**\\n\\nWe\\'re trying to solve the problem by just taking two individual letters `a` and `b` from our allowed alphabet as per the question rules: \"`s consists of lowercase English letters`\", and solving the problem for `a` against `b`. We will also end up solving it for `b` against `a` due to the loop. The final solution is the max of all the possible letters in the string solved against each other.\\n\\nIdea being, you\\'re solving:\\n```python\\nmax_variance = 0\\nunique = list(set(s))\\nfor a in unique: #     see below\\n    for b in unique: # rules dictate these 2 loops would be no more than O(26*26)\\n      if a == b: continue\\n      a_against_b_var = solveOne(a, b, s) # <= you want to do this efficiently\\n      max_variance = max(a_against_b_var, max_variance)\\n\\nreturn max_variance \\n```\\n\\nNow you want to solve one such problem `solveOne` efficiently. \\n\\nA naive solution for solving `a` against `b` and `b` against `a` simultaneously is a `O(N^2)` loop tracking the -1 and +1 as explained in the hint, and taking the abs value of `(countA - countB)`. \\n\\nBut you can see that what you\\'re really trying to do, is maximise the count of `a` against `b` and `b` against `a` for both cases. This is really just [#53](https://leetcode.com/problems/3sum) **Maximum Subarray**, which you can do in O(N) (so 2*O(N) for both `a` against `b` and `b` against `a`: much better than O(N^2)), with a twist:\\n\\nYou can only consider your current running subarray as a valid solution if you were considering at least one `b` (= one `-1`) inside the solution. Solutions composed of just `a` are not valid. So you must ensure that you have `b`s, but you must also minimise their \"impact\" on the running sum.\\n\\nYou start with a solution not considering these bonus rules. Just basic Kadane\\'s algorithm for the `a`s against the `b`s:\\n\\n```python \\ndef solveOne(a, b, string):\\n    max_var = 0\\n    var = 0\\n    \\n    for c in string:\\n        if c == a:\\n            var += 1\\n        elif c == b:\\n            var -= 1\\n        \\n        var = max(0, var)\\n        max_var = max(max_var, var)\\n    \\n    return max_var\\n```\\n\\nThen you add the simple rule of \"you must have a b in the considered substring\"\\n```python\\ndef solveOne(a, b, string):\\n    max_var = 0\\n    var = 0\\n\\n    has_b = False\\n    \\n    for c in string:\\n        if c == a:\\n            var += 1\\n        elif c == b:\\n            has_b = True\\n            var -= 1\\n\\n        var = max(0, var)\\n        if has_b:\\n            max_var = max(max_var, var)\\n    \\n    return max_var\\n```\\n\\nNow for the more complex rules: \\nConsider \"baaaa\". The correct solution is 3. The above algoritm would give us results: \\n```\\n+----------+---+---+---+---+---+\\n| letter   | b | a | a | a | a |\\n+----------+---+---+---+---+---+\\n| variance | 0 | 1 | 2 | 3 | 4 |\\n+----------+---+---+---+---+---+\\n```\\nThis is an issue, so we must ensure we track the `b` properly. So we can\\'t be resetting to 0 immediately as you do in the typical Kadane algorithm.\\nLet\\'s say we allow var to go to -1 (at least initially), so that seeing an `a` after a `b` will reset us back to 0 (which would be a correct result for the string \"ba\"). \\n\\nNow what did the `max(0, var)` in Kadane\\'s algorithm really _mean_?\\nWell, we were discarding a subarray and restarting at/after the current array item because the subarray up until the discarded number was no longer \"saveable\"; we would not get the max possible sum by continuing to add numbers to that running sum. Restarting from 0 with the other/remaining half *could* still give us a better result.\\n\\nLet\\'s say we kept the -1 for the `b`s without resetting to 0, and consider:\\n```\\n+----------+----+---+---+---+---+\\n| letter   | b  | b | a | a | a |\\n+----------+----+---+---+---+---+\\n| variance | -1 | ? | ? | ? | ? |\\n+----------+----+---+---+---+---+\\n```\\n\\nWe\\'re considering the subarray `\"[b]baaa\"` and start that off with a decrement. Do we want `\"[bb]aaa\"` to be considered in its entirety? \\nWell, `bb` would not give us the max sum of `a`s if we kept both `b`s and kept going trying to look for `a`s, similar to going to a negative value in the original Kadane\\'s algorithm. \\n\\nE.g. `\"[bba]aa\"` would give us -1, `\"[bbaa]a\"` would give us 0, but `\"b[baa]a\"` would give us 1. Removing the first of those \"b\"s obviously doesn\\'t break the rule of \"all substrings must have at least one b\" and maximises the sum for `a`.\\n\\nSo we want to cut off/restart our subarray start each time we get to -1 in this implementation. Such that in the example we\\'d be considering:\\n`\"[b]baaa\"` -> `\"[bb]aaa\"`  becomes  `\"b[b]aaa\"` -> `\"b[ba]aa\"` -> `\"b[baa]a\"` -> `\"b[baaa]\"` (this gives us the max!)\\n```\\n+----------+----+----+---+---+---+\\n| letter   | b  | b  | a | a | a |\\n+----------+----+----+---+---+---+\\n| variance | -1 | -1 | 0 | 1 | 2 |\\n+----------+----+----+---+---+---+\\n```\\n\\nTo summarise up until now:\\n- if we have a positive var value and we see an `a` or a `b`, we just increment/decrement accordingly\\n- we only consider a var value towards our maximum from the point we\\'ve seen at least one `b` and that `b` is contained in our subarray\\n- -1 indicates the start of a new subarray, if we get a var value under -1, we reset var to -1 which means we restart the subarray from that point\\n\\nWhat if we had some `a`s before we get another b like in `\"baabbbaaaaa\"\\n```\\n+----+---+---+---+---+---+---+---+---+---+---+\\n| b  | a | a | b | b | b | a | a | a | a | a |\\n+----+---+---+---+---+---+---+---+---+---+---+\\n| -1 | 0 | 1 | ? |   |   |   |   |   |   |   |\\n+----+---+---+---+---+---+---+---+---+---+---+\\n```\\nWell, observe that we wouldn\\'t get the max value by considering `\"[baab]bbbaaaaa\"` (var = 0), rather `\"b[aab]bbbaaaaa\"` (var = 1) would be more optimal and continue following the rule of having to have at least one `b`. \\nIt\\'s pretty easy to say that if we knew we had a `b` as our first subarray member, then when we see our next `b` assuming we had some `a`s, we benefit by simply shifting our subarray range to the right by one, which results in the var value remaining unchanged, but us having the ability to extend into a larger sum with subsequent characters. \\n\\nWe can also know when we have such a `b` at the start of our range, because as we just saw it\\'s whenever we restart the subarray: whenever we get to var <= -1.\\n\\nShould this rule take priority over the subarray restart rule? Throwback to the previous example: `\"[b]baaaa\"` -> `\"[bb]aaaa\"` becomes `\"b[b]aaaa\"` which kind of a special case of this idea, but we\\'d like to be immediately aware that our first subarray member is `b` here so that we could apply the rule again later. \\nSo in general, the main reason to do a right shift is when we are considering a non -1 valued subarray (= not a single item that is a `b`) to preserve the running sum.\\n\\nSo we\\'d like to have:\\n`\"[b]aabbbaaaaa\"` (-1) -> `\"[ba]abbbaaaaa\"` (0) -> `\"[baa]bbbaaaaa\"` (1) -> `\"[baab]bbaaaaa\"` would be 0 but we shift right to get `\"b[aab]bbaaaaa\"` (1) -> `\"b[aabb]baaaaa\"` (0) -> `\"b[aabbb]aaaaa\"` (-1) leading to a reset starting with that last `b`: `\"baabb[b]aaaaa\"` (-1) -> `\"baabb[ba]aaaa\"` (0) -> `\"baabb[baa]aaa\"` (1) -> `\"baabb[baaa]aa\"` (2) -> `\"baabb[baaaa]a\"` (3) -> `\"baabb[baaaaa]\"` (4)\\n```\\n+----+---+---+---+---+----+---+---+---+---+---+\\n| b  | a | a | b | b | b  | a | a | a | a | a |\\n+----+---+---+---+---+----+---+---+---+---+---+\\n| -1 | 0 | 1 | 1 | 0 | -1 | 0 | 1 | 2 | 3 | 4 |\\n+----+---+---+---+---+----+---+---+---+---+---+\\n```\\n\\n**Final Rules**\\n\\nThe rules we\\'ve found are, for any given char `c` being considered at any position in the string:\\n- if we have any var value and we see that the current `c` == `a` we can just increment. There\\'s no special rules relating to incrementing\\n- if we see the current `c` == `b`:\\n> - if we see that we have a non -1 var value (indicating a current substring containing not just `b`s) and assuming we could \"shift right by one\" to save our current var value, then we will do so. We would need to track if we do actually have a `b` at the start of our current substring to be able to do so.\\n> - if for the new var value, `var - 1`, `(var - 1)` <= -1, we set it to -1 exactly and restart the substring from the current `b`. We now have a first `b` for the previous rule to use.\\n> - otherwise the var value is currently positive, and adding the b would set var to 0 (minimum), not ever below 0.\\n\\n\\n**Final Code**\\nThis gets us to @votrubac\\'s code, or here the python version of it:\\n\\n```python\\ndef solveOne(a, b, string):\\n    max_var = 0\\n    \\n    var = 0\\n    has_b = False\\n    first_b = False # first element of the currently considered subarray is b\\n    \\n    for c in string:\\n        if c == a:\\n            var += 1\\n        \\n        elif c == b:\\n            has_b = True\\n            \\n            if first_b and var >= 0: # \"shift right\" and save a 1 in the current sum to be able to properly maximise it\\n                # we can only do this when we know that we have a `b` at the start of our current subarray, and we\\'ll only ever have a single b at the start\\n                # always followed by an a, due to the next rule\\n                first_b = False \\n            elif (var - 1) < 0: # restart the subarray from this b (inclusive) onwards\\n                # this rule ensures we skip double-b\\'s, every subarray will always end up being `ba....`, `[bb]a` would become `b[b]a` -> `b[ba]`\\n                first_b = True \\n                var = -1\\n            else:\\n                var -= 1 # var will always be >= 0 in this case\\n        \\n        if has_b and var > max_var:\\n            max_var = var\\n    \\n    return max_var\\n``` \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nmax_variance = 0\\nunique = list(set(s))\\nfor a in unique: #     see below\\n    for b in unique: # rules dictate these 2 loops would be no more than O(26*26)\\n      if a == b: continue\\n      a_against_b_var = solveOne(a, b, s) # <= you want to do this efficiently\\n      max_variance = max(a_against_b_var, max_variance)\\n\\nreturn max_variance \\n```\n```python \\ndef solveOne(a, b, string):\\n    max_var = 0\\n    var = 0\\n    \\n    for c in string:\\n        if c == a:\\n            var += 1\\n        elif c == b:\\n            var -= 1\\n        \\n        var = max(0, var)\\n        max_var = max(max_var, var)\\n    \\n    return max_var\\n```\n```python\\ndef solveOne(a, b, string):\\n    max_var = 0\\n    var = 0\\n\\n    has_b = False\\n    \\n    for c in string:\\n        if c == a:\\n            var += 1\\n        elif c == b:\\n            has_b = True\\n            var -= 1\\n\\n        var = max(0, var)\\n        if has_b:\\n            max_var = max(max_var, var)\\n    \\n    return max_var\\n```\n```\\n+----------+---+---+---+---+---+\\n| letter   | b | a | a | a | a |\\n+----------+---+---+---+---+---+\\n| variance | 0 | 1 | 2 | 3 | 4 |\\n+----------+---+---+---+---+---+\\n```\n```\\n+----------+----+---+---+---+---+\\n| letter   | b  | b | a | a | a |\\n+----------+----+---+---+---+---+\\n| variance | -1 | ? | ? | ? | ? |\\n+----------+----+---+---+---+---+\\n```\n```\\n+----------+----+----+---+---+---+\\n| letter   | b  | b  | a | a | a |\\n+----------+----+----+---+---+---+\\n| variance | -1 | -1 | 0 | 1 | 2 |\\n+----------+----+----+---+---+---+\\n```\n```\\n+----+---+---+---+---+---+---+---+---+---+---+\\n| b  | a | a | b | b | b | a | a | a | a | a |\\n+----+---+---+---+---+---+---+---+---+---+---+\\n| -1 | 0 | 1 | ? |   |   |   |   |   |   |   |\\n+----+---+---+---+---+---+---+---+---+---+---+\\n```\n```\\n+----+---+---+---+---+----+---+---+---+---+---+\\n| b  | a | a | b | b | b  | a | a | a | a | a |\\n+----+---+---+---+---+----+---+---+---+---+---+\\n| -1 | 0 | 1 | 1 | 0 | -1 | 0 | 1 | 2 | 3 | 4 |\\n+----+---+---+---+---+----+---+---+---+---+---+\\n```\n```python\\ndef solveOne(a, b, string):\\n    max_var = 0\\n    \\n    var = 0\\n    has_b = False\\n    first_b = False # first element of the currently considered subarray is b\\n    \\n    for c in string:\\n        if c == a:\\n            var += 1\\n        \\n        elif c == b:\\n            has_b = True\\n            \\n            if first_b and var >= 0: # \"shift right\" and save a 1 in the current sum to be able to properly maximise it\\n                # we can only do this when we know that we have a `b` at the start of our current subarray, and we\\'ll only ever have a single b at the start\\n                # always followed by an a, due to the next rule\\n                first_b = False \\n            elif (var - 1) < 0: # restart the subarray from this b (inclusive) onwards\\n                # this rule ensures we skip double-b\\'s, every subarray will always end up being `ba....`, `[bb]a` would become `b[b]a` -> `b[ba]`\\n                first_b = True \\n                var = -1\\n            else:\\n                var -= 1 # var will always be >= 0 in this case\\n        \\n        if has_b and var > max_var:\\n            max_var = var\\n    \\n    return max_var\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2041108,
                "title": "python3-enumerate-all-a-b-combinations-and-do-maximum-subarray",
                "content": "The basic idea is same: pick 2 chars, check the results for these particular 2 chars.\\nTotaly less than 300 ways of picking 2 chars, not big deal.\\nWhen 2 chars a,b are decided, we go through s, +1 when see \\'a\\', -1 when see \\'b\\'. The question becomes:\\n-1, +1, +1, -1, +1, ...\\nWhat is the maximum subarray?\\n\\nTypical Kadanes algorithm, which is essentially DP\\ndp[i] is max subarray ending at i. We have dp[i] = max(dp[i-1],0) + s[i], which means if dp[i-1] <0, we start a new subarray, if not, we connect current value to previous subarray.\\nIn this quesiton, we also need to ensure the subarray contains both \\'a\\' and \\'b\\', which can be done using has_a and has_b flag.\\nAlso, if there is no \\'a\\' or no \\'b\\' on the right side, we cannot start over a new subarray when dp[i-1]<0, because if we start over a new subarray, there will be not enough a and b left to build a valid array. In this case don\\'t break, but continue append nums[i] to dp[i-1], because a maximum subarray might still come after that.\\n\\n```\\n    def largestVariance(self, s: str) -> int:\\n        counter = Counter(s)\\n        res = 0\\n        for a,b in itertools.permutations(counter,2):\\n            max_subarray=0\\n            has_a,has_b = False,False\\n            remain_a,remain_b = counter[a],counter[b]\\n            for ch in s:\\n                if ch!=a and ch!=b:\\n                    continue\\n                if max_subarray<0 and remain_a!=0 and remain_b!=0:\\n                    max_subarray=0\\n                    has_a,has_b = False,False\\n                if ch==a: \\n                    max_subarray+=1\\n                    remain_a-=1\\n                    has_a = True\\n                elif ch==b: \\n                    max_subarray-=1\\n                    remain_b-=1\\n                    has_b = True\\n                if has_a and has_b:\\n                    res = max(res, max_subarray)\\n        return res\\n```\\n\\nAnother way to do maximum subarray is using prefix sum. \\ncurrent prefix sum - previous minimum prefix sum == maximum subarray ended at current.\\nNeed to hash all char indexes to avoid TLE. Also, for convenience, better using O(n) space to store all previous min subarrays, because of the constraint at least one \\'a\\' and one \\'b\\' must be in the subarray, we might need to find previous minimum subarray several indexes ago.\\n```\\n    def largestVariance(self, s: str) -> int:\\n        chr_idxs = defaultdict(lambda: [])\\n        for i,c in enumerate(s):\\n            chr_idxs[c].append(i)\\n        res = 0\\n        for a,b in itertools.combinations(chr_idxs,2):\\n            last_a,last_b=-1,-1 # at least one a one b\\n            prev_min,prev_max = defaultdict(int),defaultdict(int)\\n            cur = 0\\n            idxs = list(sorted(chr_idxs[a]+chr_idxs[b]))\\n            for ii,i in enumerate(idxs):\\n                if s[i]==a:\\n                    last_a=ii\\n                    cur+=1\\n                elif s[i]==b:\\n                    last_b=ii\\n                    cur-=1\\n                ii2 = min(last_a,last_b)\\n                if ii2>=0:\\n                    res = max(res, cur-prev_min[ii2-1], prev_max[ii2-1]-cur)\\n                prev_min[ii]=min(prev_min[ii-1],cur)\\n                prev_max[ii]=max(prev_max[ii-1],cur)\\n        return res\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    def largestVariance(self, s: str) -> int:\\n        counter = Counter(s)\\n        res = 0\\n        for a,b in itertools.permutations(counter,2):\\n            max_subarray=0\\n            has_a,has_b = False,False\\n            remain_a,remain_b = counter[a],counter[b]\\n            for ch in s:\\n                if ch!=a and ch!=b:\\n                    continue\\n                if max_subarray<0 and remain_a!=0 and remain_b!=0:\\n                    max_subarray=0\\n                    has_a,has_b = False,False\\n                if ch==a: \\n                    max_subarray+=1\\n                    remain_a-=1\\n                    has_a = True\\n                elif ch==b: \\n                    max_subarray-=1\\n                    remain_b-=1\\n                    has_b = True\\n                if has_a and has_b:\\n                    res = max(res, max_subarray)\\n        return res\\n```\n```\\n    def largestVariance(self, s: str) -> int:\\n        chr_idxs = defaultdict(lambda: [])\\n        for i,c in enumerate(s):\\n            chr_idxs[c].append(i)\\n        res = 0\\n        for a,b in itertools.combinations(chr_idxs,2):\\n            last_a,last_b=-1,-1 # at least one a one b\\n            prev_min,prev_max = defaultdict(int),defaultdict(int)\\n            cur = 0\\n            idxs = list(sorted(chr_idxs[a]+chr_idxs[b]))\\n            for ii,i in enumerate(idxs):\\n                if s[i]==a:\\n                    last_a=ii\\n                    cur+=1\\n                elif s[i]==b:\\n                    last_b=ii\\n                    cur-=1\\n                ii2 = min(last_a,last_b)\\n                if ii2>=0:\\n                    res = max(res, cur-prev_min[ii2-1], prev_max[ii2-1]-cur)\\n                prev_min[ii]=min(prev_min[ii-1],cur)\\n                prev_max[ii]=max(prev_max[ii-1],cur)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2038840,
                "title": "c-kadane-s-algorithm-with-edge-case-explaination",
                "content": "Explain the edge case in detail mentioned by https://leetcode.com/problems/substring-with-largest-variance/discuss/2038774/C++-O(1)-space-complexity-Kadane\\'s-for-each-pair-of-characters\\n\\n#### Concept:\\n1. Only consider two characters each time. Specify one `p`  with higher frequency and one `q` with lower frequency. Thus, the time complexity would be in `O(26*26*n)`.\\n2. Run Kadane\\'s algorithm. Keep counting `p` and `q`. Once `q`\\'s count > `p`\\'s count, reset their counts. If `q`\\'s count > 0, calculate the difference of counts between `p` and `q`.\\n3. There would be an edge case e.g., `pqqpppppp`, in which the last `pppppp` will not be involved as `q`\\'s count is set to zero after processing first `pq`. Set a flag to extend the current interval after reseting `p` and `q`\\'s count.\\n```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int n = s.size();\\n        int res = 0;\\n        \\n        // choose two char for comparison\\n        // p is the one with higher freq.\\n        // q is the one with lower freq.\\n        for (char p = \\'a\\'; p <= \\'z\\'; p++) {\\n            for (char q = \\'a\\'; q <= \\'z\\'; q++) {\\n                if (p == q) continue;\\n                \\n                // run Kadane\\'s algo\\n                int pCount = 0; // higher one\\n                int qCount = 0; // lower one\\n                \\n                // this flag would deal with the edge case\\n                // e.g., \"pqqpppppp\"\\n                // after reset, there is no q but we can extend\\n                // the interval to the previous q\\n                // and the answer should -1\\n                bool canExtendprevQ = false;\\n                \\n                for (auto c : s) {\\n                    if (c == p) pCount++;\\n                    if (c == q) qCount++;\\n                    \\n                    // an interval should contain at least one q\\n                    if (qCount > 0) {\\n                        res = max(res, pCount - qCount);\\n                    }\\n                    // edge case: consider previous q\\n                    else if (qCount == 0 && canExtendprevQ) {\\n                        res = max(res, pCount - 1);\\n                    }\\n                    \\n                    // reset if # of q > # of p\\n                    if (qCount > pCount) {\\n                        qCount = pCount = 0;\\n                        \\n                        // once reset, the interval can be extended\\n                        // as there must be one q before the next interval\\n                        canExtendprevQ = true;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int n = s.size();\\n        int res = 0;\\n        \\n        // choose two char for comparison\\n        // p is the one with higher freq.\\n        // q is the one with lower freq.\\n        for (char p = \\'a\\'; p <= \\'z\\'; p++) {\\n            for (char q = \\'a\\'; q <= \\'z\\'; q++) {\\n                if (p == q) continue;\\n                \\n                // run Kadane\\'s algo\\n                int pCount = 0; // higher one\\n                int qCount = 0; // lower one\\n                \\n                // this flag would deal with the edge case\\n                // e.g., \"pqqpppppp\"\\n                // after reset, there is no q but we can extend\\n                // the interval to the previous q\\n                // and the answer should -1\\n                bool canExtendprevQ = false;\\n                \\n                for (auto c : s) {\\n                    if (c == p) pCount++;\\n                    if (c == q) qCount++;\\n                    \\n                    // an interval should contain at least one q\\n                    if (qCount > 0) {\\n                        res = max(res, pCount - qCount);\\n                    }\\n                    // edge case: consider previous q\\n                    else if (qCount == 0 && canExtendprevQ) {\\n                        res = max(res, pCount - 1);\\n                    }\\n                    \\n                    // reset if # of q > # of p\\n                    if (qCount > pCount) {\\n                        qCount = pCount = 0;\\n                        \\n                        // once reset, the interval can be extended\\n                        // as there must be one q before the next interval\\n                        canExtendprevQ = true;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738829,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "# An Upvote will be encouraging \\uD83D\\uDC4D\\n\\n# Video Solution\\n\\n# Search \\uD83D\\uDC49 `Substring With Largest Variance By Tech Wired`\\n\\n# OR\\n\\n# Click the link in my profile\\n\\n# Intuition\\n\\n- Initialize count1, count2, and max_variance to 0. These variables will keep track of the counts and the maximum variance encountered.\\n\\n- Create a set of distinct characters from the input string s. This step ensures that we only consider unique characters for our pairs.\\n\\n- Iterate over the characters in the string s twice:\\na. First, iterate in the original order.\\nb. Then, iterate in the reverse order.\\n\\n- For each pair of distinct characters (l1 and l2) from the set:\\na. Reset count1 and count2 to 0.\\nb. Iterate over each character in the string s.\\n\\n- Inside the inner iteration:\\na. If the current character is equal to l1, increment count1.\\nb. If the current character is equal to l2, increment count2.\\n\\n- Check if count1 is less than count2. If so, reset count1 and count2 to 0. This step ensures that the counts are only considered if count1 >= count2.\\n\\n- If both count1 and count2 are greater than 0, calculate the variance (count1 - count2) and update max_variance if the calculated variance is greater than the current max_variance. This step keeps track of the maximum variance encountered so far.\\n\\n- After completing the iteration for the current string order, reverse the string s for the next iteration. Reversing the string allows us to consider the pairs in both the original and reverse order.\\n\\n- Finally, return the maximum variance (max_variance) found during the iterations.\\n\\n```Python []\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        count1 = 0\\n        count2 = 0\\n        max_variance = 0\\n        \\n        # create distinct list of character pairs\\n        pairs = [(l1, l2) for l1 in set(s) for l2 in set(s) if l1 != l2]\\n\\n        # run once for original string order, then again for reverse string order\\n        for runs in range(2):\\n            for pair in pairs:\\n                count1 = count2 = 0\\n                for letter in s:\\n                    # no reason to process letters that aren\\'t part of the current pair\\n                    if letter not in pair:\\n                        continue\\n                    if letter == pair[0]:\\n                        count1 += 1\\n                    elif letter == pair[1]:\\n                        count2 += 1\\n                    if count1 < count2:\\n                        count1 = count2 = 0\\n                    elif count1 > 0 and count2 > 0:\\n                        max_variance = max(max_variance, count1 - count2)\\n                \\n            \\n            # reverse the string for the second time around\\n            s = s[::-1]\\n                \\n        return max_variance\\n```\\n```Java []\\npublic class Solution {\\n    public int largestVariance(String s) {\\n        int count1 = 0;\\n        int count2 = 0;\\n        int maxVariance = 0;\\n\\n        // Create a distinct set of character pairs\\n        HashSet<Character> distinctChars = new HashSet<>();\\n        for (char c : s.toCharArray()) {\\n            distinctChars.add(c);\\n        }\\n\\n        // Run once for original string order, then again for reverse string order\\n        for (int runs = 0; runs < 2; runs++) {\\n            for (char l1 : distinctChars) {\\n                for (char l2 : distinctChars) {\\n                    if (l1 == l2) {\\n                        continue;\\n                    }\\n                    count1 = count2 = 0;\\n                    for (char letter : s.toCharArray()) {\\n                        if (letter == l1) {\\n                            count1++;\\n                        } else if (letter == l2) {\\n                            count2++;\\n                        }\\n                        if (count1 < count2) {\\n                            count1 = count2 = 0;\\n                        } else if (count1 > 0 && count2 > 0) {\\n                            maxVariance = Math.max(maxVariance, count1 - count2);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            // Reverse the string for the second time around\\n            s = new StringBuilder(s).reverse().toString();\\n        }\\n\\n        return maxVariance;\\n    }\\n}\\n```\\n```C++ []\\n\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int count1 = 0;\\n        int count2 = 0;\\n        int max_variance = 0;\\n\\n        // Create a distinct set of character pairs\\n        unordered_set<char> distinct_chars(s.begin(), s.end());\\n\\n        // Run once for original string order, then again for reverse string order\\n        for (int runs = 0; runs < 2; runs++) {\\n            for (char l1 : distinct_chars) {\\n                for (char l2 : distinct_chars) {\\n                    if (l1 == l2) {\\n                        continue;\\n                    }\\n                    count1 = count2 = 0;\\n                    for (char letter : s) {\\n                        if (letter == l1) {\\n                            count1++;\\n                        } else if (letter == l2) {\\n                            count2++;\\n                        }\\n                        if (count1 < count2) {\\n                            count1 = count2 = 0;\\n                        } else if (count1 > 0 && count2 > 0) {\\n                            max_variance = max(max_variance, count1 - count2);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            // Reverse the string for the second time around\\n            reverse(s.begin(), s.end());\\n        }\\n\\n        return max_variance;\\n    }\\n};\\n\\n```\\n# An Upvote will be encouraging \\uD83D\\uDC4D\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```Python []\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        count1 = 0\\n        count2 = 0\\n        max_variance = 0\\n        \\n        # create distinct list of character pairs\\n        pairs = [(l1, l2) for l1 in set(s) for l2 in set(s) if l1 != l2]\\n\\n        # run once for original string order, then again for reverse string order\\n        for runs in range(2):\\n            for pair in pairs:\\n                count1 = count2 = 0\\n                for letter in s:\\n                    # no reason to process letters that aren\\'t part of the current pair\\n                    if letter not in pair:\\n                        continue\\n                    if letter == pair[0]:\\n                        count1 += 1\\n                    elif letter == pair[1]:\\n                        count2 += 1\\n                    if count1 < count2:\\n                        count1 = count2 = 0\\n                    elif count1 > 0 and count2 > 0:\\n                        max_variance = max(max_variance, count1 - count2)\\n                \\n            \\n            # reverse the string for the second time around\\n            s = s[::-1]\\n                \\n        return max_variance\\n```\n```Java []\\npublic class Solution {\\n    public int largestVariance(String s) {\\n        int count1 = 0;\\n        int count2 = 0;\\n        int maxVariance = 0;\\n\\n        // Create a distinct set of character pairs\\n        HashSet<Character> distinctChars = new HashSet<>();\\n        for (char c : s.toCharArray()) {\\n            distinctChars.add(c);\\n        }\\n\\n        // Run once for original string order, then again for reverse string order\\n        for (int runs = 0; runs < 2; runs++) {\\n            for (char l1 : distinctChars) {\\n                for (char l2 : distinctChars) {\\n                    if (l1 == l2) {\\n                        continue;\\n                    }\\n                    count1 = count2 = 0;\\n                    for (char letter : s.toCharArray()) {\\n                        if (letter == l1) {\\n                            count1++;\\n                        } else if (letter == l2) {\\n                            count2++;\\n                        }\\n                        if (count1 < count2) {\\n                            count1 = count2 = 0;\\n                        } else if (count1 > 0 && count2 > 0) {\\n                            maxVariance = Math.max(maxVariance, count1 - count2);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            // Reverse the string for the second time around\\n            s = new StringBuilder(s).reverse().toString();\\n        }\\n\\n        return maxVariance;\\n    }\\n}\\n```\n```C++ []\\n\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int count1 = 0;\\n        int count2 = 0;\\n        int max_variance = 0;\\n\\n        // Create a distinct set of character pairs\\n        unordered_set<char> distinct_chars(s.begin(), s.end());\\n\\n        // Run once for original string order, then again for reverse string order\\n        for (int runs = 0; runs < 2; runs++) {\\n            for (char l1 : distinct_chars) {\\n                for (char l2 : distinct_chars) {\\n                    if (l1 == l2) {\\n                        continue;\\n                    }\\n                    count1 = count2 = 0;\\n                    for (char letter : s) {\\n                        if (letter == l1) {\\n                            count1++;\\n                        } else if (letter == l2) {\\n                            count2++;\\n                        }\\n                        if (count1 < count2) {\\n                            count1 = count2 = 0;\\n                        } else if (count1 > 0 && count2 > 0) {\\n                            max_variance = max(max_variance, count1 - count2);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            // Reverse the string for the second time around\\n            reverse(s.begin(), s.end());\\n        }\\n\\n        return max_variance;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038774,
                "title": "c-fast-o-1-space-complexity-kadane-s-for-each-pair-of-characters",
                "content": "The difference of this implementation from other is: constant space complexity.\\nWe can avoid additional arrays creation - just carefully implement Kadane\\'s algo and take into account the algo details - commented in the code below.\\n1. Try every possible pair of chars {`highFreqChar`, `lowFreqChar`} - e.g., {\\'a\\',\\'b\\'}\\n2. For the input string `s` calculate `highFreq` and `lowFreq`, find max `highFreq - lowFreq` using Kadane\\'s algorithm. But according to the problem description, we must have at least 1 occurence of the `lowFreqChar` - so update the result only in these 2 cases:\\n\\t2.1 when `lowFreq > 0` - i.e., there is at least 1 `lowFreqChar` in current interval, our current interval result is `highFreq - lowFreq`.\\n\\t2.2 else (when `lowFreq == 0`) - but if we previously restarted the Kadane\\'s interval (if `lowFreqAbandoned` == true) - we can extend back our interval for 1 `lowFreqChar`, and our current interval result is `highFreq - 1`.\\n\\n```cpp\\nint largestVariance(string s) {\\n    int result = 0;\\n    for (char highFreqChar = \\'a\\'; highFreqChar <= \\'z\\'; ++highFreqChar) {\\n        for (char lowFreqChar = \\'a\\'; lowFreqChar <= \\'z\\'; ++lowFreqChar) {\\n            if (highFreqChar == lowFreqChar) continue;\\n            \\n            int highFreq = 0;\\n            int lowFreq = 0;\\n            bool lowFreqAbandoned = false;\\n            \\n            for (const char& ch : s) {\\n                if (ch == highFreqChar) ++highFreq;\\n                if (ch == lowFreqChar) ++lowFreq;\\n                \\n                if (lowFreq > 0) {\\n                    result = max(result, highFreq - lowFreq);\\n                } else {\\n                    // Edge case: there are no `lowFreqChar` in current interval.\\n                    // In case if we re-started Kadane algo calculation - \\n                    // we can \"extend\" current interval with 1 previously abandoned \\'lowFreqChar\\'\\n                    if (lowFreqAbandoned) {\\n                        result = max(result, highFreq - 1);\\n                    }\\n                } \\n                \\n                if (lowFreq > highFreq) {\\n                    // Kadane\\'s algo calculation re-start: abandon previous chars and their freqs.\\n                    // Important: the last abandoned char is the `lowFreqChar` - this can be used on further iterations.\\n                    lowFreq = 0;\\n                    highFreq = 0;\\n                    lowFreqAbandoned = true;\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```\\nTime complexity: O(26 * 26 * N) = O(N)\\nSpace complexity: O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint largestVariance(string s) {\\n    int result = 0;\\n    for (char highFreqChar = \\'a\\'; highFreqChar <= \\'z\\'; ++highFreqChar) {\\n        for (char lowFreqChar = \\'a\\'; lowFreqChar <= \\'z\\'; ++lowFreqChar) {\\n            if (highFreqChar == lowFreqChar) continue;\\n            \\n            int highFreq = 0;\\n            int lowFreq = 0;\\n            bool lowFreqAbandoned = false;\\n            \\n            for (const char& ch : s) {\\n                if (ch == highFreqChar) ++highFreq;\\n                if (ch == lowFreqChar) ++lowFreq;\\n                \\n                if (lowFreq > 0) {\\n                    result = max(result, highFreq - lowFreq);\\n                } else {\\n                    // Edge case: there are no `lowFreqChar` in current interval.\\n                    // In case if we re-started Kadane algo calculation - \\n                    // we can \"extend\" current interval with 1 previously abandoned \\'lowFreqChar\\'\\n                    if (lowFreqAbandoned) {\\n                        result = max(result, highFreq - 1);\\n                    }\\n                } \\n                \\n                if (lowFreq > highFreq) {\\n                    // Kadane\\'s algo calculation re-start: abandon previous chars and their freqs.\\n                    // Important: the last abandoned char is the `lowFreqChar` - this can be used on further iterations.\\n                    lowFreq = 0;\\n                    highFreq = 0;\\n                    lowFreqAbandoned = true;\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2297768,
                "title": "java-kadane-s-algorithm-easy-to-understand",
                "content": "**Intuition:**\\n- The problem becomes easy to reason, if we think that there are only 2 characters (let\\'s say `a` & `b`) in the given String. We\\'ll try to solve the problem, once assuming that maximum variance in a substring is when `a` > `b` and the other time we\\'ll assume it is `b` > `a`.\\n- We can maintain a `max_count` which gets updated everytime a max variance is found.\\n- We check for the maximum variance for each set of characters and update this global `max_count`.\\n\\n**Code:**\\n```\\nclass Solution {\\n    public int largestVariance(String s) {\\n\\t    // Maintain a map of freq of characters in the string\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c : s.toCharArray())\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        \\n        int max=0;\\n\\t\\t// Check for every possible pair of characters in the map with the assumption that the one char is greater than the other\\n\\t\\t// In the following piece of code, assuming c2 count is greater than c1\\n        for(char c1 : map.keySet()){\\n            for(char c2 : map.keySet()){\\n\\t\\t\\t    // If both the characters are same then we don\\'t explore any further\\n                if(c1 == c2)\\n                    continue;\\n                int c1Freq=0, c2Freq=0;\\n                int c1Remaining=map.get(c1); // Keep track of the remaining c1 chars\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Iterate through all the characters in the string\\n                for(char c : s.toCharArray()){\\n                    if(c == c1){\\n                        c1Freq++;\\n                        c1Remaining--;\\n                    }\\n                    if(c == c2)\\n                        c2Freq++;\\n\\n\\t\\t\\t\\t\\t// If c2-count < c1-count then we reset the counters, only if we know there are more c1 chars to come in the iteration\\n\\t\\t\\t\\t\\t// c1Remaining check is required for the test case \"baa\" and c1=b && c2=a. We don\\'t reset the counters if there are no more c1 chars left\\t\\t\\t\\t\\t\\n                    if(c2Freq < c1Freq && c1Remaining > 0) {\\n                        c2Freq=0;\\n                        c1Freq=0;\\n                    }\\n                    \\n\\t\\t\\t\\t\\t// Calculate variance of current substring and update max accordingly\\n                    if(c1Freq > 0 && c2Freq > 0)\\n                        max = Math.max(max, c2Freq-c1Freq);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestVariance(String s) {\\n\\t    // Maintain a map of freq of characters in the string\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c : s.toCharArray())\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        \\n        int max=0;\\n\\t\\t// Check for every possible pair of characters in the map with the assumption that the one char is greater than the other\\n\\t\\t// In the following piece of code, assuming c2 count is greater than c1\\n        for(char c1 : map.keySet()){\\n            for(char c2 : map.keySet()){\\n\\t\\t\\t    // If both the characters are same then we don\\'t explore any further\\n                if(c1 == c2)\\n                    continue;\\n                int c1Freq=0, c2Freq=0;\\n                int c1Remaining=map.get(c1); // Keep track of the remaining c1 chars\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Iterate through all the characters in the string\\n                for(char c : s.toCharArray()){\\n                    if(c == c1){\\n                        c1Freq++;\\n                        c1Remaining--;\\n                    }\\n                    if(c == c2)\\n                        c2Freq++;\\n\\n\\t\\t\\t\\t\\t// If c2-count < c1-count then we reset the counters, only if we know there are more c1 chars to come in the iteration\\n\\t\\t\\t\\t\\t// c1Remaining check is required for the test case \"baa\" and c1=b && c2=a. We don\\'t reset the counters if there are no more c1 chars left\\t\\t\\t\\t\\t\\n                    if(c2Freq < c1Freq && c1Remaining > 0) {\\n                        c2Freq=0;\\n                        c1Freq=0;\\n                    }\\n                    \\n\\t\\t\\t\\t\\t// Calculate variance of current substring and update max accordingly\\n                    if(c1Freq > 0 && c2Freq > 0)\\n                        max = Math.max(max, c2Freq-c1Freq);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738770,
                "title": "kadane-algorithm-c-java-python-video-explanation",
                "content": "\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\niterate through every possible pair of character and finding the variance and maximum among them will be answer.for this we will always take c1 greater than c2 so answer is postive.automatically the case will be covered for c2 greater than c1 when j and i character swap its posistion. \\n\\nFor detailed explanation you can refer to my youtube channel (hindi Language)\\nhttps://youtu.be/c-U5cQMXFH4\\n or link in my profile.Here,you can find any solution in playlists monthwise from June 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\nor\\nsearch \\uD83D\\uDC49`Substring With Largest Variance by Let\\'s Code Together` on youtube\\n\\n# Complexity\\n- Time complexity:$$O(26*26*2*s)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(26)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        vector<int>arr(26);\\n        for(auto x:s){\\n           arr[x-\\'a\\']++; \\n        }\\n        int ans=0;\\n        for(char i=\\'a\\';i<=\\'z\\';i++){\\n            for(char j=\\'a\\';j<=\\'z\\';j++){\\n                 if(j==i||arr[i-\\'a\\']==0||arr[j-\\'a\\']==0)\\n                            continue;\\n                for(int k=1;k<=2;k++){\\n                   int c1=0;\\n                    int c2=0;\\n                    for(auto x:s){\\n                        if(x==i)\\n                            c1++;\\n                        if(x==j)\\n                            c2++;\\n                        if(c2>c1){\\n                            c1=0;\\n                            c2=0;\\n                        }\\n                        if(c1>0&&c2>0)\\n                        ans=max(ans,c1-c2);\\n                    }\\n                    reverse(s.begin(),s.end());\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote-this-you.jpg](https://assets.leetcode.com/users/images/97f02b90-c490-4e09-8483-922ca776257f_1688879379.8440745.jpeg)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        vector<int>arr(26);\\n        for(auto x:s){\\n           arr[x-\\'a\\']++; \\n        }\\n        int ans=0;\\n        for(char i=\\'a\\';i<=\\'z\\';i++){\\n            for(char j=\\'a\\';j<=\\'z\\';j++){\\n                 if(j==i||arr[i-\\'a\\']==0||arr[j-\\'a\\']==0)\\n                            continue;\\n                for(int k=1;k<=2;k++){\\n                   int c1=0;\\n                    int c2=0;\\n                    for(auto x:s){\\n                        if(x==i)\\n                            c1++;\\n                        if(x==j)\\n                            c2++;\\n                        if(c2>c1){\\n                            c1=0;\\n                            c2=0;\\n                        }\\n                        if(c1>0&&c2>0)\\n                        ans=max(ans,c1-c2);\\n                    }\\n                    reverse(s.begin(),s.end());\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038516,
                "title": "python-simple-solution-faster-than-100",
                "content": "**Algorithm:**\\nFor each pair of characters (c1, c2), find their maximum of `count(c1) - count(c2)` in the substrings. The time complexity is O(n) in this case. \\n\\n**My Solution with comments:**\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        res = 0\\n        chars = list(set(s))\\n\\t\\t\\n\\t\\t# Loop through each pari of (c1, c2)\\n        for i in range(len(chars)):\\n            for j in range(i+1, len(chars)):\\n                c1, c2 = chars[i], chars[j]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# keep track of count(c1) - count(c2) \\n                diff = 0 \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# max and min of diff\\n\\t\\t\\t\\t# result should be maximum of (diff - min_diff, max_diff - diff)\\n\\t\\t\\t\\t# e.g. \"baabaa\", at index = 0, min_diff = -1. when index = 5, diff = 4 - 2 = 2, result = diff - min_diff = 2 - (-1) = 3\\n                max_diff = min_diff = 0\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# diff at the previous occurance of c1/c2\\n                last_c1_diff = last_c2_diff = 0 \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# check wether we have met c1/c2 during the loop\\n                meet_c1 = meet_c2 = False\\n\\t\\t\\t\\t\\n                for c in s:\\n                    if c == c1:\\n                        meet_c1 = True\\n                        diff += 1\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t#  use last_c1_diff instead of diff because we have to make sure that c1 is in the rest part of the substring. \\n\\t\\t\\t\\t\\t\\t# e.g. [c1, c1, c2, c2, c2]\\n\\t\\t\\t\\t\\t\\t# At index = 1, if we use diff = 2 -> max_diff = 2\\n\\t\\t\\t\\t\\t\\t# At index = 4, diff = 2 - 3 = -1, result = max_diff - diff = 3. \\n\\t\\t\\t\\t\\t\\t# Though we have [c2, c2, c2] as a substring, c1 is not in this string and the result is invalid\\n                        max_diff = max(last_c1_diff, max_diff)\\n\\t\\t\\t\\t\\t\\t\\n                        last_c1_diff = diff\\n                    elif c == c2:\\n                        meet_c2 = True\\n                        diff -= 1\\n                        min_diff = min(last_c2_diff, min_diff)\\n                        last_c2_diff = diff\\n                    else:\\n                        continue\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# update the result only when we have met both c1 and c2 \\n                    if meet_c1 and meet_c2:\\n                        res = max(diff - min_diff, max_diff - diff, res)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        res = 0\\n        chars = list(set(s))\\n\\t\\t\\n\\t\\t# Loop through each pari of (c1, c2)\\n        for i in range(len(chars)):\\n            for j in range(i+1, len(chars)):\\n                c1, c2 = chars[i], chars[j]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# keep track of count(c1) - count(c2) \\n                diff = 0 \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# max and min of diff\\n\\t\\t\\t\\t# result should be maximum of (diff - min_diff, max_diff - diff)\\n\\t\\t\\t\\t# e.g. \"baabaa\", at index = 0, min_diff = -1. when index = 5, diff = 4 - 2 = 2, result = diff - min_diff = 2 - (-1) = 3\\n                max_diff = min_diff = 0\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# diff at the previous occurance of c1/c2\\n                last_c1_diff = last_c2_diff = 0 \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# check wether we have met c1/c2 during the loop\\n                meet_c1 = meet_c2 = False\\n\\t\\t\\t\\t\\n                for c in s:\\n                    if c == c1:\\n                        meet_c1 = True\\n                        diff += 1\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t#  use last_c1_diff instead of diff because we have to make sure that c1 is in the rest part of the substring. \\n\\t\\t\\t\\t\\t\\t# e.g. [c1, c1, c2, c2, c2]\\n\\t\\t\\t\\t\\t\\t# At index = 1, if we use diff = 2 -> max_diff = 2\\n\\t\\t\\t\\t\\t\\t# At index = 4, diff = 2 - 3 = -1, result = max_diff - diff = 3. \\n\\t\\t\\t\\t\\t\\t# Though we have [c2, c2, c2] as a substring, c1 is not in this string and the result is invalid\\n                        max_diff = max(last_c1_diff, max_diff)\\n\\t\\t\\t\\t\\t\\t\\n                        last_c1_diff = diff\\n                    elif c == c2:\\n                        meet_c2 = True\\n                        diff -= 1\\n                        min_diff = min(last_c2_diff, min_diff)\\n                        last_c2_diff = diff\\n                    else:\\n                        continue\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# update the result only when we have met both c1 and c2 \\n                    if meet_c1 and meet_c2:\\n                        res = max(diff - min_diff, max_diff - diff, res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2412313,
                "title": "python-kadene-algo-with-explanation",
                "content": "## Description\\n\\nThe\\xA0**variance**\\xA0of a string is defined as the largest difference between the number of occurrences of\\xA0**any**\\xA0`2`\\xA0characters present in the string. Note the two characters may or may not be the same.\\n\\nGiven a string\\xA0`s`\\xA0consisting of lowercase English letters only, return\\xA0*the\\xA0**largest variance**\\xA0possible among all\\xA0**substrings**\\xA0of*\\xA0`s`.\\n\\nA\\xA0**substring**\\xA0is a contiguous sequence of characters within a string.\\n\\n**Example 1:**\\n\\n```\\nInput: s = \"aababbb\"\\nOutput: 3\\nExplanation:\\nAll possible variances along with their respective substrings are listed below:\\n- Variance 0 for substrings \"a\", \"aa\", \"ab\", \"abab\", \"aababb\", \"ba\", \"b\", \"bb\", and \"bbb\".\\n- Variance 1 for substrings \"aab\", \"aba\", \"abb\", \"aabab\", \"ababb\", \"aababbb\", and \"bab\".\\n- Variance 2 for substrings \"aaba\", \"ababbb\", \"abbb\", and \"babb\".\\n- Variance 3 for substring \"babbb\".\\nSince the largest possible variance is 3, we return it.\\n```\\n\\n**Example 2:**\\n\\n```\\nInput: s = \"abcde\"\\nOutput: 0\\nExplanation:\\nNo letter occurs more than once in s, so the variance of every substring is 0.\\n```\\n\\n**Constraints:**\\n\\n- `1 <= s.length <= 104`\\n- `s`\\xA0consists of lowercase English letters.\\n\\n## Solution\\n\\nThe proposed solution is based on a solution of the problem `Maximum Contiguos Subarray Sum` which is solved by Kadenes algorithm and a variation of the Kadene\\u2019s algorithm.\\n\\nThe important thing to link Kadene\\u2019s algorithm to this solution is based on this observation:\\n\\nGiven a string `s = \"aababbb\"` find the substring with the largest variation. Lets do 2 separate considerations\\n\\n1. Give the value of `1` to `a` and `-1` to `b` \\n    \\n    ```python\\n    s = \"aababbb\"\\n    s = [1, 1, -1, 1, -1, -1, -1]\\n    ```\\n    \\n2. Give the value of `1` to `b` and `-1` to `a` \\n    \\n    ```python\\n    s = \"aababbb\"\\n    s = [-1, -1, 1, -1, 1, 1, 1]\\n    ```\\n    \\n\\nOn both scenarios we have transformed the original problem into the maximum subarray sum problem which is well know that can be solved by Kadenes algorithm. \\n\\nIf we assume we are solving this problem to string with 2 character then the solution will be pretty straightforward as we only need to pass Kadenes algorithm twice i,e. once for the first scenario and a second time for the other. Let\\u2019s take a look at this implementation\\n\\n```python\\nclass Solution:\\n\\tdef largestVariance(self, s):\\n\\t\\tcase_1 = [1 if c == \"a\" else -1 for c in s]\\n\\t\\tcase_2 = [1 if c == \"b\" else -1 for c in s]\\n\\n\\t\\t# Appliying Kadenes algo to case 1\\n\\t\\tcase1_max = 0\\n\\t\\tcase1_total = 0\\n\\t\\tfor num in case_1:\\n\\t\\t\\tcase1_max = max(case1_max + num, num)\\n\\t\\t\\tcase1_total = max(case1_max, case1_total)\\n\\n\\t\\t# Applying Kadenes algo to case 2\\n\\t\\tcase2_max = 0 \\n\\t\\tcase2_total = 0\\n\\t\\tfor num in case_2:\\n\\t\\t\\tcase2_max = max(case2_max + num, num)\\n\\t\\t\\tcase2_total = max(case2_total, case2_max)\\n\\n\\t\\treturn max(case1_total, case2_total)\\n```\\n\\nThe reason we needed to run Kadenes algorithm twice is because the considerations we gave i,e. one character should have the value of -1 and the other of 1,  if we want to generalize this consideration we will need to loop over each of this considerations so:\\n\\n```python\\nclass Solution:\\n\\tdef largestVariance(self, s):\\n\\t\\tmax_count = 0\\n\\t\\tfor a,b in [(\"a\", \"b\"), (\"b\", \"a\")]:\\n\\t\\t\\tmax_local = 0\\n\\t\\t\\tfor c in s:\\n\\t\\t\\t\\tif c == a:\\n\\t\\t\\t\\t\\tmax_local += 1\\n\\n\\t\\t\\t\\tif c == b:\\n\\t\\t\\t\\t\\tmax_local -= 1\\n\\n\\t\\t\\t\\tmax_count = max(max_count, max_local)\\n\\t\\t\\n\\t\\treturn max_count\\n```\\n\\nIn this case we are looping over each consideration giving to the variable `a` the value of either `\"a\"` or `\"b\"` and same goes for `b` \\n\\nIf we want to account for more characters we will need to add a couple of new considerations to our code:\\n\\n1. We will need to account the possible permutations for each pair of characters existing on the string\\n2. We will need to add a mechanism to reset the values of `max_local` once it\\u2019s lower than `0` or once there are no characters left on the string for the current pair `a, b`\\n\\nLet\\u2019s start with the first consideration, we could either implement that manually or just use `itertools` to calculate all the possible 2-permutations\\n\\n```python\\nimport itertools\\n\\n# Count the number of characters on the string\\nchars = {}\\nfor c in s:\\n\\tchars[c] = chars.get(c, 0) + 1\\n\\n# Calculate the possible permulations\\npermutations = itertools.permutations(chars, 2)\\n```\\n\\nOn the other hand, for the next consideration we will need to add a mechanism to reset the `max_local` either when is below 0 or when there are no characters left for `a` or `b`\\n\\n```python\\n        count = 0\\n        max_local = 0\\n\\n\\t\\t# Keep track if c has become a or b\\n        is_a = False\\n        is_b = False\\n\\n\\t\\t# Keep track of characters for a and b\\n        val_a = chars[a]\\n        val_b = chars[b]\\n        for c in s:\\n\\t\\t\\t# No need to continue if c is not a or b\\n            if c != a and c != b:\\n                continue\\n\\n\\t\\t\\t# Reset the max_local if there are no chars left or max_total\\n\\t\\t\\t# is negative\\n            if max_local < 0 and val_a != 0 and val_b != 0:\\n                max_local = 0\\n                is_a = False\\n                is_b = False\\n\\n\\t\\t\\t\\t\\t\\t# Add 1 to the local max if c is the expected char\\n            if c == a:\\n                max_local += 1\\n                val_a -= 1\\n                is_a = True\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# Remove 1 from the local max if c is the expected char\\n            if c == b:\\n                max_local -= 1\\n                val_b -=1\\n                is_b = True\\n            \\n\\t\\t\\t\\t\\t\\t# Only calculate the count if a and b apperared\\n            if is_a and is_b:\\n                count = max(count, max_local)\\n```\\n\\nIntegrating both considerations we end up with:\\n\\n```python\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n\\t\\t# Create a dictionary with the count of all chars of s\\n        chars = {}\\n        for c in s:\\n            chars[c] = chars.get(c, 0) + 1\\n\\n        # Calculate the possible permulations\\n        permutations = itertools.permutations(chars, 2)\\n        \\n\\t\\t# Calculate the max subarray count with kadene algo\\n        count = 0\\n        for a, b in permutations:\\n            count = max(self.kadene(a, b, s, chars), count)\\n        return count\\n\\n    def kadene(self, a, b, s, chars):\\n        count = 0\\n        max_local = 0\\n\\n\\t\\t# Keep track if c has become a or b\\n        is_a = False\\n        is_b = False\\n\\n\\t\\t# Keep track of characters for a and b\\n        val_a = chars[a]\\n        val_b = chars[b]\\n        for c in s:\\n\\n\\t\\t\\t# No need to continue if c is not a or b\\n            if c != a and c != b:\\n                continue\\n\\n\\t\\t\\t# Reset the max_local if there are no chars left or max_total\\n\\t\\t    # is negative\\n            if max_local < 0 and val_a != 0 and val_b != 0:\\n                max_local = 0\\n                is_a = False\\n                is_b = False\\n\\n\\t\\t\\t# Add 1 to the local max if c is the expected char\\n            if c == a:\\n                max_local += 1\\n                val_a -= 1\\n                is_a = True\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t# Remove 1 from the local max if c is the expected char\\n            if c == b:\\n                max_local -= 1\\n                val_b -=1\\n                is_b = True\\n            \\n\\t\\t\\t# Only calculate the count if a and b apperared\\n            if is_a and is_b:\\n                count = max(count, max_local)\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nInput: s = \"aababbb\"\\nOutput: 3\\nExplanation:\\nAll possible variances along with their respective substrings are listed below:\\n- Variance 0 for substrings \"a\", \"aa\", \"ab\", \"abab\", \"aababb\", \"ba\", \"b\", \"bb\", and \"bbb\".\\n- Variance 1 for substrings \"aab\", \"aba\", \"abb\", \"aabab\", \"ababb\", \"aababbb\", and \"bab\".\\n- Variance 2 for substrings \"aaba\", \"ababbb\", \"abbb\", and \"babb\".\\n- Variance 3 for substring \"babbb\".\\nSince the largest possible variance is 3, we return it.\\n```\n```\\nInput: s = \"abcde\"\\nOutput: 0\\nExplanation:\\nNo letter occurs more than once in s, so the variance of every substring is 0.\\n```\n```python\\n    s = \"aababbb\"\\n    s = [1, 1, -1, 1, -1, -1, -1]\\n    ```\n```python\\n    s = \"aababbb\"\\n    s = [-1, -1, 1, -1, 1, 1, 1]\\n    ```\n```python\\nclass Solution:\\n\\tdef largestVariance(self, s):\\n\\t\\tcase_1 = [1 if c == \"a\" else -1 for c in s]\\n\\t\\tcase_2 = [1 if c == \"b\" else -1 for c in s]\\n\\n\\t\\t# Appliying Kadenes algo to case 1\\n\\t\\tcase1_max = 0\\n\\t\\tcase1_total = 0\\n\\t\\tfor num in case_1:\\n\\t\\t\\tcase1_max = max(case1_max + num, num)\\n\\t\\t\\tcase1_total = max(case1_max, case1_total)\\n\\n\\t\\t# Applying Kadenes algo to case 2\\n\\t\\tcase2_max = 0 \\n\\t\\tcase2_total = 0\\n\\t\\tfor num in case_2:\\n\\t\\t\\tcase2_max = max(case2_max + num, num)\\n\\t\\t\\tcase2_total = max(case2_total, case2_max)\\n\\n\\t\\treturn max(case1_total, case2_total)\\n```\n```python\\nclass Solution:\\n\\tdef largestVariance(self, s):\\n\\t\\tmax_count = 0\\n\\t\\tfor a,b in [(\"a\", \"b\"), (\"b\", \"a\")]:\\n\\t\\t\\tmax_local = 0\\n\\t\\t\\tfor c in s:\\n\\t\\t\\t\\tif c == a:\\n\\t\\t\\t\\t\\tmax_local += 1\\n\\n\\t\\t\\t\\tif c == b:\\n\\t\\t\\t\\t\\tmax_local -= 1\\n\\n\\t\\t\\t\\tmax_count = max(max_count, max_local)\\n\\t\\t\\n\\t\\treturn max_count\\n```\n```python\\nimport itertools\\n\\n# Count the number of characters on the string\\nchars = {}\\nfor c in s:\\n\\tchars[c] = chars.get(c, 0) + 1\\n\\n# Calculate the possible permulations\\npermutations = itertools.permutations(chars, 2)\\n```\n```python\\n        count = 0\\n        max_local = 0\\n\\n\\t\\t# Keep track if c has become a or b\\n        is_a = False\\n        is_b = False\\n\\n\\t\\t# Keep track of characters for a and b\\n        val_a = chars[a]\\n        val_b = chars[b]\\n        for c in s:\\n\\t\\t\\t# No need to continue if c is not a or b\\n            if c != a and c != b:\\n                continue\\n\\n\\t\\t\\t# Reset the max_local if there are no chars left or max_total\\n\\t\\t\\t# is negative\\n            if max_local < 0 and val_a != 0 and val_b != 0:\\n                max_local = 0\\n                is_a = False\\n                is_b = False\\n\\n\\t\\t\\t\\t\\t\\t# Add 1 to the local max if c is the expected char\\n            if c == a:\\n                max_local += 1\\n                val_a -= 1\\n                is_a = True\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# Remove 1 from the local max if c is the expected char\\n            if c == b:\\n                max_local -= 1\\n                val_b -=1\\n                is_b = True\\n            \\n\\t\\t\\t\\t\\t\\t# Only calculate the count if a and b apperared\\n            if is_a and is_b:\\n                count = max(count, max_local)\\n```\n```python\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n\\t\\t# Create a dictionary with the count of all chars of s\\n        chars = {}\\n        for c in s:\\n            chars[c] = chars.get(c, 0) + 1\\n\\n        # Calculate the possible permulations\\n        permutations = itertools.permutations(chars, 2)\\n        \\n\\t\\t# Calculate the max subarray count with kadene algo\\n        count = 0\\n        for a, b in permutations:\\n            count = max(self.kadene(a, b, s, chars), count)\\n        return count\\n\\n    def kadene(self, a, b, s, chars):\\n        count = 0\\n        max_local = 0\\n\\n\\t\\t# Keep track if c has become a or b\\n        is_a = False\\n        is_b = False\\n\\n\\t\\t# Keep track of characters for a and b\\n        val_a = chars[a]\\n        val_b = chars[b]\\n        for c in s:\\n\\n\\t\\t\\t# No need to continue if c is not a or b\\n            if c != a and c != b:\\n                continue\\n\\n\\t\\t\\t# Reset the max_local if there are no chars left or max_total\\n\\t\\t    # is negative\\n            if max_local < 0 and val_a != 0 and val_b != 0:\\n                max_local = 0\\n                is_a = False\\n                is_b = False\\n\\n\\t\\t\\t# Add 1 to the local max if c is the expected char\\n            if c == a:\\n                max_local += 1\\n                val_a -= 1\\n                is_a = True\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t# Remove 1 from the local max if c is the expected char\\n            if c == b:\\n                max_local -= 1\\n                val_b -=1\\n                is_b = True\\n            \\n\\t\\t\\t# Only calculate the count if a and b apperared\\n            if is_a and is_b:\\n                count = max(count, max_local)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739212,
                "title": "c-kadane-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Upon reviewing the code, my initial thoughts on solving this problem are as follows:\\n\\n1. The code appears to be finding the largest variance between two letters in a given string. Variance here refers to the absolute difference in the count of occurrences of two letters, while maintaining the order of the letters.\\n\\n2. The code utilizes a nested loop to iterate through all possible pairs of letters (i and j) in the range \\'a\\' to \\'z\\'. It then calculates the variance between these two letters by counting their occurrences in the string.\\n\\n3. The code uses two counters, `c1` and `c2`, to keep track of the occurrences of letters i and j while iterating through the string.\\n\\n4. The maximum variance found so far is stored in the variable `ans` and is updated whenever a larger variance is found.\\n\\n5. The code also reverses the string `s` after each iteration of the innermost loop, allowing it to calculate the variance in both the forward and backward directions.\\n\\n6. The final result, the largest variance found, is returned by the function.\\n\\nOverall, the code employs a brute-force approach by checking all possible pairs of letters and calculating the variance between them. It iterates through the string twice, considering both forward and backward directions. However, without additional context or problem statement, it is difficult to determine the exact purpose or intended use of this code.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Based on the code provided, the approach to solving the problem seems to involve the following steps:\\n\\n1. Create a vector `arr` of size 26 to store the frequency of each letter from \\'a\\' to \\'z\\' in the input string `s`.\\n\\n2. Iterate through each character `x` in the string `s` and increment the corresponding frequency count in the `arr` vector using `x - \\'a\\'` as the index.\\n\\n3. Initialize a variable `ans` to store the maximum variance found.\\n\\n4. Iterate through each pair of letters `i` and `j` from \\'a\\' to \\'z\\' using nested loops. Skip the iteration if `i` and `j` are the same or if either of their frequency counts in `arr` is zero.\\n\\n5. For each pair of letters `i` and `j`, perform the following steps twice (forward and backward):\\n\\n   a. Initialize two variables, `A1` and `A2`, to represent the counters for letters `i` and `j`, respectively.\\n\\n   b. Iterate through each character `x` in the string `s`.\\n\\n   c. If `x` is equal to `i`, increment `A1`. If `x` is equal to `j`, increment `A2`.\\n\\n   d. If `A2` becomes greater than `A1`, reset both `A1` and `A2` to zero.\\n\\n   e. If both `A1` and `A2` are greater than zero, update `ans` with the maximum difference between `A1` and `A2` so far.\\n\\n   f. Reverse the string `s` using `reverse(s.begin(), s.end())` to perform the same calculation in the backward direction.\\n\\n6. After all iterations, return the maximum variance `ans`.\\n\\nThe code follows a brute-force approach by checking all possible pairs of letters and calculating the variance between them while considering the order of the letters in the string. However, without additional context or a specific problem statement, it is challenging to determine the exact purpose or optimal approach for solving this problem.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        vector<int> arr(26); // Array to store the frequency of each letter (a-z)\\n        for(auto x : s) {\\n            arr[x - \\'a\\']++; // Increment the count for the corresponding letter\\n        }\\n        int ans = 0; // Variable to store the maximum variance found\\n        for(char i = \\'a\\'; i <= \\'z\\'; i++) { // Iterate through each letter i\\n            for(char j = \\'a\\'; j <= \\'z\\'; j++) { // Iterate through each letter j\\n                // Skip if j is the same as i or either i or j has a frequency of 0\\n                if(j == i || arr[i - \\'a\\'] == 0 || arr[j - \\'a\\'] == 0)\\n                    continue;\\n                for(int k = 1; k <= 2; k++) { // Perform the calculation twice (forward and backward)\\n                    int A1 = 0; // Counter for letter i\\n                    int A2 = 0; // Counter for letter j\\n                    for(auto x : s) {\\n                        if(x == i)\\n                            A1++; // Increment A1 if the current letter is i\\n                        if(x == j)\\n                            A2++; // Increment A2 if the current letter is j\\n                        if(A2 > A1) {\\n                            A1 = 0;\\n                            A2 = 0; // Reset A1 and A2 if A2 becomes greater than A1\\n                        }\\n                        if(A1 > 0 && A2 > 0)\\n                            ans = max(ans, A1 - A2); // Update the maximum variance if A1 - A2 is greater\\n                    }\\n                    reverse(s.begin(), s.end()); // Reverse the string for the next iteration\\n                }\\n            }\\n        }\\n        return ans; // Return the maximum variance found\\n    }\\n};\\n\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/39f2d049-7bf9-4953-975e-71db43da4a24_1688876955.521812.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        vector<int> arr(26); // Array to store the frequency of each letter (a-z)\\n        for(auto x : s) {\\n            arr[x - \\'a\\']++; // Increment the count for the corresponding letter\\n        }\\n        int ans = 0; // Variable to store the maximum variance found\\n        for(char i = \\'a\\'; i <= \\'z\\'; i++) { // Iterate through each letter i\\n            for(char j = \\'a\\'; j <= \\'z\\'; j++) { // Iterate through each letter j\\n                // Skip if j is the same as i or either i or j has a frequency of 0\\n                if(j == i || arr[i - \\'a\\'] == 0 || arr[j - \\'a\\'] == 0)\\n                    continue;\\n                for(int k = 1; k <= 2; k++) { // Perform the calculation twice (forward and backward)\\n                    int A1 = 0; // Counter for letter i\\n                    int A2 = 0; // Counter for letter j\\n                    for(auto x : s) {\\n                        if(x == i)\\n                            A1++; // Increment A1 if the current letter is i\\n                        if(x == j)\\n                            A2++; // Increment A2 if the current letter is j\\n                        if(A2 > A1) {\\n                            A1 = 0;\\n                            A2 = 0; // Reset A1 and A2 if A2 becomes greater than A1\\n                        }\\n                        if(A1 > 0 && A2 > 0)\\n                            ans = max(ans, A1 - A2); // Update the maximum variance if A1 - A2 is greater\\n                    }\\n                    reverse(s.begin(), s.end()); // Reverse the string for the next iteration\\n                }\\n            }\\n        }\\n        return ans; // Return the maximum variance found\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038799,
                "title": "simple-easy-to-understand",
                "content": "**Idea?**\\n* We need to find **maximum difference** between a number of occurrences between any two characters\\' overall substrings.\\n* Fix the two characters.\\n* If we fix the two characters, then we need to find a substring with **frequency of the first character - frequency of the second character** being **maximized**.\\n* A simple solution like Kadane\\'s Algorithm will work provided the frequency of both fixed characters are non-zero and they aren\\'t the same.\\n* **Note:**- You must perform the above step for both the original string and reversed string to handle cases like: \"abbbbb\",\"aabbbbb\", etc.\\n\\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(26*26*N)\\n    // Space Complexity:- O(26)\\n    int largestVariance(string s) {\\n        int ans = 0;\\n        vector<int> freq(26);\\n        for(auto& c:s){\\n            freq[c-\\'a\\']++;\\n        }\\n        for(char ch1=\\'a\\';ch1<=\\'z\\';ch1++){\\n            for(char ch2=\\'a\\';ch2<=\\'z\\';ch2++){\\n                if(ch1==ch2 or !freq[ch1-\\'a\\'] or !freq[ch2-\\'a\\']){\\n                    continue;\\n                }\\n                for(int rev=1;rev<=2;rev++){\\n                   int cnt1 = 0,cnt2 = 0;\\n                    for(auto& c:s){\\n                        cnt1 += c==ch1;\\n                        cnt2 += c==ch2;\\n                        if(cnt1<cnt2){\\n                            cnt1 = cnt2 = 0;\\n                        }\\n                        if(cnt1>0 and cnt2>0){\\n                            ans = max(ans,cnt1-cnt2);\\n                        }\\n                    } \\n                    reverse(s.begin(),s.end());\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Don\\'t Forget to Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(26*26*N)\\n    // Space Complexity:- O(26)\\n    int largestVariance(string s) {\\n        int ans = 0;\\n        vector<int> freq(26);\\n        for(auto& c:s){\\n            freq[c-\\'a\\']++;\\n        }\\n        for(char ch1=\\'a\\';ch1<=\\'z\\';ch1++){\\n            for(char ch2=\\'a\\';ch2<=\\'z\\';ch2++){\\n                if(ch1==ch2 or !freq[ch1-\\'a\\'] or !freq[ch2-\\'a\\']){\\n                    continue;\\n                }\\n                for(int rev=1;rev<=2;rev++){\\n                   int cnt1 = 0,cnt2 = 0;\\n                    for(auto& c:s){\\n                        cnt1 += c==ch1;\\n                        cnt2 += c==ch2;\\n                        if(cnt1<cnt2){\\n                            cnt1 = cnt2 = 0;\\n                        }\\n                        if(cnt1>0 and cnt2>0){\\n                            ans = max(ans,cnt1-cnt2);\\n                        }\\n                    } \\n                    reverse(s.begin(),s.end());\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038556,
                "title": "python3-simple-kadanes-algo-faster-than-100",
                "content": "Idea: \\n\\nAs maximum number of letters is 26, we may have in the worst case 26x25 combinations of different letters, which is not bad! We can pick any two letters and check the subarrays for the maximum length with Kadanes algo! For letters x,y, I will check both cases when x-max occur, y-min occur and vice versa. As we need to have at least one occurence of each letter, I used flags to make sure of it!\\n\\n\\nHope it helps! Please upvote if you like it! \\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        def kadane(letter1, letter2, string):\\n            ans= 0\\n            cur1= cur2 = 0\\n            flag1=flag2 = True\\n\\n            for i in string:\\n                cur1+=(i==letter1)-(i==letter2)\\n                flag1 &=(i!=letter2)\\n\\n                cur2+=(i==letter2)-(i==letter1)\\n                flag2 &=(i!=letter1)\\n\\n                if cur1<0: cur1, flag1 =0, True \\n                if cur2<0: cur2, flag2=0, True \\n                ans = max(ans, cur1-flag1, cur2-flag2)\\n            return ans\\n\\n        ans = 0\\n        for a,b in combinations(set(s), 2):\\n            arr = [i for i in s if i==a or i==b]\\n            ans= max(ans, kadane(a,b,arr))\\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        def kadane(letter1, letter2, string):\\n            ans= 0\\n            cur1= cur2 = 0\\n            flag1=flag2 = True\\n\\n            for i in string:\\n                cur1+=(i==letter1)-(i==letter2)\\n                flag1 &=(i!=letter2)\\n\\n                cur2+=(i==letter2)-(i==letter1)\\n                flag2 &=(i!=letter1)\\n\\n                if cur1<0: cur1, flag1 =0, True \\n                if cur2<0: cur2, flag2=0, True \\n                ans = max(ans, cur1-flag1, cur2-flag2)\\n            return ans\\n\\n        ans = 0\\n        for a,b in combinations(set(s), 2):\\n            arr = [i for i in s if i==a or i==b]\\n            ans= max(ans, kadane(a,b,arr))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064942,
                "title": "java-solution-o-n-space-and-o-n-3-time",
                "content": "```\\n/**\\n* The given problem asks us to compute the maximum possible variance between\\n* 2 characters in any substring of the given string. This value will be the \\n* largest difference between the highest frequence element and the lowest frequency\\n* element. This problem can be broken down so that we compute the maximum possible\\n* variation between any 2 characters. By computing the maximum possible variation between\\n* all unique characters and then getting the maximum among those values we can compute\\n* the largest variance for String, s. We can start the problem by filling a hashmap with\\n* the characters in the string and their respective counts. We can then iterate through\\n* pairs of characters using a nested loop on the maps keyset. Once we have our primary\\n* character and secondary character we can compute the maximum variance for those characters\\n* using Kadane\\'s algorithm. As we iterate through the characters in our string we can check\\n* whether any of those characters belong to our pair. We can update the frequencies for those\\n* characters. It is also important that we track the count of our secondary character. This\\n* is so we can reset our frequencies. For example, if the secondary frequency outweighs the primary\\n* frequency upto that point we know that the substring upto that point has already had its max variance\\n* computed and continuing to work with that part of the string is pointless since our variance is lower\\n* than 0 for the primary character. If we have more secondary characters we can simply, reset our string\\n* to start at this new index and continue to calculate new frequencies. Therefore we reset our primary\\n* and secondary frequencies that we might meet a better frequence later down the iteration of  our string.\\n* We can keep a global variable for the nested loops which we can compare with our current max frequency\\n* between 2 characters. At the end we can simply return our variance.\\n*\\n**/\\nclass Solution {\\n    \\n    public int largestVariance(String s) {\\n        HashMap<Character, Integer> charCount = new HashMap<Character, Integer>();\\n        for (int i = 0; i < s.length(); i++) {\\n            charCount.put(s.charAt(i), charCount.getOrDefault(s.charAt(i), 0)+1);\\n        }\\n        int variance = 0;\\n        //Iterate through unique characters\\n        for (Character primaryChar: charCount.keySet()) {\\n            for  (Character secondaryChar: charCount.keySet()) {\\n                // We need a unique character  pair to compute variance\\n                if (primaryChar == secondaryChar) { continue; }\\n                int secondaryCharCount = charCount.get(secondaryChar);\\n                int primaryFreq = 0;\\n                int secondaryFreq = 0;              \\n                \\n                for (int i = 0; i < s.length(); i++) {\\n                    Character currChar = s.charAt(i);\\n                    if (currChar == primaryChar) {\\n                        primaryFreq++;  \\n                    }\\n                    if (currChar == secondaryChar) {\\n                        secondaryFreq++;\\n                        secondaryCharCount--;\\n                    }\\n                    // Variance only computed if we have already seen both a primary\\n                    // and a secondary character\\n                    if (primaryFreq > 0 && secondaryFreq > 0 && primaryFreq > secondaryFreq) {                    \\n                        variance  = Math.max(variance, (primaryFreq - secondaryFreq));\\n                    }\\n                    // We reset our index so we are ignoring the substring which will\\n                    // impact our variance negatively\\n                    if (primaryFreq < secondaryFreq && secondaryCharCount > 0) {                      \\n                        primaryFreq = 0;\\n                        secondaryFreq = 0;                       \\n                    }\\n                }\\n                \\n            }\\n        }\\n        return variance;\\n    }   \\n}```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n* The given problem asks us to compute the maximum possible variance between\\n* 2 characters in any substring of the given string. This value will be the \\n* largest difference between the highest frequence element and the lowest frequency\\n* element. This problem can be broken down so that we compute the maximum possible\\n* variation between any 2 characters. By computing the maximum possible variation between\\n* all unique characters and then getting the maximum among those values we can compute\\n* the largest variance for String, s. We can start the problem by filling a hashmap with\\n* the characters in the string and their respective counts. We can then iterate through\\n* pairs of characters using a nested loop on the maps keyset. Once we have our primary\\n* character and secondary character we can compute the maximum variance for those characters\\n* using Kadane\\'s algorithm. As we iterate through the characters in our string we can check\\n* whether any of those characters belong to our pair. We can update the frequencies for those\\n* characters. It is also important that we track the count of our secondary character. This\\n* is so we can reset our frequencies. For example, if the secondary frequency outweighs the primary\\n* frequency upto that point we know that the substring upto that point has already had its max variance\\n* computed and continuing to work with that part of the string is pointless since our variance is lower\\n* than 0 for the primary character. If we have more secondary characters we can simply, reset our string\\n* to start at this new index and continue to calculate new frequencies. Therefore we reset our primary\\n* and secondary frequencies that we might meet a better frequence later down the iteration of  our string.\\n* We can keep a global variable for the nested loops which we can compare with our current max frequency\\n* between 2 characters. At the end we can simply return our variance.\\n*\\n**/\\nclass Solution {\\n    \\n    public int largestVariance(String s) {\\n        HashMap<Character, Integer> charCount = new HashMap<Character, Integer>();\\n        for (int i = 0; i < s.length(); i++) {\\n            charCount.put(s.charAt(i), charCount.getOrDefault(s.charAt(i), 0)+1);\\n        }\\n        int variance = 0;\\n        //Iterate through unique characters\\n        for (Character primaryChar: charCount.keySet()) {\\n            for  (Character secondaryChar: charCount.keySet()) {\\n                // We need a unique character  pair to compute variance\\n                if (primaryChar == secondaryChar) { continue; }\\n                int secondaryCharCount = charCount.get(secondaryChar);\\n                int primaryFreq = 0;\\n                int secondaryFreq = 0;              \\n                \\n                for (int i = 0; i < s.length(); i++) {\\n                    Character currChar = s.charAt(i);\\n                    if (currChar == primaryChar) {\\n                        primaryFreq++;  \\n                    }\\n                    if (currChar == secondaryChar) {\\n                        secondaryFreq++;\\n                        secondaryCharCount--;\\n                    }\\n                    // Variance only computed if we have already seen both a primary\\n                    // and a secondary character\\n                    if (primaryFreq > 0 && secondaryFreq > 0 && primaryFreq > secondaryFreq) {                    \\n                        variance  = Math.max(variance, (primaryFreq - secondaryFreq));\\n                    }\\n                    // We reset our index so we are ignoring the substring which will\\n                    // impact our variance negatively\\n                    if (primaryFreq < secondaryFreq && secondaryCharCount > 0) {                      \\n                        primaryFreq = 0;\\n                        secondaryFreq = 0;                       \\n                    }\\n                }\\n                \\n            }\\n        }\\n        return variance;\\n    }   \\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2491331,
                "title": "insights-into-votrubac-soln",
                "content": "Insights into votrubac solution: https://leetcode.com/problems/substring-with-largest-variance/discuss/2039178/Weird-Kadane\\n\\n**Q1)** How is this a Kadane problem?\\nWe can reduce the problem of finding maximum frequency variation in `s`, by first constraining the search space to pairwise consideration of all possible character combinations in `s` - of which there are `26 * 26` possibilities - we can iterate through them all in constant time. This allows us to map `s` to an integer array composed entirely of `+1` for the max frequency char considered in that iteration, `-1` for the min frequency character, and `0` for characters which are neither. For example when `s` is `aabckdbsba`, and we are considering `a` as highFreq and `b` as lowFreq, the mapped array for `s` in that iteration is: `1, 1, -1, 0, 0, 0, -1, 0, -1, 1`. Similarly when we later switch the highFreq and lowFreq chars (`a` becomes low, `b` becomes high), the array for that iteration is `-1, -1, 1, 0, 0, 0, 1, 0, 1, -1`. \\n\\nIf you apply this idea to all possible character combinations, you end up with `26*26` arrays of size `s.length()`. The maximum frequency variance problem can then be interpreted as the maximum subarray sum problem, which is an `O(n)` DP problem (Kadane). The trick is implementing Kadane correctly here.\\n\\n**Q2a)** Why do we discard the prefix when the variance goes negative?\\n\\n![image](https://assets.leetcode.com/users/images/ae74f2d3-88ff-47fa-a5b1-0a57cb73c31c_1661621029.0343204.png)\\n\\nWhen the variance goes negative, this means in our current substring, we have more lowFreq chars than highFreq characters - let\\'s say this is not a concern, because if there are remaining characters in `s`, we can possible continue to extend the substring and the frequency may go positive again, right?\\n\\nIf we kept the prefix and continued extending, what if the subsequent char is a lowFreq character? This would force the variance to go even lower - then the suffix after this point, no matter how positive it is, would be forced to add onto -2 rather than -1.\\n\\n**Q2b)** How do we handle adjacent lowFreq chars at the start of a prefix? i.e. `bb` case\\n\\nSuppose we did indeed discard the prefix, as explained in Q2. Now, we start the new prefix at the character which drove our variance negative. Then pick up the case mentioned above, where the subsequent character is still a lowFreq char. If we include it (extend the prefix), then our variance is back to -2, and we encounter the same problem as mentioned above. So, what are our options? We can discard the prefix again, which means that instead of two lowFreq chars, we\\'ll just have one lowFreq char as the root of this new prefix (-2 vs. -1).\\n\\n![image](https://assets.leetcode.com/users/images/b54da300-85d0-4bb1-b027-a98752117628_1661621381.1848505.png)\\n\\n![image](https://assets.leetcode.com/users/images/ffcf83ac-b65c-4258-9a0c-3ea4b26fb470_1661621482.622762.png)\\n\\n**Q4)** What\\'s the point of `first_b`?\\n\\nThis is part of why we discard prefixes. We can observe that whenever we discard prefixes, we do so because we\\'ve encountered a lowFreq character that brings the variance below 0. That means, when we discard prefixes, we always start new prefixes on a lowFreq character, and that is when we set `first_b`. Why is this important?\\n\\nSuppose we proceeded to build the prefix below (we pick the second `b` here because of the reason described in **Q2b**):\\n\\n![image](https://assets.leetcode.com/users/images/1f9f9aaf-f2c1-43f3-999a-37b08aff48bc_1661621704.1533308.png)\\n\\nThe prefix contains `baa`, and our `first_b` flag is set - it refers to that `b` which is the root of this prefix.\\n\\nWhen we then encounter that second `b`:\\n\\n![image](https://assets.leetcode.com/users/images/7924fc9c-f4fc-481a-9887-ea40445f070c_1661621785.6016202.png)\\n\\nWell, now the prefix is `baab` - Is that the best we can do? No, because in this window, the ideal prefix would be `aab` - that gives us a variance of 1. Because `first_b` is set, this indicates to us that the current prefix starts with a lowFreq char - which means we are allowed to discard it and still maintain a valid substring! Discarding it allows us to not decrement the variance once we add that second `b`.\\n\\n![image](https://assets.leetcode.com/users/images/72543a88-a026-412b-8161-c0dc5c3443eb_1661621924.7503421.png)\\n\\nSo everytime we need to add a lowFreq character to the current substring, we check if it\\'s possible for it to replace the `first_b` character. If not, then we\\'re forced to add it - and if adding it brings the variance to -1, then we go back to **Q2a** and **Q2b** above.\\n",
                "solutionTags": [],
                "code": "Insights into votrubac solution: https://leetcode.com/problems/substring-with-largest-variance/discuss/2039178/Weird-Kadane\\n\\n**Q1)** How is this a Kadane problem?\\nWe can reduce the problem of finding maximum frequency variation in `s`, by first constraining the search space to pairwise consideration of all possible character combinations in `s` - of which there are `26 * 26` possibilities - we can iterate through them all in constant time. This allows us to map `s` to an integer array composed entirely of `+1` for the max frequency char considered in that iteration, `-1` for the min frequency character, and `0` for characters which are neither. For example when `s` is `aabckdbsba`, and we are considering `a` as highFreq and `b` as lowFreq, the mapped array for `s` in that iteration is: `1, 1, -1, 0, 0, 0, -1, 0, -1, 1`. Similarly when we later switch the highFreq and lowFreq chars (`a` becomes low, `b` becomes high), the array for that iteration is `-1, -1, 1, 0, 0, 0, 1, 0, 1, -1`. \\n\\nIf you apply this idea to all possible character combinations, you end up with `26*26` arrays of size `s.length()`. The maximum frequency variance problem can then be interpreted as the maximum subarray sum problem, which is an `O(n)` DP problem (Kadane). The trick is implementing Kadane correctly here.\\n\\n**Q2a)** Why do we discard the prefix when the variance goes negative?\\n\\n![image](https://assets.leetcode.com/users/images/ae74f2d3-88ff-47fa-a5b1-0a57cb73c31c_1661621029.0343204.png)\\n\\nWhen the variance goes negative, this means in our current substring, we have more lowFreq chars than highFreq characters - let\\'s say this is not a concern, because if there are remaining characters in `s`, we can possible continue to extend the substring and the frequency may go positive again, right?\\n\\nIf we kept the prefix and continued extending, what if the subsequent char is a lowFreq character? This would force the variance to go even lower - then the suffix after this point, no matter how positive it is, would be forced to add onto -2 rather than -1.\\n\\n**Q2b)** How do we handle adjacent lowFreq chars at the start of a prefix? i.e. `bb` case\\n\\nSuppose we did indeed discard the prefix, as explained in Q2. Now, we start the new prefix at the character which drove our variance negative. Then pick up the case mentioned above, where the subsequent character is still a lowFreq char. If we include it (extend the prefix), then our variance is back to -2, and we encounter the same problem as mentioned above. So, what are our options? We can discard the prefix again, which means that instead of two lowFreq chars, we\\'ll just have one lowFreq char as the root of this new prefix (-2 vs. -1).\\n\\n![image](https://assets.leetcode.com/users/images/b54da300-85d0-4bb1-b027-a98752117628_1661621381.1848505.png)\\n\\n![image](https://assets.leetcode.com/users/images/ffcf83ac-b65c-4258-9a0c-3ea4b26fb470_1661621482.622762.png)\\n\\n**Q4)** What\\'s the point of `first_b`?\\n\\nThis is part of why we discard prefixes. We can observe that whenever we discard prefixes, we do so because we\\'ve encountered a lowFreq character that brings the variance below 0. That means, when we discard prefixes, we always start new prefixes on a lowFreq character, and that is when we set `first_b`. Why is this important?\\n\\nSuppose we proceeded to build the prefix below (we pick the second `b` here because of the reason described in **Q2b**):\\n\\n![image](https://assets.leetcode.com/users/images/1f9f9aaf-f2c1-43f3-999a-37b08aff48bc_1661621704.1533308.png)\\n\\nThe prefix contains `baa`, and our `first_b` flag is set - it refers to that `b` which is the root of this prefix.\\n\\nWhen we then encounter that second `b`:\\n\\n![image](https://assets.leetcode.com/users/images/7924fc9c-f4fc-481a-9887-ea40445f070c_1661621785.6016202.png)\\n\\nWell, now the prefix is `baab` - Is that the best we can do? No, because in this window, the ideal prefix would be `aab` - that gives us a variance of 1. Because `first_b` is set, this indicates to us that the current prefix starts with a lowFreq char - which means we are allowed to discard it and still maintain a valid substring! Discarding it allows us to not decrement the variance once we add that second `b`.\\n\\n![image](https://assets.leetcode.com/users/images/72543a88-a026-412b-8161-c0dc5c3443eb_1661621924.7503421.png)\\n\\nSo everytime we need to add a lowFreq character to the current substring, we check if it\\'s possible for it to replace the `first_b` character. If not, then we\\'re forced to add it - and if adding it brings the variance to -1, then we go back to **Q2a** and **Q2b** above.\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2038438,
                "title": "python3-using-max-sum-subarray-with-explanation",
                "content": "\\nGiven the constraints, an O(n^2) solution won\\'t suffice. Noticing that there are at most a constant amount of letters, one idea is to try and compute the maximum variance between any two possible letters in the string `s`. If we can find a way to this in O(n) time, then we can solve the problem. \\n\\nSo for any substring, we want to find the maximum absolute difference of two letters say \\'a\\' and \\'b\\'. Since we only care about \\'a\\' and \\'b\\', we can ignore all other letters in `s` . Lets drop the absolute value and just try to find frequency(\\'b\\') - frequencyy(\\'a\\'). For any substring, a \\'b\\' contributes a value of 1 to that difference and an \\'a\\' contributes a value of -1. If we imagine an array `arr` where `arr[i]=-1` if `s[i]==\\'a\\'`, 1 if `s[i]==\\'b\\'` and 0 otherwise, then any subarray corresponds to a substring of `s` and its sum is equal to the frequency of \\'b\\' minus the frequency of \\'a\\'. Also notice, only the relative ordering of the 1s and -1s matter so we can actually drop the 0s to boost efficiency.\\n\\nWell not quite. If you had a subarray that does not contain an -1. That implies that there is no \\'a\\' in the substring. So we need to consider all subarrays that contain at least one -1.\\n\\nSo our algorithm will then be to consider all pairs of letters (x,y) in `s` (no repeats of course) and then for each (x,y), construct an array as described above where we append 1 if `s[i]=x` or append -1 if `s[i]=y` else don\\'t do anything. We then run kadanes algorithm for finding the max sum subarray with a slight modification where we check to see if an -1 has been seen in our subarray before updating the maximum sum. If an -1 has been seen, we proceed as normal, if not then we set `ans=max(ans,runningSum-1)` to represent extending our subarray to include the occurence of -1 before it. We then rerun kadanes algorithm on the array where all entries are negated because we want the maximum absolute difference. We return the maximum value returned across all calls of kadanes algorithm.\\n\\n\\n```\\nclass Solution:\\n    class Solution:\\n    def largestVariance(self, s: str) -> int:\\n        \\n        def maxSubArray(nums: List[int]):\\n            ans=-float(\\'inf\\')\\n            runningSum=0\\n            seen=False\\n            for x in (nums):\\n                if x<0:\\n                    seen=True\\n                runningSum+=x\\n                if seen:\\n                    ans=max(ans,runningSum)\\n                else:\\n                    ans=max(ans,runningSum-1)\\n                if runningSum<0:\\n                    runningSum=0\\n                    seen=False\\n            return ans\\n        \\n        f=set()\\n        a=\\'\\'\\n        for x in s:\\n            if x not in f:\\n                a+=x\\n                f.add(x)\\n       \\n        n=len(s)\\n        res=0\\n        for j in range(len(a)-1):\\n            for k in range(j+1,len(a)):\\n                x=a[j]\\n                y=a[k]\\n                arr=[]\\n                for i in range(n):\\n                    if s[i]!=x and s[i]!=y:\\n                        continue\\n                    elif s[i]==x:\\n                        arr.append(1)\\n                    else:\\n                        arr.append(-1)\\n                \\n                res=max(res,maxSubArray(arr),maxSubArray([-x for x in arr]))\\n                \\n        return res\\n                \\n                \\n                \\n                \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    class Solution:\\n    def largestVariance(self, s: str) -> int:\\n        \\n        def maxSubArray(nums: List[int]):\\n            ans=-float(\\'inf\\')\\n            runningSum=0\\n            seen=False\\n            for x in (nums):\\n                if x<0:\\n                    seen=True\\n                runningSum+=x\\n                if seen:\\n                    ans=max(ans,runningSum)\\n                else:\\n                    ans=max(ans,runningSum-1)\\n                if runningSum<0:\\n                    runningSum=0\\n                    seen=False\\n            return ans\\n        \\n        f=set()\\n        a=\\'\\'\\n        for x in s:\\n            if x not in f:\\n                a+=x\\n                f.add(x)\\n       \\n        n=len(s)\\n        res=0\\n        for j in range(len(a)-1):\\n            for k in range(j+1,len(a)):\\n                x=a[j]\\n                y=a[k]\\n                arr=[]\\n                for i in range(n):\\n                    if s[i]!=x and s[i]!=y:\\n                        continue\\n                    elif s[i]==x:\\n                        arr.append(1)\\n                    else:\\n                        arr.append(-1)\\n                \\n                res=max(res,maxSubArray(arr),maxSubArray([-x for x in arr]))\\n                \\n        return res\\n                \\n                \\n                \\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372714,
                "title": "c-simple-c-code-o-26-26-n-90-time",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int Kadane(int x, int y, string &s)\\n    {\\n        int d = 0, n = s.size();\\n        int ans = 0, ycnt = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if((s[i]-\\'a\\') == x)\\n            {\\n                d++;\\n            }\\n            else if((s[i]-\\'a\\') == y)\\n            {\\n                d--;\\n                ycnt = 1;\\n            }\\n            if(ycnt != 0)\\n            {\\n                ans = max(ans, d);\\n            }\\n            else\\n            {\\n                ans = max(ans, d-1);\\n            }\\n            if(d < 0)\\n            {\\n                ycnt = 0;\\n                d = 0;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int largestVariance(string s) {\\n        vector<int> alphabet(26,0);\\n        int ans = 0;\\n        for(char &ch : s)\\n            alphabet[ch-\\'a\\']++;\\n        for(int i = 0; i < 25; i++)\\n        {\\n            if(alphabet[i] == 0) continue;\\n            for(int j = i+1; j < 26; j++)\\n            {\\n                if(alphabet[j] == 0) continue;\\n                //cout << i << \" \" << j << endl;\\n                int val = max(Kadane(i,j,s), Kadane(j,i,s));\\n                ans = max(val, ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int Kadane(int x, int y, string &s)\\n    {\\n        int d = 0, n = s.size();\\n        int ans = 0, ycnt = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if((s[i]-\\'a\\') == x)\\n            {\\n                d++;\\n            }\\n            else if((s[i]-\\'a\\') == y)\\n            {\\n                d--;\\n                ycnt = 1;\\n            }\\n            if(ycnt != 0)\\n            {\\n                ans = max(ans, d);\\n            }\\n            else\\n            {\\n                ans = max(ans, d-1);\\n            }\\n            if(d < 0)\\n            {\\n                ycnt = 0;\\n                d = 0;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int largestVariance(string s) {\\n        vector<int> alphabet(26,0);\\n        int ans = 0;\\n        for(char &ch : s)\\n            alphabet[ch-\\'a\\']++;\\n        for(int i = 0; i < 25; i++)\\n        {\\n            if(alphabet[i] == 0) continue;\\n            for(int j = i+1; j < 26; j++)\\n            {\\n                if(alphabet[j] == 0) continue;\\n                //cout << i << \" \" << j << endl;\\n                int val = max(Kadane(i,j,s), Kadane(j,i,s));\\n                ans = max(val, ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3738611,
                "title": "beats-100-fast-solution-unordered-set-fully-optimized",
                "content": "![2011fd12-ec1d-4f0a-ba7a-1444d2514279_1652570779.202012.png](https://assets.leetcode.com/users/images/94d157ac-f25a-4a03-b741-a73309fa6abb_1688861468.1538856.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe solve it independently for each combination of 2 characters. We use variables a and b below, and their values could be any character. We go left-to-right, and:\\n\\nFor a, we increase our variance (+1).\\nFor b - decrease ( -1).\\nWhen the variance goes negative, we restart.\\nThis is Kadane\\'s algorithm. Hower, we need to make sure that the substring includes at least one b character. Therefore, we update the result only if has_b is true.\\n\\nAnother trick is that we need to track whether our substring starts with b. If we encounter another b - we can trim the first one (no change to the variance).\\n\\nHowever, when the variance goes negative, the next substring will start with b again (first_b = true).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int largestVariance(string s) {\\n    int res = 0;\\n    unordered_set<char> unique(begin(s), end(s));\\n    for (char a : unique)\\n        for (char b : unique) {\\n            int var = 0, has_b = 0, first_b = 0;\\n            for (auto ch : s) {\\n                var += ch == a;\\n                if (ch == b) {\\n                    has_b = true;\\n                    if (first_b && var >= 0)\\n                        first_b = false;\\n                    else if (--var < 0) {\\n                        first_b = true;\\n                        var = -1;\\n                    }\\n                }\\n                res = max(res, has_b ? var : 0);\\n            }\\n        }\\n    return res;\\n}\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/4875aa93-a7be-4717-b3a4-4fc8685cda9e_1688861495.3035545.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int largestVariance(string s) {\\n    int res = 0;\\n    unordered_set<char> unique(begin(s), end(s));\\n    for (char a : unique)\\n        for (char b : unique) {\\n            int var = 0, has_b = 0, first_b = 0;\\n            for (auto ch : s) {\\n                var += ch == a;\\n                if (ch == b) {\\n                    has_b = true;\\n                    if (first_b && var >= 0)\\n                        first_b = false;\\n                    else if (--var < 0) {\\n                        first_b = true;\\n                        var = -1;\\n                    }\\n                }\\n                res = max(res, has_b ? var : 0);\\n            }\\n        }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238783,
                "title": "python-solution-easy-to-understand",
                "content": "need reference prob 53, try to complete number 53 prob first. and then come to this one\\nIdea here:\\nwe always compare 2 different charactors, assume `a`, `b`\\nin the string `s`, when we see `a`, we convert to 1, `b` to -1 to build an array like  `[1,1,-1,1,-1,-1,-1,1]`\\nso we are looking for, many of 1s  plus just one -1, this will be the max diff.  \\nWhy need a -1?  If all 1s, it just represented one charactor. \\nto relosve above,\\nwe are looking for -1 and what is the max on its left and right. then `left + right - itself` \\nwhy `- itself`?  itself has counted in both left and right, hence `- itself`. \\nnow, referecne leetcode prob 53, 2 dp arrays dp1, dp2\\ndp1 left to right to record each max sum at that index \\ndp2 right to left to record each max sum at that index\\nfor the `1 and -1` array, each time we see a `-1`, let\\'s find dp1[i] + dp2[i] - arr[i]\\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        \\n        def helper(arr): # leetcode prob #53\\n            n = len(arr)\\n            dp1 = [0] * n\\n            dp2 = [0] * n\\n            dp1[0] = arr[0]\\n            dp2[-1] = arr[-1]\\n            \\n            for i in range(1,n):\\n                dp1[i] = max(arr[i], dp1[i-1] + arr[i])\\n            \\n            for j in range(n-2,-1,-1):\\n                dp2[j] = max(arr[j], dp2[j+1] + arr[j])\\n            \\n            ans = 0\\n            for k in range(n):\\n                if arr[k] == -1:\\n                    ans = max(ans, dp1[k] + dp2[k] - arr[k])\\n            return ans\\n        \\n        res = 0\\n        lookup = Counter(s) # find unique charactors\\n        for c1 in lookup:\\n            for c2 in lookup:\\n                if c1 != c2:\\n                    arr = []\\n                    for c in s:\\n                        if c1 == c:\\n                            arr.append(1)\\n                        elif c2 == c:\\n                            arr.append(-1)\\n                    res = max(res, helper(arr))\\n        return res\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "need reference prob 53, try to complete number 53 prob first. and then come to this one\\nIdea here:\\nwe always compare 2 different charactors, assume `a`, `b`\\nin the string `s`, when we see `a`, we convert to 1, `b` to -1 to build an array like  `[1,1,-1,1,-1,-1,-1,1]`\\nso we are looking for, many of 1s  plus just one -1, this will be the max diff.  \\nWhy need a -1?  If all 1s, it just represented one charactor. \\nto relosve above,\\nwe are looking for -1 and what is the max on its left and right. then `left + right - itself` \\nwhy `- itself`?  itself has counted in both left and right, hence `- itself`. \\nnow, referecne leetcode prob 53, 2 dp arrays dp1, dp2\\ndp1 left to right to record each max sum at that index \\ndp2 right to left to record each max sum at that index\\nfor the `1 and -1` array, each time we see a `-1`, let\\'s find dp1[i] + dp2[i] - arr[i]\\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        \\n        def helper(arr): # leetcode prob #53\\n            n = len(arr)\\n            dp1 = [0] * n\\n            dp2 = [0] * n\\n            dp1[0] = arr[0]\\n            dp2[-1] = arr[-1]\\n            \\n            for i in range(1,n):\\n                dp1[i] = max(arr[i], dp1[i-1] + arr[i])\\n            \\n            for j in range(n-2,-1,-1):\\n                dp2[j] = max(arr[j], dp2[j+1] + arr[j])\\n            \\n            ans = 0\\n            for k in range(n):\\n                if arr[k] == -1:\\n                    ans = max(ans, dp1[k] + dp2[k] - arr[k])\\n            return ans\\n        \\n        res = 0\\n        lookup = Counter(s) # find unique charactors\\n        for c1 in lookup:\\n            for c2 in lookup:\\n                if c1 != c2:\\n                    arr = []\\n                    for c in s:\\n                        if c1 == c:\\n                            arr.append(1)\\n                        elif c2 == c:\\n                            arr.append(-1)\\n                    res = max(res, helper(arr))\\n        return res\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2126305,
                "title": "javascript-try-each-pair-of-characters",
                "content": "**Solution: Try Each Pair of Characters**\\n\\nWhen we only have two unique characters, we can find the largest difference in `O(n)` time using kadane\\'s algorithm.\\nSince s consists of lowercase letters only, there are only at most `26 * 26` different pairs.\\nWe can try each pair of characters.\\n\\nTo recap kadane\\'s algorithm: Keep an ongoing sum, when it becomes negative reset it to the current number -> take `max(sum + curr, curr)`\\n\\nOne catch is that the substring must contain both of the characters, so we need to account for the case where the substring only consists of one character.\\nWe can do this by keeping track of whether the other character existed before, and can \\'virtually\\' add it back when we need it.\\n  `e.g: \"abbb\", where we need the \"a\" in front of the 3 b\\'s.`\\n\\nTime Complexity: `O(26^2 * n)` 1286ms\\nSpace Complexity: `O(n)` 44.4MB\\n```\\nvar largestVariance = function(s) {\\n  let chars = new Set(s.split(\"\")), maxDiff = 0;\\n  for (let l of chars) {\\n    for (let r of chars) {\\n      if (l === r) continue;\\n      let lCount = 0, rCount = 0, hasRight = false;\\n      for (let char of s) {\\n        lCount += char === l ? 1 : 0;\\n        rCount += char === r ? 1 : 0;\\n        if (rCount > 0 && lCount > rCount) { // has both characters and positive difference\\n          maxDiff = Math.max(maxDiff, lCount - rCount);\\n        }\\n        if (lCount > rCount && hasRight) { // has positive difference and a previous \"right\" character we can add to the start\\n          maxDiff = Math.max(maxDiff, lCount - rCount - 1);\\n        }\\n        if (lCount < rCount) {\\n          lCount = 0, rCount = 0;\\n          hasRight = true; \\n        }\\n      }\\n    }\\n  }\\n  return maxDiff;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestVariance = function(s) {\\n  let chars = new Set(s.split(\"\")), maxDiff = 0;\\n  for (let l of chars) {\\n    for (let r of chars) {\\n      if (l === r) continue;\\n      let lCount = 0, rCount = 0, hasRight = false;\\n      for (let char of s) {\\n        lCount += char === l ? 1 : 0;\\n        rCount += char === r ? 1 : 0;\\n        if (rCount > 0 && lCount > rCount) { // has both characters and positive difference\\n          maxDiff = Math.max(maxDiff, lCount - rCount);\\n        }\\n        if (lCount > rCount && hasRight) { // has positive difference and a previous \"right\" character we can add to the start\\n          maxDiff = Math.max(maxDiff, lCount - rCount - 1);\\n        }\\n        if (lCount < rCount) {\\n          lCount = 0, rCount = 0;\\n          hasRight = true; \\n        }\\n      }\\n    }\\n  }\\n  return maxDiff;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3740725,
                "title": "simple-solution-explained-with-example-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is really a nice problem and can be only solved if we observe the examples really carefully. Let me explain the whole problem with the help of an example \\n\\n**Let the string be \"aababbb\"**\\n\\nNow to calculate the variance we need the **(count of some charcter) - (count of some other charcter)** and we need to do this for every substring so that we can calculate the **max out of all the substrings**\\n\\nNow, In the above paragraph, **I gave you a small hint**\\n\\nThe hint is **(count of some charcter - count of some other character)**, so it means that we can any choose any 2 random characters and calculate the differnce of counts between them\\n\\nLet us take a simple example, **let the first choosen character will be \"a\" and the second choosen charcter is \"b\"**, and let us try to calculate the variance for the whole string only.....\\n\\nNow , just for explanation purpose, consider this string is a **bollywood movie** where **first charcter is our main hero** and the **second charcter is our villain** , and the **hero has to win always** and for winning ,\\n\\nThe **strength of the hero should be greater then the strength of villain** , so let us say at the starting point both of them have a **strength equal to 0** which means they are not even born\\n\\nNow let us start iterating \\n\\nAt 0th index we see a \"a\", so we **increase the strength of a by 1**\\n\\nAt 1st index we see a \"a\", so we increase the strength of \"a\" by 1 so total strength becomes 2 for \"a\" and for \"b\" it is 0 , **but they can\\'t fight right now as the villain is not even born** :)\\n\\nAt 2nd index we see a \"b\" so we increase the strength of \"b\" by 1 so the strength of b becomes one and for \"a\" it is 2 and **they can fight now so if they fight (2-1) our ans comes to be 1**, which we can store it in some variable say max\\n\\nAt 3rd index we see a \"a\" so we increase the strength of \"a\" by 1 so the strength of \"a\" becomes 3 and for \"b\" it is 1, and they can fight so after fight the **variance comes to be (3-1) = 2, which was bigger then what we stored in max so now max contains 2**\\n\\nAt 4th index, we see a \"b\" so strength of b is \"2\" now and for \"a\" it is 3 and after fight it becomes (3-2)=1, **which is less then max so we move on**\\n\\nAt 5th index, **we see a \"b\" so strength of b is \"3\"** and \"a\" is also 3 and after fight it comes out to be 0 which is less then max so we will continue\\n\\nAt 6th index, we see a \"b\" again , so strength of b is \"4\" and for \"a\" is 3, but **we see that the strength of villain is stronger then the hero (\"a\") which is not possible** so our hero loses and as per bollywood movie ,both of them will have a rebirth again so , now again the **strength of \"a\" is 0 and b is \"0\"**,\\n\\nand for this particular combaintion **where first character was \"a\" and second charatcer was \"b\"**, the max variance comes out to be 2 \\n\\nNow for some other combination , let us say first charcter ( our hero) is \"b\" and second charcter is \"a\", if we calculate the varinace using the above steps **we find the max variance as 3 which is our ans**\\n\\nYou just need to keep a simple thing in your mind \\n\\n**If the strength of villain > strength of hero then hero loses and rebirth takes place for both of them (so count of both the strength becomes zero)**\\n\\n***This is the main crux of the question*** , This will help you in calculating the variance of all the subarrays and will help you find the maximum one \\n\\n**Now , there is a special case as well, let us say the string is \"abbbbb\" and b is our hero and a is our villain**,\\n\\nIn such a case , we will see on the zero index only, the strength of \"a\" becomes 1 and strength of hero remains zero(he is not born only)\\n\\n**So for such cases, we just need to reverse the string and perform the above told steps**\\n\\nSo we will have 2 cases , where we will take out the ans for the **string without reversing and the other one will be where we will be reversing the string** , we just need to send the max of both of them.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) We have to choose 2 random charcters every time, so we will run a for loop within a for loop which will point to some random charcters every time\\n\\n2) We will initalise the count of both char as 0 and as we iterate the string we will increase the count of that charcter if we see any of the choosen character\\n\\n3) If the strength of second charcter increases then the first charcter then **both of them wil be reinitalised to be 0**.\\n\\n4) We have to make sure that, they can only fight, if both of them are born (**which means the count of first charcter is >0 and count of second charcter is >0**)\\n\\n5) Do it for all 26 characters and we will get our ans :)\\n\\n6) Repeat the same steps for the reverse of string as well.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe will be choosing 2 random charcters so for that **we are running a for loop within a for loop** and for two random charcters **we are iterating the whole string** , so\\n\\n**O(26 * 26 * N)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo extra space taken so **O(1)**\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    int solve(string s)\\n    {\\n        int ans  = 0;\\n\\n        for(char i =\\'a\\'; i<=\\'z\\'; i++)\\n        {\\n            for(char j = \\'a\\'; j<=\\'z\\'; j++)\\n            {\\n                if(i!=j)\\n                {\\n                    int cnt1 = 0;\\n                    int cnt2 =0;\\n                    for(int k=0; k<s.size(); k++)\\n                    {\\n                        if(s[k]==i)\\n                        {\\n                            cnt1++;\\n                        }\\n                        if(s[k]==j)\\n                        {\\n                            cnt2++;\\n                        }\\n                        if(cnt2>cnt1)\\n                        {\\n                            cnt1 = 0;\\n                            cnt2 = 0;\\n                        }\\n\\n                        if(cnt1>0 && cnt2>0)\\n                        {\\n                            ans = max(ans,cnt1-cnt2);\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    int largestVariance(string s) {\\n        int a  = solve(s);\\n        reverse(s.begin(),s.end());\\n        int b  = solve(s);\\n\\n        return max(a,b);\\n\\n    }\\n};\\n```\\n\\n**TIME FOR A MEME NOW** \\n\\n![WhatsApp Image 2023-07-09 at 16.52.21.jpeg](https://assets.leetcode.com/users/images/ac76d47f-8e8c-4ad6-a924-650a7ca1a357_1688901938.9452684.jpeg)\\n\\n**IF YOU LIKE MY SOLUTION , PLEASE UPVOTE....**",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    int solve(string s)\\n    {\\n        int ans  = 0;\\n\\n        for(char i =\\'a\\'; i<=\\'z\\'; i++)\\n        {\\n            for(char j = \\'a\\'; j<=\\'z\\'; j++)\\n            {\\n                if(i!=j)\\n                {\\n                    int cnt1 = 0;\\n                    int cnt2 =0;\\n                    for(int k=0; k<s.size(); k++)\\n                    {\\n                        if(s[k]==i)\\n                        {\\n                            cnt1++;\\n                        }\\n                        if(s[k]==j)\\n                        {\\n                            cnt2++;\\n                        }\\n                        if(cnt2>cnt1)\\n                        {\\n                            cnt1 = 0;\\n                            cnt2 = 0;\\n                        }\\n\\n                        if(cnt1>0 && cnt2>0)\\n                        {\\n                            ans = max(ans,cnt1-cnt2);\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    int largestVariance(string s) {\\n        int a  = solve(s);\\n        reverse(s.begin(),s.end());\\n        int b  = solve(s);\\n\\n        return max(a,b);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564502,
                "title": "java-commented-walkthrough",
                "content": "Time O(26 * 26 * N) N is the length of the string\\nSpace O(1)\\n```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        \\n        // First get the count of all characters in the string\\n        int[] freq = new int[26];\\n        boolean invalid = true;\\n        for (int i = 0; i < s.length(); i++) {\\n            // if the character frequency is never greater than 1\\n            // then the max variance is always 0. (ab == 0, but aab == 1)\\n            if (++freq[s.charAt(i) - \\'a\\'] > 1) { \\n                invalid = false;\\n            }\\n        }\\n        if (invalid) return 0;\\n        \\n        // Next we need to compare the number of occurrences between \\n        // every character in the string so the complexity is O(26*26) worst case\\n        int maxVariance = 0;\\n        \\n        for (int i = 0; i < 26; i++) {\\n            if (freq[i] == 0) // if freq == 0 then character does not exist \\n                continue;\\n            \\n            for (int j = 0; j < 26; j++) {\\n                if (i == j || freq[j] == 0) // if the same as first character or does not exist\\n                    continue;\\n                \\n                // Now we have 2 chars to compare\\n                // iterate over the string compare the count of the first character i\\n                // with the second character j and decrease their frequency\\n                int c1_count = 0, c2_count = 0, c1_freq = freq[i], c2_freq = freq[j];\\n                for (char c: s.toCharArray()) {\\n                    int curr = c-\\'a\\'; // current character in string\\n                    \\n                    if (curr == i) {\\n                        c1_count++;\\n                        c1_freq--;\\n                    }\\n                    else if (curr == j) {\\n                        c2_count++;\\n                        c2_freq--;\\n                    }\\n                    else {\\n                        continue; // neither character increased no action required\\n                    }\\n                    \\n                    // if first character count is less than the second character count\\n                    // and both characters have atleast one character left in the string\\n                    // then we reset both counts to try a better substring\\n                    if (c1_count < c2_count &&  c1_freq > 0 && c2_freq > 0) {\\n                        c1_count = 0; c2_count = 0;\\n                    }\\n                    // if second character count is atleast 1 and first character count is\\n                    // greater than second character count,\\n                    // check if variance is greater than maxVariance\\n                    else if (c2_count > 0 && c1_count > c2_count) {\\n                        maxVariance = Math.max(maxVariance, c1_count - c2_count);\\n                    }\\n                    // if both character frequency is 0 then no more variances in string\\n                    // for the current two characters, so we break out of the loop\\n                    else if (c1_freq+c2_freq == 0)\\n                        break;\\n                }\\n            }\\n        }\\n        return maxVariance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        \\n        // First get the count of all characters in the string\\n        int[] freq = new int[26];\\n        boolean invalid = true;\\n        for (int i = 0; i < s.length(); i++) {\\n            // if the character frequency is never greater than 1\\n            // then the max variance is always 0. (ab == 0, but aab == 1)\\n            if (++freq[s.charAt(i) - \\'a\\'] > 1) { \\n                invalid = false;\\n            }\\n        }\\n        if (invalid) return 0;\\n        \\n        // Next we need to compare the number of occurrences between \\n        // every character in the string so the complexity is O(26*26) worst case\\n        int maxVariance = 0;\\n        \\n        for (int i = 0; i < 26; i++) {\\n            if (freq[i] == 0) // if freq == 0 then character does not exist \\n                continue;\\n            \\n            for (int j = 0; j < 26; j++) {\\n                if (i == j || freq[j] == 0) // if the same as first character or does not exist\\n                    continue;\\n                \\n                // Now we have 2 chars to compare\\n                // iterate over the string compare the count of the first character i\\n                // with the second character j and decrease their frequency\\n                int c1_count = 0, c2_count = 0, c1_freq = freq[i], c2_freq = freq[j];\\n                for (char c: s.toCharArray()) {\\n                    int curr = c-\\'a\\'; // current character in string\\n                    \\n                    if (curr == i) {\\n                        c1_count++;\\n                        c1_freq--;\\n                    }\\n                    else if (curr == j) {\\n                        c2_count++;\\n                        c2_freq--;\\n                    }\\n                    else {\\n                        continue; // neither character increased no action required\\n                    }\\n                    \\n                    // if first character count is less than the second character count\\n                    // and both characters have atleast one character left in the string\\n                    // then we reset both counts to try a better substring\\n                    if (c1_count < c2_count &&  c1_freq > 0 && c2_freq > 0) {\\n                        c1_count = 0; c2_count = 0;\\n                    }\\n                    // if second character count is atleast 1 and first character count is\\n                    // greater than second character count,\\n                    // check if variance is greater than maxVariance\\n                    else if (c2_count > 0 && c1_count > c2_count) {\\n                        maxVariance = Math.max(maxVariance, c1_count - c2_count);\\n                    }\\n                    // if both character frequency is 0 then no more variances in string\\n                    // for the current two characters, so we break out of the loop\\n                    else if (c1_freq+c2_freq == 0)\\n                        break;\\n                }\\n            }\\n        }\\n        return maxVariance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042089,
                "title": "dp-with-detailed-explaination",
                "content": "let me sort out the question.\\n\\ngiven a string s ,we need to find the greatest difference between the number of occurrences of any 2 characters among all the substrings of s.\\n\\nand the string s  consists of 26 lowercase english letters.\\n\\nwe can enumerate the character a and character b with two nested for loops, the time is o(26*26). \\n\\nafter that, the further question is how to get the greatest difference between a and b among all the substrings of s.\\n\\nI think we can use dynamic programming technique. Plus it can be abstracted into another common problem: the largest sum of subarray. \\n\\nwhen char a occurs, sum += 1,  when char b occurs, sum -= 1, just get the largest sum. but note that what we want is if and only if when there are two chars. so there are some different.\\n\\ndefine dp(i,0) as the largest sum value when ended with s [i] and don\\'t care the existence of char b.\\n\\nso dp(i,0)  has the following results.\\n\\n\\n1. if s[i] == a, dp(i,0) = dp(i-1,0)+1.\\n\\n1. if s[i] == b, dp(i,0) = dp(i-1,0) -1. \\n\\n\\t1. if dp(i,0) < 0, dp(i,0) = 0.\\n\\n\\n\\ndp(i,1) represents the largetst sum value when ended with s[i] and it contains at least 1 b.\\n\\ndp(i,1) = [ dp(i-1,0)+1 if s[i] == a, dp(i,0) if s[i] == b ]\\n\\n\\n\\nso we can get the largest sum among all the substrings of s when we know the char a and char b.\\n\\nAnd the time complexity of this part is o(n).\\n\\nSo the total time complexity is O(n * 26 * 26)\\n\\n\\n\\n```python\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        n = len(s)\\n        if not s:\\n            return 0\\n        ans = 0\\n        for i in range(ord(\\'a\\'), ord(\\'z\\') + 1, 1):\\n            a = chr(i)\\n            for j in range(ord(\\'a\\'), ord(\\'z\\') + 1, 1):\\n                b = chr(j)\\n                # a- b\\n                if a == b: continue\\n                diff = 0\\n                diff_with_b = float(\\'-inf\\')\\n                for k, c in enumerate(s):\\n                    if c == a:\\n                        diff += 1\\n                        diff_with_b += 1\\n                    elif c == b:\\n                        diff -= 1\\n                        diff_with_b = diff\\n                        if diff < 0:\\n                            diff = 0\\n                    if diff_with_b > 0:\\n                        ans = max(ans, diff_with_b)\\n        return ans\\n\\n\\nif __name__ == \\'__main__\\':\\n    f = Solution().largestVariance\\n    print(f(s=\"aababbb\"))\\n    print(f(s=\"abcde\"))\\n    enumerate\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        n = len(s)\\n        if not s:\\n            return 0\\n        ans = 0\\n        for i in range(ord(\\'a\\'), ord(\\'z\\') + 1, 1):\\n            a = chr(i)\\n            for j in range(ord(\\'a\\'), ord(\\'z\\') + 1, 1):\\n                b = chr(j)\\n                # a- b\\n                if a == b: continue\\n                diff = 0\\n                diff_with_b = float(\\'-inf\\')\\n                for k, c in enumerate(s):\\n                    if c == a:\\n                        diff += 1\\n                        diff_with_b += 1\\n                    elif c == b:\\n                        diff -= 1\\n                        diff_with_b = diff\\n                        if diff < 0:\\n                            diff = 0\\n                    if diff_with_b > 0:\\n                        ans = max(ans, diff_with_b)\\n        return ans\\n\\n\\nif __name__ == \\'__main__\\':\\n    f = Solution().largestVariance\\n    print(f(s=\"aababbb\"))\\n    print(f(s=\"abcde\"))\\n    enumerate\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740685,
                "title": "beats-100-java-solution-dynamic-programming-o-n-2",
                "content": "# Upvote Me Please \\uD83D\\uDE4F\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        int output = 0;\\n        int[][] dif = new int[26][26];\\n        int[][] difB = new int [26][26];\\n        for(int i = 0; i < 26; i++){\\n            Arrays.fill(difB[i], -s.length());\\n        }\\n\\n        for(int j = 0; j < s.length(); j++){\\n            int ch = s.charAt(j) - \\'a\\';\\n            for(int k = 0; k < 26; k++){\\n                if(k == ch) continue;\\n                ++dif[ch][k];\\n                ++difB[ch][k];\\n                difB[k][ch] = --dif[k][ch];\\n                dif[k][ch] = Math.max(dif[k][ch], 0);\\n                output = Math.max(output, Math.max(difB[ch][k], difB[k][ch]));\\n\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        int output = 0;\\n        int[][] dif = new int[26][26];\\n        int[][] difB = new int [26][26];\\n        for(int i = 0; i < 26; i++){\\n            Arrays.fill(difB[i], -s.length());\\n        }\\n\\n        for(int j = 0; j < s.length(); j++){\\n            int ch = s.charAt(j) - \\'a\\';\\n            for(int k = 0; k < 26; k++){\\n                if(k == ch) continue;\\n                ++dif[ch][k];\\n                ++difB[ch][k];\\n                difB[k][ch] = --dif[k][ch];\\n                dif[k][ch] = Math.max(dif[k][ch], 0);\\n                output = Math.max(output, Math.max(difB[ch][k], difB[k][ch]));\\n\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738775,
                "title": "c-kadane-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code does not explicitly implement Kadane\\'s algorithm. However, it utilizes a similar concept to find the maximum variance between the counts of two distinct characters in a string.\\n\\nThe logic in a_minus_b bears some resemblance to the sliding window technique used in Kadane\\'s algorithm to find the maximum sum subarray.\\n\\nKadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[152. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/solutions/3748707/c-kadane-s-algorithm/)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(nk^2)$, where k is the number of different alphabets present in the input string s and n=len(s).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n $$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> freq;\\n\\n    int a_minus_b(char a, char b, string& s) {\\n     //   cout<<a<<\",\"<<b<<endl;\\n        int best_sum = 0;\\n        int a_count = 0, b_count = 0;\\n        for (char c : s) {\\n            if (c == a) a_count++;\\n            else if (c == b) b_count++;\\n            else continue;\\n            if (b_count > 0)\\n                best_sum = max(best_sum, a_count-b_count);\\n            else if ( b_count==0 ) //handle \"bbaaaa\" for previous b\\n                best_sum = max(best_sum, a_count-1);\\n            if (a_count < b_count ) {\\n                a_count = b_count = 0;\\n            }\\n        }\\n    //    cout<<best_sum<<endl;\\n        return best_sum;\\n    }\\n\\n    int largestVariance(string s) {\\n        freq.assign(26, 0);\\n        for (char c : s)\\n            freq[c - \\'a\\']++;\\n        \\n        int ans = 0;\\n        for (char a = \\'a\\'; a <= \\'z\\'; a++) {\\n            for (char b = \\'a\\'; b <= \\'z\\'; b++) {\\n                if (freq[a-\\'a\\']>0 && freq[b-\\'a\\']>0 && a!=b)\\n                    ans = max(ans, a_minus_b(a, b, s));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code with Comments\\n```\\nclass Solution {\\npublic:\\n    vector<int> freq; // Vector to store the frequency of each character\\n\\n    int a_minus_b(char a, char b, string& s) {\\n        int best_sum = 0; // Variable to store the largest difference between the counts of characters a and b\\n        int a_count = 0, b_count = 0; // Variables to count the occurrences of characters a and b\\n\\n        for (char c : s) {\\n            if (c == a)\\n                a_count++;\\n            else if (c == b)\\n                b_count++;\\n            else\\n                continue; // Skip the iteration if the character is neither a nor b\\n\\n            if (b_count > 0)\\n                best_sum = max(best_sum, a_count - b_count); // Update the best_sum if the current difference is larger\\n\\n            else if (b_count == 0)\\n                best_sum = max(best_sum, a_count - 1); // Handle the case when b_count becomes 0 (for previous b)\\n\\n            if (a_count < b_count) {\\n                a_count = b_count = 0; // Reset the counts if a_count becomes less than b_count\\n            }\\n        }\\n\\n        return best_sum; // Return the largest difference between the counts of characters a and b\\n    }\\n\\n    int largestVariance(string s) {\\n        freq.assign(26, 0); // Initialize the frequency vector with 26 zeros (one for each alphabet)\\n\\n        for (char c : s)\\n            freq[c - \\'a\\']++; // Increment the count for each character in the input string\\n\\n        int ans = 0; // Variable to store the largest variance\\n\\n        for (char a = \\'a\\'; a <= \\'z\\'; a++) {\\n            for (char b = \\'a\\'; b <= \\'z\\'; b++) {\\n                // Consider pairs of characters (a, b) only if they are present in the string and a is not equal to b\\n                if (freq[a-\\'a\\'] > 0 && freq[b-\\'a\\'] > 0 && a != b)\\n                    ans = max(ans, a_minus_b(a, b, s)); // Update the largest variance if a_minus_b result is greater\\n            }\\n        }\\n\\n        return ans; // Return the largest variance found\\n    }\\n};\\n\\n```\\n# code with unordered_map freq\\n```\\nclass Solution {\\npublic:\\n    \\n    int a_minus_b(char a, char b, string& s) {\\n     //   cout<<a<<\",\"<<b<<endl;\\n        int best_sum = 0;\\n        int a_count = 0, b_count = 0;\\n        for (char c : s) {\\n            if (c == a) a_count++;\\n            else if (c == b) b_count++;\\n            else continue;\\n            if (b_count > 0)\\n                best_sum = max(best_sum, a_count-b_count);\\n            else if ( b_count==0 ) //handle \"bbaaaa\" for previous b\\n                best_sum = max(best_sum, a_count-1);\\n            if (a_count < b_count ) {\\n                a_count = b_count = 0;\\n            }\\n        }\\n    //    cout<<best_sum<<endl;\\n        return best_sum;\\n    }\\n\\n    int largestVariance(string s) {\\n        unordered_map<char, int> freq;\\n        for (char c : s){\\n            if (freq.count(c)==0) freq[c]=1;\\n            else freq[c]++;\\n        }\\n         \\n        int ans = 0;\\n        for (auto [a, fa]: freq) {\\n            for (auto [b, fb]: freq) {\\n                if (a!=b)\\n                    ans = max(ans, a_minus_b(a, b, s));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> freq;\\n\\n    int a_minus_b(char a, char b, string& s) {\\n     //   cout<<a<<\",\"<<b<<endl;\\n        int best_sum = 0;\\n        int a_count = 0, b_count = 0;\\n        for (char c : s) {\\n            if (c == a) a_count++;\\n            else if (c == b) b_count++;\\n            else continue;\\n            if (b_count > 0)\\n                best_sum = max(best_sum, a_count-b_count);\\n            else if ( b_count==0 ) //handle \"bbaaaa\" for previous b\\n                best_sum = max(best_sum, a_count-1);\\n            if (a_count < b_count ) {\\n                a_count = b_count = 0;\\n            }\\n        }\\n    //    cout<<best_sum<<endl;\\n        return best_sum;\\n    }\\n\\n    int largestVariance(string s) {\\n        freq.assign(26, 0);\\n        for (char c : s)\\n            freq[c - \\'a\\']++;\\n        \\n        int ans = 0;\\n        for (char a = \\'a\\'; a <= \\'z\\'; a++) {\\n            for (char b = \\'a\\'; b <= \\'z\\'; b++) {\\n                if (freq[a-\\'a\\']>0 && freq[b-\\'a\\']>0 && a!=b)\\n                    ans = max(ans, a_minus_b(a, b, s));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> freq; // Vector to store the frequency of each character\\n\\n    int a_minus_b(char a, char b, string& s) {\\n        int best_sum = 0; // Variable to store the largest difference between the counts of characters a and b\\n        int a_count = 0, b_count = 0; // Variables to count the occurrences of characters a and b\\n\\n        for (char c : s) {\\n            if (c == a)\\n                a_count++;\\n            else if (c == b)\\n                b_count++;\\n            else\\n                continue; // Skip the iteration if the character is neither a nor b\\n\\n            if (b_count > 0)\\n                best_sum = max(best_sum, a_count - b_count); // Update the best_sum if the current difference is larger\\n\\n            else if (b_count == 0)\\n                best_sum = max(best_sum, a_count - 1); // Handle the case when b_count becomes 0 (for previous b)\\n\\n            if (a_count < b_count) {\\n                a_count = b_count = 0; // Reset the counts if a_count becomes less than b_count\\n            }\\n        }\\n\\n        return best_sum; // Return the largest difference between the counts of characters a and b\\n    }\\n\\n    int largestVariance(string s) {\\n        freq.assign(26, 0); // Initialize the frequency vector with 26 zeros (one for each alphabet)\\n\\n        for (char c : s)\\n            freq[c - \\'a\\']++; // Increment the count for each character in the input string\\n\\n        int ans = 0; // Variable to store the largest variance\\n\\n        for (char a = \\'a\\'; a <= \\'z\\'; a++) {\\n            for (char b = \\'a\\'; b <= \\'z\\'; b++) {\\n                // Consider pairs of characters (a, b) only if they are present in the string and a is not equal to b\\n                if (freq[a-\\'a\\'] > 0 && freq[b-\\'a\\'] > 0 && a != b)\\n                    ans = max(ans, a_minus_b(a, b, s)); // Update the largest variance if a_minus_b result is greater\\n            }\\n        }\\n\\n        return ans; // Return the largest variance found\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int a_minus_b(char a, char b, string& s) {\\n     //   cout<<a<<\",\"<<b<<endl;\\n        int best_sum = 0;\\n        int a_count = 0, b_count = 0;\\n        for (char c : s) {\\n            if (c == a) a_count++;\\n            else if (c == b) b_count++;\\n            else continue;\\n            if (b_count > 0)\\n                best_sum = max(best_sum, a_count-b_count);\\n            else if ( b_count==0 ) //handle \"bbaaaa\" for previous b\\n                best_sum = max(best_sum, a_count-1);\\n            if (a_count < b_count ) {\\n                a_count = b_count = 0;\\n            }\\n        }\\n    //    cout<<best_sum<<endl;\\n        return best_sum;\\n    }\\n\\n    int largestVariance(string s) {\\n        unordered_map<char, int> freq;\\n        for (char c : s){\\n            if (freq.count(c)==0) freq[c]=1;\\n            else freq[c]++;\\n        }\\n         \\n        int ans = 0;\\n        for (auto [a, fa]: freq) {\\n            for (auto [b, fb]: freq) {\\n                if (a!=b)\\n                    ans = max(ans, a_minus_b(a, b, s));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2579443,
                "title": "python-3-solution-kadanes",
                "content": "This took me so long to get the processing time fast enough to pass.  I got Time Exceeded so many times.\\nThe final piece was checking if the letter was in the current testing pair, then continuuing to the next pair if it wasn\\'t\\n\\nI saw several solutions that used [a-z] * [a-z].  I only used a set of the letters from the actual string. \\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        freq1 = 0\\n        freq2 = 0\\n        variance = 0\\n        \\n        # create distinct list of character pairs\\n        pairs = [(l1, l2) for l1 in set(s) for l2 in set(s) if l1 != l2]\\n\\n        # run once for original string order, then again for reverse string order\\n        for runs in range(2):\\n            for pair in pairs:\\n\\n                for letter in s:\\n                    # no reason to process letters that aren\\'t part of the current pair\\n                    if letter not in pair:\\n                        continue\\n                    if letter == pair[0]:\\n                        freq1 += 1\\n                    elif letter == pair[1]:\\n                        freq2 += 1\\n                    if freq1 < freq2:\\n                        freq1 = freq2 = 0\\n                    elif freq1 > 0 and freq2 > 0:\\n                        variance = max(variance, freq1-freq2)\\n                freq1 = freq2 = 0\\n            \\n            # reverse the string for the second time around\\n            s = s[::-1]\\n                \\n        return variance\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        freq1 = 0\\n        freq2 = 0\\n        variance = 0\\n        \\n        # create distinct list of character pairs\\n        pairs = [(l1, l2) for l1 in set(s) for l2 in set(s) if l1 != l2]\\n\\n        # run once for original string order, then again for reverse string order\\n        for runs in range(2):\\n            for pair in pairs:\\n\\n                for letter in s:\\n                    # no reason to process letters that aren\\'t part of the current pair\\n                    if letter not in pair:\\n                        continue\\n                    if letter == pair[0]:\\n                        freq1 += 1\\n                    elif letter == pair[1]:\\n                        freq2 += 1\\n                    if freq1 < freq2:\\n                        freq1 = freq2 = 0\\n                    elif freq1 > 0 and freq2 > 0:\\n                        variance = max(variance, freq1-freq2)\\n                freq1 = freq2 = 0\\n            \\n            # reverse the string for the second time around\\n            s = s[::-1]\\n                \\n        return variance\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2471185,
                "title": "thinking-process",
                "content": "After finishing Leetcode 53, read the following hints. You\\'ll be able to figure out the solution. Let me know if this helps.\\n\\n![image](https://assets.leetcode.com/users/images/c272d2c2-7233-4e32-9691-1a0392a2b17d_1661309509.5563269.png)\\n",
                "solutionTags": [],
                "code": "After finishing Leetcode 53, read the following hints. You\\'ll be able to figure out the solution. Let me know if this helps.\\n\\n![image](https://assets.leetcode.com/users/images/c272d2c2-7233-4e32-9691-1a0392a2b17d_1661309509.5563269.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3740211,
                "title": "easy-to-understand-c-simply-use-with-kadane-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int kadane(const vector<int>& nums) {\\n        int sum = 0;\\n        int ans = INT_MIN;\\n        bool flag = false;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == -1) {\\n                flag = true;\\n            }\\n            sum += nums[i];\\n//             if we include both the elements then only we see the sum \\n            if (flag) {\\n                ans = max(ans, sum);\\n            }\\n\\n            if (sum < 0) {\\n                sum = 0;\\n                flag = false;\\n            }\\n        }\\n        if (flag) {\\n            return ans;\\n        }\\n        return 0;\\n    }\\n\\n    int solve(char a, char b, const string& s) {\\n        vector<int> v1(s.length(), 0), v2(s.length());\\n//         put the value -1 for char b and 1 for char a \\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] == a) {\\n                v1[i] = -1;\\n            }\\n            if (s[i] == b) {\\n                v1[i] = 1;\\n            }\\n        }\\n        int l1 = kadane(v1);\\n//          if this case come to handle this means first negative  then positive \"lripaa\"\\n        reverse_copy(v1.begin(), v1.end(), v2.begin());\\n        int l2 = kadane(v2);\\n        return max(l1, l2);\\n    }\\n    int largestVariance(const string& s) {\\n        int ans = 0;\\n//         calculating for each condtion where the 2 char can be any two\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                char alpha = static_cast<char>(97 + i);\\n                char beta = static_cast<char>(97 + j);\\n                if (alpha != beta) {\\n                    ans = max(ans, solve(alpha, beta, s));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int kadane(const vector<int>& nums) {\\n        int sum = 0;\\n        int ans = INT_MIN;\\n        bool flag = false;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == -1) {\\n                flag = true;\\n            }\\n            sum += nums[i];\\n//             if we include both the elements then only we see the sum \\n            if (flag) {\\n                ans = max(ans, sum);\\n            }\\n\\n            if (sum < 0) {\\n                sum = 0;\\n                flag = false;\\n            }\\n        }\\n        if (flag) {\\n            return ans;\\n        }\\n        return 0;\\n    }\\n\\n    int solve(char a, char b, const string& s) {\\n        vector<int> v1(s.length(), 0), v2(s.length());\\n//         put the value -1 for char b and 1 for char a \\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] == a) {\\n                v1[i] = -1;\\n            }\\n            if (s[i] == b) {\\n                v1[i] = 1;\\n            }\\n        }\\n        int l1 = kadane(v1);\\n//          if this case come to handle this means first negative  then positive \"lripaa\"\\n        reverse_copy(v1.begin(), v1.end(), v2.begin());\\n        int l2 = kadane(v2);\\n        return max(l1, l2);\\n    }\\n    int largestVariance(const string& s) {\\n        int ans = 0;\\n//         calculating for each condtion where the 2 char can be any two\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                char alpha = static_cast<char>(97 + i);\\n                char beta = static_cast<char>(97 + j);\\n                if (alpha != beta) {\\n                    ans = max(ans, solve(alpha, beta, s));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738683,
                "title": "beats-90-cpp-sol",
                "content": "# **Pls Upvote if Helpful \\uD83E\\uDD79**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int n = s.size();\\n        int res = 0;\\n        \\n        // choose two char for comparison\\n        // p is the one with higher freq.\\n        // q is the one with lower freq.\\n        for (char p = \\'a\\'; p <= \\'z\\'; p++) {\\n            for (char q = \\'a\\'; q <= \\'z\\'; q++) {\\n                if (p == q) continue;\\n                \\n                // run Kadane\\'s algo\\n                int pCount = 0; // higher one\\n                int qCount = 0; // lower one\\n                \\n                // this flag would deal with the edge case\\n                // e.g., \"pqqpppppp\"\\n                // after reset, there is no q but we can extend\\n                // the interval to the previous q\\n                // and the answer should -1\\n                bool canExtendprevQ = false;\\n                \\n                for (auto c : s) {\\n                    if (c == p) pCount++;\\n                    if (c == q) qCount++;\\n                    \\n                    // an interval should contain at least one q\\n                    if (qCount > 0) {\\n                        res = max(res, pCount - qCount);\\n                    }\\n                    // edge case: consider previous q\\n                    else if (qCount == 0 && canExtendprevQ) {\\n                        res = max(res, pCount - 1);\\n                    }\\n                    \\n                    // reset if # of q > # of p\\n                    if (qCount > pCount) {\\n                        qCount = pCount = 0;\\n                        \\n                        // once reset, the interval can be extended\\n                        // as there must be one q before the next interval\\n                        canExtendprevQ = true;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int n = s.size();\\n        int res = 0;\\n        \\n        // choose two char for comparison\\n        // p is the one with higher freq.\\n        // q is the one with lower freq.\\n        for (char p = \\'a\\'; p <= \\'z\\'; p++) {\\n            for (char q = \\'a\\'; q <= \\'z\\'; q++) {\\n                if (p == q) continue;\\n                \\n                // run Kadane\\'s algo\\n                int pCount = 0; // higher one\\n                int qCount = 0; // lower one\\n                \\n                // this flag would deal with the edge case\\n                // e.g., \"pqqpppppp\"\\n                // after reset, there is no q but we can extend\\n                // the interval to the previous q\\n                // and the answer should -1\\n                bool canExtendprevQ = false;\\n                \\n                for (auto c : s) {\\n                    if (c == p) pCount++;\\n                    if (c == q) qCount++;\\n                    \\n                    // an interval should contain at least one q\\n                    if (qCount > 0) {\\n                        res = max(res, pCount - qCount);\\n                    }\\n                    // edge case: consider previous q\\n                    else if (qCount == 0 && canExtendprevQ) {\\n                        res = max(res, pCount - 1);\\n                    }\\n                    \\n                    // reset if # of q > # of p\\n                    if (qCount > pCount) {\\n                        qCount = pCount = 0;\\n                        \\n                        // once reset, the interval can be extended\\n                        // as there must be one q before the next interval\\n                        canExtendprevQ = true;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092245,
                "title": "c-kadane-s-take-two-characters-at-a-time",
                "content": "```\\n/* \\n    Time: O(26*26*n)\\n    Space: O(1)\\n    Tag: Kadane\\'s Algorithm\\n    Difficulty: H (Logic) | E(Implementation)\\n*/\\n\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int res = 0;\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                if (i == j) continue;\\n                int highFreq = 0;\\n                int lowFreq = 0;\\n                bool prevHadLowFreqChar = false;\\n                for (char ch : s) {\\n                    if (ch - \\'a\\' == i)\\n                        highFreq++;\\n                    else if (ch - \\'a\\' == j)\\n                        lowFreq++;\\n                    if (lowFreq > 0)\\n                        res = max(res, highFreq - lowFreq);\\n                    else if (prevHadLowFreqChar)\\n                        res = max(res, highFreq - 1);\\n                    if (highFreq - lowFreq < 0) {\\n                        highFreq = 0;\\n                        lowFreq = 0;\\n                        prevHadLowFreqChar = true;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/* \\n    Time: O(26*26*n)\\n    Space: O(1)\\n    Tag: Kadane\\'s Algorithm\\n    Difficulty: H (Logic) | E(Implementation)\\n*/\\n\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int res = 0;\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                if (i == j) continue;\\n                int highFreq = 0;\\n                int lowFreq = 0;\\n                bool prevHadLowFreqChar = false;\\n                for (char ch : s) {\\n                    if (ch - \\'a\\' == i)\\n                        highFreq++;\\n                    else if (ch - \\'a\\' == j)\\n                        lowFreq++;\\n                    if (lowFreq > 0)\\n                        res = max(res, highFreq - lowFreq);\\n                    else if (prevHadLowFreqChar)\\n                        res = max(res, highFreq - 1);\\n                    if (highFreq - lowFreq < 0) {\\n                        highFreq = 0;\\n                        lowFreq = 0;\\n                        prevHadLowFreqChar = true;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739942,
                "title": "same-as-200-other-solutions",
                "content": "# Code\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        res=0\\n        for ch1 in set(s):\\n            for ch2 in set(s):\\n                if ch1==ch2: continue\\n                ch2_front=False; has_ch2=False; var=0\\n                for i in range(len(s)):\\n                    if s[i]==ch1: var+=1\\n                    if s[i]==ch2:\\n                        has_ch2=True\\n                        var-=1\\n                        if ch2_front and var>=-1:\\n                            ch2_front=False\\n                            var+=1\\n                        elif var<0:\\n                            ch2_front=True\\n                            var=-1\\n                    res=max(res,var if has_ch2 else 0)\\n        return res                        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        res=0\\n        for ch1 in set(s):\\n            for ch2 in set(s):\\n                if ch1==ch2: continue\\n                ch2_front=False; has_ch2=False; var=0\\n                for i in range(len(s)):\\n                    if s[i]==ch1: var+=1\\n                    if s[i]==ch2:\\n                        has_ch2=True\\n                        var-=1\\n                        if ch2_front and var>=-1:\\n                            ch2_front=False\\n                            var+=1\\n                        elif var<0:\\n                            ch2_front=True\\n                            var=-1\\n                    res=max(res,var if has_ch2 else 0)\\n        return res                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556094,
                "title": "java-well-explained-code-and-solution",
                "content": "Following hints, we know that we should treat all letters in the string as pairs. For each pair we do looping string s twice, once assume one letter being the major element, the other being the minor element; second time assume the other way around.\\n\\nThe reason we assume major and minor is so that we know when to discard a substring. For example, if we assume a-major b-minor, then in \"bbab\" we would discard first \"b\" and second \"b\", and only consider \"ab\". Because we do not want a substring having more b than a without the current b being the last b (if the current b is the last, even if freq b > freq a, we need to include it so the variance is valid). **In other words, the best substring always starts with major or starts with minor only when this minor is the last minor in our string.** Otherwise, we can always come up with better substrings. \\n\\nWe know that in a substring variance = freq major - freq minor. And we also know that when the minor freq exceeds the major freq we should discard this substring and restart a new substring by setting freq major = 0 and freq minor = 0. This always holds unless the char we are at is the last minor char, then we should not discard it. And also, to ensure the we have the valid variance, we can only update variance when we do have at lease one minor element in the current substring which is freq minor > 0.\\n\\nNow we are ready to write the code for this problem!\\n\\n```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        //First we record the last index of all letters in the string, if a letter never appears, its value would be -1\\n        int[] lastInd = new int[26];\\n        Arrays.fill(lastInd,-1);\\n        for(int i=s.length()-1;i>=0;i--)\\n            if(lastInd[s.charAt(i)-\\'a\\']==-1)\\n                lastInd[s.charAt(i)-\\'a\\'] = i;\\n        int res = 0;\\n        //Organize all letters in pairs\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                //Only select two distinct letters that appear in the string\\n                if(i==j||lastInd[i]==-1||lastInd[j]==-1) continue;\\n                int majorC = 0, minorC = 0;\\n                char major = (char)(\\'a\\'+ i), minor = (char)(\\'a\\'+j);\\n                for(int k=0;k<s.length();k++){\\n                    char cur = s.charAt(k);\\n                    //If this element is neither major nor minor, we skip it, it does not need to be considered\\n                    if(cur!=major&&cur!=minor) continue;\\n                    if(cur==major) majorC++;\\n                    if(cur==minor) minorC++;\\n                    //if minorCount > majorCount and this minor element is not the last minor, we do not want this substring, we only want the major elements to dominate, so discard\\n                    if(majorC<minorC&&k!=lastInd[minor-\\'a\\']){\\n                        majorC = 0;\\n                        minorC = 0;\\n                    }\\n                    //We only consider a variance to be valid if at least one minor exists in this substring, so we update var when minor>1\\n                    if(minorC>0) res = Math.max(res,majorC-minorC);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        //First we record the last index of all letters in the string, if a letter never appears, its value would be -1\\n        int[] lastInd = new int[26];\\n        Arrays.fill(lastInd,-1);\\n        for(int i=s.length()-1;i>=0;i--)\\n            if(lastInd[s.charAt(i)-\\'a\\']==-1)\\n                lastInd[s.charAt(i)-\\'a\\'] = i;\\n        int res = 0;\\n        //Organize all letters in pairs\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                //Only select two distinct letters that appear in the string\\n                if(i==j||lastInd[i]==-1||lastInd[j]==-1) continue;\\n                int majorC = 0, minorC = 0;\\n                char major = (char)(\\'a\\'+ i), minor = (char)(\\'a\\'+j);\\n                for(int k=0;k<s.length();k++){\\n                    char cur = s.charAt(k);\\n                    //If this element is neither major nor minor, we skip it, it does not need to be considered\\n                    if(cur!=major&&cur!=minor) continue;\\n                    if(cur==major) majorC++;\\n                    if(cur==minor) minorC++;\\n                    //if minorCount > majorCount and this minor element is not the last minor, we do not want this substring, we only want the major elements to dominate, so discard\\n                    if(majorC<minorC&&k!=lastInd[minor-\\'a\\']){\\n                        majorC = 0;\\n                        minorC = 0;\\n                    }\\n                    //We only consider a variance to be valid if at least one minor exists in this substring, so we update var when minor>1\\n                    if(minorC>0) res = Math.max(res,majorC-minorC);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417767,
                "title": "javascript-solution",
                "content": "\\n\\n```\\n\\n/**\\nThe given problem asks us to compute the maximum possible variance between 2 characters in any substring of the given string. \\nThis value will be the largest difference between the highest frequence element and the lowest frequency element. \\nThis problem can be broken down so that we compute the maximum possible variation between any 2 characters. \\nBy computing the maximum possible variation between all unique characters and then getting the maximum among those values we can compute the largest variance for String, s. \\nWe can start the problem by filling a hashmap with the characters in the string and their respective counts. \\nWe can then iterate through pairs of characters using a nested loop on the maps keyset. \\nOnce we have our primary character and secondary character we can compute the maximum variance for those characters using Kadane\\'s algorithm. \\nAs we iterate through the characters in our string we can check whether any of those characters belong to our pair. We can update the frequencies for those characters. \\nIt is also important that we track the count of our secondary character. \\nThis is so we can reset our frequencies. \\nFor example, if the secondary frequency outweighs the primary frequency upto that point we know that the substring upto that point has already had its max variance computed and continuing to work with that part of the string is pointless since our variance is lower than 0 for the primary character. \\nIf we have more secondary characters we can simply, reset our string to start at this new index and continue to calculate new frequencies. \\nTherefore we reset our primary and secondary frequencies that we might meet a better frequence later down the iteration of  our string. \\nWe can keep a global variable for the nested loops which we can compare with our current max frequency between 2 characters. \\nAt the end we can simply return our variance.\\n**/\\nfunction largestVariance(s: string): number {\\n    const freqObj: Record<string, number> = {};\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        const currStr = s.charAt(i);\\n        \\n        if (freqObj[currStr]) {\\n            freqObj[currStr]++\\n        } else {\\n            freqObj[currStr] = 1;\\n        }\\n    }\\n    \\n    const freqObjKeys = Object.keys(freqObj);\\n    \\n    let variance: number = 0;\\n    \\n    for (let primaryString of freqObjKeys) {\\n        \\n        for (let secondaryString of freqObjKeys) {\\n            \\n            if (primaryString === secondaryString) continue;\\n            \\n            let primaryFreq: number = 0;\\n            let secondaryFreq: number = 0;\\n            let secondaryCharCount: number = freqObj[secondaryString];\\n            \\n            for (let i = 0; i < s.length; i++) {\\n                const currentStr: string = s[i];\\n                \\n                if (currentStr === primaryString) primaryFreq++;\\n                if (currentStr === secondaryString) {\\n                    secondaryFreq++;\\n                    secondaryCharCount--\\n                }\\n                \\n                if ((primaryFreq > 0 && secondaryFreq > 0) && (primaryFreq > secondaryFreq)) {\\n                    variance = Math.max(variance, (primaryFreq - secondaryFreq))\\n                }\\n                \\n                if (primaryFreq < secondaryFreq && secondaryCharCount > 0) {\\n                   primaryFreq = 0;\\n                   secondaryFreq= 0;\\n                }\\n            } \\n            \\n        }\\n    }\\n    \\n    return variance;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n\\n/**\\nThe given problem asks us to compute the maximum possible variance between 2 characters in any substring of the given string. \\nThis value will be the largest difference between the highest frequence element and the lowest frequency element. \\nThis problem can be broken down so that we compute the maximum possible variation between any 2 characters. \\nBy computing the maximum possible variation between all unique characters and then getting the maximum among those values we can compute the largest variance for String, s. \\nWe can start the problem by filling a hashmap with the characters in the string and their respective counts. \\nWe can then iterate through pairs of characters using a nested loop on the maps keyset. \\nOnce we have our primary character and secondary character we can compute the maximum variance for those characters using Kadane\\'s algorithm. \\nAs we iterate through the characters in our string we can check whether any of those characters belong to our pair. We can update the frequencies for those characters. \\nIt is also important that we track the count of our secondary character. \\nThis is so we can reset our frequencies. \\nFor example, if the secondary frequency outweighs the primary frequency upto that point we know that the substring upto that point has already had its max variance computed and continuing to work with that part of the string is pointless since our variance is lower than 0 for the primary character. \\nIf we have more secondary characters we can simply, reset our string to start at this new index and continue to calculate new frequencies. \\nTherefore we reset our primary and secondary frequencies that we might meet a better frequence later down the iteration of  our string. \\nWe can keep a global variable for the nested loops which we can compare with our current max frequency between 2 characters. \\nAt the end we can simply return our variance.\\n**/\\nfunction largestVariance(s: string): number {\\n    const freqObj: Record<string, number> = {};\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        const currStr = s.charAt(i);\\n        \\n        if (freqObj[currStr]) {\\n            freqObj[currStr]++\\n        } else {\\n            freqObj[currStr] = 1;\\n        }\\n    }\\n    \\n    const freqObjKeys = Object.keys(freqObj);\\n    \\n    let variance: number = 0;\\n    \\n    for (let primaryString of freqObjKeys) {\\n        \\n        for (let secondaryString of freqObjKeys) {\\n            \\n            if (primaryString === secondaryString) continue;\\n            \\n            let primaryFreq: number = 0;\\n            let secondaryFreq: number = 0;\\n            let secondaryCharCount: number = freqObj[secondaryString];\\n            \\n            for (let i = 0; i < s.length; i++) {\\n                const currentStr: string = s[i];\\n                \\n                if (currentStr === primaryString) primaryFreq++;\\n                if (currentStr === secondaryString) {\\n                    secondaryFreq++;\\n                    secondaryCharCount--\\n                }\\n                \\n                if ((primaryFreq > 0 && secondaryFreq > 0) && (primaryFreq > secondaryFreq)) {\\n                    variance = Math.max(variance, (primaryFreq - secondaryFreq))\\n                }\\n                \\n                if (primaryFreq < secondaryFreq && secondaryCharCount > 0) {\\n                   primaryFreq = 0;\\n                   secondaryFreq= 0;\\n                }\\n            } \\n            \\n        }\\n    }\\n    \\n    return variance;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2159090,
                "title": "python-kadane-s-algo-optimized-version",
                "content": "First solution (TLE in python :( , might pass in c++/java):\\nTC- O(26 * 26 * N)\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        n=len(s)\\n        count=Counter(s)\\n        ans=0\\n        for c1 in count:\\n            for c2 in count:\\n                if c1!=c2:\\n                    val,res,m=0,0,10**9+7\\n                    for c in s:\\n                        if c==c1: \\n                            val+=1\\n                        elif c==c2:\\n                            m=min(m,res)\\n                            val-=1\\n                            res=val\\n                        ans=max(ans,val-m)\\n        return ans\\n                \\n            \\n```\\nSecond solution (optimized version, AC in python):\\nTC- O(26 * 26 * M * log(M)), where M is length of subsequence of s formed by any 2 chars c1 and c2.\\nA pretty significant improvement.\\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        n=len(s)\\n        count=set(s)\\n        ans=0\\n        arr=defaultdict(list)\\n        for i,c in enumerate(s): arr[c].append((i,c))\\n        for c1 in count:\\n            for c2 in count:\\n                if c1!=c2:\\n                    val,res,m=0,0,10**9+7\\n                    for _,c in sorted(arr[c1]+arr[c2]):\\n                        if c==c1: \\n                            val+=1\\n                        elif c==c2:\\n                            m=min(m,res)\\n                            val-=1\\n                            res=val\\n                        ans=max(ans,val-m)\\n        return ans\\n                \\n            \\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        n=len(s)\\n        count=Counter(s)\\n        ans=0\\n        for c1 in count:\\n            for c2 in count:\\n                if c1!=c2:\\n                    val,res,m=0,0,10**9+7\\n                    for c in s:\\n                        if c==c1: \\n                            val+=1\\n                        elif c==c2:\\n                            m=min(m,res)\\n                            val-=1\\n                            res=val\\n                        ans=max(ans,val-m)\\n        return ans\\n                \\n            \\n```\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        n=len(s)\\n        count=set(s)\\n        ans=0\\n        arr=defaultdict(list)\\n        for i,c in enumerate(s): arr[c].append((i,c))\\n        for c1 in count:\\n            for c2 in count:\\n                if c1!=c2:\\n                    val,res,m=0,0,10**9+7\\n                    for _,c in sorted(arr[c1]+arr[c2]):\\n                        if c==c1: \\n                            val+=1\\n                        elif c==c2:\\n                            m=min(m,res)\\n                            val-=1\\n                            res=val\\n                        ans=max(ans,val-m)\\n        return ans\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042949,
                "title": "python-3-kadane-s-algorithm-two-pointers-explanation",
                "content": "### Explanation\\n- Time complexity: `O((1+26)*26/2*800)`, there will be `(1+26)*26/2 = 351` for loops, on average there will be a `10000/26*2 ~= 800` length on two pointers walk. In total we are looking at a scale of `O(1e5)`, which is approximately `O(N)`\\n- See below for more explanation\\n### Implementation\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        d = collections.defaultdict(list)\\n        for i, c in enumerate(s):                                       # for each letter, create a list of its indices\\n            d[c].append(i)\\n        ans = 0\\n        for x, chr1 in enumerate(string.ascii_lowercase):               # character 1\\n            for chr2 in string.ascii_lowercase[x+1:]:                   # character 2\\n                if chr1 == chr2 or chr1 not in d or chr2 not in d:\\n                    continue\\n                prefix = i = p1 = p2 = 0\\n                hi = hi_idx = lo = lo_idx = 0\\n                n1, n2 = len(d[chr1]), len(d[chr2])\\n                while p1 < n1 or p2 < n2:                               # two pointers\\n                    if p1 < n1 and p2 < n2:\\n                        if d[chr1][p1] < d[chr2][p2]:\\n                            prefix, p1 = prefix+1, p1+1                 # count prefix\\n                        else:\\n                            prefix, p2 = prefix-1, p2+1\\n                    elif p1 < n1:        \\n                        prefix, p1 = prefix+1, p1+1\\n                    else:\\n                        prefix, p2 = prefix-1, p2+1\\n                    if prefix > hi:                                     # update high value\\n                        hi, hi_idx = prefix, i\\n                    if prefix < lo:                                     # update low value\\n                        lo, lo_idx = prefix, i\\n                    ans = max(ans, min(prefix-lo, i-lo_idx-1))          # update ans by calculate difference, i-lo_idx-1 is to handle when only one elements are showing up\\n                    ans = max(ans, min(hi-prefix, i-hi_idx-1)) \\n                    i += 1 \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        d = collections.defaultdict(list)\\n        for i, c in enumerate(s):                                       # for each letter, create a list of its indices\\n            d[c].append(i)\\n        ans = 0\\n        for x, chr1 in enumerate(string.ascii_lowercase):               # character 1\\n            for chr2 in string.ascii_lowercase[x+1:]:                   # character 2\\n                if chr1 == chr2 or chr1 not in d or chr2 not in d:\\n                    continue\\n                prefix = i = p1 = p2 = 0\\n                hi = hi_idx = lo = lo_idx = 0\\n                n1, n2 = len(d[chr1]), len(d[chr2])\\n                while p1 < n1 or p2 < n2:                               # two pointers\\n                    if p1 < n1 and p2 < n2:\\n                        if d[chr1][p1] < d[chr2][p2]:\\n                            prefix, p1 = prefix+1, p1+1                 # count prefix\\n                        else:\\n                            prefix, p2 = prefix-1, p2+1\\n                    elif p1 < n1:        \\n                        prefix, p1 = prefix+1, p1+1\\n                    else:\\n                        prefix, p2 = prefix-1, p2+1\\n                    if prefix > hi:                                     # update high value\\n                        hi, hi_idx = prefix, i\\n                    if prefix < lo:                                     # update low value\\n                        lo, lo_idx = prefix, i\\n                    ans = max(ans, min(prefix-lo, i-lo_idx-1))          # update ans by calculate difference, i-lo_idx-1 is to handle when only one elements are showing up\\n                    ans = max(ans, min(hi-prefix, i-hi_idx-1)) \\n                    i += 1 \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740846,
                "title": "c-solution-modified-kadane-algorithm-supereasy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n                    `Modification on Kadane Algorithm`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The `modKadane` function iterates through each character `c` in the input string `s` using a range-based for loop.\\n\\n2. If c is neither \\'a\\' nor \\'b\\', the loop continues to the next character using the continue statement.\\n\\n3. If c is \\'a\\', `countA` is incremented by 1. Otherwise, if c is \\'b\\', `countB` is incremented by 1.\\n\\n4. If the count of \\'b\\' characters `countB` is greater than 0, it means that an interval with at least one \\'b\\' character is present. In this case, the code calculates the variance by subtracting the count of \\'b\\' characters from the count of \\'a\\' characters `countA - countB`. It updates the `ans` variable with the maximum variance seen so far using the max function.\\n\\n5. If the count of \\'b\\' characters is 0, but the previous interval had an extended \\'b\\' character (`extendPrevB` is true), it means that the current interval starts with a \\'b\\'. In this case, the code calculates the variance by subtracting 1 from the count of \\'a\\' characters `countA - 1` and updates the ans variable.\\n\\n6. If the count of \\'b\\' characters is greater than the count of \\'a\\' characters `countB > countA`, it means that the previous interval had more \\'b\\' characters. In this case, both countA and countB are reset to 0, and extendPrevB is set to true to indicate that the next interval starts with an extended \\'b\\'.\\n\\n7. After iterating through all the characters in s, the `ans` variable holds the maximum variance obtained from all the intervals. The function returns this value.\\n\\n8. The `largestVariance` function is defined, which takes a string s as a parameter.\\n\\n9. Inside largestVariance, the variable `res` is initialized to 0, which will hold the maximum variance obtained from all the character combinations of \\'a\\' and \\'b\\'.\\n\\n10. The function uses nested loops to iterate through all possible combinations of \\'a\\' and \\'b\\' characters.\\n\\n11. For each combination where `c1` is not equal to `c2`, the modKadane function is called with the input string s and the characters c1 and c2 as parameters. The returned value is compared with the current maximum variance res, and if it is greater, res is updated.\\n\\n12. After all combinations have been considered, the function returns the maximum variance `res`.\\n\\n# Complexity\\n- Time complexity:$$O(n.26^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int modKadane(string& s, char a, char b) {\\n    int ans = 0;\\n    int countA = 0;\\n    int countB = 0;\\n    bool extendPrevB = false;\\n\\n    for (const char c : s) {\\n      if (c != a && c != b)\\n        continue;\\n      if (c == a)\\n        ++countA;\\n      else\\n        ++countB;\\n      if (countB > 0) {\\n        // An interval should contain at least one b\\n        ans = max(ans, countA - countB);\\n      } else if (countB == 0 && extendPrevB) {\\n        // Edge case: consider previous b\\n        ans = max(ans, countA - 1);\\n      }\\n      \\n      if (countB > countA) {\\n        countA = 0;\\n        countB = 0;\\n        extendPrevB = true;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n    int largestVariance(string s) {\\n        \\n        int res=0;\\n\\n        for(char c1=\\'a\\';c1<=\\'z\\';c1++){\\n            for(char c2=\\'a\\';c2<=\\'z\\';c2++){\\n                if(c1!=c2){\\n                    res=max(res,modKadane(s,c1,c2));\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int modKadane(string& s, char a, char b) {\\n    int ans = 0;\\n    int countA = 0;\\n    int countB = 0;\\n    bool extendPrevB = false;\\n\\n    for (const char c : s) {\\n      if (c != a && c != b)\\n        continue;\\n      if (c == a)\\n        ++countA;\\n      else\\n        ++countB;\\n      if (countB > 0) {\\n        // An interval should contain at least one b\\n        ans = max(ans, countA - countB);\\n      } else if (countB == 0 && extendPrevB) {\\n        // Edge case: consider previous b\\n        ans = max(ans, countA - 1);\\n      }\\n      \\n      if (countB > countA) {\\n        countA = 0;\\n        countB = 0;\\n        extendPrevB = true;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n    int largestVariance(string s) {\\n        \\n        int res=0;\\n\\n        for(char c1=\\'a\\';c1<=\\'z\\';c1++){\\n            for(char c2=\\'a\\';c2<=\\'z\\';c2++){\\n                if(c1!=c2){\\n                    res=max(res,modKadane(s,c1,c2));\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739336,
                "title": "c-dynamic-programming",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int max_result = 0;\\n\\n        for (char from = \\'a\\'; from <= \\'z\\'; from++) {\\n            for (char to = \\'a\\'; to <= \\'z\\'; to++) {\\n                if (from == to) continue;\\n\\n                int dp = 0;  \\n                int dp1 = INT_MIN;\\n\\n                for (int i = 0; i < s.size(); i++) {\\n                    char c = s[i];\\n\\n                    if (c == from) {\\n                        dp = max(1, dp+1);\\n                        if (dp1 != INT_MIN) dp1 = dp1 + 1;\\n                    } else if (c == to) {\\n                        if (dp1 == INT_MIN) {\\n                            dp1 = max(-1, dp-1);\\n                        } else {\\n                            dp1 = max(max(-1, dp-1), dp1 -1);\\n                        }\\n\\n                        dp = dp -1;\\n                    }\\n\\n                    max_result = max(max_result, dp1);\\n                }\\n            }\\n        }\\n\\n        return max_result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int max_result = 0;\\n\\n        for (char from = \\'a\\'; from <= \\'z\\'; from++) {\\n            for (char to = \\'a\\'; to <= \\'z\\'; to++) {\\n                if (from == to) continue;\\n\\n                int dp = 0;  \\n                int dp1 = INT_MIN;\\n\\n                for (int i = 0; i < s.size(); i++) {\\n                    char c = s[i];\\n\\n                    if (c == from) {\\n                        dp = max(1, dp+1);\\n                        if (dp1 != INT_MIN) dp1 = dp1 + 1;\\n                    } else if (c == to) {\\n                        if (dp1 == INT_MIN) {\\n                            dp1 = max(-1, dp-1);\\n                        } else {\\n                            dp1 = max(max(-1, dp-1), dp1 -1);\\n                        }\\n\\n                        dp = dp -1;\\n                    }\\n\\n                    max_result = max(max_result, dp1);\\n                }\\n            }\\n        }\\n\\n        return max_result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649607,
                "title": "python-solution-simple",
                "content": "\\tclass Solution:\\n\\t\\tdef largestVariance(self, s: str) -> int:\\n\\t\\t\\tcounter = Counter(s)\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor a,b in itertools.permutations(counter,2):\\n\\t\\t\\t\\tmax_subarray=0\\n\\t\\t\\t\\thas_a,has_b = False,False\\n\\t\\t\\t\\tremain_a,remain_b = counter[a],counter[b]\\n\\t\\t\\t\\tfor ch in s:\\n\\t\\t\\t\\t\\tif ch!=a and ch!=b:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tif max_subarray<0 and remain_a!=0 and remain_b!=0:\\n\\t\\t\\t\\t\\t\\tmax_subarray=0\\n\\t\\t\\t\\t\\t\\thas_a,has_b = False,False\\n\\t\\t\\t\\t\\tif ch==a: \\n\\t\\t\\t\\t\\t\\tmax_subarray+=1\\n\\t\\t\\t\\t\\t\\tremain_a-=1\\n\\t\\t\\t\\t\\t\\thas_a = True\\n\\t\\t\\t\\t\\telif ch==b: \\n\\t\\t\\t\\t\\t\\tmax_subarray-=1\\n\\t\\t\\t\\t\\t\\tremain_b-=1\\n\\t\\t\\t\\t\\t\\thas_b = True\\n\\t\\t\\t\\t\\tif has_a and has_b:\\n\\t\\t\\t\\t\\t\\tres = max(res, max_subarray)\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef largestVariance(self, s: str) -> int:\\n\\t\\t\\tcounter = Counter(s)\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor a,b in itertools.permutations(counter,2):\\n\\t\\t\\t\\tmax_subarray=0\\n\\t\\t\\t\\thas_a,has_b = False,False\\n\\t\\t\\t\\tremain_a,remain_b = counter[a],counter[b]\\n\\t\\t\\t\\tfor ch in s:\\n\\t\\t\\t\\t\\tif ch!=a and ch!=b:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tif max_subarray<0 and remain_a!=0 and remain_b!=0:\\n\\t\\t\\t\\t\\t\\tmax_subarray=0\\n\\t\\t\\t\\t\\t\\thas_a,has_b = False,False\\n\\t\\t\\t\\t\\tif ch==a: \\n\\t\\t\\t\\t\\t\\tmax_subarray+=1\\n\\t\\t\\t\\t\\t\\tremain_a-=1\\n\\t\\t\\t\\t\\t\\thas_a = True\\n\\t\\t\\t\\t\\telif ch==b: \\n\\t\\t\\t\\t\\t\\tmax_subarray-=1\\n\\t\\t\\t\\t\\t\\tremain_b-=1\\n\\t\\t\\t\\t\\t\\thas_b = True\\n\\t\\t\\t\\t\\tif has_a and has_b:\\n\\t\\t\\t\\t\\t\\tres = max(res, max_subarray)\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2347623,
                "title": "c-clean-and-tidy-solution-with-kadane-and-characters-pair-frequency",
                "content": "```\\n    int largestVariance(string s) {\\n        int total = 0;\\n        unordered_set<char> unique(begin(s), end(s));\\n\\n        for (char a: unique) {\\n            for (char b: unique) {\\n                if (a == b) continue;\\n\\n                int countA = 0, countB = 0;\\n                for (auto ch: s) {\\n                    countA += (ch == a) ? 1 : 0;\\n                    countB += (ch == b) ? 1 : 0;\\n\\n                    total = max(total, countB > 0 ? countA - countB : countA - countB - 1);\\n\\n                    if (countA - countB < 0) {\\n                        countA = 0;\\n                        countB = 0;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return total;\\n    }\\n```\\n\\nSubmitted and accepted solution: https://leetcode.com/submissions/detail/759334799/\\n\\nRuntime: 181ms\\nFaster than: 74%",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int largestVariance(string s) {\\n        int total = 0;\\n        unordered_set<char> unique(begin(s), end(s));\\n\\n        for (char a: unique) {\\n            for (char b: unique) {\\n                if (a == b) continue;\\n\\n                int countA = 0, countB = 0;\\n                for (auto ch: s) {\\n                    countA += (ch == a) ? 1 : 0;\\n                    countB += (ch == b) ? 1 : 0;\\n\\n                    total = max(total, countB > 0 ? countA - countB : countA - countB - 1);\\n\\n                    if (countA - countB < 0) {\\n                        countA = 0;\\n                        countB = 0;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return total;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2148640,
                "title": "python3-pairwise-prefix-sum",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/e134859baf16ddb9bd1645d01619449f3d067c14) for solutions of biweekly 78. \\n\\nBased on this [thread.](http://leetcode.com/problems/substring-with-largest-variance/discuss/2049183/(C%2B%2B)-2272.-Substring-With-Largest-Variance)\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        ans = 0 \\n        seen = set(s)\\n        for x in ascii_lowercase: \\n            for y in ascii_lowercase: \\n                if x != y and x in seen and y in seen: \\n                    vals = []\\n                    for ch in s: \\n                        if ch == x: vals.append(1)\\n                        elif ch == y: vals.append(-1)\\n                    cand = prefix = least = 0 \\n                    ii = -1 \\n                    for i, v in enumerate(vals): \\n                        prefix += v\\n                        if prefix < least: \\n                            least = prefix \\n                            ii = i \\n                        ans = max(ans, min(prefix-least, i-ii-1))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        ans = 0 \\n        seen = set(s)\\n        for x in ascii_lowercase: \\n            for y in ascii_lowercase: \\n                if x != y and x in seen and y in seen: \\n                    vals = []\\n                    for ch in s: \\n                        if ch == x: vals.append(1)\\n                        elif ch == y: vals.append(-1)\\n                    cand = prefix = least = 0 \\n                    ii = -1 \\n                    for i, v in enumerate(vals): \\n                        prefix += v\\n                        if prefix < least: \\n                            least = prefix \\n                            ii = i \\n                        ans = max(ans, min(prefix-least, i-ii-1))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038583,
                "title": "c-python-kadane-s-algorithm",
                "content": "Implemented in python during the contest and got TLE :(\\n\\nTry all permutations of lowercase letters and apply Kadane\\'s algorithm for them.\\n\\n`flag` is for the case like `baaa`. Since we scan the string from left to right, when we meet the first `a`, the count for `b` (i.e. `v2`) would be 0, and we can\\'t update `now` if `v2` is 0\\nIf we\\'ve met `b` before, `flag` would be `true`, and we can update now by `v1-1` because we\\'re sure that there is at least 1 `b`\\n\\n**C++ code:**\\n```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int ans = 0;\\n        string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\\n        for (char &c1: alphabet) {\\n            for (char &c2: alphabet) {\\n                if (c1 == c2) {\\n                    continue;\\n                }\\n                int v1 = 0;\\n                int v2 = 0;\\n                int now = 0;\\n                bool flag = false;\\n                for (char &c : s) {\\n                    if (c == c2) flag = true;\\n                    v1 += c == c1;\\n                    v2 += c == c2;\\n                    if (v2 > v1) v1 = v2 = 0;\\n                    if (v2 > 0) now = max(now, v1-v2);\\n                }\\n                if (v1 > 0 && v2 == 0) {\\n                    if (v1 == s.length()) return 0;\\n                    if (flag) now = max(now, v1-1);\\n                }\\n                ans = max(ans, now);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n---\\n**Updated:**\\nThanks for the great idea from @Dilshodbek . You can see his/her post [here](https://leetcode.com/problems/substring-with-largest-variance/discuss/2038556/Python3-or-Simple-or-Kadanes-algo-or-Faster-than-100)\\n\\nWe can switch the two characters in one Kadane\\'s to try permutations. \\nAlso, we skip the current character if it is neither `c1` nor `c2`. This will reduce the runtime a lot, and will help us pass the test cases even if we implement the solution in Python\\n\\nIf the combination we\\'re trying is `ab`, we try `a,b` and `b,a` in the same Kadane\\'s. I add prefix `c1_c2_` for case `a,b` and `c2_c1_` for case `b,a`\\n\\n**Python code:**\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        ans = 0\\n        S = set(s)\\n        for c1, c2 in combinations(S, 2):\\n            c1_c2_v1 = 0\\n            c1_c2_v2 = 0\\n            c2_c1_v1 = 0\\n            c2_c1_v2 = 0\\n            c1_c2_max = 0\\n            c2_c1_max = 0\\n            c1_c2_flag = False\\n            c2_c1_flag = False\\n            for c in s:\\n                if c == c1:\\n                    c2_c1_flag = True\\n                    c1_c2_v1 += 1\\n                    c2_c1_v2 += 1\\n                elif c == c2:\\n                    c1_c2_flag = True\\n                    c1_c2_v2 += 1\\n                    c2_c1_v1 += 1\\n                else:\\n                    continue\\n\\n                if c1_c2_v2 > c1_c2_v1:\\n                    c1_c2_v1 = c1_c2_v2 = 0\\n                if c2_c1_v2 > c2_c1_v1:\\n                    c2_c1_v1 = c2_c1_v2 = 0    \\n                    \\n                if c1_c2_v2 > 0:\\n                    c1_c2_max = max(c1_c2_max, c1_c2_v1-c1_c2_v2)\\n                if c2_c1_v2 > 0:\\n                    c2_c1_max = max(c2_c1_max, c2_c1_v1-c2_c1_v2)\\n            \\n            if c1_c2_v1 > 0 and c1_c2_v2 == 0:\\n                if c1_c2_v1 == len(s):\\n                    return 0\\n                if c1_c2_flag:\\n                    c1_c2_max = max(c1_c2_max, c1_c2_v1-1)\\n            if c2_c1_v1 > 0 and c2_c1_v2 == 0:\\n                if c2_c1_v1 == len(s):\\n                    return 0\\n                if c2_c1_flag:\\n                    c2_c1_max = max(c2_c1_max, c2_c1_v1-1)\\n\\n            ans = max(ans, c1_c2_max)\\n            ans = max(ans, c2_c1_max)\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int ans = 0;\\n        string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\\n        for (char &c1: alphabet) {\\n            for (char &c2: alphabet) {\\n                if (c1 == c2) {\\n                    continue;\\n                }\\n                int v1 = 0;\\n                int v2 = 0;\\n                int now = 0;\\n                bool flag = false;\\n                for (char &c : s) {\\n                    if (c == c2) flag = true;\\n                    v1 += c == c1;\\n                    v2 += c == c2;\\n                    if (v2 > v1) v1 = v2 = 0;\\n                    if (v2 > 0) now = max(now, v1-v2);\\n                }\\n                if (v1 > 0 && v2 == 0) {\\n                    if (v1 == s.length()) return 0;\\n                    if (flag) now = max(now, v1-1);\\n                }\\n                ans = max(ans, now);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        ans = 0\\n        S = set(s)\\n        for c1, c2 in combinations(S, 2):\\n            c1_c2_v1 = 0\\n            c1_c2_v2 = 0\\n            c2_c1_v1 = 0\\n            c2_c1_v2 = 0\\n            c1_c2_max = 0\\n            c2_c1_max = 0\\n            c1_c2_flag = False\\n            c2_c1_flag = False\\n            for c in s:\\n                if c == c1:\\n                    c2_c1_flag = True\\n                    c1_c2_v1 += 1\\n                    c2_c1_v2 += 1\\n                elif c == c2:\\n                    c1_c2_flag = True\\n                    c1_c2_v2 += 1\\n                    c2_c1_v1 += 1\\n                else:\\n                    continue\\n\\n                if c1_c2_v2 > c1_c2_v1:\\n                    c1_c2_v1 = c1_c2_v2 = 0\\n                if c2_c1_v2 > c2_c1_v1:\\n                    c2_c1_v1 = c2_c1_v2 = 0    \\n                    \\n                if c1_c2_v2 > 0:\\n                    c1_c2_max = max(c1_c2_max, c1_c2_v1-c1_c2_v2)\\n                if c2_c1_v2 > 0:\\n                    c2_c1_max = max(c2_c1_max, c2_c1_v1-c2_c1_v2)\\n            \\n            if c1_c2_v1 > 0 and c1_c2_v2 == 0:\\n                if c1_c2_v1 == len(s):\\n                    return 0\\n                if c1_c2_flag:\\n                    c1_c2_max = max(c1_c2_max, c1_c2_v1-1)\\n            if c2_c1_v1 > 0 and c2_c1_v2 == 0:\\n                if c2_c1_v1 == len(s):\\n                    return 0\\n                if c2_c1_flag:\\n                    c2_c1_max = max(c2_c1_max, c2_c1_v1-1)\\n\\n            ans = max(ans, c1_c2_max)\\n            ans = max(ans, c2_c1_max)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038369,
                "title": "rust-tracking-maximum-seen-difference-in-one-pass-3ms-time",
                "content": "Solving this in one linear scan, tracking cumulative counts and maximum seen differences\\n```rust\\nimpl Solution {\\n    pub fn largest_variance(s: String) -> i32 {\\n        let mut best = 0;\\n        let mut running_counts = [0i32; 26];\\n        let mut max_ci_minus_cj = [[0; 26]; 26]; // Maximum seen ever\\n        let mut max_ci_minus_cj_stable = [[-1000000; 26]; 26]; // Maximum count[i]-count[j] seen before the last `i` char\\n        for b in s.bytes() {\\n            let idx = (b - b\\'a\\') as usize;\\n            for oth in 0..26 { // We\\'re seeing the idx char, so can update the maximum differences for it\\n                max_ci_minus_cj_stable[idx][oth] = max_ci_minus_cj[idx][oth];\\n            }\\n            running_counts[idx] += 1;\\n            for oth in 0..26 {\\n\\t\\t\\t    // Update the best seen difference ever (but don\\'t promote it to stable for now)\\n                max_ci_minus_cj[idx][oth] = std::cmp::max(max_ci_minus_cj[idx][oth], running_counts[idx] - running_counts[oth]);\\n\\t\\t\\t\\t// Two cases: seeing \\'a\\' can either increase the \\'a\\' over \\'b\\' lead, or it can be the first \\'a\\' in some substring allowing \\'b\\' to compare to it\\n                let idx_best = running_counts[idx] - running_counts[oth] + max_ci_minus_cj_stable[oth][idx];\\n                let oth_best = running_counts[oth] - running_counts[idx] + max_ci_minus_cj_stable[idx][oth];\\n                best = std::cmp::max(best, idx_best);\\n                best = std::cmp::max(best, oth_best);\\n            }\\n        }\\n        best\\n    }\\n}\\n```\\n3ms, 2.2MB",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn largest_variance(s: String) -> i32 {\\n        let mut best = 0;\\n        let mut running_counts = [0i32; 26];\\n        let mut max_ci_minus_cj = [[0; 26]; 26]; // Maximum seen ever\\n        let mut max_ci_minus_cj_stable = [[-1000000; 26]; 26]; // Maximum count[i]-count[j] seen before the last `i` char\\n        for b in s.bytes() {\\n            let idx = (b - b\\'a\\') as usize;\\n            for oth in 0..26 { // We\\'re seeing the idx char, so can update the maximum differences for it\\n                max_ci_minus_cj_stable[idx][oth] = max_ci_minus_cj[idx][oth];\\n            }\\n            running_counts[idx] += 1;\\n            for oth in 0..26 {\\n\\t\\t\\t    // Update the best seen difference ever (but don\\'t promote it to stable for now)\\n                max_ci_minus_cj[idx][oth] = std::cmp::max(max_ci_minus_cj[idx][oth], running_counts[idx] - running_counts[oth]);\\n\\t\\t\\t\\t// Two cases: seeing \\'a\\' can either increase the \\'a\\' over \\'b\\' lead, or it can be the first \\'a\\' in some substring allowing \\'b\\' to compare to it\\n                let idx_best = running_counts[idx] - running_counts[oth] + max_ci_minus_cj_stable[oth][idx];\\n                let oth_best = running_counts[oth] - running_counts[idx] + max_ci_minus_cj_stable[idx][oth];\\n                best = std::cmp::max(best, idx_best);\\n                best = std::cmp::max(best, oth_best);\\n            }\\n        }\\n        best\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3741079,
                "title": "ruby",
                "content": "\\n# Code\\n```ruby\\nrequire \\'set\\'\\n\\nclass NilClass\\n    def max(v) = v\\nend\\n\\nclass Numeric\\n    def max(v) = self < v ? v : self\\nend\\n\\nclass String\\n    def aord = ord - \\'a\\'.ord\\nend\\n\\nclass Array\\n    def Array.new2(d1, d2, dflt)\\n        Array.new(d1) {|_| Array.new(d2, dflt) }\\n    end\\nend\\n\\nNCHARS = \\'z\\'.aord + 1\\n\\ndef largest_variance(s)\\n    o, d, db = 0, *[0, -s.size].collect {|v| Array.new2(NCHARS, NCHARS, v) }\\n    s.chars.each {|c|\\n        ch = c.aord\\n        NCHARS.times {|k|\\n            next if k == ch\\n            d[ch][k] += 1\\n            db[ch][k] += 1\\n            db[k][ch] = (d[k][ch] -= 1)\\n            d[k][ch] = 0.max(d.dig(k, ch))\\n            o = o.max(db.dig(ch, k).max(db.dig(k, ch)))\\n        }\\n    }\\n    o\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nrequire \\'set\\'\\n\\nclass NilClass\\n    def max(v) = v\\nend\\n\\nclass Numeric\\n    def max(v) = self < v ? v : self\\nend\\n\\nclass String\\n    def aord = ord - \\'a\\'.ord\\nend\\n\\nclass Array\\n    def Array.new2(d1, d2, dflt)\\n        Array.new(d1) {|_| Array.new(d2, dflt) }\\n    end\\nend\\n\\nNCHARS = \\'z\\'.aord + 1\\n\\ndef largest_variance(s)\\n    o, d, db = 0, *[0, -s.size].collect {|v| Array.new2(NCHARS, NCHARS, v) }\\n    s.chars.each {|c|\\n        ch = c.aord\\n        NCHARS.times {|k|\\n            next if k == ch\\n            d[ch][k] += 1\\n            db[ch][k] += 1\\n            db[k][ch] = (d[k][ch] -= 1)\\n            d[k][ch] = 0.max(d.dig(k, ch))\\n            o = o.max(db.dig(ch, k).max(db.dig(k, ch)))\\n        }\\n    }\\n    o\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740850,
                "title": "2272-substring-with-largest-variance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int largestVariance(String s) {\\n    int ans = 0;\\n\\n    for (char c1 = \\'a\\'; c1 <= \\'z\\'; ++c1)\\n      for (char c2 = \\'a\\'; c2 <= \\'z\\'; ++c2)\\n        if (c1 != c2)\\n          ans = Math.max(ans, kadane(s, c1, c2));\\n\\n    return ans;\\n  }\\n\\n  // A := the char w/ higher freq\\n  // B := the char w/ lower freq\\n  private int kadane(final String s, char a, char b) {\\n    int ans = 0;\\n    int countA = 0;\\n    int countB = 0;\\n    boolean canExtendPrevB = false;\\n\\n    for (final char c : s.toCharArray()) {\\n      if (c != a && c != b)\\n        continue;\\n      if (c == a)\\n        ++countA;\\n      else\\n        ++countB;\\n      if (countB > 0) {\\n        // An interval should contain at least one b\\n        ans = Math.max(ans, countA - countB);\\n      } else if (countB == 0 && canExtendPrevB) {\\n        // Edge case: consider previous b\\n        ans = Math.max(ans, countA - 1);\\n      }\\n      // Reset if # of b > # of a\\n      if (countB > countA) {\\n        countA = 0;\\n        countB = 0;\\n        canExtendPrevB = true;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int largestVariance(String s) {\\n    int ans = 0;\\n\\n    for (char c1 = \\'a\\'; c1 <= \\'z\\'; ++c1)\\n      for (char c2 = \\'a\\'; c2 <= \\'z\\'; ++c2)\\n        if (c1 != c2)\\n          ans = Math.max(ans, kadane(s, c1, c2));\\n\\n    return ans;\\n  }\\n\\n  // A := the char w/ higher freq\\n  // B := the char w/ lower freq\\n  private int kadane(final String s, char a, char b) {\\n    int ans = 0;\\n    int countA = 0;\\n    int countB = 0;\\n    boolean canExtendPrevB = false;\\n\\n    for (final char c : s.toCharArray()) {\\n      if (c != a && c != b)\\n        continue;\\n      if (c == a)\\n        ++countA;\\n      else\\n        ++countB;\\n      if (countB > 0) {\\n        // An interval should contain at least one b\\n        ans = Math.max(ans, countA - countB);\\n      } else if (countB == 0 && canExtendPrevB) {\\n        // Edge case: consider previous b\\n        ans = Math.max(ans, countA - 1);\\n      }\\n      // Reset if # of b > # of a\\n      if (countB > countA) {\\n        countA = 0;\\n        countB = 0;\\n        canExtendPrevB = true;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740797,
                "title": "simple-intuitive-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$.\\n\\n- Space complexity: $$O(1)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        abc = ascii_lowercase\\n        cntrAll = Counter(s)\\n        result = 0\\n        for ch1 in abc:\\n            for ch2 in abc:\\n                if ch1 == ch2:\\n                    continue\\n                \\n                cntr1, cntr2 = 0, 0\\n                numOfCh2Reminder = cntrAll[ch2]\\n                for ch in s:\\n                    if ch == ch1:\\n                        cntr1 += 1\\n                    elif ch == ch2:\\n                        cntr2 += 1\\n                        numOfCh2Reminder -= 1\\n\\n                    if cntr2 > 0:\\n                        result = max(result, cntr1 - cntr2)\\n                    if cntr1 < cntr2 and numOfCh2Reminder > 0:\\n                        cntr1, cntr2 = 0, 0\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        abc = ascii_lowercase\\n        cntrAll = Counter(s)\\n        result = 0\\n        for ch1 in abc:\\n            for ch2 in abc:\\n                if ch1 == ch2:\\n                    continue\\n                \\n                cntr1, cntr2 = 0, 0\\n                numOfCh2Reminder = cntrAll[ch2]\\n                for ch in s:\\n                    if ch == ch1:\\n                        cntr1 += 1\\n                    elif ch == ch2:\\n                        cntr2 += 1\\n                        numOfCh2Reminder -= 1\\n\\n                    if cntr2 > 0:\\n                        result = max(result, cntr1 - cntr2)\\n                    if cntr1 < cntr2 and numOfCh2Reminder > 0:\\n                        cntr1, cntr2 = 0, 0\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740444,
                "title": "solution-using-sliding-window-best-approach-o-n-time-complexity-o-1-space-complexity",
                "content": "# Intuition\\nsliding window \\n\\n# Approach\\nfor every two combination of \\'a\\' to \\'z\\' we just apply sliding window technicque to find max subarry using 2 variable if count first char is grater then second char then increse j++; and when its less then increse l++ and modified cnt1and cnt2 until we get cnt1>cnt2. then take diff of cnt1-cnt2.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(string s)\\n    {\\n        int n=s.size();\\n        int ans=0;\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                int l=0,h=0,cnt1=0,cnt2=0;\\n                if(i==j)continue;\\n                while(h<n){\\n                    if((s[h]-\\'a\\')==i){\\n                        cnt2++;\\n                    }\\n                     if((s[h]-\\'a\\')==j){\\n                        cnt1++;\\n                    }\\n                    while(l<n&&cnt1>cnt2){\\n                        if((s[l]-\\'a\\')==i){\\n                         cnt2--;\\n                         }\\n                         if((s[l]-\\'a\\')==j){\\n                            cnt1--;\\n                        } \\n                        l++;\\n                    }\\n                    h++;\\n                    if(cnt1>0&&cnt2>0)\\n                    ans=max(ans,cnt2-cnt1);\\n                }\\n            }\\n        }\\n        return ans; \\n    }  \\n      int largestVariance(string s) {\\n        string s1=s;\\n        reverse(s1.begin(),s1.end());\\n        return max(solve(s),solve(s1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string s)\\n    {\\n        int n=s.size();\\n        int ans=0;\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                int l=0,h=0,cnt1=0,cnt2=0;\\n                if(i==j)continue;\\n                while(h<n){\\n                    if((s[h]-\\'a\\')==i){\\n                        cnt2++;\\n                    }\\n                     if((s[h]-\\'a\\')==j){\\n                        cnt1++;\\n                    }\\n                    while(l<n&&cnt1>cnt2){\\n                        if((s[l]-\\'a\\')==i){\\n                         cnt2--;\\n                         }\\n                         if((s[l]-\\'a\\')==j){\\n                            cnt1--;\\n                        } \\n                        l++;\\n                    }\\n                    h++;\\n                    if(cnt1>0&&cnt2>0)\\n                    ans=max(ans,cnt2-cnt1);\\n                }\\n            }\\n        }\\n        return ans; \\n    }  \\n      int largestVariance(string s) {\\n        string s1=s;\\n        reverse(s1.begin(),s1.end());\\n        return max(solve(s),solve(s1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739442,
                "title": "kadane-algorithm-java-c-simple-solution",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code is a solution to a problem that calculates the largest variance in a string. The string is represented by lowercase alphabets (a-z), and the variance is calculated based on two different characters in the string.\\n\\nThe main function in the code is `largestVariance`, which takes a string `s` as input and returns the largest variance. The function first initializes a vector `alphabet` of size 26 with all elements set to 0. This vector will be used to count the frequency of each alphabet in the input string.\\n\\nThe next step is to iterate through each character in the input string `s` and update the `alphabet` vector by incrementing the corresponding count. This step counts the frequency of each character in the string.\\n\\nAfter counting the frequency of each character, the code proceeds with two nested loops to iterate over all pairs of characters in the alphabet. The outer loop iterates from `i = 0` to `i = 24`, and the inner loop iterates from `j = i + 1` to `j = 25`. These loops ensure that each pair of characters is considered only once, avoiding duplicates and unnecessary computations.\\n\\nFor each pair of characters `(i, j)`, the code calculates the maximum variance using the `Kadane` function. The `Kadane` function takes the two characters `x` and `y` along with the input string `s` and returns the maximum variance between `x` and `y`. The variance is calculated by traversing the string and keeping track of the count of character `x` and decrementing the count of character `y`. The variable `d` keeps track of the current difference between the counts of `x` and `y`. The variable `ycnt` is a flag that indicates whether character `y` has occurred in the string. If `ycnt` is non-zero, it means that `y` has occurred at least once, and the current difference `d` is considered for calculating the variance. If `ycnt` is zero, it means `y` has not occurred yet, and the current difference `d-1` is considered for calculating the variance. The maximum variance is updated at each step.\\n\\nIf the current difference `d` becomes negative during the traversal, it means that the count of `y` has surpassed the count of `x` in the current substring. In this case, `ycnt` is reset to zero, and `d` is reset to zero to start counting again.\\n\\nFinally, the largest variance among all pairs of characters is updated and returned as the result.\\n\\nIn summary, the code calculates the largest variance between any two characters in the input string. The variance is determined by counting the occurrences of each character and traversing the string to calculate the maximum difference between two characters using the Kadane\\'s algorithm. The code efficiently handles all possible pairs of characters and returns the maximum variance.\\n\\n# Complexity\\n- Time complexity: O(26 * 26 * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# C++ Code \\n```\\nclass Solution {\\n    int Kadane(int x, int y, string &s)\\n    {\\n        int d = 0, n = s.size();\\n        int ans = 0, ycnt = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if((s[i]-\\'a\\') == x)\\n            {\\n                d++;\\n            }\\n            else if((s[i]-\\'a\\') == y)\\n            {\\n                d--;\\n                ycnt = 1;\\n            }\\n            if(ycnt != 0)\\n            {\\n                ans = max(ans, d);\\n            }\\n            else\\n            {\\n                ans = max(ans, d-1);\\n            }\\n            if(d < 0)\\n            {\\n                ycnt = 0;\\n                d = 0;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int largestVariance(string s) {\\n        vector<int> alphabet(26,0);\\n        int ans = 0;\\n        for(char &ch : s)\\n            alphabet[ch-\\'a\\']++;\\n        for(int i = 0; i < 25; i++)\\n        {\\n            if(alphabet[i] == 0) continue;\\n            for(int j = i+1; j < 26; j++)\\n            {\\n                if(alphabet[j] == 0) continue;\\n                int val = max(Kadane(i,j,s), Kadane(j,i,s));\\n                ans = max(val, ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n# Java Code\\n\\npublic class Solution {\\n    public int largestVariance(String s) {\\n        int count1 = 0;\\n        int count2 = 0;\\n        int maxVariance = 0;\\n\\n        // Create a distinct set of character pairs\\n        HashSet<Character> distinctChars = new HashSet<>();\\n        for (char c : s.toCharArray()) {\\n            distinctChars.add(c);\\n        }\\n\\n        // Run once for original string order, then again for reverse string order\\n        for (int runs = 0; runs < 2; runs++) {\\n            for (char l1 : distinctChars) {\\n                for (char l2 : distinctChars) {\\n                    if (l1 == l2) {\\n                        continue;\\n                    }\\n                    count1 = count2 = 0;\\n                    for (char letter : s.toCharArray()) {\\n                        if (letter == l1) {\\n                            count1++;\\n                        } else if (letter == l2) {\\n                            count2++;\\n                        }\\n                        if (count1 < count2) {\\n                            count1 = count2 = 0;\\n                        } else if (count1 > 0 && count2 > 0) {\\n                            maxVariance = Math.max(maxVariance, count1 - count2);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            // Reverse the string for the second time around\\n            s = new StringBuilder(s).reverse().toString();\\n        }\\n\\n        return maxVariance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    int Kadane(int x, int y, string &s)\\n    {\\n        int d = 0, n = s.size();\\n        int ans = 0, ycnt = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if((s[i]-\\'a\\') == x)\\n            {\\n                d++;\\n            }\\n            else if((s[i]-\\'a\\') == y)\\n            {\\n                d--;\\n                ycnt = 1;\\n            }\\n            if(ycnt != 0)\\n            {\\n                ans = max(ans, d);\\n            }\\n            else\\n            {\\n                ans = max(ans, d-1);\\n            }\\n            if(d < 0)\\n            {\\n                ycnt = 0;\\n                d = 0;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int largestVariance(string s) {\\n        vector<int> alphabet(26,0);\\n        int ans = 0;\\n        for(char &ch : s)\\n            alphabet[ch-\\'a\\']++;\\n        for(int i = 0; i < 25; i++)\\n        {\\n            if(alphabet[i] == 0) continue;\\n            for(int j = i+1; j < 26; j++)\\n            {\\n                if(alphabet[j] == 0) continue;\\n                int val = max(Kadane(i,j,s), Kadane(j,i,s));\\n                ans = max(val, ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739408,
                "title": "c-solution-for-substring-with-largest-variance-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to consider all possible pairs of distinct characters in the given string and calculate the variance between the counts of those characters in different substrings.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an array counter of size 26 to keep track of the counts of each lowercase English letter in the given string s.\\n1. Traverse the characters of the string s and update the corresponding count in the counter array.\\n1. Initialize a variable globalMax to keep track of the maximum variance encountered so far.\\n1. Iterate over all pairs of distinct characters (major and minor) from \\'a\\' to \\'z\\'.\\n1. For each pair of characters, calculate the variance between their counts in different substrings.\\n1. Traverse the string s again and maintain two counts: majorCount for the major character and minorCount for the minor character in the pair. Also, keep track of the remaining occurrences of the minor character (restMinor).\\n1. Update the majorCount and minorCount while traversing the string. If the minor character count is non-zero, calculate the variance (majorCount - minorCount) and update globalMax if necessary.\\n1. If the major count becomes smaller than the minor count and there are remaining occurrences of the minor character, reset the counts to zero. This allows us to discard the previous substring and start calculating counts for the next substring.\\n1. Repeat steps 6-8 for all characters in the string.\\n1. Finally, return the value of globalMax, which represents the largest variance among all substrings.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n^2) because there are two nested loops iterating over all possible pairs of characters. The outer loop runs for 26 iterations (representing the 26 lowercase English letters), and the inner loop also runs for 26 iterations. Within the loops, we traverse the string of length n, resulting in a total time complexity of O(n^2).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(1) because we are using a fixed-size array counter of size 26 to store the counts of characters. The space required for the variables used in the calculations is also constant, regardless of the input size.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LargestVariance(string s) {\\n        int[] counter = new int[26];\\n        foreach (char ch in s)\\n        {\\n            counter[ch - \\'a\\']++;\\n        }\\n\\n        int globalMax = 0;\\n\\n        for (int i = 0; i < 26; i++)\\n        {\\n            for (int j = 0; j < 26; j++)\\n            {\\n                if (i == j || counter[i] == 0 || counter[j] == 0)\\n                {\\n                    continue;\\n                }\\n\\n                char major = (char)(\\'a\\' + i);\\n                char minor = (char)(\\'a\\' + j);\\n                int majorCount = 0;\\n                int minorCount = 0;\\n                int restMinor = counter[j];\\n\\n                foreach (char ch in s)\\n                {\\n                    if (ch == major)\\n                    {\\n                        majorCount++;\\n                    }\\n                    if (ch == minor)\\n                    {\\n                        minorCount++;\\n                        restMinor--;\\n                    }\\n\\n                    if (minorCount > 0)\\n                    {\\n                        globalMax = Math.Max(globalMax, majorCount - minorCount);\\n                    }\\n\\n                    if (majorCount < minorCount && restMinor > 0)\\n                    {\\n                        majorCount = 0;\\n                        minorCount = 0;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return globalMax;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LargestVariance(string s) {\\n        int[] counter = new int[26];\\n        foreach (char ch in s)\\n        {\\n            counter[ch - \\'a\\']++;\\n        }\\n\\n        int globalMax = 0;\\n\\n        for (int i = 0; i < 26; i++)\\n        {\\n            for (int j = 0; j < 26; j++)\\n            {\\n                if (i == j || counter[i] == 0 || counter[j] == 0)\\n                {\\n                    continue;\\n                }\\n\\n                char major = (char)(\\'a\\' + i);\\n                char minor = (char)(\\'a\\' + j);\\n                int majorCount = 0;\\n                int minorCount = 0;\\n                int restMinor = counter[j];\\n\\n                foreach (char ch in s)\\n                {\\n                    if (ch == major)\\n                    {\\n                        majorCount++;\\n                    }\\n                    if (ch == minor)\\n                    {\\n                        minorCount++;\\n                        restMinor--;\\n                    }\\n\\n                    if (minorCount > 0)\\n                    {\\n                        globalMax = Math.Max(globalMax, majorCount - minorCount);\\n                    }\\n\\n                    if (majorCount < minorCount && restMinor > 0)\\n                    {\\n                        majorCount = 0;\\n                        minorCount = 0;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return globalMax;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739353,
                "title": "layman-s-code-in-beats-100",
                "content": "![image.png](https://assets.leetcode.com/users/images/9df58282-95b0-49c9-8666-b86aa12e5dc0_1688879268.3483753.png)\\n\\n---\\n# An upvote from you would make my day\\n---\\n# Intuition\\nThe code aims to find the largest variance in a given string `s`. In this problem, variance refers to the difference in count between two distinct characters in the string.\\n\\n1. Initialize two defaultdicts: `char_count` to keep track of the count of each character and `char_index` to store the indices of each character occurrence.\\n   - Set `char_count` as a defaultdict with an initial value of 0.\\n   - Set `char_index` as a defaultdict with an initial value of an empty list.\\n2. Iterate through each character `ch` and its index `i` in the input string `s`.\\n   - Increment the count of `ch` in `char_count` by 1.\\n   - Append the tuple `(i, ch)` to the list corresponding to `ch` in `char_index`.\\n3. Initialize a variable `max_variance` as 0 to store the maximum variance.\\n4. Generate all possible pairs of distinct characters using `itertools.permutations` and iterate over each pair `(char_a, char_b)`.\\n   - Check if the count of `char_b` minus 1 is greater than the current maximum variance.\\n   - Initialize `total` as 0 to keep track of the total count of `char_a` occurrences.\\n   - Initialize `has_b` as False to check if `char_b` has been encountered.\\n   - Sort the occurrences of `char_a` and `char_b` in ascending order by concatenating the lists from `char_index`.\\n   - Iterate over each index-character pair `(index, x)` in the sorted list.\\n     - If `x` is equal to `char_a` and `has_b` is True, decrement `total` by 1.\\n     - If `x` is equal to `char_b`, update the maximum variance if the current `total` plus `has_b` is larger.\\n5. Return the maximum variance as the result.\\n\\n# Complexity\\n- Time complexity: \\nThe time complexity depends on the length of the input string `s` and the number of distinct characters. It involves iterating through the string, sorting the indices, and calculating permutations, resulting in a time complexity of $$O(n^2)$$, where n is the length of `s`.\\n\\n- Space complexity:\\nThe space complexity is determined by the storage of character counts and indices. It grows linearly with the number of distinct characters in the string, resulting in a space complexity of $$O(k)$$, where k is the number of distinct characters.\\n\\n# Code\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        char_count = defaultdict(int)\\n        char_index = defaultdict(list)\\n        for i, ch in enumerate(s):\\n            char_count[ch] += 1\\n            char_index[ch].append((i, ch))\\n\\n        max_variance = 0\\n        for char_a, char_b in itertools.permutations(char_count.keys(), 2):\\n            total, has_b = 0, False\\n            if char_count[char_b] - 1 > max_variance:\\n                for _, x in sorted(char_index[char_a] + char_index[char_b]):\\n                    if x == char_a and (has_b := total > 0):\\n                        total -= 1\\n                    elif x == char_b:\\n                        max_variance = max(max_variance, total + has_b)\\n                        total += 1\\n        return max_variance\\n```\\n# An upvote from you would make my day\\n---",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        char_count = defaultdict(int)\\n        char_index = defaultdict(list)\\n        for i, ch in enumerate(s):\\n            char_count[ch] += 1\\n            char_index[ch].append((i, ch))\\n\\n        max_variance = 0\\n        for char_a, char_b in itertools.permutations(char_count.keys(), 2):\\n            total, has_b = 0, False\\n            if char_count[char_b] - 1 > max_variance:\\n                for _, x in sorted(char_index[char_a] + char_index[char_b]):\\n                    if x == char_a and (has_b := total > 0):\\n                        total -= 1\\n                    elif x == char_b:\\n                        max_variance = max(max_variance, total + has_b)\\n                        total += 1\\n        return max_variance\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738882,
                "title": "beats-100-runtime-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function(s) {\\n    let l = s.length, codes = new Array(l), aCode = \\'a\\'.charCodeAt(0), result = 0, counter = new Array(26).fill(0);\\n    for (let i = 0; i < l; i++) {\\n        codes[i] = s.charCodeAt(i) - aCode;\\n        counter[codes[i]]++;\\n    }\\n    for (let i = 0; i < 26; i++) {//major\\n        for (let j = 0; j < 26; j++) {//minor\\n            if (i == j || counter[i] == 0 || counter[j] == 0) {\\n                continue;\\n            }\\n            let majorCount = 0, minorCount = 0, restMinor = counter[j];\\n            for (k = 0; k < l; k++) {\\n                if (codes[k] == i) {\\n                    majorCount++;\\n                } else if (codes[k] == j) {\\n                    minorCount++;\\n                    restMinor--;\\n                }\\n                if (minorCount > 0) {\\n                    result = Math.max(result, majorCount - minorCount);\\n                }\\n                if (majorCount < minorCount && restMinor > 0) {\\n                    majorCount = 0;\\n                    minorCount = 0;\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function(s) {\\n    let l = s.length, codes = new Array(l), aCode = \\'a\\'.charCodeAt(0), result = 0, counter = new Array(26).fill(0);\\n    for (let i = 0; i < l; i++) {\\n        codes[i] = s.charCodeAt(i) - aCode;\\n        counter[codes[i]]++;\\n    }\\n    for (let i = 0; i < 26; i++) {//major\\n        for (let j = 0; j < 26; j++) {//minor\\n            if (i == j || counter[i] == 0 || counter[j] == 0) {\\n                continue;\\n            }\\n            let majorCount = 0, minorCount = 0, restMinor = counter[j];\\n            for (k = 0; k < l; k++) {\\n                if (codes[k] == i) {\\n                    majorCount++;\\n                } else if (codes[k] == j) {\\n                    minorCount++;\\n                    restMinor--;\\n                }\\n                if (minorCount > 0) {\\n                    result = Math.max(result, majorCount - minorCount);\\n                }\\n                if (majorCount < minorCount && restMinor > 0) {\\n                    majorCount = 0;\\n                    minorCount = 0;\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3738778,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        chars = {}\\n        for c in s:\\n            chars[c] = chars.get(c, 0) + 1\\n\\n        permutations = itertools.permutations(chars, 2)\\n        count = 0\\n        for a, b in permutations:\\n            count = max(self.kadene(a, b, s, chars), count)\\n        return count\\n\\n    def kadene(self, a, b, s, chars):\\n        count = 0\\n        max_local = 0\\n        is_a = False\\n        is_b = False\\n\\n        val_a = chars[a]\\n        val_b = chars[b]\\n        for c in s:\\t\\t\\t\\n            if c != a and c != b:\\n                continue\\n\\n            if max_local < 0 and val_a != 0 and val_b != 0:\\n                max_local = 0\\n                is_a = False\\n                is_b = False\\n\\n            if c == a:\\n                max_local += 1\\n                val_a -= 1\\n                is_a = True\\n\\t\\t\\t\\t\\t\\t\\n            if c == b:\\n                max_local -= 1\\n                val_b -=1\\n                is_b = True\\n            \\n            if is_a and is_b:\\n                count = max(count, max_local)\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        chars = {}\\n        for c in s:\\n            chars[c] = chars.get(c, 0) + 1\\n\\n        permutations = itertools.permutations(chars, 2)\\n        count = 0\\n        for a, b in permutations:\\n            count = max(self.kadene(a, b, s, chars), count)\\n        return count\\n\\n    def kadene(self, a, b, s, chars):\\n        count = 0\\n        max_local = 0\\n        is_a = False\\n        is_b = False\\n\\n        val_a = chars[a]\\n        val_b = chars[b]\\n        for c in s:\\t\\t\\t\\n            if c != a and c != b:\\n                continue\\n\\n            if max_local < 0 and val_a != 0 and val_b != 0:\\n                max_local = 0\\n                is_a = False\\n                is_b = False\\n\\n            if c == a:\\n                max_local += 1\\n                val_a -= 1\\n                is_a = True\\n\\t\\t\\t\\t\\t\\t\\n            if c == b:\\n                max_local -= 1\\n                val_b -=1\\n                is_b = True\\n            \\n            if is_a and is_b:\\n                count = max(count, max_local)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738776,
                "title": "beat-100-o-n-k-most-optimal-solution-k-times-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we are handling a `01` binary string, then it\\'s pretty simple to find the variance. The only complication lies on the fact that both character must have non-zero frequence in the substring. This can be solved by slightly modifying the standard algorithm (Kadane\\'s Algorithm).\\n\\nLet\\'s call the max frequence character **major character** and min frequence character **minor character**. We can add the following constraints and still get the same **variance**.\\n  * The substring starts after a minor character (or the begining of the entire string)\\n  * The substring ends before a minor character (or the end of the entire string)\\n  * The substring has at least one minor character inside.\\n\\nWe do not need to care about the existence of major character, because if it does not exist we get a \"negative variance\" which is always worse than the actual answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe caculate the variance for each pair of **major** and **minor** characters.\\n\\nIn addition, we further optimize this by precomputing all the indices and only operate on indices rather than the original string. This makes our code run $k$ times faster than the editorial solutionm.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N k)$$\\nwhere $N$ is the string length and $k$ is the alphabet size (26).\\n\\n**Proof**\\nFor each call of `FindVariance()`, the two loops run in total $N_x + N_y$ where $N_x$ is the frequency of $x$ in the original string (Note $x$ here is a variable that stands for some character, not the liberal character `x`). We have an obvious condition:\\n$$\\n\\\\sum_x N_x = N\\n$$\\nNow we call `FindVariance()` for each pair of $x$ and $y$ provided that $x \\\\ne y$. Therefore the total running time is:\\n$$\\n\\\\sum_x \\\\sum_{y \\\\ne x} (N_x + N_y) =\\n\\\\sum_x \\\\sum_{y \\\\ne x} N_x + \\\\sum_x \\\\sum_{y \\\\ne x} N_y = \\\\\\\\\\n\\\\sum_y(N - N_y) + \\\\sum_x (N - N_x) = 2 (k - 1) N\\n$$\\nwhere $k$ is the number of unique characters in the original string (at most 26).\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N)$$\\n\\n# Code\\n```\\n\\nint FindVariance(const vector<int>& indices_x, const vector<int>& indices_y) {\\n  int variance = 0;\\n  int low = indices_y.size();\\n  int new_low = 0;\\n  int diff = 0;\\n  auto it = indices_y.begin();\\n  for (int index_x : indices_x) {\\n    while (it != indices_y.end() && *it < index_x) {\\n      ++it;\\n      ++diff;\\n    }\\n    variance = max(variance, diff - low);\\n    --diff;  // Now diff includes index_x\\n    low = min(low, new_low);\\n    new_low = diff;  // This one cannot be used in the next index_x.\\n    if (it == indices_y.end()) {\\n      break;\\n    }\\n  }\\n  diff += indices_y.end() - it;\\n  variance = max(variance, diff - low);\\n  return variance;\\n}\\n\\nclass Solution {\\npublic:\\n  int largestVariance(string s) {\\n    vector<int> indices[26];\\n    for (int i = 0; i < s.size(); ++i) {\\n      indices[s[i] - \\'a\\'].push_back(i);\\n    }\\n    int answer = 0;\\n    for (const vector<int>& indices_x : indices) {\\n      if (indices_x.empty()) {\\n        continue;\\n      }\\n      for (const vector<int>& indices_y : indices) {\\n        if (indices_y.empty() || &indices_y == &indices_x) {\\n          continue;\\n        }\\n        answer = std::max(answer, FindVariance(indices_x, indices_y));\\n      }\\n    }\\n    return answer;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nint FindVariance(const vector<int>& indices_x, const vector<int>& indices_y) {\\n  int variance = 0;\\n  int low = indices_y.size();\\n  int new_low = 0;\\n  int diff = 0;\\n  auto it = indices_y.begin();\\n  for (int index_x : indices_x) {\\n    while (it != indices_y.end() && *it < index_x) {\\n      ++it;\\n      ++diff;\\n    }\\n    variance = max(variance, diff - low);\\n    --diff;  // Now diff includes index_x\\n    low = min(low, new_low);\\n    new_low = diff;  // This one cannot be used in the next index_x.\\n    if (it == indices_y.end()) {\\n      break;\\n    }\\n  }\\n  diff += indices_y.end() - it;\\n  variance = max(variance, diff - low);\\n  return variance;\\n}\\n\\nclass Solution {\\npublic:\\n  int largestVariance(string s) {\\n    vector<int> indices[26];\\n    for (int i = 0; i < s.size(); ++i) {\\n      indices[s[i] - \\'a\\'].push_back(i);\\n    }\\n    int answer = 0;\\n    for (const vector<int>& indices_x : indices) {\\n      if (indices_x.empty()) {\\n        continue;\\n      }\\n      for (const vector<int>& indices_y : indices) {\\n        if (indices_y.empty() || &indices_y == &indices_x) {\\n          continue;\\n        }\\n        answer = std::max(answer, FindVariance(indices_x, indices_y));\\n      }\\n    }\\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464258,
                "title": "concise-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a Kadane\\'s problem, do the Leetcode 53 before this one. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(26*26*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n\\n        char_list = [chr(x) for x in range(ord(\\'a\\'), ord(\\'z\\')+1)]\\n        res = 0\\n        for a in char_list:\\n            for b in char_list:\\n\\n                diff, differWithB = 0, -len(s)\\n\\n                for char in s:\\n\\n                    if char == a:\\n                        diff += 1\\n                        differWithB += 1\\n                    \\n                    elif char == b:\\n                        diff -= 1\\n                        differWithB = diff\\n                        diff = max(0, differWithB)\\n                \\n                    res = max(res, differWithB)\\n        \\n        return res\\n                        \\n\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n\\n        char_list = [chr(x) for x in range(ord(\\'a\\'), ord(\\'z\\')+1)]\\n        res = 0\\n        for a in char_list:\\n            for b in char_list:\\n\\n                diff, differWithB = 0, -len(s)\\n\\n                for char in s:\\n\\n                    if char == a:\\n                        diff += 1\\n                        differWithB += 1\\n                    \\n                    elif char == b:\\n                        diff -= 1\\n                        differWithB = diff\\n                        diff = max(0, differWithB)\\n                \\n                    res = max(res, differWithB)\\n        \\n        return res\\n                        \\n\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786797,
                "title": "python3-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        # This is similar to the Kadane\\'s algorithm, see problem 53 before attempting this one\\n        # Here we take every permutation of 2 characters in a string and then apply Kadane algo to it\\n        # Say string is \\'abcdab\\'\\n        # From the perspective of characters a, b the string is +1, -1, +0, +0, +1, -1\\n        # and we want to maximize this sum\\n        # note that we also want to make sure both a and b are in there, otherwise the numbers\\n        # will be incorrect.\\n        # Also, our operation of finding the sum is not commutative, so we need permutations and\\n        # not combinations.\\n        cntr = Counter(s)\\n        res = 0\\n        for a, b in itertools.permutations(cntr, 2): # note cntr not s\\n            a_cnt, b_cnt = cntr[a], cntr[b]\\n            var = 0; seen_a = seen_b = False\\n            \\n            for c in s:\\n                # this won\\'t impact the variance -- so ignore\\n                if c not in (a, b): continue\\n                if var < 0:\\n                    # we have more b\\'s than a\\'s\\n                    # if no more a\\'s left, var would ultimately be -ve -- so break\\n                    if not a_cnt: break\\n                    # just add the remaining a\\'s to var\\n                    if not b_cnt:\\n                        res = max(res, var + a_cnt)\\n                        break\\n                    # we have a\\'s and b\\'s remaining, so restart\\n                    seen_a = seen_b = False\\n                    var = 0\\n                if c == a:\\n                    var += 1\\n                    a_cnt -= 1\\n                    seen_a = True\\n                if c == b:\\n                    var -= 1\\n                    b_cnt -= 1\\n                    seen_b = True\\n                if seen_a and seen_b:\\n                    res = max(res, var)\\n        return res\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        # This is similar to the Kadane\\'s algorithm, see problem 53 before attempting this one\\n        # Here we take every permutation of 2 characters in a string and then apply Kadane algo to it\\n        # Say string is \\'abcdab\\'\\n        # From the perspective of characters a, b the string is +1, -1, +0, +0, +1, -1\\n        # and we want to maximize this sum\\n        # note that we also want to make sure both a and b are in there, otherwise the numbers\\n        # will be incorrect.\\n        # Also, our operation of finding the sum is not commutative, so we need permutations and\\n        # not combinations.\\n        cntr = Counter(s)\\n        res = 0\\n        for a, b in itertools.permutations(cntr, 2): # note cntr not s\\n            a_cnt, b_cnt = cntr[a], cntr[b]\\n            var = 0; seen_a = seen_b = False\\n            \\n            for c in s:\\n                # this won\\'t impact the variance -- so ignore\\n                if c not in (a, b): continue\\n                if var < 0:\\n                    # we have more b\\'s than a\\'s\\n                    # if no more a\\'s left, var would ultimately be -ve -- so break\\n                    if not a_cnt: break\\n                    # just add the remaining a\\'s to var\\n                    if not b_cnt:\\n                        res = max(res, var + a_cnt)\\n                        break\\n                    # we have a\\'s and b\\'s remaining, so restart\\n                    seen_a = seen_b = False\\n                    var = 0\\n                if c == a:\\n                    var += 1\\n                    a_cnt -= 1\\n                    seen_a = True\\n                if c == b:\\n                    var -= 1\\n                    b_cnt -= 1\\n                    seen_b = True\\n                if seen_a and seen_b:\\n                    res = max(res, var)\\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731742,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int n = s.size();\\n        int res = 0;\\n    \\n        for (char p = \\'a\\'; p <= \\'z\\'; p++) {\\n            for (char q = \\'a\\'; q <= \\'z\\'; q++) {\\n                if (p == q) continue;\\n                \\n                int pCount = 0; \\n                int qCount = 0; \\n                \\n                \\n                bool canExtendprevQ = false;\\n                \\n                for (auto c : s) {\\n                    if (c == p) pCount++;\\n                    if (c == q) qCount++;\\n                    \\n                    if (qCount > 0) {\\n                        res = max(res, pCount - qCount);\\n                    }\\n                    else if (qCount == 0 && canExtendprevQ) {\\n                        res = max(res, pCount - 1);\\n                    }\\n                    \\n                    if (qCount > pCount) {\\n                        qCount = pCount = 0;\\n                        \\n                        canExtendprevQ = true;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int n = s.size();\\n        int res = 0;\\n    \\n        for (char p = \\'a\\'; p <= \\'z\\'; p++) {\\n            for (char q = \\'a\\'; q <= \\'z\\'; q++) {\\n                if (p == q) continue;\\n                \\n                int pCount = 0; \\n                int qCount = 0; \\n                \\n                \\n                bool canExtendprevQ = false;\\n                \\n                for (auto c : s) {\\n                    if (c == p) pCount++;\\n                    if (c == q) qCount++;\\n                    \\n                    if (qCount > 0) {\\n                        res = max(res, pCount - qCount);\\n                    }\\n                    else if (qCount == 0 && canExtendprevQ) {\\n                        res = max(res, pCount - 1);\\n                    }\\n                    \\n                    if (qCount > pCount) {\\n                        qCount = pCount = 0;\\n                        \\n                        canExtendprevQ = true;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661972,
                "title": "java-w-detailed-comments-kadane-s-algorithm-w-o-n-time-o-1-space",
                "content": "# Intuition\\nJava Solution to Substring With Largest Variance using a modified version of Kadane\\'s Algorithm.\\n\\nIncluded comments for reference.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$ - Actually $$O(N*26*26)$$ but generalized to $$O(N)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ - Atually $$O(26)$$ but generalized to $$O(1)$$ constant.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nBoth where $$N$$ is the length of the input String $$s$$\\n# Code\\n```\\nclass Solution {\\n\\n    // Time Complexity:- O(26*26*N) -> Generalized to O(N)\\n    // Space Complexity:- O(26) -> Generalized to O(1)\\n    public int largestVariance(String s) {\\n        // Null/empty check for input String\\n        if (s == null || s.length() == 0) return 0;\\n\\n        // Init int array and increment char counts per s\\n        int[] frequency = new int[26];\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            frequency[s.charAt(i) - \\'a\\']++;\\n        }\\n\\n        int max = 0;\\n\\n        // Loop through every possible pair of chars in the initial string (charA, charB),\\n        // comparing them to find max variance in substrings\\n        for (int charA = 0; charA < 26; charA++)        // Adds O(26) to time complexity\\n        {\\n            for (int charB = 0; charB < 26; charB++)    // Adds O(26) to time complexity\\n            {\\n                int remainA = frequency[charA];\\n                int remainB = frequency[charB];\\n\\n                // When i and j are equal or either or both i and j are 0, continue to next iteration of loop\\n                if (charA == charB || remainA == 0 || remainB == 0)\\n                {\\n                    continue;\\n                }\\n\\n                // Custom Kadanes Algorithm - Dynamic Programming custom implementation to find the substring\\n                // with the max variance between the frequency of charA and charB\\n                int charAFreq = 0;\\n                int charBFreq = 0;\\n\\n                // Compare charA and charB by iterating the string s and comparing the count of charA with charB\\n                for (int k = 0; k < s.length(); k++)    // Adds O(N) to time complexity\\n                {\\n                    int currChar = s.charAt(k) - \\'a\\';   // Get the current char in the string\\n\\n                    // Current char in String is charB\\n                    if (currChar == charB)\\n                    {\\n                        charBFreq++;                    // Increment frequency for charB\\n                    }\\n                    else if (currChar == charA)\\n                    {\\n                        charAFreq++;                    // Increment frequency of charA\\n                        remainA--;                      // Decrement charA\\'s remaining in the array\\n                    }\\n\\n                    // Assuming charAFreq is larger than charBFreq, get max variance\\n                    if (charAFreq > 0)\\n                    {\\n                        max = Math.max(max, charBFreq - charAFreq);\\n                    }\\n\\n                    // charBFreq should always be larger than charAFreq\\n                    // Reset the frequency counts for charA and charB so charB frequency can be maximized as long as\\n                    // there\\'s at least 1 charA remaining on the right side of the pointer\\n                    if (charBFreq < charAFreq && remainA >= 1)\\n                    {\\n                        charBFreq = 0;\\n                        charAFreq = 0;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    // Time Complexity:- O(26*26*N) -> Generalized to O(N)\\n    // Space Complexity:- O(26) -> Generalized to O(1)\\n    public int largestVariance(String s) {\\n        // Null/empty check for input String\\n        if (s == null || s.length() == 0) return 0;\\n\\n        // Init int array and increment char counts per s\\n        int[] frequency = new int[26];\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            frequency[s.charAt(i) - \\'a\\']++;\\n        }\\n\\n        int max = 0;\\n\\n        // Loop through every possible pair of chars in the initial string (charA, charB),\\n        // comparing them to find max variance in substrings\\n        for (int charA = 0; charA < 26; charA++)        // Adds O(26) to time complexity\\n        {\\n            for (int charB = 0; charB < 26; charB++)    // Adds O(26) to time complexity\\n            {\\n                int remainA = frequency[charA];\\n                int remainB = frequency[charB];\\n\\n                // When i and j are equal or either or both i and j are 0, continue to next iteration of loop\\n                if (charA == charB || remainA == 0 || remainB == 0)\\n                {\\n                    continue;\\n                }\\n\\n                // Custom Kadanes Algorithm - Dynamic Programming custom implementation to find the substring\\n                // with the max variance between the frequency of charA and charB\\n                int charAFreq = 0;\\n                int charBFreq = 0;\\n\\n                // Compare charA and charB by iterating the string s and comparing the count of charA with charB\\n                for (int k = 0; k < s.length(); k++)    // Adds O(N) to time complexity\\n                {\\n                    int currChar = s.charAt(k) - \\'a\\';   // Get the current char in the string\\n\\n                    // Current char in String is charB\\n                    if (currChar == charB)\\n                    {\\n                        charBFreq++;                    // Increment frequency for charB\\n                    }\\n                    else if (currChar == charA)\\n                    {\\n                        charAFreq++;                    // Increment frequency of charA\\n                        remainA--;                      // Decrement charA\\'s remaining in the array\\n                    }\\n\\n                    // Assuming charAFreq is larger than charBFreq, get max variance\\n                    if (charAFreq > 0)\\n                    {\\n                        max = Math.max(max, charBFreq - charAFreq);\\n                    }\\n\\n                    // charBFreq should always be larger than charAFreq\\n                    // Reset the frequency counts for charA and charB so charB frequency can be maximized as long as\\n                    // there\\'s at least 1 charA remaining on the right side of the pointer\\n                    if (charBFreq < charAFreq && remainA >= 1)\\n                    {\\n                        charBFreq = 0;\\n                        charAFreq = 0;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551276,
                "title": "python-super-clean-solution",
                "content": "```\\nFor each pair of chars (x, y),  We need two variables xy and d to record values of \\'x-y\\' for \"x>=y\"\\nxy : current difference of x and y \\nd : possible difference of x and y with \"at least one y\"\\nIf we meet x, xy and d will increase 1\\nIf we meet y, xy will decrease 1 and d will used to record current xy.\\nNote \"x>=y\" is needed, so we will be reset xy as 0 if xy < 0\\n```\\n\\n```\\ndef largestVariance(self, s: str) -> int:\\n\\tans, cnter = 0, Counter(s)\\n\\tfor x, y in permutations(set(s), 2):\\n\\t\\tif cnter[x]==1:\\n\\t\\t\\tcontinue   # We can skip this case of only one occurrence of x in s since we need x>=y\\n\\t\\txy, d = 0, -len(s)\\n\\t\\tfor c in s:\\n\\t\\t\\tif c==x:\\n\\t\\t\\t\\txy += 1\\n\\t\\t\\t\\td += 1\\n\\t\\t\\telif c==y:\\n\\t\\t\\t\\txy -= 1\\n\\t\\t\\t\\td = xy \\n\\t\\t\\t\\tif xy<0: \\n\\t\\t\\t\\t\\txy = 0\\n\\t\\t\\tif ans<d:\\n\\t\\t\\t\\tans = d\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\nFor each pair of chars (x, y),  We need two variables xy and d to record values of \\'x-y\\' for \"x>=y\"\\nxy : current difference of x and y \\nd : possible difference of x and y with \"at least one y\"\\nIf we meet x, xy and d will increase 1\\nIf we meet y, xy will decrease 1 and d will used to record current xy.\\nNote \"x>=y\" is needed, so we will be reset xy as 0 if xy < 0\\n```\n```\\ndef largestVariance(self, s: str) -> int:\\n\\tans, cnter = 0, Counter(s)\\n\\tfor x, y in permutations(set(s), 2):\\n\\t\\tif cnter[x]==1:\\n\\t\\t\\tcontinue   # We can skip this case of only one occurrence of x in s since we need x>=y\\n\\t\\txy, d = 0, -len(s)\\n\\t\\tfor c in s:\\n\\t\\t\\tif c==x:\\n\\t\\t\\t\\txy += 1\\n\\t\\t\\t\\td += 1\\n\\t\\t\\telif c==y:\\n\\t\\t\\t\\txy -= 1\\n\\t\\t\\t\\td = xy \\n\\t\\t\\t\\tif xy<0: \\n\\t\\t\\t\\t\\txy = 0\\n\\t\\t\\tif ans<d:\\n\\t\\t\\t\\tans = d\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2533938,
                "title": "java-easy-to-understand-time-26-26-n",
                "content": "```\\n\\nclass Solution {\\n    public int largestVariance(String s) {\\n        \\n        int res = 0;\\n        \\n        //we will take every a-z pair as-> high and low\\n        //we will use kadanes to maximize freq of high in window\\n        //eg high=a, low=b, we will also calculate when high=b, low=a\\n        for(int high=0;high<26;high++){ \\n            for(int low=0;low<26;low++){\\n                if(high==low) continue;  //if both are same ignore\\n                \\n                int currHigh=0, currLow=0;\\n                boolean windowShrinked = false;\\n                for(int i=0; i<s.length(); i++){\\n                    int ch = s.charAt(i)-\\'a\\';\\n                    if(ch == high) currHigh++;\\n                    else if(ch == low) currLow++;\\n                    \\n                    if(currHigh>0 && currLow>0){\\n                        res = Math.max(res, currHigh-currLow);\\n                    }\\n                    // abb\\'aaaaaa\\' when we know window is shrinked, count of currLow can be 0 \\n                    //but we can consider it as 1 bcz it occured once\\n                    else if(currHigh>0 && windowShrinked){ \\n                        res = Math.max(res, currHigh-1);\\n                    }\\n                    \\n                    //if count of low becomes more than high(our window have more \\'low\\' elements which we dont want)\\n                    //so we reduce the size of window and set currLow and currHigh as 0;\\n                    //abbaaaaaa (a=high, b=low) when second b comes, count of low becomes more so we neglect abb\\n                    //but we may take last b into consideration in above case\\n                    if(currLow>currHigh){ //window shrinked \\n                        windowShrinked = true;\\n                        currLow = 0;\\n                        currHigh = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int largestVariance(String s) {\\n        \\n        int res = 0;\\n        \\n        //we will take every a-z pair as-> high and low\\n        //we will use kadanes to maximize freq of high in window\\n        //eg high=a, low=b, we will also calculate when high=b, low=a\\n        for(int high=0;high<26;high++){ \\n            for(int low=0;low<26;low++){\\n                if(high==low) continue;  //if both are same ignore\\n                \\n                int currHigh=0, currLow=0;\\n                boolean windowShrinked = false;\\n                for(int i=0; i<s.length(); i++){\\n                    int ch = s.charAt(i)-\\'a\\';\\n                    if(ch == high) currHigh++;\\n                    else if(ch == low) currLow++;\\n                    \\n                    if(currHigh>0 && currLow>0){\\n                        res = Math.max(res, currHigh-currLow);\\n                    }\\n                    // abb\\'aaaaaa\\' when we know window is shrinked, count of currLow can be 0 \\n                    //but we can consider it as 1 bcz it occured once\\n                    else if(currHigh>0 && windowShrinked){ \\n                        res = Math.max(res, currHigh-1);\\n                    }\\n                    \\n                    //if count of low becomes more than high(our window have more \\'low\\' elements which we dont want)\\n                    //so we reduce the size of window and set currLow and currHigh as 0;\\n                    //abbaaaaaa (a=high, b=low) when second b comes, count of low becomes more so we neglect abb\\n                    //but we may take last b into consideration in above case\\n                    if(currLow>currHigh){ //window shrinked \\n                        windowShrinked = true;\\n                        currLow = 0;\\n                        currHigh = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374540,
                "title": "kadane-s-algorithm-2-pass-dp",
                "content": "For every pair of letters in the alphabet, call them a and b.\\nConvert input String to 1s, -1s, and 0s.\\n\\nFor example: if input String is \"baacba\", and a=\\'a\\', b=\\'b\\',\\nwe would get (-1, 1, 1, 0, -1, 1).\\n\\nThen, we run Kadane\\'s algorithm on the resulting integer array, twice: \\nforward:    (-1, 1, 2, 2, 1, 2)\\nbackward: (1, 2, 1, 0, 0, 1)\\n\\nSay we want to maximize the number of a\\'s, but we need at least 1 b. \"aaaa\" has 4 a\\'s, but variance is 0. \"aaba\" has 3 a\\'s and 1 b, variance is 2.\\nSo we focus on where there is a b. We take the maximum variance from all substrings that ends with b, and maximum variance from all substrings that starts with that same b, minus -1, to get the maximum variance from all substrings containing b.\\n\\n\\n```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        int n = s.length();\\n        int maxVariance = 0;\\n        \\n        int[] freq = new int[26];\\n        \\n        for (int i=0; i<n; i++) {\\n            freq[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for (int a=0; a<26; a++) {\\n            for (int b=0; b<26; b++) {\\n                if (a == b || freq[a] == 0 || freq[b] == 0) continue;\\n\\n                int[] nums = new int[n];\\n                \\n                for (int i=0; i<n; i++) {\\n                    int c = s.charAt(i) - \\'a\\';\\n                    if (c == a) \\n                        nums[i] = 1;\\n                    else if (c == b) \\n                        nums[i] = -1;\\n                    \\n                }\\n                maxVariance = Math.max(maxVariance, findVariance(nums));\\n            }\\n        }\\n        return maxVariance;\\n    }\\n    \\n    private int findVariance(int[] nums) {\\n        int n = nums.length;\\n        \\n        int[] dpForward = new int[n];\\n        dpForward[0] = nums[0];\\n        for (int i=1; i<n; i++) {\\n            dpForward[i] = Math.max(dpForward[i-1]+nums[i], nums[i]);\\n        }\\n        \\n        int curSum = 0;\\n        int maxVariance = 0;\\n        for (int i=n-1; i>=0; i--) {\\n            curSum = Math.max(curSum+nums[i], nums[i]);\\n            if (nums[i] == -1)\\n                maxVariance = Math.max(maxVariance, dpForward[i] + curSum - nums[i]);\\n        }\\n\\n        return maxVariance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        int n = s.length();\\n        int maxVariance = 0;\\n        \\n        int[] freq = new int[26];\\n        \\n        for (int i=0; i<n; i++) {\\n            freq[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for (int a=0; a<26; a++) {\\n            for (int b=0; b<26; b++) {\\n                if (a == b || freq[a] == 0 || freq[b] == 0) continue;\\n\\n                int[] nums = new int[n];\\n                \\n                for (int i=0; i<n; i++) {\\n                    int c = s.charAt(i) - \\'a\\';\\n                    if (c == a) \\n                        nums[i] = 1;\\n                    else if (c == b) \\n                        nums[i] = -1;\\n                    \\n                }\\n                maxVariance = Math.max(maxVariance, findVariance(nums));\\n            }\\n        }\\n        return maxVariance;\\n    }\\n    \\n    private int findVariance(int[] nums) {\\n        int n = nums.length;\\n        \\n        int[] dpForward = new int[n];\\n        dpForward[0] = nums[0];\\n        for (int i=1; i<n; i++) {\\n            dpForward[i] = Math.max(dpForward[i-1]+nums[i], nums[i]);\\n        }\\n        \\n        int curSum = 0;\\n        int maxVariance = 0;\\n        for (int i=n-1; i>=0; i--) {\\n            curSum = Math.max(curSum+nums[i], nums[i]);\\n            if (nums[i] == -1)\\n                maxVariance = Math.max(maxVariance, dpForward[i] + curSum - nums[i]);\\n        }\\n\\n        return maxVariance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2369723,
                "title": "brute-force-to-optimised-java-solution",
                "content": "```\\nBrute force approach :  Gives TLE\\n\\n//generate all substring and \\n//find the diiference between the character with lowest frequency and the character with highest frequency using a map\\n\\nclass Solution {\\n    int maxVariance;\\n    \\n    public void createMapping(String res,Map<Character,Integer> map){\\n        for(char c : res.toCharArray()){\\n            map.put(c,map.getOrDefault(c,0)+1);\\n        }\\n        \\n        int maxFreq=Integer.MIN_VALUE;\\n        int minFreq=Integer.MAX_VALUE;\\n        \\n        for(char c : map.keySet()){\\n            int freq=map.get(c);\\n            maxFreq=Math.max(maxFreq,freq);\\n            minFreq=Math.min(minFreq,freq);\\n        }\\n        \\n        maxVariance=Math.max(maxFreq-minFreq,maxVariance);\\n    }\\n    \\n    public int largestVariance(String s) {\\n        maxVariance=0;\\n        for(int i=0;i<s.length();i++){\\n            for(int j=i;j<s.length();j++){\\n                Map<Character,Integer> map=new HashMap<>();\\n                String res=s.substring(i,j+1);\\n                createMapping(res,map);\\n            }\\n        }\\n        return maxVariance;\\n    }\\n}\\n\\nOptimised approach : \\n\\nclass Solution {\\n    public int largestVariance(String s) {\\n        \\n        int ans=0;\\n        int freq[]=new int[26];\\n        for(int i=0;i<s.length();i++) freq[s.charAt(i)-\\'a\\']++;\\n        \\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                if(i==j || freq[i]==0 || freq[j]==0) continue;\\n                int c1freq=0;\\n                int c2freq=0;\\n                int c1rem=freq[i];\\n                for(int k=0;k<s.length();k++){\\n                    char ch=s.charAt(k);\\n                    int idx=ch-\\'a\\';\\n                    if(idx==i){\\n                        c1freq++;\\n                        c1rem--;\\n                    }\\n                    if(idx==j) c2freq++;\\n                    if(c1freq>c2freq && c1rem>0){\\n                        c1freq=0;\\n                        c2freq=0;\\n                    }\\n                    \\n                    if(c2freq>0 && c1freq>0) ans=Math.max(ans,c2freq-c1freq);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    int maxVariance;\\n    \\n    public void createMapping(String res,Map<Character,Integer> map){\\n        for(char c : res.toCharArray()){\\n            map.put(c,map.getOrDefault(c,0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2352585,
                "title": "kadane-s-algorithm-python-with-clear-analysis",
                "content": "we can convert this question to a O(N) by converting to it a max subarray sum problem and solve it with Kadane\\'s Algorithm. \\n\\nCalculate the letters in the string. Use two for loops to iterate all combinations. Because the maximum of the combinations is only 26x25. So it is still O(1).Let\\'s assign 1 to the first letter, assign -1 to another letter, assign 0 to other letters. The problem turn into find the result of maximum sum of a subarray. This problem can be solved by Kadane\\'s Algorithm. \\n\\nHowever, this Kadane\\'s Algorithm needs the subarray at least contains one -1. Let\\'s define that dp[i] is the max subarray with at least one -1 and the subarray ends at i. Let\\'s figure the calculation of dp[i + 1]. If we can find the max element in dp, this is our result. We firstly need to add two more variables: start and valid. The start is used to mark current subarray\\'s starting position and the valid is used to mark whether current subarray contains a -1 or not.\\n\\n1) If nums[i + 1] == 1, obviously dp[i + 1] = dp[i] + 1\\n2) If nums[i + 1] == -1 and valid is false. It means the subarray ends with i is not valid. We will add this -1 behind and make it valid. Meanwhile, the dp[i + 1] = dp[i] - 1\\n3) If nums[i + 1] == -1 and valid is true and dp[i] < 0. It means we have included more -1 than 1 in the subarray. Since the minimal value of the result is at least 0, we will need to move the start to i and set the dp value to -1\\n4) If nums[i + 1] == -1 and valid is true and dp[i] >= 0 and nums[start] == -1.  It means current subarray starts with a -1. Since we are going to add a new -1, we can simple move the start forward one step and get ride of this -1 and add another -1 behind. The dp value will not change. \\n5) If nums[i + 1] == -1 and valid is true and dp[i] >= 0 and nums[start] == 1. It means the current subarray starts with a 1. If the dp[i] is 0, it means we will need to restart from i + 1. The start is set to current index and dp is set to be -1. If the dp[i] is larger than 0, the max value for i + 1 is simply dp[i] - 1.\\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        # Find max subarray sum if at least one -1 is included. \\n        # dp[i] the max subarray with at least one -1 sum that ends at i\\n        # dp[i + 1] = if nums[i + 1] == 1, dp[i] + 1\\n        #             if nums[i + 1] == -1, dp[i] - 1\\n        #.                   if dp[i] > 0 dp[i] (the start index nums[start] == -1, we move start one step forward) or dp[i] - 1\\n        #.                   if dp[i] <= 0 start = i, 0\\n        def kadane(nums):\\n            n = len(nums)\\n            dp = nums[0]\\n            start = 0\\n            valid = nums[0] == -1 # if a -1 is included, the result is valid.\\n            max_dp = 0\\n            for i in range(1, n):\\n                next_dp = 0\\n                if nums[i] == 1:\\n                    next_dp = dp + 1\\n                else:# nums[i] == -1:\\n                    if not valid:\\n                        next_dp = dp - 1\\n                        valid = True\\n                    else:\\n                        if dp >= 0:\\n                            if nums[start] == -1:\\n                                next_dp = dp\\n                                start += 1\\n                            else:\\n                                if dp == 0:\\n                                    next_dp = -1\\n                                    start = i\\n                                else:\\n                                    next_dp = dp - 1\\n                        else:\\n                            start = i\\n                            next_dp = -1\\n                dp = next_dp\\n                if valid:\\n                    max_dp = max(dp, max_dp)\\n            return max_dp\\n        n = len(s)\\n        letters = set(s)\\n        if len(letters) == 1:\\n            return 0\\n        ans = -float(\\'inf\\')\\n        for a in letters:\\n            for b in letters:\\n                if a == b:\\n                    continue\\n                nums = list(map(lambda ch: 1 if ch == a else -1, filter(lambda ch: ch == a or ch == b, s)))\\n                res = kadane(nums)\\n                ans = max(ans, res)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        # Find max subarray sum if at least one -1 is included. \\n        # dp[i] the max subarray with at least one -1 sum that ends at i\\n        # dp[i + 1] = if nums[i + 1] == 1, dp[i] + 1\\n        #             if nums[i + 1] == -1, dp[i] - 1\\n        #.                   if dp[i] > 0 dp[i] (the start index nums[start] == -1, we move start one step forward) or dp[i] - 1\\n        #.                   if dp[i] <= 0 start = i, 0\\n        def kadane(nums):\\n            n = len(nums)\\n            dp = nums[0]\\n            start = 0\\n            valid = nums[0] == -1 # if a -1 is included, the result is valid.\\n            max_dp = 0\\n            for i in range(1, n):\\n                next_dp = 0\\n                if nums[i] == 1:\\n                    next_dp = dp + 1\\n                else:# nums[i] == -1:\\n                    if not valid:\\n                        next_dp = dp - 1\\n                        valid = True\\n                    else:\\n                        if dp >= 0:\\n                            if nums[start] == -1:\\n                                next_dp = dp\\n                                start += 1\\n                            else:\\n                                if dp == 0:\\n                                    next_dp = -1\\n                                    start = i\\n                                else:\\n                                    next_dp = dp - 1\\n                        else:\\n                            start = i\\n                            next_dp = -1\\n                dp = next_dp\\n                if valid:\\n                    max_dp = max(dp, max_dp)\\n            return max_dp\\n        n = len(s)\\n        letters = set(s)\\n        if len(letters) == 1:\\n            return 0\\n        ans = -float(\\'inf\\')\\n        for a in letters:\\n            for b in letters:\\n                if a == b:\\n                    continue\\n                nums = list(map(lambda ch: 1 if ch == a else -1, filter(lambda ch: ch == a or ch == b, s)))\\n                res = kadane(nums)\\n                ans = max(ans, res)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173195,
                "title": "easy-java-intuitive-doable-in-interview-setup-no-map",
                "content": "\\n\\n```java\\nclass Solution {\\n    private void reverse(char[] c) {\\n        int low = 0, high = c.length -1;\\n        while(low < high) {\\n            char temp = c[low];\\n            c[low] = c[high];\\n            c[high] = temp;\\n            low++;\\n            high--;\\n        }\\n        \\n    }\\n    public int largestVariance(String s) {\\n        int ans = 0;\\n\\n        \\n        // act on 2 chars at a time and keep checking the difference at each idx\\n   \\n        for(char i = \\'a\\'; i <= \\'z\\'; i++) {\\n            for(char j = \\'a\\'; j <= \\'z\\'; j++) {\\n                if (i == j ) continue;\\n                 char[] aux = s.toCharArray();\\n                for(int iteration = 1; iteration <= 2; iteration++) {\\n                    int count1 = 0;\\n                    int count2 = 0;\\n                    for(char c : aux) {\\n                        if (c == i) {\\n                            count1++;\\n                        }\\n                        if (c == j) {\\n                            count2++;\\n                        }\\n\\n                        if (count1 < count2) {\\n                            count1 = 0; count2 = 0;\\n                        }\\n                        if (count1 > 0 && count2 > 0) {\\n\\t\\t\\t\\t\\t\\t//assumming aaaabb case or when count1 > count2 then only calculate ans \\n\\t\\t\\t\\t\\t\\t//for aabbbbb case we reverse the string and then make count1 > count2 and calculate ans\\n                            ans = Math.max(ans , count1 - count2);\\n                        }\\n                    }\\n                     //reverse and check again for cases where count1 < count2 and count2...count1 would result in maximum answer for eg : aabbbbb\\n                   reverse(aux); \\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private void reverse(char[] c) {\\n        int low = 0, high = c.length -1;\\n        while(low < high) {\\n            char temp = c[low];\\n            c[low] = c[high];\\n            c[high] = temp;\\n            low++;\\n            high--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2061132,
                "title": "c-solution-o-n",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        set<char> set_s;\\n        for(auto it: s) set_s.insert(it);\\n        \\n        int ans = 0;\\n        for(char a: set_s) for(char b: set_s) if(a != b && a > b) {\\n                int mx = 0, mi = 0, nw = 0;\\n                bool has_a = 0, has_b = 0;\\n                for(auto it: s) if(it == a || it == b) {\\n                        nw += (it==a? 1: -1);\\n                        if(it == a) has_a = 1;\\n                        if(it == b) has_b = 1;\\n                        if(nw > mx) mx = nw, has_a = 0;\\n                        if(nw < mi) mi = nw, has_b = 0;\\n                        ans = max(ans, mx - nw - (!has_a));\\n                        ans = max(ans, nw - mi - (!has_b));\\n                }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        set<char> set_s;\\n        for(auto it: s) set_s.insert(it);\\n        \\n        int ans = 0;\\n        for(char a: set_s) for(char b: set_s) if(a != b && a > b) {\\n                int mx = 0, mi = 0, nw = 0;\\n                bool has_a = 0, has_b = 0;\\n                for(auto it: s) if(it == a || it == b) {\\n                        nw += (it==a? 1: -1);\\n                        if(it == a) has_a = 1;\\n                        if(it == b) has_b = 1;\\n                        if(nw > mx) mx = nw, has_a = 0;\\n                        if(nw < mi) mi = nw, has_b = 0;\\n                        ans = max(ans, mx - nw - (!has_a));\\n                        ans = max(ans, nw - mi - (!has_b));\\n                }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2049183,
                "title": "c-2272-substring-with-largest-variance",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int ans = 0; \\n        for (auto& x : \"abcdefghijklmnopqrstuvwxyz\") \\n            for (auto& y : \"abcdefghijklmnopqrstuvwxyz\") \\n                if (x != y) {\\n                    int prefix = 0, buff = 0, m = 10000; \\n                    for (auto& ch : s) {\\n                        if (ch == x) ++prefix; \\n                        else if (ch == y) {\\n                            m = min(m, buff);\\n                            buff = --prefix; \\n                        }\\n                        ans = max(ans, prefix - m); \\n                    }\\n                }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int ans = 0; \\n        for (auto& x : \"abcdefghijklmnopqrstuvwxyz\") \\n            for (auto& y : \"abcdefghijklmnopqrstuvwxyz\") \\n                if (x != y) {\\n                    int prefix = 0, buff = 0, m = 10000; \\n                    for (auto& ch : s) {\\n                        if (ch == x) ++prefix; \\n                        else if (ch == y) {\\n                            m = min(m, buff);\\n                            buff = --prefix; \\n                        }\\n                        ans = max(ans, prefix - m); \\n                    }\\n                }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038952,
                "title": "python-2-26-n-faster-than-26-25-n",
                "content": "We can reduce it from 26 * 25 * N to 2 * 26 * N by storing the indices for each character (extra O(N) space). This allows us in the character comparisons to only consider parts of the array that have one of the characters. We can then find the maximum difference knowing the two characters we are comparing in O(char1_length + char2_length) time instead of O(N). \\n\\nWith this optimization, for each character, we then consider the following: (array_count-curr_char_count) + 26*curr_char_count, which is superior to 26 * N for each iteration. This results in 2 * 26 * N (each char will participate equally on each side of the comparison) rather than 26 * 25 * N. \\n\\nOne note: This is much cleaner than my contest code. :)\\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        from collections import defaultdict\\n\\n        char_list = defaultdict(list)\\n        for i,char in enumerate(s):\\n            char_list[char].append(i)\\n            \\n        best_ans = 0\\n        for target in char_list.keys():\\n            for small_char in char_list.keys():\\n                if target != small_char:\\n                    char_array = char_list[small_char]\\n                    target_array = char_list[target]\\n                    i = 0\\n                    j = 0\\n                    target_count = 0\\n                    char_count = 0\\n                    while i < len(target_array) and j < len(char_array):\\n                        if char_array[j] < target_array[i]:\\n                            char_count += 1\\n                            j += 1\\n                            if char_count > target_count:\\n                                char_count = 0\\n                                target_count = 0\\n                        else:\\n                            target_count += 1\\n\\t\\t\\t\\t\\t\\t\\t## since the most recent char is target, no need to keep small char around, \\n\\t\\t\\t\\t\\t\\t\\t## in our final answer we always assume at least one char_count because we know it\\'s in the array\\n                            if target_count-char_count==0: \\n                                target_count = 1\\n                                char_count = 0\\n                            best_ans = max(best_ans,target_count-max(char_count,1))\\n                            i += 1\\n                    if i < len(target_array):\\n                        best_ans = max(best_ans,target_count-max(char_count,1)+len(target_array)-i)\\n        return best_ans",
                "solutionTags": [],
                "code": "We can reduce it from 26 * 25 * N to 2 * 26 * N by storing the indices for each character (extra O(N) space). This allows us in the character comparisons to only consider parts of the array that have one of the characters. We can then find the maximum difference knowing the two characters we are comparing in O(char1_length + char2_length) time instead of O(N). \\n\\nWith this optimization, for each character, we then consider the following: (array_count-curr_char_count) + 26*curr_char_count, which is superior to 26 * N for each iteration. This results in 2 * 26 * N (each char will participate equally on each side of the comparison) rather than 26 * 25 * N. \\n\\nOne note: This is much cleaner than my contest code. :)\\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        from collections import defaultdict\\n\\n        char_list = defaultdict(list)\\n        for i,char in enumerate(s):\\n            char_list[char].append(i)\\n            \\n        best_ans = 0\\n        for target in char_list.keys():\\n            for small_char in char_list.keys():\\n                if target != small_char:\\n                    char_array = char_list[small_char]\\n                    target_array = char_list[target]\\n                    i = 0\\n                    j = 0\\n                    target_count = 0\\n                    char_count = 0\\n                    while i < len(target_array) and j < len(char_array):\\n                        if char_array[j] < target_array[i]:\\n                            char_count += 1\\n                            j += 1\\n                            if char_count > target_count:\\n                                char_count = 0\\n                                target_count = 0\\n                        else:\\n                            target_count += 1\\n\\t\\t\\t\\t\\t\\t\\t## since the most recent char is target, no need to keep small char around, \\n\\t\\t\\t\\t\\t\\t\\t## in our final answer we always assume at least one char_count because we know it\\'s in the array\\n                            if target_count-char_count==0: \\n                                target_count = 1\\n                                char_count = 0\\n                            best_ans = max(best_ans,target_count-max(char_count,1))\\n                            i += 1\\n                    if i < len(target_array):\\n                        best_ans = max(best_ans,target_count-max(char_count,1)+len(target_array)-i)\\n        return best_ans",
                "codeTag": "Java"
            },
            {
                "id": 2038235,
                "title": "c-boils-down-to-max-sum-subarray-kadane-s-algo",
                "content": "Make sure you take atleast one of the other char, thats why using len to handle this case.\\nIf max sum subarray == len of subarray , means all eaqual chars are taken, which is not allowed!!\\n\\n\\nPlease upvote if u liked!\\n\\n```\\n#define all(x) x.begin(), x.end()\\n#define sz(x) static_cast<int32_t>(x.size())\\ntemplate <class T> inline void chmax(T &x,T y){ x = max((x), (y));}\\n\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int n = s.size();\\n        int ans = 0;\\n        for (int a = 0; a < 26; ++a) {\\n            for (int b = 1; b < 26; ++b) {\\n                int has_a = 0, has_b = 0;\\n                string str = \"\";\\n                for (int i = 0; i < n; ++i) {\\n                    if (s[i] - \\'a\\' == a) str.push_back(\\'0\\'), has_a = 1;\\n                    else if (s[i] - \\'a\\' == b) str.push_back(\\'1\\'), has_b = 1;\\n                }\\n                if ((!has_a) or (!has_b) or sz(str) < 2) continue;\\n                int current_sum = 0;\\n                int max_sum = 0;\\n                int len = 0;\\n                for (int i = 0; i < sz(str); i++) {\\n                    len++;\\n                    current_sum += (str[i] == \\'0\\' ? 1 : -1);\\n                    if (current_sum < 0)\\n                        current_sum = 0, len = 0;\\n                    max_sum = max(current_sum - (len == current_sum ? 1 : 0), max_sum);\\n                }\\n                chmax(ans, max_sum);\\n                current_sum = 0;\\n                max_sum = 0;\\n                len = 0;\\n                for (int i = 0; i < sz(str); i++) {\\n                    len++;\\n                    current_sum += (str[i] == \\'1\\' ? 1 : -1);\\n                    if (current_sum < 0)\\n                        current_sum = 0, len = 0;\\n                    max_sum = max(current_sum - (len == current_sum ? 1 : 0), max_sum);\\n                }\\n                chmax(ans, max_sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n#define all(x) x.begin(), x.end()\\n#define sz(x) static_cast<int32_t>(x.size())\\ntemplate <class T> inline void chmax(T &x,T y){ x = max((x), (y));}\\n\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int n = s.size();\\n        int ans = 0;\\n        for (int a = 0; a < 26; ++a) {\\n            for (int b = 1; b < 26; ++b) {\\n                int has_a = 0, has_b = 0;\\n                string str = \"\";\\n                for (int i = 0; i < n; ++i) {\\n                    if (s[i] - \\'a\\' == a) str.push_back(\\'0\\'), has_a = 1;\\n                    else if (s[i] - \\'a\\' == b) str.push_back(\\'1\\'), has_b = 1;\\n                }\\n                if ((!has_a) or (!has_b) or sz(str) < 2) continue;\\n                int current_sum = 0;\\n                int max_sum = 0;\\n                int len = 0;\\n                for (int i = 0; i < sz(str); i++) {\\n                    len++;\\n                    current_sum += (str[i] == \\'0\\' ? 1 : -1);\\n                    if (current_sum < 0)\\n                        current_sum = 0, len = 0;\\n                    max_sum = max(current_sum - (len == current_sum ? 1 : 0), max_sum);\\n                }\\n                chmax(ans, max_sum);\\n                current_sum = 0;\\n                max_sum = 0;\\n                len = 0;\\n                for (int i = 0; i < sz(str); i++) {\\n                    len++;\\n                    current_sum += (str[i] == \\'1\\' ? 1 : -1);\\n                    if (current_sum < 0)\\n                        current_sum = 0, len = 0;\\n                    max_sum = max(current_sum - (len == current_sum ? 1 : 0), max_sum);\\n                }\\n                chmax(ans, max_sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744132,
                "title": "easy-c-solution-using-kadane-s-algo",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        unordered_map<char,int> freq;\\n        for(auto & c:s)\\n            freq[c]++;\\n            int ans=0;\\n        \\n        for(char ch1=\\'a\\';ch1<=\\'z\\';ch1++){\\n            for(char ch2=\\'a\\';ch2<=\\'z\\';ch2++){\\n                if(ch1==ch2||freq[ch1]==0||freq[ch2]==0)\\n                    continue;\\n                for(int r=1;r<=2;r++){\\n                    int cnt1=0,cnt2=0;\\n                    for(auto& c: s){\\n                        cnt1+=ch1==c;\\n                        cnt2+=ch2==c;\\n                        if(cnt1<cnt2)\\n                            cnt1=cnt2=0;\\n                        if(cnt1>0&&cnt2>0)\\n                        ans=max(ans,cnt1-cnt2);\\n                    }\\n                    reverse(s.begin(),s.end());\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        unordered_map<char,int> freq;\\n        for(auto & c:s)\\n            freq[c]++;\\n            int ans=0;\\n        \\n        for(char ch1=\\'a\\';ch1<=\\'z\\';ch1++){\\n            for(char ch2=\\'a\\';ch2<=\\'z\\';ch2++){\\n                if(ch1==ch2||freq[ch1]==0||freq[ch2]==0)\\n                    continue;\\n                for(int r=1;r<=2;r++){\\n                    int cnt1=0,cnt2=0;\\n                    for(auto& c: s){\\n                        cnt1+=ch1==c;\\n                        cnt2+=ch2==c;\\n                        if(cnt1<cnt2)\\n                            cnt1=cnt2=0;\\n                        if(cnt1>0&&cnt2>0)\\n                        ans=max(ans,cnt1-cnt2);\\n                    }\\n                    reverse(s.begin(),s.end());\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742693,
                "title": "python-short-and-clean-functional-programming",
                "content": "# Approach\\nTL;DR, Similar to [Editorial solution](https://leetcode.com/problems/substring-with-largest-variance/editorial/) but written using functional programming.\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\cdot k^2)$$\\n\\n- Space complexity: $$O(k)$$\\n\\nwhere,\\n`n is the length of s`,\\n`k is the charset of s. i.e in this case 26`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        def variance(major: str, minor: str, rem_minors: int) -> int:\\n            encoder = partial(getitem, defaultdict(int, {major: 1, minor: -1}))\\n            encoded_s = filter(bool, map(encoder, s))\\n\\n            next_ = lambda st, x: tuple(map(add, (x > 0, x < 0, min(x, 0)), ((0, 0, st[2]) if st[0] < st[1] and st[2] > 0 else st)))\\n            states = accumulate(encoded_s, next_, initial=(0, 0, rem_minors)) # init_st = (major_count, minor_count, remaining_minor_count)\\n\\n            return max((mjr - mnr for mjr, mnr, _ in states if mnr > 0), default=0)\\n        \\n        c = Counter(s)\\n        return max(variance(mjr, mnr, c[mnr]) for mjr, mnr in product(ascii_lowercase, ascii_lowercase))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        def variance(major: str, minor: str, rem_minors: int) -> int:\\n            encoder = partial(getitem, defaultdict(int, {major: 1, minor: -1}))\\n            encoded_s = filter(bool, map(encoder, s))\\n\\n            next_ = lambda st, x: tuple(map(add, (x > 0, x < 0, min(x, 0)), ((0, 0, st[2]) if st[0] < st[1] and st[2] > 0 else st)))\\n            states = accumulate(encoded_s, next_, initial=(0, 0, rem_minors)) # init_st = (major_count, minor_count, remaining_minor_count)\\n\\n            return max((mjr - mnr for mjr, mnr, _ in states if mnr > 0), default=0)\\n        \\n        c = Counter(s)\\n        return max(variance(mjr, mnr, c[mnr]) for mjr, mnr in product(ascii_lowercase, ascii_lowercase))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742405,
                "title": "c-concise-solution-o-26-n",
                "content": "Do Kadane for each pair of characters. For a particular pair of characters, say `a` and `b`, store their counts and a `flag`: whether opposite character has been seen before. All that\\'s left is to record max variance.\\n```\\nint f(int *a) {\\n    if (a[2] == 0) return 0; // no opposite char\\n    if (a[0] < a[1]) { a[0] = a[1] = 0; } // reset\\n    if (a[1] > 0) // at least one \\'b\\'\\n        return a[0] - a[1];\\n    return a[0] - 1; // take \\'b\\' from the side\\n}\\nint largestVariance(string s) {\\n    int dp[26][26][3] = {};\\n    int ret = 0;\\n    for (auto c : s) { \\n        int i = c - \\'a\\';\\n        for (int j = 0; j < 26; j++) {\\n            if (j == i) continue ;\\n            auto &ab = dp[i][j]; // a b Fb\\n            auto &ba = dp[j][i]; // b a Fa\\n            ab[0]++; ba[1]++; ba[2] = true;\\n            ret = max({ret, f(ab), f(ba)});\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint f(int *a) {\\n    if (a[2] == 0) return 0; // no opposite char\\n    if (a[0] < a[1]) { a[0] = a[1] = 0; } // reset\\n    if (a[1] > 0) // at least one \\'b\\'\\n        return a[0] - a[1];\\n    return a[0] - 1; // take \\'b\\' from the side\\n}\\nint largestVariance(string s) {\\n    int dp[26][26][3] = {};\\n    int ret = 0;\\n    for (auto c : s) { \\n        int i = c - \\'a\\';\\n        for (int j = 0; j < 26; j++) {\\n            if (j == i) continue ;\\n            auto &ab = dp[i][j]; // a b Fb\\n            auto &ba = dp[j][i]; // b a Fa\\n            ab[0]++; ba[1]++; ba[2] = true;\\n            ret = max({ret, f(ab), f(ba)});\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742394,
                "title": "c-solution-using-modified-kadane-s-algorithm",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int ans = 0; // Variable to store the largest variance\\n        vector<int> freq(26, 0); // Frequency array to count occurrences of each character\\n        // Count the frequency of each character in the string\\n        for (auto it : s) freq[it - \\'a\\']++;\\n        // Iterate through each pair of characters (ch1 and ch2)\\n        for (char ch1 = \\'a\\'; ch1 <= \\'z\\'; ch1++) {\\n            for (char ch2 = \\'a\\'; ch2 <= \\'z\\'; ch2++) {\\n                if (ch1 == ch2 || freq[ch1 - \\'a\\'] == 0 || freq[ch2 - \\'a\\'] == 0) continue; // Skip if ch1 and ch2 are the same or either of them has zero occurrences             \\n                // Try both the original string and its reverse\\n                for (int rev = 0; rev < 2; rev++) {\\n                    int c1 = 0, c2 = 0; // Counters for occurrences of ch1 and ch2             \\n                    // Traverse the string and update the counters\\n                    for (auto it : s) {\\n                        if (it == ch1)  c1++;\\n                        if (it == ch2)c2++;\\n                        if (c1 < c2) {\\n                            // Reset counters if c1 becomes less than c2\\n                            c1 = 0;\\n                            c2 = 0;\\n                        }\\n                        if (c1 > 0 && c2 > 0) {\\n                            // Calculate and update the largest variance\\n                            ans = max(ans, c1 - c2);\\n                        }\\n                    }\\n                    reverse(s.begin(), s.end()); // Reverse the string for the second iteration\\n                }\\n            }\\n        }\\n        return ans; // Return the largest variance\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int ans = 0; // Variable to store the largest variance\\n        vector<int> freq(26, 0); // Frequency array to count occurrences of each character\\n        // Count the frequency of each character in the string\\n        for (auto it : s) freq[it - \\'a\\']++;\\n        // Iterate through each pair of characters (ch1 and ch2)\\n        for (char ch1 = \\'a\\'; ch1 <= \\'z\\'; ch1++) {\\n            for (char ch2 = \\'a\\'; ch2 <= \\'z\\'; ch2++) {\\n                if (ch1 == ch2 || freq[ch1 - \\'a\\'] == 0 || freq[ch2 - \\'a\\'] == 0) continue; // Skip if ch1 and ch2 are the same or either of them has zero occurrences             \\n                // Try both the original string and its reverse\\n                for (int rev = 0; rev < 2; rev++) {\\n                    int c1 = 0, c2 = 0; // Counters for occurrences of ch1 and ch2             \\n                    // Traverse the string and update the counters\\n                    for (auto it : s) {\\n                        if (it == ch1)  c1++;\\n                        if (it == ch2)c2++;\\n                        if (c1 < c2) {\\n                            // Reset counters if c1 becomes less than c2\\n                            c1 = 0;\\n                            c2 = 0;\\n                        }\\n                        if (c1 > 0 && c2 > 0) {\\n                            // Calculate and update the largest variance\\n                            ans = max(ans, c1 - c2);\\n                        }\\n                    }\\n                    reverse(s.begin(), s.end()); // Reverse the string for the second iteration\\n                }\\n            }\\n        }\\n        return ans; // Return the largest variance\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742350,
                "title": "2272-substring-with-largest-variance",
                "content": "# Intuition\\nhere we have to find variance of string means frequency of s1 and s2 and find difference between s1, s2 take max of that will be the answer.\\n\\n# Approach\\nkadane algorithm state that consider a string in that take 2 distinct character and c1=a, c2=b, whenever any character occur in the string a or b increment c1 , c2 or we can say frequency of a and b. then take max of c1-c2 and store it as result.\\nNote- if c1 < c2 reset to c1=0, c2=0.\\n      if c1 == c2 reset to c1=0, c2=0.\\n      if c1 == character in string c1++.\\n      if c2 == character in string c2++.\\n      if c1>0 and c2>0 max(max_variance, c1-c2).\\n      variance is let say aabcba\\n      var is aabc = f(a)-f(c)=2-1=1  here f is freqency.\\n\\n# Complexity\\n- Time complexity:\\nO(26 * 26 * 2 * s)\\n\\n- Space complexity:\\nO(26)\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        int count1=0;\\n        int  count2=0;\\n        int max_variance=0;\\n        HashSet<Character> dist_char = new HashSet<>();\\n        for(char c : s.toCharArray()){\\n          dist_char.add(c);\\n        }\\n        for(int r=0;r<2;r++){\\n          for(char l1 : dist_char){\\n            for(char l2 : dist_char){\\n              if(l1==l2){\\n                continue;\\n              }\\n              count1=count2=0;\\n              for(char letter : s.toCharArray()){\\n                if(letter == l1){\\n                  count1++;\\n                }\\n                else if(letter == l2){\\n                  count2++;\\n                }\\n                if(count1 < count2){\\n                  count1=count2=0;\\n                }\\n                else if(count1>0 && count2>0){\\n                  max_variance=Math.max(max_variance, count1-count2);\\n                }\\n              }\\n            }\\n          }\\n          s = new StringBuilder(s).reverse().toString();\\n        }\\n        return max_variance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        int count1=0;\\n        int  count2=0;\\n        int max_variance=0;\\n        HashSet<Character> dist_char = new HashSet<>();\\n        for(char c : s.toCharArray()){\\n          dist_char.add(c);\\n        }\\n        for(int r=0;r<2;r++){\\n          for(char l1 : dist_char){\\n            for(char l2 : dist_char){\\n              if(l1==l2){\\n                continue;\\n              }\\n              count1=count2=0;\\n              for(char letter : s.toCharArray()){\\n                if(letter == l1){\\n                  count1++;\\n                }\\n                else if(letter == l2){\\n                  count2++;\\n                }\\n                if(count1 < count2){\\n                  count1=count2=0;\\n                }\\n                else if(count1>0 && count2>0){\\n                  max_variance=Math.max(max_variance, count1-count2);\\n                }\\n              }\\n            }\\n          }\\n          s = new StringBuilder(s).reverse().toString();\\n        }\\n        return max_variance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741732,
                "title": "c-super-easy-clean-code-beginner-friendly-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        \\n        bool freq[26] = {0};\\n        int n = s.size();\\n\\n        for(int i=0; i<n; i++){\\n            freq[s[i]-\\'a\\'] = 1;\\n        }\\n\\n        int maxi = 0;\\n\\n        for(char ch1=\\'a\\'; ch1<=\\'z\\'; ch1++){\\n            if(!freq[ch1-\\'a\\']) continue;\\n\\n            for(char ch2=\\'a\\'; ch2<=\\'z\\'; ch2++){\\n                if(ch1==ch2 || !freq[ch2-\\'a\\']) continue;\\n\\n                bool last = 0;\\n                int cnt1 = 0;\\n                int cnt2 = 0;\\n\\n                for(int i=0; i<n; i++){\\n                    cnt1 += ch1==s[i];\\n                    cnt2 += ch2==s[i];\\n\\n                    if(cnt2 > cnt1){\\n                        cnt1 = cnt2 = 0;\\n                        last = 1;\\n                    }\\n                    else if(cnt2 > 0){\\n                        maxi = max(maxi,cnt1-cnt2);\\n                    }\\n                    else if(last){\\n                        maxi = max(maxi,cnt1-last);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        \\n        bool freq[26] = {0};\\n        int n = s.size();\\n\\n        for(int i=0; i<n; i++){\\n            freq[s[i]-\\'a\\'] = 1;\\n        }\\n\\n        int maxi = 0;\\n\\n        for(char ch1=\\'a\\'; ch1<=\\'z\\'; ch1++){\\n            if(!freq[ch1-\\'a\\']) continue;\\n\\n            for(char ch2=\\'a\\'; ch2<=\\'z\\'; ch2++){\\n                if(ch1==ch2 || !freq[ch2-\\'a\\']) continue;\\n\\n                bool last = 0;\\n                int cnt1 = 0;\\n                int cnt2 = 0;\\n\\n                for(int i=0; i<n; i++){\\n                    cnt1 += ch1==s[i];\\n                    cnt2 += ch2==s[i];\\n\\n                    if(cnt2 > cnt1){\\n                        cnt1 = cnt2 = 0;\\n                        last = 1;\\n                    }\\n                    else if(cnt2 > 0){\\n                        maxi = max(maxi,cnt1-cnt2);\\n                    }\\n                    else if(last){\\n                        maxi = max(maxi,cnt1-last);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741652,
                "title": "c-dynamic-programming-kadane-algorithm",
                "content": "# Approach\\n\\nTo find the largest variance among all substrings, we need to consider all possible pairs of characters (c1, c2) where `c1 != c2`. For each pair, we will calculate the variance using the Kadane\\'s algorithm.\\n\\nThe Kadane\\'s algorithm is used to find the maximum subarray sum. In our case, we will modify it to find the maximum variance. We will iterate through the string character by character and update the count of characters a and b (c1 and c2). We will also keep track of the maximum variance encountered so far.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n`n` is the length of the input string `s`. The nested loops iterate through all possible pairs of characters in the lowercase English alphabet.\\n\\n- Space complexity: $$O(1)$$\\nbecause we are using a constant amount of extra space to store variables.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LargestVariance(string s) {\\n        int maxVariance = 0;\\n\\n        for (char c1 = \\'a\\'; c1 <= \\'z\\'; c1++) {\\n            for (char c2 = \\'a\\'; c2 <= \\'z\\'; c2++) {\\n                if (c1 != c2) {\\n                    int variance = Kadane(s, c1, c2);\\n                    maxVariance = Math.Max(maxVariance, variance);\\n                }\\n            }\\n        }\\n\\n        return maxVariance;\\n    }\\n\\n    private int Kadane(string s, char a, char b) {\\n        int ans = 0;\\n        int countA = 0;\\n        int countB = 0;\\n        bool canExtendPrevB = false;\\n\\n        foreach (char c in s) {\\n            if (c != a && c != b) {\\n                continue;\\n            }\\n            if (c == a) {\\n                countA += 1;\\n            } else {\\n                countB += 1;\\n            }\\n            if (countB > 0) {\\n                ans = Math.Max(ans, countA - countB);\\n            } else if (countB == 0 && canExtendPrevB) {\\n                ans = Math.Max(ans, countA - 1);\\n            }\\n            if (countB > countA) {\\n                countA = 0;\\n                countB = 0;\\n                canExtendPrevB = true;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int LargestVariance(string s) {\\n        int maxVariance = 0;\\n\\n        for (char c1 = \\'a\\'; c1 <= \\'z\\'; c1++) {\\n            for (char c2 = \\'a\\'; c2 <= \\'z\\'; c2++) {\\n                if (c1 != c2) {\\n                    int variance = Kadane(s, c1, c2);\\n                    maxVariance = Math.Max(maxVariance, variance);\\n                }\\n            }\\n        }\\n\\n        return maxVariance;\\n    }\\n\\n    private int Kadane(string s, char a, char b) {\\n        int ans = 0;\\n        int countA = 0;\\n        int countB = 0;\\n        bool canExtendPrevB = false;\\n\\n        foreach (char c in s) {\\n            if (c != a && c != b) {\\n                continue;\\n            }\\n            if (c == a) {\\n                countA += 1;\\n            } else {\\n                countB += 1;\\n            }\\n            if (countB > 0) {\\n                ans = Math.Max(ans, countA - countB);\\n            } else if (countB == 0 && canExtendPrevB) {\\n                ans = Math.Max(ans, countA - 1);\\n            }\\n            if (countB > countA) {\\n                countA = 0;\\n                countB = 0;\\n                canExtendPrevB = true;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741643,
                "title": "java-easy-understanding-kadane-s-algorithm",
                "content": "The problem becomes easy to reason, if we think that there are only 2 characters (let\\'s say a & b) in the given String. We\\'ll try to solve the problem, once assuming that maximum variance in a substring is when a > b and the other time we\\'ll assume it is b > a.\\nWe can maintain a max_count which gets updated everytime a max variance is found.\\nWe check for the maximum variance for each set of characters and update this global max_count.\\n\\n# Complexity\\n- Time complexity: O(26 * 26 * n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c : s.toCharArray())\\n        map.put(c, map.getOrDefault(c, 0) + 1);\\n        int max = 0;\\n        for(char c1 : map.keySet()) {\\n            for(char c2 : map.keySet()) {\\n                if(c1 == c2) continue;\\n                int c1Freq = 0, c2Freq = 0;\\n                int c1Remaining = map.get(c1);\\n                for(char c : s.toCharArray()) {\\n                    if(c == c1) {\\n                    c1Freq ++;\\n                    c1Remaining --;\\n                    }\\n                    if(c == c2) c2Freq ++;\\n\\n                    if(c2Freq < c1Freq && c1Remaining > 0) {\\n                        c2Freq = 0;\\n                        c1Freq = 0;\\n                    }\\n                   if(c1Freq > 0 && c2Freq > 0) \\n                   max = Math.max(max, c2Freq - c1Freq); \\n                }\\n            }\\n        }\\n        return max; \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c : s.toCharArray())\\n        map.put(c, map.getOrDefault(c, 0) + 1);\\n        int max = 0;\\n        for(char c1 : map.keySet()) {\\n            for(char c2 : map.keySet()) {\\n                if(c1 == c2) continue;\\n                int c1Freq = 0, c2Freq = 0;\\n                int c1Remaining = map.get(c1);\\n                for(char c : s.toCharArray()) {\\n                    if(c == c1) {\\n                    c1Freq ++;\\n                    c1Remaining --;\\n                    }\\n                    if(c == c2) c2Freq ++;\\n\\n                    if(c2Freq < c1Freq && c1Remaining > 0) {\\n                        c2Freq = 0;\\n                        c1Freq = 0;\\n                    }\\n                   if(c1Freq > 0 && c2Freq > 0) \\n                   max = Math.max(max, c2Freq - c1Freq); \\n                }\\n            }\\n        }\\n        return max; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741634,
                "title": "python-line-by-line-explanation-easy-to-understand",
                "content": "# Intuition\\n- We wil be using Kadane\\'s Algorithm with some modifications.\\n\\n- Although s may contain many different characters, we can focus on one pair of letters (major, minor) at a time and calculate the maximum difference between their occurrences by applying Kadane\\'s algorithm over all substrings of s that contain both major and minor.\\nIn other words, we assign the value of major as 1, the value of minor as -1, and the value of all other letters as 0, and use the standard Kadane\\'s algorithm to find the maximum subarray sum in the array representing s.\\n\\n- We notice that the standard Kadane\\'s algorithm has failed to solve the problem. This is because Kadane\\'s algorithm allows the subarray being considered to have no element with negative value. However, in our problem, a valid substring must contain at least one major and one minor, so the maximum variance calculated by regular Kadane\\'s algorithm does not necessarily represent a valid substring.\\nTherefore, we need to modify Kadane\\'s algorithm to solve this problem.\\n\\n- Update global_max only when minor_count > 0.\\n\\n- This ensures that we only consider valid substrings that contain at least one minor. As shown in the picture below, we cannot update global_max if minor_count = 0. However, after encountering at least one minor, we can update global_max as global_max = max(global_max, local_max) = 2.\\n\\n- In this problem, however, we cannot simply reset local_max to 0 whenever it becomes negative because doing so would reset both major_count and minor_count to 0. If there are no more minor in the remaining string, the minor_count will remain 0, and we will never be able to update global_max during the remaining traversal. To avoid this situation, we reset local_max to 0 only when there is at least one minor in the remaining s. To achieve this, we can use an additional variable rest_minor to keep track of the number of minor in the remaining string.\\n\\n- To sum up, we will identify every pair of different letters in the given string, treat one as a major letter and the other as a minor letter, and then apply the modified Kadane\\'s algorithm to traverse s. During the traversal, we need to keep track of the maximum variance between the occurrences of major and minor, which we call global_max. After traversing all the substrings for each pair of major and minor, we take the maximum value of global_max as the final result.\\n\\n# Approach\\n1. Initialize a counter to record the count of each distinct character in s. (Since we already know in advance that s contains only 26 different letters, we can use an array of length 26 as the counter)\\n\\n2. For each pair of distinct letters major and minor, we apply Kadane\\'s algorithm with modifications. All different pairs of distinct letters are considered, and two pairs of the same letters in different orders are considered to be different. In short, we will consider both (a, b) and (b, a).\\n\\n3. Set global_max, major_count and minor_count to 0, and let rest_minor be the number of character minor in the string.\\n\\n4. Traverse the string s, and for each letter ch:\\n\\n5. If ch is major, increment major_count by 1.\\nIf ch is minor, increment minor_count by 1 and decrement rest_minor by 1.\\nUpdate global_max only when minor_count > 0 (The first modification).\\n\\n6. If major_count - minor_count < 0, reset them to 0 only when rest_minor > 0 (The second modification).\\n\\n7. Move on to the next pair of letters (major, minor) and repeat from step 3.\\n\\n8. Return global_max when the iteration is complete.\\n\\n\\n# Complexity\\nLet n be the length of the input string s and kkk be the number of distinct characters in s.\\n\\n\\n- Time complexity:\\nO(n\\u22C5k^2)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def largestVariance(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        counter=[0]*26\\n        for ch in s:\\n            counter[ord(ch)-ord(\\'a\\')]+=1\\n        global_max=0\\n        for i in range(26):\\n            for j in range(26):\\n                if i==j or counter[i]==0 or counter[j]==0:\\n                    continue\\n                \\n                major= chr(ord(\\'a\\')+i)\\n                minor= chr(ord(\\'a\\')+j)\\n                majorCount=0\\n                minorCount=0\\n\\n                restMinor= counter[j]\\n\\n                for ch in s:\\n                    if ch==major:\\n                        majorCount+=1\\n\\n                    if ch==minor:\\n                        minorCount+=1\\n                        restMinor-=1\\n\\n                    if minorCount>0:\\n                        global_max=max(global_max, majorCount-minorCount)\\n                    \\n                    if majorCount<minorCount and restMinor>0:\\n                        majorCount=0\\n                        minorCount=0\\n\\n        return global_max\\n```\\n\\n**PLEASE UPVOTE**\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def largestVariance(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        counter=[0]*26\\n        for ch in s:\\n            counter[ord(ch)-ord(\\'a\\')]+=1\\n        global_max=0\\n        for i in range(26):\\n            for j in range(26):\\n                if i==j or counter[i]==0 or counter[j]==0:\\n                    continue\\n                \\n                major= chr(ord(\\'a\\')+i)\\n                minor= chr(ord(\\'a\\')+j)\\n                majorCount=0\\n                minorCount=0\\n\\n                restMinor= counter[j]\\n\\n                for ch in s:\\n                    if ch==major:\\n                        majorCount+=1\\n\\n                    if ch==minor:\\n                        minorCount+=1\\n                        restMinor-=1\\n\\n                    if minorCount>0:\\n                        global_max=max(global_max, majorCount-minorCount)\\n                    \\n                    if majorCount<minorCount and restMinor>0:\\n                        majorCount=0\\n                        minorCount=0\\n\\n        return global_max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741595,
                "title": "modified-kadane-s-with-greedy-optimization-commented-and-explained",
                "content": "# Intuition\\nThe following intuition lays out the process generally. If you want to attempt it on your own, or are doing this for class as extra credit, you should read ONLY the Intuition. It should be enough to cover your problem.\\n\\nRemember, extra credit is on the honor system somewhat, as I\\'m judging your code against any fundamental differences to mine. You should either try to improve it for extra credit, or show that you did implement it in a non-improved fashion for extra credit. Improvements are above and beyond, while non-improved fashion is meant to show honest work. You decide which matters more to you as part of the process.\\n\\nIt must also use the two stated ideas in the title, in this case Kadane\\'s Algorithm with a Greedy Optimization. \\n\\nTo review Kadane\\'s Algorithm, see [here](https://en.wikipedia.org/wiki/Maximum_subarray_problem). To review Greedy Optimizations, see [here](https://en.wikipedia.org/wiki/Greedy_algorithm)\\n\\nIn the general Kadane\\'s algorithm, we are comparing a global max with a local max based on a subarray of values. In this case, we are concerned with the letters in the alphabet that are present, and are interested in the substring formation. The first examples findings for the last substring are the most important. Notice that they use \\'babbb\\' with a variance of 3. This is a key idea, as it shows that we are truly only concerned with any two characters at a given time. \\n\\nFrom this, we can make our way to a modification by considering the two character limitation as a minor and major key. We can count the major key incidences, and compare it to the largest size IF we have encountered at least one minor key. \\n\\nThis gives way to some rather nice optimization ideas before we continue with the details. For the greedy approach, what early stopping condition could we preface ourself with? Remember, we are looking for a global maximum, where the number of major counts is greater than the number of minor counts at some point in the string. If doing this for class, answer the following question : \\n\\n> Since we are concerned with the global maximum of major count - minor count, and since each character has some frequency in the original string, how should we sort our major keys and our minor keys? What greedy advantage does this give us? \\n\\nContinuing our intution from there, we should note that there are instances where we would wish to reset our count of major and minor in our string. Our limiting factor in that case is the presence of the minor keys yet to be seen. If we have a string, and have not seen any minor keys, we cannot update the global max as we do not have a substring. Similarly, if we have a string, and have no remaining minor keys, we can already calculate the maximum left for the major key in the string, and should update accordingly. If doing this for class, answer the following question : \\n\\n> What is the update criterion look like when minor keys remaining is 0? How can we facilitate this using known data structures? \\n\\nThis is the end of the intuition, feel free to reach out if in class and want help on where to go from here. Otherwise, if you read the approach, you\\'re going to try for an improvement or your own implementation and comment on differences! \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nSet up a mapping for character frequency and indices of occurence in s \\nThen, \\n- For each index and value in s \\n    - update the frequency of this value\\n    - update the indices of this value to include this index \\n\\nGet the character keys as the characters that appear as keys in the mapping \\n\\nSet up your major and minor keys as this key list in a particular sorted order (check code if not in class to see what is meant, otherwise, this is part of your work!) \\n\\nSet global max to 0 \\n\\nThen, \\n- For major key in major keys \\n    - if char_frequency of major key - 1 lte global max \\n        - break as no others will be greater as well \\n    - for minor key in minor keys  \\n        - if minor key is major key -> continue \\n        - otherwise \\n            - set major and minor counts to 0 \\n            - set remaining major and minor counts as the frequency of each \\n            - get the indices of occurrence for each of your keys as the sorted indices of minor and major key \\n            - for index in total indices \\n                - if s[index] is major char \\n                    - major count += 1 \\n                    - remaining major -= 1 \\n                - otherwise \\n                    - as above for minor \\n                \\n                - global max is max of global max and major - minor count if minor count > 0 else global max \\n                \\n                - if major count lt minor count \\n                    - if remaining major - 1 lte global max -> break \\n                    - else if remaining minor > 0 \\n                        - major count = 0 \\n                        - minor count = 0 \\n                        - continue \\n                    - otherwise \\n                        - global max is max of global max and major count + remaining_major - minor count \\n                        - break \\n                - else, continue \\n\\nWhen loop completes, return global max \\n\\n# Complexity\\n- Time complexity : O(S + A log A + n * ( s log s + s\\' ))\\n    - O(S) to traverse the string once\\n    - O(A log A) to sort the keys  \\n    - O(mj) where mj is the subset of major keys such that a global max is established that lops off the remaining mj (note part about skipping out if char frequency of major key - 1 is lte global max at top of major char char loop) \\n        - within which we do O(MC), where MC is the minor char keys, for which we will consider them all \\n            - within which we need on average s log s time to sort their indices of occurrence \\n            - we then need s\\' to go over indices while valid \\n            - all steps inside here are O(1) so do not need to be counted \\n    - In total then O(S) + O(mj * MC * (s log s + s\\'))  \\n    - S can be of size up to 10**4 \\n    - mj and MC at max are 26 \\n    - so either O(S) or O(mj * MC * (s log s + s\\'))\\n    - if mj is 1/2 of MC, which holds for 137 of 138 test cases \\n        - and if MC at most 26 \\n        - then at most we get 338 * (s log s + s\\') \\n        - as s is potentially as much or more than mj or MC, we can treat those as the main components \\n        - so we get O(S + n * (s log s + s\\')) where n is the number of repetitions in total for the s log s sorting and s\\' is the time to completion of the sorted list, S is the total string length, and s is the size of the indices of the characters in the string on average as a pairing.     \\n\\n- Space complexity : O(A * s)\\n    - O(A) for the frequency of characters in S, where A is the size of the alphabet \\n    - O(A * s) where s is the size of the lists of the indices on average for each letter in the alphabet \\n    - All other space temporary assignment of size O(s) \\n\\n# Code\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int :\\n        # get each character frequency and indices \\n        char_frequency = collections.defaultdict(int)\\n        char_indices = collections.defaultdict(list)\\n        # get each index for each char as a list and track frequency \\n        for index, char in enumerate(s) : \\n            char_frequency[char] += 1 \\n            char_indices[char].append(index)\\n        # get the list of possible char keys \\n        char_keys = list(char_frequency.keys())\\n        # get the major and minor keys in order by their frequency, major sorted by highest frequency, minor by lowest \\n        char_keys_major = sorted(char_keys, key = lambda char_key : char_frequency[char_key], reverse=True)\\n        char_keys_minor = sorted(char_keys, key = lambda char_key : char_frequency[char_key])\\n        # track the global max \\n        global_max = 0 \\n        # use these to generate all pairings as major key in outerloop \\n        for major_char in char_keys_major : \\n            # skip useless major chars. Occurs greedily now. \\n            if char_frequency[major_char] - 1 <= global_max : \\n                break\\n            # minor key in inner loop \\n            for minor_char in char_keys_minor :\\n                # skip on matches  \\n                if major_char == minor_char : \\n                    continue \\n                else : \\n                    # otherwise, get counts \\n                    major_count = 0 \\n                    minor_count = 0 \\n                    # track remaining minor \\n                    remaining_minor = char_frequency[minor_char]\\n                    remaining_major = char_frequency[major_char]\\n                    # get indices list of char matches (reduces time and space complexity greatly)\\n                    total_indices = sorted([index_1 for index_1 in char_indices[major_char]] + [index_2 for index_2 in char_indices[minor_char]])\\n                    # for each index in total indices \\n                    for index in total_indices : \\n                        # if s[index] is major char, increment major count \\n                        if s[index] == major_char : \\n                            major_count += 1 \\n                            remaining_major -= 1 \\n                        else : \\n                            # otherwise, based on total indices, it must be minor char\\n                            # increment minor count and decrement remaining minor \\n                            minor_count += 1 \\n                            remaining_minor -= 1 \\n                        \\n                        # then if minor count is gt 0, update global max \\n                        global_max = max(global_max, major_count-minor_count) if minor_count > 0 else global_max\\n\\n                        # if major is lt minor count \\n                        if (major_count < minor_count) : \\n                            # if remaining major - 1 <= global max -> break \\n                            if remaining_major - 1 <= global_max : \\n                                break \\n                            elif remaining_minor > 0 : \\n                                # otherwise, if there\\'s still a shot -> reset \\n                                major_count = 0 \\n                                minor_count = 0 \\n                            else : \\n                                 # if major count lt minor count, but no remaining minor \\n                                # if remaining major + major count - minor count <= global max break \\n                                # otherwise, remaining major + major count - minor count gt global max \\n                                # update then break. Either way, break. Due to this, use global update instead \\n                                global_max = max(global_max, (major_count + remaining_major) - minor_count)\\n                                break\\n                        else : \\n                            continue \\n\\n        # return when done \\n        return global_max\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int :\\n        # get each character frequency and indices \\n        char_frequency = collections.defaultdict(int)\\n        char_indices = collections.defaultdict(list)\\n        # get each index for each char as a list and track frequency \\n        for index, char in enumerate(s) : \\n            char_frequency[char] += 1 \\n            char_indices[char].append(index)\\n        # get the list of possible char keys \\n        char_keys = list(char_frequency.keys())\\n        # get the major and minor keys in order by their frequency, major sorted by highest frequency, minor by lowest \\n        char_keys_major = sorted(char_keys, key = lambda char_key : char_frequency[char_key], reverse=True)\\n        char_keys_minor = sorted(char_keys, key = lambda char_key : char_frequency[char_key])\\n        # track the global max \\n        global_max = 0 \\n        # use these to generate all pairings as major key in outerloop \\n        for major_char in char_keys_major : \\n            # skip useless major chars. Occurs greedily now. \\n            if char_frequency[major_char] - 1 <= global_max : \\n                break\\n            # minor key in inner loop \\n            for minor_char in char_keys_minor :\\n                # skip on matches  \\n                if major_char == minor_char : \\n                    continue \\n                else : \\n                    # otherwise, get counts \\n                    major_count = 0 \\n                    minor_count = 0 \\n                    # track remaining minor \\n                    remaining_minor = char_frequency[minor_char]\\n                    remaining_major = char_frequency[major_char]\\n                    # get indices list of char matches (reduces time and space complexity greatly)\\n                    total_indices = sorted([index_1 for index_1 in char_indices[major_char]] + [index_2 for index_2 in char_indices[minor_char]])\\n                    # for each index in total indices \\n                    for index in total_indices : \\n                        # if s[index] is major char, increment major count \\n                        if s[index] == major_char : \\n                            major_count += 1 \\n                            remaining_major -= 1 \\n                        else : \\n                            # otherwise, based on total indices, it must be minor char\\n                            # increment minor count and decrement remaining minor \\n                            minor_count += 1 \\n                            remaining_minor -= 1 \\n                        \\n                        # then if minor count is gt 0, update global max \\n                        global_max = max(global_max, major_count-minor_count) if minor_count > 0 else global_max\\n\\n                        # if major is lt minor count \\n                        if (major_count < minor_count) : \\n                            # if remaining major - 1 <= global max -> break \\n                            if remaining_major - 1 <= global_max : \\n                                break \\n                            elif remaining_minor > 0 : \\n                                # otherwise, if there\\'s still a shot -> reset \\n                                major_count = 0 \\n                                minor_count = 0 \\n                            else : \\n                                 # if major count lt minor count, but no remaining minor \\n                                # if remaining major + major count - minor count <= global max break \\n                                # otherwise, remaining major + major count - minor count gt global max \\n                                # update then break. Either way, break. Due to this, use global update instead \\n                                global_max = max(global_max, (major_count + remaining_major) - minor_count)\\n                                break\\n                        else : \\n                            continue \\n\\n        # return when done \\n        return global_max\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741458,
                "title": "explaining-why-we-need-has-a-and-has-b",
                "content": "# Intuition\\n- Before the start of every index, we check whether we need to reset the accumulator (acc) zero. This mimics \\n    ```\\n    dp[i] = max(dp[i-1], 0) + nums[i];\\n    ```\\n    where `max(dp[i-1], 0)` is the reseting to zero before we add the current index.\\n- When are we allowed to reset to zero? Consider the following sequence\\n    ```\\n     b  a  a\\n     which corresponds to \\n    -1 +1 +1\\n    ```\\n    Ordinarily, we wanted to reset `acc` to zero before taking in the first `a`, because the current `acc = -1` is less than zero. However, since no `b` remains, we must not reset zero and discard the first`b`. Since we need both `a` and `b` to be in the sequence. \\n- Therefore, we can only reset to zero when `a_remain > 0 and b_remain > 0`, so that we can still find a sequence containing `a` and `b` in the future. \\n- Since resetting to zero means `has_a = 0` and `has_b = 0`, we can safely update the longest array when `has_a and has_b`. \\n\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n\\n- Space complexity: `O(n)`\\n\\n# Code C++ \\nHere, `i` means `a` and `j` means `b`.\\n```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int g_max = 0;\\n        unordered_map<char, int>mp;\\n        for(char c : s){\\n            mp[c] ++;\\n        }\\n        for(auto [i, i_cnt] : mp){\\n            for(auto [j, j_cnt] : mp){\\n                if(i == j) continue;\\n                int acc = 0;\\n                int i_remain = i_cnt;\\n                int j_remain = j_cnt;\\n                bool has_i = false;\\n                bool has_j = false;\\n                for(char c : s){\\n                    /* whether to reset to 0 before starting this index */\\n                    // must have i and j both present \\n                    if(acc < 0 && i_remain > 0 && j_remain > 0){\\n                        acc = 0;\\n                        has_i = false;\\n                        has_j = false;\\n                    }\\n\\n                    // insert i or j\\n                    if(c == i){\\n                        i_remain --; // decrease the remaining i\\n                        has_i = true;\\n                        acc ++;\\n                    }\\n                    else if(c == j){\\n                        j_remain --;\\n                        has_j = true;\\n                        acc --;\\n                    }\\n\\n                    // update max only if both are present\\n                    if(has_i && has_j){\\n                        g_max = max(acc, g_max);\\n                    }\\n                }\\n            }\\n        }\\n        return g_max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    dp[i] = max(dp[i-1], 0) + nums[i];\\n    ```\n```\\n     b  a  a\\n     which corresponds to \\n    -1 +1 +1\\n    ```\n```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int g_max = 0;\\n        unordered_map<char, int>mp;\\n        for(char c : s){\\n            mp[c] ++;\\n        }\\n        for(auto [i, i_cnt] : mp){\\n            for(auto [j, j_cnt] : mp){\\n                if(i == j) continue;\\n                int acc = 0;\\n                int i_remain = i_cnt;\\n                int j_remain = j_cnt;\\n                bool has_i = false;\\n                bool has_j = false;\\n                for(char c : s){\\n                    /* whether to reset to 0 before starting this index */\\n                    // must have i and j both present \\n                    if(acc < 0 && i_remain > 0 && j_remain > 0){\\n                        acc = 0;\\n                        has_i = false;\\n                        has_j = false;\\n                    }\\n\\n                    // insert i or j\\n                    if(c == i){\\n                        i_remain --; // decrease the remaining i\\n                        has_i = true;\\n                        acc ++;\\n                    }\\n                    else if(c == j){\\n                        j_remain --;\\n                        has_j = true;\\n                        acc --;\\n                    }\\n\\n                    // update max only if both are present\\n                    if(has_i && has_j){\\n                        g_max = max(acc, g_max);\\n                    }\\n                }\\n            }\\n        }\\n        return g_max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741283,
                "title": "c",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        vector<int> count(26, 0);\\n        int maxVariance = 0;\\n        \\n        for (char& ch : s) {\\n            count[ch - \\'a\\']++;\\n        }\\n        \\n        for (char first = \\'a\\'; first <= \\'z\\'; ++first) {\\n            for (char second = \\'a\\'; second <= \\'z\\'; ++second) {\\n                if (count[first - \\'a\\'] == 0 || count[second - \\'a\\'] == 0) {\\n                    continue;\\n                }\\n                \\n                int firstCount = 0;\\n                int secondCount = 0;\\n                bool pastLowFreq = false;\\n                \\n                for (const char& ch : s) {\\n                    if (ch == first) {\\n                        ++firstCount;\\n                    }\\n                    if (ch == second) {\\n                        ++secondCount;\\n                    }\\n                    \\n                    if (secondCount > 0) {\\n                        maxVariance = max(maxVariance, firstCount - secondCount);\\n                    } else {\\n                        if (pastLowFreq) {\\n                            maxVariance = max(maxVariance, firstCount - 1);\\n                        }\\n                    } \\n                    \\n                    if (secondCount > firstCount) {\\n                        secondCount = 0;\\n                        firstCount = 0;\\n                        pastLowFreq = true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return maxVariance;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        vector<int> count(26, 0);\\n        int maxVariance = 0;\\n        \\n        for (char& ch : s) {\\n            count[ch - \\'a\\']++;\\n        }\\n        \\n        for (char first = \\'a\\'; first <= \\'z\\'; ++first) {\\n            for (char second = \\'a\\'; second <= \\'z\\'; ++second) {\\n                if (count[first - \\'a\\'] == 0 || count[second - \\'a\\'] == 0) {\\n                    continue;\\n                }\\n                \\n                int firstCount = 0;\\n                int secondCount = 0;\\n                bool pastLowFreq = false;\\n                \\n                for (const char& ch : s) {\\n                    if (ch == first) {\\n                        ++firstCount;\\n                    }\\n                    if (ch == second) {\\n                        ++secondCount;\\n                    }\\n                    \\n                    if (secondCount > 0) {\\n                        maxVariance = max(maxVariance, firstCount - secondCount);\\n                    } else {\\n                        if (pastLowFreq) {\\n                            maxVariance = max(maxVariance, firstCount - 1);\\n                        }\\n                    } \\n                    \\n                    if (secondCount > firstCount) {\\n                        secondCount = 0;\\n                        firstCount = 0;\\n                        pastLowFreq = true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return maxVariance;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741154,
                "title": "step-by-step-explanation-java-c-python-simple-kadane-s-approach-to-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach (modified kadane\\u2019s algorithm)\\n1. Create a `StringBuilder` object, `sb`, initialized with the input string `s`.\\n2. Initialize a variable `ans` to 0 to store the largest variance between character frequencies.\\n3. Create a `HashMap<Character, Integer>` called `freq` to store the frequencies of characters. Initialize it by iterating over the characters of `s` and setting the initial frequency to 1 for each character.\\n4. Iterate over all possible pairs of characters, `ch1` and `ch2`, from \\'a\\' to \\'z\\'.\\n   - Skip the iteration if `ch1` and `ch2` are the same or if their frequencies in `freq` are null (i.e., the characters are not present in the string).\\n5. For each pair of characters, iterate twice (for `rev` equal to 1 and 2) to reverse the string and perform the following steps:\\n   - Initialize `count1` and `count2` to 0 to count the frequencies of `ch1` and `ch2`, respectively.\\n   - Iterate over the characters of the reversed string `sb.toString().toCharArray()`.\\n   - Increment `count1` if the character is equal to `ch1`, and increment `count2` if it is equal to `ch2`.\\n   - If `count1` becomes less than `count2`, reset both counts to 0.\\n   - If both `count1` and `count2` are greater than 0, update `ans` with the maximum variance between them.\\n   - Reverse the `StringBuilder` `sb` using the `reverse()` method.\\n6. Return the final value of `ans` as the largest variance between character frequencies..\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        StringBuilder sb=new StringBuilder(s);\\n        int ans=0;\\n        HashMap <Character,Integer> freq=new HashMap<>();\\n        for(char c: s.toCharArray()){\\n            freq.put(c,1);\\n        }\\n        for(char ch1=\\'a\\';ch1<=\\'z\\';ch1++){\\n            for(char ch2=\\'a\\';ch2<=\\'z\\';ch2++){\\n                if(ch1==ch2 || freq.get(ch1)==null ||freq.get(ch2)==null)\\n                    continue;\\n\\n            for(int rev=1;rev<=2;rev++){\\n                int count1=0;int count2=0;\\n                    for(char c: sb.toString().toCharArray()){\\n                        if(c==ch1){\\n                            count1++;\\n                        }else if(c==ch2){\\n                            count2++;\\n                        }\\n                        if(count1<count2){\\n                            count1=count2=0;\\n                        }\\n                        if(count1>0 && count2>0){\\n                            ans=Math.max(ans,count1-count2);\\n                        }\\n                    }\\n                    sb.reverse();\\n\\n            }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        StringBuilder sb=new StringBuilder(s);\\n        int ans=0;\\n        HashMap <Character,Integer> freq=new HashMap<>();\\n        for(char c: s.toCharArray()){\\n            freq.put(c,1);\\n        }\\n        for(char ch1=\\'a\\';ch1<=\\'z\\';ch1++){\\n            for(char ch2=\\'a\\';ch2<=\\'z\\';ch2++){\\n                if(ch1==ch2 || freq.get(ch1)==null ||freq.get(ch2)==null)\\n                    continue;\\n\\n            for(int rev=1;rev<=2;rev++){\\n                int count1=0;int count2=0;\\n                    for(char c: sb.toString().toCharArray()){\\n                        if(c==ch1){\\n                            count1++;\\n                        }else if(c==ch2){\\n                            count2++;\\n                        }\\n                        if(count1<count2){\\n                            count1=count2=0;\\n                        }\\n                        if(count1>0 && count2>0){\\n                            ans=Math.max(ans,count1-count2);\\n                        }\\n                    }\\n                    sb.reverse();\\n\\n            }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740914,
                "title": "python-solution-beats-99",
                "content": "# Intuition\\nThe main idea in this problem seems to be something a little bit like best subarray sums, except instead of having a singular array to explore, you must explore one with every combination of characters in the string.\\n\\n# Approach\\nThe idea is to test every combination of characters $a,b \\\\in s$ with $a \\\\neq b$. And test how many more times $a$ appears than $b$. We can do this efficiently using the *Kadane* algorithm.\\n\\nBecause it would be very wasteful for strings with many different characters to test every position in the array, we can use a trick and instead do something similar to a *natural merge*, where we store the occurrences in the string of every character and we can then check them in order.\\n\\nThe last challenge is to deal with cases where $a$ appears in the candidate substring but $b$ doesn\\'t. Since we know that $b \\\\in s$, we can *always* extend the substring to the nearest $b$, resulting in a substring with 1 less variance.\\n\\n# Complexity\\nWith $n = len(s)$ and $c =$ number of unique characters in $s$.\\nWe have some simple preprocessing which is $O(n)$\\nThe following feels like $O(nc^2)$, but because of the optimization where we don\\'t query 0s in the \"array\", we save on a lot of comparisons if we have many different characters.\\n\\nWe run the algorithm on every permutation $\\\\{a,b \\\\in s | a \\\\neq b\\\\}$, giving us $c^2$ executions.\\n\\nEach execution iterates over only the occurrences of $a$ and $b$ in $s$, which in average is ${2n}/{c}$.\\n\\nAfter simplifying, we get the final time complexity.\\n\\n- Time complexity:\\n$$O(nc)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        letters = set(s)\\n        occurrences = {c: [] for c in letters}\\n        for i, c in enumerate(s):\\n            occurrences[c].append(i)\\n        \\n        # Alias\\n        occ = occurrences\\n        \\n        best = 0\\n        for a in letters:\\n            for b in letters:\\n                if a == b: continue\\n                ptr_a = 0\\n                ptr_b = 0\\n                occ_a = occ[a]\\n                occ_b = occ[b]\\n                len_a = len(occ_a)\\n                len_b = len(occ_b)\\n                found_a = False\\n                found_b = False\\n\\n                best_sum = float(\\'-inf\\')\\n                max_curr = 0\\n                while ptr_a < len_a and ptr_b < len_b:\\n                    if occ_a[ptr_a] < occ_b[ptr_b]:\\n                        ptr_a += 1\\n                        max_curr += 1\\n                        if found_b: best_sum = max(max_curr, best_sum)\\n                        else: best_sum = max(max_curr - 1, best_sum)\\n                    else:\\n                        found_b = True\\n                        ptr_b += 1\\n                        max_curr -= 1\\n                        if max_curr < 0: \\n                            max_curr = 0\\n                            found_b = False\\n                \\n                max_curr += len_a - ptr_a\\n                best_sum = max(max_curr - (0 if found_b else 1), best_sum)\\n                print(f\"max variance between {a} and {b} is {best_sum}\")\\n                best = max(best_sum, best)\\n        return best\\n\\n\\n\\n\\n                \\n                \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        letters = set(s)\\n        occurrences = {c: [] for c in letters}\\n        for i, c in enumerate(s):\\n            occurrences[c].append(i)\\n        \\n        # Alias\\n        occ = occurrences\\n        \\n        best = 0\\n        for a in letters:\\n            for b in letters:\\n                if a == b: continue\\n                ptr_a = 0\\n                ptr_b = 0\\n                occ_a = occ[a]\\n                occ_b = occ[b]\\n                len_a = len(occ_a)\\n                len_b = len(occ_b)\\n                found_a = False\\n                found_b = False\\n\\n                best_sum = float(\\'-inf\\')\\n                max_curr = 0\\n                while ptr_a < len_a and ptr_b < len_b:\\n                    if occ_a[ptr_a] < occ_b[ptr_b]:\\n                        ptr_a += 1\\n                        max_curr += 1\\n                        if found_b: best_sum = max(max_curr, best_sum)\\n                        else: best_sum = max(max_curr - 1, best_sum)\\n                    else:\\n                        found_b = True\\n                        ptr_b += 1\\n                        max_curr -= 1\\n                        if max_curr < 0: \\n                            max_curr = 0\\n                            found_b = False\\n                \\n                max_curr += len_a - ptr_a\\n                best_sum = max(max_curr - (0 if found_b else 1), best_sum)\\n                print(f\"max variance between {a} and {b} is {best_sum}\")\\n                best = max(best_sum, best)\\n        return best\\n\\n\\n\\n\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740688,
                "title": "take-two-chars-at-a-time-and-get-max-diff-of-the-frequencies",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        vector<int> freq(26,0);\\n        int res = 0;\\n        int n  = s.length();\\n        \\n        for(auto i : s)\\n        {\\n            freq[i-\\'a\\']++;\\n        }\\n        \\n        for(char c1=\\'a\\';c1<=\\'z\\';c1++)\\n        {\\n            for(char c2=\\'a\\';c2<=\\'z\\';c2++)\\n            {\\n                if(c1==c2 || !freq[c1-\\'a\\'] || !freq[c2-\\'a\\'])\\n                    continue;\\n                \\n                for(int tt = 0;tt<2;tt++){\\n                    int ff = 0;\\n                    int ss = 0;\\n                    for(int i=0;i<n;i++)\\n                    {\\n                        ff += (s[i] == c1);\\n                        ss += (s[i] == c2);\\n                        if(ss>ff)\\n                        {\\n                            ff=0;\\n                            ss=0;\\n                        }\\n\\n                        if(ss>0 && ff>0)\\n                        {\\n                            res = max(res, ff-ss);\\n                        }\\n                    }\\n                    reverse(s.begin(),s.end());\\n                }\\n            }   \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        vector<int> freq(26,0);\\n        int res = 0;\\n        int n  = s.length();\\n        \\n        for(auto i : s)\\n        {\\n            freq[i-\\'a\\']++;\\n        }\\n        \\n        for(char c1=\\'a\\';c1<=\\'z\\';c1++)\\n        {\\n            for(char c2=\\'a\\';c2<=\\'z\\';c2++)\\n            {\\n                if(c1==c2 || !freq[c1-\\'a\\'] || !freq[c2-\\'a\\'])\\n                    continue;\\n                \\n                for(int tt = 0;tt<2;tt++){\\n                    int ff = 0;\\n                    int ss = 0;\\n                    for(int i=0;i<n;i++)\\n                    {\\n                        ff += (s[i] == c1);\\n                        ss += (s[i] == c2);\\n                        if(ss>ff)\\n                        {\\n                            ff=0;\\n                            ss=0;\\n                        }\\n\\n                        if(ss>0 && ff>0)\\n                        {\\n                            res = max(res, ff-ss);\\n                        }\\n                    }\\n                    reverse(s.begin(),s.end());\\n                }\\n            }   \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740687,
                "title": "beats-100-java-solution-dynamic-programming-o-n-2",
                "content": "# Upvote Me Please \\uD83D\\uDE4F\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        int output = 0;\\n        int[][] dif = new int[26][26];\\n        int[][] difB = new int [26][26];\\n        for(int i = 0; i < 26; i++){\\n            Arrays.fill(difB[i], -s.length());\\n        }\\n\\n        for(int j = 0; j < s.length(); j++){\\n            int ch = s.charAt(j) - \\'a\\';\\n            for(int k = 0; k < 26; k++){\\n                if(k == ch) continue;\\n                ++dif[ch][k];\\n                ++difB[ch][k];\\n                difB[k][ch] = --dif[k][ch];\\n                dif[k][ch] = Math.max(dif[k][ch], 0);\\n                output = Math.max(output, Math.max(difB[ch][k], difB[k][ch]));\\n\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        int output = 0;\\n        int[][] dif = new int[26][26];\\n        int[][] difB = new int [26][26];\\n        for(int i = 0; i < 26; i++){\\n            Arrays.fill(difB[i], -s.length());\\n        }\\n\\n        for(int j = 0; j < s.length(); j++){\\n            int ch = s.charAt(j) - \\'a\\';\\n            for(int k = 0; k < 26; k++){\\n                if(k == ch) continue;\\n                ++dif[ch][k];\\n                ++difB[ch][k];\\n                difB[k][ch] = --dif[k][ch];\\n                dif[k][ch] = Math.max(dif[k][ch], 0);\\n                output = Math.max(output, Math.max(difB[ch][k], difB[k][ch]));\\n\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740570,
                "title": "looking-for-an-easiest-video-explanation-see-this-codestorywithmik",
                "content": "My YouTube Video Link - [Substring With Largest Variance](https://www.youtube.com/watch?v=M428--94ny0)\\nMy Github Treasure - [Substring With Largest Variance](https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/strings/Substring%20With%20Largest%20Variance.cpp)\\n\\n```\\n//Approach-1 (Brute Force)\\n/*\\n  Find all substrings\\n  Find max freq and min freq of chars\\n  result = max(result, max_freq - min_freq)\\n*/\\n```\\n\\n```\\n//Approach-2 (26*26*n)\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        vector<int> count(26, 0);\\n        \\n        for(char &ch : s) {\\n            count[ch-\\'a\\']++;\\n        }\\n        \\n        int result = 0;\\n\\n        for (char first = \\'a\\'; first <= \\'z\\'; ++first) {\\n\\n            for (char second = \\'a\\'; second <= \\'z\\'; ++second) {\\n\\n                if (count[first-\\'a\\'] == 0 || count[second-\\'a\\'] == 0) \\n                    continue;\\n\\n                int firstCount = 0;\\n                int secondCount = 0;\\n                bool pastLowFreq = false;\\n\\n                for (const char& ch : s) {\\n                    if (ch == first) ++firstCount;\\n                    if (ch == second) ++secondCount;\\n\\n                    if (secondCount > 0) {\\n                        result = max(result, firstCount - secondCount);\\n                    } else {\\n                        if (pastLowFreq) {\\n                            result = max(result, firstCount - 1);\\n                        }\\n                    } \\n\\n                    if (secondCount > firstCount) {\\n                        secondCount = 0;\\n                        firstCount = 0;\\n                        pastLowFreq = true;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Brute Force)\\n/*\\n  Find all substrings\\n  Find max freq and min freq of chars\\n  result = max(result, max_freq - min_freq)\\n*/\\n```\n```\\n//Approach-2 (26*26*n)\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        vector<int> count(26, 0);\\n        \\n        for(char &ch : s) {\\n            count[ch-\\'a\\']++;\\n        }\\n        \\n        int result = 0;\\n\\n        for (char first = \\'a\\'; first <= \\'z\\'; ++first) {\\n\\n            for (char second = \\'a\\'; second <= \\'z\\'; ++second) {\\n\\n                if (count[first-\\'a\\'] == 0 || count[second-\\'a\\'] == 0) \\n                    continue;\\n\\n                int firstCount = 0;\\n                int secondCount = 0;\\n                bool pastLowFreq = false;\\n\\n                for (const char& ch : s) {\\n                    if (ch == first) ++firstCount;\\n                    if (ch == second) ++secondCount;\\n\\n                    if (secondCount > 0) {\\n                        result = max(result, firstCount - secondCount);\\n                    } else {\\n                        if (pastLowFreq) {\\n                            result = max(result, firstCount - 1);\\n                        }\\n                    } \\n\\n                    if (secondCount > firstCount) {\\n                        secondCount = 0;\\n                        firstCount = 0;\\n                        pastLowFreq = true;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740540,
                "title": "variant-of-kadane-s-algorithm-c",
                "content": "```\\nclass Solution {\\n    int kadane(string s, char a, char b) {\\n        int ans = 0, cnt = 0, f= 0;\\n        for(char c : s) {\\n            if(c == a) cnt++;\\n            else if(c == b) cnt--, f = 1;\\n\\n            if(cnt < 0) cnt = f = 0;\\n\\n            if(f) ans = max(ans, cnt);\\n            else ans = max(ans, cnt - 1); \\n        }\\n        return ans;\\n    }\\npublic:\\n    int largestVariance(string s) {\\n        int ans = 0;\\n        unordered_set<char> seen;\\n        for(char c : s) seen.insert(c);\\n        \\n        for(char a=\\'a\\'; a<=\\'z\\'; a++) {\\n            if(seen.find(a) == seen.end()) continue;\\n\\n            for(char b=\\'a\\'; b<=\\'z\\'; b++) {\\n                if(a == b || seen.find(b) == seen.end()) continue;\\n                ans = max({ans, kadane(s, a, b), kadane(s, b, a)});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int kadane(string s, char a, char b) {\\n        int ans = 0, cnt = 0, f= 0;\\n        for(char c : s) {\\n            if(c == a) cnt++;\\n            else if(c == b) cnt--, f = 1;\\n\\n            if(cnt < 0) cnt = f = 0;\\n\\n            if(f) ans = max(ans, cnt);\\n            else ans = max(ans, cnt - 1); \\n        }\\n        return ans;\\n    }\\npublic:\\n    int largestVariance(string s) {\\n        int ans = 0;\\n        unordered_set<char> seen;\\n        for(char c : s) seen.insert(c);\\n        \\n        for(char a=\\'a\\'; a<=\\'z\\'; a++) {\\n            if(seen.find(a) == seen.end()) continue;\\n\\n            for(char b=\\'a\\'; b<=\\'z\\'; b++) {\\n                if(a == b || seen.find(b) == seen.end()) continue;\\n                ans = max({ans, kadane(s, a, b), kadane(s, b, a)});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740037,
                "title": "2272-substring-with-largest-variance-java",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int largestVariance(String s) {\\n    int ans = 0;\\n\\n    for (char c1 = \\'a\\'; c1 <= \\'z\\'; ++c1)\\n      for (char c2 = \\'a\\'; c2 <= \\'z\\'; ++c2)\\n        if (c1 != c2)\\n          ans = Math.max(ans, kadane(s, c1, c2));\\n\\n    return ans;\\n  }\\n  private int kadane(final String s, char a, char b) {\\n    int ans = 0;\\n    int countA = 0;\\n    int countB = 0;\\n    boolean canExtendPrevB = false;\\n\\n    for (final char c : s.toCharArray()) {\\n      if (c != a && c != b)\\n        continue;\\n      if (c == a)\\n        ++countA;\\n      else\\n        ++countB;\\n      if (countB > 0) {\\n        ans = Math.max(ans, countA - countB);\\n      } else if (countB == 0 && canExtendPrevB) {\\n        ans = Math.max(ans, countA - 1);\\n      }\\n      if (countB > countA) {\\n        countA = 0;\\n        countB = 0;\\n        canExtendPrevB = true;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n  public int largestVariance(String s) {\\n    int ans = 0;\\n\\n    for (char c1 = \\'a\\'; c1 <= \\'z\\'; ++c1)\\n      for (char c2 = \\'a\\'; c2 <= \\'z\\'; ++c2)\\n        if (c1 != c2)\\n          ans = Math.max(ans, kadane(s, c1, c2));\\n\\n    return ans;\\n  }\\n  private int kadane(final String s, char a, char b) {\\n    int ans = 0;\\n    int countA = 0;\\n    int countB = 0;\\n    boolean canExtendPrevB = false;\\n\\n    for (final char c : s.toCharArray()) {\\n      if (c != a && c != b)\\n        continue;\\n      if (c == a)\\n        ++countA;\\n      else\\n        ++countB;\\n      if (countB > 0) {\\n        ans = Math.max(ans, countA - countB);\\n      } else if (countB == 0 && canExtendPrevB) {\\n        ans = Math.max(ans, countA - 1);\\n      }\\n      if (countB > countA) {\\n        countA = 0;\\n        countB = 0;\\n        canExtendPrevB = true;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739940,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) \\n    {\\n        int n = s.size();\\n        int res = 0;\\n        for (char p = \\'a\\'; p <= \\'z\\'; p++) {\\n            for (char q = \\'a\\'; q <= \\'z\\'; q++) {\\n                if (p == q) continue;\\n                int pCount = 0;\\n                int qCount = 0;\\n                bool canExtendprevQ = false;\\n                \\n                for (auto c : s) \\n                {\\n                    if (c == p) pCount++;\\n                    if (c == q) qCount++;\\n                    if (qCount > 0) \\n                    {\\n                        res = max(res, pCount - qCount);\\n                    }\\n                    else if (qCount == 0 && canExtendprevQ) \\n                    {\\n                        res = max(res, pCount - 1);\\n                    }\\n                    if (qCount > pCount) {\\n                        qCount = pCount = 0;\\n                        canExtendprevQ = true;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) \\n    {\\n        int n = s.size();\\n        int res = 0;\\n        for (char p = \\'a\\'; p <= \\'z\\'; p++) {\\n            for (char q = \\'a\\'; q <= \\'z\\'; q++) {\\n                if (p == q) continue;\\n                int pCount = 0;\\n                int qCount = 0;\\n                bool canExtendprevQ = false;\\n                \\n                for (auto c : s) \\n                {\\n                    if (c == p) pCount++;\\n                    if (c == q) qCount++;\\n                    if (qCount > 0) \\n                    {\\n                        res = max(res, pCount - qCount);\\n                    }\\n                    else if (qCount == 0 && canExtendprevQ) \\n                    {\\n                        res = max(res, pCount - 1);\\n                    }\\n                    if (qCount > pCount) {\\n                        qCount = pCount = 0;\\n                        canExtendprevQ = true;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739844,
                "title": "java-beginner-friendly-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe program aims to find the maximum variance of a substring in a given string. Variance is defined as the difference in the occurrence of any two characters in a substring.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach 1:\\n- Initialize a variable answer to store the maximum variance found so far. Set it to 0 initially.\\n- Iterate over the string s using a loop variable i to mark the starting index of the substring.\\n- Within the outer loop, use another loop variable j to mark the ending index of the substring.\\n- For each substring s.substring(i, j+1), create a Map called map to store the count of each character in the substring.\\n- Iterate over each character c in the substring by converting it to a character array using toCharArray().\\n- Update the count of character c in the map by using map.put(c, map.getOrDefault(c, 0) + 1). If the character is not present in the map, its count is initialized to 0 and then incremented by 1.\\n- Initialize a variable count to store the maximum difference in occurrence of any two characters in the current substring. Set it to 0 initially.\\n- Iterate over each character key in the map.keySet() to compare it with every other character key2 in the map.keySet().\\nCalculate the difference in occurrence between key and key2 using Math.abs(map.get(key) - map.get(key2)).\\n- Update the value of count by taking the maximum between its current value and the calculated difference using count = Math.max(count, diff).\\n- After the inner loop finishes, update the value of answer by taking the maximum between its current value and count using answer = Math.max(answer, count).\\n- Repeat steps 2-11 for all possible substrings of the given string s.\\n- Finally, return the value of answer, which represents the maximum variance found among all substrings in the input string s.\\n\\nApproach 2:\\n\\n1. Initialize three variables: temp1, temp2, and answer to store temporary counts and the maximum variance found so far. Set them to 0 initially.\\n1. Create a Set<Character> called set to store the unique characters present in the string s.\\n1. Iterate over each character c in the string s using a for-each loop. Add each character to the set using set.add(c) to ensure only unique characters are stored.\\n1. Use a nested loop with variable k to repeat the following steps twice:\\na. Iterate over each character a in the set using a for-each loop.\\nb. Iterate over each character b in the set using another for-each loop.\\nc. Check if a and b are the same character. If they are the same, skip the current iteration using the continue statement.\\nd. Reset temp1 and temp2 to 0 before processing a new pair of characters.\\ne. Iterate over each character i in the string s using a for-each loop.\\nIf i is equal to a, increment temp1 by 1.\\nIf i is equal to b, increment temp2 by 1.\\nCheck if temp1 is less than temp2. If so, reset both temp1 and temp2 to 0, as it means the current substring does not contribute to the maximum variance.\\nOtherwise, check if both temp1 and temp2 are greater than 0. If true, calculate the variance by subtracting temp2 from temp1, and update the answer variable with the maximum variance found so far using answer = Math.max(answer, temp1 - temp2).\\n1. Reverse the string s using new StringBuilder(s).reverse().toString() to process the reverse substrings in the next iteration.\\n1. Repeat steps 4-5 for the reversed string.\\n1. Return the value of answer, which represents the maximum variance found among all substrings in the input string s.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n^3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code - 1 (suffers TLE)\\n```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        int answer = 0;\\n        for(int i=0;i<s.length();i++){\\n            for(int j=i;j<s.length();j++){\\n                Map<Character, Integer> map = new HashMap<>();\\n                for(char c: s.substring(i,j+1).toCharArray()){\\n                    map.put(c, map.getOrDefault(c, 0)+1);\\n                }\\n                int count = 0;\\n                for(char key: map.keySet()){\\n                    for(char key2: map.keySet()){\\n                        int diff = Math.abs(map.get(key)-map.get(key2));\\n                        count = Math.max(count , diff);\\n                    }\\n                }\\n                answer = Math.max(answer , count);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\n# Code - 2\\n```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        int temp1 = 0, temp2 = 0, answer = 0;\\n        Set<Character> set = new HashSet<>();\\n        for(char c: s.toCharArray()){\\n            set.add(c);\\n        }\\n        for(int k = 0;k<2;k++){\\n            for(char a: set){\\n                for(char b: set){\\n                    if(a==b){\\n                        continue;\\n                    }\\n                    temp1 = temp2 = 0;\\n                    for(char i: s.toCharArray()){\\n                        if(i==a){\\n                            temp1++;\\n                        }else if(i==b){\\n                            temp2++;\\n                        }\\n                        if(temp1<temp2){\\n                            temp1 = temp2 = 0;\\n                        }\\n                        else if(temp1>0 && temp2>0){\\n                            answer = Math.max(answer, temp1- temp2);\\n                        }\\n                    }\\n                }\\n            }\\n            s = new StringBuilder(s).reverse().toString();\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        int answer = 0;\\n        for(int i=0;i<s.length();i++){\\n            for(int j=i;j<s.length();j++){\\n                Map<Character, Integer> map = new HashMap<>();\\n                for(char c: s.substring(i,j+1).toCharArray()){\\n                    map.put(c, map.getOrDefault(c, 0)+1);\\n                }\\n                int count = 0;\\n                for(char key: map.keySet()){\\n                    for(char key2: map.keySet()){\\n                        int diff = Math.abs(map.get(key)-map.get(key2));\\n                        count = Math.max(count , diff);\\n                    }\\n                }\\n                answer = Math.max(answer , count);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        int temp1 = 0, temp2 = 0, answer = 0;\\n        Set<Character> set = new HashSet<>();\\n        for(char c: s.toCharArray()){\\n            set.add(c);\\n        }\\n        for(int k = 0;k<2;k++){\\n            for(char a: set){\\n                for(char b: set){\\n                    if(a==b){\\n                        continue;\\n                    }\\n                    temp1 = temp2 = 0;\\n                    for(char i: s.toCharArray()){\\n                        if(i==a){\\n                            temp1++;\\n                        }else if(i==b){\\n                            temp2++;\\n                        }\\n                        if(temp1<temp2){\\n                            temp1 = temp2 = 0;\\n                        }\\n                        else if(temp1>0 && temp2>0){\\n                            answer = Math.max(answer, temp1- temp2);\\n                        }\\n                    }\\n                }\\n            }\\n            s = new StringBuilder(s).reverse().toString();\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739827,
                "title": "dart-kadane-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\cdot k^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int largestVariance(String s) {\\n    final counter = List<int>.filled(26, 0);\\n    for (final codeUnit in s.codeUnits) {\\n      counter[codeUnit - 97]++;\\n    }\\n    int globalMax = 0;\\n    for (int i = 0; i < 26; i++) {\\n      for (int j = 0; j < 26; j++) {\\n        if (i == j || counter[i] == 0 || counter[j] == 0) continue;\\n        int major = 97 + i, minor = 97 + j, majorCount = 0, minorCount = 0;\\n        int restMinor = counter[j];\\n        for (final codeUnit in s.codeUnits) {\\n          if (codeUnit == major) {\\n            majorCount++;\\n          }\\n          if (codeUnit == minor) {\\n            minorCount++;\\n            restMinor--;\\n          }\\n\\n          if (minorCount > 0) {\\n            globalMax = max(globalMax, majorCount - minorCount);\\n          }\\n          if (majorCount < minorCount && restMinor > 0) {\\n            majorCount = 0;\\n            minorCount = 0;\\n          }\\n        }\\n      }\\n    }\\n    return globalMax;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int largestVariance(String s) {\\n    final counter = List<int>.filled(26, 0);\\n    for (final codeUnit in s.codeUnits) {\\n      counter[codeUnit - 97]++;\\n    }\\n    int globalMax = 0;\\n    for (int i = 0; i < 26; i++) {\\n      for (int j = 0; j < 26; j++) {\\n        if (i == j || counter[i] == 0 || counter[j] == 0) continue;\\n        int major = 97 + i, minor = 97 + j, majorCount = 0, minorCount = 0;\\n        int restMinor = counter[j];\\n        for (final codeUnit in s.codeUnits) {\\n          if (codeUnit == major) {\\n            majorCount++;\\n          }\\n          if (codeUnit == minor) {\\n            minorCount++;\\n            restMinor--;\\n          }\\n\\n          if (minorCount > 0) {\\n            globalMax = max(globalMax, majorCount - minorCount);\\n          }\\n          if (majorCount < minorCount && restMinor > 0) {\\n            majorCount = 0;\\n            minorCount = 0;\\n          }\\n        }\\n      }\\n    }\\n    return globalMax;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739542,
                "title": "kotlin-try-all-pairs",
                "content": "![image.png](https://assets.leetcode.com/users/images/c0c1f372-45e0-4a71-a86b-cc062582f0e9_1688881095.5316043.png)\\n\\n#### Join me on Telegram\\nhttps://t.me/leetcode_daily_unstoppable/270\\n#### Problem TLDR\\nMax diff between count `s[i]` and count `s[j]` in all substrings of `s`\\n#### Intuition\\nThe first idea is to simplify the task by considering only two chars, iterating over all alphabet combinations.\\nSecond idea is how to solve this problem for binary string in $$O(n)$$: `abaabbb` \\u2192 `abbb`. \\nWe split this problem: find the largest subarray for `a` with the smallest count of `b`, and reverse the problem \\u2013 largest `b` with smallest `a`.\\nFor this issue, there is a Kadane\\'s algorithm for maximizing `sum`: take values greedily and reset count when `sum < 0`.\\nImportant customization is to always consider `countB` at least `1` as it must be present in a subarray.\\n\\n#### Approach\\n* we can use `Set` of only the chars in `s`\\n* iterate in `ab` and `ba` pairs\\n* Kotlin API helps save some LOC\\n#### Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity:\\n$$O(n)$$, or O(1) if `asSequence` used\\n#### Code\\n```\\n\\n    fun largestVariance(s: String): Int = s.toSet()\\n       .let { ss -> ss.map { a -> ss.filter { it != a }.map { a to it } }.flatten() }\\n       .map { (a, b) -> \\n          var countA = 0\\n          var countB = 0\\n          s.filter { it == a || it == b }\\n          .map { c ->\\n            if (c == a) countA++ else countB++\\n            if (countA < countB) {\\n              countA = 0\\n              countB = 0\\n            }\\n            countA - maxOf(1, countB)\\n          }.max() ?: 0\\n       }.max() ?: 0\\n\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n\\n    fun largestVariance(s: String): Int = s.toSet()\\n       .let { ss -> ss.map { a -> ss.filter { it != a }.map { a to it } }.flatten() }\\n       .map { (a, b) -> \\n          var countA = 0\\n          var countB = 0\\n          s.filter { it == a || it == b }\\n          .map { c ->\\n            if (c == a) countA++ else countB++\\n            if (countA < countB) {\\n              countA = 0\\n              countB = 0\\n            }\\n            countA - maxOf(1, countB)\\n          }.max() ?: 0\\n       }.max() ?: 0\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3739502,
                "title": "explained-brute-force-with-sliding-window-for-beginners",
                "content": "# Intuition\\nWe have to find maximum difference between occurences of two characters.\\n\\n\\n# Approach\\nI used hints to solve the problem.\\nI have not used any external library so it must be easy to rewrite in any other language.\\nAs there are only 26 chars in alphabets therefore at max 325 combinations or 650 permutation can be there.\\n1).We first find all permutaions.\\n\\n2).Then for each combination treat one of char as +1 and other -1 and find maximum sum of subarray which include both .\\nIf our maximum sum doesnot have any -1 or second char then we subtract -1 from sum bcoz the second char will surely be on immediate left or right of our maximum sum subarray.\\nwe iterate through all permutations and find best result.\\n\\nInstead of Sliding Window you may be able to use Prefix sum.\\n\\n# Complexity\\n- Time complexity:\\n$$O(N^2)$$\\n\\nPlease corrent if wrong.\\n- Space complexity:\\n $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        res=0\\n        Combinations=[]\\n        Unique=[]\\n        for i in s:\\n            if i not in Unique:\\n                Unique.append(i)\\n        for i in range(len(Unique)):\\n            for j in range(i+1,len(Unique)):\\n                Combinations.append([Unique[i],Unique[j]])\\n                Combinations.append([Unique[j],Unique[i]])\\n        #Till now we have just found all the possible pair of two chars.\\n        for i in range(len(Combinations)):\\n            first=Combinations[i][0]\\n            second=Combinations[i][1]\\n            currSum=0\\n            ans=0\\n            start=0\\n            isSecond=0\\n            for j in range(len(s)):\\n                if s[j]!=first and s[j]!=second:\\n                    start+=1\\n                    continue\\n                if s[j]==first:\\n                    currSum+=1\\n                elif s[j]==second:\\n                    isSecond+=1\\n                    currSum-=1\\n                if currSum>ans and isSecond>0:\\n                    ans=max(currSum,ans)\\n                else:\\n                    ans=max(currSum-1,ans)\\n                while currSum<0 and start<=j:\\n                    if s[start]==first:\\n                        currSum-=1\\n                    elif s[start]==second:\\n                        currSum+=1\\n                        isSecond-=1\\n                    start+=1\\n            res=max(res,ans)\\n\\n        return res\\n```\\n\\nI would appreciate if you can comment a cleaner version of code.\\nThanks have an error free day.\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sliding Window",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        res=0\\n        Combinations=[]\\n        Unique=[]\\n        for i in s:\\n            if i not in Unique:\\n                Unique.append(i)\\n        for i in range(len(Unique)):\\n            for j in range(i+1,len(Unique)):\\n                Combinations.append([Unique[i],Unique[j]])\\n                Combinations.append([Unique[j],Unique[i]])\\n        #Till now we have just found all the possible pair of two chars.\\n        for i in range(len(Combinations)):\\n            first=Combinations[i][0]\\n            second=Combinations[i][1]\\n            currSum=0\\n            ans=0\\n            start=0\\n            isSecond=0\\n            for j in range(len(s)):\\n                if s[j]!=first and s[j]!=second:\\n                    start+=1\\n                    continue\\n                if s[j]==first:\\n                    currSum+=1\\n                elif s[j]==second:\\n                    isSecond+=1\\n                    currSum-=1\\n                if currSum>ans and isSecond>0:\\n                    ans=max(currSum,ans)\\n                else:\\n                    ans=max(currSum-1,ans)\\n                while currSum<0 and start<=j:\\n                    if s[start]==first:\\n                        currSum-=1\\n                    elif s[start]==second:\\n                        currSum+=1\\n                        isSecond-=1\\n                    start+=1\\n            res=max(res,ans)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739426,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        vector<int>freq(26,0);\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)freq[s[i]-\\'a\\']++;\\n        \\n        for(char ch1=\\'a\\';ch1<=\\'z\\';ch1++){\\n            for(char ch2=\\'a\\';ch2<=\\'z\\';ch2++){\\n                if(ch1==ch2 || !freq[ch1-\\'a\\'] || !freq[ch2-\\'a\\'])continue;\\n\\n                for(int i =1;i<=2;i++){\\n                    int ct1=0,ct2=0;\\n                    for(auto c:s){\\n                        ct1+= c==ch1;\\n                        ct2+= c==ch2;\\n\\n                        if(ct1<ct2)ct1=ct2=0;\\n\\n                        if(ct1>0 && ct2>0)ans=max(ans,ct1-ct2);\\n                    }\\n                    reverse(s.begin(),s.end());\\n                }\\n            }\\n        }\\nreturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        vector<int>freq(26,0);\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)freq[s[i]-\\'a\\']++;\\n        \\n        for(char ch1=\\'a\\';ch1<=\\'z\\';ch1++){\\n            for(char ch2=\\'a\\';ch2<=\\'z\\';ch2++){\\n                if(ch1==ch2 || !freq[ch1-\\'a\\'] || !freq[ch2-\\'a\\'])continue;\\n\\n                for(int i =1;i<=2;i++){\\n                    int ct1=0,ct2=0;\\n                    for(auto c:s){\\n                        ct1+= c==ch1;\\n                        ct2+= c==ch2;\\n\\n                        if(ct1<ct2)ct1=ct2=0;\\n\\n                        if(ct1>0 && ct2>0)ans=max(ans,ct1-ct2);\\n                    }\\n                    reverse(s.begin(),s.end());\\n                }\\n            }\\n        }\\nreturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739415,
                "title": "swift-solution",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    func largestVariance(_ s: String) -> Int {\\n        var freq = Array(repeating: 0, count: 26)\\n        for c in s {\\n            freq[Int(c.asciiValue! - Character(\"a\").asciiValue!)] += 1\\n        }\\n        \\n        var maxVariance = 0\\n        for a in 0..<26 {\\n            for b in 0..<26 {\\n                var remainingA = freq[a]\\n                var remainingB = freq[b]\\n                if a == b || remainingA == 0 || remainingB == 0 { continue }\\n                \\n                var currBFreq = 0, currAFreq = 0\\n                for c in s {\\n                    let c = Int(c.asciiValue! - Character(\"a\").asciiValue!)\\n                    \\n                    if c == b { currBFreq += 1 }\\n                    if c == a {\\n                        currAFreq += 1\\n                        remainingA -= 1\\n                    }\\n                    \\n                    if currAFreq > 0 {\\n                        maxVariance = max(maxVariance, currBFreq - currAFreq)\\n                    }\\n                    \\n                    if currBFreq < currAFreq && remainingA >= 1 {\\n                        currBFreq = 0\\n                        currAFreq = 0\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return maxVariance\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func largestVariance(_ s: String) -> Int {\\n        var freq = Array(repeating: 0, count: 26)\\n        for c in s {\\n            freq[Int(c.asciiValue! - Character(\"a\").asciiValue!)] += 1\\n        }\\n        \\n        var maxVariance = 0\\n        for a in 0..<26 {\\n            for b in 0..<26 {\\n                var remainingA = freq[a]\\n                var remainingB = freq[b]\\n                if a == b || remainingA == 0 || remainingB == 0 { continue }\\n                \\n                var currBFreq = 0, currAFreq = 0\\n                for c in s {\\n                    let c = Int(c.asciiValue! - Character(\"a\").asciiValue!)\\n                    \\n                    if c == b { currBFreq += 1 }\\n                    if c == a {\\n                        currAFreq += 1\\n                        remainingA -= 1\\n                    }\\n                    \\n                    if currAFreq > 0 {\\n                        maxVariance = max(maxVariance, currBFreq - currAFreq)\\n                    }\\n                    \\n                    if currBFreq < currAFreq && remainingA >= 1 {\\n                        currBFreq = 0\\n                        currAFreq = 0\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return maxVariance\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739375,
                "title": "c-easy-to-understand-2272-substring-with-largest-variance-optimal-solution",
                "content": "# C++ | Easy to Understand | 2272. Substring With Largest Variance | Optimal Solution\\n```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int n = s.size();\\n        int res = 0;\\n     \\n        for (char p = \\'a\\'; p <= \\'z\\'; p++) {\\n            for (char q = \\'a\\'; q <= \\'z\\'; q++) {\\n                if (p == q) continue;\\n         \\n                int pCount = 0; \\n                int qCount = 0; \\n                \\n                bool canExtendprevQ = false;\\n                \\n                for (auto c : s) {\\n                    if (c == p) pCount++;\\n                    if (c == q) qCount++;\\n                    \\n                    if (qCount > 0) {\\n                        res = max(res, pCount - qCount);\\n                    }\\n\\n                    else if (qCount == 0 && canExtendprevQ) {\\n                        res = max(res, pCount - 1);\\n                    }\\n                \\n                    if (qCount > pCount) {\\n                        qCount = pCount = 0;\\n                        \\n                        canExtendprevQ = true;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int n = s.size();\\n        int res = 0;\\n     \\n        for (char p = \\'a\\'; p <= \\'z\\'; p++) {\\n            for (char q = \\'a\\'; q <= \\'z\\'; q++) {\\n                if (p == q) continue;\\n         \\n                int pCount = 0; \\n                int qCount = 0; \\n                \\n                bool canExtendprevQ = false;\\n                \\n                for (auto c : s) {\\n                    if (c == p) pCount++;\\n                    if (c == q) qCount++;\\n                    \\n                    if (qCount > 0) {\\n                        res = max(res, pCount - qCount);\\n                    }\\n\\n                    else if (qCount == 0 && canExtendprevQ) {\\n                        res = max(res, pCount - 1);\\n                    }\\n                \\n                    if (qCount > pCount) {\\n                        qCount = pCount = 0;\\n                        \\n                        canExtendprevQ = true;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739262,
                "title": "dart-solution",
                "content": "# Code\\n```\\nimport \\'dart:math\\';\\n\\nconst MIN = -1 << 30, MAX = 1 << 30;\\nclass Solution {\\n  int largestVariance(String s) {\\n    final has = List.filled(26, false);\\n    for (int i = 0; i < s.length; i++) has[s[i].codeUnitAt(0) - \\'a\\'.codeUnitAt(0)] = true;\\n\\n    int helper(String A, String B) {\\n      int global_min = MAX, global_max = MIN;\\n      int prev_min_A = MAX, prev_max_A = MIN;\\n      int prev_min_B = MAX, prev_max_B = MIN;\\n      int res = 0, sum = 0;\\n      for (int i = 0; i < s.length; i++) {\\n        global_min = min(global_min, sum);\\n        global_max = max(global_max, sum);\\n        if (s[i] == A) {\\n          prev_min_A = min(prev_min_A, global_min);\\n          prev_max_A = max(prev_max_A, global_max);\\n\\n          sum++;\\n\\n          if (prev_min_B != MAX)\\n            res = max(res, (sum - prev_min_B).abs());\\n          if (prev_max_B != MIN)\\n            res = max(res, (sum - prev_max_B).abs());\\n        } else if (s[i] == B) {\\n          prev_min_B = min(prev_min_B, global_min);\\n          prev_max_B = max(prev_max_B, global_max);\\n\\n          sum--;\\n\\n          if (prev_min_A != MAX)\\n            res = max(res, (sum - prev_min_A).abs());\\n          if (prev_max_A != MIN)\\n            res = max(res, (sum - prev_max_A).abs());\\n        }\\n      }\\n      return res;\\n    }\\n\\n    var res = 0;\\n    for (int i = 0; i < 26; i++)\\n      for (int j = i + 1; j < 26; j++)\\n        if (has[i] && has[j])\\n          res = max(res, helper(\\n              String.fromCharCode(\\'a\\'.codeUnitAt(0) + i),\\n              String.fromCharCode(\\'a\\'.codeUnitAt(0) + j)));\\n    return res;\\n  }\\n\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nimport \\'dart:math\\';\\n\\nconst MIN = -1 << 30, MAX = 1 << 30;\\nclass Solution {\\n  int largestVariance(String s) {\\n    final has = List.filled(26, false);\\n    for (int i = 0; i < s.length; i++) has[s[i].codeUnitAt(0) - \\'a\\'.codeUnitAt(0)] = true;\\n\\n    int helper(String A, String B) {\\n      int global_min = MAX, global_max = MIN;\\n      int prev_min_A = MAX, prev_max_A = MIN;\\n      int prev_min_B = MAX, prev_max_B = MIN;\\n      int res = 0, sum = 0;\\n      for (int i = 0; i < s.length; i++) {\\n        global_min = min(global_min, sum);\\n        global_max = max(global_max, sum);\\n        if (s[i] == A) {\\n          prev_min_A = min(prev_min_A, global_min);\\n          prev_max_A = max(prev_max_A, global_max);\\n\\n          sum++;\\n\\n          if (prev_min_B != MAX)\\n            res = max(res, (sum - prev_min_B).abs());\\n          if (prev_max_B != MIN)\\n            res = max(res, (sum - prev_max_B).abs());\\n        } else if (s[i] == B) {\\n          prev_min_B = min(prev_min_B, global_min);\\n          prev_max_B = max(prev_max_B, global_max);\\n\\n          sum--;\\n\\n          if (prev_min_A != MAX)\\n            res = max(res, (sum - prev_min_A).abs());\\n          if (prev_max_A != MIN)\\n            res = max(res, (sum - prev_max_A).abs());\\n        }\\n      }\\n      return res;\\n    }\\n\\n    var res = 0;\\n    for (int i = 0; i < 26; i++)\\n      for (int j = i + 1; j < 26; j++)\\n        if (has[i] && has[j])\\n          res = max(res, helper(\\n              String.fromCharCode(\\'a\\'.codeUnitAt(0) + i),\\n              String.fromCharCode(\\'a\\'.codeUnitAt(0) + j)));\\n    return res;\\n  }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739161,
                "title": "python-kadane-s-algo-sparse-array-99",
                "content": "Verbose version to figure out what we\\'re doing with Kadane\\'s DP algo:\\n\\nBasically what we do here is:\\n1. Loop over all pairs of the alphabet chars (could be 26^2, but py is slow) (we need to find variance for **2 chars**)\\n2. For each pair of chars we do the following:\\n2.1. Replace all `a` with `1 ` and `b` with `-1` and find the prefix/running_sum. e.g. `abbb -> [1,-1,-1,-1]`\\n2.2. Replace all `b` with `1 ` and `a` with `-1` and find the prefix/running_sum. e.g. `abbb -> [-1,1,1,1]`\\n3. Find max variance with Kadane\\'s algo as in the `max subarray sum` problem:\\n\\nThe only constraint here is that we need to have at least one `a` and one `b` as variane for a sequence like `aaaa` equals `0`. We reset when the `prefix_sum < 0`, which means that there\\'s more `b` than `a`s  and there\\'s still a chance to find a new substring with other combination of `a` and `b`. \\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        freq = Counter(s)\\n        res = 0\\n        for a in freq.keys():\\n            for b in freq.keys():\\n                if a == b:\\n                    continue\\n                left_a = freq[a]\\n                left_b = freq[b]\\n                running_sum = 0\\n                has_a = has_b = False\\n                for c in s:\\n                    if c != a and c != b:\\n                        continue\\n                    if c == a:\\n                        running_sum += 1 # +1 for `a`. Next time for [b,a] it will be `-1` for `a`\\n                        left_a -= 1 # decrease remaining count of `a`s in string\\n                        has_a = True\\n                    else:\\n                        running_sum -= 1 # -1 for `b`. Next time for [b,a] it will be `-1` for `b`\\n                        left_b -= 1 # decrease remaining count of `b`s in string\\n                        has_b = True\\n\\t\\t\\t\\t\\t# abbb case: cannot reset after abb as we can build longer substring abbb\\n                    if running_sum < 0 and left_a > 0 and left_b > 0: # reset algo when there are left `a` and `b`\\n                        running_sum = 0\\n                        has_a = has_b = False\\n                    if has_a and has_b: # if the string has `a` and `b` chars. Or it\\'s variance = 0\\n                        res = max(res, running_sum)\\n        return res\\n```\\n\\nKadane\\'s algo DP optimized with `sparse array`. Faster than 99% for py3\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        char_pos = defaultdict(list)\\n        for i,c in enumerate(s):\\n            char_pos[c].append(i)\\n        res = 0\\n        for a in char_pos.keys():\\n            for b in char_pos.keys():\\n                if a == b:\\n                    continue\\n                A, B = len(char_pos[a]), len(char_pos[b])\\n                a_idx = b_idx = 0\\n                running_sum = 0\\n                has_a = has_b = False\\n                while a_idx < A or b_idx < B:\\n                    if a_idx < A and (b_idx == B or char_pos[a][a_idx] < char_pos[b][b_idx]):\\n                        running_sum += 1\\n                        has_a = True\\n                        a_idx += 1\\n                    elif b_idx < B:\\n                        running_sum -= 1\\n                        has_b = True\\n                        b_idx += 1\\n                    if running_sum < 0 and a_idx < A and b_idx < B:\\n                        running_sum = 0\\n                        has_a = has_b = False\\n                    if has_a and has_b:\\n                        res = max(res, running_sum)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        freq = Counter(s)\\n        res = 0\\n        for a in freq.keys():\\n            for b in freq.keys():\\n                if a == b:\\n                    continue\\n                left_a = freq[a]\\n                left_b = freq[b]\\n                running_sum = 0\\n                has_a = has_b = False\\n                for c in s:\\n                    if c != a and c != b:\\n                        continue\\n                    if c == a:\\n                        running_sum += 1 # +1 for `a`. Next time for [b,a] it will be `-1` for `a`\\n                        left_a -= 1 # decrease remaining count of `a`s in string\\n                        has_a = True\\n                    else:\\n                        running_sum -= 1 # -1 for `b`. Next time for [b,a] it will be `-1` for `b`\\n                        left_b -= 1 # decrease remaining count of `b`s in string\\n                        has_b = True\\n\\t\\t\\t\\t\\t# abbb case: cannot reset after abb as we can build longer substring abbb\\n                    if running_sum < 0 and left_a > 0 and left_b > 0: # reset algo when there are left `a` and `b`\\n                        running_sum = 0\\n                        has_a = has_b = False\\n                    if has_a and has_b: # if the string has `a` and `b` chars. Or it\\'s variance = 0\\n                        res = max(res, running_sum)\\n        return res\\n```\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        char_pos = defaultdict(list)\\n        for i,c in enumerate(s):\\n            char_pos[c].append(i)\\n        res = 0\\n        for a in char_pos.keys():\\n            for b in char_pos.keys():\\n                if a == b:\\n                    continue\\n                A, B = len(char_pos[a]), len(char_pos[b])\\n                a_idx = b_idx = 0\\n                running_sum = 0\\n                has_a = has_b = False\\n                while a_idx < A or b_idx < B:\\n                    if a_idx < A and (b_idx == B or char_pos[a][a_idx] < char_pos[b][b_idx]):\\n                        running_sum += 1\\n                        has_a = True\\n                        a_idx += 1\\n                    elif b_idx < B:\\n                        running_sum -= 1\\n                        has_b = True\\n                        b_idx += 1\\n                    if running_sum < 0 and a_idx < A and b_idx < B:\\n                        running_sum = 0\\n                        has_a = has_b = False\\n                    if has_a and has_b:\\n                        res = max(res, running_sum)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738787,
                "title": "typescript-solution-based-on-editorial",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Count the number of each character of `s`. \\n- Pick major and minor characters to calculate the variance by visiting `s`. \\n- Using **Kadane\\'s algorithm** so that we could visit `s` only one time for each major/minor pair. \\n- Since the subarray should contain both major and minor characters, if there is no major and minor characters left, we can not reset the array even local sum is negative. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Count the number of each character of `s`, and store the result into `charCount`. \\n- Select differnet characters `major` and `minor` from `charCount.keys()` and initial the counter `majorCount` and `minorCount` as `0`. \\n- Get the count of minor `restMinorCount = charCount.get(minor)`. \\n- Loop the `s` with element `char`. \\n    - Increase `majorCount` and decrease `restMajorCount` by 1 while `char===major`. \\n    - Increase `minorCount` and decrease `restMinorCount` by 1 while `char===minor`. \\n    - If both `restMajorCount` and `restMinorCount` are `0`, we can break the loop for current pair. \\n    - If the current subarray contains both `major` and `minor` (`majorCount>0 && minorCount>0`), update the result `res` with larger variance `majorCount-minorCount`. \\n    - If `majorCount < minorCount`, means our variance would be negative, we should reset the counter if `restMinorCount > 0 && restMajorCount > 0`. \\n\\n# Complexity\\nLet $$n$$ be the length of `s`, $$k$$ be the count of distinct characters of `s`. \\n- Time complexity: $$O(k^2 \\\\cdot n)$$\\n    - Make `charCount`: $$O(n)$$\\n    - Nesting loops of `major`, `minor` and `s`: $$O(k^2 \\\\cdot n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n    - `charCount`: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction largestVariance(s: string): number {\\n    const n = s.length;\\n    let res = 0;\\n    const charCount = new Map<string, number>();\\n\\n    for(const char of s){\\n        const count = charCount.get(char);\\n        if(count){\\n            charCount.set(char, count+1);\\n        }else{\\n            charCount.set(char, 1);\\n        }\\n    }\\n\\n    for(const major of charCount.keys()){\\n        for(const minor of charCount.keys()){\\n            if(major===minor){\\n                continue;\\n            }\\n            let majorCount = 0;\\n            let minorCount = 0;\\n            let restMajorCount = charCount.get(major) as number;\\n            let restMinorCount = charCount.get(minor) as number;\\n            for(const char of s){\\n                if(restMajorCount===0 && restMinorCount===0){\\n                    break;\\n                }\\n                if(char===major){\\n                    majorCount += 1;\\n                    restMajorCount -= 1;\\n                }\\n                if(char===minor){\\n                    minorCount += 1;\\n                    restMinorCount -= 1;\\n                }\\n\\n                if(majorCount>0 && minorCount>0){\\n                    res = Math.max(majorCount-minorCount, res);\\n                }\\n\\n                if(majorCount < minorCount && restMinorCount > 0 && restMajorCount > 0){\\n                    majorCount = 0;\\n                    minorCount = 0;\\n                }\\n            }\\n\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction largestVariance(s: string): number {\\n    const n = s.length;\\n    let res = 0;\\n    const charCount = new Map<string, number>();\\n\\n    for(const char of s){\\n        const count = charCount.get(char);\\n        if(count){\\n            charCount.set(char, count+1);\\n        }else{\\n            charCount.set(char, 1);\\n        }\\n    }\\n\\n    for(const major of charCount.keys()){\\n        for(const minor of charCount.keys()){\\n            if(major===minor){\\n                continue;\\n            }\\n            let majorCount = 0;\\n            let minorCount = 0;\\n            let restMajorCount = charCount.get(major) as number;\\n            let restMinorCount = charCount.get(minor) as number;\\n            for(const char of s){\\n                if(restMajorCount===0 && restMinorCount===0){\\n                    break;\\n                }\\n                if(char===major){\\n                    majorCount += 1;\\n                    restMajorCount -= 1;\\n                }\\n                if(char===minor){\\n                    minorCount += 1;\\n                    restMinorCount -= 1;\\n                }\\n\\n                if(majorCount>0 && minorCount>0){\\n                    res = Math.max(majorCount-minorCount, res);\\n                }\\n\\n                if(majorCount < minorCount && restMinorCount > 0 && restMajorCount > 0){\\n                    majorCount = 0;\\n                    minorCount = 0;\\n                }\\n            }\\n\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3738600,
                "title": "daily-leetcoding-challenge-july-day-9",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/substring-with-largest-variance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Kadane's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/substring-with-largest-variance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3100780,
                "title": "kadane-greedy-c-explanation-with-diagram",
                "content": "# Intuition\\nNot my own idea. Source: https://leetcode.com/problems/substring-with-largest-variance/solutions/2038840/c-kadane-s-algorithm-with-edge-case-explaination/ \\n\\nBut if you find that explanation hard, you may try understanding my explanation. \\n\\n# Approach\\n![image.png](https://assets.leetcode.com/users/images/685bf648-2d6f-4468-8ee4-3cebf15905c2_1674720175.2750695.png)\\n\\n\\n\\n/* LOGIC \\nRun this logic for every pair combo (i, j) in [a, z]. i != j \\n\\nbool \"extend\" signifies that there is atleast one lower-freq char, before you encounter a set of higher-freq_char.\\nExample: assume \\'b\\' is lower_freq_char (lfc)  and \\'a\\' is higher-freq-char (hfc)\\ne.g lets take a sequence bbbaaabbbaaaaa\\n\\nFor the first subsequence \\'bbb\\' the variance is 0. This will not add anything to the vairance. you can safely say ret = max (ret,hfc - lfc), even though hfc = 0 at this point  \\n\\nReset the frequencies of lfc and hfc, but set the \\'extend\\' bool to true. the reasoning behing this is whenever we encounter a bunch of hfc after this b at index 2 (i.e the third b), it is guaranteed that there is atleast one \\'b\\' at the start of this sequence of hfc (aaa). so for that baaa from index 2 to 5, we have 3 aaa, with one trailing b. so variance is 3 - 1. \\n\\nNow when we encounter the b at index 6, we can discard / disregard that \\'b\\' at index 2 to take a \"greedy\" result. \\nAgain at index 8 ,right when we encounter the end of another 3b\\'s bbb => reset the counts, because there is no way the prior sequence yields a better result. and then when we encounter that last 5 a\\'s the optimal result is nothing but  #count of a\\'s (5) - 1 . \\n*/\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int n = s.size();\\n        int ret = 0;\\n        //hfc - higher freq char lfc - lower freq char\\n        \\n        for (char hfc = \\'a\\'; hfc <= \\'z\\'; hfc++) {\\n            for (char lfc = \\'a\\' ; lfc <= \\'z\\'; lfc++) {\\n                if (lfc == hfc) continue;\\n                int hfc_count = 0;\\n                int lfc_count = 0;\\n                \\n                bool extend = false;\\n                for (auto& c : s) {\\n                    if (c == lfc) lfc_count++;\\n                    if (c == hfc) hfc_count++;\\n                    \\n                    //CASE 1\\n                    if (lfc_count > 0) \\n                        ret = max(ret, hfc_count - lfc_count);\\n                    \\n                    //CASE 2\\n                    if (lfc_count > hfc_count) {\\n                        lfc_count = 0;\\n                        hfc_count = 0;\\n                        extend = true;\\n                    }\\n\\n                    //CASE 3\\n                    if (extend && lfc_count == 0) {\\n                        ret = max (ret , hfc_count - 1);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int n = s.size();\\n        int ret = 0;\\n        //hfc - higher freq char lfc - lower freq char\\n        \\n        for (char hfc = \\'a\\'; hfc <= \\'z\\'; hfc++) {\\n            for (char lfc = \\'a\\' ; lfc <= \\'z\\'; lfc++) {\\n                if (lfc == hfc) continue;\\n                int hfc_count = 0;\\n                int lfc_count = 0;\\n                \\n                bool extend = false;\\n                for (auto& c : s) {\\n                    if (c == lfc) lfc_count++;\\n                    if (c == hfc) hfc_count++;\\n                    \\n                    //CASE 1\\n                    if (lfc_count > 0) \\n                        ret = max(ret, hfc_count - lfc_count);\\n                    \\n                    //CASE 2\\n                    if (lfc_count > hfc_count) {\\n                        lfc_count = 0;\\n                        hfc_count = 0;\\n                        extend = true;\\n                    }\\n\\n                    //CASE 3\\n                    if (extend && lfc_count == 0) {\\n                        ret = max (ret , hfc_count - 1);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804475,
                "title": "golang",
                "content": "# Code\\n```\\nfunc max(i, j int) int {\\n    if i > j {\\n        return i\\n    }\\n    return j\\n}\\n\\nfunc largestVariance(s string) int {\\n    result := 0\\n    chars := make(map[rune]struct{}) \\n    for _, c := range s {\\n        chars[c] = struct{}{}\\n    }\\n\\n    for x, _ := range chars {\\n        for y, _ := range chars {\\n            if x == y {\\n                continue\\n            }\\n            totalX := 0\\n            totalY := 0\\n            for _, c := range s {\\n               switch c {\\n                  case x: totalX += 1 \\n                  case y: totalY += 1\\n                  default: continue\\n               } \\n\\n               if totalY > 0 {\\n                   result = max(result, totalX - totalY)\\n               } else {\\n                   result = max(result, totalX - 1)\\n               }\\n\\n               if totalX - totalY < 0 {\\n                   totalX = 0\\n                   totalY = 0\\n               }\\n            }\\n        }\\n    }\\n    return result \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc max(i, j int) int {\\n    if i > j {\\n        return i\\n    }\\n    return j\\n}\\n\\nfunc largestVariance(s string) int {\\n    result := 0\\n    chars := make(map[rune]struct{}) \\n    for _, c := range s {\\n        chars[c] = struct{}{}\\n    }\\n\\n    for x, _ := range chars {\\n        for y, _ := range chars {\\n            if x == y {\\n                continue\\n            }\\n            totalX := 0\\n            totalY := 0\\n            for _, c := range s {\\n               switch c {\\n                  case x: totalX += 1 \\n                  case y: totalY += 1\\n                  default: continue\\n               } \\n\\n               if totalY > 0 {\\n                   result = max(result, totalX - totalY)\\n               } else {\\n                   result = max(result, totalX - 1)\\n               }\\n\\n               if totalX - totalY < 0 {\\n                   totalX = 0\\n                   totalY = 0\\n               }\\n            }\\n        }\\n    }\\n    return result \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2776926,
                "title": "max-sum-subarray-problem-intuition-for-landing-there-from-the-trivial-soln",
                "content": "**Idea**: If you had frequency table at each ith element you could have calculated the answer by comparing i-1th and jth entry of the table for every i > j. But, sadly it takes **n^2 * m** time, where n = s.size() and  m is number of distinct characters. we have **m = 26** here. This is beacause we considered all substring (**n^2**) and compared **m** entries for each substring.\\n\\nnow, building on this idea perhaphs, if we could reduce this time to **n * m^2** time, we could be done if m is **orderely constant**, which is true for m being 26.\\n\\n**Intitution why n * n * m could be reduce in n * m * m (It will be further reduce to n * m)** :\\nwell, let say the maximum variance substring has maximum count element as \\'a\\' and minimum count element as \\'b\\', then we can also represent this substring maxSub{a,b}(s) where, s is our original string and maxSub{a,b} is maximum variance substring with condition that \\'a\\' should be maximum count element and \\'b\\' is minimum count element. If we take \\nmax(maxSub{i,j}(s)), where i is from \\'a\\' to \\'z\\' and \\'j\\' is also from \\'a\\' to \\'z\\' then we would get the answer of original problem which happened to be maxSub{a,b}(s) in this example.\\n\\nso there are **m * m** pairs possible. So, while traversing the string s, if at every ith character, we could correctly update all these **m^2 pairs with each pair taking constant time**, then we would be done in O(n * m^2). Now for a pair{a, b} the maxSub{a,b}(s) = count(a) - count(b) in the substring with highest variance of pair{a, b}. So for pair {a, b}, at every ith element only \\'a\\' and \\'b\\' matters in variance count where \\'a\\' would result in +1 in and \\'b\\' would result in -1. All the other characters would be taken care by other pairs where they belong. Now, this can be solved as **(maximum sum subarray problem) * m^2 pairs** which is O(n) problem * m^2.\\n\\nOnly care which need to be taken is that in subproblem of pair{a,b}, \\'b\\' must have been occured atleast for current sum to be considered as answer of the subproblem.\\n\\nIn the code below, I have used -2 to represent that for pair {\\'a\\', \\'b\\'}, \\'b\\' has not ever occured in the string s yet. I have then used -1 to represent that b has occured in string s, but b is not counted even once contender of the answer for subproblem {a,b} (so, current conternder - 1 should be considered for answer instead, as b has atleast appeared in the string so far). Similarly if b is counted atleast once in current contender of the answer then it should be considered for possible answer.\\n\\nsummarizing the build up : **instead of comparing all substrings(n^2)  m times, we compared all pairs(m^2) n times**\\n\\nNow, actual order is **O(n * m)** and not **O(n * m^2)** as at every ith element we would be affecting only the current contenders of **2 * m - 1 pairs** as, the current element would be either the start of the affected pair or the end of the affected pair. **rest pairs\\'(m^2 - (2 * m -1) = (m - 1)^2) contenders** would be undisturbed, at the ith element . So order is **O(n * m) + O(m * m)[for initialization of m pairs] = O(n * m)**\\n\\nso, we reduced **O(n^2 * m) to O(n * m)** which is effectively reducing **O(n^2) to O(n)** as m is orderly constant for us.\\n\\n**phew!**\\n```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int ans = 0;\\n        vector<vector<pair<int, int> > > table(26, vector<pair<int, int> > (26, {0, -2}));\\n        int x;\\n        for(char c : s) {\\n            x =  c -\\'a\\';\\n            for(int i = 0; i < 26; i++) {\\n                table[x][i].first += 1;\\n                if(table[i][x].first == 0){\\n                    table[i][x].second = -1;\\n                }\\n                else {\\n                    table[i][x].first -= 1;\\n                    table[i][x].second = 0;\\n                }\\n                if(table[x][i].second != -2) ans = max(ans, table[x][i].first + table[x][i].second);\\n                ans = max(ans, table[i][x].first + table[i][x].second);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int ans = 0;\\n        vector<vector<pair<int, int> > > table(26, vector<pair<int, int> > (26, {0, -2}));\\n        int x;\\n        for(char c : s) {\\n            x =  c -\\'a\\';\\n            for(int i = 0; i < 26; i++) {\\n                table[x][i].first += 1;\\n                if(table[i][x].first == 0){\\n                    table[i][x].second = -1;\\n                }\\n                else {\\n                    table[i][x].first -= 1;\\n                    table[i][x].second = 0;\\n                }\\n                if(table[x][i].second != -2) ans = max(ans, table[x][i].first + table[x][i].second);\\n                ans = max(ans, table[i][x].first + table[i][x].second);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700738,
                "title": "python-recursive-solution-tle-conceptual",
                "content": "```\\n# Unoptimized approach - Kadanes algorithm is better\\n\\nimport collections\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        @cache\\n        def dp(i):\\n            if i == len(s):\\n                return 0\\n            \\n            res = 0\\n            for j in range(i,len(s)):\\n                count = collections.Counter(s[i:j+1])\\n                variance = abs(count.most_common(1)[-1][1] - count.most_common()[-1][1]) #This gets us the most and least frequently occuring elements in the substring, to help us calculate variance\\n                res = max(res, variance, dp(j+1))\\n    \\n            return res\\n        \\n        return dp(0)\\n```\\n\\n```\\nimport collections\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        dp = [0 for i in range(len(s)+1)]\\n        for i in range(len(s)-1,-1,-1):\\n            for j in range(i,len(s)):\\n                count = collections.Counter(s[i:j+1])\\n                variance = abs(count.most_common(1)[-1][1] - count.most_common()[-1][1])\\n                dp[i] = max(dp[i], variance, dp[j+1])\\n                \\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# Unoptimized approach - Kadanes algorithm is better\\n\\nimport collections\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        @cache\\n        def dp(i):\\n            if i == len(s):\\n                return 0\\n            \\n            res = 0\\n            for j in range(i,len(s)):\\n                count = collections.Counter(s[i:j+1])\\n                variance = abs(count.most_common(1)[-1][1] - count.most_common()[-1][1]) #This gets us the most and least frequently occuring elements in the substring, to help us calculate variance\\n                res = max(res, variance, dp(j+1))\\n    \\n            return res\\n        \\n        return dp(0)\\n```\n```\\nimport collections\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        dp = [0 for i in range(len(s)+1)]\\n        for i in range(len(s)-1,-1,-1):\\n            for j in range(i,len(s)):\\n                count = collections.Counter(s[i:j+1])\\n                variance = abs(count.most_common(1)[-1][1] - count.most_common()[-1][1])\\n                dp[i] = max(dp[i], variance, dp[j+1])\\n                \\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666088,
                "title": "python-character1-and-character-2-explained",
                "content": "This code is modified from this link [here] : (https://leetcode.com/problems/substring-with-largest-variance/discuss/2649607/python-solution-simple)\\n\\nThe modifications I hope make it more readable overall. First time posting with explanations. \\nIn this task we are asked to come up with the largest variance of the substrings of string s. To start with we use the Counter class to generate a count of each character in s, and thus allow us to use itertools permutations function to loop over s. Next, for character permutations within s, and for those permutations which have a character1 whose total count is at least greater than our current result, we loop through the string so long as we have remaining characters for both. As we do, as we encounter these characters, we decrement their remaining. If at any time the difference between them is less than 0 with remaining characters for each not zero, we reset our character difference and our presence of the characters, akin to a new substring. If we have encountered both characters, we compute the max of the resulting variance. \\n\\nThe major speedup that could likely be introduced into other more promising solutions is the check of the remaining characters for the character considered against the resulting maximum variance, where the maximum variance that is larger than the remaining characters for a new ch1 could then be used to skip non-promising candidates, trimming the total pool of candidates. \\n\\n\\'\\'\\'\\n\\n\\tdef largest_variance(self, s) : \\n        # counter is faster, better to use this than increments \\n        counter = Counter(s)\\n        # result is the return value for maximum variance \\n        result = 0\\n        # itertools permutations allows us to permute the string in sets of 2 characters at a time \\n        for ch1, ch2 in itertools.permutations(counter, 2):\\n\\t\\t\\t# This is difference in character 1 and character 2 \\n            ch1diffch2 = 0\\n            # booleans for has_ch1 and has_ch2, initially False\\n            # These are used to determine if our current frequency count is greater than 0 for both \\n            has_ch1, has_ch2 = False, False\\n            # remain a and remain b is the counter at ch1 and ch2. \\n            # This value lets us know how many remaining amounts of these characters we\\'ve yet to encounter in the string \\n            remain_ch1, remain_ch2 = counter[ch1], counter[ch2]\\n            # only do those you care about that could improve your answer \\n            if remain_ch1 < result : \\n                continue \\n            # for each character in the string \\n            for character in s:\\n                # if the character is not ch1 and not ch2 continue \\n                if character != ch1 and character != ch2:\\n                    continue\\n                # else if both of the remains are now 0 or less \\n                elif remain_ch1 <= 0 and remain_ch2 <= 0: \\n                    break\\n                # otherwise if ch1diffch2 < 0 and remain_ch1 is not 0 and remain_ch2 is not 0 \\n                if ch1diffch2 < 0 and remain_ch1 != 0 and remain_ch2 != 0:\\n                    # set ch1diffch2 to zero as this means we are at a point of the difference being not in favor of ch1 \\n                    ch1diffch2 = 0\\n                    # has_ch1 and has_ch2 are false as we are restarting the frequency comparison \\n                    has_ch1, has_ch2 = False, False\\n                if character == ch1: \\n                    # if the character is ch1 \\n                    # increment the difference\\n                    ch1diffch2 += 1\\n                    # decrement remain ch1 as you encountered a ch1 \\n                    remain_ch1 -= 1\\n                    # has_ch1 is now True as you have encountered a ch1 \\n                    has_ch1 = True\\n                elif character == ch2: \\n                    # if the character is ch2 decrement the difference \\n                    ch1diffch2 -= 1\\n                    # decrement remain_ch2 as you encountered a ch2 \\n                    remain_ch2 -= 1\\n                    # has_ch2 is  now True as you have encountered a ch2 \\n                    has_ch2 = True\\n                # if you have ch1 and ch2 it means you\\'ve encountered each and should set result as appropriate \\n                if has_ch1 and has_ch2:\\n                    # set result to the maximum of result and the ch1 and ch2 difference\\n                    result = max(result, ch1diffch2)\\n        # return the resulting max variance \\n        return result\\n\\t\\t\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "This code is modified from this link [here] : (https://leetcode.com/problems/substring-with-largest-variance/discuss/2649607/python-solution-simple)\\n\\nThe modifications I hope make it more readable overall. First time posting with explanations. \\nIn this task we are asked to come up with the largest variance of the substrings of string s. To start with we use the Counter class to generate a count of each character in s, and thus allow us to use itertools permutations function to loop over s. Next, for character permutations within s, and for those permutations which have a character1 whose total count is at least greater than our current result, we loop through the string so long as we have remaining characters for both. As we do, as we encounter these characters, we decrement their remaining. If at any time the difference between them is less than 0 with remaining characters for each not zero, we reset our character difference and our presence of the characters, akin to a new substring. If we have encountered both characters, we compute the max of the resulting variance. \\n\\nThe major speedup that could likely be introduced into other more promising solutions is the check of the remaining characters for the character considered against the resulting maximum variance, where the maximum variance that is larger than the remaining characters for a new ch1 could then be used to skip non-promising candidates, trimming the total pool of candidates. \\n\\n\\'\\'\\'\\n\\n\\tdef largest_variance(self, s) : \\n        # counter is faster, better to use this than increments \\n        counter = Counter(s)\\n        # result is the return value for maximum variance \\n        result = 0\\n        # itertools permutations allows us to permute the string in sets of 2 characters at a time \\n        for ch1, ch2 in itertools.permutations(counter, 2):\\n\\t\\t\\t# This is difference in character 1 and character 2 \\n            ch1diffch2 = 0\\n            # booleans for has_ch1 and has_ch2, initially False\\n            # These are used to determine if our current frequency count is greater than 0 for both \\n            has_ch1, has_ch2 = False, False\\n            # remain a and remain b is the counter at ch1 and ch2. \\n            # This value lets us know how many remaining amounts of these characters we\\'ve yet to encounter in the string \\n            remain_ch1, remain_ch2 = counter[ch1], counter[ch2]\\n            # only do those you care about that could improve your answer \\n            if remain_ch1 < result : \\n                continue \\n            # for each character in the string \\n            for character in s:\\n                # if the character is not ch1 and not ch2 continue \\n                if character != ch1 and character != ch2:\\n                    continue\\n                # else if both of the remains are now 0 or less \\n                elif remain_ch1 <= 0 and remain_ch2 <= 0: \\n                    break\\n                # otherwise if ch1diffch2 < 0 and remain_ch1 is not 0 and remain_ch2 is not 0 \\n                if ch1diffch2 < 0 and remain_ch1 != 0 and remain_ch2 != 0:\\n                    # set ch1diffch2 to zero as this means we are at a point of the difference being not in favor of ch1 \\n                    ch1diffch2 = 0\\n                    # has_ch1 and has_ch2 are false as we are restarting the frequency comparison \\n                    has_ch1, has_ch2 = False, False\\n                if character == ch1: \\n                    # if the character is ch1 \\n                    # increment the difference\\n                    ch1diffch2 += 1\\n                    # decrement remain ch1 as you encountered a ch1 \\n                    remain_ch1 -= 1\\n                    # has_ch1 is now True as you have encountered a ch1 \\n                    has_ch1 = True\\n                elif character == ch2: \\n                    # if the character is ch2 decrement the difference \\n                    ch1diffch2 -= 1\\n                    # decrement remain_ch2 as you encountered a ch2 \\n                    remain_ch2 -= 1\\n                    # has_ch2 is  now True as you have encountered a ch2 \\n                    has_ch2 = True\\n                # if you have ch1 and ch2 it means you\\'ve encountered each and should set result as appropriate \\n                if has_ch1 and has_ch2:\\n                    # set result to the maximum of result and the ch1 and ch2 difference\\n                    result = max(result, ch1diffch2)\\n        # return the resulting max variance \\n        return result\\n\\t\\t\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2657970,
                "title": "easy-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int aux(string s, char a, char b){\\n        bool foundb = false;\\n        int afreq = 0 , bfreq = 0, res = 0;\\n        for (auto c:s){\\n            if (c==a) afreq++;\\n            else if (b==c) bfreq++;\\n            if (bfreq || foundb){\\n                if (bfreq) res = max(res , afreq - bfreq);\\n                else res = max(res , afreq - 1);\\n            }\\n            if (afreq - bfreq<0) {\\n                foundb = true;\\n                afreq = bfreq = 0;\\n            }\\n        }\\n        return res;\\n    }\\n    int largestVariance(string s) {\\n        unordered_set<char> characters;\\n        for (auto i:s) characters.insert(i);\\n        int res = 0;\\n        for (auto a:characters){\\n            for (auto b:characters){\\n                if (a!=b) res = max(res , aux(s,a,b));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int aux(string s, char a, char b){\\n        bool foundb = false;\\n        int afreq = 0 , bfreq = 0, res = 0;\\n        for (auto c:s){\\n            if (c==a) afreq++;\\n            else if (b==c) bfreq++;\\n            if (bfreq || foundb){\\n                if (bfreq) res = max(res , afreq - bfreq);\\n                else res = max(res , afreq - 1);\\n            }\\n            if (afreq - bfreq<0) {\\n                foundb = true;\\n                afreq = bfreq = 0;\\n            }\\n        }\\n        return res;\\n    }\\n    int largestVariance(string s) {\\n        unordered_set<char> characters;\\n        for (auto i:s) characters.insert(i);\\n        int res = 0;\\n        for (auto a:characters){\\n            for (auto b:characters){\\n                if (a!=b) res = max(res , aux(s,a,b));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608186,
                "title": "help-needed-to-understand-the-problem",
                "content": "I went through all the solutions, youtube videos, but i am not able to understand this particular problem. Can someone explain me in easy layman\\'s terms.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2521424,
                "title": "o-26-n-solution-with-comments-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[26][26];\\n    /* \\n    dp[x][y] is maximum variance value where x is maximum and y is the minimum \\n    character at i-th position.\\n    \\n    for any sequence for dp[x][y],\\n    if y is not the minimum character and lets assume z is the minimum character\\n    then we will get the correct result from dp[x][z].\\n    \\n    since all pair of character is being considered, even if we hold wrong result\\n    for any pair, we will still get the correct result for the correct pair.\\n    */\\n    bool foundChar[26],startedWithMinimumChar[26][26];\\n    /*\\n    foundChar[x] is true if we have encountered character x till i-th postion\\n    \\n    startedWithMinimumChar[x][y] is true if current maximum variance sequence \\n    with maximum character x and minimum character y started with the\\n    minimum character y\\n    */\\n    \\n    int largestVariance(string s) {\\n        \\n        memset(dp,0,sizeof(dp));\\n        memset(foundChar,0,sizeof(foundChar));\\n        memset(startedWithMinimumChar,0,sizeof(startedWithMinimumChar));\\n        \\n        int res = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int curCh = s[i] - \\'a\\';\\n            foundChar[curCh] = 1;\\n            for(int ch=0;ch<26;ch++)\\n            {\\n                if(ch==curCh) continue;\\n               \\n                dp[curCh][ch] += 1;\\n                if(foundChar[ch]) res = max(res,dp[curCh][ch]);\\n                \\n                dp[ch][curCh] -= 1;\\n                if(startedWithMinimumChar[ch][curCh])\\n                {\\n                    dp[ch][curCh] += 1;\\n                    startedWithMinimumChar[ch][curCh] = 0;\\n                }\\n                if(foundChar[ch]) res = max(res, dp[ch][curCh]);\\n                \\n                if(dp[ch][curCh]<0) \\n                    dp[ch][curCh] = -1,startedWithMinimumChar[ch][curCh] = 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[26][26];\\n    /* \\n    dp[x][y] is maximum variance value where x is maximum and y is the minimum \\n    character at i-th position.\\n    \\n    for any sequence for dp[x][y],\\n    if y is not the minimum character and lets assume z is the minimum character\\n    then we will get the correct result from dp[x][z].\\n    \\n    since all pair of character is being considered, even if we hold wrong result\\n    for any pair, we will still get the correct result for the correct pair.\\n    */\\n    bool foundChar[26],startedWithMinimumChar[26][26];\\n    /*\\n    foundChar[x] is true if we have encountered character x till i-th postion\\n    \\n    startedWithMinimumChar[x][y] is true if current maximum variance sequence \\n    with maximum character x and minimum character y started with the\\n    minimum character y\\n    */\\n    \\n    int largestVariance(string s) {\\n        \\n        memset(dp,0,sizeof(dp));\\n        memset(foundChar,0,sizeof(foundChar));\\n        memset(startedWithMinimumChar,0,sizeof(startedWithMinimumChar));\\n        \\n        int res = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int curCh = s[i] - \\'a\\';\\n            foundChar[curCh] = 1;\\n            for(int ch=0;ch<26;ch++)\\n            {\\n                if(ch==curCh) continue;\\n               \\n                dp[curCh][ch] += 1;\\n                if(foundChar[ch]) res = max(res,dp[curCh][ch]);\\n                \\n                dp[ch][curCh] -= 1;\\n                if(startedWithMinimumChar[ch][curCh])\\n                {\\n                    dp[ch][curCh] += 1;\\n                    startedWithMinimumChar[ch][curCh] = 0;\\n                }\\n                if(foundChar[ch]) res = max(res, dp[ch][curCh]);\\n                \\n                if(dp[ch][curCh]<0) \\n                    dp[ch][curCh] = -1,startedWithMinimumChar[ch][curCh] = 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470129,
                "title": "java-use-of-kadane-s-algorithm-on-all-possible-pairs-of-characters",
                "content": "```\\n    /*\\n    Basic intuition of the problem is - How to use kadane\\'s Algorithm using\\n    all possible pairs of characters?\\n    */\\n    public int largestVariance(String s) {\\n        int maxVariance=0;\\n        //two loops to get all the possible combinations of the character pair that exist\\n        for(int highFreq=0;highFreq<=26;highFreq++){\\n            for(int lowFreq=0;lowFreq<26;lowFreq++){\\n                //if both the characters are same no need to calculate as variance will be zero\\n                if(lowFreq == highFreq)\\n                    continue;\\n                int curLow=0,curHigh=0;\\n                boolean lowCharIgnored = false;\\n                for(char ch : s.toCharArray()){\\n                    //update the current freq as per current character \\n                    int freq = ch-\\'a\\';\\n                    if(freq == highFreq) curHigh++;\\n                    if(freq == lowFreq) curLow++;\\n                    //if both high and low freq exist then calculate the maxVariance as per\\n                    //kadane\\'s algorithm\\n                    if(curLow > 0 && curHigh > 0)\\n                        maxVariance = Math.max(maxVariance,curHigh-curLow);\\n                    else{\\n                        //if you have ignored one of the low frequency you can always use one\\n                        //ignored occurence for corner cases\\n                        if(lowCharIgnored)\\n                            maxVariance = Math.max(maxVariance,curHigh-1);\\n                    }\\n                    //as we always want curHigh > curLow, if that\\'s not the case simply reset\\n                    //the counters and lowCharIgnored to true as you are ignoring one of the low freq\\n                    if(curLow > curHigh){\\n                        curHigh = 0;\\n                        curLow = 0;\\n                        lowCharIgnored=true;\\n                    }\\n                }\\n            }\\n        }\\n        return maxVariance;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    /*\\n    Basic intuition of the problem is - How to use kadane\\'s Algorithm using\\n    all possible pairs of characters?\\n    */\\n    public int largestVariance(String s) {\\n        int maxVariance=0;\\n        //two loops to get all the possible combinations of the character pair that exist\\n        for(int highFreq=0;highFreq<=26;highFreq++){\\n            for(int lowFreq=0;lowFreq<26;lowFreq++){\\n                //if both the characters are same no need to calculate as variance will be zero\\n                if(lowFreq == highFreq)\\n                    continue;\\n                int curLow=0,curHigh=0;\\n                boolean lowCharIgnored = false;\\n                for(char ch : s.toCharArray()){\\n                    //update the current freq as per current character \\n                    int freq = ch-\\'a\\';\\n                    if(freq == highFreq) curHigh++;\\n                    if(freq == lowFreq) curLow++;\\n                    //if both high and low freq exist then calculate the maxVariance as per\\n                    //kadane\\'s algorithm\\n                    if(curLow > 0 && curHigh > 0)\\n                        maxVariance = Math.max(maxVariance,curHigh-curLow);\\n                    else{\\n                        //if you have ignored one of the low frequency you can always use one\\n                        //ignored occurence for corner cases\\n                        if(lowCharIgnored)\\n                            maxVariance = Math.max(maxVariance,curHigh-1);\\n                    }\\n                    //as we always want curHigh > curLow, if that\\'s not the case simply reset\\n                    //the counters and lowCharIgnored to true as you are ignoring one of the low freq\\n                    if(curLow > curHigh){\\n                        curHigh = 0;\\n                        curLow = 0;\\n                        lowCharIgnored=true;\\n                    }\\n                }\\n            }\\n        }\\n        return maxVariance;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422015,
                "title": "kotlin-kadane-very-simple-using-string-reverse-o-1-space",
                "content": "```\\nclass Solution {\\n    \\n    fun variance(s: String,c1: Char, c2: Char, rev : Boolean) : Int {\\n        var ret = 0 \\n        var sum = 0 \\n        var has1 = false\\n        var has2 = false\\n        \\n        for(chi in 0..s.length-1) {\\n            var chi1 = chi\\n            if(rev) chi1 = s.length-1 - chi1\\n            val ch = s[chi1]\\n            if(ch == c1) {\\n                has1 = true\\n                sum++\\n            }\\n            else if(ch == c2) {\\n                has2 = true\\n                sum--\\n            }\\n            if(has1 && has2 && sum >ret) {\\n                ret = sum\\n            }\\n            if(sum < 0) {\\n                sum = 0 \\n                has1 = false\\n                has2 = false\\n            }\\n        }\\n        \\n        if(has1 && has2 && sum >ret) {\\n            ret = sum\\n        }\\n\\n        return ret\\n        \\n    }\\n    \\n    fun largestVariance(s: String): Int {\\n       \\n        var ret = 0\\n        for(c1 in \\'a\\'..\\'z\\') {\\n            for(c2 in \\'a\\'..\\'z\\') {\\n                if(c1 != c2){\\n                    ret = Math.max(ret,variance(s,c1,c2,false))\\n                    ret = Math.max(ret,variance(s,c1,c2, true))\\n                }\\n                \\n            }\\n        }\\n        return ret\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    \\n    fun variance(s: String,c1: Char, c2: Char, rev : Boolean) : Int {\\n        var ret = 0 \\n        var sum = 0 \\n        var has1 = false\\n        var has2 = false\\n        \\n        for(chi in 0..s.length-1) {\\n            var chi1 = chi\\n            if(rev) chi1 = s.length-1 - chi1\\n            val ch = s[chi1]\\n            if(ch == c1) {\\n                has1 = true\\n                sum++\\n            }\\n            else if(ch == c2) {\\n                has2 = true\\n                sum--\\n            }\\n            if(has1 && has2 && sum >ret) {\\n                ret = sum\\n            }\\n            if(sum < 0) {\\n                sum = 0 \\n                has1 = false\\n                has2 = false\\n            }\\n        }\\n        \\n        if(has1 && has2 && sum >ret) {\\n            ret = sum\\n        }\\n\\n        return ret\\n        \\n    }\\n    \\n    fun largestVariance(s: String): Int {\\n       \\n        var ret = 0\\n        for(c1 in \\'a\\'..\\'z\\') {\\n            for(c2 in \\'a\\'..\\'z\\') {\\n                if(c1 != c2){\\n                    ret = Math.max(ret,variance(s,c1,c2,false))\\n                    ret = Math.max(ret,variance(s,c1,c2, true))\\n                }\\n                \\n            }\\n        }\\n        return ret\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283440,
                "title": "python-o-26-n-best-solution-possible",
                "content": "edit1: Please look to the @RJMCMC [solution here](https://leetcode.com/problems/substring-with-largest-variance/discuss/2038952/Python-2*26*N-(faster-than-26*25*N)), I\\'m basicaly doing the same thing but in a horrible way; that\\'s a clean solution and easy to understand.\\n\\nThis is a O(26 *n) solution, I\\'m a bit lazy to improve code readability, sorry.\\nThe idea is the same of kadane n * 26^2, but instead of simulating the pair C1, C2 for all different characters of the string you can do something better:\\nImagine the best solution is the substring at the interval [i, j], it\\'s guarantee the most frequent character is s[i] or s[j] OR both s[i] and s[j]. Also the case s[i] != s[j] means the s[i] is the most frequent and s[j] is the lowest frequent or the inverse! So, given that, for the Kadane solution where we simulate all C1 and C2, what you can do is simulate the end of the best solution and set it as a fixed value for C2 for each position of the string, then you iterate over all values of C1 keeping track of the cumulative sum using a hashset.\\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        mp = {}\\n        mp_min = {}\\n        mp_prev_min = {}\\n        all_chars = set([char for char in s])\\n        visited = set()\\n        best = 0\\n        for i in range(len(s)):\\n            c_in = s[i]\\n            visited.add(c_in)\\n            for c_out in all_chars:\\n                if c_in == c_out:\\n                    continue\\n\\n                # get max\\n                # c_in is positive and c_out is negative\\n                sum_at = mp.get((c_in, c_out), 0) + 1\\n                sum_min = min(mp_prev_min.get((c_in, c_out), 0), sum_at)\\n                mp[(c_in, c_out)] = sum_at\\n                if c_out in visited:\\n                    best = max(best, sum_at - sum_min)\\n                \\n                #c_out is positive and c_in is negative\\n                sum_at = mp.get((c_out, c_in), 0) - 1\\n                sum_min = min(mp_prev_min.get((c_out, c_in), 0), sum_at)\\n                if c_out in visited:\\n                    best = max(best, sum_at - sum_min)\\n\\n                #update min\\n                sum_at = mp.get((c_out, c_in), 0) - 1\\n                mp_prev_min[(c_out, c_in)] = mp_min.get((c_out, c_in), 0)\\n                sum_min = min(mp_prev_min[(c_out, c_in)], sum_at)\\n                mp[(c_out, c_in)] = sum_at\\n                mp_min[(c_out, c_in)] = sum_min\\n        \\n\\n        return best\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def largestVariance(self, s: str) -> int:\\n        mp = {}",
                "codeTag": "Java"
            },
            {
                "id": 2175859,
                "title": "java-o-26-26-n",
                "content": "** SLOW BUT EASY TO UNDERSTAND**\\n\\n```\\nclass Solution {\\n    int max=0;\\n    public int largestVariance(String s) {\\n        StringBuilder sb=new StringBuilder(s);\\n        sb=sb.reverse();\\n        \\n        for(char c=\\'a\\';c<=\\'z\\';c++){\\n            for(char c1=\\'a\\';c1<=\\'z\\';c1++){\\n                if(c!=c1){\\n                    find(c,c1,s);\\n                    find(c,c1,sb.toString());\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    void find(char c1,char c2,String str){\\n        \\n        int count=0;\\n        int count1=0;\\n        for(int i=0;i<str.length();i++){\\n            if(str.charAt(i)==c1){\\n                count++;\\n                count1++;\\n            }\\n            else if(str.charAt(i)==c2){\\n                count--;\\n            }\\n            else{\\n                continue;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//We need two different character\\n            if(count!=count1){\\n                max=Math.max(max,count);\\n            }            \\n            if(count<0){\\n                count=0;\\n                count1=0;\\n            }\\n        }   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max=0;\\n    public int largestVariance(String s) {\\n        StringBuilder sb=new StringBuilder(s);\\n        sb=sb.reverse();\\n        \\n        for(char c=\\'a\\';c<=\\'z\\';c++){\\n            for(char c1=\\'a\\';c1<=\\'z\\';c1++){\\n                if(c!=c1){\\n                    find(c,c1,s);\\n                    find(c,c1,sb.toString());\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    void find(char c1,char c2,String str){\\n        \\n        int count=0;\\n        int count1=0;\\n        for(int i=0;i<str.length();i++){\\n            if(str.charAt(i)==c1){\\n                count++;\\n                count1++;\\n            }\\n            else if(str.charAt(i)==c2){\\n                count--;\\n            }\\n            else{\\n                continue;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//We need two different character\\n            if(count!=count1){\\n                max=Math.max(max,count);\\n            }            \\n            if(count<0){\\n                count=0;\\n                count1=0;\\n            }\\n        }   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168013,
                "title": "c-solution-beats-94-95-tc",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        //FAST IO\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        //Assume first char is max occurence, second char is min occurence \\n        int result =0;\\n        vector <int> freq(26,0);\\n        for(int i=0;i<s.size();i++)\\n            freq[s[i]-\\'a\\']++;\\n        \\n        for(char first_char=\\'a\\';first_char<=\\'z\\';first_char++){\\n            for(char second_char=\\'a\\'; second_char<=\\'z\\';second_char++){\\n                if(first_char==second_char || freq[first_char-\\'a\\']==0 || freq[second_char-\\'a\\']==0)\\n                    continue;\\n                int maxOccur=0,minOccur=0;\\n                bool resetReq = false;\\n                for(char ch: s) {\\n                    if(ch == first_char)\\n                        maxOccur++;\\n                    else if(ch == second_char)\\n                        minOccur++;\\n                    \\n                    \\n                    if(minOccur!=0)\\n                     result = max(result,maxOccur-minOccur);\\n                    else if(resetReq)\\n                     result = max(result,maxOccur-1);\\n                    \\n                    //Set rest condition\\n                    if(maxOccur<minOccur){\\n                        maxOccur=0;\\n                        minOccur=0;\\n                        resetReq=true;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        //FAST IO\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        //Assume first char is max occurence, second char is min occurence \\n        int result =0;\\n        vector <int> freq(26,0);\\n        for(int i=0;i<s.size();i++)\\n            freq[s[i]-\\'a\\']++;\\n        \\n        for(char first_char=\\'a\\';first_char<=\\'z\\';first_char++){\\n            for(char second_char=\\'a\\'; second_char<=\\'z\\';second_char++){\\n                if(first_char==second_char || freq[first_char-\\'a\\']==0 || freq[second_char-\\'a\\']==0)\\n                    continue;\\n                int maxOccur=0,minOccur=0;\\n                bool resetReq = false;\\n                for(char ch: s) {\\n                    if(ch == first_char)\\n                        maxOccur++;\\n                    else if(ch == second_char)\\n                        minOccur++;\\n                    \\n                    \\n                    if(minOccur!=0)\\n                     result = max(result,maxOccur-minOccur);\\n                    else if(resetReq)\\n                     result = max(result,maxOccur-1);\\n                    \\n                    //Set rest condition\\n                    if(maxOccur<minOccur){\\n                        maxOccur=0;\\n                        minOccur=0;\\n                        resetReq=true;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2161152,
                "title": "python-go-kadane-variant-o-n",
                "content": "*Python* solution\\n\\n```python\\ndef largestVariance(self, s):\\n    res = 0\\n    for x, y in itertools.permutations(set(s), 2):\\n        tot, mid = 0, False\\n        for c in s:\\n            if c == x and (mid := tot > 0):\\n                tot -= 1\\n            elif c == y:\\n                res = max(res, tot + mid)\\n                tot += 1\\n    return res\\n```\\n\\n*Go* solution in 64ms beat 91% :)\\n\\n```go\\nfunc largestVariance(s string) int {\\n\\tvar (\\n\\t\\tres int\\n\\t\\tV   [128]bool\\n\\t\\tA   = make([]rune, 0)\\n\\t)\\n\\tfor _, c := range s {\\n\\t\\tif !V[c] {\\n\\t\\t\\tA, V[c] = append(A, c), true\\n\\t\\t}\\n\\t}\\n\\tfor _, x := range A {\\n\\t\\tfor _, y := range A {\\n\\t\\t\\tif x != y {\\n\\t\\t\\t\\ttot, mid := 0, false\\n\\t\\t\\t\\tfor _, c := range s {\\n\\t\\t\\t\\t\\tif c == x {\\n\\t\\t\\t\\t\\t\\tmid = tot > 0\\n\\t\\t\\t\\t\\t\\tif mid {\\n\\t\\t\\t\\t\\t\\t\\ttot--\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else if c == y {\\n\\t\\t\\t\\t\\t\\tif mid {\\n\\t\\t\\t\\t\\t\\t\\ttot++\\n\\t\\t\\t\\t\\t\\t\\tif tot > res {\\n\\t\\t\\t\\t\\t\\t\\t\\tres = tot\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tif tot > res {\\n\\t\\t\\t\\t\\t\\t\\t\\tres = tot\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\ttot++\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef largestVariance(self, s):\\n    res = 0\\n    for x, y in itertools.permutations(set(s), 2):\\n        tot, mid = 0, False\\n        for c in s:\\n            if c == x and (mid := tot > 0):\\n                tot -= 1\\n            elif c == y:\\n                res = max(res, tot + mid)\\n                tot += 1\\n    return res\\n```\n```go\\nfunc largestVariance(s string) int {\\n\\tvar (\\n\\t\\tres int\\n\\t\\tV   [128]bool\\n\\t\\tA   = make([]rune, 0)\\n\\t)\\n\\tfor _, c := range s {\\n\\t\\tif !V[c] {\\n\\t\\t\\tA, V[c] = append(A, c), true\\n\\t\\t}\\n\\t}\\n\\tfor _, x := range A {\\n\\t\\tfor _, y := range A {\\n\\t\\t\\tif x != y {\\n\\t\\t\\t\\ttot, mid := 0, false\\n\\t\\t\\t\\tfor _, c := range s {\\n\\t\\t\\t\\t\\tif c == x {\\n\\t\\t\\t\\t\\t\\tmid = tot > 0\\n\\t\\t\\t\\t\\t\\tif mid {\\n\\t\\t\\t\\t\\t\\t\\ttot--\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else if c == y {\\n\\t\\t\\t\\t\\t\\tif mid {\\n\\t\\t\\t\\t\\t\\t\\ttot++\\n\\t\\t\\t\\t\\t\\t\\tif tot > res {\\n\\t\\t\\t\\t\\t\\t\\t\\tres = tot\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tif tot > res {\\n\\t\\t\\t\\t\\t\\t\\t\\tres = tot\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\ttot++\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2130243,
                "title": "c-modified-kadane-s-two-traversals-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int n=s.size(), max_till=0;\\n        unordered_set<char> st(s.begin(),s.end());\\n        for(char a:st) {\\n            for(char b:st) {\\n                if(a==b) continue;\\n                int max_here=0, b_here=0;\\n                for(int i=0; i<n; i++) {\\n                    if(s[i]==a) max_here++;\\n                    else if(s[i]==b) {max_here--; b_here=1;}\\n                    if(b_here==1) max_till=max(max_till,max_here);\\n                    if(max_here<0) {max_here=0; b_here=0;}\\n                }\\n                max_here=0, b_here=0;\\n                for(int i=n-1; i>=0; i--) {\\n                    if(s[i]==a) max_here++;\\n                    else if(s[i]==b) {max_here--; b_here=1;}\\n                    if(b_here!=0) max_till=max(max_till,max_here);\\n                    if(max_here<0) {max_here=0; b_here=0;}\\n                }\\n            }\\n        }\\n        return max_till;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int n=s.size(), max_till=0;\\n        unordered_set<char> st(s.begin(),s.end());\\n        for(char a:st) {\\n            for(char b:st) {\\n                if(a==b) continue;\\n                int max_here=0, b_here=0;\\n                for(int i=0; i<n; i++) {\\n                    if(s[i]==a) max_here++;\\n                    else if(s[i]==b) {max_here--; b_here=1;}\\n                    if(b_here==1) max_till=max(max_till,max_here);\\n                    if(max_here<0) {max_here=0; b_here=0;}\\n                }\\n                max_here=0, b_here=0;\\n                for(int i=n-1; i>=0; i--) {\\n                    if(s[i]==a) max_here++;\\n                    else if(s[i]==b) {max_here--; b_here=1;}\\n                    if(b_here!=0) max_till=max(max_till,max_here);\\n                    if(max_here<0) {max_here=0; b_here=0;}\\n                }\\n            }\\n        }\\n        return max_till;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092132,
                "title": "intuitive-kadane-with-helper-function",
                "content": "```\\nclass Solution {\\npublic:\\n    int findVariance(string& s, char x, char y){\\n        int ans = 0;\\n        int cur = 0;\\n        int hasY = 0;\\n        for(char c: s){\\n            if(c == x) cur++;\\n            if(c == y) {\\n                cur--;\\n                hasY = 1;\\n            }\\n            if(!hasY) ans = max(cur-1, ans); \\n            else ans = max(cur, ans);\\n            \\n            if(cur < 0){\\n                hasY = 0;\\n                cur = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n    int largestVariance(string s) {\\n        int ans = 0;\\n        unordered_map<char, bool> exists;\\n        for(char c: s){\\n            exists[c] = 1;\\n        }\\n        for(char x = \\'a\\'; x <= \\'z\\'; x++){\\n            for(char y = x + 1; y <= \\'z\\'; y++){\\n                if(!exists[x] || !exists[y]) continue;\\n                ans = max(ans, findVariance(s, x, y));\\n                ans = max(ans, findVariance(s, y, x));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findVariance(string& s, char x, char y){\\n        int ans = 0;\\n        int cur = 0;\\n        int hasY = 0;\\n        for(char c: s){\\n            if(c == x) cur++;\\n            if(c == y) {\\n                cur--;\\n                hasY = 1;\\n            }\\n            if(!hasY) ans = max(cur-1, ans); \\n            else ans = max(cur, ans);\\n            \\n            if(cur < 0){\\n                hasY = 0;\\n                cur = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n    int largestVariance(string s) {\\n        int ans = 0;\\n        unordered_map<char, bool> exists;\\n        for(char c: s){\\n            exists[c] = 1;\\n        }\\n        for(char x = \\'a\\'; x <= \\'z\\'; x++){\\n            for(char y = x + 1; y <= \\'z\\'; y++){\\n                if(!exists[x] || !exists[y]) continue;\\n                ans = max(ans, findVariance(s, x, y));\\n                ans = max(ans, findVariance(s, y, x));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056166,
                "title": "c-solution-using-kadanes-algo-and-flags-time-o-26-26-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string a) {\\n        \\n        int n = a.size(),ans =0 ,var,flag1,flag2;\\n        unordered_map<char,int> m;\\n        for(auto i:a)\\n            m[i]++;\\n        for(char i=\\'a\\';i<=\\'z\\';i++)\\n        {\\n            for(char j=\\'a\\';j<=\\'z\\';j++)\\n            {\\n                if(i!=j&&m.count(i)&&m.count(j))\\n                {\\n                    var =0;\\n                    flag1=0;\\n                    flag2=0;\\n                    for(int k=0;k<n;k++)\\n                    {\\n                        if(a[k]==i)\\n                        {\\n                            flag1=1;\\n                            var++;\\n                        }\\n                        if(a[k]==j)\\n                        {\\n                            var--;\\n                            if(flag1==1)\\n                                flag2=1;\\n                        }\\n                        if(flag1==1&&flag2==1)\\n                            ans = max(ans,var);\\n                        else if(flag1==1)\\n                            ans = max(ans,var-1);\\n                        if(var<0)\\n                        {\\n                            var=0;\\n                            flag1=0;\\n                            flag2=0;\\n                        }\\n                    }\\n                }\\n                    \\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string a) {\\n        \\n        int n = a.size(),ans =0 ,var,flag1,flag2;\\n        unordered_map<char,int> m;\\n        for(auto i:a)\\n            m[i]++;\\n        for(char i=\\'a\\';i<=\\'z\\';i++)\\n        {\\n            for(char j=\\'a\\';j<=\\'z\\';j++)\\n            {\\n                if(i!=j&&m.count(i)&&m.count(j))\\n                {\\n                    var =0;\\n                    flag1=0;\\n                    flag2=0;\\n                    for(int k=0;k<n;k++)\\n                    {\\n                        if(a[k]==i)\\n                        {\\n                            flag1=1;\\n                            var++;\\n                        }\\n                        if(a[k]==j)\\n                        {\\n                            var--;\\n                            if(flag1==1)\\n                                flag2=1;\\n                        }\\n                        if(flag1==1&&flag2==1)\\n                            ans = max(ans,var);\\n                        else if(flag1==1)\\n                            ans = max(ans,var-1);\\n                        if(var<0)\\n                        {\\n                            var=0;\\n                            flag1=0;\\n                            flag2=0;\\n                        }\\n                    }\\n                }\\n                    \\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2055198,
                "title": "python-o-n-based-on-kadane",
                "content": "# Idea\\nWe have limted 26 latters all we need to do is try pairs of them and find the best one. Trying pairs part is easy see the loop at the end. The hardest part is make an algorithm that would find variance with O(N). It\\'s Kadane algorithm but modified with 2 key points.\\n1. Kadane\\'s part: stop after limit goes below 0\\n\\nFor example if we have a string like `bbaaaaa` and want to find Variance(\\'b\\',\\'a\\') meaning max of b mins mins of a in every substrings. For that case we can stop after seeing 3d \\'a\\' because our counts goes to negative. Below it\\'s written as \\n\\n```python\\nif na > nb:\\n\\t# Kadane part: \\n\\tna = 1\\n\\tnb = 0\\n```\\n\\nso everytime we see case like that we restart a counts to 1\\n\\n2. we should skip \\'a\\'s before if we see \\'a\\' and have a non-iterapted \\'bs\\'\\n\\nFor example `aaabbba` as we see \\'a\\' we can restart a counts to 1. That\\'s the code for\\n\\n```python\\ncurra += 1\\nif nb == currb and curra == 1:\\n\\tna = 0\\n```\\n\\n# Solution\\n\\n```python\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:        \\n        def count_variance(b = \\'b\\', a = \\'a\\'):\\n\\t\\t    \\'\\'\\'\\n\\t\\t\\t\\tFor 2 characters b and a find variance\\n\\t\\t\\t\\tas maxb - mina\\n\\t\\t\\t\\'\\'\\'\\n            curra = currb = na = nb = ans = 0\\n            for i,l in enumerate(s):\\n                if l == b:\\n                    nb += 1\\n                    currb += 1\\n                    curra = 0\\n                    \\n                elif l == a:\\n                    curra += 1\\n                    if nb == currb and curra == 1:\\n                        # we need this condition to reset na for cases like\\n                        # abbbba if currb == nb means we can skip \\'a\\'s before\\n                        na = 0\\n                    \\n                    na += 1\\n                    if na > nb:\\n                        # Kadane part: \\n                        # if we stocked with the case like bbbaaaa \\n                        # no need to keep all \\'a\\'s and \\'b\\'s we should restart our counts\\n                        na = 1\\n                        nb = 0\\n                    currb = 0\\n                        \\n                if na and nb:\\n                    ans = max(ans, nb-na)\\n            return ans\\n        \\n        ans = 0\\n        for l1,l2 in permutations(set(s),2):\\n            ans = max(ans, count_variance(l1,l2))\\n        return ans\\n        \\n```\\n\\n# Complexity\\nTime: `O(N)`\\nSpace: `O(1)`\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nif na > nb:\\n\\t# Kadane part: \\n\\tna = 1\\n\\tnb = 0\\n```\n```python\\ncurra += 1\\nif nb == currb and curra == 1:\\n\\tna = 0\\n```\n```python\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:        \\n        def count_variance(b = \\'b\\', a = \\'a\\'):\\n\\t\\t    \\'\\'\\'\\n\\t\\t\\t\\tFor 2 characters b and a find variance\\n\\t\\t\\t\\tas maxb - mina\\n\\t\\t\\t\\'\\'\\'\\n            curra = currb = na = nb = ans = 0\\n            for i,l in enumerate(s):\\n                if l == b:\\n                    nb += 1\\n                    currb += 1\\n                    curra = 0\\n                    \\n                elif l == a:\\n                    curra += 1\\n                    if nb == currb and curra == 1:\\n                        # we need this condition to reset na for cases like\\n                        # abbbba if currb == nb means we can skip \\'a\\'s before\\n                        na = 0\\n                    \\n                    na += 1\\n                    if na > nb:\\n                        # Kadane part: \\n                        # if we stocked with the case like bbbaaaa \\n                        # no need to keep all \\'a\\'s and \\'b\\'s we should restart our counts\\n                        na = 1\\n                        nb = 0\\n                    currb = 0\\n                        \\n                if na and nb:\\n                    ans = max(ans, nb-na)\\n            return ans\\n        \\n        ans = 0\\n        for l1,l2 in permutations(set(s),2):\\n            ans = max(ans, count_variance(l1,l2))\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050741,
                "title": "python-pairwise-4-case-kadanes",
                "content": "For case like \\'abbaaa\\', we can transfer to a =  [1, -1, -1,1,1,1]  or -a or a[::-1] or -a[::-1] four case, then solve it with Leetcode 53, except we need to track there are teo type in current sub array.\\n``` \\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        idxs = {c : i for i, c in enumerate(string.ascii_lowercase)}\\n        s = [idxs[c] for c in s]\\n        cs = set(s)\\n        def pairvar(s):\\n            ret, cur, seen = 0, 0, set()\\n            for v in s:\\n                seen.add(v)\\n                cur += v\\n                if cur < 0: cur, seen = 0, set()\\n                if len(seen) > 1: ret = max(ret, cur)\\n            return ret\\n        ans = 0\\n        for i in cs:\\n            for j in range(i + 1, 26):\\n                if j not in cs: continue\\n                sub = []\\n                for c in s:\\n                    if c == i: sub.append(1)\\n                    elif c == j: sub.append(-1)\\n                ans = max(ans, pairvar(sub), pairvar(-v for v in sub), pairvar(sub[::-1]), pairvar(-v for v in sub[::-1]))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        idxs = {c : i for i, c in enumerate(string.ascii_lowercase)}\\n        s = [idxs[c] for c in s]\\n        cs = set(s)\\n        def pairvar(s):\\n            ret, cur, seen = 0, 0, set()\\n            for v in s:\\n                seen.add(v)\\n                cur += v\\n                if cur < 0: cur, seen = 0, set()\\n                if len(seen) > 1: ret = max(ret, cur)\\n            return ret\\n        ans = 0\\n        for i in cs:\\n            for j in range(i + 1, 26):\\n                if j not in cs: continue\\n                sub = []\\n                for c in s:\\n                    if c == i: sub.append(1)\\n                    elif c == j: sub.append(-1)\\n                ans = max(ans, pairvar(sub), pairvar(-v for v in sub), pairvar(sub[::-1]), pairvar(-v for v in sub[::-1]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045076,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int find(string &str,int a,int b)\\n    {\\n        int ans=0;\\n        string s=str;\\n        for(int round=0;round<2;round++)\\n        {\\n            int counta,countb;\\n            counta=countb=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                counta+=(a==(s[i]-\\'a\\'));\\n                countb+=(b==(s[i]-\\'a\\'));\\n                // counta is higher\\n                if(counta&&countb)\\n                {\\n                    ans=max(ans,counta-countb);\\n                }\\n                if(countb>counta)\\n                {\\n                    counta=countb=0;\\n                }\\n            }\\n            reverse(s.begin(),s.end());\\n        }\\n        return ans;\\n    }\\n    int largestVariance(string s) \\n    {\\n        int ans=0;\\n        n=s.size();\\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                ans=max(ans,find(s,i,j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int find(string &str,int a,int b)\\n    {\\n        int ans=0;\\n        string s=str;\\n        for(int round=0;round<2;round++)\\n        {\\n            int counta,countb;\\n            counta=countb=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                counta+=(a==(s[i]-\\'a\\'));\\n                countb+=(b==(s[i]-\\'a\\'));\\n                // counta is higher\\n                if(counta&&countb)\\n                {\\n                    ans=max(ans,counta-countb);\\n                }\\n                if(countb>counta)\\n                {\\n                    counta=countb=0;\\n                }\\n            }\\n            reverse(s.begin(),s.end());\\n        }\\n        return ans;\\n    }\\n    int largestVariance(string s) \\n    {\\n        int ans=0;\\n        n=s.size();\\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                ans=max(ans,find(s,i,j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044294,
                "title": "python-kadane-s-algorithm-simple-solution",
                "content": "The idea is from [@amjadmoqade98](https://leetcode.com/amjadmoqade98/) \\'s [Kadanes algorithm solution (Java)\\n](https://leetcode.com/problems/substring-with-largest-variance/discuss/2038222/Kadanes-algorithm-solution-(Java))\\nAlso thanks to [@yuanzhi247012](https://leetcode.com/yuanzhi247012/) for the pythonic code [[Python3] enumerate all [a,b] combinations and do maximum subarray](https://leetcode.com/problems/substring-with-largest-variance/discuss/2041108/Python3-enumerate-all-ab-combinations-and-do-maximum-subarray)\\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        counter = Counter(s)\\n        res = 0\\n        \\n        for a, b in permutations(counter, 2):\\n            count_a, count_b = 0, 0\\n            remain_b = counter[b]\\n            for ch in s:\\n                if ch not in {a, b}:\\n                    continue\\n                if ch == a:\\n                    count_a += 1\\n                elif ch == b:\\n                    count_b += 1\\n                    remain_b -= 1\\n                # Kadane\\'s Algorithm, modified\\n                if count_a < count_b and remain_b > 0:\\n                    count_a, count_b = 0, 0\\n                if count_b > 0:\\n                    res = max(res, count_a - count_b) \\n\\n        return res\\n```\\n\\nThe original Kadane\\'s Algorithm would be like:\\n```\\n                if count_a < count_b:\\n                    count_a, count_b = 0, 0\\n                res = max(res, count_a - count_b)\\n```\\n\\nTo make sure we have at least one b, we check the current and remain count of b.\\n```\\n                if count_a < count_b and remain_b > 0:\\n                    count_a, count_b = 0, 0\\n                if count_b > 0:\\n                    res = max(res, count_a - count_b) \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        counter = Counter(s)\\n        res = 0\\n        \\n        for a, b in permutations(counter, 2):\\n            count_a, count_b = 0, 0\\n            remain_b = counter[b]\\n            for ch in s:\\n                if ch not in {a, b}:\\n                    continue\\n                if ch == a:\\n                    count_a += 1\\n                elif ch == b:\\n                    count_b += 1\\n                    remain_b -= 1\\n                # Kadane\\'s Algorithm, modified\\n                if count_a < count_b and remain_b > 0:\\n                    count_a, count_b = 0, 0\\n                if count_b > 0:\\n                    res = max(res, count_a - count_b) \\n\\n        return res\\n```\n```\\n                if count_a < count_b:\\n                    count_a, count_b = 0, 0\\n                res = max(res, count_a - count_b)\\n```\n```\\n                if count_a < count_b and remain_b > 0:\\n                    count_a, count_b = 0, 0\\n                if count_b > 0:\\n                    res = max(res, count_a - count_b) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043197,
                "title": "swift-prefix-sum-o-26-26-n",
                "content": "```\\nclass Solution {\\n    func largestVariance(_ s: String) -> Int {\\n        let buff = \"abcdefghijklmnopqrstuvwxyz\"\\n        var res = 0\\n        for x in buff\\n        {\\n            for y in buff where x != y\\n            {\\n                res = max(res, presum(s, x, y))\\n            }\\n        }\\n        return res\\n    }\\n    \\n    private func presum(_ s: String, _ x: Character, _ y: Character) -> Int\\n    {\\n        var ycount = 0, xcount = 0\\n        var mini = 100_000, curr = 0, maxi = 0\\n        for c in s where c == x || c == y\\n        {\\n            if c == x\\n            {\\n                curr -= 1\\n                xcount += 1\\n            }\\n            if c == y\\n            {\\n                curr += 1\\n                ycount += 1\\n            }\\n            maxi = max(maxi, curr, curr-mini)\\n            mini = min(mini, curr)\\n            if maxi == ycount {maxi -= 1}\\n        }\\n        if xcount == 0 {return 0}\\n        return maxi\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func largestVariance(_ s: String) -> Int {\\n        let buff = \"abcdefghijklmnopqrstuvwxyz\"\\n        var res = 0\\n        for x in buff\\n        {\\n            for y in buff where x != y\\n            {\\n                res = max(res, presum(s, x, y))\\n            }\\n        }\\n        return res\\n    }\\n    \\n    private func presum(_ s: String, _ x: Character, _ y: Character) -> Int\\n    {\\n        var ycount = 0, xcount = 0\\n        var mini = 100_000, curr = 0, maxi = 0\\n        for c in s where c == x || c == y\\n        {\\n            if c == x\\n            {\\n                curr -= 1\\n                xcount += 1\\n            }\\n            if c == y\\n            {\\n                curr += 1\\n                ycount += 1\\n            }\\n            maxi = max(maxi, curr, curr-mini)\\n            mini = min(mini, curr)\\n            if maxi == ycount {maxi -= 1}\\n        }\\n        if xcount == 0 {return 0}\\n        return maxi\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042854,
                "title": "c-easy-solution",
                "content": "\\t int largestVariance(string s) {\\n        int n = s.length();\\n        \\n        vector<int> fq(26, 0);\\n        for(char c: s)\\n            fq[c - \\'a\\']++;\\n        \\n        int ans = 0;\\n        for(char ch1 = \\'a\\'; ch1 <= \\'z\\'; ch1++) {\\n            for(char ch2 = \\'a\\'; ch2 <= \\'z\\'; ch2++) {\\n                if(ch1 == ch2 || fq[ch1 - \\'a\\'] == 0 || fq[ch2 - \\'a\\'] == 0)\\n                    continue;\\n                \\n                for(int times = 1; times <= 2; times++) {\\n                    \\n                    int cnt1 = 0, cnt2 = 0;\\n                    for(char c: s) {\\n                        cnt1 += (ch1 == c);\\n                        cnt2 += (ch2 == c);\\n                        \\n                        if(cnt2 > cnt1) \\n                            cnt1 = cnt2 = 0;\\n                        else if(cnt1 > 0 && cnt2 > 0)\\n                            ans = max(ans, cnt1 - cnt2);\\n                    }\\n                    \\n                    reverse(s.begin(), s.end());\\n                }\\n            }   \\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\t int largestVariance(string s) {\\n        int n = s.length();\\n        \\n        vector<int> fq(26, 0);\\n        for(char c: s)\\n            fq[c - \\'a\\']++;\\n        \\n        int ans = 0;\\n        for(char ch1 = \\'a\\'; ch1 <= \\'z\\'; ch1++) {\\n            for(char ch2 = \\'a\\'; ch2 <= \\'z\\'; ch2++) {\\n                if(ch1 == ch2 || fq[ch1 - \\'a\\'] == 0 || fq[ch2 - \\'a\\'] == 0)\\n                    continue;\\n                \\n                for(int times = 1; times <= 2; times++) {\\n                    \\n                    int cnt1 = 0, cnt2 = 0;\\n                    for(char c: s) {\\n                        cnt1 += (ch1 == c);\\n                        cnt2 += (ch2 == c);\\n                        \\n                        if(cnt2 > cnt1) \\n                            cnt1 = cnt2 = 0;\\n                        else if(cnt1 > 0 && cnt2 > 0)\\n                            ans = max(ans, cnt1 - cnt2);\\n                    }\\n                    \\n                    reverse(s.begin(), s.end());\\n                }\\n            }   \\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2041290,
                "title": "javascript-kadane-s-with-comments",
                "content": "```\\nvar largestVariance = function(s) {\\n    const arr = [\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\'];\\n    \\n    //Creating freq object to check for the last occurence\\n    let freq = {};\\n    for(let i=0; i<s.length; i++){\\n        if(freq[s[i]]){\\n            freq[s[i]]++;\\n        }else{\\n            freq[s[i]]=1;\\n        }\\n    }\\n        \\n    let max=0;\\n    for(let i=0; i<arr.length; i++){\\n        for(let j=0; j<arr.length; j++){\\n            if(i!==j){\\n                let iFreq=0; //Freq of arr[i] in current substring\\n                let jFreq=0; //Freq of arr[j] in current substring\\n                let iTotalFreq=0; //Total freq of arr[i] so far\\n                for(let k=0; k<s.length; k++){\\n                    if(s[k]===arr[i]){\\n                        iFreq++;\\n                        iTotalFreq++;\\n                        //Kadane\\'s algorithm logic\\n                        if(jFreq<iFreq && iTotalFreq<freq[arr[i]]){\\n                            iFreq=0;\\n                            jFreq=0;\\n                        }\\n                    }\\n                    if(s[k]===arr[j]){\\n                        jFreq++;\\n                    }\\n                    //Checking for max variance\\n                    if(jFreq-iFreq>max && iFreq){\\n                        max = jFreq-iFreq;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar largestVariance = function(s) {\\n    const arr = [\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\'];\\n    \\n    //Creating freq object to check for the last occurence\\n    let freq = {};\\n    for(let i=0; i<s.length; i++){\\n        if(freq[s[i]]){\\n            freq[s[i]]++;\\n        }else{\\n            freq[s[i]]=1;\\n        }\\n    }\\n        \\n    let max=0;\\n    for(let i=0; i<arr.length; i++){\\n        for(let j=0; j<arr.length; j++){\\n            if(i!==j){\\n                let iFreq=0; //Freq of arr[i] in current substring\\n                let jFreq=0; //Freq of arr[j] in current substring\\n                let iTotalFreq=0; //Total freq of arr[i] so far\\n                for(let k=0; k<s.length; k++){\\n                    if(s[k]===arr[i]){\\n                        iFreq++;\\n                        iTotalFreq++;\\n                        //Kadane\\'s algorithm logic\\n                        if(jFreq<iFreq && iTotalFreq<freq[arr[i]]){\\n                            iFreq=0;\\n                            jFreq=0;\\n                        }\\n                    }\\n                    if(s[k]===arr[j]){\\n                        jFreq++;\\n                    }\\n                    //Checking for max variance\\n                    if(jFreq-iFreq>max && iFreq){\\n                        max = jFreq-iFreq;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2041086,
                "title": "kadanes-algo-java",
                "content": "```\\nclass Solution {\\n    public int largestVariance(String s) {\\n       int [][] arr = new int[s.length()+1][26];\\n       for(int i=0;i<s.length();i++){\\n           char ch = s.charAt(i);\\n           if(i==0)arr[i+1][ch-\\'a\\'] = 1;\\n           else arr[i+1][ch-\\'a\\'] = arr[i][ch-\\'a\\'] + 1;\\n           if(i!=0){\\n             for(int k=0;k<26;k++){\\n                if(arr[i+1][k]==0)arr[i+1][k] = arr[i][k];\\n            }  \\n           }\\n       }\\n      int gbmax = 0;\\n      int countt =1;\\n        for(int i=s.length()-2;i>=0;i--){\\n            if(s.charAt(i)==s.charAt(i+1))countt++;\\n            else break;\\n        }\\n        if(countt==s.length())return 0;\\n       if(countt>1)gbmax = Math.max(gbmax,countt-1); \\n      for(int i=0;i<26;i++){\\n          for(int k=0;k<26;k++){\\n              int count =0;\\n              int max = Integer.MIN_VALUE;\\n              int start =0;\\n              for(int j=0;j<s.length();j++){\\n                  if(s.charAt(j)!=(char)(i + \\'a\\') && s.charAt(j)!=(char)(k + \\'a\\'))continue;\\n                  if(s.charAt(j)-\\'a\\'==i)count++;\\n                  else count--;\\n                  int one = arr[j+1][i] - arr[start][i];\\n                  int two = arr[j+1][k] - arr[start][k];\\n                  if(two!=0)max = Math.max(one - two,max);\\n                  if(count<0){\\n                      start = j + 1;\\n                      count = 0;\\n                  }\\n              }\\n              gbmax = Math.max(max,gbmax);\\n          }\\n      }\\n        return gbmax;\\n    }\\n    \\n    public void print(int [][]arr){\\n        for(int []b:arr){\\n            for(int a:b)System.out.print(a + \" \");\\n            System.out.println();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestVariance(String s) {\\n       int [][] arr = new int[s.length()+1][26];\\n       for(int i=0;i<s.length();i++){\\n           char ch = s.charAt(i);\\n           if(i==0)arr[i+1][ch-\\'a\\'] = 1;\\n           else arr[i+1][ch-\\'a\\'] = arr[i][ch-\\'a\\'] + 1;\\n           if(i!=0){\\n             for(int k=0;k<26;k++){\\n                if(arr[i+1][k]==0)arr[i+1][k] = arr[i][k];\\n            }  \\n           }\\n       }\\n      int gbmax = 0;\\n      int countt =1;\\n        for(int i=s.length()-2;i>=0;i--){\\n            if(s.charAt(i)==s.charAt(i+1))countt++;\\n            else break;\\n        }\\n        if(countt==s.length())return 0;\\n       if(countt>1)gbmax = Math.max(gbmax,countt-1); \\n      for(int i=0;i<26;i++){\\n          for(int k=0;k<26;k++){\\n              int count =0;\\n              int max = Integer.MIN_VALUE;\\n              int start =0;\\n              for(int j=0;j<s.length();j++){\\n                  if(s.charAt(j)!=(char)(i + \\'a\\') && s.charAt(j)!=(char)(k + \\'a\\'))continue;\\n                  if(s.charAt(j)-\\'a\\'==i)count++;\\n                  else count--;\\n                  int one = arr[j+1][i] - arr[start][i];\\n                  int two = arr[j+1][k] - arr[start][k];\\n                  if(two!=0)max = Math.max(one - two,max);\\n                  if(count<0){\\n                      start = j + 1;\\n                      count = 0;\\n                  }\\n              }\\n              gbmax = Math.max(max,gbmax);\\n          }\\n      }\\n        return gbmax;\\n    }\\n    \\n    public void print(int [][]arr){\\n        for(int []b:arr){\\n            for(int a:b)System.out.print(a + \" \");\\n            System.out.println();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040442,
                "title": "can-anyone-tell-me-why-this-o-676n-solution-is-giving-tle",
                "content": "class Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int n=s.length(),ans=0;\\n        unordered_set<char>st;\\n        for(auto &x:s){\\n            st.insert(x);\\n        }\\n        vector<int>prev(n),pref_min(n),pref(n);\\n        for(auto &ch1:st){\\n            for(auto &ch2:st){\\n                if(ch1==ch2){\\n                    continue;\\n                }\\n                for(int i=0;i<n;i++){\\n                    if(s[i]==ch2){\\n                        prev[i]=i;\\n                    }\\n                    else{\\n                        prev[i]=(i?prev[i-1]:-1);\\n                    }\\n                }\\n                for(int i=0;i<n;i++){\\n                    if(s[i]==ch1){\\n                        pref[i]=1;\\n                    }\\n                    else if(s[i]==ch2){\\n                        pref[i]=-1;\\n                    }\\n                    else{\\n                        pref[i]=0;\\n                    }\\n                    pref[i]+=(i?pref[i-1]:0);\\n                    pref_min[i]=min({0,(i?pref_min[i-1]:0),pref[i]});\\n                }\\n                int curr=0;\\n                for(int i=0;i<n;i++){\\n                    if(prev[i]==-1){\\n                        continue;\\n                    }\\n                    int curr1=pref[i]-(prev[i]?pref_min[prev[i]-1]:0);\\n                    curr=max(curr,curr1);\\n                }\\n                ans=max(ans,curr);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int n=s.length(),ans=0;\\n        unordered_set<char>st;\\n        for(auto &x:s){\\n            st.insert(x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2039689,
                "title": "python3-check-all-pairs-of-letters-multiple-solutions-with-some-optimisations",
                "content": "Every time we pick 2 letters `l1` and `l2`, try to find the max \"l1 over l2 variance\" (number of l1 - number of l2) in any substring.\\n\\nThere are at most 26\\\\*25 combinations.\\n\\nThere are many ways to find the max l1 over l2 variance. The tricy part is - the substring must contain at least 1 of each letter\\n- prefix sum (time O(n), space O(n))\\n\\t- similar to below\\n- optimized prefix sum (time O(n), space O(1))\\n\\t```python\\n    def largestVariance(self, s: str) -> int:\\n        ans = 0\\n        for a in string.ascii_lowercase:\\n            for b in string.ascii_lowercase:\\n                if a == b: continue\\n                ca = cb = mn = mn2 = 0\\n                for ch in s:\\n                    if ch == a: ca += 1\\n                    elif ch == b:\\n                        if ca and cb:\\n                            ans = max(ans, ca - cb - mn)\\n                        mn = min(mn, mn2)\\n                        cb += 1\\n                        mn2 = min(mn2, ca - cb)\\n                if ca and cb: ans = max(ans, ca - cb - mn)\\n        return ans\\n\\t```\\n- kadane algrithom (time O(n), space O(1))\\n\\t```python\\n    def largestVariance(self, s: str) -> int:\\n        ans = 0\\n        for a in string.ascii_lowercase:\\n            for b in string.ascii_lowercase:\\n                if a == b: continue\\n                c = 0\\n                cb = 0\\n                for ch in s:\\n                    if ch == a:\\n                        c += 1\\n                        if cb: ans = max(ans, c - (cb == 1))\\n                    elif ch == b:\\n                        if cb == 0: cb = 1\\n                        c -= 1\\n                        if c < 0:\\n                            c = 0\\n                            cb = 0\\n                        cb += 1\\n                        ans = max(ans, c - (cb == 1))\\n        return ans\\n\\t```\\n\\t\\nThere are something we can do to optimise it:\\n1. Count frequecies of all letters, if there\\'s only one letter (all letters the same), the result is 0\\n2. if there exists any letter appears exactly once, the result is `the max frequency - 1`\\n3. we only need to check the letters appeared in `s`\\n4. say, we try to count `l1` over `l2`, if `l1` appeared only once, the result won\\'t be > 0, we can skip it.\\n\\n```python3\\n    def largestVariance(self, s: str) -> int:\\n        cnt = Counter(s).most_common()\\n        if len(cnt) == 1: return 0\\n        if cnt[-1][1] == 1: return cnt[0][1] - cnt[-1][1]\\n        ans = 0\\n        for a, af in cnt:\\n            if af < 2: break\\n            for b, _ in cnt:\\n                if a == b: continue\\n                c = 0\\n                cb = 0\\n                for ch in s:\\n                    if ch == a:\\n                        c += 1\\n                        if cb: ans = max(ans, c - (cb == 1))\\n                    elif ch == b:\\n                        if cb == 0: cb = 1\\n                        c -= 1\\n                        if c < 0:\\n                            c = 0\\n                            cb = 0\\n                        cb += 1\\n                        ans = max(ans, c - (cb == 1))\\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```python\\n    def largestVariance(self, s: str) -> int:\\n        ans = 0\\n        for a in string.ascii_lowercase:\\n            for b in string.ascii_lowercase:\\n                if a == b: continue\\n                ca = cb = mn = mn2 = 0\\n                for ch in s:\\n                    if ch == a: ca += 1\\n                    elif ch == b:\\n                        if ca and cb:\\n                            ans = max(ans, ca - cb - mn)\\n                        mn = min(mn, mn2)\\n                        cb += 1\\n                        mn2 = min(mn2, ca - cb)\\n                if ca and cb: ans = max(ans, ca - cb - mn)\\n        return ans\\n\\t```\n```python\\n    def largestVariance(self, s: str) -> int:\\n        ans = 0\\n        for a in string.ascii_lowercase:\\n            for b in string.ascii_lowercase:\\n                if a == b: continue\\n                c = 0\\n                cb = 0\\n                for ch in s:\\n                    if ch == a:\\n                        c += 1\\n                        if cb: ans = max(ans, c - (cb == 1))\\n                    elif ch == b:\\n                        if cb == 0: cb = 1\\n                        c -= 1\\n                        if c < 0:\\n                            c = 0\\n                            cb = 0\\n                        cb += 1\\n                        ans = max(ans, c - (cb == 1))\\n        return ans\\n\\t```\n```python3\\n    def largestVariance(self, s: str) -> int:\\n        cnt = Counter(s).most_common()\\n        if len(cnt) == 1: return 0\\n        if cnt[-1][1] == 1: return cnt[0][1] - cnt[-1][1]\\n        ans = 0\\n        for a, af in cnt:\\n            if af < 2: break\\n            for b, _ in cnt:\\n                if a == b: continue\\n                c = 0\\n                cb = 0\\n                for ch in s:\\n                    if ch == a:\\n                        c += 1\\n                        if cb: ans = max(ans, c - (cb == 1))\\n                    elif ch == b:\\n                        if cb == 0: cb = 1\\n                        c -= 1\\n                        if c < 0:\\n                            c = 0\\n                            cb = 0\\n                        cb += 1\\n                        ans = max(ans, c - (cb == 1))\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2039147,
                "title": "modification-of-kadane-algo-with-commented-explanation",
                "content": "```\\ntypedef vector<int> VI;\\n\\nclass Solution {\\npublic:\\n    int kadane(string s, char ch1, char ch2){\\n        if(ch1 == ch2) return 0;\\n        //we have two storages -- max_so_far and curr_max\\n        int n = s.length();\\n        VI v(26, 0);\\n        v[ch1-\\'a\\'] = 1, v[ch2-\\'a\\'] = -1;\\n        int max_so_far = 0, curr_max_without = 0, curr_max_with = INT_MIN;\\n        //curr_max_with -- stores the max value if we include the element at curr index and have previously encountered a ch2 character and included its contribution \\n        //curr_max_without -- stores the max value if we don\\'t include the ch2 character at present index. if none ch2 character has been found till yet, then it stores the freq of ch1\\n        //curr_max_without -- should be reset to zero when we encounter ch2, as if it is inlcuded then this value goes to zero. when we encounter ch1, then we can simply increase it.\\n        //curr_max_with -- should be increased in presence of ch1 only if its not INT_MIN. when ch2 is encountered -- there can be two cases \\n        //case 1: we alredy have some value in curr_max_with\\n            //to take the contribution of the current ch2 into account, we subtract one from it\\n        //case 2: we dont\\n        \\n        //the most important thing to take care of is that curr_max_with and curr_max_without should \\'necessarily\\' be updated each time either of ch1/ch2 is encountered. you can\\'t skip the updates in these.\\n        \\n        \\n        //when we encounter ch2 we have to condider two cases which can give optimal answer\\n        //Case 1: we start the left boundary of the windown from just right of the last occurence of ch2 and put the right boundary of the window on the current occurence of ch2. to get its answer we use the term -- curr_max_without - 1\\n        //Case 2: we start the left boundary of the window from some index which is to the left of the last occurence of ch2(we actually don\\'t care about the exact position of the left boundary) and put the right boundary of the window on the current occurence of ch2. to get the value we use the term -- curr_max_with - 1\\n        //taking max of these gives the optimal answer value to store in curr_max_with to include the effect of current occurence of ch2\\n        //as the current character is ch2 and we have to include its effect into both curr_max_with and curr_max_without necessarily, curr_max_without = 0\\n        \\n        //we we encounter ch1 we can have two cases\\n        //Case 1: we didn\\'t encounter any ch2 so far. in that case we only update the value of curr_max_without by 1\\n        //Case 2: we had encountered ch2 atleast once. in that case the value stored in curr_max_with can be increase by one. the left boundary in case of this window lies either on the last occurence of ch2 or somewher to the left of it , while the right boundary lies on the current occurence of ch1.\\n        for(int i=0;i<n;i++){\\n            if(s[i] == ch2){\\n                curr_max_with = max(curr_max_with != INT_MIN ? curr_max_with-1 : curr_max_with, curr_max_without - 1);\\n                curr_max_without = 0;\\n            }\\n            else if(s[i] == ch1){\\n                curr_max_without++;\\n                if(curr_max_with != INT_MIN) curr_max_with++;\\n            }\\n            max_so_far = max(max_so_far, curr_max_with);\\n        }\\n        return max_so_far;\\n    }\\n    int largestVariance(string s) {\\n        int n = s.length();\\n        int ans = 0;\\n        VI presence(26, 0);\\n        for(int i=0;i<n;i++) presence[s[i]-\\'a\\'] = 1; \\n        for(char ch1 = \\'a\\';ch1 <= \\'z\\';ch1++){\\n            for(char ch2 = \\'a\\';ch2 <= \\'z\\';ch2++){\\n                if(presence[ch1-\\'a\\'] && presence[ch2-\\'a\\']) ans = max(ans, kadane(s, ch1, ch2));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\ntypedef vector<int> VI;\\n\\nclass Solution {\\npublic:\\n    int kadane(string s, char ch1, char ch2){\\n        if(ch1 == ch2) return 0;\\n        //we have two storages -- max_so_far and curr_max\\n        int n = s.length();\\n        VI v(26, 0);\\n        v[ch1-\\'a\\'] = 1, v[ch2-\\'a\\'] = -1;\\n        int max_so_far = 0, curr_max_without = 0, curr_max_with = INT_MIN;\\n        //curr_max_with -- stores the max value if we include the element at curr index and have previously encountered a ch2 character and included its contribution \\n        //curr_max_without -- stores the max value if we don\\'t include the ch2 character at present index. if none ch2 character has been found till yet, then it stores the freq of ch1\\n        //curr_max_without -- should be reset to zero when we encounter ch2, as if it is inlcuded then this value goes to zero. when we encounter ch1, then we can simply increase it.\\n        //curr_max_with -- should be increased in presence of ch1 only if its not INT_MIN. when ch2 is encountered -- there can be two cases \\n        //case 1: we alredy have some value in curr_max_with\\n            //to take the contribution of the current ch2 into account, we subtract one from it\\n        //case 2: we dont\\n        \\n        //the most important thing to take care of is that curr_max_with and curr_max_without should \\'necessarily\\' be updated each time either of ch1/ch2 is encountered. you can\\'t skip the updates in these.\\n        \\n        \\n        //when we encounter ch2 we have to condider two cases which can give optimal answer\\n        //Case 1: we start the left boundary of the windown from just right of the last occurence of ch2 and put the right boundary of the window on the current occurence of ch2. to get its answer we use the term -- curr_max_without - 1\\n        //Case 2: we start the left boundary of the window from some index which is to the left of the last occurence of ch2(we actually don\\'t care about the exact position of the left boundary) and put the right boundary of the window on the current occurence of ch2. to get the value we use the term -- curr_max_with - 1\\n        //taking max of these gives the optimal answer value to store in curr_max_with to include the effect of current occurence of ch2\\n        //as the current character is ch2 and we have to include its effect into both curr_max_with and curr_max_without necessarily, curr_max_without = 0\\n        \\n        //we we encounter ch1 we can have two cases\\n        //Case 1: we didn\\'t encounter any ch2 so far. in that case we only update the value of curr_max_without by 1\\n        //Case 2: we had encountered ch2 atleast once. in that case the value stored in curr_max_with can be increase by one. the left boundary in case of this window lies either on the last occurence of ch2 or somewher to the left of it , while the right boundary lies on the current occurence of ch1.\\n        for(int i=0;i<n;i++){\\n            if(s[i] == ch2){\\n                curr_max_with = max(curr_max_with != INT_MIN ? curr_max_with-1 : curr_max_with, curr_max_without - 1);\\n                curr_max_without = 0;\\n            }\\n            else if(s[i] == ch1){\\n                curr_max_without++;\\n                if(curr_max_with != INT_MIN) curr_max_with++;\\n            }\\n            max_so_far = max(max_so_far, curr_max_with);\\n        }\\n        return max_so_far;\\n    }\\n    int largestVariance(string s) {\\n        int n = s.length();\\n        int ans = 0;\\n        VI presence(26, 0);\\n        for(int i=0;i<n;i++) presence[s[i]-\\'a\\'] = 1; \\n        for(char ch1 = \\'a\\';ch1 <= \\'z\\';ch1++){\\n            for(char ch2 = \\'a\\';ch2 <= \\'z\\';ch2++){\\n                if(presence[ch1-\\'a\\'] && presence[ch2-\\'a\\']) ans = max(ans, kadane(s, ch1, ch2));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038742,
                "title": "javascript-prefix-min-1380ms",
                "content": "```\\nconst largestVariance = (s) => {\\n    let se = new Set(s), n = s.length, res = 0;\\n    for (const x of se) { // max\\n        for (const y of se) { // min\\n            if (x != y) {\\n                let pre = Array(n + 1).fill(0), preX, preY, diff = 0;\\n                for (let i = 0; i < n; i++) {\\n                    if (s[i] == x) {\\n                        preX = i + 1;\\n                        diff++;\\n                    }\\n                    if (s[i] == y) {\\n                        preY = i + 1;\\n                        diff--;\\n                    } \\n                    pre[i + 1] = Math.min(pre[i], diff);\\n                    if (preX == undefined || preY == undefined) continue;\\n                    res = Math.max(res, diff - pre[Math.min(preX, preY) - 1]);\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\nconst largestVariance = (s) => {\\n    let se = new Set(s), n = s.length, res = 0;\\n    for (const x of se) { // max\\n        for (const y of se) { // min\\n            if (x != y) {\\n                let pre = Array(n + 1).fill(0), preX, preY, diff = 0;\\n                for (let i = 0; i < n; i++) {\\n                    if (s[i] == x) {\\n                        preX = i + 1;\\n                        diff++;\\n                    }\\n                    if (s[i] == y) {\\n                        preY = i + 1;\\n                        diff--;\\n                    } \\n                    pre[i + 1] = Math.min(pre[i], diff);\\n                    if (preX == undefined || preY == undefined) continue;\\n                    res = Math.max(res, diff - pre[Math.min(preX, preY) - 1]);\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038322,
                "title": "could-somebody-have-a-look-at-my-approach-question-worded-weirdly",
                "content": "My initial approach is to iterate over every pair of characters. Then do a linear search to track the difference between the two characters of this new string in `diff` array. Then my idea was to  use this difference array to calculate the maximum difference in the positive and negative direction, which is the two ends of our selection.\\n\\nIt seems to work until a particularly long test case which makes debugging very hard. Not sure if my logic is completely flawed (especially the difference part).  Would love some insights or what the correct approach is.\\n\\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        chars = set()\\n        for c in s:\\n            chars.add(c)\\n            \\n        chars = list(chars)\\n        maxvar = 0\\n        for i in range(len(chars)):\\n            for j in range(i+1, len(chars)):\\n                maxvar = max(maxvar, self.maxVariance(s, chars[i], chars[j]))\\n        return maxvar\\n                    \\n                    \\n    def maxVariance(self, s, a, b):\\n        new_s = [c for c in s if c in [a,b]]\\n        freqa = 0\\n        freqb = 0\\n        diff = []\\n        for c in new_s:\\n            if c == a:\\n                freqa += 1\\n            if c == b:\\n                freqb += 1\\n            if freqa > 0 and freqb > 0:\\n                diff.append(freqa-freqb)\\n            else:\\n                diff.append(0)\\n            \\n\\n        \\n        return abs(max(diff)) + abs(min(diff))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        chars = set()\\n        for c in s:\\n            chars.add(c)\\n            \\n        chars = list(chars)\\n        maxvar = 0\\n        for i in range(len(chars)):\\n            for j in range(i+1, len(chars)):\\n                maxvar = max(maxvar, self.maxVariance(s, chars[i], chars[j]))\\n        return maxvar\\n                    \\n                    \\n    def maxVariance(self, s, a, b):\\n        new_s = [c for c in s if c in [a,b]]\\n        freqa = 0\\n        freqb = 0\\n        diff = []\\n        for c in new_s:\\n            if c == a:\\n                freqa += 1\\n            if c == b:\\n                freqb += 1\\n            if freqa > 0 and freqb > 0:\\n                diff.append(freqa-freqb)\\n            else:\\n                diff.append(0)\\n            \\n\\n        \\n        return abs(max(diff)) + abs(min(diff))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073640,
                "title": "python-16-lines-with-comments-beats-85-and-97",
                "content": "# Intuition\\nTry all permutations of two characters, see which has the largest substring variance.\\n\\n# Approach\\nCalculating the largest substring variance for two given letters is the hard part.\\n\\n# Complexity\\nWhere $$n$$ is the length of $$s$$:\\n\\n- Time complexity:\\n$$O(n)$$, per permutation of two letters. At most $$O(n^2)$$ unique permutations of letters. Overall $$O(n^3)$$.\\n\\n- Space complexity:\\n$$O(1)$$, per permutation of two letters (nothing extra stored).\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        def variance(lesser, greater):\\n            lesser_count = greater_count = var = 0\\n\\n            for c in s:\\n                if c == lesser:\\n                    lesser_count += 1\\n                    if lesser_count > greater_count: # where we are is worse than simply starting fresh at the next position\\n                        lesser_count = greater_count = 0\\n                elif c == greater:\\n                    greater_count += 1\\n                    var = max(var, greater_count - max(lesser_count, 1)) # if lesser_count is 0, consider it to be 1 (either before or after the current \\'greater\\' only stretch, there is guaranteed to be one \\'lesser\\' to make it a valid substring)\\n                # ignore irrelivant letters\\n            return var\\n\\n        return max([0] + [variance(a, b) for a, b in permutations(set(s), 2)]) # try all combinations of lesser and greater\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        def variance(lesser, greater):\\n            lesser_count = greater_count = var = 0\\n\\n            for c in s:\\n                if c == lesser:\\n                    lesser_count += 1\\n                    if lesser_count > greater_count: # where we are is worse than simply starting fresh at the next position\\n                        lesser_count = greater_count = 0\\n                elif c == greater:\\n                    greater_count += 1\\n                    var = max(var, greater_count - max(lesser_count, 1)) # if lesser_count is 0, consider it to be 1 (either before or after the current \\'greater\\' only stretch, there is guaranteed to be one \\'lesser\\' to make it a valid substring)\\n                # ignore irrelivant letters\\n            return var\\n\\n        return max([0] + [variance(a, b) for a, b in permutations(set(s), 2)]) # try all combinations of lesser and greater\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033098,
                "title": "faster-than-editorial-easy-to-understand-o-n-k-time-o-k-2-space-complexity-k-26-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s consider the difference of the count of any letters `a` and `b` in a string `s_i`: `diff(a,b,s_i) = count(a,s_i) - count(b,s_i)` (this can be negative if `b` appears more than `a`). We calculate all `diff(a,b,prefix(s))` and the answer should be `max(diff(a,b,prefix(s))) - min(diff(a,b,prefix(s)))`. \\n\\nWhy? Because the `diff` is just the suffix sum. For example, `s = \\'abbbaaabaaa\\'`. If we want to calculate for a substr from 2nd to 6th: `diff(\\'a\\',\\'b\\',\\'bbbaaa\\')`, we can substract the `diff` of the two prefixes of `s`: `diff(\\'a\\',\\'b\\',\\'bbbaaa\\') = diff(\\'a\\',\\'b\\',\\'abbbaaa\\') - diff(\\'a\\',\\'b\\',\\'a\\')`. Similarly, the `diff` of any substring can be expressed as the a substraction of two `diff` of the prefixes. In this example, the `diff(\\'a\\',\\'b\\',s_i)` goes to `min = -2` at the suffix `\\'abbb\\'` with 4 letters, then increases and finally reaches the `max = 3` at the end `\\'abbbaaabaaa\\'` with 11 letters. The substring from the 5th to the 11th, which is `\\'aaabaaa\\'`, have the biggest variance.\\n\\nOf course, we also need to be careful about the substrings that do not contains `a` or `b`, such as `diff(\\'a\\',\\'b\\',\\'aaa\\')` which cannot be considered as a valid answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start from `s_i = \\'\\'` and add a letter to the end each time to get `diff(a,b,prefix(s))` efficiently. For example, if the new letter we add to the end is `\\'a\\'`, only the `diff` related to `\\'a\\'` like `diff(\\'a\\',\\'c\\',s_i)` will be updated, and we don\\'t need to care about others like `diff(\\'x\\',\\'y\\',s_i)`. Thus, the time complexity is `O(n*k)` where `k` is 26 here.\\n\\nWe can easily notice `diff(a,b,s_i) = -diff(b,a,s_i)` from the definition, so `max(diff(a,b,prefix(s)))` and `-min(diff(b,a,prefix(s)))` are the same. We can consider only the `max` as `ans = max(diff(a,b,prefix(s))) + max(diff(b,a,prefix(s)))`.\\n\\nIt\\'s very annoying to eliminate invalid substrings. We can:\\n1. Only update ans from `diff(a,b)` and `diff(b,a)` if both `a` and `b` are seen;\\n2. Track if the `max` value is \\'fresh\\': if we see `a`, `count(a)` will increase, so `max(diff(a,b,s_i))` (`b` can be any letter) may update. If it really increases,  this prefix `s_i` may be the start of the optimal substr, and we mark it as \\'fresh\\', otherwise \\'not fresh\\'. If we see many `b` later, `max(diff(b,a,s_i_new))` can get large. When we use the difference between `s_i` and `s_i_new` as the substring to update the answer, if `max(diff(a,b))` is still \\'fresh\\', this means this substring is invalid, because we didn\\'t see `a` in this substring (otherwise it is not fresh). However, according to rule 1, both `a` and `b` are seen, so we can add a `a` from the previous letters, which will let the difference decrease 1. <br> For example, `s=\\'cacbbcb\\'`. `diff(\\'a\\',\\'b\\',s_i)` gets max at the prefix `s_i=\\'ca\\'`, and `diff(\\'b\\',\\'a\\',s_i)` gets max at the prefix `s_i=\\'cacbbcb\\'`. The substring `\\'cbbcb\\'` doesn\\'t contains `\\'a\\'`, but we can add an `\\'a\\'` to the beginning as `\\'acbbcb\\'`\\n3. Due to rule 1, there is a special case is missing: when `b` first appears, it can make the previous `s_i` valid and be the answer. <br>For example, `s=\\'aaaaaab\\'`. According to rule 1, `ans` will not update until it reaches the end. We can update the `ans` when we first see `\\'b\\'`\\n\\nPlease comment if my method to test and eliminate invalid substrings is wrong or you have a better method. Thanks!\\n\\n# Complexity\\n- Time complexity:\\n  $$O(n*k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  $$O(k^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        ans = 0\\n        occ = [0] * 26\\n        max_diff = [[0]*26 for _ in range(26)]\\n        # Note: initialize max_fresh to True or False or anything is OK\\n        max_fresh = [[0]*26 for _ in range(26)]\\n        for c in s:\\n            c_i = ord(c) - ord(\\'a\\')\\n            occ[c_i] += 1\\n            for i in range(26):\\n                diff = occ[c_i] - occ[i]\\n                if diff > max_diff[c_i][i]:\\n                    max_diff[c_i][i] = diff\\n                    max_fresh[c_i][i] = True\\n                else:\\n                    max_fresh[c_i][i] = False\\n                if occ[i] > 0:\\n                    if occ[c_i] == 1:\\n                        # special case: prev substr will get valid when c first appears\\n                        ans = max(ans, max_diff[i][c_i] - 1)\\n                        continue\\n                    # var CANNOT be max_diff[i][c_i] + max_diff[c_i][i], because\\n                    # we can only test the substr end with c is valid or not\\n                    var = max_diff[i][c_i] + diff\\n                    if max_fresh[i][c_i]:\\n                        var -= 1\\n                    ans = max(ans, var)\\n                    \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        ans = 0\\n        occ = [0] * 26\\n        max_diff = [[0]*26 for _ in range(26)]\\n        # Note: initialize max_fresh to True or False or anything is OK\\n        max_fresh = [[0]*26 for _ in range(26)]\\n        for c in s:\\n            c_i = ord(c) - ord(\\'a\\')\\n            occ[c_i] += 1\\n            for i in range(26):\\n                diff = occ[c_i] - occ[i]\\n                if diff > max_diff[c_i][i]:\\n                    max_diff[c_i][i] = diff\\n                    max_fresh[c_i][i] = True\\n                else:\\n                    max_fresh[c_i][i] = False\\n                if occ[i] > 0:\\n                    if occ[c_i] == 1:\\n                        # special case: prev substr will get valid when c first appears\\n                        ans = max(ans, max_diff[i][c_i] - 1)\\n                        continue\\n                    # var CANNOT be max_diff[i][c_i] + max_diff[c_i][i], because\\n                    # we can only test the substr end with c is valid or not\\n                    var = max_diff[i][c_i] + diff\\n                    if max_fresh[i][c_i]:\\n                        var -= 1\\n                    ans = max(ans, var)\\n                    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983486,
                "title": "golang-kadane",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(26*26*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc largestVariance(s string) int {\\n    mapper := make(map[rune]int)\\n    for _, v := range s {\\n        mapper[v] = 1\\n    }\\n    m := 0\\n    for a := range mapper {\\n        for b := range mapper {\\n            if a == b {\\n                continue\\n            }\\n            m = max(m, kadane(s, a, b))\\n        }\\n    }\\n    return m\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc kadane(s string, a, b rune) int {\\n    re := -1\\n     m := 0\\n    hasB := 0\\n    for _, v := range s {\\n        if v == a {\\n            if re == -1 {\\n                hasB = 1\\n            }\\n            re = max(-1, re) + 1\\n            \\n            // continue\\n        }\\n        if v == b {\\n            if hasB == 1 {\\n                re += 1\\n                hasB = 0\\n            }\\n            re = max(0, re) - 1\\n        }\\n        m = max(m, re)\\n    }\\n    return m\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc largestVariance(s string) int {\\n    mapper := make(map[rune]int)\\n    for _, v := range s {\\n        mapper[v] = 1\\n    }\\n    m := 0\\n    for a := range mapper {\\n        for b := range mapper {\\n            if a == b {\\n                continue\\n            }\\n            m = max(m, kadane(s, a, b))\\n        }\\n    }\\n    return m\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc kadane(s string, a, b rune) int {\\n    re := -1\\n     m := 0\\n    hasB := 0\\n    for _, v := range s {\\n        if v == a {\\n            if re == -1 {\\n                hasB = 1\\n            }\\n            re = max(-1, re) + 1\\n            \\n            // continue\\n        }\\n        if v == b {\\n            if hasB == 1 {\\n                re += 1\\n                hasB = 0\\n            }\\n            re = max(0, re) - 1\\n        }\\n        m = max(m, re)\\n    }\\n    return m\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3907643,
                "title": "two-iterations-over-alphabets-nothing-fancy-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        unique_s = \\'\\'.join(set(s))\\n        max_var_global = 0\\n        for i in unique_s:\\n            for j in unique_s:\\n                if i==j:\\n                    continue\\n                min_var = float(\"inf\")\\n                max_var = float(\"-inf\")\\n                ind_lag = 0\\n                s_new = []\\n                for k in range(0,len(s)):\\n                    if s[k] in [i,j]:\\n                        s_new.append(s[k])\\n                s_new.append(\\'\\n```)\\n                s_new = \\'\\'.join(s_new)\\n                forward_count_first = [0 for _ in range(len(s_new))]\\n                forward_count_second = [0 for _ in range(len(s_new))]\\n                for l in range(1,len(s_new)):\\n                    forward_count_first[l] = forward_count_first[l-1]+int(s_new[l-1]==i)\\n                    forward_count_second[l] = forward_count_second[l-1]+int(s_new[l-1]==j)\\n\\n                for ind in range(1,len(s_new)):\\n                    if forward_count_first[ind]>0 and forward_count_second[ind]>0:\\n                        max_var = forward_count_second[ind]-forward_count_first[ind]\\n                    \\n                    if forward_count_second[ind_lag]<forward_count_second[ind] and forward_count_first[ind_lag]<forward_count_first[ind]:\\n                        min_var = min(min_var, forward_count_second[ind_lag]-forward_count_first[ind_lag])\\n                        ind_lag += 1\\n                    max_var_global = max(max_var_global, max_var-min_var)\\n        return max_var_global\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        unique_s = \\'\\'.join(set(s))\\n        max_var_global = 0\\n        for i in unique_s:\\n            for j in unique_s:\\n                if i==j:\\n                    continue\\n                min_var = float(\"inf\")\\n                max_var = float(\"-inf\")\\n                ind_lag = 0\\n                s_new = []\\n                for k in range(0,len(s)):\\n                    if s[k] in [i,j]:\\n                        s_new.append(s[k])\\n                s_new.append(\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885816,
                "title": "equivalence-to-the-largest-summing-subseq",
                "content": "# Intuition\\nThis problem is in a way equivalent to the largest summing subsequence.\\n\\nAt first, we notice that the alphabet in the given string contains english lowercase letters only, this indicates that multiplying some factors in the same level of the polinomial of all english alphabet is acceptable.\\n\\nBecause e.g. O(P(26)N) = O(cN) = O(N), where c is a constant.\\n\\nThis gives us a hint that, we can convert the measure of $max_{c_1, c_2\\\\in V_{eng}, c_1 \\\\neq c_2}Count(c_1) - Count(c_2)$ to the following subproblem:\\n\\nIn each round we select a pair of different letters and measure their difference, while the other letters do nothing about the results. Then select the maximum difference over all such pairs.\\n\\nThen the idea of equivalence of this to the maximum sum subsequence is inspired by the other solutions.\\n\\nIn their solutions, they calculate the difference between the c1 (or c_large in the code) and c2 (or c_little in the code) from one end to the other in a window.\\n\\nWhenever #c1-#c2 == -1 (there are one more c2 than c1 in the current window), one\\'d better ditch the old c1 and c2 collection (since they only contribute -1 to the difference and it doesn\\'t worth it to include them) and start a new window.\\n\\nThis subproblem is equivalent to the largest sum subsequence problem, where we replace all c1 with a score of 1, while the c2-s are replaced with a score of -1.\\n\\nThe only three differences between this problem and the MSS question are that:\\n1. One needs to remember the number of possitive and negative letters contributing to the maximum sum (a.k.a. number of the c1 and c2)\\n2. Whenever it is possible to start anew from a new-comming c_1 (values[-1] + 1 <= 1), don\\'t rush to start from the new c_1. Instead, for the equal case (values[-1] + 1 == 1), the new c_1 should be included to the old window\\n3. One thing need to notice is that this equivalence only happens when the c_1 occurs before c_2. Therefore we need to do a reversed-batch for each pair of letters.\\n\\n# Complexity\\n- Time complexity:\\n$O(N)$\\n\\n- Space complexity:\\n$O(N)$\\n\\n# Code\\n```python\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        def search_max_var(large_c, little_c):\\n            p = 0\\n            while s[p] != large_c and s[p] != little_c:\\n                p += 1\\n            n_large = [1 if s[p] == large_c else 0]\\n            n_little = [1 if s[p] == little_c else 0]\\n            values = [-1 if s[p] == little_c else 1]\\n            for idx, c in enumerate(s[p + 1 :], p + 1):\\n                if c == large_c:\\n                    if values[-1] + 1 >= 1:\\n                        values.append(values[-1] + 1)\\n                        n_large.append(n_large[-1] + 1)\\n                        n_little.append(n_little[-1])\\n                    else:\\n                        values.append(1)\\n                        n_large.append(1)\\n                        n_little.append(0)\\n                elif c == little_c:\\n                    if values[-1] - 1 > -1:\\n                        values.append(values[-1] - 1)\\n                        n_large.append(n_large[-1])\\n                        n_little.append(n_little[-1] + 1)\\n                    else:\\n                        values.append(-1)\\n                        n_large.append(0)\\n                        n_little.append(1)\\n            res = 0\\n            for a, b in zip(n_large, n_little):\\n                if b != 0:\\n                    res = max(res, a - b)\\n            return res\\n\\n        res = 0\\n        for c1 in set(s):\\n            for c2 in set(s):\\n                if c1 == c2:\\n                    continue\\n                res = max(search_max_var(c1, c2), res)\\n                s = s[::-1]\\n                res = max(search_max_var(c1, c2), res)\\n                s = s[::-1]\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        def search_max_var(large_c, little_c):\\n            p = 0\\n            while s[p] != large_c and s[p] != little_c:\\n                p += 1\\n            n_large = [1 if s[p] == large_c else 0]\\n            n_little = [1 if s[p] == little_c else 0]\\n            values = [-1 if s[p] == little_c else 1]\\n            for idx, c in enumerate(s[p + 1 :], p + 1):\\n                if c == large_c:\\n                    if values[-1] + 1 >= 1:\\n                        values.append(values[-1] + 1)\\n                        n_large.append(n_large[-1] + 1)\\n                        n_little.append(n_little[-1])\\n                    else:\\n                        values.append(1)\\n                        n_large.append(1)\\n                        n_little.append(0)\\n                elif c == little_c:\\n                    if values[-1] - 1 > -1:\\n                        values.append(values[-1] - 1)\\n                        n_large.append(n_large[-1])\\n                        n_little.append(n_little[-1] + 1)\\n                    else:\\n                        values.append(-1)\\n                        n_large.append(0)\\n                        n_little.append(1)\\n            res = 0\\n            for a, b in zip(n_large, n_little):\\n                if b != 0:\\n                    res = max(res, a - b)\\n            return res\\n\\n        res = 0\\n        for c1 in set(s):\\n            for c2 in set(s):\\n                if c1 == c2:\\n                    continue\\n                res = max(search_max_var(c1, c2), res)\\n                s = s[::-1]\\n                res = max(search_max_var(c1, c2), res)\\n                s = s[::-1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867758,
                "title": "nk-2-to-nk-using-extra-memory",
                "content": "# Intuition\\nIntuition comes from Editorial.  The using-extra-memory insight comes from\\nthis [post](https://leetcode.com/problems/substring-with-largest-variance/solutions/3747221/o-nk-solution-in-python-faster-than-98/).\\n\\nThe code I wrote based on the editorial text:\\n```\\ndef largestVariance4(self, s: str) -> int:\\n    ans = 0\\n    ctr = Counter(s)\\n    for major_ch in ctr.keys():\\n        for minor_ch in ctr.keys():\\n            if major_ch == minor_ch:\\n                continue\\n\\n            major_cnt, minor_cnt = 0, 0\\n            rem_minor = ctr[minor_ch]\\n            rem_major = ctr[major_ch]\\n            for ch in s:\\n                if ch == major_ch:\\n                    major_cnt += 1\\n                    rem_major -= 1\\n                elif ch == minor_ch:\\n                    minor_cnt += 1\\n                    rem_minor -= 1\\n                    if minor_cnt > major_cnt:\\n                        major_cnt = 0\\n                        minor_cnt = 0\\n                        if rem_minor == 0:\\n                            ans = max(ans, rem_major - 1)\\n                            break\\n\\n                if minor_cnt > 0:\\n                    ans = max(ans, major_cnt - minor_cnt)\\n\\n    return ans\\n```\\n\\nNote: \"major\" means highest count, \"minor\" - lowest count\\nAt any given point, `major_cnt - minor_cnt` might not be valid for the current proposed major and minor char in a given sequence.  There might be another \"major\" and/or another \"minor\" character.  However, `major_cnt - minor_cnt` will never be larger then the true result for a sequence.  Going over all the character pairs yields the correct final result!\\n\\nNote2:  we keep `rem_minor` and `rem_major` - remaining minor/major chars.  When there\\'s the last minor char., we have to have it in the sequence: the proposed result is `ans = max(ans, rem_major - 1)`, where 1 is the remaining minor char.\\n\\nThis solution is O(Nk^2) RT where k - is size of the string s alphabet.\\nSpace is O(k) to store the remaining char count.\\n\\nNow, for the next optimization, instead of going over the (major,minor) letter pairs like (a,b) and (b,a) 2 separate times, we can go over (a,b) once and store (b,a) run in memory while processing (a,b).  The code is logically the same, but the run time is O(Nk).  Space is O(Nk).\\n\\n# Approach\\nReverse the loops in the Editorial approach: calculate answer for every subsequence ending at character ch in the string s.\\n\\nFor every proposed major char. x in string s, go over all possible minor chars y\\'s.  Update (x,y) and reverse (y,x) pair counts in memory `major_minor_dic` to (x_cnt+1,y_cnt) and (y_cnt,x_cnt+1), respectively. \\n\\nDo Kadane\\'s algo part on the reverse pair, since that\\'s where the minor char count increases and could become higher than the count of the major char.\\n\\nSince, the minor char may come after the major one like in \"bbbc\", we\\'d better calculate `rev_rel_cnts[MAJOR_IDX] - rev_rel_cnts[MINOR_IDX]` on the reverse pair as well.\\n\\n# Complexity\\n- Time complexity: O(Nk)\\n\\n- Space complexity: O(Nk) \\n\\n# Code\\n```\\nfrom collections import Counter, defaultdict\\n\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        MAJOR_IDX, MINOR_IDX = 0, 1\\n        ans = 0\\n        remain_ctr = Counter(s)\\n        major_minor_dic = defaultdict(lambda: [0,0])  # store char. pairs\\n        for i,major_ch in enumerate(s):\\n            remain_ctr[major_ch] -= 1\\n            for minor_ch in remain_ctr.keys():\\n                if major_ch == minor_ch:\\n                    continue\\n                rel_cnts = major_minor_dic[major_ch, minor_ch]\\n                rel_cnts[MAJOR_IDX] += 1\\n                rev_rel_cnts = major_minor_dic[minor_ch, major_ch]\\n                rev_rel_cnts[MINOR_IDX] += 1\\n\\n                if rev_rel_cnts[MINOR_IDX] > rev_rel_cnts[MAJOR_IDX]:\\n                    rev_rel_cnts[MAJOR_IDX] = 0\\n                    rev_rel_cnts[MINOR_IDX] = 0\\n                    if remain_ctr[major_ch] == 0:\\n                        ans = max(ans, remain_ctr[minor_ch] - 1)\\n\\n                if rel_cnts[MINOR_IDX] > 0:\\n                    ans = max(ans, rel_cnts[MAJOR_IDX] - rel_cnts[MINOR_IDX])\\n                if rev_rel_cnts[MINOR_IDX] > 0:\\n                    ans = max(ans, rev_rel_cnts[MAJOR_IDX] - rev_rel_cnts[MINOR_IDX])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef largestVariance4(self, s: str) -> int:\\n    ans = 0\\n    ctr = Counter(s)\\n    for major_ch in ctr.keys():\\n        for minor_ch in ctr.keys():\\n            if major_ch == minor_ch:\\n                continue\\n\\n            major_cnt, minor_cnt = 0, 0\\n            rem_minor = ctr[minor_ch]\\n            rem_major = ctr[major_ch]\\n            for ch in s:\\n                if ch == major_ch:\\n                    major_cnt += 1\\n                    rem_major -= 1\\n                elif ch == minor_ch:\\n                    minor_cnt += 1\\n                    rem_minor -= 1\\n                    if minor_cnt > major_cnt:\\n                        major_cnt = 0\\n                        minor_cnt = 0\\n                        if rem_minor == 0:\\n                            ans = max(ans, rem_major - 1)\\n                            break\\n\\n                if minor_cnt > 0:\\n                    ans = max(ans, major_cnt - minor_cnt)\\n\\n    return ans\\n```\n```\\nfrom collections import Counter, defaultdict\\n\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        MAJOR_IDX, MINOR_IDX = 0, 1\\n        ans = 0\\n        remain_ctr = Counter(s)\\n        major_minor_dic = defaultdict(lambda: [0,0])  # store char. pairs\\n        for i,major_ch in enumerate(s):\\n            remain_ctr[major_ch] -= 1\\n            for minor_ch in remain_ctr.keys():\\n                if major_ch == minor_ch:\\n                    continue\\n                rel_cnts = major_minor_dic[major_ch, minor_ch]\\n                rel_cnts[MAJOR_IDX] += 1\\n                rev_rel_cnts = major_minor_dic[minor_ch, major_ch]\\n                rev_rel_cnts[MINOR_IDX] += 1\\n\\n                if rev_rel_cnts[MINOR_IDX] > rev_rel_cnts[MAJOR_IDX]:\\n                    rev_rel_cnts[MAJOR_IDX] = 0\\n                    rev_rel_cnts[MINOR_IDX] = 0\\n                    if remain_ctr[major_ch] == 0:\\n                        ans = max(ans, remain_ctr[minor_ch] - 1)\\n\\n                if rel_cnts[MINOR_IDX] > 0:\\n                    ans = max(ans, rel_cnts[MAJOR_IDX] - rel_cnts[MINOR_IDX])\\n                if rev_rel_cnts[MINOR_IDX] > 0:\\n                    ans = max(ans, rev_rel_cnts[MAJOR_IDX] - rev_rel_cnts[MINOR_IDX])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855457,
                "title": "readable-solution-in-swift-modified-kadane-s-failed-attempt",
                "content": "# Code\\n```\\nextension StringProtocol {\\n    subscript(offset: Int) -> Character {\\n        self[index(startIndex, offsetBy: offset)]\\n    }\\n}\\n\\nclass Solution {\\n    func varianceBetween(_ a: Character, _ b: Character, _ s: String) -> Int {\\n        var aCount = 0, bCount = 0\\n        var largestVar = 0\\n        for c in s {\\n            if c == a {\\n                aCount += 1\\n            } else if c == b {\\n                bCount += 1\\n            } else {\\n                // nothing has changed, so move to the next character\\n                continue\\n            }\\n\\n            if bCount > 0 {\\n                largestVar = max(largestVar, aCount - bCount)\\n            } else if (bCount == 0) {\\n                largestVar = max(largestVar, aCount - 1)\\n            }\\n\\n            if aCount < bCount {\\n                aCount = 0\\n                bCount = 0\\n            }\\n        }\\n        \\n        return largestVar\\n    }\\n\\n    // Third Pass: Adaptation of Kadane\\'s algorithm\\n    func largestVariance(_ s: String) -> Int {\\n        let alphabet = Array(Set(s))\\n\\n        var largestVar = 0\\n        for a in alphabet {\\n            for b in alphabet {\\n                if a != b {\\n                    largestVar = max(varianceBetween(a, b, s), largestVar)\\n                }\\n            }\\n        }\\n        \\n        return largestVar\\n    }\\n\\n\\n    // Second pass: slight improvement on first pass by more efficiently populating the counts dict\\n    // no more \"sliding window\"\\n    func largestVariance2(_ s: String) -> Int {\\n\\n        // track the largest variance we have seen so far\\n        var largestVar = Int.min\\n\\n        for i in (0..<s.count) {\\n            // track the counts of each character we have seen so far\\n            var counts = [Character:Int]()\\n            for j in (i..<s.count) {\\n                counts[s[j]] = (counts[s[j]] ?? 0) + 1\\n                let (minCount, maxCount) = counts.reduce((Int.max, Int.min), { (min($0.0, $1.1), max($0.1, $1.1)) })\\n                largestVar = max(largestVar, maxCount - minCount)\\n            }            \\n        }\\n\\n        return largestVar\\n    }\\n\\n    // First pass: use a sliding window and shrink the window\\n    func largestVariance1(_ s: String) -> Int {\\n        var window = s.count\\n        var largestVariance = Int.min\\n        while window > 0 && !(largestVariance != Int.min && window < largestVariance) {\\n            // compute the variance for substrings of size window\\n            for i in (0...(s.count - window)) {\\n                var counts = [Character:Int]()\\n                for j in (0..<window) {\\n                    counts[s[i+j]] = (counts[s[i+j]] ?? 0) + 1\\n                }\\n                let (vMin,vMax) = counts.reduce((Int.max, Int.min), { (min($0.0, $1.1), max($0.1, $1.1)) })\\n                largestVariance = max(largestVariance, vMax-vMin)\\n            }\\n            window -= 1\\n        }\\n\\n        return largestVariance\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nextension StringProtocol {\\n    subscript(offset: Int) -> Character {\\n        self[index(startIndex, offsetBy: offset)]\\n    }\\n}\\n\\nclass Solution {\\n    func varianceBetween(_ a: Character, _ b: Character, _ s: String) -> Int {\\n        var aCount = 0, bCount = 0\\n        var largestVar = 0\\n        for c in s {\\n            if c == a {\\n                aCount += 1\\n            } else if c == b {\\n                bCount += 1\\n            } else {\\n                // nothing has changed, so move to the next character\\n                continue\\n            }\\n\\n            if bCount > 0 {\\n                largestVar = max(largestVar, aCount - bCount)\\n            } else if (bCount == 0) {\\n                largestVar = max(largestVar, aCount - 1)\\n            }\\n\\n            if aCount < bCount {\\n                aCount = 0\\n                bCount = 0\\n            }\\n        }\\n        \\n        return largestVar\\n    }\\n\\n    // Third Pass: Adaptation of Kadane\\'s algorithm\\n    func largestVariance(_ s: String) -> Int {\\n        let alphabet = Array(Set(s))\\n\\n        var largestVar = 0\\n        for a in alphabet {\\n            for b in alphabet {\\n                if a != b {\\n                    largestVar = max(varianceBetween(a, b, s), largestVar)\\n                }\\n            }\\n        }\\n        \\n        return largestVar\\n    }\\n\\n\\n    // Second pass: slight improvement on first pass by more efficiently populating the counts dict\\n    // no more \"sliding window\"\\n    func largestVariance2(_ s: String) -> Int {\\n\\n        // track the largest variance we have seen so far\\n        var largestVar = Int.min\\n\\n        for i in (0..<s.count) {\\n            // track the counts of each character we have seen so far\\n            var counts = [Character:Int]()\\n            for j in (i..<s.count) {\\n                counts[s[j]] = (counts[s[j]] ?? 0) + 1\\n                let (minCount, maxCount) = counts.reduce((Int.max, Int.min), { (min($0.0, $1.1), max($0.1, $1.1)) })\\n                largestVar = max(largestVar, maxCount - minCount)\\n            }            \\n        }\\n\\n        return largestVar\\n    }\\n\\n    // First pass: use a sliding window and shrink the window\\n    func largestVariance1(_ s: String) -> Int {\\n        var window = s.count\\n        var largestVariance = Int.min\\n        while window > 0 && !(largestVariance != Int.min && window < largestVariance) {\\n            // compute the variance for substrings of size window\\n            for i in (0...(s.count - window)) {\\n                var counts = [Character:Int]()\\n                for j in (0..<window) {\\n                    counts[s[i+j]] = (counts[s[i+j]] ?? 0) + 1\\n                }\\n                let (vMin,vMax) = counts.reduce((Int.max, Int.min), { (min($0.0, $1.1), max($0.1, $1.1)) })\\n                largestVariance = max(largestVariance, vMax-vMin)\\n            }\\n            window -= 1\\n        }\\n\\n        return largestVariance\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810361,
                "title": "2272-substring-with-largest-variance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to find the largest variance among all substrings of the given string s. Variance is defined as the largest difference between the number of occurrences of any two characters in the substring.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We use two defaultdicts, char_count to keep track of character occurrences, and char_index to store the index positions of each character in the string.\\n2. Iterate through the string and update char_count and char_index accordingly for each character.\\n3. For each pair of distinct characters char_a and char_b, we calculate the variance using a sliding window approach.\\n4. We use total to keep track of occurrences of character char_a and char_b in the current substring and has_b to check if char_b is present in the substring.\\n5. By sorting the index positions of char_a and char_b, we can efficiently count their occurrences in the substring.\\n6. Update the max_variance if a larger variance is found during the iteration.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(N^2), where N is the length of the input string s. This is because of the nested iterations and sorting performed to calculate the variances.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(N), where N is the length of the input string s. This is due to the space used to store char_count and char_index.\\n# Code\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        char_count = defaultdict(int)     # Dictionary to keep track of character occurrences\\n        char_index = defaultdict(list)    # Dictionary to store the index positions of each character\\n        for i, ch in enumerate(s):\\n            char_count[ch] += 1\\n            char_index[ch].append((i, ch))\\n\\n        max_variance = 0\\n        for char_a, char_b in itertools.permutations(char_count.keys(), 2):\\n            total, has_b = 0, False\\n            if char_count[char_b] - 1 > max_variance:\\n                for _, x in sorted(char_index[char_a] + char_index[char_b]):\\n                    if x == char_a and (has_b := total > 0):\\n                        total -= 1\\n                    elif x == char_b:\\n                        max_variance = max(max_variance, total + has_b)\\n                        total += 1\\n        return max_variance\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        char_count = defaultdict(int)     # Dictionary to keep track of character occurrences\\n        char_index = defaultdict(list)    # Dictionary to store the index positions of each character\\n        for i, ch in enumerate(s):\\n            char_count[ch] += 1\\n            char_index[ch].append((i, ch))\\n\\n        max_variance = 0\\n        for char_a, char_b in itertools.permutations(char_count.keys(), 2):\\n            total, has_b = 0, False\\n            if char_count[char_b] - 1 > max_variance:\\n                for _, x in sorted(char_index[char_a] + char_index[char_b]):\\n                    if x == char_a and (has_b := total > 0):\\n                        total -= 1\\n                    elif x == char_b:\\n                        max_variance = max(max_variance, total + has_b)\\n                        total += 1\\n        return max_variance\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806904,
                "title": "o-26-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nOne sweap through the string, each char updates the database that consists of all possible two-letter pairs and following information:\\n- the minimum and maximum of difference of occurences of the first and second letter.\\n- for both minimum and maximum difference the first and last point it happened.\\n\\nThen the varience for this particular pair is the difference between the minimum and maximum. But it must be checked that we do not have a situation when the apparent optimum varience is reached with a string consisting only of one letter. This possibility is excluded with the help of knowing when the minimum and maximum appeared first and last. If it is indeed the case then the varience is decreased by 1 \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def largestVariance(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"     \\n        dict={}\\n        letters=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\\n        for l in \"abcdefghijklmnopqrstuvwxyz\":\\n            if s.find(l)==-1:\\n                letters.remove(l)\\n        L=len(letters)\\n        print(letters)\\n        if L==1:\\n            return 0\\n        \\n        for l in letters:\\n            if s[s.find(l)+1:].find(l)!=-1:\\n                break\\n            if l==letters[-1]:\\n                return 0\\n        for i in range(L-1):\\n            dict.update({letters[i]:{}})\\n            for j in range(i+1,L):\\n                dict[letters[i]].update({letters[j]:[0,[0,0,0],[0,0,0]]})\\n        print(dict)\\n\\n        maxvar=0\\n        run=0\\n        for l in s:\\n            for i in range(letters.index(l)):\\n                dict[letters[i]][l][0]-=1\\n                if dict[letters[i]][l][1][0]==dict[letters[i]][l][0]:\\n                    dict[letters[i]][l][1][2]=run\\n                elif dict[letters[i]][l][1][0]>dict[letters[i]][l][0]:\\n                    dict[letters[i]][l][1]=[dict[letters[i]][l][0],run,run]\\n                    #if abs(dict[letters[i]][l][1][0]-dict[letters[i]][l][2][0])>maxvar and s[min(dict[letters[i]][l][1][2],dict[letters[i]][l][1][1],dict[letters[i]][l][2][2],dict[letters[i]][l][2][1])+1:max(dict[letters[i]][l][1][2],dict[letters[i]][l][1][1],dict[letters[i]][l][2][2],dict[letters[i]][l][2][1])].find(letters[i])!=-1:\\n                        #maxvar=abs(dict[letters[i]][l][1][0]-dict[letters[i]][l][2][0])\\n\\n                 \\n            for i in range(letters.index(l)+1,L):\\n                dict[l][letters[i]][0]+=1\\n                if dict[l][letters[i]][2][0]==dict[l][letters[i]][0]:\\n                    dict[l][letters[i]][2][2]=run\\n                elif dict[l][letters[i]][2][0]<dict[l][letters[i]][0]:\\n                    dict[l][letters[i]][2]=[dict[l][letters[i]][0],run,run]\\n                    #if abs(dict[l][letters[i]][1][0]-dict[l][letters[i]][2][0])>maxvar and s[min(dict[l][letters[i]][2][2],dict[l][letters[i]][2][1],dict[l][letters[i]][1][2],dict[l][letters[i]][1][1])+1:max(dict[l][letters[i]][2][2],dict[l][letters[i]][2][1],dict[l][letters[i]][1][2],dict[l][letters[i]][1][1])].find(letters[i])!=-1:\\n                        #maxvar=abs(dict[letters[i]][l][1][0]-dict[letters[i]][l][2][0])\\n            run+=1\\n            #print(dict)\\n             \\n        for i in range(L-1):\\n            I=letters[i]\\n            for j in range(i+1,L):\\n                J=letters[j]\\n                if abs(dict[I][J][1][0]-dict[I][J][2][0])>maxvar:\\n                    if dict[I][J][1][1]<dict[I][J][2][2] and J in s[dict[I][J][1][1]+1:dict[I][J][2][2]+1]:\\n                        #print(s[dict[I][J][1][1]+1:dict[I][J][2][2]+1],I,J)\\n                        maxvar=abs(dict[I][J][1][0]-dict[I][J][2][0])\\n                    elif dict[I][J][2][1]<dict[I][J][1][2] and I in s[dict[I][J][2][1]+1:dict[I][J][1][2]+1]:\\n                        #print(s[dict[I][J][2][1]+1:dict[I][J][1][2]+1],I,J)\\n                        maxvar=abs(dict[I][J][1][0]-dict[I][J][2][0])\\n                    else:\\n                        maxvar=abs(dict[I][J][1][0]-dict[I][J][2][0])-1\\n\\n\\n            \\n        return maxvar\\n\\n    \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def largestVariance(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"     \\n        dict={}\\n        letters=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\\n        for l in \"abcdefghijklmnopqrstuvwxyz\":\\n            if s.find(l)==-1:\\n                letters.remove(l)\\n        L=len(letters)\\n        print(letters)\\n        if L==1:\\n            return 0\\n        \\n        for l in letters:\\n            if s[s.find(l)+1:].find(l)!=-1:\\n                break\\n            if l==letters[-1]:\\n                return 0\\n        for i in range(L-1):\\n            dict.update({letters[i]:{}})\\n            for j in range(i+1,L):\\n                dict[letters[i]].update({letters[j]:[0,[0,0,0],[0,0,0]]})\\n        print(dict)\\n\\n        maxvar=0\\n        run=0\\n        for l in s:\\n            for i in range(letters.index(l)):\\n                dict[letters[i]][l][0]-=1\\n                if dict[letters[i]][l][1][0]==dict[letters[i]][l][0]:\\n                    dict[letters[i]][l][1][2]=run\\n                elif dict[letters[i]][l][1][0]>dict[letters[i]][l][0]:\\n                    dict[letters[i]][l][1]=[dict[letters[i]][l][0],run,run]\\n                    #if abs(dict[letters[i]][l][1][0]-dict[letters[i]][l][2][0])>maxvar and s[min(dict[letters[i]][l][1][2],dict[letters[i]][l][1][1],dict[letters[i]][l][2][2],dict[letters[i]][l][2][1])+1:max(dict[letters[i]][l][1][2],dict[letters[i]][l][1][1],dict[letters[i]][l][2][2],dict[letters[i]][l][2][1])].find(letters[i])!=-1:\\n                        #maxvar=abs(dict[letters[i]][l][1][0]-dict[letters[i]][l][2][0])\\n\\n                 \\n            for i in range(letters.index(l)+1,L):\\n                dict[l][letters[i]][0]+=1\\n                if dict[l][letters[i]][2][0]==dict[l][letters[i]][0]:\\n                    dict[l][letters[i]][2][2]=run\\n                elif dict[l][letters[i]][2][0]<dict[l][letters[i]][0]:\\n                    dict[l][letters[i]][2]=[dict[l][letters[i]][0],run,run]\\n                    #if abs(dict[l][letters[i]][1][0]-dict[l][letters[i]][2][0])>maxvar and s[min(dict[l][letters[i]][2][2],dict[l][letters[i]][2][1],dict[l][letters[i]][1][2],dict[l][letters[i]][1][1])+1:max(dict[l][letters[i]][2][2],dict[l][letters[i]][2][1],dict[l][letters[i]][1][2],dict[l][letters[i]][1][1])].find(letters[i])!=-1:\\n                        #maxvar=abs(dict[letters[i]][l][1][0]-dict[letters[i]][l][2][0])\\n            run+=1\\n            #print(dict)\\n             \\n        for i in range(L-1):\\n            I=letters[i]\\n            for j in range(i+1,L):\\n                J=letters[j]\\n                if abs(dict[I][J][1][0]-dict[I][J][2][0])>maxvar:\\n                    if dict[I][J][1][1]<dict[I][J][2][2] and J in s[dict[I][J][1][1]+1:dict[I][J][2][2]+1]:\\n                        #print(s[dict[I][J][1][1]+1:dict[I][J][2][2]+1],I,J)\\n                        maxvar=abs(dict[I][J][1][0]-dict[I][J][2][0])\\n                    elif dict[I][J][2][1]<dict[I][J][1][2] and I in s[dict[I][J][2][1]+1:dict[I][J][1][2]+1]:\\n                        #print(s[dict[I][J][2][1]+1:dict[I][J][1][2]+1],I,J)\\n                        maxvar=abs(dict[I][J][1][0]-dict[I][J][2][0])\\n                    else:\\n                        maxvar=abs(dict[I][J][1][0]-dict[I][J][2][0])-1\\n\\n\\n            \\n        return maxvar\\n\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805092,
                "title": "clean-symmetric-code-with-explanation-of-the-idea-99-performance-in-c",
                "content": "# Intuition\\nThe noise introduced in this problem is pair-wise consideration, as opposed to the simplified problem where we need to find max freq difference occurring in some substring of a string with just 2 unique characters. After analysis & considerations, we take the approach of finding all unique pairs in the given string and imagining only 1 pair exists at a time by ignoring all other chars, and solving for each such pair. This approach is exhaustive as it considers all pair. However this outer looping of pairs is a constant number of iterations O(26*26), since there are $$^{26}C_2$$ pairs.\\n\\nWhen we solve the problem for a specific pair, the main issue is how to find maximum frequency difference? \\n\\nWe can do this by continuously tracking freq difference from pos 0 to last position. However each time, we also see if we can increase the difference by knocking off (_knock-off_) some number of characters. The exhaustive (quadratic) way of doing this would be to repeat frequency difference calculation starting from each position. But we realize that if we keep track of maximum frequency difference in the opposite direction along the way, we can simly use that to subtract from the current frequency difference!\\n\\nNote however that we would need to track frequency difference and the knock-off both ways, i.e., if freq1 & freq2 are the frequencies of the two characters in pair, we need to track for both freq1-freq2 & freq2-freq1. \\n\\n# Approach\\nMaintain counts & frequencies in pairs for book-keeping. The only caveat is, how do we ensure that a given frequency difference point is valid? A point is valid if that frequency difference is obtained such that there is at least 1 occurrence of each of the two characters. This can be ensured by checking if the individual counts are > 1, even when we knock-off. \\n\\nThe optimal knock-off occurs when the majority frequency is knocked-off the least and the minority frequency is knocked-off the most. During this process, we will need to ensure that the knock-off, does not make a count 0. The way to do that is by ensuring that the knock-off counts stop short of reaching the total counts of the respective characters in the string. This is tracked by doing a frequency count of all characters at the beginning and decrementing as we traverse the string. This info is also used to optimize the outer looping for selecting pairs.\\n\\n# Complexity\\n- Time complexity:\\n$$^{26}C_2 * O(N)$$ where $$N$$ is the string length\\n\\n- Space complexity:\\nWe use additional vector of alphabet size $$26$$ plus bookkeeping variables, so $$O(constant)$$ \\n\\n# Code\\n```\\n\\nclass Solution {    \\n\\n    int maxFreqDiff(string &sub, char first, char second, array<int,2> freq) {\\n        // Define 2 element arrays to hold counts\\n        // min12, min21 carry max possible freq diff increases in future\\n        array<int,2> count = {0,0}, min12 = count, min21 = count;        \\n        int result = 0;\\n\\n        // strict comparison element by element, unlike the default lexicographic behavior. Greater than & greater than.\\n        auto gg = [](array<int,2> &left, array<int,2> &right) { \\n            return left[0] > right[0] && left[1] > right[1];\\n        };\\n\\n        for ( char x : sub ) {\\n            // update counters\\n            // Decrease overall freq\\n            if ( x == first ) ++count[0], --freq[0];              \\n            else if ( x == second ) ++count[1], --freq[1];\\n            else continue; // ignore character not in the chosen pair\\n\\n            int diff12 = count[0] - count[1]; // find out freq diff assuming [0] dominates\\n            int min12Diff = diff12 - (min12[0] - min12[1]); // increase freq difference as much as possible\\n            int diff21 = -diff12; // find out freq diff assuming [1] dominates\\n            int min21Diff = diff21 - (min21[1] - min21[0]); // increase freq difference as much as possible\\n                      \\n            // if increasing freq diff is viable where first char dominates, i.e. at least one of each character must be present\\n            if ( gg(count, min12) ) result = max(result, min12Diff);\\n\\n            // if increasing freq diff is viable where second char dominates, i.e. at least one of each character must be present\\n            if ( gg(count, min21) ) result = max(result, min21Diff);            \\n\\n            // Ensure we don\\'t over-optimize where a character in the pair completely disappears by checking there is still at least one occurrence of that character left, by cheking the freq.\\n            if ( freq[0] && freq[1] ) {\\n                if ( min12Diff < 0 ) min12 = count;\\n                if ( min21Diff < 0 ) min21 = count;\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    \\npublic:\\n    int largestVariance(string s) {            \\n        int allMax = 0;\\n        const int ALPHA = 26;\\n        vector<int> exists(ALPHA, 0);\\n\\n        // Initial frequency count to be used for optimizing pair selection and also ensuring we don\\'t optimize away all occurrences of a character in the differential pair later.\\n        for ( char ch : s ) {\\n            ++exists[ch-\\'a\\'];\\n        }        \\n\\n        // Select pairs for computing differentials and for each pair compute the max differential in the string\\n        for ( int i = 0; i < ALPHA; ++i ) {\\n            if ( !exists[i] ) continue; // optimize pair creation\\n            for ( int j = i+1; j < ALPHA; ++j ) {\\n                if ( !exists[j] || (exists[i] < 2 && exists[j] < 2) ) continue; // optimize pair creation\\n                allMax = max(allMax, maxFreqDiff(s, \\'a\\'+i, \\'a\\'+j, {exists[i], exists[j]}));       \\n            }\\n        }\\n        return allMax;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {    \\n\\n    int maxFreqDiff(string &sub, char first, char second, array<int,2> freq) {\\n        // Define 2 element arrays to hold counts\\n        // min12, min21 carry max possible freq diff increases in future\\n        array<int,2> count = {0,0}, min12 = count, min21 = count;        \\n        int result = 0;\\n\\n        // strict comparison element by element, unlike the default lexicographic behavior. Greater than & greater than.\\n        auto gg = [](array<int,2> &left, array<int,2> &right) { \\n            return left[0] > right[0] && left[1] > right[1];\\n        };\\n\\n        for ( char x : sub ) {\\n            // update counters\\n            // Decrease overall freq\\n            if ( x == first ) ++count[0], --freq[0];              \\n            else if ( x == second ) ++count[1], --freq[1];\\n            else continue; // ignore character not in the chosen pair\\n\\n            int diff12 = count[0] - count[1]; // find out freq diff assuming [0] dominates\\n            int min12Diff = diff12 - (min12[0] - min12[1]); // increase freq difference as much as possible\\n            int diff21 = -diff12; // find out freq diff assuming [1] dominates\\n            int min21Diff = diff21 - (min21[1] - min21[0]); // increase freq difference as much as possible\\n                      \\n            // if increasing freq diff is viable where first char dominates, i.e. at least one of each character must be present\\n            if ( gg(count, min12) ) result = max(result, min12Diff);\\n\\n            // if increasing freq diff is viable where second char dominates, i.e. at least one of each character must be present\\n            if ( gg(count, min21) ) result = max(result, min21Diff);            \\n\\n            // Ensure we don\\'t over-optimize where a character in the pair completely disappears by checking there is still at least one occurrence of that character left, by cheking the freq.\\n            if ( freq[0] && freq[1] ) {\\n                if ( min12Diff < 0 ) min12 = count;\\n                if ( min21Diff < 0 ) min21 = count;\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    \\npublic:\\n    int largestVariance(string s) {            \\n        int allMax = 0;\\n        const int ALPHA = 26;\\n        vector<int> exists(ALPHA, 0);\\n\\n        // Initial frequency count to be used for optimizing pair selection and also ensuring we don\\'t optimize away all occurrences of a character in the differential pair later.\\n        for ( char ch : s ) {\\n            ++exists[ch-\\'a\\'];\\n        }        \\n\\n        // Select pairs for computing differentials and for each pair compute the max differential in the string\\n        for ( int i = 0; i < ALPHA; ++i ) {\\n            if ( !exists[i] ) continue; // optimize pair creation\\n            for ( int j = i+1; j < ALPHA; ++j ) {\\n                if ( !exists[j] || (exists[i] < 2 && exists[j] < 2) ) continue; // optimize pair creation\\n                allMax = max(allMax, maxFreqDiff(s, \\'a\\'+i, \\'a\\'+j, {exists[i], exists[j]}));       \\n            }\\n        }\\n        return allMax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752842,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int largestVariance(String s) {\\n    int ans = 0;\\n\\n    for (char c1 = \\'a\\'; c1 <= \\'z\\'; ++c1)\\n      for (char c2 = \\'a\\'; c2 <= \\'z\\'; ++c2)\\n        if (c1 != c2)\\n          ans = Math.max(ans, kadane(s, c1, c2));\\n\\n    return ans;\\n  }\\n\\n  // A := the char w/ higher freq\\n  // B := the char w/ lower freq\\n  private int kadane(final String s, char a, char b) {\\n    int ans = 0;\\n    int countA = 0;\\n    int countB = 0;\\n    boolean canExtendPrevB = false;\\n\\n    for (final char c : s.toCharArray()) {\\n      if (c != a && c != b)\\n        continue;\\n      if (c == a)\\n        ++countA;\\n      else\\n        ++countB;\\n      if (countB > 0) {\\n        // An interval should contain at least one b\\n        ans = Math.max(ans, countA - countB);\\n      } else if (countB == 0 && canExtendPrevB) {\\n        // Edge case: consider previous b\\n        ans = Math.max(ans, countA - 1);\\n      }\\n      // Reset if # of b > # of a\\n      if (countB > countA) {\\n        countA = 0;\\n        countB = 0;\\n        canExtendPrevB = true;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int largestVariance(String s) {\\n    int ans = 0;\\n\\n    for (char c1 = \\'a\\'; c1 <= \\'z\\'; ++c1)\\n      for (char c2 = \\'a\\'; c2 <= \\'z\\'; ++c2)\\n        if (c1 != c2)\\n          ans = Math.max(ans, kadane(s, c1, c2));\\n\\n    return ans;\\n  }\\n\\n  // A := the char w/ higher freq\\n  // B := the char w/ lower freq\\n  private int kadane(final String s, char a, char b) {\\n    int ans = 0;\\n    int countA = 0;\\n    int countB = 0;\\n    boolean canExtendPrevB = false;\\n\\n    for (final char c : s.toCharArray()) {\\n      if (c != a && c != b)\\n        continue;\\n      if (c == a)\\n        ++countA;\\n      else\\n        ++countB;\\n      if (countB > 0) {\\n        // An interval should contain at least one b\\n        ans = Math.max(ans, countA - countB);\\n      } else if (countB == 0 && canExtendPrevB) {\\n        // Edge case: consider previous b\\n        ans = Math.max(ans, countA - 1);\\n      }\\n      // Reset if # of b > # of a\\n      if (countB > countA) {\\n        countA = 0;\\n        countB = 0;\\n        canExtendPrevB = true;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751025,
                "title": "java-beat-97-30-kadane-s-algorithm-explanation",
                "content": "# Intuition\\nThe idea is find difference count of 2 characters (variance) in given string by applying Kadane\\'s algorithm and return max variance value.\\n\\n**Example:** \\nGiven s = \"abcca\"\\nWe must find out maximum diff count of \\'a\\' and \\'b\\', \\'a\\' and \\'c\\', \\'b\\' and \\'c\\'.\\nWith \\'a\\' and \\'b\\':\\n1. Init a \"**variance**\" variable and set it to 0.\\n2. Travel to each character in given string.\\n3. If s[i] is \\'a\\', increase \\'**variance**\\' variable by 1\\n4. If s[i] is \\'b\\', decrease \\'**variance**\\' by 1. If \\'**variance**\\' is less than 0, set it to 0.\\n5. Maximum value of \\'**variance**\\' is difference count.\\n\\n\\n\\n# Complexity\\n- We have maximum 26 character in given string, for each character, we find difference count with others (26 * 26).\\n- When we find a difference count, we must travel to length of given string (n).\\n=> Time complexity: 26 * 26 * O(n) \\n\\n# Code\\n```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        char[] chars = s.toCharArray();\\n        int[] count = new int[26];\\n        // count number of each char in s\\n        for (char c : chars) {\\n            count[c - \\'a\\'] ++;\\n        }\\n        int max = 0;\\n        for (int i = 0; i < 26; i ++) {\\n            // only find difference count for character that appears in s\\n            if (count[i] > 0) {\\n                max = Math.max(search(count, chars, (char) (i + \\'a\\')), max);\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private int search(int[] numsOfChar, char[] chars, char target) {\\n        // if s only contains target, return 0.\\n        // ex. s = \"aaaaaa\" target = \\'a\\'\\n        if (numsOfChar[target - \\'a\\'] == chars.length) {\\n            return 0;\\n        }\\n        // if s contains only one target, return 0.\\n        // ex. s = \"abcde\", target = \\'a\\'\\n        if (numsOfChar[target - \\'a\\'] == 1) {\\n            return 0;\\n        }\\n        int max = 0;\\n        // find diff count between target and others character \\n        for (int i = 0; i < 26; i ++) {\\n            // find target with only characters appeared in s\\n            if (numsOfChar[i] > 0 && i != target - \\'a\\') {\\n                int variance = 0;\\n                // bool variables for handling cases:\\n                // aaa => 0\\n                // baa => 1\\n                // aba => 1, ...\\n                boolean visitedTarget = false;\\n                boolean hasAnotherChar = false;\\n                int pos = -1;\\n                for (char c : chars) {\\n                    pos ++;\\n                    // this is step 3\\n                    if (c == target) {\\n                        visitedTarget = true;\\n                        variance ++;\\n                        if (!hasAnotherChar) {\\n                            max = Math.max(variance - 1, max);\\n                        } else {\\n                            max = Math.max(variance, max);\\n                        }\\n                    // this is step 4\\n                    } else if (c - \\'a\\' == i) {\\n                        if (visitedTarget) {\\n                            hasAnotherChar = true;\\n                        }\\n                        variance --;\\n                        // reset variables following Kadane\\'s algorithm\\n                        if (variance < 0) {\\n                            variance = 0;\\n                            hasAnotherChar = false;\\n                            visitedTarget = false;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        char[] chars = s.toCharArray();\\n        int[] count = new int[26];\\n        // count number of each char in s\\n        for (char c : chars) {\\n            count[c - \\'a\\'] ++;\\n        }\\n        int max = 0;\\n        for (int i = 0; i < 26; i ++) {\\n            // only find difference count for character that appears in s\\n            if (count[i] > 0) {\\n                max = Math.max(search(count, chars, (char) (i + \\'a\\')), max);\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private int search(int[] numsOfChar, char[] chars, char target) {\\n        // if s only contains target, return 0.\\n        // ex. s = \"aaaaaa\" target = \\'a\\'\\n        if (numsOfChar[target - \\'a\\'] == chars.length) {\\n            return 0;\\n        }\\n        // if s contains only one target, return 0.\\n        // ex. s = \"abcde\", target = \\'a\\'\\n        if (numsOfChar[target - \\'a\\'] == 1) {\\n            return 0;\\n        }\\n        int max = 0;\\n        // find diff count between target and others character \\n        for (int i = 0; i < 26; i ++) {\\n            // find target with only characters appeared in s\\n            if (numsOfChar[i] > 0 && i != target - \\'a\\') {\\n                int variance = 0;\\n                // bool variables for handling cases:\\n                // aaa => 0\\n                // baa => 1\\n                // aba => 1, ...\\n                boolean visitedTarget = false;\\n                boolean hasAnotherChar = false;\\n                int pos = -1;\\n                for (char c : chars) {\\n                    pos ++;\\n                    // this is step 3\\n                    if (c == target) {\\n                        visitedTarget = true;\\n                        variance ++;\\n                        if (!hasAnotherChar) {\\n                            max = Math.max(variance - 1, max);\\n                        } else {\\n                            max = Math.max(variance, max);\\n                        }\\n                    // this is step 4\\n                    } else if (c - \\'a\\' == i) {\\n                        if (visitedTarget) {\\n                            hasAnotherChar = true;\\n                        }\\n                        variance --;\\n                        // reset variables following Kadane\\'s algorithm\\n                        if (variance < 0) {\\n                            variance = 0;\\n                            hasAnotherChar = false;\\n                            visitedTarget = false;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747647,
                "title": "concurrent-kandane-in-o-n-k-log-k-time",
                "content": "# Intuition\\nAs presented by LeetCode hints/editorial, this problem can be solved using Kandane\\'s algorithm for maximum subarray sum. Each pair of characters `a`, `b` in the string can be used as 1 and -1, while other characters are treated as 0. Then the max variance is equal to the maximum sum across all pairs.\\n\\n# Approach\\nThe special sauce in this algorithm is not to waste iterations Kandane\\'s algorithm ignoring the other characters. In order to do this, we\\'ll run Kandane on multiple pairs of characters at the same time. We\\'ll call the character that we map to +1 `a` and every other character can be tested as -1 concurrently.\\n\\nAfter choosing the `a` character, we need a way to efficiently track all the possible `b` characters. We\\'ll do this by constructing a priority queue of searches for each `b` value.\\n\\nAny time we see a `b` character, we\\'ll update the state of that Kandane problem and the check if the current state is optimal. Many other solutions \\'reset\\' the problem when the value is negative by 0-ing out the counts for both `a` and `b`. Since the count of `a` affects all the Kandane problems, we need a slightly different approach. Imagine that instead of testing if `count(a)-count(b)` is optimal, we introduce a reset variable into the search. Rather than setting `count(a) = 0` when a search needs to be reset, we\\'ll instead set `reset(b) = count(a)` at that time. The value we need to test is then instead `count(a)-reset(b)-count(b)`. By maintaining a `reset` for every `b`, we can test all `b` values concurrently.\\n\\nAny time we see an `a` character, the actual state of all the Kandane problems is actually being updated at the same time. However, we don\\'t need to check all the problems, just the best one. To keep track of the best problem, we keep them all in a priority queue and then we can test the top of the queue, knowing that all other problems are in a worse state. The ordering of this queue needs to be somewhat unusual. We want to favor problems where `count(b) > 0` over any and all problems where `count(b) == 0`. After that, we prefer problems that minimize `reset(b)+count(b)`, since that will maximize `count(a)-reset(b)-count(b)`.\\n\\n# Complexity\\nGiven `n = len(s)` and `k = len(set(s))` (in Python parlance).\\n### Time complexity:\\nThe total runtime of this algorithm is `O(k * n * log k)`. We run `k` batches of concurrent searches. Each search takes `n` iterations to traverse `s` and each iteration takes a maximum of `log k` operations to maintain the heap invariant.\\n\\nTechnically, we could say this algorthm runs in `O(n)` *for this specific problem*, since `k` is limited to no more than 26 letters. However, that is **not** inherent to the algorithm. It is an accident of the fact that problem definition restricts to a finite set of characters.\\n\\n### Space complexity:\\nWhat we gain in time, we pay for in space. Since we introduce a heap to maintain the priority queue of the Kandane problems, we need `O(k)` space to hold all the problems.\\n\\nAs with time, we could say that are still using `O(1)` space, since the `k` is limited to no more than 26 letters. That would again be accident of the problem definition, not inherent to the algorithm.\\n\\n# Code\\n```\\ntype KandaneNode struct {\\n    index   int\\n    count   int\\n    reset   int\\n    remain  int\\n}\\n\\ntype KandaneHeap []*KandaneNode\\n\\nfunc (h KandaneHeap) Len() int {\\n    return len(h)\\n}\\n\\nfunc (h KandaneHeap) Less(i, j int) bool {\\n    // Favor searches with positive count over those without.\\n    if (h[i].count == 0) != (h[j].count == 0) {\\n        return h[i].count > 0\\n    }\\n    // Make sure the top node will produce the maximum variance.\\n    return h[i].count + h[i].reset < h[j].count + h[j].reset\\n}\\n\\nfunc (h KandaneHeap) Swap(i, j int) {\\n    h[i], h[j] = h[j], h[i]\\n    h[i].index = i\\n    h[j].index = j\\n}\\n\\nfunc (h KandaneHeap) Peek() *KandaneNode {\\n    return h[0]\\n}\\n\\nfunc (h *KandaneHeap) Pop() interface{} {\\n    old := *h\\n    n := len(old)\\n    x := old[n-1]\\n    x.index = -1\\n    *h = old[:n-1]\\n    return x\\n}\\n\\nfunc (h *KandaneHeap) Push(x interface{}) {\\n    item := x.(*KandaneNode)\\n    item.index = h.Len()\\n    *h = append(*h, item)\\n}\\n\\nfunc largestVariance(s string) int {\\n\\n    // Preprocessing: get unique chars and their counts\\n    var chars []rune\\n    var have [256]int\\n    for _, r := range s {\\n        if have[r] == 0 {\\n            chars = append(chars, r)\\n        }\\n        have[r]++\\n    }\\n\\n    // Hold the answer.\\n    var max int\\n\\n    // Iterate over every possible most common character.\\n    for _, a := range chars {\\n\\n        // Keep a running count of how many times we\\'ve seen the char.\\n        var aCount int\\n\\n        // Make a priority queue of Kandane calcs and a table to reference into the heap.\\n        queue := new(KandaneHeap)\\n        var table [256]*KandaneNode\\n\\n        // Iterate across characters in the string.\\n        for _, r := range s {\\n\\n            // Get the Kandane calc where r is the least common.\\n            item := table[r]\\n\\n            // If r is not the most common character.\\n            if a != r {\\n\\n                // If we haven\\'t started Kandane with r as the least common, intialize it and add it to the heap.\\n                if item == nil {\\n\\n                    item = &KandaneNode{\\n                        count: 0,\\n                        reset: 0,\\n                        remain: have[r],\\n                    }\\n\\n                    // Don\\'t need to do a heap.Push, because we\\'re about to heap.Fix anyway.\\n                    queue.Push(item)\\n                    table[r] = item\\n                }\\n\\n                // Add to the count of r and decrement the remaining amount.\\n                item.count++\\n                item.remain--\\n\\n                // Restore the heap invariant.\\n                heap.Fix(queue, item.index)\\n\\n            } else {\\n\\n                // Increment the count of the most frequent.\\n                aCount++\\n\\n                // If we don\\'t have any searches in the queue, just move on.\\n                if queue.Len() < 1 {\\n                    continue\\n                }\\n                // Since we just found a new copy of the most common char, we\\'ll check the best search instead.\\n                item = queue.Peek()\\n\\n            }\\n\\n            // Update the maximum if this is better, or reset the search if that\\'s better.\\n            if diff := aCount - item.reset - item.count; item.count > 0 && max < diff {\\n                max = diff\\n            } else if diff < 0 && item.remain > 0 {\\n                item.count = 0\\n                item.reset = aCount\\n            }\\n\\n       }\\n\\n    }\\n\\n    return max\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype KandaneNode struct {\\n    index   int\\n    count   int\\n    reset   int\\n    remain  int\\n}\\n\\ntype KandaneHeap []*KandaneNode\\n\\nfunc (h KandaneHeap) Len() int {\\n    return len(h)\\n}\\n\\nfunc (h KandaneHeap) Less(i, j int) bool {\\n    // Favor searches with positive count over those without.\\n    if (h[i].count == 0) != (h[j].count == 0) {\\n        return h[i].count > 0\\n    }\\n    // Make sure the top node will produce the maximum variance.\\n    return h[i].count + h[i].reset < h[j].count + h[j].reset\\n}\\n\\nfunc (h KandaneHeap) Swap(i, j int) {\\n    h[i], h[j] = h[j], h[i]\\n    h[i].index = i\\n    h[j].index = j\\n}\\n\\nfunc (h KandaneHeap) Peek() *KandaneNode {\\n    return h[0]\\n}\\n\\nfunc (h *KandaneHeap) Pop() interface{} {\\n    old := *h\\n    n := len(old)\\n    x := old[n-1]\\n    x.index = -1\\n    *h = old[:n-1]\\n    return x\\n}\\n\\nfunc (h *KandaneHeap) Push(x interface{}) {\\n    item := x.(*KandaneNode)\\n    item.index = h.Len()\\n    *h = append(*h, item)\\n}\\n\\nfunc largestVariance(s string) int {\\n\\n    // Preprocessing: get unique chars and their counts\\n    var chars []rune\\n    var have [256]int\\n    for _, r := range s {\\n        if have[r] == 0 {\\n            chars = append(chars, r)\\n        }\\n        have[r]++\\n    }\\n\\n    // Hold the answer.\\n    var max int\\n\\n    // Iterate over every possible most common character.\\n    for _, a := range chars {\\n\\n        // Keep a running count of how many times we\\'ve seen the char.\\n        var aCount int\\n\\n        // Make a priority queue of Kandane calcs and a table to reference into the heap.\\n        queue := new(KandaneHeap)\\n        var table [256]*KandaneNode\\n\\n        // Iterate across characters in the string.\\n        for _, r := range s {\\n\\n            // Get the Kandane calc where r is the least common.\\n            item := table[r]\\n\\n            // If r is not the most common character.\\n            if a != r {\\n\\n                // If we haven\\'t started Kandane with r as the least common, intialize it and add it to the heap.\\n                if item == nil {\\n\\n                    item = &KandaneNode{\\n                        count: 0,\\n                        reset: 0,\\n                        remain: have[r],\\n                    }\\n\\n                    // Don\\'t need to do a heap.Push, because we\\'re about to heap.Fix anyway.\\n                    queue.Push(item)\\n                    table[r] = item\\n                }\\n\\n                // Add to the count of r and decrement the remaining amount.\\n                item.count++\\n                item.remain--\\n\\n                // Restore the heap invariant.\\n                heap.Fix(queue, item.index)\\n\\n            } else {\\n\\n                // Increment the count of the most frequent.\\n                aCount++\\n\\n                // If we don\\'t have any searches in the queue, just move on.\\n                if queue.Len() < 1 {\\n                    continue\\n                }\\n                // Since we just found a new copy of the most common char, we\\'ll check the best search instead.\\n                item = queue.Peek()\\n\\n            }\\n\\n            // Update the maximum if this is better, or reset the search if that\\'s better.\\n            if diff := aCount - item.reset - item.count; item.count > 0 && max < diff {\\n                max = diff\\n            } else if diff < 0 && item.remain > 0 {\\n                item.count = 0\\n                item.reset = aCount\\n            }\\n\\n       }\\n\\n    }\\n\\n    return max\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3747221,
                "title": "o-nk-solution-in-python-faster-than-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAn adaptation of the linear time algorithm for finding maximum subarray sum. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nExtend the famous maximum subarray sum algorithm to handle all pairs of alphabets (Up to $$26 \\\\times 25$$ pairs). For every pair, we update the current maximum subarray sum. Additional work has been done for handling the case such as `abbb` or `bbba`, where the answer is 2 but not 3.\\n\\n# Complexity\\n- Time complexity: $$O(nk)$$ where $$n$$ is the length of the input string, and $$k \\\\le 26 $$ is number of unique alphabets in the input. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n+k^2)$$, very efficient. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        progress = defaultdict(int)\\n        mixed = defaultdict(bool)\\n        vocab = set(list(s))\\n        ans = 0\\n        for i, c1 in enumerate(s):\\n            for c2 in vocab:\\n                if c2 == c1:\\n                    continue\\n                if progress[(c1, c2)] >= 0:\\n                    progress[(c1, c2)] += 1\\n                    if mixed[(c1, c2)]:\\n                        ans = max(progress[(c1, c2)], ans)\\n                    elif i - progress[(c1, c2)] >= 0 or (i < len(s) - 1 and s[i+1] != c1):\\n                        ans = max(progress[(c1, c2)] - 1, ans)\\n                else:\\n                    progress[(c1, c2)] = 1\\n                    mixed[(c1, c2)] = False\\n                if progress[(c2, c1)] > 0:\\n                    progress[(c2, c1)] -= 1\\n                    mixed[(c2, c1)] = True\\n                else:\\n                    progress[(c2, c1)] = -1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        progress = defaultdict(int)\\n        mixed = defaultdict(bool)\\n        vocab = set(list(s))\\n        ans = 0\\n        for i, c1 in enumerate(s):\\n            for c2 in vocab:\\n                if c2 == c1:\\n                    continue\\n                if progress[(c1, c2)] >= 0:\\n                    progress[(c1, c2)] += 1\\n                    if mixed[(c1, c2)]:\\n                        ans = max(progress[(c1, c2)], ans)\\n                    elif i - progress[(c1, c2)] >= 0 or (i < len(s) - 1 and s[i+1] != c1):\\n                        ans = max(progress[(c1, c2)] - 1, ans)\\n                else:\\n                    progress[(c1, c2)] = 1\\n                    mixed[(c1, c2)] = False\\n                if progress[(c2, c1)] > 0:\\n                    progress[(c2, c1)] -= 1\\n                    mixed[(c2, c1)] = True\\n                else:\\n                    progress[(c2, c1)] = -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745993,
                "title": "generate-pair-use-kadense-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n       frequency_count1 = 0\\n       frequency_count2 = 0\\n       max_variance = 0\\n       pairs = [(s1,s2) for s1 in set(s) for s2 in set(s) if s1!=s2] \\n       for i in range(2):\\n           for pair in pairs:\\n               frequency_count1 = frequency_count2 = 0\\n               for string in s:\\n                   if string not in pair:\\n                       continue\\n                   elif string == pair[0]:\\n                        frequency_count1 += 1  \\n                   elif string == pair[1]:\\n                        frequency_count2 += 1\\n                   if frequency_count1<frequency_count2:\\n                        frequency_count1 = 0\\n                        frequency_count2 = 0\\n                   elif frequency_count1>0 and frequency_count2>0:\\n                        max_variance=max(max_variance, frequency_count1 - frequency_count2)\\n           s=s[::-1]\\n       return max_variance                             \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n       frequency_count1 = 0\\n       frequency_count2 = 0\\n       max_variance = 0\\n       pairs = [(s1,s2) for s1 in set(s) for s2 in set(s) if s1!=s2] \\n       for i in range(2):\\n           for pair in pairs:\\n               frequency_count1 = frequency_count2 = 0\\n               for string in s:\\n                   if string not in pair:\\n                       continue\\n                   elif string == pair[0]:\\n                        frequency_count1 += 1  \\n                   elif string == pair[1]:\\n                        frequency_count2 += 1\\n                   if frequency_count1<frequency_count2:\\n                        frequency_count1 = 0\\n                        frequency_count2 = 0\\n                   elif frequency_count1>0 and frequency_count2>0:\\n                        max_variance=max(max_variance, frequency_count1 - frequency_count2)\\n           s=s[::-1]\\n       return max_variance                             \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744968,
                "title": "2272-substring-with-largest-variance-simple-to-understand-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Kadane algorithm\\'s modification here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn largestVariance function run two for loops, for a -> z and inner also a -> z.\\n\\nFor each (26*26) iterations, calculate the maximum possible variance which can be achieved if string contained only these two characters.\\n\\nCreate a kadaneVariance function which will get the maximum variance possible of two characters.\\n\\nReturn the maximum.\\n\\n# Complexity\\n- Time complexity: $$O(26*26*n) = O(n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestVariance(String s){          // time complexity O( 26*26*n ) = O(n)\\n        int res = 0;\\n        for( char i = \\'a\\'; i <= \\'z\\'; i++){\\n            for( char j = \\'a\\'; j <= \\'z\\'; j++){\\n                res = Math.max( res, kadaneVariance( s, i, j));   // with help of kadane we will get max of each substring possible\\n            }\\n        }\\n        return res;\\n    }\\n    public int kadaneVariance( String s, char i, char j){\\n        int r = 0;\\n        int countI = 0;\\n        int countJ = 0;\\n        boolean canextendJ = false;   // for boundary condition ( may be substring leftmost left neighbour is j)\\n        for( final char c: s.toCharArray()){\\n            if( c != i && c != j){\\n                continue;\\n            }\\n            if( c == i){\\n                ++countI;\\n            }\\n            else{\\n                ++countJ;\\n            }\\n            if( countJ > 0){\\n                r = Math.max(r, countI - countJ);\\n            }\\n            else if( countJ == 0 && canextendJ){   // if current substr not contain j , but j is present just at the outside of leftmost boundary\\n                r = Math.max(r, countI - 1);       // then difference may be countI - 1\\n            }\\n\\n            if( countJ > countI){\\n                countI = 0;\\n                countJ = 0;\\n                canextendJ = true;\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestVariance(String s){          // time complexity O( 26*26*n ) = O(n)\\n        int res = 0;\\n        for( char i = \\'a\\'; i <= \\'z\\'; i++){\\n            for( char j = \\'a\\'; j <= \\'z\\'; j++){\\n                res = Math.max( res, kadaneVariance( s, i, j));   // with help of kadane we will get max of each substring possible\\n            }\\n        }\\n        return res;\\n    }\\n    public int kadaneVariance( String s, char i, char j){\\n        int r = 0;\\n        int countI = 0;\\n        int countJ = 0;\\n        boolean canextendJ = false;   // for boundary condition ( may be substring leftmost left neighbour is j)\\n        for( final char c: s.toCharArray()){\\n            if( c != i && c != j){\\n                continue;\\n            }\\n            if( c == i){\\n                ++countI;\\n            }\\n            else{\\n                ++countJ;\\n            }\\n            if( countJ > 0){\\n                r = Math.max(r, countI - countJ);\\n            }\\n            else if( countJ == 0 && canextendJ){   // if current substr not contain j , but j is present just at the outside of leftmost boundary\\n                r = Math.max(r, countI - 1);       // then difference may be countI - 1\\n            }\\n\\n            if( countJ > countI){\\n                countI = 0;\\n                countJ = 0;\\n                canextendJ = true;\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744290,
                "title": "easy-c-solution-checking-for-all-pairs-of-characters",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int ans=0;\\n        int n=s.size();\\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                if(i==j)continue;\\n                char c1=char(\\'a\\'+i);\\n                char c2=char(\\'a\\'+j);\\n                // cout<<c1<<\" \"<<c2<<endl;\\n                int mini=0;\\n                int maxi=0;\\n                for(int ind=0;ind<n;ind++)\\n                {\\n                    if(s[ind]==c1)\\n                    {\\n                        maxi++;\\n                        if(mini>0)ans=max(ans,maxi-mini);\\n                    }\\n                    else if(s[ind]==c2)\\n                    {\\n                        mini++;\\n                        ans=max(ans,maxi-mini);\\n                        if(mini>maxi)\\n                        {\\n                            maxi=0;\\n                            mini=0;\\n                        }\\n                    }\\n                }\\n\\n                maxi=0;\\n                mini=0;\\n\\n                for(int ind=n;ind>=0;ind--)\\n                {\\n                    if(s[ind]==c1)\\n                    {\\n                        maxi++;\\n                        if(mini>0)ans=max(ans,maxi-mini);\\n                    }\\n                    else if(s[ind]==c2)\\n                    {\\n                        mini++;\\n                        ans=max(ans,maxi-mini);\\n                        if(mini>maxi)\\n                        {\\n                            maxi=0;\\n                            mini=0;\\n                        }\\n                    }\\n                }\\n\\n\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int ans=0;\\n        int n=s.size();\\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                if(i==j)continue;\\n                char c1=char(\\'a\\'+i);\\n                char c2=char(\\'a\\'+j);\\n                // cout<<c1<<\" \"<<c2<<endl;\\n                int mini=0;\\n                int maxi=0;\\n                for(int ind=0;ind<n;ind++)\\n                {\\n                    if(s[ind]==c1)\\n                    {\\n                        maxi++;\\n                        if(mini>0)ans=max(ans,maxi-mini);\\n                    }\\n                    else if(s[ind]==c2)\\n                    {\\n                        mini++;\\n                        ans=max(ans,maxi-mini);\\n                        if(mini>maxi)\\n                        {\\n                            maxi=0;\\n                            mini=0;\\n                        }\\n                    }\\n                }\\n\\n                maxi=0;\\n                mini=0;\\n\\n                for(int ind=n;ind>=0;ind--)\\n                {\\n                    if(s[ind]==c1)\\n                    {\\n                        maxi++;\\n                        if(mini>0)ans=max(ans,maxi-mini);\\n                    }\\n                    else if(s[ind]==c2)\\n                    {\\n                        mini++;\\n                        ans=max(ans,maxi-mini);\\n                        if(mini>maxi)\\n                        {\\n                            maxi=0;\\n                            mini=0;\\n                        }\\n                    }\\n                }\\n\\n\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3744142,
                "title": "python3-clean-no-string-reversal-code",
                "content": "# Intuition\\nReversing the string didn\\'t really make sense to me, but I think this version is a lot clearer. Since we always need to have at least one element, if we 0 min elements in our window, substract one. Otherwise substract how many ever min elements we have!\\n\\n# Code\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        chars = set(s)\\n\\n        if len(chars) == len(s): return 0\\n\\n        def get_variance(s, min_char, max_char):\\n            best = min_char_count = max_char_count = 0\\n            for c in s:\\n                if c == max_char: max_char_count += 1\\n                if c == min_char: min_char_count += 1\\n\\n                if max_char_count - min_char_count < 0:\\n                    min_char_count = max_char_count = 0\\n                \\n                sub_one = 1 if min_char_count == 0 else min_char_count\\n                best = max(best, max_char_count - sub_one)\\n\\n            return best\\n\\n        best = 0\\n\\n        for min_char_idx in range(26):\\n            for max_char_idx in range(26):\\n                min_char = chr(min_char_idx + ord(\\'a\\'))\\n                max_char = chr(max_char_idx + ord(\\'a\\'))\\n\\n                if min_char_idx == max_char_idx: continue\\n                if max_char not in chars or min_char not in chars: continue\\n\\n                best = max(best, get_variance(s, min_char, max_char))\\n\\n        return best\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        chars = set(s)\\n\\n        if len(chars) == len(s): return 0\\n\\n        def get_variance(s, min_char, max_char):\\n            best = min_char_count = max_char_count = 0\\n            for c in s:\\n                if c == max_char: max_char_count += 1\\n                if c == min_char: min_char_count += 1\\n\\n                if max_char_count - min_char_count < 0:\\n                    min_char_count = max_char_count = 0\\n                \\n                sub_one = 1 if min_char_count == 0 else min_char_count\\n                best = max(best, max_char_count - sub_one)\\n\\n            return best\\n\\n        best = 0\\n\\n        for min_char_idx in range(26):\\n            for max_char_idx in range(26):\\n                min_char = chr(min_char_idx + ord(\\'a\\'))\\n                max_char = chr(max_char_idx + ord(\\'a\\'))\\n\\n                if min_char_idx == max_char_idx: continue\\n                if max_char not in chars or min_char not in chars: continue\\n\\n                best = max(best, get_variance(s, min_char, max_char))\\n\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743537,
                "title": "java-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        int output = 0;\\n        int[][] dif = new int[26][26];\\n        int[][] difB = new int [26][26];\\n        for(int i = 0; i < 26; i++){\\n            Arrays.fill(difB[i], -s.length());\\n        }\\n\\n        for(int j = 0; j < s.length(); j++){\\n            int ch = s.charAt(j) - \\'a\\';\\n            for(int k = 0; k < 26; k++){\\n                if(k == ch) continue;\\n                ++dif[ch][k];\\n                ++difB[ch][k];\\n                difB[k][ch] = --dif[k][ch];\\n                dif[k][ch] = Math.max(dif[k][ch], 0);\\n                output = Math.max(output, Math.max(difB[ch][k], difB[k][ch]));\\n\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        int output = 0;\\n        int[][] dif = new int[26][26];\\n        int[][] difB = new int [26][26];\\n        for(int i = 0; i < 26; i++){\\n            Arrays.fill(difB[i], -s.length());\\n        }\\n\\n        for(int j = 0; j < s.length(); j++){\\n            int ch = s.charAt(j) - \\'a\\';\\n            for(int k = 0; k < 26; k++){\\n                if(k == ch) continue;\\n                ++dif[ch][k];\\n                ++difB[ch][k];\\n                difB[k][ch] = --dif[k][ch];\\n                dif[k][ch] = Math.max(dif[k][ch], 0);\\n                output = Math.max(output, Math.max(difB[ch][k], difB[k][ch]));\\n\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743508,
                "title": "concise-minimal-python3-solution-with-explanations-wrote-this-as-didn-t-find-one-here",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis one comes across as a modification of Kadane\\'s algorithm.\\nWe can solve it by finding the maximum of the maximum difference for each of the valid pair of characters\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every possible 2-permutation of all the unique charcters of given string, we run a modified Kadane\\'s algorithm.\\n\\nIn this modified pass, given a minor character and major character, loop over every character of string and do the following:\\n-> increment count of major or minor character if the character is either of them\\nOR \\n-> skip to the next value in the loop\\n\\ncompute the max_diff as the max of the existing max_diff and difference between major_count and minor_count if the minor character has occurred **at least once**. This is the modification that we are using in Kadane\\'s algorithm.\\n\\nAny time the minor count exceeds the major count, and there is atleast 1 more minor character remaining, reset the minor and major counts\\n\\nThe max_diff is returned for every pass\\n\\nIn the outer loop, we re-compute result as the max of result (inititialized as 0) and returned max_diff for every valid pair\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs total number of characters in the alphabet is 26. The complexity of computing 2-permutation wold be O(k^2) and Kadane\\'s algorithm would be O(n)\\nSo Overall complexity is:\\n\\n$$O(k^2. n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nConsidering the space taken by Counter variable, \\n\\n$$O(k)$$\\n# Code\\n```\\nfrom collections import defaultdict, Counter\\nfrom itertools import permutations\\n\\n\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n\\n        def get_max_diff(minim, maxim):\\n            max_diff = minor_count = major_count = 0\\n            rest_minor = counter[minim]\\n\\n            for elem in s:\\n                if elem == minim: \\n                    minor_count += 1\\n                    rest_minor -= 1\\n                elif elem == maxim:\\n                    major_count += 1\\n                else:\\n                    continue\\n\\n                if minor_count:\\n                    max_diff = max(max_diff, major_count - minor_count)\\n                \\n                # do not reset if no more minor character remains in the string. \\n                # This ensures that a valid diff can be made when najor character appears\\n                if major_count < minor_count and rest_minor > 0:\\n                    major_count = minor_count = 0\\n                \\n            return max_diff\\n\\n\\n        # Steps:\\n        # use kadane\\'s algorithm to compute max_diff for all alphabet pairs\\n        res = 0\\n        counter = Counter(s)\\n\\n        for min_, max_ in permutations(set(s), 2):\\n            res = max(res, get_max_diff(min_, max_))\\n\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict, Counter\\nfrom itertools import permutations\\n\\n\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n\\n        def get_max_diff(minim, maxim):\\n            max_diff = minor_count = major_count = 0\\n            rest_minor = counter[minim]\\n\\n            for elem in s:\\n                if elem == minim: \\n                    minor_count += 1\\n                    rest_minor -= 1\\n                elif elem == maxim:\\n                    major_count += 1\\n                else:\\n                    continue\\n\\n                if minor_count:\\n                    max_diff = max(max_diff, major_count - minor_count)\\n                \\n                # do not reset if no more minor character remains in the string. \\n                # This ensures that a valid diff can be made when najor character appears\\n                if major_count < minor_count and rest_minor > 0:\\n                    major_count = minor_count = 0\\n                \\n            return max_diff\\n\\n\\n        # Steps:\\n        # use kadane\\'s algorithm to compute max_diff for all alphabet pairs\\n        res = 0\\n        counter = Counter(s)\\n\\n        for min_, max_ in permutations(set(s), 2):\\n            res = max(res, get_max_diff(min_, max_))\\n\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742946,
                "title": "kadane-algorithm-java-simple-solution",
                "content": "# Upvote me please \\uD83D\\uDE4F\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The `largestVariance` method takes a string `s` as input and returns an integer representing the largest variance between two characters in the string.\\n\\n2. An integer variable `ans` is initialized to 0. This variable will store the largest variance found so far.\\n\\n3. An integer array `counter` of size 26 is created. This array will be used to count the occurrences of each character in the string. The index of the array corresponds to the ASCII value of the character minus the ASCII value of \\'a\\'. For example, `counter[0]` represents the count of character \\'a\\', `counter[1]` represents the count of character \\'b\\', and so on.\\n\\n4. The code then iterates through each character `ch` in the string `s`. It increments the corresponding counter in the `counter` array by using `ch - \\'a\\'` to convert the character to its corresponding index in the array.\\n\\n5. The code then has two nested loops that iterate over all possible pairs of characters (`ch1` and `ch2`) from \\'a\\' to \\'z\\'. These loops check each combination of characters to find the largest variance.\\n\\n6. Inside the nested loops, the code performs the following checks:\\n   - It skips the iteration if `ch1` is equal to `ch2` or if the corresponding counters in the `counter` array for `ch1` or `ch2` are 0. This is done with the condition `ch1 == ch2 || counter[ch1-\\'a\\'] == 0 || counter[ch2-\\'a\\'] == 0`.\\n   - It initializes two variables `cnt1` and `cnt2` to 0, which will be used to count the occurrences of `ch1` and `ch2` in the string.\\n   - It initializes `remA` with the count of character `ch2` in the `counter` array.\\n   \\n7. The code then iterates through each character `ch` in the string `s` again. It increments `cnt1` when `ch` is equal to `ch1` and increments `cnt2` when `ch` is equal to `ch2`. It also decrements `remA` when `ch` is equal to `ch2`.\\n\\n8. Inside this second loop, the code performs the following checks:\\n   - If `cnt1` is less than `cnt2` and there are remaining occurrences of `ch2` (`remA >= 1`), it means the counts are not valid for calculating variance. In this case, `cnt1` and `cnt2` are reset to 0 to start counting from scratch.\\n   - If both `cnt1` and `cnt2` are greater than 0, it means valid counts of `ch1` and `ch2` have been found. The code then updates `ans` with the maximum variance found so far by taking the difference between `cnt1` and `cnt2` using `Math.max(ans, cnt1 - cnt2)`.\\n\\n9. After the nested loops have finished iterating through all possible combinations of characters, the code returns the largest variance stored in the `ans` variable.\\n\\n# Complexity\\n- Time complexity: O(26 * 26 * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        int ans = 0;\\n        int[] counter = new int[26];\\n        for (char ch : s.toCharArray()) {\\n            counter[(int)(ch - \\'a\\')]++;\\n        } \\n        for(char ch1 = \\'a\\'; ch1 <= \\'z\\'; ch1++){\\n            for(char ch2 = \\'a\\'; ch2 <= \\'z\\'; ch2++){\\n                if(ch1 == ch2 || counter[ch1-\\'a\\'] == 0 || counter[ch2-\\'a\\'] == 0){\\n                    continue;\\n                }\\n                \\n                int cnt1 = 0;\\n                int cnt2 = 0;\\n                int remA = counter[ch2 - \\'a\\'];\\n                \\n                for(char ch : s.toCharArray()){\\n                    if(ch == ch1){\\n                        cnt1++;\\n                    }\\n                    if(ch == ch2){\\n                        cnt2++;\\n                        remA--;\\n                    }\\n                    \\n                    if(cnt1 < cnt2 && remA >= 1){\\n                        \\n                        cnt1 = 0;\\n                        cnt2 = 0;\\n                    }\\n                    \\n                    if(cnt1 > 0 && cnt2 > 0){\\n                        \\n                        ans = Math.max(ans, cnt1 - cnt2);\\n                    }\\n                    \\n                }\\n            \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestVariance(String s) {\\n        int ans = 0;\\n        int[] counter = new int[26];\\n        for (char ch : s.toCharArray()) {\\n            counter[(int)(ch - \\'a\\')]++;\\n        } \\n        for(char ch1 = \\'a\\'; ch1 <= \\'z\\'; ch1++){\\n            for(char ch2 = \\'a\\'; ch2 <= \\'z\\'; ch2++){\\n                if(ch1 == ch2 || counter[ch1-\\'a\\'] == 0 || counter[ch2-\\'a\\'] == 0){\\n                    continue;\\n                }\\n                \\n                int cnt1 = 0;\\n                int cnt2 = 0;\\n                int remA = counter[ch2 - \\'a\\'];\\n                \\n                for(char ch : s.toCharArray()){\\n                    if(ch == ch1){\\n                        cnt1++;\\n                    }\\n                    if(ch == ch2){\\n                        cnt2++;\\n                        remA--;\\n                    }\\n                    \\n                    if(cnt1 < cnt2 && remA >= 1){\\n                        \\n                        cnt1 = 0;\\n                        cnt2 = 0;\\n                    }\\n                    \\n                    if(cnt1 > 0 && cnt2 > 0){\\n                        \\n                        ans = Math.max(ans, cnt1 - cnt2);\\n                    }\\n                    \\n                }\\n            \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742861,
                "title": "100-fast-o-26-n-time-o-n-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake list indexes for every letter in string. \\nGo through each pair of lists.\\nIt is faster because don\\'t need go through whole string every time.\\n\\n# Complexity\\n- Time complexity:  **O(26*n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ngo through each letter indexes 25 times at most.\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nstore list indexes for every letter\\n# Code\\n```\\npublic class Solution {\\n    \\n    public int LargestVariance(List<int> l1, List<int> l2)\\n    {\\n        int res = 0;\\n        int count = l1.Count + l2.Count;\\n        var curL1 = 0;\\n        var curL2 = 0;\\n        int countL1 = 0;\\n        int countL2 = 0;\\n        int inveseCountL1 = 0;\\n        int inveseCountL2 = 0;\\n        \\n        for (int i = 0; i < count; i++)\\n        {\\n            if(curL1== l1.Count)\\n            {\\n                curL2++; \\n                countL2++; \\n                inveseCountL2++;\\n            }\\n            else if (curL2 == l2.Count)\\n            {\\n                curL1++; \\n                countL1++; \\n                inveseCountL1++;\\n            }\\n            else if (l1[curL1] < l2[curL2])\\n            {\\n                curL1++;\\n                countL1++;\\n                inveseCountL1++;\\n            }\\n            else\\n            {\\n                curL2++;\\n                countL2++;\\n                inveseCountL2++;\\n            }\\n            if (countL1 > 0)\\n                res = Math.Max(res, countL2 - countL1);\\n\\n            if (countL2 < countL1 && curL1 < l1.Count)\\n            {\\n                countL2 = 0;\\n                countL1 = 0;\\n            }\\n            if (inveseCountL2 > 0)\\n                res = Math.Max(res, inveseCountL1 - inveseCountL2);\\n\\n            if (inveseCountL1 < inveseCountL2 && curL2 < l2.Count)\\n            {\\n                inveseCountL1 = 0;\\n                inveseCountL2 = 0;\\n            }\\n        }\\n        return res;\\n    }\\n    public int LargestVariance(string s)\\n    {\\n        var letters = new Dictionary<char, List<int>>();\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (letters.ContainsKey(s[i]))\\n                letters[s[i]].Add(i);\\n            else\\n                letters.Add(s[i], new List<int>() { i });\\n        }\\n        int res = 0;\\n        for (int i = 0; i < letters.Count; i++)\\n        {\\n            for (int j = i + 1; j < letters.Count; j++)\\n                res = Math.Max(res, LargestVariance(letters.Values.ElementAt(i), letters.Values.ElementAt(j)));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    \\n    public int LargestVariance(List<int> l1, List<int> l2)\\n    {\\n        int res = 0;\\n        int count = l1.Count + l2.Count;\\n        var curL1 = 0;\\n        var curL2 = 0;\\n        int countL1 = 0;\\n        int countL2 = 0;\\n        int inveseCountL1 = 0;\\n        int inveseCountL2 = 0;\\n        \\n        for (int i = 0; i < count; i++)\\n        {\\n            if(curL1== l1.Count)\\n            {\\n                curL2++; \\n                countL2++; \\n                inveseCountL2++;\\n            }\\n            else if (curL2 == l2.Count)\\n            {\\n                curL1++; \\n                countL1++; \\n                inveseCountL1++;\\n            }\\n            else if (l1[curL1] < l2[curL2])\\n            {\\n                curL1++;\\n                countL1++;\\n                inveseCountL1++;\\n            }\\n            else\\n            {\\n                curL2++;\\n                countL2++;\\n                inveseCountL2++;\\n            }\\n            if (countL1 > 0)\\n                res = Math.Max(res, countL2 - countL1);\\n\\n            if (countL2 < countL1 && curL1 < l1.Count)\\n            {\\n                countL2 = 0;\\n                countL1 = 0;\\n            }\\n            if (inveseCountL2 > 0)\\n                res = Math.Max(res, inveseCountL1 - inveseCountL2);\\n\\n            if (inveseCountL1 < inveseCountL2 && curL2 < l2.Count)\\n            {\\n                inveseCountL1 = 0;\\n                inveseCountL2 = 0;\\n            }\\n        }\\n        return res;\\n    }\\n    public int LargestVariance(string s)\\n    {\\n        var letters = new Dictionary<char, List<int>>();\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (letters.ContainsKey(s[i]))\\n                letters[s[i]].Add(i);\\n            else\\n                letters.Add(s[i], new List<int>() { i });\\n        }\\n        int res = 0;\\n        for (int i = 0; i < letters.Count; i++)\\n        {\\n            for (int j = i + 1; j < letters.Count; j++)\\n                res = Math.Max(res, LargestVariance(letters.Values.ElementAt(i), letters.Values.ElementAt(j)));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1652985,
                "content": [
                    {
                        "username": "darlingmidas",
                        "content": "I had this problem in an Amazon assessment recently. I think I ended up getting half of tests passing with a recursive solution. Didn\\'t have time to analyze runtime. I ended up advancing to onsite interview! Wish me luck."
                    },
                    {
                        "username": "khe1154",
                        "content": "[@sachin269](/sachin269) i do not think recursion is necessary. you can use nested for loop to generate substring. the calculate frequency and then calculate the variance.\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function (s) {\\n  const n = s.length;\\n  let maxVariance = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const substring = s.substring(i, j + 1);\\n      const freq = {};\\n\\n      for (let k = 0; k < substring.length; k++) {\\n        const c = substring[k];\\n        if (c in freq) {\\n          freq[c]++;\\n        } else {\\n          freq[c] = 1;\\n        }\\n      }\\n\\n      const values = Object.values(freq);\\n      const variance = Math.max(...values) - Math.min(...values);\\n      maxVariance = Math.max(maxVariance, variance);\\n    }\\n  }\\n\\n  return maxVariance;\\n\\n};\\n```"
                    },
                    {
                        "username": "pradeepmahato007",
                        "content": "All the best!!"
                    },
                    {
                        "username": "sachin269",
                        "content": "[@tjstinso](/tjstinso) can you help me knowing the recursive approach?"
                    },
                    {
                        "username": "wareag1e",
                        "content": "[@Maksadbek](/Maksadbek) Not necessarily. Maybe he has another account to practice problems. LOL"
                    },
                    {
                        "username": "tjstinso",
                        "content": "my initial implementation was a recursive one that passed something like 2/3rds. The actual optimization is pretty slick when you realize the trick, but I would not like to need the optimal solution in an interview. The first hint available is enough of a clue to implement this as the well-known algorithm with modifications, but there are more edge cases than the original problem. This could be a bit of a haul in an interview if the interviewer was just trying to break ankles."
                    },
                    {
                        "username": "Maksadbek",
                        "content": "[@JRajasri](/JRajasri) Looks like he passed the interview as he don\\'t open Leetcode."
                    },
                    {
                        "username": "JRajasri",
                        "content": "Hello. How did your onsite go ?"
                    },
                    {
                        "username": "madness97",
                        "content": "DIdnt understand the example the questions provided too."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@0x6B0](/0x6B0) Than you take the most frequent one and the least frequent one and subtract them from each other. \\n\\nSo say you have string \"abbccccba\", you have 4 c\\'s and 2 a\\'s so that string will have a variance of 2. (The smaller substring \\'bcccc\\' will have 4 c\\'s and 1 be so that substring will have a variance of 3, which will ultimately by your answer). \\n\\nFor coming up with the solution I think the most straight forward way is to compare all the letters pairwise, so I made a matrix of 26 by 26 and to compare each letter against all other letters, filling each of those cells with an array of +1 and -1, as suggested in the hints. And than go through all the arrays in the matrix to find the largest possible sum.  "
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@Mister_CK](/Mister_CK) But what if there are more than 2 letters in that substring? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference.\\n\\nThat\\'s how I would phrase it."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Leetcode\\'s obsession with hard questions on weekends :)"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "It makes sense since ppl usually have more spare time on weekend"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I don\\'t understand what the question is asking me to do."
                    },
                    {
                        "username": "mrb15",
                        "content": "sliding window hangover\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@whoisslimshady](/whoisslimshady) You can, it just gives TLE :P "
                    },
                    {
                        "username": "whoisslimshady",
                        "content": "for real even though i haven\\'t practice sliding window from long time still i though this can be done using sliding window"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Confused what the question is asking. Example explains absolutely nothing as well"
                    },
                    {
                        "username": "tifv",
                        "content": "[@Rishu_sh](/Rishu_sh) Yeah, this part was somewhat confusing. I guess it is accounting for cases like `aaaaa`, where there are no two different characters (the variance in this case is zero). You can ignore this sentence for all other cases."
                    },
                    {
                        "username": "Rishu_sh",
                        "content": "[@jswang00037](/jswang00037)  what is meant by this line : \"Note the two characters may or may not be the same\"?"
                    },
                    {
                        "username": "jswang00037",
                        "content": "In short, find the maximum variance of substring of s. \\nwhere the variance is difference of count between most/least frequent character in substring. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to use the hint, maybe something is more clear?\ns = \"aababbb\"->[1,1,-1,1,-1,-1,-1] This is  a one-to-one correspondence.\nFind the subarrays   containing  -1 & 1 with the largest sum , say A, and with the smallest sum, say B.\nThen A=[1,1,-1, 1] with sum(A)=2 , B=[-1,1,-1,-1,-1] with sum(B)=-3\nThen take max(abs(sum(A)), abs(sum(B)))=3\nThe subarray corresponds to \"babbb\".\nThere are at most 26 different alphabets in a string. Do it pairwise!"
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "[@seeker_747](/seeker_747) \n\nPay attention to description:\nThe variance of a string is defined as the LARGEST difference between the number of occurrences of ANY 2 characters present in the string. \n\nSo you need to consider only two different chars at one moment ignoring any others.\n\nIn example \"abbbcecfffaaccaaddea\" actually the largest diff is the one between \"e\" and \"a\" in \"abbbcecfffaaccaa\" (5 \"a\" and 1 \"e\", 5 - 1 = 4)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@anwendeng](/anwendeng) We can do better.\\nWe can do $26 N$ rather than $26^2 N$:\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@seeker_747](/seeker_747)  There are 26 alphabets.  Do it pairwise, in the ways of 26*25/2 combinations"
                    },
                    {
                        "username": "seeker_747",
                        "content": "what if we had something like \\'abbbcecfffaaccaaddea\\' (too many duplicate characters ) ,then how would we write the one to one correspondence array "
                    },
                    {
                        "username": "roman-mc",
                        "content": "Having more test cases provided would definitely help to understand task more :) "
                    },
                    {
                        "username": "dev-null0",
                        "content": "Didn't read the problem yet... but holy crap, stop with the back-to-back hard's please..."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those getting confused in what the question demands \nIts basically saying to find the maximum variance amongst substring of s. Where the variance is difference of count between most/least frequent character in substring. \nWhen they say \" two characters may or may not be the same.\" : it is just for saying if there is only one unique character : answer is zero.\n\nNow do the question, have a great weekend!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "thank you so much\\n"
                    }
                ]
            },
            {
                "id": 1567133,
                "content": [
                    {
                        "username": "darlingmidas",
                        "content": "I had this problem in an Amazon assessment recently. I think I ended up getting half of tests passing with a recursive solution. Didn\\'t have time to analyze runtime. I ended up advancing to onsite interview! Wish me luck."
                    },
                    {
                        "username": "khe1154",
                        "content": "[@sachin269](/sachin269) i do not think recursion is necessary. you can use nested for loop to generate substring. the calculate frequency and then calculate the variance.\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function (s) {\\n  const n = s.length;\\n  let maxVariance = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const substring = s.substring(i, j + 1);\\n      const freq = {};\\n\\n      for (let k = 0; k < substring.length; k++) {\\n        const c = substring[k];\\n        if (c in freq) {\\n          freq[c]++;\\n        } else {\\n          freq[c] = 1;\\n        }\\n      }\\n\\n      const values = Object.values(freq);\\n      const variance = Math.max(...values) - Math.min(...values);\\n      maxVariance = Math.max(maxVariance, variance);\\n    }\\n  }\\n\\n  return maxVariance;\\n\\n};\\n```"
                    },
                    {
                        "username": "pradeepmahato007",
                        "content": "All the best!!"
                    },
                    {
                        "username": "sachin269",
                        "content": "[@tjstinso](/tjstinso) can you help me knowing the recursive approach?"
                    },
                    {
                        "username": "wareag1e",
                        "content": "[@Maksadbek](/Maksadbek) Not necessarily. Maybe he has another account to practice problems. LOL"
                    },
                    {
                        "username": "tjstinso",
                        "content": "my initial implementation was a recursive one that passed something like 2/3rds. The actual optimization is pretty slick when you realize the trick, but I would not like to need the optimal solution in an interview. The first hint available is enough of a clue to implement this as the well-known algorithm with modifications, but there are more edge cases than the original problem. This could be a bit of a haul in an interview if the interviewer was just trying to break ankles."
                    },
                    {
                        "username": "Maksadbek",
                        "content": "[@JRajasri](/JRajasri) Looks like he passed the interview as he don\\'t open Leetcode."
                    },
                    {
                        "username": "JRajasri",
                        "content": "Hello. How did your onsite go ?"
                    },
                    {
                        "username": "madness97",
                        "content": "DIdnt understand the example the questions provided too."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@0x6B0](/0x6B0) Than you take the most frequent one and the least frequent one and subtract them from each other. \\n\\nSo say you have string \"abbccccba\", you have 4 c\\'s and 2 a\\'s so that string will have a variance of 2. (The smaller substring \\'bcccc\\' will have 4 c\\'s and 1 be so that substring will have a variance of 3, which will ultimately by your answer). \\n\\nFor coming up with the solution I think the most straight forward way is to compare all the letters pairwise, so I made a matrix of 26 by 26 and to compare each letter against all other letters, filling each of those cells with an array of +1 and -1, as suggested in the hints. And than go through all the arrays in the matrix to find the largest possible sum.  "
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@Mister_CK](/Mister_CK) But what if there are more than 2 letters in that substring? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference.\\n\\nThat\\'s how I would phrase it."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Leetcode\\'s obsession with hard questions on weekends :)"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "It makes sense since ppl usually have more spare time on weekend"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I don\\'t understand what the question is asking me to do."
                    },
                    {
                        "username": "mrb15",
                        "content": "sliding window hangover\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@whoisslimshady](/whoisslimshady) You can, it just gives TLE :P "
                    },
                    {
                        "username": "whoisslimshady",
                        "content": "for real even though i haven\\'t practice sliding window from long time still i though this can be done using sliding window"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Confused what the question is asking. Example explains absolutely nothing as well"
                    },
                    {
                        "username": "tifv",
                        "content": "[@Rishu_sh](/Rishu_sh) Yeah, this part was somewhat confusing. I guess it is accounting for cases like `aaaaa`, where there are no two different characters (the variance in this case is zero). You can ignore this sentence for all other cases."
                    },
                    {
                        "username": "Rishu_sh",
                        "content": "[@jswang00037](/jswang00037)  what is meant by this line : \"Note the two characters may or may not be the same\"?"
                    },
                    {
                        "username": "jswang00037",
                        "content": "In short, find the maximum variance of substring of s. \\nwhere the variance is difference of count between most/least frequent character in substring. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to use the hint, maybe something is more clear?\ns = \"aababbb\"->[1,1,-1,1,-1,-1,-1] This is  a one-to-one correspondence.\nFind the subarrays   containing  -1 & 1 with the largest sum , say A, and with the smallest sum, say B.\nThen A=[1,1,-1, 1] with sum(A)=2 , B=[-1,1,-1,-1,-1] with sum(B)=-3\nThen take max(abs(sum(A)), abs(sum(B)))=3\nThe subarray corresponds to \"babbb\".\nThere are at most 26 different alphabets in a string. Do it pairwise!"
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "[@seeker_747](/seeker_747) \n\nPay attention to description:\nThe variance of a string is defined as the LARGEST difference between the number of occurrences of ANY 2 characters present in the string. \n\nSo you need to consider only two different chars at one moment ignoring any others.\n\nIn example \"abbbcecfffaaccaaddea\" actually the largest diff is the one between \"e\" and \"a\" in \"abbbcecfffaaccaa\" (5 \"a\" and 1 \"e\", 5 - 1 = 4)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@anwendeng](/anwendeng) We can do better.\\nWe can do $26 N$ rather than $26^2 N$:\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@seeker_747](/seeker_747)  There are 26 alphabets.  Do it pairwise, in the ways of 26*25/2 combinations"
                    },
                    {
                        "username": "seeker_747",
                        "content": "what if we had something like \\'abbbcecfffaaccaaddea\\' (too many duplicate characters ) ,then how would we write the one to one correspondence array "
                    },
                    {
                        "username": "roman-mc",
                        "content": "Having more test cases provided would definitely help to understand task more :) "
                    },
                    {
                        "username": "dev-null0",
                        "content": "Didn't read the problem yet... but holy crap, stop with the back-to-back hard's please..."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those getting confused in what the question demands \nIts basically saying to find the maximum variance amongst substring of s. Where the variance is difference of count between most/least frequent character in substring. \nWhen they say \" two characters may or may not be the same.\" : it is just for saying if there is only one unique character : answer is zero.\n\nNow do the question, have a great weekend!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "thank you so much\\n"
                    }
                ]
            },
            {
                "id": 1962085,
                "content": [
                    {
                        "username": "darlingmidas",
                        "content": "I had this problem in an Amazon assessment recently. I think I ended up getting half of tests passing with a recursive solution. Didn\\'t have time to analyze runtime. I ended up advancing to onsite interview! Wish me luck."
                    },
                    {
                        "username": "khe1154",
                        "content": "[@sachin269](/sachin269) i do not think recursion is necessary. you can use nested for loop to generate substring. the calculate frequency and then calculate the variance.\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function (s) {\\n  const n = s.length;\\n  let maxVariance = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const substring = s.substring(i, j + 1);\\n      const freq = {};\\n\\n      for (let k = 0; k < substring.length; k++) {\\n        const c = substring[k];\\n        if (c in freq) {\\n          freq[c]++;\\n        } else {\\n          freq[c] = 1;\\n        }\\n      }\\n\\n      const values = Object.values(freq);\\n      const variance = Math.max(...values) - Math.min(...values);\\n      maxVariance = Math.max(maxVariance, variance);\\n    }\\n  }\\n\\n  return maxVariance;\\n\\n};\\n```"
                    },
                    {
                        "username": "pradeepmahato007",
                        "content": "All the best!!"
                    },
                    {
                        "username": "sachin269",
                        "content": "[@tjstinso](/tjstinso) can you help me knowing the recursive approach?"
                    },
                    {
                        "username": "wareag1e",
                        "content": "[@Maksadbek](/Maksadbek) Not necessarily. Maybe he has another account to practice problems. LOL"
                    },
                    {
                        "username": "tjstinso",
                        "content": "my initial implementation was a recursive one that passed something like 2/3rds. The actual optimization is pretty slick when you realize the trick, but I would not like to need the optimal solution in an interview. The first hint available is enough of a clue to implement this as the well-known algorithm with modifications, but there are more edge cases than the original problem. This could be a bit of a haul in an interview if the interviewer was just trying to break ankles."
                    },
                    {
                        "username": "Maksadbek",
                        "content": "[@JRajasri](/JRajasri) Looks like he passed the interview as he don\\'t open Leetcode."
                    },
                    {
                        "username": "JRajasri",
                        "content": "Hello. How did your onsite go ?"
                    },
                    {
                        "username": "madness97",
                        "content": "DIdnt understand the example the questions provided too."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@0x6B0](/0x6B0) Than you take the most frequent one and the least frequent one and subtract them from each other. \\n\\nSo say you have string \"abbccccba\", you have 4 c\\'s and 2 a\\'s so that string will have a variance of 2. (The smaller substring \\'bcccc\\' will have 4 c\\'s and 1 be so that substring will have a variance of 3, which will ultimately by your answer). \\n\\nFor coming up with the solution I think the most straight forward way is to compare all the letters pairwise, so I made a matrix of 26 by 26 and to compare each letter against all other letters, filling each of those cells with an array of +1 and -1, as suggested in the hints. And than go through all the arrays in the matrix to find the largest possible sum.  "
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@Mister_CK](/Mister_CK) But what if there are more than 2 letters in that substring? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference.\\n\\nThat\\'s how I would phrase it."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Leetcode\\'s obsession with hard questions on weekends :)"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "It makes sense since ppl usually have more spare time on weekend"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I don\\'t understand what the question is asking me to do."
                    },
                    {
                        "username": "mrb15",
                        "content": "sliding window hangover\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@whoisslimshady](/whoisslimshady) You can, it just gives TLE :P "
                    },
                    {
                        "username": "whoisslimshady",
                        "content": "for real even though i haven\\'t practice sliding window from long time still i though this can be done using sliding window"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Confused what the question is asking. Example explains absolutely nothing as well"
                    },
                    {
                        "username": "tifv",
                        "content": "[@Rishu_sh](/Rishu_sh) Yeah, this part was somewhat confusing. I guess it is accounting for cases like `aaaaa`, where there are no two different characters (the variance in this case is zero). You can ignore this sentence for all other cases."
                    },
                    {
                        "username": "Rishu_sh",
                        "content": "[@jswang00037](/jswang00037)  what is meant by this line : \"Note the two characters may or may not be the same\"?"
                    },
                    {
                        "username": "jswang00037",
                        "content": "In short, find the maximum variance of substring of s. \\nwhere the variance is difference of count between most/least frequent character in substring. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to use the hint, maybe something is more clear?\ns = \"aababbb\"->[1,1,-1,1,-1,-1,-1] This is  a one-to-one correspondence.\nFind the subarrays   containing  -1 & 1 with the largest sum , say A, and with the smallest sum, say B.\nThen A=[1,1,-1, 1] with sum(A)=2 , B=[-1,1,-1,-1,-1] with sum(B)=-3\nThen take max(abs(sum(A)), abs(sum(B)))=3\nThe subarray corresponds to \"babbb\".\nThere are at most 26 different alphabets in a string. Do it pairwise!"
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "[@seeker_747](/seeker_747) \n\nPay attention to description:\nThe variance of a string is defined as the LARGEST difference between the number of occurrences of ANY 2 characters present in the string. \n\nSo you need to consider only two different chars at one moment ignoring any others.\n\nIn example \"abbbcecfffaaccaaddea\" actually the largest diff is the one between \"e\" and \"a\" in \"abbbcecfffaaccaa\" (5 \"a\" and 1 \"e\", 5 - 1 = 4)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@anwendeng](/anwendeng) We can do better.\\nWe can do $26 N$ rather than $26^2 N$:\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@seeker_747](/seeker_747)  There are 26 alphabets.  Do it pairwise, in the ways of 26*25/2 combinations"
                    },
                    {
                        "username": "seeker_747",
                        "content": "what if we had something like \\'abbbcecfffaaccaaddea\\' (too many duplicate characters ) ,then how would we write the one to one correspondence array "
                    },
                    {
                        "username": "roman-mc",
                        "content": "Having more test cases provided would definitely help to understand task more :) "
                    },
                    {
                        "username": "dev-null0",
                        "content": "Didn't read the problem yet... but holy crap, stop with the back-to-back hard's please..."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those getting confused in what the question demands \nIts basically saying to find the maximum variance amongst substring of s. Where the variance is difference of count between most/least frequent character in substring. \nWhen they say \" two characters may or may not be the same.\" : it is just for saying if there is only one unique character : answer is zero.\n\nNow do the question, have a great weekend!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "thank you so much\\n"
                    }
                ]
            },
            {
                "id": 1761484,
                "content": [
                    {
                        "username": "darlingmidas",
                        "content": "I had this problem in an Amazon assessment recently. I think I ended up getting half of tests passing with a recursive solution. Didn\\'t have time to analyze runtime. I ended up advancing to onsite interview! Wish me luck."
                    },
                    {
                        "username": "khe1154",
                        "content": "[@sachin269](/sachin269) i do not think recursion is necessary. you can use nested for loop to generate substring. the calculate frequency and then calculate the variance.\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function (s) {\\n  const n = s.length;\\n  let maxVariance = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const substring = s.substring(i, j + 1);\\n      const freq = {};\\n\\n      for (let k = 0; k < substring.length; k++) {\\n        const c = substring[k];\\n        if (c in freq) {\\n          freq[c]++;\\n        } else {\\n          freq[c] = 1;\\n        }\\n      }\\n\\n      const values = Object.values(freq);\\n      const variance = Math.max(...values) - Math.min(...values);\\n      maxVariance = Math.max(maxVariance, variance);\\n    }\\n  }\\n\\n  return maxVariance;\\n\\n};\\n```"
                    },
                    {
                        "username": "pradeepmahato007",
                        "content": "All the best!!"
                    },
                    {
                        "username": "sachin269",
                        "content": "[@tjstinso](/tjstinso) can you help me knowing the recursive approach?"
                    },
                    {
                        "username": "wareag1e",
                        "content": "[@Maksadbek](/Maksadbek) Not necessarily. Maybe he has another account to practice problems. LOL"
                    },
                    {
                        "username": "tjstinso",
                        "content": "my initial implementation was a recursive one that passed something like 2/3rds. The actual optimization is pretty slick when you realize the trick, but I would not like to need the optimal solution in an interview. The first hint available is enough of a clue to implement this as the well-known algorithm with modifications, but there are more edge cases than the original problem. This could be a bit of a haul in an interview if the interviewer was just trying to break ankles."
                    },
                    {
                        "username": "Maksadbek",
                        "content": "[@JRajasri](/JRajasri) Looks like he passed the interview as he don\\'t open Leetcode."
                    },
                    {
                        "username": "JRajasri",
                        "content": "Hello. How did your onsite go ?"
                    },
                    {
                        "username": "madness97",
                        "content": "DIdnt understand the example the questions provided too."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@0x6B0](/0x6B0) Than you take the most frequent one and the least frequent one and subtract them from each other. \\n\\nSo say you have string \"abbccccba\", you have 4 c\\'s and 2 a\\'s so that string will have a variance of 2. (The smaller substring \\'bcccc\\' will have 4 c\\'s and 1 be so that substring will have a variance of 3, which will ultimately by your answer). \\n\\nFor coming up with the solution I think the most straight forward way is to compare all the letters pairwise, so I made a matrix of 26 by 26 and to compare each letter against all other letters, filling each of those cells with an array of +1 and -1, as suggested in the hints. And than go through all the arrays in the matrix to find the largest possible sum.  "
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@Mister_CK](/Mister_CK) But what if there are more than 2 letters in that substring? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference.\\n\\nThat\\'s how I would phrase it."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Leetcode\\'s obsession with hard questions on weekends :)"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "It makes sense since ppl usually have more spare time on weekend"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I don\\'t understand what the question is asking me to do."
                    },
                    {
                        "username": "mrb15",
                        "content": "sliding window hangover\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@whoisslimshady](/whoisslimshady) You can, it just gives TLE :P "
                    },
                    {
                        "username": "whoisslimshady",
                        "content": "for real even though i haven\\'t practice sliding window from long time still i though this can be done using sliding window"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Confused what the question is asking. Example explains absolutely nothing as well"
                    },
                    {
                        "username": "tifv",
                        "content": "[@Rishu_sh](/Rishu_sh) Yeah, this part was somewhat confusing. I guess it is accounting for cases like `aaaaa`, where there are no two different characters (the variance in this case is zero). You can ignore this sentence for all other cases."
                    },
                    {
                        "username": "Rishu_sh",
                        "content": "[@jswang00037](/jswang00037)  what is meant by this line : \"Note the two characters may or may not be the same\"?"
                    },
                    {
                        "username": "jswang00037",
                        "content": "In short, find the maximum variance of substring of s. \\nwhere the variance is difference of count between most/least frequent character in substring. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to use the hint, maybe something is more clear?\ns = \"aababbb\"->[1,1,-1,1,-1,-1,-1] This is  a one-to-one correspondence.\nFind the subarrays   containing  -1 & 1 with the largest sum , say A, and with the smallest sum, say B.\nThen A=[1,1,-1, 1] with sum(A)=2 , B=[-1,1,-1,-1,-1] with sum(B)=-3\nThen take max(abs(sum(A)), abs(sum(B)))=3\nThe subarray corresponds to \"babbb\".\nThere are at most 26 different alphabets in a string. Do it pairwise!"
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "[@seeker_747](/seeker_747) \n\nPay attention to description:\nThe variance of a string is defined as the LARGEST difference between the number of occurrences of ANY 2 characters present in the string. \n\nSo you need to consider only two different chars at one moment ignoring any others.\n\nIn example \"abbbcecfffaaccaaddea\" actually the largest diff is the one between \"e\" and \"a\" in \"abbbcecfffaaccaa\" (5 \"a\" and 1 \"e\", 5 - 1 = 4)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@anwendeng](/anwendeng) We can do better.\\nWe can do $26 N$ rather than $26^2 N$:\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@seeker_747](/seeker_747)  There are 26 alphabets.  Do it pairwise, in the ways of 26*25/2 combinations"
                    },
                    {
                        "username": "seeker_747",
                        "content": "what if we had something like \\'abbbcecfffaaccaaddea\\' (too many duplicate characters ) ,then how would we write the one to one correspondence array "
                    },
                    {
                        "username": "roman-mc",
                        "content": "Having more test cases provided would definitely help to understand task more :) "
                    },
                    {
                        "username": "dev-null0",
                        "content": "Didn't read the problem yet... but holy crap, stop with the back-to-back hard's please..."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those getting confused in what the question demands \nIts basically saying to find the maximum variance amongst substring of s. Where the variance is difference of count between most/least frequent character in substring. \nWhen they say \" two characters may or may not be the same.\" : it is just for saying if there is only one unique character : answer is zero.\n\nNow do the question, have a great weekend!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "thank you so much\\n"
                    }
                ]
            },
            {
                "id": 1962110,
                "content": [
                    {
                        "username": "darlingmidas",
                        "content": "I had this problem in an Amazon assessment recently. I think I ended up getting half of tests passing with a recursive solution. Didn\\'t have time to analyze runtime. I ended up advancing to onsite interview! Wish me luck."
                    },
                    {
                        "username": "khe1154",
                        "content": "[@sachin269](/sachin269) i do not think recursion is necessary. you can use nested for loop to generate substring. the calculate frequency and then calculate the variance.\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function (s) {\\n  const n = s.length;\\n  let maxVariance = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const substring = s.substring(i, j + 1);\\n      const freq = {};\\n\\n      for (let k = 0; k < substring.length; k++) {\\n        const c = substring[k];\\n        if (c in freq) {\\n          freq[c]++;\\n        } else {\\n          freq[c] = 1;\\n        }\\n      }\\n\\n      const values = Object.values(freq);\\n      const variance = Math.max(...values) - Math.min(...values);\\n      maxVariance = Math.max(maxVariance, variance);\\n    }\\n  }\\n\\n  return maxVariance;\\n\\n};\\n```"
                    },
                    {
                        "username": "pradeepmahato007",
                        "content": "All the best!!"
                    },
                    {
                        "username": "sachin269",
                        "content": "[@tjstinso](/tjstinso) can you help me knowing the recursive approach?"
                    },
                    {
                        "username": "wareag1e",
                        "content": "[@Maksadbek](/Maksadbek) Not necessarily. Maybe he has another account to practice problems. LOL"
                    },
                    {
                        "username": "tjstinso",
                        "content": "my initial implementation was a recursive one that passed something like 2/3rds. The actual optimization is pretty slick when you realize the trick, but I would not like to need the optimal solution in an interview. The first hint available is enough of a clue to implement this as the well-known algorithm with modifications, but there are more edge cases than the original problem. This could be a bit of a haul in an interview if the interviewer was just trying to break ankles."
                    },
                    {
                        "username": "Maksadbek",
                        "content": "[@JRajasri](/JRajasri) Looks like he passed the interview as he don\\'t open Leetcode."
                    },
                    {
                        "username": "JRajasri",
                        "content": "Hello. How did your onsite go ?"
                    },
                    {
                        "username": "madness97",
                        "content": "DIdnt understand the example the questions provided too."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@0x6B0](/0x6B0) Than you take the most frequent one and the least frequent one and subtract them from each other. \\n\\nSo say you have string \"abbccccba\", you have 4 c\\'s and 2 a\\'s so that string will have a variance of 2. (The smaller substring \\'bcccc\\' will have 4 c\\'s and 1 be so that substring will have a variance of 3, which will ultimately by your answer). \\n\\nFor coming up with the solution I think the most straight forward way is to compare all the letters pairwise, so I made a matrix of 26 by 26 and to compare each letter against all other letters, filling each of those cells with an array of +1 and -1, as suggested in the hints. And than go through all the arrays in the matrix to find the largest possible sum.  "
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@Mister_CK](/Mister_CK) But what if there are more than 2 letters in that substring? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference.\\n\\nThat\\'s how I would phrase it."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Leetcode\\'s obsession with hard questions on weekends :)"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "It makes sense since ppl usually have more spare time on weekend"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I don\\'t understand what the question is asking me to do."
                    },
                    {
                        "username": "mrb15",
                        "content": "sliding window hangover\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@whoisslimshady](/whoisslimshady) You can, it just gives TLE :P "
                    },
                    {
                        "username": "whoisslimshady",
                        "content": "for real even though i haven\\'t practice sliding window from long time still i though this can be done using sliding window"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Confused what the question is asking. Example explains absolutely nothing as well"
                    },
                    {
                        "username": "tifv",
                        "content": "[@Rishu_sh](/Rishu_sh) Yeah, this part was somewhat confusing. I guess it is accounting for cases like `aaaaa`, where there are no two different characters (the variance in this case is zero). You can ignore this sentence for all other cases."
                    },
                    {
                        "username": "Rishu_sh",
                        "content": "[@jswang00037](/jswang00037)  what is meant by this line : \"Note the two characters may or may not be the same\"?"
                    },
                    {
                        "username": "jswang00037",
                        "content": "In short, find the maximum variance of substring of s. \\nwhere the variance is difference of count between most/least frequent character in substring. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to use the hint, maybe something is more clear?\ns = \"aababbb\"->[1,1,-1,1,-1,-1,-1] This is  a one-to-one correspondence.\nFind the subarrays   containing  -1 & 1 with the largest sum , say A, and with the smallest sum, say B.\nThen A=[1,1,-1, 1] with sum(A)=2 , B=[-1,1,-1,-1,-1] with sum(B)=-3\nThen take max(abs(sum(A)), abs(sum(B)))=3\nThe subarray corresponds to \"babbb\".\nThere are at most 26 different alphabets in a string. Do it pairwise!"
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "[@seeker_747](/seeker_747) \n\nPay attention to description:\nThe variance of a string is defined as the LARGEST difference between the number of occurrences of ANY 2 characters present in the string. \n\nSo you need to consider only two different chars at one moment ignoring any others.\n\nIn example \"abbbcecfffaaccaaddea\" actually the largest diff is the one between \"e\" and \"a\" in \"abbbcecfffaaccaa\" (5 \"a\" and 1 \"e\", 5 - 1 = 4)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@anwendeng](/anwendeng) We can do better.\\nWe can do $26 N$ rather than $26^2 N$:\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@seeker_747](/seeker_747)  There are 26 alphabets.  Do it pairwise, in the ways of 26*25/2 combinations"
                    },
                    {
                        "username": "seeker_747",
                        "content": "what if we had something like \\'abbbcecfffaaccaaddea\\' (too many duplicate characters ) ,then how would we write the one to one correspondence array "
                    },
                    {
                        "username": "roman-mc",
                        "content": "Having more test cases provided would definitely help to understand task more :) "
                    },
                    {
                        "username": "dev-null0",
                        "content": "Didn't read the problem yet... but holy crap, stop with the back-to-back hard's please..."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those getting confused in what the question demands \nIts basically saying to find the maximum variance amongst substring of s. Where the variance is difference of count between most/least frequent character in substring. \nWhen they say \" two characters may or may not be the same.\" : it is just for saying if there is only one unique character : answer is zero.\n\nNow do the question, have a great weekend!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "thank you so much\\n"
                    }
                ]
            },
            {
                "id": 1962094,
                "content": [
                    {
                        "username": "darlingmidas",
                        "content": "I had this problem in an Amazon assessment recently. I think I ended up getting half of tests passing with a recursive solution. Didn\\'t have time to analyze runtime. I ended up advancing to onsite interview! Wish me luck."
                    },
                    {
                        "username": "khe1154",
                        "content": "[@sachin269](/sachin269) i do not think recursion is necessary. you can use nested for loop to generate substring. the calculate frequency and then calculate the variance.\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function (s) {\\n  const n = s.length;\\n  let maxVariance = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const substring = s.substring(i, j + 1);\\n      const freq = {};\\n\\n      for (let k = 0; k < substring.length; k++) {\\n        const c = substring[k];\\n        if (c in freq) {\\n          freq[c]++;\\n        } else {\\n          freq[c] = 1;\\n        }\\n      }\\n\\n      const values = Object.values(freq);\\n      const variance = Math.max(...values) - Math.min(...values);\\n      maxVariance = Math.max(maxVariance, variance);\\n    }\\n  }\\n\\n  return maxVariance;\\n\\n};\\n```"
                    },
                    {
                        "username": "pradeepmahato007",
                        "content": "All the best!!"
                    },
                    {
                        "username": "sachin269",
                        "content": "[@tjstinso](/tjstinso) can you help me knowing the recursive approach?"
                    },
                    {
                        "username": "wareag1e",
                        "content": "[@Maksadbek](/Maksadbek) Not necessarily. Maybe he has another account to practice problems. LOL"
                    },
                    {
                        "username": "tjstinso",
                        "content": "my initial implementation was a recursive one that passed something like 2/3rds. The actual optimization is pretty slick when you realize the trick, but I would not like to need the optimal solution in an interview. The first hint available is enough of a clue to implement this as the well-known algorithm with modifications, but there are more edge cases than the original problem. This could be a bit of a haul in an interview if the interviewer was just trying to break ankles."
                    },
                    {
                        "username": "Maksadbek",
                        "content": "[@JRajasri](/JRajasri) Looks like he passed the interview as he don\\'t open Leetcode."
                    },
                    {
                        "username": "JRajasri",
                        "content": "Hello. How did your onsite go ?"
                    },
                    {
                        "username": "madness97",
                        "content": "DIdnt understand the example the questions provided too."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@0x6B0](/0x6B0) Than you take the most frequent one and the least frequent one and subtract them from each other. \\n\\nSo say you have string \"abbccccba\", you have 4 c\\'s and 2 a\\'s so that string will have a variance of 2. (The smaller substring \\'bcccc\\' will have 4 c\\'s and 1 be so that substring will have a variance of 3, which will ultimately by your answer). \\n\\nFor coming up with the solution I think the most straight forward way is to compare all the letters pairwise, so I made a matrix of 26 by 26 and to compare each letter against all other letters, filling each of those cells with an array of +1 and -1, as suggested in the hints. And than go through all the arrays in the matrix to find the largest possible sum.  "
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@Mister_CK](/Mister_CK) But what if there are more than 2 letters in that substring? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference.\\n\\nThat\\'s how I would phrase it."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Leetcode\\'s obsession with hard questions on weekends :)"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "It makes sense since ppl usually have more spare time on weekend"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I don\\'t understand what the question is asking me to do."
                    },
                    {
                        "username": "mrb15",
                        "content": "sliding window hangover\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@whoisslimshady](/whoisslimshady) You can, it just gives TLE :P "
                    },
                    {
                        "username": "whoisslimshady",
                        "content": "for real even though i haven\\'t practice sliding window from long time still i though this can be done using sliding window"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Confused what the question is asking. Example explains absolutely nothing as well"
                    },
                    {
                        "username": "tifv",
                        "content": "[@Rishu_sh](/Rishu_sh) Yeah, this part was somewhat confusing. I guess it is accounting for cases like `aaaaa`, where there are no two different characters (the variance in this case is zero). You can ignore this sentence for all other cases."
                    },
                    {
                        "username": "Rishu_sh",
                        "content": "[@jswang00037](/jswang00037)  what is meant by this line : \"Note the two characters may or may not be the same\"?"
                    },
                    {
                        "username": "jswang00037",
                        "content": "In short, find the maximum variance of substring of s. \\nwhere the variance is difference of count between most/least frequent character in substring. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to use the hint, maybe something is more clear?\ns = \"aababbb\"->[1,1,-1,1,-1,-1,-1] This is  a one-to-one correspondence.\nFind the subarrays   containing  -1 & 1 with the largest sum , say A, and with the smallest sum, say B.\nThen A=[1,1,-1, 1] with sum(A)=2 , B=[-1,1,-1,-1,-1] with sum(B)=-3\nThen take max(abs(sum(A)), abs(sum(B)))=3\nThe subarray corresponds to \"babbb\".\nThere are at most 26 different alphabets in a string. Do it pairwise!"
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "[@seeker_747](/seeker_747) \n\nPay attention to description:\nThe variance of a string is defined as the LARGEST difference between the number of occurrences of ANY 2 characters present in the string. \n\nSo you need to consider only two different chars at one moment ignoring any others.\n\nIn example \"abbbcecfffaaccaaddea\" actually the largest diff is the one between \"e\" and \"a\" in \"abbbcecfffaaccaa\" (5 \"a\" and 1 \"e\", 5 - 1 = 4)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@anwendeng](/anwendeng) We can do better.\\nWe can do $26 N$ rather than $26^2 N$:\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@seeker_747](/seeker_747)  There are 26 alphabets.  Do it pairwise, in the ways of 26*25/2 combinations"
                    },
                    {
                        "username": "seeker_747",
                        "content": "what if we had something like \\'abbbcecfffaaccaaddea\\' (too many duplicate characters ) ,then how would we write the one to one correspondence array "
                    },
                    {
                        "username": "roman-mc",
                        "content": "Having more test cases provided would definitely help to understand task more :) "
                    },
                    {
                        "username": "dev-null0",
                        "content": "Didn't read the problem yet... but holy crap, stop with the back-to-back hard's please..."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those getting confused in what the question demands \nIts basically saying to find the maximum variance amongst substring of s. Where the variance is difference of count between most/least frequent character in substring. \nWhen they say \" two characters may or may not be the same.\" : it is just for saying if there is only one unique character : answer is zero.\n\nNow do the question, have a great weekend!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "thank you so much\\n"
                    }
                ]
            },
            {
                "id": 1962092,
                "content": [
                    {
                        "username": "darlingmidas",
                        "content": "I had this problem in an Amazon assessment recently. I think I ended up getting half of tests passing with a recursive solution. Didn\\'t have time to analyze runtime. I ended up advancing to onsite interview! Wish me luck."
                    },
                    {
                        "username": "khe1154",
                        "content": "[@sachin269](/sachin269) i do not think recursion is necessary. you can use nested for loop to generate substring. the calculate frequency and then calculate the variance.\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function (s) {\\n  const n = s.length;\\n  let maxVariance = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const substring = s.substring(i, j + 1);\\n      const freq = {};\\n\\n      for (let k = 0; k < substring.length; k++) {\\n        const c = substring[k];\\n        if (c in freq) {\\n          freq[c]++;\\n        } else {\\n          freq[c] = 1;\\n        }\\n      }\\n\\n      const values = Object.values(freq);\\n      const variance = Math.max(...values) - Math.min(...values);\\n      maxVariance = Math.max(maxVariance, variance);\\n    }\\n  }\\n\\n  return maxVariance;\\n\\n};\\n```"
                    },
                    {
                        "username": "pradeepmahato007",
                        "content": "All the best!!"
                    },
                    {
                        "username": "sachin269",
                        "content": "[@tjstinso](/tjstinso) can you help me knowing the recursive approach?"
                    },
                    {
                        "username": "wareag1e",
                        "content": "[@Maksadbek](/Maksadbek) Not necessarily. Maybe he has another account to practice problems. LOL"
                    },
                    {
                        "username": "tjstinso",
                        "content": "my initial implementation was a recursive one that passed something like 2/3rds. The actual optimization is pretty slick when you realize the trick, but I would not like to need the optimal solution in an interview. The first hint available is enough of a clue to implement this as the well-known algorithm with modifications, but there are more edge cases than the original problem. This could be a bit of a haul in an interview if the interviewer was just trying to break ankles."
                    },
                    {
                        "username": "Maksadbek",
                        "content": "[@JRajasri](/JRajasri) Looks like he passed the interview as he don\\'t open Leetcode."
                    },
                    {
                        "username": "JRajasri",
                        "content": "Hello. How did your onsite go ?"
                    },
                    {
                        "username": "madness97",
                        "content": "DIdnt understand the example the questions provided too."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@0x6B0](/0x6B0) Than you take the most frequent one and the least frequent one and subtract them from each other. \\n\\nSo say you have string \"abbccccba\", you have 4 c\\'s and 2 a\\'s so that string will have a variance of 2. (The smaller substring \\'bcccc\\' will have 4 c\\'s and 1 be so that substring will have a variance of 3, which will ultimately by your answer). \\n\\nFor coming up with the solution I think the most straight forward way is to compare all the letters pairwise, so I made a matrix of 26 by 26 and to compare each letter against all other letters, filling each of those cells with an array of +1 and -1, as suggested in the hints. And than go through all the arrays in the matrix to find the largest possible sum.  "
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@Mister_CK](/Mister_CK) But what if there are more than 2 letters in that substring? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference.\\n\\nThat\\'s how I would phrase it."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Leetcode\\'s obsession with hard questions on weekends :)"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "It makes sense since ppl usually have more spare time on weekend"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I don\\'t understand what the question is asking me to do."
                    },
                    {
                        "username": "mrb15",
                        "content": "sliding window hangover\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@whoisslimshady](/whoisslimshady) You can, it just gives TLE :P "
                    },
                    {
                        "username": "whoisslimshady",
                        "content": "for real even though i haven\\'t practice sliding window from long time still i though this can be done using sliding window"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Confused what the question is asking. Example explains absolutely nothing as well"
                    },
                    {
                        "username": "tifv",
                        "content": "[@Rishu_sh](/Rishu_sh) Yeah, this part was somewhat confusing. I guess it is accounting for cases like `aaaaa`, where there are no two different characters (the variance in this case is zero). You can ignore this sentence for all other cases."
                    },
                    {
                        "username": "Rishu_sh",
                        "content": "[@jswang00037](/jswang00037)  what is meant by this line : \"Note the two characters may or may not be the same\"?"
                    },
                    {
                        "username": "jswang00037",
                        "content": "In short, find the maximum variance of substring of s. \\nwhere the variance is difference of count between most/least frequent character in substring. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to use the hint, maybe something is more clear?\ns = \"aababbb\"->[1,1,-1,1,-1,-1,-1] This is  a one-to-one correspondence.\nFind the subarrays   containing  -1 & 1 with the largest sum , say A, and with the smallest sum, say B.\nThen A=[1,1,-1, 1] with sum(A)=2 , B=[-1,1,-1,-1,-1] with sum(B)=-3\nThen take max(abs(sum(A)), abs(sum(B)))=3\nThe subarray corresponds to \"babbb\".\nThere are at most 26 different alphabets in a string. Do it pairwise!"
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "[@seeker_747](/seeker_747) \n\nPay attention to description:\nThe variance of a string is defined as the LARGEST difference between the number of occurrences of ANY 2 characters present in the string. \n\nSo you need to consider only two different chars at one moment ignoring any others.\n\nIn example \"abbbcecfffaaccaaddea\" actually the largest diff is the one between \"e\" and \"a\" in \"abbbcecfffaaccaa\" (5 \"a\" and 1 \"e\", 5 - 1 = 4)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@anwendeng](/anwendeng) We can do better.\\nWe can do $26 N$ rather than $26^2 N$:\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@seeker_747](/seeker_747)  There are 26 alphabets.  Do it pairwise, in the ways of 26*25/2 combinations"
                    },
                    {
                        "username": "seeker_747",
                        "content": "what if we had something like \\'abbbcecfffaaccaaddea\\' (too many duplicate characters ) ,then how would we write the one to one correspondence array "
                    },
                    {
                        "username": "roman-mc",
                        "content": "Having more test cases provided would definitely help to understand task more :) "
                    },
                    {
                        "username": "dev-null0",
                        "content": "Didn't read the problem yet... but holy crap, stop with the back-to-back hard's please..."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those getting confused in what the question demands \nIts basically saying to find the maximum variance amongst substring of s. Where the variance is difference of count between most/least frequent character in substring. \nWhen they say \" two characters may or may not be the same.\" : it is just for saying if there is only one unique character : answer is zero.\n\nNow do the question, have a great weekend!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "thank you so much\\n"
                    }
                ]
            },
            {
                "id": 1962210,
                "content": [
                    {
                        "username": "darlingmidas",
                        "content": "I had this problem in an Amazon assessment recently. I think I ended up getting half of tests passing with a recursive solution. Didn\\'t have time to analyze runtime. I ended up advancing to onsite interview! Wish me luck."
                    },
                    {
                        "username": "khe1154",
                        "content": "[@sachin269](/sachin269) i do not think recursion is necessary. you can use nested for loop to generate substring. the calculate frequency and then calculate the variance.\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function (s) {\\n  const n = s.length;\\n  let maxVariance = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const substring = s.substring(i, j + 1);\\n      const freq = {};\\n\\n      for (let k = 0; k < substring.length; k++) {\\n        const c = substring[k];\\n        if (c in freq) {\\n          freq[c]++;\\n        } else {\\n          freq[c] = 1;\\n        }\\n      }\\n\\n      const values = Object.values(freq);\\n      const variance = Math.max(...values) - Math.min(...values);\\n      maxVariance = Math.max(maxVariance, variance);\\n    }\\n  }\\n\\n  return maxVariance;\\n\\n};\\n```"
                    },
                    {
                        "username": "pradeepmahato007",
                        "content": "All the best!!"
                    },
                    {
                        "username": "sachin269",
                        "content": "[@tjstinso](/tjstinso) can you help me knowing the recursive approach?"
                    },
                    {
                        "username": "wareag1e",
                        "content": "[@Maksadbek](/Maksadbek) Not necessarily. Maybe he has another account to practice problems. LOL"
                    },
                    {
                        "username": "tjstinso",
                        "content": "my initial implementation was a recursive one that passed something like 2/3rds. The actual optimization is pretty slick when you realize the trick, but I would not like to need the optimal solution in an interview. The first hint available is enough of a clue to implement this as the well-known algorithm with modifications, but there are more edge cases than the original problem. This could be a bit of a haul in an interview if the interviewer was just trying to break ankles."
                    },
                    {
                        "username": "Maksadbek",
                        "content": "[@JRajasri](/JRajasri) Looks like he passed the interview as he don\\'t open Leetcode."
                    },
                    {
                        "username": "JRajasri",
                        "content": "Hello. How did your onsite go ?"
                    },
                    {
                        "username": "madness97",
                        "content": "DIdnt understand the example the questions provided too."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@0x6B0](/0x6B0) Than you take the most frequent one and the least frequent one and subtract them from each other. \\n\\nSo say you have string \"abbccccba\", you have 4 c\\'s and 2 a\\'s so that string will have a variance of 2. (The smaller substring \\'bcccc\\' will have 4 c\\'s and 1 be so that substring will have a variance of 3, which will ultimately by your answer). \\n\\nFor coming up with the solution I think the most straight forward way is to compare all the letters pairwise, so I made a matrix of 26 by 26 and to compare each letter against all other letters, filling each of those cells with an array of +1 and -1, as suggested in the hints. And than go through all the arrays in the matrix to find the largest possible sum.  "
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@Mister_CK](/Mister_CK) But what if there are more than 2 letters in that substring? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference.\\n\\nThat\\'s how I would phrase it."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Leetcode\\'s obsession with hard questions on weekends :)"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "It makes sense since ppl usually have more spare time on weekend"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I don\\'t understand what the question is asking me to do."
                    },
                    {
                        "username": "mrb15",
                        "content": "sliding window hangover\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@whoisslimshady](/whoisslimshady) You can, it just gives TLE :P "
                    },
                    {
                        "username": "whoisslimshady",
                        "content": "for real even though i haven\\'t practice sliding window from long time still i though this can be done using sliding window"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Confused what the question is asking. Example explains absolutely nothing as well"
                    },
                    {
                        "username": "tifv",
                        "content": "[@Rishu_sh](/Rishu_sh) Yeah, this part was somewhat confusing. I guess it is accounting for cases like `aaaaa`, where there are no two different characters (the variance in this case is zero). You can ignore this sentence for all other cases."
                    },
                    {
                        "username": "Rishu_sh",
                        "content": "[@jswang00037](/jswang00037)  what is meant by this line : \"Note the two characters may or may not be the same\"?"
                    },
                    {
                        "username": "jswang00037",
                        "content": "In short, find the maximum variance of substring of s. \\nwhere the variance is difference of count between most/least frequent character in substring. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to use the hint, maybe something is more clear?\ns = \"aababbb\"->[1,1,-1,1,-1,-1,-1] This is  a one-to-one correspondence.\nFind the subarrays   containing  -1 & 1 with the largest sum , say A, and with the smallest sum, say B.\nThen A=[1,1,-1, 1] with sum(A)=2 , B=[-1,1,-1,-1,-1] with sum(B)=-3\nThen take max(abs(sum(A)), abs(sum(B)))=3\nThe subarray corresponds to \"babbb\".\nThere are at most 26 different alphabets in a string. Do it pairwise!"
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "[@seeker_747](/seeker_747) \n\nPay attention to description:\nThe variance of a string is defined as the LARGEST difference between the number of occurrences of ANY 2 characters present in the string. \n\nSo you need to consider only two different chars at one moment ignoring any others.\n\nIn example \"abbbcecfffaaccaaddea\" actually the largest diff is the one between \"e\" and \"a\" in \"abbbcecfffaaccaa\" (5 \"a\" and 1 \"e\", 5 - 1 = 4)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@anwendeng](/anwendeng) We can do better.\\nWe can do $26 N$ rather than $26^2 N$:\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@seeker_747](/seeker_747)  There are 26 alphabets.  Do it pairwise, in the ways of 26*25/2 combinations"
                    },
                    {
                        "username": "seeker_747",
                        "content": "what if we had something like \\'abbbcecfffaaccaaddea\\' (too many duplicate characters ) ,then how would we write the one to one correspondence array "
                    },
                    {
                        "username": "roman-mc",
                        "content": "Having more test cases provided would definitely help to understand task more :) "
                    },
                    {
                        "username": "dev-null0",
                        "content": "Didn't read the problem yet... but holy crap, stop with the back-to-back hard's please..."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those getting confused in what the question demands \nIts basically saying to find the maximum variance amongst substring of s. Where the variance is difference of count between most/least frequent character in substring. \nWhen they say \" two characters may or may not be the same.\" : it is just for saying if there is only one unique character : answer is zero.\n\nNow do the question, have a great weekend!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "thank you so much\\n"
                    }
                ]
            },
            {
                "id": 1962083,
                "content": [
                    {
                        "username": "darlingmidas",
                        "content": "I had this problem in an Amazon assessment recently. I think I ended up getting half of tests passing with a recursive solution. Didn\\'t have time to analyze runtime. I ended up advancing to onsite interview! Wish me luck."
                    },
                    {
                        "username": "khe1154",
                        "content": "[@sachin269](/sachin269) i do not think recursion is necessary. you can use nested for loop to generate substring. the calculate frequency and then calculate the variance.\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function (s) {\\n  const n = s.length;\\n  let maxVariance = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const substring = s.substring(i, j + 1);\\n      const freq = {};\\n\\n      for (let k = 0; k < substring.length; k++) {\\n        const c = substring[k];\\n        if (c in freq) {\\n          freq[c]++;\\n        } else {\\n          freq[c] = 1;\\n        }\\n      }\\n\\n      const values = Object.values(freq);\\n      const variance = Math.max(...values) - Math.min(...values);\\n      maxVariance = Math.max(maxVariance, variance);\\n    }\\n  }\\n\\n  return maxVariance;\\n\\n};\\n```"
                    },
                    {
                        "username": "pradeepmahato007",
                        "content": "All the best!!"
                    },
                    {
                        "username": "sachin269",
                        "content": "[@tjstinso](/tjstinso) can you help me knowing the recursive approach?"
                    },
                    {
                        "username": "wareag1e",
                        "content": "[@Maksadbek](/Maksadbek) Not necessarily. Maybe he has another account to practice problems. LOL"
                    },
                    {
                        "username": "tjstinso",
                        "content": "my initial implementation was a recursive one that passed something like 2/3rds. The actual optimization is pretty slick when you realize the trick, but I would not like to need the optimal solution in an interview. The first hint available is enough of a clue to implement this as the well-known algorithm with modifications, but there are more edge cases than the original problem. This could be a bit of a haul in an interview if the interviewer was just trying to break ankles."
                    },
                    {
                        "username": "Maksadbek",
                        "content": "[@JRajasri](/JRajasri) Looks like he passed the interview as he don\\'t open Leetcode."
                    },
                    {
                        "username": "JRajasri",
                        "content": "Hello. How did your onsite go ?"
                    },
                    {
                        "username": "madness97",
                        "content": "DIdnt understand the example the questions provided too."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@0x6B0](/0x6B0) Than you take the most frequent one and the least frequent one and subtract them from each other. \\n\\nSo say you have string \"abbccccba\", you have 4 c\\'s and 2 a\\'s so that string will have a variance of 2. (The smaller substring \\'bcccc\\' will have 4 c\\'s and 1 be so that substring will have a variance of 3, which will ultimately by your answer). \\n\\nFor coming up with the solution I think the most straight forward way is to compare all the letters pairwise, so I made a matrix of 26 by 26 and to compare each letter against all other letters, filling each of those cells with an array of +1 and -1, as suggested in the hints. And than go through all the arrays in the matrix to find the largest possible sum.  "
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@Mister_CK](/Mister_CK) But what if there are more than 2 letters in that substring? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference.\\n\\nThat\\'s how I would phrase it."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Leetcode\\'s obsession with hard questions on weekends :)"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "It makes sense since ppl usually have more spare time on weekend"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I don\\'t understand what the question is asking me to do."
                    },
                    {
                        "username": "mrb15",
                        "content": "sliding window hangover\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@whoisslimshady](/whoisslimshady) You can, it just gives TLE :P "
                    },
                    {
                        "username": "whoisslimshady",
                        "content": "for real even though i haven\\'t practice sliding window from long time still i though this can be done using sliding window"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Confused what the question is asking. Example explains absolutely nothing as well"
                    },
                    {
                        "username": "tifv",
                        "content": "[@Rishu_sh](/Rishu_sh) Yeah, this part was somewhat confusing. I guess it is accounting for cases like `aaaaa`, where there are no two different characters (the variance in this case is zero). You can ignore this sentence for all other cases."
                    },
                    {
                        "username": "Rishu_sh",
                        "content": "[@jswang00037](/jswang00037)  what is meant by this line : \"Note the two characters may or may not be the same\"?"
                    },
                    {
                        "username": "jswang00037",
                        "content": "In short, find the maximum variance of substring of s. \\nwhere the variance is difference of count between most/least frequent character in substring. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to use the hint, maybe something is more clear?\ns = \"aababbb\"->[1,1,-1,1,-1,-1,-1] This is  a one-to-one correspondence.\nFind the subarrays   containing  -1 & 1 with the largest sum , say A, and with the smallest sum, say B.\nThen A=[1,1,-1, 1] with sum(A)=2 , B=[-1,1,-1,-1,-1] with sum(B)=-3\nThen take max(abs(sum(A)), abs(sum(B)))=3\nThe subarray corresponds to \"babbb\".\nThere are at most 26 different alphabets in a string. Do it pairwise!"
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "[@seeker_747](/seeker_747) \n\nPay attention to description:\nThe variance of a string is defined as the LARGEST difference between the number of occurrences of ANY 2 characters present in the string. \n\nSo you need to consider only two different chars at one moment ignoring any others.\n\nIn example \"abbbcecfffaaccaaddea\" actually the largest diff is the one between \"e\" and \"a\" in \"abbbcecfffaaccaa\" (5 \"a\" and 1 \"e\", 5 - 1 = 4)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@anwendeng](/anwendeng) We can do better.\\nWe can do $26 N$ rather than $26^2 N$:\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@seeker_747](/seeker_747)  There are 26 alphabets.  Do it pairwise, in the ways of 26*25/2 combinations"
                    },
                    {
                        "username": "seeker_747",
                        "content": "what if we had something like \\'abbbcecfffaaccaaddea\\' (too many duplicate characters ) ,then how would we write the one to one correspondence array "
                    },
                    {
                        "username": "roman-mc",
                        "content": "Having more test cases provided would definitely help to understand task more :) "
                    },
                    {
                        "username": "dev-null0",
                        "content": "Didn't read the problem yet... but holy crap, stop with the back-to-back hard's please..."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those getting confused in what the question demands \nIts basically saying to find the maximum variance amongst substring of s. Where the variance is difference of count between most/least frequent character in substring. \nWhen they say \" two characters may or may not be the same.\" : it is just for saying if there is only one unique character : answer is zero.\n\nNow do the question, have a great weekend!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "thank you so much\\n"
                    }
                ]
            },
            {
                "id": 1962418,
                "content": [
                    {
                        "username": "darlingmidas",
                        "content": "I had this problem in an Amazon assessment recently. I think I ended up getting half of tests passing with a recursive solution. Didn\\'t have time to analyze runtime. I ended up advancing to onsite interview! Wish me luck."
                    },
                    {
                        "username": "khe1154",
                        "content": "[@sachin269](/sachin269) i do not think recursion is necessary. you can use nested for loop to generate substring. the calculate frequency and then calculate the variance.\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function (s) {\\n  const n = s.length;\\n  let maxVariance = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const substring = s.substring(i, j + 1);\\n      const freq = {};\\n\\n      for (let k = 0; k < substring.length; k++) {\\n        const c = substring[k];\\n        if (c in freq) {\\n          freq[c]++;\\n        } else {\\n          freq[c] = 1;\\n        }\\n      }\\n\\n      const values = Object.values(freq);\\n      const variance = Math.max(...values) - Math.min(...values);\\n      maxVariance = Math.max(maxVariance, variance);\\n    }\\n  }\\n\\n  return maxVariance;\\n\\n};\\n```"
                    },
                    {
                        "username": "pradeepmahato007",
                        "content": "All the best!!"
                    },
                    {
                        "username": "sachin269",
                        "content": "[@tjstinso](/tjstinso) can you help me knowing the recursive approach?"
                    },
                    {
                        "username": "wareag1e",
                        "content": "[@Maksadbek](/Maksadbek) Not necessarily. Maybe he has another account to practice problems. LOL"
                    },
                    {
                        "username": "tjstinso",
                        "content": "my initial implementation was a recursive one that passed something like 2/3rds. The actual optimization is pretty slick when you realize the trick, but I would not like to need the optimal solution in an interview. The first hint available is enough of a clue to implement this as the well-known algorithm with modifications, but there are more edge cases than the original problem. This could be a bit of a haul in an interview if the interviewer was just trying to break ankles."
                    },
                    {
                        "username": "Maksadbek",
                        "content": "[@JRajasri](/JRajasri) Looks like he passed the interview as he don\\'t open Leetcode."
                    },
                    {
                        "username": "JRajasri",
                        "content": "Hello. How did your onsite go ?"
                    },
                    {
                        "username": "madness97",
                        "content": "DIdnt understand the example the questions provided too."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@0x6B0](/0x6B0) Than you take the most frequent one and the least frequent one and subtract them from each other. \\n\\nSo say you have string \"abbccccba\", you have 4 c\\'s and 2 a\\'s so that string will have a variance of 2. (The smaller substring \\'bcccc\\' will have 4 c\\'s and 1 be so that substring will have a variance of 3, which will ultimately by your answer). \\n\\nFor coming up with the solution I think the most straight forward way is to compare all the letters pairwise, so I made a matrix of 26 by 26 and to compare each letter against all other letters, filling each of those cells with an array of +1 and -1, as suggested in the hints. And than go through all the arrays in the matrix to find the largest possible sum.  "
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@Mister_CK](/Mister_CK) But what if there are more than 2 letters in that substring? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference.\\n\\nThat\\'s how I would phrase it."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Leetcode\\'s obsession with hard questions on weekends :)"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "It makes sense since ppl usually have more spare time on weekend"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I don\\'t understand what the question is asking me to do."
                    },
                    {
                        "username": "mrb15",
                        "content": "sliding window hangover\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@whoisslimshady](/whoisslimshady) You can, it just gives TLE :P "
                    },
                    {
                        "username": "whoisslimshady",
                        "content": "for real even though i haven\\'t practice sliding window from long time still i though this can be done using sliding window"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Confused what the question is asking. Example explains absolutely nothing as well"
                    },
                    {
                        "username": "tifv",
                        "content": "[@Rishu_sh](/Rishu_sh) Yeah, this part was somewhat confusing. I guess it is accounting for cases like `aaaaa`, where there are no two different characters (the variance in this case is zero). You can ignore this sentence for all other cases."
                    },
                    {
                        "username": "Rishu_sh",
                        "content": "[@jswang00037](/jswang00037)  what is meant by this line : \"Note the two characters may or may not be the same\"?"
                    },
                    {
                        "username": "jswang00037",
                        "content": "In short, find the maximum variance of substring of s. \\nwhere the variance is difference of count between most/least frequent character in substring. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to use the hint, maybe something is more clear?\ns = \"aababbb\"->[1,1,-1,1,-1,-1,-1] This is  a one-to-one correspondence.\nFind the subarrays   containing  -1 & 1 with the largest sum , say A, and with the smallest sum, say B.\nThen A=[1,1,-1, 1] with sum(A)=2 , B=[-1,1,-1,-1,-1] with sum(B)=-3\nThen take max(abs(sum(A)), abs(sum(B)))=3\nThe subarray corresponds to \"babbb\".\nThere are at most 26 different alphabets in a string. Do it pairwise!"
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "[@seeker_747](/seeker_747) \n\nPay attention to description:\nThe variance of a string is defined as the LARGEST difference between the number of occurrences of ANY 2 characters present in the string. \n\nSo you need to consider only two different chars at one moment ignoring any others.\n\nIn example \"abbbcecfffaaccaaddea\" actually the largest diff is the one between \"e\" and \"a\" in \"abbbcecfffaaccaa\" (5 \"a\" and 1 \"e\", 5 - 1 = 4)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@anwendeng](/anwendeng) We can do better.\\nWe can do $26 N$ rather than $26^2 N$:\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@seeker_747](/seeker_747)  There are 26 alphabets.  Do it pairwise, in the ways of 26*25/2 combinations"
                    },
                    {
                        "username": "seeker_747",
                        "content": "what if we had something like \\'abbbcecfffaaccaaddea\\' (too many duplicate characters ) ,then how would we write the one to one correspondence array "
                    },
                    {
                        "username": "roman-mc",
                        "content": "Having more test cases provided would definitely help to understand task more :) "
                    },
                    {
                        "username": "dev-null0",
                        "content": "Didn't read the problem yet... but holy crap, stop with the back-to-back hard's please..."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those getting confused in what the question demands \nIts basically saying to find the maximum variance amongst substring of s. Where the variance is difference of count between most/least frequent character in substring. \nWhen they say \" two characters may or may not be the same.\" : it is just for saying if there is only one unique character : answer is zero.\n\nNow do the question, have a great weekend!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "thank you so much\\n"
                    }
                ]
            },
            {
                "id": 1652985,
                "content": [
                    {
                        "username": "darlingmidas",
                        "content": "I had this problem in an Amazon assessment recently. I think I ended up getting half of tests passing with a recursive solution. Didn\\'t have time to analyze runtime. I ended up advancing to onsite interview! Wish me luck."
                    },
                    {
                        "username": "khe1154",
                        "content": "[@sachin269](/sachin269) i do not think recursion is necessary. you can use nested for loop to generate substring. the calculate frequency and then calculate the variance.\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function (s) {\\n  const n = s.length;\\n  let maxVariance = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const substring = s.substring(i, j + 1);\\n      const freq = {};\\n\\n      for (let k = 0; k < substring.length; k++) {\\n        const c = substring[k];\\n        if (c in freq) {\\n          freq[c]++;\\n        } else {\\n          freq[c] = 1;\\n        }\\n      }\\n\\n      const values = Object.values(freq);\\n      const variance = Math.max(...values) - Math.min(...values);\\n      maxVariance = Math.max(maxVariance, variance);\\n    }\\n  }\\n\\n  return maxVariance;\\n\\n};\\n```"
                    },
                    {
                        "username": "pradeepmahato007",
                        "content": "All the best!!"
                    },
                    {
                        "username": "sachin269",
                        "content": "[@tjstinso](/tjstinso) can you help me knowing the recursive approach?"
                    },
                    {
                        "username": "wareag1e",
                        "content": "[@Maksadbek](/Maksadbek) Not necessarily. Maybe he has another account to practice problems. LOL"
                    },
                    {
                        "username": "tjstinso",
                        "content": "my initial implementation was a recursive one that passed something like 2/3rds. The actual optimization is pretty slick when you realize the trick, but I would not like to need the optimal solution in an interview. The first hint available is enough of a clue to implement this as the well-known algorithm with modifications, but there are more edge cases than the original problem. This could be a bit of a haul in an interview if the interviewer was just trying to break ankles."
                    },
                    {
                        "username": "Maksadbek",
                        "content": "[@JRajasri](/JRajasri) Looks like he passed the interview as he don\\'t open Leetcode."
                    },
                    {
                        "username": "JRajasri",
                        "content": "Hello. How did your onsite go ?"
                    },
                    {
                        "username": "madness97",
                        "content": "DIdnt understand the example the questions provided too."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@0x6B0](/0x6B0) Than you take the most frequent one and the least frequent one and subtract them from each other. \\n\\nSo say you have string \"abbccccba\", you have 4 c\\'s and 2 a\\'s so that string will have a variance of 2. (The smaller substring \\'bcccc\\' will have 4 c\\'s and 1 be so that substring will have a variance of 3, which will ultimately by your answer). \\n\\nFor coming up with the solution I think the most straight forward way is to compare all the letters pairwise, so I made a matrix of 26 by 26 and to compare each letter against all other letters, filling each of those cells with an array of +1 and -1, as suggested in the hints. And than go through all the arrays in the matrix to find the largest possible sum.  "
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@Mister_CK](/Mister_CK) But what if there are more than 2 letters in that substring? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference.\\n\\nThat\\'s how I would phrase it."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Leetcode\\'s obsession with hard questions on weekends :)"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "It makes sense since ppl usually have more spare time on weekend"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I don\\'t understand what the question is asking me to do."
                    },
                    {
                        "username": "mrb15",
                        "content": "sliding window hangover\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@whoisslimshady](/whoisslimshady) You can, it just gives TLE :P "
                    },
                    {
                        "username": "whoisslimshady",
                        "content": "for real even though i haven\\'t practice sliding window from long time still i though this can be done using sliding window"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Confused what the question is asking. Example explains absolutely nothing as well"
                    },
                    {
                        "username": "tifv",
                        "content": "[@Rishu_sh](/Rishu_sh) Yeah, this part was somewhat confusing. I guess it is accounting for cases like `aaaaa`, where there are no two different characters (the variance in this case is zero). You can ignore this sentence for all other cases."
                    },
                    {
                        "username": "Rishu_sh",
                        "content": "[@jswang00037](/jswang00037)  what is meant by this line : \"Note the two characters may or may not be the same\"?"
                    },
                    {
                        "username": "jswang00037",
                        "content": "In short, find the maximum variance of substring of s. \\nwhere the variance is difference of count between most/least frequent character in substring. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to use the hint, maybe something is more clear?\ns = \"aababbb\"->[1,1,-1,1,-1,-1,-1] This is  a one-to-one correspondence.\nFind the subarrays   containing  -1 & 1 with the largest sum , say A, and with the smallest sum, say B.\nThen A=[1,1,-1, 1] with sum(A)=2 , B=[-1,1,-1,-1,-1] with sum(B)=-3\nThen take max(abs(sum(A)), abs(sum(B)))=3\nThe subarray corresponds to \"babbb\".\nThere are at most 26 different alphabets in a string. Do it pairwise!"
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "[@seeker_747](/seeker_747) \n\nPay attention to description:\nThe variance of a string is defined as the LARGEST difference between the number of occurrences of ANY 2 characters present in the string. \n\nSo you need to consider only two different chars at one moment ignoring any others.\n\nIn example \"abbbcecfffaaccaaddea\" actually the largest diff is the one between \"e\" and \"a\" in \"abbbcecfffaaccaa\" (5 \"a\" and 1 \"e\", 5 - 1 = 4)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@anwendeng](/anwendeng) We can do better.\\nWe can do $26 N$ rather than $26^2 N$:\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@seeker_747](/seeker_747)  There are 26 alphabets.  Do it pairwise, in the ways of 26*25/2 combinations"
                    },
                    {
                        "username": "seeker_747",
                        "content": "what if we had something like \\'abbbcecfffaaccaaddea\\' (too many duplicate characters ) ,then how would we write the one to one correspondence array "
                    },
                    {
                        "username": "roman-mc",
                        "content": "Having more test cases provided would definitely help to understand task more :) "
                    },
                    {
                        "username": "dev-null0",
                        "content": "Didn't read the problem yet... but holy crap, stop with the back-to-back hard's please..."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those getting confused in what the question demands \nIts basically saying to find the maximum variance amongst substring of s. Where the variance is difference of count between most/least frequent character in substring. \nWhen they say \" two characters may or may not be the same.\" : it is just for saying if there is only one unique character : answer is zero.\n\nNow do the question, have a great weekend!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "thank you so much\\n"
                    }
                ]
            },
            {
                "id": 1567133,
                "content": [
                    {
                        "username": "darlingmidas",
                        "content": "I had this problem in an Amazon assessment recently. I think I ended up getting half of tests passing with a recursive solution. Didn\\'t have time to analyze runtime. I ended up advancing to onsite interview! Wish me luck."
                    },
                    {
                        "username": "khe1154",
                        "content": "[@sachin269](/sachin269) i do not think recursion is necessary. you can use nested for loop to generate substring. the calculate frequency and then calculate the variance.\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function (s) {\\n  const n = s.length;\\n  let maxVariance = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const substring = s.substring(i, j + 1);\\n      const freq = {};\\n\\n      for (let k = 0; k < substring.length; k++) {\\n        const c = substring[k];\\n        if (c in freq) {\\n          freq[c]++;\\n        } else {\\n          freq[c] = 1;\\n        }\\n      }\\n\\n      const values = Object.values(freq);\\n      const variance = Math.max(...values) - Math.min(...values);\\n      maxVariance = Math.max(maxVariance, variance);\\n    }\\n  }\\n\\n  return maxVariance;\\n\\n};\\n```"
                    },
                    {
                        "username": "pradeepmahato007",
                        "content": "All the best!!"
                    },
                    {
                        "username": "sachin269",
                        "content": "[@tjstinso](/tjstinso) can you help me knowing the recursive approach?"
                    },
                    {
                        "username": "wareag1e",
                        "content": "[@Maksadbek](/Maksadbek) Not necessarily. Maybe he has another account to practice problems. LOL"
                    },
                    {
                        "username": "tjstinso",
                        "content": "my initial implementation was a recursive one that passed something like 2/3rds. The actual optimization is pretty slick when you realize the trick, but I would not like to need the optimal solution in an interview. The first hint available is enough of a clue to implement this as the well-known algorithm with modifications, but there are more edge cases than the original problem. This could be a bit of a haul in an interview if the interviewer was just trying to break ankles."
                    },
                    {
                        "username": "Maksadbek",
                        "content": "[@JRajasri](/JRajasri) Looks like he passed the interview as he don\\'t open Leetcode."
                    },
                    {
                        "username": "JRajasri",
                        "content": "Hello. How did your onsite go ?"
                    },
                    {
                        "username": "madness97",
                        "content": "DIdnt understand the example the questions provided too."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@0x6B0](/0x6B0) Than you take the most frequent one and the least frequent one and subtract them from each other. \\n\\nSo say you have string \"abbccccba\", you have 4 c\\'s and 2 a\\'s so that string will have a variance of 2. (The smaller substring \\'bcccc\\' will have 4 c\\'s and 1 be so that substring will have a variance of 3, which will ultimately by your answer). \\n\\nFor coming up with the solution I think the most straight forward way is to compare all the letters pairwise, so I made a matrix of 26 by 26 and to compare each letter against all other letters, filling each of those cells with an array of +1 and -1, as suggested in the hints. And than go through all the arrays in the matrix to find the largest possible sum.  "
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@Mister_CK](/Mister_CK) But what if there are more than 2 letters in that substring? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference.\\n\\nThat\\'s how I would phrase it."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Leetcode\\'s obsession with hard questions on weekends :)"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "It makes sense since ppl usually have more spare time on weekend"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I don\\'t understand what the question is asking me to do."
                    },
                    {
                        "username": "mrb15",
                        "content": "sliding window hangover\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@whoisslimshady](/whoisslimshady) You can, it just gives TLE :P "
                    },
                    {
                        "username": "whoisslimshady",
                        "content": "for real even though i haven\\'t practice sliding window from long time still i though this can be done using sliding window"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Confused what the question is asking. Example explains absolutely nothing as well"
                    },
                    {
                        "username": "tifv",
                        "content": "[@Rishu_sh](/Rishu_sh) Yeah, this part was somewhat confusing. I guess it is accounting for cases like `aaaaa`, where there are no two different characters (the variance in this case is zero). You can ignore this sentence for all other cases."
                    },
                    {
                        "username": "Rishu_sh",
                        "content": "[@jswang00037](/jswang00037)  what is meant by this line : \"Note the two characters may or may not be the same\"?"
                    },
                    {
                        "username": "jswang00037",
                        "content": "In short, find the maximum variance of substring of s. \\nwhere the variance is difference of count between most/least frequent character in substring. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to use the hint, maybe something is more clear?\ns = \"aababbb\"->[1,1,-1,1,-1,-1,-1] This is  a one-to-one correspondence.\nFind the subarrays   containing  -1 & 1 with the largest sum , say A, and with the smallest sum, say B.\nThen A=[1,1,-1, 1] with sum(A)=2 , B=[-1,1,-1,-1,-1] with sum(B)=-3\nThen take max(abs(sum(A)), abs(sum(B)))=3\nThe subarray corresponds to \"babbb\".\nThere are at most 26 different alphabets in a string. Do it pairwise!"
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "[@seeker_747](/seeker_747) \n\nPay attention to description:\nThe variance of a string is defined as the LARGEST difference between the number of occurrences of ANY 2 characters present in the string. \n\nSo you need to consider only two different chars at one moment ignoring any others.\n\nIn example \"abbbcecfffaaccaaddea\" actually the largest diff is the one between \"e\" and \"a\" in \"abbbcecfffaaccaa\" (5 \"a\" and 1 \"e\", 5 - 1 = 4)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@anwendeng](/anwendeng) We can do better.\\nWe can do $26 N$ rather than $26^2 N$:\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@seeker_747](/seeker_747)  There are 26 alphabets.  Do it pairwise, in the ways of 26*25/2 combinations"
                    },
                    {
                        "username": "seeker_747",
                        "content": "what if we had something like \\'abbbcecfffaaccaaddea\\' (too many duplicate characters ) ,then how would we write the one to one correspondence array "
                    },
                    {
                        "username": "roman-mc",
                        "content": "Having more test cases provided would definitely help to understand task more :) "
                    },
                    {
                        "username": "dev-null0",
                        "content": "Didn't read the problem yet... but holy crap, stop with the back-to-back hard's please..."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those getting confused in what the question demands \nIts basically saying to find the maximum variance amongst substring of s. Where the variance is difference of count between most/least frequent character in substring. \nWhen they say \" two characters may or may not be the same.\" : it is just for saying if there is only one unique character : answer is zero.\n\nNow do the question, have a great weekend!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "thank you so much\\n"
                    }
                ]
            },
            {
                "id": 1962085,
                "content": [
                    {
                        "username": "darlingmidas",
                        "content": "I had this problem in an Amazon assessment recently. I think I ended up getting half of tests passing with a recursive solution. Didn\\'t have time to analyze runtime. I ended up advancing to onsite interview! Wish me luck."
                    },
                    {
                        "username": "khe1154",
                        "content": "[@sachin269](/sachin269) i do not think recursion is necessary. you can use nested for loop to generate substring. the calculate frequency and then calculate the variance.\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function (s) {\\n  const n = s.length;\\n  let maxVariance = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const substring = s.substring(i, j + 1);\\n      const freq = {};\\n\\n      for (let k = 0; k < substring.length; k++) {\\n        const c = substring[k];\\n        if (c in freq) {\\n          freq[c]++;\\n        } else {\\n          freq[c] = 1;\\n        }\\n      }\\n\\n      const values = Object.values(freq);\\n      const variance = Math.max(...values) - Math.min(...values);\\n      maxVariance = Math.max(maxVariance, variance);\\n    }\\n  }\\n\\n  return maxVariance;\\n\\n};\\n```"
                    },
                    {
                        "username": "pradeepmahato007",
                        "content": "All the best!!"
                    },
                    {
                        "username": "sachin269",
                        "content": "[@tjstinso](/tjstinso) can you help me knowing the recursive approach?"
                    },
                    {
                        "username": "wareag1e",
                        "content": "[@Maksadbek](/Maksadbek) Not necessarily. Maybe he has another account to practice problems. LOL"
                    },
                    {
                        "username": "tjstinso",
                        "content": "my initial implementation was a recursive one that passed something like 2/3rds. The actual optimization is pretty slick when you realize the trick, but I would not like to need the optimal solution in an interview. The first hint available is enough of a clue to implement this as the well-known algorithm with modifications, but there are more edge cases than the original problem. This could be a bit of a haul in an interview if the interviewer was just trying to break ankles."
                    },
                    {
                        "username": "Maksadbek",
                        "content": "[@JRajasri](/JRajasri) Looks like he passed the interview as he don\\'t open Leetcode."
                    },
                    {
                        "username": "JRajasri",
                        "content": "Hello. How did your onsite go ?"
                    },
                    {
                        "username": "madness97",
                        "content": "DIdnt understand the example the questions provided too."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@0x6B0](/0x6B0) Than you take the most frequent one and the least frequent one and subtract them from each other. \\n\\nSo say you have string \"abbccccba\", you have 4 c\\'s and 2 a\\'s so that string will have a variance of 2. (The smaller substring \\'bcccc\\' will have 4 c\\'s and 1 be so that substring will have a variance of 3, which will ultimately by your answer). \\n\\nFor coming up with the solution I think the most straight forward way is to compare all the letters pairwise, so I made a matrix of 26 by 26 and to compare each letter against all other letters, filling each of those cells with an array of +1 and -1, as suggested in the hints. And than go through all the arrays in the matrix to find the largest possible sum.  "
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@Mister_CK](/Mister_CK) But what if there are more than 2 letters in that substring? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference.\\n\\nThat\\'s how I would phrase it."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Leetcode\\'s obsession with hard questions on weekends :)"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "It makes sense since ppl usually have more spare time on weekend"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I don\\'t understand what the question is asking me to do."
                    },
                    {
                        "username": "mrb15",
                        "content": "sliding window hangover\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@whoisslimshady](/whoisslimshady) You can, it just gives TLE :P "
                    },
                    {
                        "username": "whoisslimshady",
                        "content": "for real even though i haven\\'t practice sliding window from long time still i though this can be done using sliding window"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Confused what the question is asking. Example explains absolutely nothing as well"
                    },
                    {
                        "username": "tifv",
                        "content": "[@Rishu_sh](/Rishu_sh) Yeah, this part was somewhat confusing. I guess it is accounting for cases like `aaaaa`, where there are no two different characters (the variance in this case is zero). You can ignore this sentence for all other cases."
                    },
                    {
                        "username": "Rishu_sh",
                        "content": "[@jswang00037](/jswang00037)  what is meant by this line : \"Note the two characters may or may not be the same\"?"
                    },
                    {
                        "username": "jswang00037",
                        "content": "In short, find the maximum variance of substring of s. \\nwhere the variance is difference of count between most/least frequent character in substring. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to use the hint, maybe something is more clear?\ns = \"aababbb\"->[1,1,-1,1,-1,-1,-1] This is  a one-to-one correspondence.\nFind the subarrays   containing  -1 & 1 with the largest sum , say A, and with the smallest sum, say B.\nThen A=[1,1,-1, 1] with sum(A)=2 , B=[-1,1,-1,-1,-1] with sum(B)=-3\nThen take max(abs(sum(A)), abs(sum(B)))=3\nThe subarray corresponds to \"babbb\".\nThere are at most 26 different alphabets in a string. Do it pairwise!"
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "[@seeker_747](/seeker_747) \n\nPay attention to description:\nThe variance of a string is defined as the LARGEST difference between the number of occurrences of ANY 2 characters present in the string. \n\nSo you need to consider only two different chars at one moment ignoring any others.\n\nIn example \"abbbcecfffaaccaaddea\" actually the largest diff is the one between \"e\" and \"a\" in \"abbbcecfffaaccaa\" (5 \"a\" and 1 \"e\", 5 - 1 = 4)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@anwendeng](/anwendeng) We can do better.\\nWe can do $26 N$ rather than $26^2 N$:\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@seeker_747](/seeker_747)  There are 26 alphabets.  Do it pairwise, in the ways of 26*25/2 combinations"
                    },
                    {
                        "username": "seeker_747",
                        "content": "what if we had something like \\'abbbcecfffaaccaaddea\\' (too many duplicate characters ) ,then how would we write the one to one correspondence array "
                    },
                    {
                        "username": "roman-mc",
                        "content": "Having more test cases provided would definitely help to understand task more :) "
                    },
                    {
                        "username": "dev-null0",
                        "content": "Didn't read the problem yet... but holy crap, stop with the back-to-back hard's please..."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those getting confused in what the question demands \nIts basically saying to find the maximum variance amongst substring of s. Where the variance is difference of count between most/least frequent character in substring. \nWhen they say \" two characters may or may not be the same.\" : it is just for saying if there is only one unique character : answer is zero.\n\nNow do the question, have a great weekend!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "thank you so much\\n"
                    }
                ]
            },
            {
                "id": 1761484,
                "content": [
                    {
                        "username": "darlingmidas",
                        "content": "I had this problem in an Amazon assessment recently. I think I ended up getting half of tests passing with a recursive solution. Didn\\'t have time to analyze runtime. I ended up advancing to onsite interview! Wish me luck."
                    },
                    {
                        "username": "khe1154",
                        "content": "[@sachin269](/sachin269) i do not think recursion is necessary. you can use nested for loop to generate substring. the calculate frequency and then calculate the variance.\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function (s) {\\n  const n = s.length;\\n  let maxVariance = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const substring = s.substring(i, j + 1);\\n      const freq = {};\\n\\n      for (let k = 0; k < substring.length; k++) {\\n        const c = substring[k];\\n        if (c in freq) {\\n          freq[c]++;\\n        } else {\\n          freq[c] = 1;\\n        }\\n      }\\n\\n      const values = Object.values(freq);\\n      const variance = Math.max(...values) - Math.min(...values);\\n      maxVariance = Math.max(maxVariance, variance);\\n    }\\n  }\\n\\n  return maxVariance;\\n\\n};\\n```"
                    },
                    {
                        "username": "pradeepmahato007",
                        "content": "All the best!!"
                    },
                    {
                        "username": "sachin269",
                        "content": "[@tjstinso](/tjstinso) can you help me knowing the recursive approach?"
                    },
                    {
                        "username": "wareag1e",
                        "content": "[@Maksadbek](/Maksadbek) Not necessarily. Maybe he has another account to practice problems. LOL"
                    },
                    {
                        "username": "tjstinso",
                        "content": "my initial implementation was a recursive one that passed something like 2/3rds. The actual optimization is pretty slick when you realize the trick, but I would not like to need the optimal solution in an interview. The first hint available is enough of a clue to implement this as the well-known algorithm with modifications, but there are more edge cases than the original problem. This could be a bit of a haul in an interview if the interviewer was just trying to break ankles."
                    },
                    {
                        "username": "Maksadbek",
                        "content": "[@JRajasri](/JRajasri) Looks like he passed the interview as he don\\'t open Leetcode."
                    },
                    {
                        "username": "JRajasri",
                        "content": "Hello. How did your onsite go ?"
                    },
                    {
                        "username": "madness97",
                        "content": "DIdnt understand the example the questions provided too."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@0x6B0](/0x6B0) Than you take the most frequent one and the least frequent one and subtract them from each other. \\n\\nSo say you have string \"abbccccba\", you have 4 c\\'s and 2 a\\'s so that string will have a variance of 2. (The smaller substring \\'bcccc\\' will have 4 c\\'s and 1 be so that substring will have a variance of 3, which will ultimately by your answer). \\n\\nFor coming up with the solution I think the most straight forward way is to compare all the letters pairwise, so I made a matrix of 26 by 26 and to compare each letter against all other letters, filling each of those cells with an array of +1 and -1, as suggested in the hints. And than go through all the arrays in the matrix to find the largest possible sum.  "
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@Mister_CK](/Mister_CK) But what if there are more than 2 letters in that substring? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference.\\n\\nThat\\'s how I would phrase it."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Leetcode\\'s obsession with hard questions on weekends :)"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "It makes sense since ppl usually have more spare time on weekend"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I don\\'t understand what the question is asking me to do."
                    },
                    {
                        "username": "mrb15",
                        "content": "sliding window hangover\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@whoisslimshady](/whoisslimshady) You can, it just gives TLE :P "
                    },
                    {
                        "username": "whoisslimshady",
                        "content": "for real even though i haven\\'t practice sliding window from long time still i though this can be done using sliding window"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Confused what the question is asking. Example explains absolutely nothing as well"
                    },
                    {
                        "username": "tifv",
                        "content": "[@Rishu_sh](/Rishu_sh) Yeah, this part was somewhat confusing. I guess it is accounting for cases like `aaaaa`, where there are no two different characters (the variance in this case is zero). You can ignore this sentence for all other cases."
                    },
                    {
                        "username": "Rishu_sh",
                        "content": "[@jswang00037](/jswang00037)  what is meant by this line : \"Note the two characters may or may not be the same\"?"
                    },
                    {
                        "username": "jswang00037",
                        "content": "In short, find the maximum variance of substring of s. \\nwhere the variance is difference of count between most/least frequent character in substring. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to use the hint, maybe something is more clear?\ns = \"aababbb\"->[1,1,-1,1,-1,-1,-1] This is  a one-to-one correspondence.\nFind the subarrays   containing  -1 & 1 with the largest sum , say A, and with the smallest sum, say B.\nThen A=[1,1,-1, 1] with sum(A)=2 , B=[-1,1,-1,-1,-1] with sum(B)=-3\nThen take max(abs(sum(A)), abs(sum(B)))=3\nThe subarray corresponds to \"babbb\".\nThere are at most 26 different alphabets in a string. Do it pairwise!"
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "[@seeker_747](/seeker_747) \n\nPay attention to description:\nThe variance of a string is defined as the LARGEST difference between the number of occurrences of ANY 2 characters present in the string. \n\nSo you need to consider only two different chars at one moment ignoring any others.\n\nIn example \"abbbcecfffaaccaaddea\" actually the largest diff is the one between \"e\" and \"a\" in \"abbbcecfffaaccaa\" (5 \"a\" and 1 \"e\", 5 - 1 = 4)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@anwendeng](/anwendeng) We can do better.\\nWe can do $26 N$ rather than $26^2 N$:\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@seeker_747](/seeker_747)  There are 26 alphabets.  Do it pairwise, in the ways of 26*25/2 combinations"
                    },
                    {
                        "username": "seeker_747",
                        "content": "what if we had something like \\'abbbcecfffaaccaaddea\\' (too many duplicate characters ) ,then how would we write the one to one correspondence array "
                    },
                    {
                        "username": "roman-mc",
                        "content": "Having more test cases provided would definitely help to understand task more :) "
                    },
                    {
                        "username": "dev-null0",
                        "content": "Didn't read the problem yet... but holy crap, stop with the back-to-back hard's please..."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those getting confused in what the question demands \nIts basically saying to find the maximum variance amongst substring of s. Where the variance is difference of count between most/least frequent character in substring. \nWhen they say \" two characters may or may not be the same.\" : it is just for saying if there is only one unique character : answer is zero.\n\nNow do the question, have a great weekend!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "thank you so much\\n"
                    }
                ]
            },
            {
                "id": 1962110,
                "content": [
                    {
                        "username": "darlingmidas",
                        "content": "I had this problem in an Amazon assessment recently. I think I ended up getting half of tests passing with a recursive solution. Didn\\'t have time to analyze runtime. I ended up advancing to onsite interview! Wish me luck."
                    },
                    {
                        "username": "khe1154",
                        "content": "[@sachin269](/sachin269) i do not think recursion is necessary. you can use nested for loop to generate substring. the calculate frequency and then calculate the variance.\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function (s) {\\n  const n = s.length;\\n  let maxVariance = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const substring = s.substring(i, j + 1);\\n      const freq = {};\\n\\n      for (let k = 0; k < substring.length; k++) {\\n        const c = substring[k];\\n        if (c in freq) {\\n          freq[c]++;\\n        } else {\\n          freq[c] = 1;\\n        }\\n      }\\n\\n      const values = Object.values(freq);\\n      const variance = Math.max(...values) - Math.min(...values);\\n      maxVariance = Math.max(maxVariance, variance);\\n    }\\n  }\\n\\n  return maxVariance;\\n\\n};\\n```"
                    },
                    {
                        "username": "pradeepmahato007",
                        "content": "All the best!!"
                    },
                    {
                        "username": "sachin269",
                        "content": "[@tjstinso](/tjstinso) can you help me knowing the recursive approach?"
                    },
                    {
                        "username": "wareag1e",
                        "content": "[@Maksadbek](/Maksadbek) Not necessarily. Maybe he has another account to practice problems. LOL"
                    },
                    {
                        "username": "tjstinso",
                        "content": "my initial implementation was a recursive one that passed something like 2/3rds. The actual optimization is pretty slick when you realize the trick, but I would not like to need the optimal solution in an interview. The first hint available is enough of a clue to implement this as the well-known algorithm with modifications, but there are more edge cases than the original problem. This could be a bit of a haul in an interview if the interviewer was just trying to break ankles."
                    },
                    {
                        "username": "Maksadbek",
                        "content": "[@JRajasri](/JRajasri) Looks like he passed the interview as he don\\'t open Leetcode."
                    },
                    {
                        "username": "JRajasri",
                        "content": "Hello. How did your onsite go ?"
                    },
                    {
                        "username": "madness97",
                        "content": "DIdnt understand the example the questions provided too."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@0x6B0](/0x6B0) Than you take the most frequent one and the least frequent one and subtract them from each other. \\n\\nSo say you have string \"abbccccba\", you have 4 c\\'s and 2 a\\'s so that string will have a variance of 2. (The smaller substring \\'bcccc\\' will have 4 c\\'s and 1 be so that substring will have a variance of 3, which will ultimately by your answer). \\n\\nFor coming up with the solution I think the most straight forward way is to compare all the letters pairwise, so I made a matrix of 26 by 26 and to compare each letter against all other letters, filling each of those cells with an array of +1 and -1, as suggested in the hints. And than go through all the arrays in the matrix to find the largest possible sum.  "
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@Mister_CK](/Mister_CK) But what if there are more than 2 letters in that substring? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference.\\n\\nThat\\'s how I would phrase it."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Leetcode\\'s obsession with hard questions on weekends :)"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "It makes sense since ppl usually have more spare time on weekend"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I don\\'t understand what the question is asking me to do."
                    },
                    {
                        "username": "mrb15",
                        "content": "sliding window hangover\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@whoisslimshady](/whoisslimshady) You can, it just gives TLE :P "
                    },
                    {
                        "username": "whoisslimshady",
                        "content": "for real even though i haven\\'t practice sliding window from long time still i though this can be done using sliding window"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Confused what the question is asking. Example explains absolutely nothing as well"
                    },
                    {
                        "username": "tifv",
                        "content": "[@Rishu_sh](/Rishu_sh) Yeah, this part was somewhat confusing. I guess it is accounting for cases like `aaaaa`, where there are no two different characters (the variance in this case is zero). You can ignore this sentence for all other cases."
                    },
                    {
                        "username": "Rishu_sh",
                        "content": "[@jswang00037](/jswang00037)  what is meant by this line : \"Note the two characters may or may not be the same\"?"
                    },
                    {
                        "username": "jswang00037",
                        "content": "In short, find the maximum variance of substring of s. \\nwhere the variance is difference of count between most/least frequent character in substring. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to use the hint, maybe something is more clear?\ns = \"aababbb\"->[1,1,-1,1,-1,-1,-1] This is  a one-to-one correspondence.\nFind the subarrays   containing  -1 & 1 with the largest sum , say A, and with the smallest sum, say B.\nThen A=[1,1,-1, 1] with sum(A)=2 , B=[-1,1,-1,-1,-1] with sum(B)=-3\nThen take max(abs(sum(A)), abs(sum(B)))=3\nThe subarray corresponds to \"babbb\".\nThere are at most 26 different alphabets in a string. Do it pairwise!"
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "[@seeker_747](/seeker_747) \n\nPay attention to description:\nThe variance of a string is defined as the LARGEST difference between the number of occurrences of ANY 2 characters present in the string. \n\nSo you need to consider only two different chars at one moment ignoring any others.\n\nIn example \"abbbcecfffaaccaaddea\" actually the largest diff is the one between \"e\" and \"a\" in \"abbbcecfffaaccaa\" (5 \"a\" and 1 \"e\", 5 - 1 = 4)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@anwendeng](/anwendeng) We can do better.\\nWe can do $26 N$ rather than $26^2 N$:\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@seeker_747](/seeker_747)  There are 26 alphabets.  Do it pairwise, in the ways of 26*25/2 combinations"
                    },
                    {
                        "username": "seeker_747",
                        "content": "what if we had something like \\'abbbcecfffaaccaaddea\\' (too many duplicate characters ) ,then how would we write the one to one correspondence array "
                    },
                    {
                        "username": "roman-mc",
                        "content": "Having more test cases provided would definitely help to understand task more :) "
                    },
                    {
                        "username": "dev-null0",
                        "content": "Didn't read the problem yet... but holy crap, stop with the back-to-back hard's please..."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those getting confused in what the question demands \nIts basically saying to find the maximum variance amongst substring of s. Where the variance is difference of count between most/least frequent character in substring. \nWhen they say \" two characters may or may not be the same.\" : it is just for saying if there is only one unique character : answer is zero.\n\nNow do the question, have a great weekend!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "thank you so much\\n"
                    }
                ]
            },
            {
                "id": 1962094,
                "content": [
                    {
                        "username": "darlingmidas",
                        "content": "I had this problem in an Amazon assessment recently. I think I ended up getting half of tests passing with a recursive solution. Didn\\'t have time to analyze runtime. I ended up advancing to onsite interview! Wish me luck."
                    },
                    {
                        "username": "khe1154",
                        "content": "[@sachin269](/sachin269) i do not think recursion is necessary. you can use nested for loop to generate substring. the calculate frequency and then calculate the variance.\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function (s) {\\n  const n = s.length;\\n  let maxVariance = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const substring = s.substring(i, j + 1);\\n      const freq = {};\\n\\n      for (let k = 0; k < substring.length; k++) {\\n        const c = substring[k];\\n        if (c in freq) {\\n          freq[c]++;\\n        } else {\\n          freq[c] = 1;\\n        }\\n      }\\n\\n      const values = Object.values(freq);\\n      const variance = Math.max(...values) - Math.min(...values);\\n      maxVariance = Math.max(maxVariance, variance);\\n    }\\n  }\\n\\n  return maxVariance;\\n\\n};\\n```"
                    },
                    {
                        "username": "pradeepmahato007",
                        "content": "All the best!!"
                    },
                    {
                        "username": "sachin269",
                        "content": "[@tjstinso](/tjstinso) can you help me knowing the recursive approach?"
                    },
                    {
                        "username": "wareag1e",
                        "content": "[@Maksadbek](/Maksadbek) Not necessarily. Maybe he has another account to practice problems. LOL"
                    },
                    {
                        "username": "tjstinso",
                        "content": "my initial implementation was a recursive one that passed something like 2/3rds. The actual optimization is pretty slick when you realize the trick, but I would not like to need the optimal solution in an interview. The first hint available is enough of a clue to implement this as the well-known algorithm with modifications, but there are more edge cases than the original problem. This could be a bit of a haul in an interview if the interviewer was just trying to break ankles."
                    },
                    {
                        "username": "Maksadbek",
                        "content": "[@JRajasri](/JRajasri) Looks like he passed the interview as he don\\'t open Leetcode."
                    },
                    {
                        "username": "JRajasri",
                        "content": "Hello. How did your onsite go ?"
                    },
                    {
                        "username": "madness97",
                        "content": "DIdnt understand the example the questions provided too."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@0x6B0](/0x6B0) Than you take the most frequent one and the least frequent one and subtract them from each other. \\n\\nSo say you have string \"abbccccba\", you have 4 c\\'s and 2 a\\'s so that string will have a variance of 2. (The smaller substring \\'bcccc\\' will have 4 c\\'s and 1 be so that substring will have a variance of 3, which will ultimately by your answer). \\n\\nFor coming up with the solution I think the most straight forward way is to compare all the letters pairwise, so I made a matrix of 26 by 26 and to compare each letter against all other letters, filling each of those cells with an array of +1 and -1, as suggested in the hints. And than go through all the arrays in the matrix to find the largest possible sum.  "
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@Mister_CK](/Mister_CK) But what if there are more than 2 letters in that substring? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference.\\n\\nThat\\'s how I would phrase it."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Leetcode\\'s obsession with hard questions on weekends :)"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "It makes sense since ppl usually have more spare time on weekend"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I don\\'t understand what the question is asking me to do."
                    },
                    {
                        "username": "mrb15",
                        "content": "sliding window hangover\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@whoisslimshady](/whoisslimshady) You can, it just gives TLE :P "
                    },
                    {
                        "username": "whoisslimshady",
                        "content": "for real even though i haven\\'t practice sliding window from long time still i though this can be done using sliding window"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Confused what the question is asking. Example explains absolutely nothing as well"
                    },
                    {
                        "username": "tifv",
                        "content": "[@Rishu_sh](/Rishu_sh) Yeah, this part was somewhat confusing. I guess it is accounting for cases like `aaaaa`, where there are no two different characters (the variance in this case is zero). You can ignore this sentence for all other cases."
                    },
                    {
                        "username": "Rishu_sh",
                        "content": "[@jswang00037](/jswang00037)  what is meant by this line : \"Note the two characters may or may not be the same\"?"
                    },
                    {
                        "username": "jswang00037",
                        "content": "In short, find the maximum variance of substring of s. \\nwhere the variance is difference of count between most/least frequent character in substring. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to use the hint, maybe something is more clear?\ns = \"aababbb\"->[1,1,-1,1,-1,-1,-1] This is  a one-to-one correspondence.\nFind the subarrays   containing  -1 & 1 with the largest sum , say A, and with the smallest sum, say B.\nThen A=[1,1,-1, 1] with sum(A)=2 , B=[-1,1,-1,-1,-1] with sum(B)=-3\nThen take max(abs(sum(A)), abs(sum(B)))=3\nThe subarray corresponds to \"babbb\".\nThere are at most 26 different alphabets in a string. Do it pairwise!"
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "[@seeker_747](/seeker_747) \n\nPay attention to description:\nThe variance of a string is defined as the LARGEST difference between the number of occurrences of ANY 2 characters present in the string. \n\nSo you need to consider only two different chars at one moment ignoring any others.\n\nIn example \"abbbcecfffaaccaaddea\" actually the largest diff is the one between \"e\" and \"a\" in \"abbbcecfffaaccaa\" (5 \"a\" and 1 \"e\", 5 - 1 = 4)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@anwendeng](/anwendeng) We can do better.\\nWe can do $26 N$ rather than $26^2 N$:\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@seeker_747](/seeker_747)  There are 26 alphabets.  Do it pairwise, in the ways of 26*25/2 combinations"
                    },
                    {
                        "username": "seeker_747",
                        "content": "what if we had something like \\'abbbcecfffaaccaaddea\\' (too many duplicate characters ) ,then how would we write the one to one correspondence array "
                    },
                    {
                        "username": "roman-mc",
                        "content": "Having more test cases provided would definitely help to understand task more :) "
                    },
                    {
                        "username": "dev-null0",
                        "content": "Didn't read the problem yet... but holy crap, stop with the back-to-back hard's please..."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those getting confused in what the question demands \nIts basically saying to find the maximum variance amongst substring of s. Where the variance is difference of count between most/least frequent character in substring. \nWhen they say \" two characters may or may not be the same.\" : it is just for saying if there is only one unique character : answer is zero.\n\nNow do the question, have a great weekend!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "thank you so much\\n"
                    }
                ]
            },
            {
                "id": 1962092,
                "content": [
                    {
                        "username": "darlingmidas",
                        "content": "I had this problem in an Amazon assessment recently. I think I ended up getting half of tests passing with a recursive solution. Didn\\'t have time to analyze runtime. I ended up advancing to onsite interview! Wish me luck."
                    },
                    {
                        "username": "khe1154",
                        "content": "[@sachin269](/sachin269) i do not think recursion is necessary. you can use nested for loop to generate substring. the calculate frequency and then calculate the variance.\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function (s) {\\n  const n = s.length;\\n  let maxVariance = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const substring = s.substring(i, j + 1);\\n      const freq = {};\\n\\n      for (let k = 0; k < substring.length; k++) {\\n        const c = substring[k];\\n        if (c in freq) {\\n          freq[c]++;\\n        } else {\\n          freq[c] = 1;\\n        }\\n      }\\n\\n      const values = Object.values(freq);\\n      const variance = Math.max(...values) - Math.min(...values);\\n      maxVariance = Math.max(maxVariance, variance);\\n    }\\n  }\\n\\n  return maxVariance;\\n\\n};\\n```"
                    },
                    {
                        "username": "pradeepmahato007",
                        "content": "All the best!!"
                    },
                    {
                        "username": "sachin269",
                        "content": "[@tjstinso](/tjstinso) can you help me knowing the recursive approach?"
                    },
                    {
                        "username": "wareag1e",
                        "content": "[@Maksadbek](/Maksadbek) Not necessarily. Maybe he has another account to practice problems. LOL"
                    },
                    {
                        "username": "tjstinso",
                        "content": "my initial implementation was a recursive one that passed something like 2/3rds. The actual optimization is pretty slick when you realize the trick, but I would not like to need the optimal solution in an interview. The first hint available is enough of a clue to implement this as the well-known algorithm with modifications, but there are more edge cases than the original problem. This could be a bit of a haul in an interview if the interviewer was just trying to break ankles."
                    },
                    {
                        "username": "Maksadbek",
                        "content": "[@JRajasri](/JRajasri) Looks like he passed the interview as he don\\'t open Leetcode."
                    },
                    {
                        "username": "JRajasri",
                        "content": "Hello. How did your onsite go ?"
                    },
                    {
                        "username": "madness97",
                        "content": "DIdnt understand the example the questions provided too."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@0x6B0](/0x6B0) Than you take the most frequent one and the least frequent one and subtract them from each other. \\n\\nSo say you have string \"abbccccba\", you have 4 c\\'s and 2 a\\'s so that string will have a variance of 2. (The smaller substring \\'bcccc\\' will have 4 c\\'s and 1 be so that substring will have a variance of 3, which will ultimately by your answer). \\n\\nFor coming up with the solution I think the most straight forward way is to compare all the letters pairwise, so I made a matrix of 26 by 26 and to compare each letter against all other letters, filling each of those cells with an array of +1 and -1, as suggested in the hints. And than go through all the arrays in the matrix to find the largest possible sum.  "
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@Mister_CK](/Mister_CK) But what if there are more than 2 letters in that substring? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference.\\n\\nThat\\'s how I would phrase it."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Leetcode\\'s obsession with hard questions on weekends :)"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "It makes sense since ppl usually have more spare time on weekend"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I don\\'t understand what the question is asking me to do."
                    },
                    {
                        "username": "mrb15",
                        "content": "sliding window hangover\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@whoisslimshady](/whoisslimshady) You can, it just gives TLE :P "
                    },
                    {
                        "username": "whoisslimshady",
                        "content": "for real even though i haven\\'t practice sliding window from long time still i though this can be done using sliding window"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Confused what the question is asking. Example explains absolutely nothing as well"
                    },
                    {
                        "username": "tifv",
                        "content": "[@Rishu_sh](/Rishu_sh) Yeah, this part was somewhat confusing. I guess it is accounting for cases like `aaaaa`, where there are no two different characters (the variance in this case is zero). You can ignore this sentence for all other cases."
                    },
                    {
                        "username": "Rishu_sh",
                        "content": "[@jswang00037](/jswang00037)  what is meant by this line : \"Note the two characters may or may not be the same\"?"
                    },
                    {
                        "username": "jswang00037",
                        "content": "In short, find the maximum variance of substring of s. \\nwhere the variance is difference of count between most/least frequent character in substring. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to use the hint, maybe something is more clear?\ns = \"aababbb\"->[1,1,-1,1,-1,-1,-1] This is  a one-to-one correspondence.\nFind the subarrays   containing  -1 & 1 with the largest sum , say A, and with the smallest sum, say B.\nThen A=[1,1,-1, 1] with sum(A)=2 , B=[-1,1,-1,-1,-1] with sum(B)=-3\nThen take max(abs(sum(A)), abs(sum(B)))=3\nThe subarray corresponds to \"babbb\".\nThere are at most 26 different alphabets in a string. Do it pairwise!"
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "[@seeker_747](/seeker_747) \n\nPay attention to description:\nThe variance of a string is defined as the LARGEST difference between the number of occurrences of ANY 2 characters present in the string. \n\nSo you need to consider only two different chars at one moment ignoring any others.\n\nIn example \"abbbcecfffaaccaaddea\" actually the largest diff is the one between \"e\" and \"a\" in \"abbbcecfffaaccaa\" (5 \"a\" and 1 \"e\", 5 - 1 = 4)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@anwendeng](/anwendeng) We can do better.\\nWe can do $26 N$ rather than $26^2 N$:\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@seeker_747](/seeker_747)  There are 26 alphabets.  Do it pairwise, in the ways of 26*25/2 combinations"
                    },
                    {
                        "username": "seeker_747",
                        "content": "what if we had something like \\'abbbcecfffaaccaaddea\\' (too many duplicate characters ) ,then how would we write the one to one correspondence array "
                    },
                    {
                        "username": "roman-mc",
                        "content": "Having more test cases provided would definitely help to understand task more :) "
                    },
                    {
                        "username": "dev-null0",
                        "content": "Didn't read the problem yet... but holy crap, stop with the back-to-back hard's please..."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those getting confused in what the question demands \nIts basically saying to find the maximum variance amongst substring of s. Where the variance is difference of count between most/least frequent character in substring. \nWhen they say \" two characters may or may not be the same.\" : it is just for saying if there is only one unique character : answer is zero.\n\nNow do the question, have a great weekend!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "thank you so much\\n"
                    }
                ]
            },
            {
                "id": 1962210,
                "content": [
                    {
                        "username": "darlingmidas",
                        "content": "I had this problem in an Amazon assessment recently. I think I ended up getting half of tests passing with a recursive solution. Didn\\'t have time to analyze runtime. I ended up advancing to onsite interview! Wish me luck."
                    },
                    {
                        "username": "khe1154",
                        "content": "[@sachin269](/sachin269) i do not think recursion is necessary. you can use nested for loop to generate substring. the calculate frequency and then calculate the variance.\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function (s) {\\n  const n = s.length;\\n  let maxVariance = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const substring = s.substring(i, j + 1);\\n      const freq = {};\\n\\n      for (let k = 0; k < substring.length; k++) {\\n        const c = substring[k];\\n        if (c in freq) {\\n          freq[c]++;\\n        } else {\\n          freq[c] = 1;\\n        }\\n      }\\n\\n      const values = Object.values(freq);\\n      const variance = Math.max(...values) - Math.min(...values);\\n      maxVariance = Math.max(maxVariance, variance);\\n    }\\n  }\\n\\n  return maxVariance;\\n\\n};\\n```"
                    },
                    {
                        "username": "pradeepmahato007",
                        "content": "All the best!!"
                    },
                    {
                        "username": "sachin269",
                        "content": "[@tjstinso](/tjstinso) can you help me knowing the recursive approach?"
                    },
                    {
                        "username": "wareag1e",
                        "content": "[@Maksadbek](/Maksadbek) Not necessarily. Maybe he has another account to practice problems. LOL"
                    },
                    {
                        "username": "tjstinso",
                        "content": "my initial implementation was a recursive one that passed something like 2/3rds. The actual optimization is pretty slick when you realize the trick, but I would not like to need the optimal solution in an interview. The first hint available is enough of a clue to implement this as the well-known algorithm with modifications, but there are more edge cases than the original problem. This could be a bit of a haul in an interview if the interviewer was just trying to break ankles."
                    },
                    {
                        "username": "Maksadbek",
                        "content": "[@JRajasri](/JRajasri) Looks like he passed the interview as he don\\'t open Leetcode."
                    },
                    {
                        "username": "JRajasri",
                        "content": "Hello. How did your onsite go ?"
                    },
                    {
                        "username": "madness97",
                        "content": "DIdnt understand the example the questions provided too."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@0x6B0](/0x6B0) Than you take the most frequent one and the least frequent one and subtract them from each other. \\n\\nSo say you have string \"abbccccba\", you have 4 c\\'s and 2 a\\'s so that string will have a variance of 2. (The smaller substring \\'bcccc\\' will have 4 c\\'s and 1 be so that substring will have a variance of 3, which will ultimately by your answer). \\n\\nFor coming up with the solution I think the most straight forward way is to compare all the letters pairwise, so I made a matrix of 26 by 26 and to compare each letter against all other letters, filling each of those cells with an array of +1 and -1, as suggested in the hints. And than go through all the arrays in the matrix to find the largest possible sum.  "
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@Mister_CK](/Mister_CK) But what if there are more than 2 letters in that substring? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference.\\n\\nThat\\'s how I would phrase it."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Leetcode\\'s obsession with hard questions on weekends :)"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "It makes sense since ppl usually have more spare time on weekend"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I don\\'t understand what the question is asking me to do."
                    },
                    {
                        "username": "mrb15",
                        "content": "sliding window hangover\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@whoisslimshady](/whoisslimshady) You can, it just gives TLE :P "
                    },
                    {
                        "username": "whoisslimshady",
                        "content": "for real even though i haven\\'t practice sliding window from long time still i though this can be done using sliding window"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Confused what the question is asking. Example explains absolutely nothing as well"
                    },
                    {
                        "username": "tifv",
                        "content": "[@Rishu_sh](/Rishu_sh) Yeah, this part was somewhat confusing. I guess it is accounting for cases like `aaaaa`, where there are no two different characters (the variance in this case is zero). You can ignore this sentence for all other cases."
                    },
                    {
                        "username": "Rishu_sh",
                        "content": "[@jswang00037](/jswang00037)  what is meant by this line : \"Note the two characters may or may not be the same\"?"
                    },
                    {
                        "username": "jswang00037",
                        "content": "In short, find the maximum variance of substring of s. \\nwhere the variance is difference of count between most/least frequent character in substring. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to use the hint, maybe something is more clear?\ns = \"aababbb\"->[1,1,-1,1,-1,-1,-1] This is  a one-to-one correspondence.\nFind the subarrays   containing  -1 & 1 with the largest sum , say A, and with the smallest sum, say B.\nThen A=[1,1,-1, 1] with sum(A)=2 , B=[-1,1,-1,-1,-1] with sum(B)=-3\nThen take max(abs(sum(A)), abs(sum(B)))=3\nThe subarray corresponds to \"babbb\".\nThere are at most 26 different alphabets in a string. Do it pairwise!"
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "[@seeker_747](/seeker_747) \n\nPay attention to description:\nThe variance of a string is defined as the LARGEST difference between the number of occurrences of ANY 2 characters present in the string. \n\nSo you need to consider only two different chars at one moment ignoring any others.\n\nIn example \"abbbcecfffaaccaaddea\" actually the largest diff is the one between \"e\" and \"a\" in \"abbbcecfffaaccaa\" (5 \"a\" and 1 \"e\", 5 - 1 = 4)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@anwendeng](/anwendeng) We can do better.\\nWe can do $26 N$ rather than $26^2 N$:\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@seeker_747](/seeker_747)  There are 26 alphabets.  Do it pairwise, in the ways of 26*25/2 combinations"
                    },
                    {
                        "username": "seeker_747",
                        "content": "what if we had something like \\'abbbcecfffaaccaaddea\\' (too many duplicate characters ) ,then how would we write the one to one correspondence array "
                    },
                    {
                        "username": "roman-mc",
                        "content": "Having more test cases provided would definitely help to understand task more :) "
                    },
                    {
                        "username": "dev-null0",
                        "content": "Didn't read the problem yet... but holy crap, stop with the back-to-back hard's please..."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those getting confused in what the question demands \nIts basically saying to find the maximum variance amongst substring of s. Where the variance is difference of count between most/least frequent character in substring. \nWhen they say \" two characters may or may not be the same.\" : it is just for saying if there is only one unique character : answer is zero.\n\nNow do the question, have a great weekend!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "thank you so much\\n"
                    }
                ]
            },
            {
                "id": 1962083,
                "content": [
                    {
                        "username": "darlingmidas",
                        "content": "I had this problem in an Amazon assessment recently. I think I ended up getting half of tests passing with a recursive solution. Didn\\'t have time to analyze runtime. I ended up advancing to onsite interview! Wish me luck."
                    },
                    {
                        "username": "khe1154",
                        "content": "[@sachin269](/sachin269) i do not think recursion is necessary. you can use nested for loop to generate substring. the calculate frequency and then calculate the variance.\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function (s) {\\n  const n = s.length;\\n  let maxVariance = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const substring = s.substring(i, j + 1);\\n      const freq = {};\\n\\n      for (let k = 0; k < substring.length; k++) {\\n        const c = substring[k];\\n        if (c in freq) {\\n          freq[c]++;\\n        } else {\\n          freq[c] = 1;\\n        }\\n      }\\n\\n      const values = Object.values(freq);\\n      const variance = Math.max(...values) - Math.min(...values);\\n      maxVariance = Math.max(maxVariance, variance);\\n    }\\n  }\\n\\n  return maxVariance;\\n\\n};\\n```"
                    },
                    {
                        "username": "pradeepmahato007",
                        "content": "All the best!!"
                    },
                    {
                        "username": "sachin269",
                        "content": "[@tjstinso](/tjstinso) can you help me knowing the recursive approach?"
                    },
                    {
                        "username": "wareag1e",
                        "content": "[@Maksadbek](/Maksadbek) Not necessarily. Maybe he has another account to practice problems. LOL"
                    },
                    {
                        "username": "tjstinso",
                        "content": "my initial implementation was a recursive one that passed something like 2/3rds. The actual optimization is pretty slick when you realize the trick, but I would not like to need the optimal solution in an interview. The first hint available is enough of a clue to implement this as the well-known algorithm with modifications, but there are more edge cases than the original problem. This could be a bit of a haul in an interview if the interviewer was just trying to break ankles."
                    },
                    {
                        "username": "Maksadbek",
                        "content": "[@JRajasri](/JRajasri) Looks like he passed the interview as he don\\'t open Leetcode."
                    },
                    {
                        "username": "JRajasri",
                        "content": "Hello. How did your onsite go ?"
                    },
                    {
                        "username": "madness97",
                        "content": "DIdnt understand the example the questions provided too."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@0x6B0](/0x6B0) Than you take the most frequent one and the least frequent one and subtract them from each other. \\n\\nSo say you have string \"abbccccba\", you have 4 c\\'s and 2 a\\'s so that string will have a variance of 2. (The smaller substring \\'bcccc\\' will have 4 c\\'s and 1 be so that substring will have a variance of 3, which will ultimately by your answer). \\n\\nFor coming up with the solution I think the most straight forward way is to compare all the letters pairwise, so I made a matrix of 26 by 26 and to compare each letter against all other letters, filling each of those cells with an array of +1 and -1, as suggested in the hints. And than go through all the arrays in the matrix to find the largest possible sum.  "
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@Mister_CK](/Mister_CK) But what if there are more than 2 letters in that substring? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference.\\n\\nThat\\'s how I would phrase it."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Leetcode\\'s obsession with hard questions on weekends :)"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "It makes sense since ppl usually have more spare time on weekend"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I don\\'t understand what the question is asking me to do."
                    },
                    {
                        "username": "mrb15",
                        "content": "sliding window hangover\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@whoisslimshady](/whoisslimshady) You can, it just gives TLE :P "
                    },
                    {
                        "username": "whoisslimshady",
                        "content": "for real even though i haven\\'t practice sliding window from long time still i though this can be done using sliding window"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Confused what the question is asking. Example explains absolutely nothing as well"
                    },
                    {
                        "username": "tifv",
                        "content": "[@Rishu_sh](/Rishu_sh) Yeah, this part was somewhat confusing. I guess it is accounting for cases like `aaaaa`, where there are no two different characters (the variance in this case is zero). You can ignore this sentence for all other cases."
                    },
                    {
                        "username": "Rishu_sh",
                        "content": "[@jswang00037](/jswang00037)  what is meant by this line : \"Note the two characters may or may not be the same\"?"
                    },
                    {
                        "username": "jswang00037",
                        "content": "In short, find the maximum variance of substring of s. \\nwhere the variance is difference of count between most/least frequent character in substring. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to use the hint, maybe something is more clear?\ns = \"aababbb\"->[1,1,-1,1,-1,-1,-1] This is  a one-to-one correspondence.\nFind the subarrays   containing  -1 & 1 with the largest sum , say A, and with the smallest sum, say B.\nThen A=[1,1,-1, 1] with sum(A)=2 , B=[-1,1,-1,-1,-1] with sum(B)=-3\nThen take max(abs(sum(A)), abs(sum(B)))=3\nThe subarray corresponds to \"babbb\".\nThere are at most 26 different alphabets in a string. Do it pairwise!"
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "[@seeker_747](/seeker_747) \n\nPay attention to description:\nThe variance of a string is defined as the LARGEST difference between the number of occurrences of ANY 2 characters present in the string. \n\nSo you need to consider only two different chars at one moment ignoring any others.\n\nIn example \"abbbcecfffaaccaaddea\" actually the largest diff is the one between \"e\" and \"a\" in \"abbbcecfffaaccaa\" (5 \"a\" and 1 \"e\", 5 - 1 = 4)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@anwendeng](/anwendeng) We can do better.\\nWe can do $26 N$ rather than $26^2 N$:\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@seeker_747](/seeker_747)  There are 26 alphabets.  Do it pairwise, in the ways of 26*25/2 combinations"
                    },
                    {
                        "username": "seeker_747",
                        "content": "what if we had something like \\'abbbcecfffaaccaaddea\\' (too many duplicate characters ) ,then how would we write the one to one correspondence array "
                    },
                    {
                        "username": "roman-mc",
                        "content": "Having more test cases provided would definitely help to understand task more :) "
                    },
                    {
                        "username": "dev-null0",
                        "content": "Didn't read the problem yet... but holy crap, stop with the back-to-back hard's please..."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those getting confused in what the question demands \nIts basically saying to find the maximum variance amongst substring of s. Where the variance is difference of count between most/least frequent character in substring. \nWhen they say \" two characters may or may not be the same.\" : it is just for saying if there is only one unique character : answer is zero.\n\nNow do the question, have a great weekend!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "thank you so much\\n"
                    }
                ]
            },
            {
                "id": 1962418,
                "content": [
                    {
                        "username": "darlingmidas",
                        "content": "I had this problem in an Amazon assessment recently. I think I ended up getting half of tests passing with a recursive solution. Didn\\'t have time to analyze runtime. I ended up advancing to onsite interview! Wish me luck."
                    },
                    {
                        "username": "khe1154",
                        "content": "[@sachin269](/sachin269) i do not think recursion is necessary. you can use nested for loop to generate substring. the calculate frequency and then calculate the variance.\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar largestVariance = function (s) {\\n  const n = s.length;\\n  let maxVariance = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const substring = s.substring(i, j + 1);\\n      const freq = {};\\n\\n      for (let k = 0; k < substring.length; k++) {\\n        const c = substring[k];\\n        if (c in freq) {\\n          freq[c]++;\\n        } else {\\n          freq[c] = 1;\\n        }\\n      }\\n\\n      const values = Object.values(freq);\\n      const variance = Math.max(...values) - Math.min(...values);\\n      maxVariance = Math.max(maxVariance, variance);\\n    }\\n  }\\n\\n  return maxVariance;\\n\\n};\\n```"
                    },
                    {
                        "username": "pradeepmahato007",
                        "content": "All the best!!"
                    },
                    {
                        "username": "sachin269",
                        "content": "[@tjstinso](/tjstinso) can you help me knowing the recursive approach?"
                    },
                    {
                        "username": "wareag1e",
                        "content": "[@Maksadbek](/Maksadbek) Not necessarily. Maybe he has another account to practice problems. LOL"
                    },
                    {
                        "username": "tjstinso",
                        "content": "my initial implementation was a recursive one that passed something like 2/3rds. The actual optimization is pretty slick when you realize the trick, but I would not like to need the optimal solution in an interview. The first hint available is enough of a clue to implement this as the well-known algorithm with modifications, but there are more edge cases than the original problem. This could be a bit of a haul in an interview if the interviewer was just trying to break ankles."
                    },
                    {
                        "username": "Maksadbek",
                        "content": "[@JRajasri](/JRajasri) Looks like he passed the interview as he don\\'t open Leetcode."
                    },
                    {
                        "username": "JRajasri",
                        "content": "Hello. How did your onsite go ?"
                    },
                    {
                        "username": "madness97",
                        "content": "DIdnt understand the example the questions provided too."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@0x6B0](/0x6B0) Than you take the most frequent one and the least frequent one and subtract them from each other. \\n\\nSo say you have string \"abbccccba\", you have 4 c\\'s and 2 a\\'s so that string will have a variance of 2. (The smaller substring \\'bcccc\\' will have 4 c\\'s and 1 be so that substring will have a variance of 3, which will ultimately by your answer). \\n\\nFor coming up with the solution I think the most straight forward way is to compare all the letters pairwise, so I made a matrix of 26 by 26 and to compare each letter against all other letters, filling each of those cells with an array of +1 and -1, as suggested in the hints. And than go through all the arrays in the matrix to find the largest possible sum.  "
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@Mister_CK](/Mister_CK) But what if there are more than 2 letters in that substring? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference.\\n\\nThat\\'s how I would phrase it."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Leetcode\\'s obsession with hard questions on weekends :)"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "It makes sense since ppl usually have more spare time on weekend"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I don\\'t understand what the question is asking me to do."
                    },
                    {
                        "username": "mrb15",
                        "content": "sliding window hangover\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@whoisslimshady](/whoisslimshady) You can, it just gives TLE :P "
                    },
                    {
                        "username": "whoisslimshady",
                        "content": "for real even though i haven\\'t practice sliding window from long time still i though this can be done using sliding window"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Confused what the question is asking. Example explains absolutely nothing as well"
                    },
                    {
                        "username": "tifv",
                        "content": "[@Rishu_sh](/Rishu_sh) Yeah, this part was somewhat confusing. I guess it is accounting for cases like `aaaaa`, where there are no two different characters (the variance in this case is zero). You can ignore this sentence for all other cases."
                    },
                    {
                        "username": "Rishu_sh",
                        "content": "[@jswang00037](/jswang00037)  what is meant by this line : \"Note the two characters may or may not be the same\"?"
                    },
                    {
                        "username": "jswang00037",
                        "content": "In short, find the maximum variance of substring of s. \\nwhere the variance is difference of count between most/least frequent character in substring. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to use the hint, maybe something is more clear?\ns = \"aababbb\"->[1,1,-1,1,-1,-1,-1] This is  a one-to-one correspondence.\nFind the subarrays   containing  -1 & 1 with the largest sum , say A, and with the smallest sum, say B.\nThen A=[1,1,-1, 1] with sum(A)=2 , B=[-1,1,-1,-1,-1] with sum(B)=-3\nThen take max(abs(sum(A)), abs(sum(B)))=3\nThe subarray corresponds to \"babbb\".\nThere are at most 26 different alphabets in a string. Do it pairwise!"
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "[@seeker_747](/seeker_747) \n\nPay attention to description:\nThe variance of a string is defined as the LARGEST difference between the number of occurrences of ANY 2 characters present in the string. \n\nSo you need to consider only two different chars at one moment ignoring any others.\n\nIn example \"abbbcecfffaaccaaddea\" actually the largest diff is the one between \"e\" and \"a\" in \"abbbcecfffaaccaa\" (5 \"a\" and 1 \"e\", 5 - 1 = 4)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@anwendeng](/anwendeng) We can do better.\\nWe can do $26 N$ rather than $26^2 N$:\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@seeker_747](/seeker_747)  There are 26 alphabets.  Do it pairwise, in the ways of 26*25/2 combinations"
                    },
                    {
                        "username": "seeker_747",
                        "content": "what if we had something like \\'abbbcecfffaaccaaddea\\' (too many duplicate characters ) ,then how would we write the one to one correspondence array "
                    },
                    {
                        "username": "roman-mc",
                        "content": "Having more test cases provided would definitely help to understand task more :) "
                    },
                    {
                        "username": "dev-null0",
                        "content": "Didn't read the problem yet... but holy crap, stop with the back-to-back hard's please..."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those getting confused in what the question demands \nIts basically saying to find the maximum variance amongst substring of s. Where the variance is difference of count between most/least frequent character in substring. \nWhen they say \" two characters may or may not be the same.\" : it is just for saying if there is only one unique character : answer is zero.\n\nNow do the question, have a great weekend!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "thank you so much\\n"
                    }
                ]
            },
            {
                "id": 1962095,
                "content": [
                    {
                        "username": "seeker_747",
                        "content": "Not again , my streak is on the line..."
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "julkar9",
                        "content": "Hint: kadane\\'s algorithm but with at least one negative value.\\nAlso try these test cases\\n\"babbbaaaaabbbb\"\\n\"abbb\" \\n\"abbabaaba\""
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "https://www.icode9.com/content-4-1373196.html\\n\\nAlso the exact question was posted in march in leetcode discuss interview question section. Somehow it got removed from there.\\n\\nOverall a nice problem"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "The hard questions really want you to think out of the box.\nSuch a great question :)"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "I might be wrong bit I think it\\'s sliding window problem after considering all pairs. But we need to have atleast a single 1 with opposite sign to be considered as valid answer, right?\\nlike [1,1,1] the max sum would be 3 but ans is 0. right?\\nfor [1,1,1,-1] the answer is 2 and not 3, it\\'s not just maximum subarray sum. I am hella confused.\\n"
                    },
                    {
                        "username": "sachin269",
                        "content": "in all same char case the pair combo is also like (a,a) from the possible pair combo so ensuring the ans 0 is by default considering through the case but when a diff char is being introduced different combo needs to be taken care of like if \"aab\" (a,a),(a,b) all are being taken care of when in the pair different char are available freq(a),freq(b)both should be non zero as fre(b) being zero  makes no sense of calculating variance and freq(a) if zero varaince will be negative"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "yeah that is indeed confusing. but it is mentioned in the question that, occurence of any two characters present in a substring. as an example if you take the string \"aaaa\", here you must have to find the difference between two characters(it also says that they might be the same character). So the answer being 0 instead of being 4 backs up my explanation which is => ans = maximum absolute difference of (occurence of s[i] - occurence of s[j]), where i and j can be any valid indexes in string s. since all characters are \\'a\\', we will get the answer = 4 - 4 = 0. Hope I explained properly : )"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "I suppose the hard part is understanding the question"
                    },
                    {
                        "username": "alyoshark",
                        "content": "I\\'m so comforted to see that I\\'m not the only one who doesn\\'t understand the question"
                    },
                    {
                        "username": "vaibhavkumargautam",
                        "content": "Time complexity - (26 * 26 * N)\\nStill limit limit exceeded error.\\nCan\\'t understand why?\\n\\n\\nCan anyone please help me?\\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        maxi=0\\n        dicta=[0]*26\\n        for i in range(0,len(s)):\\n            dicta[ord(s[i])-97]+=1\\n        for ch1 in range(0,26):           \\n            for ch2 in range(0,26):                     \\n                if ch1==ch2 or  dicta[ch2]==0 or  dicta[ch1]==0:\\n                    continue\\n                else:\\n                    word1=0\\n                    word2=0    \\n                    remain1=dicta[ch1]         \\n                    for i in range(0,len(s)):                               \\n                        if ch1==(ord(s[i])-97):\\n                            word1+=1\\n                            remain1-=1\\n\\n                        if ch2==(ord(s[i])-97):\\n                            word2+=1\\n                        \\n                        if word2<word1 and remain1>=1:\\n                            word1=0\\n                            word2=0\\n                           \\n                        if word2>0 and word1>0:\\n                            maxi=max(maxi,word2-word1)     \\n                                          \\n        return maxi\\n        \\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current solution involves two nested loops over 26 possible characters plus a loop over the length of the string inside them, yielding a time complexity of `O(26*26*N)`. Even though the character loops are not too large, this can still cause a time limit exceeded error for long strings because of the third loop.\\n\\nThe problem might be solved more efficiently by exploiting the hint: creating a prefix sum array and applying two pointers. Here is an optimized solution with time complexity `O(26*N)`:\\n\\n```python\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for ch1 in range(26):\\n            for ch2 in range(26):\\n                if ch1 == ch2:\\n                    continue\\n                prefix = [0] * (n + 1)\\n                for i in range(n):\\n                    prefix[i + 1] = prefix[i] + (1 if ord(s[i]) - 97 == ch1 else -1 if ord(s[i]) - 97 == ch2 else 0)\\n                min_prefix = 0\\n                for i in range(1, n + 1):\\n                    ans = max(ans, prefix[i] - min_prefix)\\n                    min_prefix = min(min_prefix, prefix[i])\\n        return ans\\n```\\n\\nThe core idea here is that we iterate through every possible pair of characters. For each pair, we construct a prefix sum array where the character corresponding to `ch1` is represented by `1`, the character corresponding to `ch2` by `-1`, and every other character by `0`.\\n\\nThen, we iterate over the prefix sum array, tracking the minimum prefix sum we\\'ve seen (`min_prefix`) and updating our answer (`ans`) as the maximum difference between the current prefix sum and the minimum prefix sum. This process effectively finds the subarray with the largest sum for this particular mapping of characters to `1` and `-1`, which corresponds to the string segment with the largest variance between the two characters.\\n\\nFinally, we return the largest variance we\\'ve found over all pairs of characters."
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "Try to ignore letters that are not present in the string. Also consider using letters directly without calculating chars."
                    },
                    {
                        "username": "nonme",
                        "content": ":( Sorry, it is possible that the version of your browser is too low to load the code-editor, please try to update browser to revert to using code-editor.\\n\\nOh no goodbye my streak"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Time Limit Exceeded\\n138 / 138 testcases passed\\nLast Executed Input\\nUse Testcase\\ns =\\n\\uD83D\\uDE11"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it\\'s a bad output, but LC says you should treat it as any other time out, it is just annoying that you don\\'t get the testCase that actually fails. "
                    }
                ]
            },
            {
                "id": 1962802,
                "content": [
                    {
                        "username": "seeker_747",
                        "content": "Not again , my streak is on the line..."
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "julkar9",
                        "content": "Hint: kadane\\'s algorithm but with at least one negative value.\\nAlso try these test cases\\n\"babbbaaaaabbbb\"\\n\"abbb\" \\n\"abbabaaba\""
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "https://www.icode9.com/content-4-1373196.html\\n\\nAlso the exact question was posted in march in leetcode discuss interview question section. Somehow it got removed from there.\\n\\nOverall a nice problem"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "The hard questions really want you to think out of the box.\nSuch a great question :)"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "I might be wrong bit I think it\\'s sliding window problem after considering all pairs. But we need to have atleast a single 1 with opposite sign to be considered as valid answer, right?\\nlike [1,1,1] the max sum would be 3 but ans is 0. right?\\nfor [1,1,1,-1] the answer is 2 and not 3, it\\'s not just maximum subarray sum. I am hella confused.\\n"
                    },
                    {
                        "username": "sachin269",
                        "content": "in all same char case the pair combo is also like (a,a) from the possible pair combo so ensuring the ans 0 is by default considering through the case but when a diff char is being introduced different combo needs to be taken care of like if \"aab\" (a,a),(a,b) all are being taken care of when in the pair different char are available freq(a),freq(b)both should be non zero as fre(b) being zero  makes no sense of calculating variance and freq(a) if zero varaince will be negative"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "yeah that is indeed confusing. but it is mentioned in the question that, occurence of any two characters present in a substring. as an example if you take the string \"aaaa\", here you must have to find the difference between two characters(it also says that they might be the same character). So the answer being 0 instead of being 4 backs up my explanation which is => ans = maximum absolute difference of (occurence of s[i] - occurence of s[j]), where i and j can be any valid indexes in string s. since all characters are \\'a\\', we will get the answer = 4 - 4 = 0. Hope I explained properly : )"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "I suppose the hard part is understanding the question"
                    },
                    {
                        "username": "alyoshark",
                        "content": "I\\'m so comforted to see that I\\'m not the only one who doesn\\'t understand the question"
                    },
                    {
                        "username": "vaibhavkumargautam",
                        "content": "Time complexity - (26 * 26 * N)\\nStill limit limit exceeded error.\\nCan\\'t understand why?\\n\\n\\nCan anyone please help me?\\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        maxi=0\\n        dicta=[0]*26\\n        for i in range(0,len(s)):\\n            dicta[ord(s[i])-97]+=1\\n        for ch1 in range(0,26):           \\n            for ch2 in range(0,26):                     \\n                if ch1==ch2 or  dicta[ch2]==0 or  dicta[ch1]==0:\\n                    continue\\n                else:\\n                    word1=0\\n                    word2=0    \\n                    remain1=dicta[ch1]         \\n                    for i in range(0,len(s)):                               \\n                        if ch1==(ord(s[i])-97):\\n                            word1+=1\\n                            remain1-=1\\n\\n                        if ch2==(ord(s[i])-97):\\n                            word2+=1\\n                        \\n                        if word2<word1 and remain1>=1:\\n                            word1=0\\n                            word2=0\\n                           \\n                        if word2>0 and word1>0:\\n                            maxi=max(maxi,word2-word1)     \\n                                          \\n        return maxi\\n        \\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current solution involves two nested loops over 26 possible characters plus a loop over the length of the string inside them, yielding a time complexity of `O(26*26*N)`. Even though the character loops are not too large, this can still cause a time limit exceeded error for long strings because of the third loop.\\n\\nThe problem might be solved more efficiently by exploiting the hint: creating a prefix sum array and applying two pointers. Here is an optimized solution with time complexity `O(26*N)`:\\n\\n```python\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for ch1 in range(26):\\n            for ch2 in range(26):\\n                if ch1 == ch2:\\n                    continue\\n                prefix = [0] * (n + 1)\\n                for i in range(n):\\n                    prefix[i + 1] = prefix[i] + (1 if ord(s[i]) - 97 == ch1 else -1 if ord(s[i]) - 97 == ch2 else 0)\\n                min_prefix = 0\\n                for i in range(1, n + 1):\\n                    ans = max(ans, prefix[i] - min_prefix)\\n                    min_prefix = min(min_prefix, prefix[i])\\n        return ans\\n```\\n\\nThe core idea here is that we iterate through every possible pair of characters. For each pair, we construct a prefix sum array where the character corresponding to `ch1` is represented by `1`, the character corresponding to `ch2` by `-1`, and every other character by `0`.\\n\\nThen, we iterate over the prefix sum array, tracking the minimum prefix sum we\\'ve seen (`min_prefix`) and updating our answer (`ans`) as the maximum difference between the current prefix sum and the minimum prefix sum. This process effectively finds the subarray with the largest sum for this particular mapping of characters to `1` and `-1`, which corresponds to the string segment with the largest variance between the two characters.\\n\\nFinally, we return the largest variance we\\'ve found over all pairs of characters."
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "Try to ignore letters that are not present in the string. Also consider using letters directly without calculating chars."
                    },
                    {
                        "username": "nonme",
                        "content": ":( Sorry, it is possible that the version of your browser is too low to load the code-editor, please try to update browser to revert to using code-editor.\\n\\nOh no goodbye my streak"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Time Limit Exceeded\\n138 / 138 testcases passed\\nLast Executed Input\\nUse Testcase\\ns =\\n\\uD83D\\uDE11"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it\\'s a bad output, but LC says you should treat it as any other time out, it is just annoying that you don\\'t get the testCase that actually fails. "
                    }
                ]
            },
            {
                "id": 1566719,
                "content": [
                    {
                        "username": "seeker_747",
                        "content": "Not again , my streak is on the line..."
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "julkar9",
                        "content": "Hint: kadane\\'s algorithm but with at least one negative value.\\nAlso try these test cases\\n\"babbbaaaaabbbb\"\\n\"abbb\" \\n\"abbabaaba\""
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "https://www.icode9.com/content-4-1373196.html\\n\\nAlso the exact question was posted in march in leetcode discuss interview question section. Somehow it got removed from there.\\n\\nOverall a nice problem"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "The hard questions really want you to think out of the box.\nSuch a great question :)"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "I might be wrong bit I think it\\'s sliding window problem after considering all pairs. But we need to have atleast a single 1 with opposite sign to be considered as valid answer, right?\\nlike [1,1,1] the max sum would be 3 but ans is 0. right?\\nfor [1,1,1,-1] the answer is 2 and not 3, it\\'s not just maximum subarray sum. I am hella confused.\\n"
                    },
                    {
                        "username": "sachin269",
                        "content": "in all same char case the pair combo is also like (a,a) from the possible pair combo so ensuring the ans 0 is by default considering through the case but when a diff char is being introduced different combo needs to be taken care of like if \"aab\" (a,a),(a,b) all are being taken care of when in the pair different char are available freq(a),freq(b)both should be non zero as fre(b) being zero  makes no sense of calculating variance and freq(a) if zero varaince will be negative"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "yeah that is indeed confusing. but it is mentioned in the question that, occurence of any two characters present in a substring. as an example if you take the string \"aaaa\", here you must have to find the difference between two characters(it also says that they might be the same character). So the answer being 0 instead of being 4 backs up my explanation which is => ans = maximum absolute difference of (occurence of s[i] - occurence of s[j]), where i and j can be any valid indexes in string s. since all characters are \\'a\\', we will get the answer = 4 - 4 = 0. Hope I explained properly : )"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "I suppose the hard part is understanding the question"
                    },
                    {
                        "username": "alyoshark",
                        "content": "I\\'m so comforted to see that I\\'m not the only one who doesn\\'t understand the question"
                    },
                    {
                        "username": "vaibhavkumargautam",
                        "content": "Time complexity - (26 * 26 * N)\\nStill limit limit exceeded error.\\nCan\\'t understand why?\\n\\n\\nCan anyone please help me?\\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        maxi=0\\n        dicta=[0]*26\\n        for i in range(0,len(s)):\\n            dicta[ord(s[i])-97]+=1\\n        for ch1 in range(0,26):           \\n            for ch2 in range(0,26):                     \\n                if ch1==ch2 or  dicta[ch2]==0 or  dicta[ch1]==0:\\n                    continue\\n                else:\\n                    word1=0\\n                    word2=0    \\n                    remain1=dicta[ch1]         \\n                    for i in range(0,len(s)):                               \\n                        if ch1==(ord(s[i])-97):\\n                            word1+=1\\n                            remain1-=1\\n\\n                        if ch2==(ord(s[i])-97):\\n                            word2+=1\\n                        \\n                        if word2<word1 and remain1>=1:\\n                            word1=0\\n                            word2=0\\n                           \\n                        if word2>0 and word1>0:\\n                            maxi=max(maxi,word2-word1)     \\n                                          \\n        return maxi\\n        \\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current solution involves two nested loops over 26 possible characters plus a loop over the length of the string inside them, yielding a time complexity of `O(26*26*N)`. Even though the character loops are not too large, this can still cause a time limit exceeded error for long strings because of the third loop.\\n\\nThe problem might be solved more efficiently by exploiting the hint: creating a prefix sum array and applying two pointers. Here is an optimized solution with time complexity `O(26*N)`:\\n\\n```python\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for ch1 in range(26):\\n            for ch2 in range(26):\\n                if ch1 == ch2:\\n                    continue\\n                prefix = [0] * (n + 1)\\n                for i in range(n):\\n                    prefix[i + 1] = prefix[i] + (1 if ord(s[i]) - 97 == ch1 else -1 if ord(s[i]) - 97 == ch2 else 0)\\n                min_prefix = 0\\n                for i in range(1, n + 1):\\n                    ans = max(ans, prefix[i] - min_prefix)\\n                    min_prefix = min(min_prefix, prefix[i])\\n        return ans\\n```\\n\\nThe core idea here is that we iterate through every possible pair of characters. For each pair, we construct a prefix sum array where the character corresponding to `ch1` is represented by `1`, the character corresponding to `ch2` by `-1`, and every other character by `0`.\\n\\nThen, we iterate over the prefix sum array, tracking the minimum prefix sum we\\'ve seen (`min_prefix`) and updating our answer (`ans`) as the maximum difference between the current prefix sum and the minimum prefix sum. This process effectively finds the subarray with the largest sum for this particular mapping of characters to `1` and `-1`, which corresponds to the string segment with the largest variance between the two characters.\\n\\nFinally, we return the largest variance we\\'ve found over all pairs of characters."
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "Try to ignore letters that are not present in the string. Also consider using letters directly without calculating chars."
                    },
                    {
                        "username": "nonme",
                        "content": ":( Sorry, it is possible that the version of your browser is too low to load the code-editor, please try to update browser to revert to using code-editor.\\n\\nOh no goodbye my streak"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Time Limit Exceeded\\n138 / 138 testcases passed\\nLast Executed Input\\nUse Testcase\\ns =\\n\\uD83D\\uDE11"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it\\'s a bad output, but LC says you should treat it as any other time out, it is just annoying that you don\\'t get the testCase that actually fails. "
                    }
                ]
            },
            {
                "id": 1963275,
                "content": [
                    {
                        "username": "seeker_747",
                        "content": "Not again , my streak is on the line..."
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "julkar9",
                        "content": "Hint: kadane\\'s algorithm but with at least one negative value.\\nAlso try these test cases\\n\"babbbaaaaabbbb\"\\n\"abbb\" \\n\"abbabaaba\""
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "https://www.icode9.com/content-4-1373196.html\\n\\nAlso the exact question was posted in march in leetcode discuss interview question section. Somehow it got removed from there.\\n\\nOverall a nice problem"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "The hard questions really want you to think out of the box.\nSuch a great question :)"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "I might be wrong bit I think it\\'s sliding window problem after considering all pairs. But we need to have atleast a single 1 with opposite sign to be considered as valid answer, right?\\nlike [1,1,1] the max sum would be 3 but ans is 0. right?\\nfor [1,1,1,-1] the answer is 2 and not 3, it\\'s not just maximum subarray sum. I am hella confused.\\n"
                    },
                    {
                        "username": "sachin269",
                        "content": "in all same char case the pair combo is also like (a,a) from the possible pair combo so ensuring the ans 0 is by default considering through the case but when a diff char is being introduced different combo needs to be taken care of like if \"aab\" (a,a),(a,b) all are being taken care of when in the pair different char are available freq(a),freq(b)both should be non zero as fre(b) being zero  makes no sense of calculating variance and freq(a) if zero varaince will be negative"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "yeah that is indeed confusing. but it is mentioned in the question that, occurence of any two characters present in a substring. as an example if you take the string \"aaaa\", here you must have to find the difference between two characters(it also says that they might be the same character). So the answer being 0 instead of being 4 backs up my explanation which is => ans = maximum absolute difference of (occurence of s[i] - occurence of s[j]), where i and j can be any valid indexes in string s. since all characters are \\'a\\', we will get the answer = 4 - 4 = 0. Hope I explained properly : )"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "I suppose the hard part is understanding the question"
                    },
                    {
                        "username": "alyoshark",
                        "content": "I\\'m so comforted to see that I\\'m not the only one who doesn\\'t understand the question"
                    },
                    {
                        "username": "vaibhavkumargautam",
                        "content": "Time complexity - (26 * 26 * N)\\nStill limit limit exceeded error.\\nCan\\'t understand why?\\n\\n\\nCan anyone please help me?\\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        maxi=0\\n        dicta=[0]*26\\n        for i in range(0,len(s)):\\n            dicta[ord(s[i])-97]+=1\\n        for ch1 in range(0,26):           \\n            for ch2 in range(0,26):                     \\n                if ch1==ch2 or  dicta[ch2]==0 or  dicta[ch1]==0:\\n                    continue\\n                else:\\n                    word1=0\\n                    word2=0    \\n                    remain1=dicta[ch1]         \\n                    for i in range(0,len(s)):                               \\n                        if ch1==(ord(s[i])-97):\\n                            word1+=1\\n                            remain1-=1\\n\\n                        if ch2==(ord(s[i])-97):\\n                            word2+=1\\n                        \\n                        if word2<word1 and remain1>=1:\\n                            word1=0\\n                            word2=0\\n                           \\n                        if word2>0 and word1>0:\\n                            maxi=max(maxi,word2-word1)     \\n                                          \\n        return maxi\\n        \\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current solution involves two nested loops over 26 possible characters plus a loop over the length of the string inside them, yielding a time complexity of `O(26*26*N)`. Even though the character loops are not too large, this can still cause a time limit exceeded error for long strings because of the third loop.\\n\\nThe problem might be solved more efficiently by exploiting the hint: creating a prefix sum array and applying two pointers. Here is an optimized solution with time complexity `O(26*N)`:\\n\\n```python\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for ch1 in range(26):\\n            for ch2 in range(26):\\n                if ch1 == ch2:\\n                    continue\\n                prefix = [0] * (n + 1)\\n                for i in range(n):\\n                    prefix[i + 1] = prefix[i] + (1 if ord(s[i]) - 97 == ch1 else -1 if ord(s[i]) - 97 == ch2 else 0)\\n                min_prefix = 0\\n                for i in range(1, n + 1):\\n                    ans = max(ans, prefix[i] - min_prefix)\\n                    min_prefix = min(min_prefix, prefix[i])\\n        return ans\\n```\\n\\nThe core idea here is that we iterate through every possible pair of characters. For each pair, we construct a prefix sum array where the character corresponding to `ch1` is represented by `1`, the character corresponding to `ch2` by `-1`, and every other character by `0`.\\n\\nThen, we iterate over the prefix sum array, tracking the minimum prefix sum we\\'ve seen (`min_prefix`) and updating our answer (`ans`) as the maximum difference between the current prefix sum and the minimum prefix sum. This process effectively finds the subarray with the largest sum for this particular mapping of characters to `1` and `-1`, which corresponds to the string segment with the largest variance between the two characters.\\n\\nFinally, we return the largest variance we\\'ve found over all pairs of characters."
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "Try to ignore letters that are not present in the string. Also consider using letters directly without calculating chars."
                    },
                    {
                        "username": "nonme",
                        "content": ":( Sorry, it is possible that the version of your browser is too low to load the code-editor, please try to update browser to revert to using code-editor.\\n\\nOh no goodbye my streak"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Time Limit Exceeded\\n138 / 138 testcases passed\\nLast Executed Input\\nUse Testcase\\ns =\\n\\uD83D\\uDE11"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it\\'s a bad output, but LC says you should treat it as any other time out, it is just annoying that you don\\'t get the testCase that actually fails. "
                    }
                ]
            },
            {
                "id": 1962969,
                "content": [
                    {
                        "username": "seeker_747",
                        "content": "Not again , my streak is on the line..."
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "julkar9",
                        "content": "Hint: kadane\\'s algorithm but with at least one negative value.\\nAlso try these test cases\\n\"babbbaaaaabbbb\"\\n\"abbb\" \\n\"abbabaaba\""
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "https://www.icode9.com/content-4-1373196.html\\n\\nAlso the exact question was posted in march in leetcode discuss interview question section. Somehow it got removed from there.\\n\\nOverall a nice problem"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "The hard questions really want you to think out of the box.\nSuch a great question :)"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "I might be wrong bit I think it\\'s sliding window problem after considering all pairs. But we need to have atleast a single 1 with opposite sign to be considered as valid answer, right?\\nlike [1,1,1] the max sum would be 3 but ans is 0. right?\\nfor [1,1,1,-1] the answer is 2 and not 3, it\\'s not just maximum subarray sum. I am hella confused.\\n"
                    },
                    {
                        "username": "sachin269",
                        "content": "in all same char case the pair combo is also like (a,a) from the possible pair combo so ensuring the ans 0 is by default considering through the case but when a diff char is being introduced different combo needs to be taken care of like if \"aab\" (a,a),(a,b) all are being taken care of when in the pair different char are available freq(a),freq(b)both should be non zero as fre(b) being zero  makes no sense of calculating variance and freq(a) if zero varaince will be negative"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "yeah that is indeed confusing. but it is mentioned in the question that, occurence of any two characters present in a substring. as an example if you take the string \"aaaa\", here you must have to find the difference between two characters(it also says that they might be the same character). So the answer being 0 instead of being 4 backs up my explanation which is => ans = maximum absolute difference of (occurence of s[i] - occurence of s[j]), where i and j can be any valid indexes in string s. since all characters are \\'a\\', we will get the answer = 4 - 4 = 0. Hope I explained properly : )"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "I suppose the hard part is understanding the question"
                    },
                    {
                        "username": "alyoshark",
                        "content": "I\\'m so comforted to see that I\\'m not the only one who doesn\\'t understand the question"
                    },
                    {
                        "username": "vaibhavkumargautam",
                        "content": "Time complexity - (26 * 26 * N)\\nStill limit limit exceeded error.\\nCan\\'t understand why?\\n\\n\\nCan anyone please help me?\\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        maxi=0\\n        dicta=[0]*26\\n        for i in range(0,len(s)):\\n            dicta[ord(s[i])-97]+=1\\n        for ch1 in range(0,26):           \\n            for ch2 in range(0,26):                     \\n                if ch1==ch2 or  dicta[ch2]==0 or  dicta[ch1]==0:\\n                    continue\\n                else:\\n                    word1=0\\n                    word2=0    \\n                    remain1=dicta[ch1]         \\n                    for i in range(0,len(s)):                               \\n                        if ch1==(ord(s[i])-97):\\n                            word1+=1\\n                            remain1-=1\\n\\n                        if ch2==(ord(s[i])-97):\\n                            word2+=1\\n                        \\n                        if word2<word1 and remain1>=1:\\n                            word1=0\\n                            word2=0\\n                           \\n                        if word2>0 and word1>0:\\n                            maxi=max(maxi,word2-word1)     \\n                                          \\n        return maxi\\n        \\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current solution involves two nested loops over 26 possible characters plus a loop over the length of the string inside them, yielding a time complexity of `O(26*26*N)`. Even though the character loops are not too large, this can still cause a time limit exceeded error for long strings because of the third loop.\\n\\nThe problem might be solved more efficiently by exploiting the hint: creating a prefix sum array and applying two pointers. Here is an optimized solution with time complexity `O(26*N)`:\\n\\n```python\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for ch1 in range(26):\\n            for ch2 in range(26):\\n                if ch1 == ch2:\\n                    continue\\n                prefix = [0] * (n + 1)\\n                for i in range(n):\\n                    prefix[i + 1] = prefix[i] + (1 if ord(s[i]) - 97 == ch1 else -1 if ord(s[i]) - 97 == ch2 else 0)\\n                min_prefix = 0\\n                for i in range(1, n + 1):\\n                    ans = max(ans, prefix[i] - min_prefix)\\n                    min_prefix = min(min_prefix, prefix[i])\\n        return ans\\n```\\n\\nThe core idea here is that we iterate through every possible pair of characters. For each pair, we construct a prefix sum array where the character corresponding to `ch1` is represented by `1`, the character corresponding to `ch2` by `-1`, and every other character by `0`.\\n\\nThen, we iterate over the prefix sum array, tracking the minimum prefix sum we\\'ve seen (`min_prefix`) and updating our answer (`ans`) as the maximum difference between the current prefix sum and the minimum prefix sum. This process effectively finds the subarray with the largest sum for this particular mapping of characters to `1` and `-1`, which corresponds to the string segment with the largest variance between the two characters.\\n\\nFinally, we return the largest variance we\\'ve found over all pairs of characters."
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "Try to ignore letters that are not present in the string. Also consider using letters directly without calculating chars."
                    },
                    {
                        "username": "nonme",
                        "content": ":( Sorry, it is possible that the version of your browser is too low to load the code-editor, please try to update browser to revert to using code-editor.\\n\\nOh no goodbye my streak"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Time Limit Exceeded\\n138 / 138 testcases passed\\nLast Executed Input\\nUse Testcase\\ns =\\n\\uD83D\\uDE11"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it\\'s a bad output, but LC says you should treat it as any other time out, it is just annoying that you don\\'t get the testCase that actually fails. "
                    }
                ]
            },
            {
                "id": 1962968,
                "content": [
                    {
                        "username": "seeker_747",
                        "content": "Not again , my streak is on the line..."
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "julkar9",
                        "content": "Hint: kadane\\'s algorithm but with at least one negative value.\\nAlso try these test cases\\n\"babbbaaaaabbbb\"\\n\"abbb\" \\n\"abbabaaba\""
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "https://www.icode9.com/content-4-1373196.html\\n\\nAlso the exact question was posted in march in leetcode discuss interview question section. Somehow it got removed from there.\\n\\nOverall a nice problem"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "The hard questions really want you to think out of the box.\nSuch a great question :)"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "I might be wrong bit I think it\\'s sliding window problem after considering all pairs. But we need to have atleast a single 1 with opposite sign to be considered as valid answer, right?\\nlike [1,1,1] the max sum would be 3 but ans is 0. right?\\nfor [1,1,1,-1] the answer is 2 and not 3, it\\'s not just maximum subarray sum. I am hella confused.\\n"
                    },
                    {
                        "username": "sachin269",
                        "content": "in all same char case the pair combo is also like (a,a) from the possible pair combo so ensuring the ans 0 is by default considering through the case but when a diff char is being introduced different combo needs to be taken care of like if \"aab\" (a,a),(a,b) all are being taken care of when in the pair different char are available freq(a),freq(b)both should be non zero as fre(b) being zero  makes no sense of calculating variance and freq(a) if zero varaince will be negative"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "yeah that is indeed confusing. but it is mentioned in the question that, occurence of any two characters present in a substring. as an example if you take the string \"aaaa\", here you must have to find the difference between two characters(it also says that they might be the same character). So the answer being 0 instead of being 4 backs up my explanation which is => ans = maximum absolute difference of (occurence of s[i] - occurence of s[j]), where i and j can be any valid indexes in string s. since all characters are \\'a\\', we will get the answer = 4 - 4 = 0. Hope I explained properly : )"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "I suppose the hard part is understanding the question"
                    },
                    {
                        "username": "alyoshark",
                        "content": "I\\'m so comforted to see that I\\'m not the only one who doesn\\'t understand the question"
                    },
                    {
                        "username": "vaibhavkumargautam",
                        "content": "Time complexity - (26 * 26 * N)\\nStill limit limit exceeded error.\\nCan\\'t understand why?\\n\\n\\nCan anyone please help me?\\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        maxi=0\\n        dicta=[0]*26\\n        for i in range(0,len(s)):\\n            dicta[ord(s[i])-97]+=1\\n        for ch1 in range(0,26):           \\n            for ch2 in range(0,26):                     \\n                if ch1==ch2 or  dicta[ch2]==0 or  dicta[ch1]==0:\\n                    continue\\n                else:\\n                    word1=0\\n                    word2=0    \\n                    remain1=dicta[ch1]         \\n                    for i in range(0,len(s)):                               \\n                        if ch1==(ord(s[i])-97):\\n                            word1+=1\\n                            remain1-=1\\n\\n                        if ch2==(ord(s[i])-97):\\n                            word2+=1\\n                        \\n                        if word2<word1 and remain1>=1:\\n                            word1=0\\n                            word2=0\\n                           \\n                        if word2>0 and word1>0:\\n                            maxi=max(maxi,word2-word1)     \\n                                          \\n        return maxi\\n        \\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current solution involves two nested loops over 26 possible characters plus a loop over the length of the string inside them, yielding a time complexity of `O(26*26*N)`. Even though the character loops are not too large, this can still cause a time limit exceeded error for long strings because of the third loop.\\n\\nThe problem might be solved more efficiently by exploiting the hint: creating a prefix sum array and applying two pointers. Here is an optimized solution with time complexity `O(26*N)`:\\n\\n```python\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for ch1 in range(26):\\n            for ch2 in range(26):\\n                if ch1 == ch2:\\n                    continue\\n                prefix = [0] * (n + 1)\\n                for i in range(n):\\n                    prefix[i + 1] = prefix[i] + (1 if ord(s[i]) - 97 == ch1 else -1 if ord(s[i]) - 97 == ch2 else 0)\\n                min_prefix = 0\\n                for i in range(1, n + 1):\\n                    ans = max(ans, prefix[i] - min_prefix)\\n                    min_prefix = min(min_prefix, prefix[i])\\n        return ans\\n```\\n\\nThe core idea here is that we iterate through every possible pair of characters. For each pair, we construct a prefix sum array where the character corresponding to `ch1` is represented by `1`, the character corresponding to `ch2` by `-1`, and every other character by `0`.\\n\\nThen, we iterate over the prefix sum array, tracking the minimum prefix sum we\\'ve seen (`min_prefix`) and updating our answer (`ans`) as the maximum difference between the current prefix sum and the minimum prefix sum. This process effectively finds the subarray with the largest sum for this particular mapping of characters to `1` and `-1`, which corresponds to the string segment with the largest variance between the two characters.\\n\\nFinally, we return the largest variance we\\'ve found over all pairs of characters."
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "Try to ignore letters that are not present in the string. Also consider using letters directly without calculating chars."
                    },
                    {
                        "username": "nonme",
                        "content": ":( Sorry, it is possible that the version of your browser is too low to load the code-editor, please try to update browser to revert to using code-editor.\\n\\nOh no goodbye my streak"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Time Limit Exceeded\\n138 / 138 testcases passed\\nLast Executed Input\\nUse Testcase\\ns =\\n\\uD83D\\uDE11"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it\\'s a bad output, but LC says you should treat it as any other time out, it is just annoying that you don\\'t get the testCase that actually fails. "
                    }
                ]
            },
            {
                "id": 1962781,
                "content": [
                    {
                        "username": "seeker_747",
                        "content": "Not again , my streak is on the line..."
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "julkar9",
                        "content": "Hint: kadane\\'s algorithm but with at least one negative value.\\nAlso try these test cases\\n\"babbbaaaaabbbb\"\\n\"abbb\" \\n\"abbabaaba\""
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "https://www.icode9.com/content-4-1373196.html\\n\\nAlso the exact question was posted in march in leetcode discuss interview question section. Somehow it got removed from there.\\n\\nOverall a nice problem"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "The hard questions really want you to think out of the box.\nSuch a great question :)"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "I might be wrong bit I think it\\'s sliding window problem after considering all pairs. But we need to have atleast a single 1 with opposite sign to be considered as valid answer, right?\\nlike [1,1,1] the max sum would be 3 but ans is 0. right?\\nfor [1,1,1,-1] the answer is 2 and not 3, it\\'s not just maximum subarray sum. I am hella confused.\\n"
                    },
                    {
                        "username": "sachin269",
                        "content": "in all same char case the pair combo is also like (a,a) from the possible pair combo so ensuring the ans 0 is by default considering through the case but when a diff char is being introduced different combo needs to be taken care of like if \"aab\" (a,a),(a,b) all are being taken care of when in the pair different char are available freq(a),freq(b)both should be non zero as fre(b) being zero  makes no sense of calculating variance and freq(a) if zero varaince will be negative"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "yeah that is indeed confusing. but it is mentioned in the question that, occurence of any two characters present in a substring. as an example if you take the string \"aaaa\", here you must have to find the difference between two characters(it also says that they might be the same character). So the answer being 0 instead of being 4 backs up my explanation which is => ans = maximum absolute difference of (occurence of s[i] - occurence of s[j]), where i and j can be any valid indexes in string s. since all characters are \\'a\\', we will get the answer = 4 - 4 = 0. Hope I explained properly : )"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "I suppose the hard part is understanding the question"
                    },
                    {
                        "username": "alyoshark",
                        "content": "I\\'m so comforted to see that I\\'m not the only one who doesn\\'t understand the question"
                    },
                    {
                        "username": "vaibhavkumargautam",
                        "content": "Time complexity - (26 * 26 * N)\\nStill limit limit exceeded error.\\nCan\\'t understand why?\\n\\n\\nCan anyone please help me?\\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        maxi=0\\n        dicta=[0]*26\\n        for i in range(0,len(s)):\\n            dicta[ord(s[i])-97]+=1\\n        for ch1 in range(0,26):           \\n            for ch2 in range(0,26):                     \\n                if ch1==ch2 or  dicta[ch2]==0 or  dicta[ch1]==0:\\n                    continue\\n                else:\\n                    word1=0\\n                    word2=0    \\n                    remain1=dicta[ch1]         \\n                    for i in range(0,len(s)):                               \\n                        if ch1==(ord(s[i])-97):\\n                            word1+=1\\n                            remain1-=1\\n\\n                        if ch2==(ord(s[i])-97):\\n                            word2+=1\\n                        \\n                        if word2<word1 and remain1>=1:\\n                            word1=0\\n                            word2=0\\n                           \\n                        if word2>0 and word1>0:\\n                            maxi=max(maxi,word2-word1)     \\n                                          \\n        return maxi\\n        \\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current solution involves two nested loops over 26 possible characters plus a loop over the length of the string inside them, yielding a time complexity of `O(26*26*N)`. Even though the character loops are not too large, this can still cause a time limit exceeded error for long strings because of the third loop.\\n\\nThe problem might be solved more efficiently by exploiting the hint: creating a prefix sum array and applying two pointers. Here is an optimized solution with time complexity `O(26*N)`:\\n\\n```python\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for ch1 in range(26):\\n            for ch2 in range(26):\\n                if ch1 == ch2:\\n                    continue\\n                prefix = [0] * (n + 1)\\n                for i in range(n):\\n                    prefix[i + 1] = prefix[i] + (1 if ord(s[i]) - 97 == ch1 else -1 if ord(s[i]) - 97 == ch2 else 0)\\n                min_prefix = 0\\n                for i in range(1, n + 1):\\n                    ans = max(ans, prefix[i] - min_prefix)\\n                    min_prefix = min(min_prefix, prefix[i])\\n        return ans\\n```\\n\\nThe core idea here is that we iterate through every possible pair of characters. For each pair, we construct a prefix sum array where the character corresponding to `ch1` is represented by `1`, the character corresponding to `ch2` by `-1`, and every other character by `0`.\\n\\nThen, we iterate over the prefix sum array, tracking the minimum prefix sum we\\'ve seen (`min_prefix`) and updating our answer (`ans`) as the maximum difference between the current prefix sum and the minimum prefix sum. This process effectively finds the subarray with the largest sum for this particular mapping of characters to `1` and `-1`, which corresponds to the string segment with the largest variance between the two characters.\\n\\nFinally, we return the largest variance we\\'ve found over all pairs of characters."
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "Try to ignore letters that are not present in the string. Also consider using letters directly without calculating chars."
                    },
                    {
                        "username": "nonme",
                        "content": ":( Sorry, it is possible that the version of your browser is too low to load the code-editor, please try to update browser to revert to using code-editor.\\n\\nOh no goodbye my streak"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Time Limit Exceeded\\n138 / 138 testcases passed\\nLast Executed Input\\nUse Testcase\\ns =\\n\\uD83D\\uDE11"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it\\'s a bad output, but LC says you should treat it as any other time out, it is just annoying that you don\\'t get the testCase that actually fails. "
                    }
                ]
            },
            {
                "id": 1723636,
                "content": [
                    {
                        "username": "seeker_747",
                        "content": "Not again , my streak is on the line..."
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "julkar9",
                        "content": "Hint: kadane\\'s algorithm but with at least one negative value.\\nAlso try these test cases\\n\"babbbaaaaabbbb\"\\n\"abbb\" \\n\"abbabaaba\""
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "https://www.icode9.com/content-4-1373196.html\\n\\nAlso the exact question was posted in march in leetcode discuss interview question section. Somehow it got removed from there.\\n\\nOverall a nice problem"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "The hard questions really want you to think out of the box.\nSuch a great question :)"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "I might be wrong bit I think it\\'s sliding window problem after considering all pairs. But we need to have atleast a single 1 with opposite sign to be considered as valid answer, right?\\nlike [1,1,1] the max sum would be 3 but ans is 0. right?\\nfor [1,1,1,-1] the answer is 2 and not 3, it\\'s not just maximum subarray sum. I am hella confused.\\n"
                    },
                    {
                        "username": "sachin269",
                        "content": "in all same char case the pair combo is also like (a,a) from the possible pair combo so ensuring the ans 0 is by default considering through the case but when a diff char is being introduced different combo needs to be taken care of like if \"aab\" (a,a),(a,b) all are being taken care of when in the pair different char are available freq(a),freq(b)both should be non zero as fre(b) being zero  makes no sense of calculating variance and freq(a) if zero varaince will be negative"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "yeah that is indeed confusing. but it is mentioned in the question that, occurence of any two characters present in a substring. as an example if you take the string \"aaaa\", here you must have to find the difference between two characters(it also says that they might be the same character). So the answer being 0 instead of being 4 backs up my explanation which is => ans = maximum absolute difference of (occurence of s[i] - occurence of s[j]), where i and j can be any valid indexes in string s. since all characters are \\'a\\', we will get the answer = 4 - 4 = 0. Hope I explained properly : )"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "I suppose the hard part is understanding the question"
                    },
                    {
                        "username": "alyoshark",
                        "content": "I\\'m so comforted to see that I\\'m not the only one who doesn\\'t understand the question"
                    },
                    {
                        "username": "vaibhavkumargautam",
                        "content": "Time complexity - (26 * 26 * N)\\nStill limit limit exceeded error.\\nCan\\'t understand why?\\n\\n\\nCan anyone please help me?\\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        maxi=0\\n        dicta=[0]*26\\n        for i in range(0,len(s)):\\n            dicta[ord(s[i])-97]+=1\\n        for ch1 in range(0,26):           \\n            for ch2 in range(0,26):                     \\n                if ch1==ch2 or  dicta[ch2]==0 or  dicta[ch1]==0:\\n                    continue\\n                else:\\n                    word1=0\\n                    word2=0    \\n                    remain1=dicta[ch1]         \\n                    for i in range(0,len(s)):                               \\n                        if ch1==(ord(s[i])-97):\\n                            word1+=1\\n                            remain1-=1\\n\\n                        if ch2==(ord(s[i])-97):\\n                            word2+=1\\n                        \\n                        if word2<word1 and remain1>=1:\\n                            word1=0\\n                            word2=0\\n                           \\n                        if word2>0 and word1>0:\\n                            maxi=max(maxi,word2-word1)     \\n                                          \\n        return maxi\\n        \\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current solution involves two nested loops over 26 possible characters plus a loop over the length of the string inside them, yielding a time complexity of `O(26*26*N)`. Even though the character loops are not too large, this can still cause a time limit exceeded error for long strings because of the third loop.\\n\\nThe problem might be solved more efficiently by exploiting the hint: creating a prefix sum array and applying two pointers. Here is an optimized solution with time complexity `O(26*N)`:\\n\\n```python\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for ch1 in range(26):\\n            for ch2 in range(26):\\n                if ch1 == ch2:\\n                    continue\\n                prefix = [0] * (n + 1)\\n                for i in range(n):\\n                    prefix[i + 1] = prefix[i] + (1 if ord(s[i]) - 97 == ch1 else -1 if ord(s[i]) - 97 == ch2 else 0)\\n                min_prefix = 0\\n                for i in range(1, n + 1):\\n                    ans = max(ans, prefix[i] - min_prefix)\\n                    min_prefix = min(min_prefix, prefix[i])\\n        return ans\\n```\\n\\nThe core idea here is that we iterate through every possible pair of characters. For each pair, we construct a prefix sum array where the character corresponding to `ch1` is represented by `1`, the character corresponding to `ch2` by `-1`, and every other character by `0`.\\n\\nThen, we iterate over the prefix sum array, tracking the minimum prefix sum we\\'ve seen (`min_prefix`) and updating our answer (`ans`) as the maximum difference between the current prefix sum and the minimum prefix sum. This process effectively finds the subarray with the largest sum for this particular mapping of characters to `1` and `-1`, which corresponds to the string segment with the largest variance between the two characters.\\n\\nFinally, we return the largest variance we\\'ve found over all pairs of characters."
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "Try to ignore letters that are not present in the string. Also consider using letters directly without calculating chars."
                    },
                    {
                        "username": "nonme",
                        "content": ":( Sorry, it is possible that the version of your browser is too low to load the code-editor, please try to update browser to revert to using code-editor.\\n\\nOh no goodbye my streak"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Time Limit Exceeded\\n138 / 138 testcases passed\\nLast Executed Input\\nUse Testcase\\ns =\\n\\uD83D\\uDE11"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it\\'s a bad output, but LC says you should treat it as any other time out, it is just annoying that you don\\'t get the testCase that actually fails. "
                    }
                ]
            },
            {
                "id": 1963581,
                "content": [
                    {
                        "username": "seeker_747",
                        "content": "Not again , my streak is on the line..."
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "julkar9",
                        "content": "Hint: kadane\\'s algorithm but with at least one negative value.\\nAlso try these test cases\\n\"babbbaaaaabbbb\"\\n\"abbb\" \\n\"abbabaaba\""
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "https://www.icode9.com/content-4-1373196.html\\n\\nAlso the exact question was posted in march in leetcode discuss interview question section. Somehow it got removed from there.\\n\\nOverall a nice problem"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "The hard questions really want you to think out of the box.\nSuch a great question :)"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "I might be wrong bit I think it\\'s sliding window problem after considering all pairs. But we need to have atleast a single 1 with opposite sign to be considered as valid answer, right?\\nlike [1,1,1] the max sum would be 3 but ans is 0. right?\\nfor [1,1,1,-1] the answer is 2 and not 3, it\\'s not just maximum subarray sum. I am hella confused.\\n"
                    },
                    {
                        "username": "sachin269",
                        "content": "in all same char case the pair combo is also like (a,a) from the possible pair combo so ensuring the ans 0 is by default considering through the case but when a diff char is being introduced different combo needs to be taken care of like if \"aab\" (a,a),(a,b) all are being taken care of when in the pair different char are available freq(a),freq(b)both should be non zero as fre(b) being zero  makes no sense of calculating variance and freq(a) if zero varaince will be negative"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "yeah that is indeed confusing. but it is mentioned in the question that, occurence of any two characters present in a substring. as an example if you take the string \"aaaa\", here you must have to find the difference between two characters(it also says that they might be the same character). So the answer being 0 instead of being 4 backs up my explanation which is => ans = maximum absolute difference of (occurence of s[i] - occurence of s[j]), where i and j can be any valid indexes in string s. since all characters are \\'a\\', we will get the answer = 4 - 4 = 0. Hope I explained properly : )"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "I suppose the hard part is understanding the question"
                    },
                    {
                        "username": "alyoshark",
                        "content": "I\\'m so comforted to see that I\\'m not the only one who doesn\\'t understand the question"
                    },
                    {
                        "username": "vaibhavkumargautam",
                        "content": "Time complexity - (26 * 26 * N)\\nStill limit limit exceeded error.\\nCan\\'t understand why?\\n\\n\\nCan anyone please help me?\\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        maxi=0\\n        dicta=[0]*26\\n        for i in range(0,len(s)):\\n            dicta[ord(s[i])-97]+=1\\n        for ch1 in range(0,26):           \\n            for ch2 in range(0,26):                     \\n                if ch1==ch2 or  dicta[ch2]==0 or  dicta[ch1]==0:\\n                    continue\\n                else:\\n                    word1=0\\n                    word2=0    \\n                    remain1=dicta[ch1]         \\n                    for i in range(0,len(s)):                               \\n                        if ch1==(ord(s[i])-97):\\n                            word1+=1\\n                            remain1-=1\\n\\n                        if ch2==(ord(s[i])-97):\\n                            word2+=1\\n                        \\n                        if word2<word1 and remain1>=1:\\n                            word1=0\\n                            word2=0\\n                           \\n                        if word2>0 and word1>0:\\n                            maxi=max(maxi,word2-word1)     \\n                                          \\n        return maxi\\n        \\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current solution involves two nested loops over 26 possible characters plus a loop over the length of the string inside them, yielding a time complexity of `O(26*26*N)`. Even though the character loops are not too large, this can still cause a time limit exceeded error for long strings because of the third loop.\\n\\nThe problem might be solved more efficiently by exploiting the hint: creating a prefix sum array and applying two pointers. Here is an optimized solution with time complexity `O(26*N)`:\\n\\n```python\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for ch1 in range(26):\\n            for ch2 in range(26):\\n                if ch1 == ch2:\\n                    continue\\n                prefix = [0] * (n + 1)\\n                for i in range(n):\\n                    prefix[i + 1] = prefix[i] + (1 if ord(s[i]) - 97 == ch1 else -1 if ord(s[i]) - 97 == ch2 else 0)\\n                min_prefix = 0\\n                for i in range(1, n + 1):\\n                    ans = max(ans, prefix[i] - min_prefix)\\n                    min_prefix = min(min_prefix, prefix[i])\\n        return ans\\n```\\n\\nThe core idea here is that we iterate through every possible pair of characters. For each pair, we construct a prefix sum array where the character corresponding to `ch1` is represented by `1`, the character corresponding to `ch2` by `-1`, and every other character by `0`.\\n\\nThen, we iterate over the prefix sum array, tracking the minimum prefix sum we\\'ve seen (`min_prefix`) and updating our answer (`ans`) as the maximum difference between the current prefix sum and the minimum prefix sum. This process effectively finds the subarray with the largest sum for this particular mapping of characters to `1` and `-1`, which corresponds to the string segment with the largest variance between the two characters.\\n\\nFinally, we return the largest variance we\\'ve found over all pairs of characters."
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "Try to ignore letters that are not present in the string. Also consider using letters directly without calculating chars."
                    },
                    {
                        "username": "nonme",
                        "content": ":( Sorry, it is possible that the version of your browser is too low to load the code-editor, please try to update browser to revert to using code-editor.\\n\\nOh no goodbye my streak"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Time Limit Exceeded\\n138 / 138 testcases passed\\nLast Executed Input\\nUse Testcase\\ns =\\n\\uD83D\\uDE11"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it\\'s a bad output, but LC says you should treat it as any other time out, it is just annoying that you don\\'t get the testCase that actually fails. "
                    }
                ]
            },
            {
                "id": 1963218,
                "content": [
                    {
                        "username": "seeker_747",
                        "content": "Not again , my streak is on the line..."
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "julkar9",
                        "content": "Hint: kadane\\'s algorithm but with at least one negative value.\\nAlso try these test cases\\n\"babbbaaaaabbbb\"\\n\"abbb\" \\n\"abbabaaba\""
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "https://www.icode9.com/content-4-1373196.html\\n\\nAlso the exact question was posted in march in leetcode discuss interview question section. Somehow it got removed from there.\\n\\nOverall a nice problem"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "The hard questions really want you to think out of the box.\nSuch a great question :)"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "I might be wrong bit I think it\\'s sliding window problem after considering all pairs. But we need to have atleast a single 1 with opposite sign to be considered as valid answer, right?\\nlike [1,1,1] the max sum would be 3 but ans is 0. right?\\nfor [1,1,1,-1] the answer is 2 and not 3, it\\'s not just maximum subarray sum. I am hella confused.\\n"
                    },
                    {
                        "username": "sachin269",
                        "content": "in all same char case the pair combo is also like (a,a) from the possible pair combo so ensuring the ans 0 is by default considering through the case but when a diff char is being introduced different combo needs to be taken care of like if \"aab\" (a,a),(a,b) all are being taken care of when in the pair different char are available freq(a),freq(b)both should be non zero as fre(b) being zero  makes no sense of calculating variance and freq(a) if zero varaince will be negative"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "yeah that is indeed confusing. but it is mentioned in the question that, occurence of any two characters present in a substring. as an example if you take the string \"aaaa\", here you must have to find the difference between two characters(it also says that they might be the same character). So the answer being 0 instead of being 4 backs up my explanation which is => ans = maximum absolute difference of (occurence of s[i] - occurence of s[j]), where i and j can be any valid indexes in string s. since all characters are \\'a\\', we will get the answer = 4 - 4 = 0. Hope I explained properly : )"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "I suppose the hard part is understanding the question"
                    },
                    {
                        "username": "alyoshark",
                        "content": "I\\'m so comforted to see that I\\'m not the only one who doesn\\'t understand the question"
                    },
                    {
                        "username": "vaibhavkumargautam",
                        "content": "Time complexity - (26 * 26 * N)\\nStill limit limit exceeded error.\\nCan\\'t understand why?\\n\\n\\nCan anyone please help me?\\n\\n```\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        maxi=0\\n        dicta=[0]*26\\n        for i in range(0,len(s)):\\n            dicta[ord(s[i])-97]+=1\\n        for ch1 in range(0,26):           \\n            for ch2 in range(0,26):                     \\n                if ch1==ch2 or  dicta[ch2]==0 or  dicta[ch1]==0:\\n                    continue\\n                else:\\n                    word1=0\\n                    word2=0    \\n                    remain1=dicta[ch1]         \\n                    for i in range(0,len(s)):                               \\n                        if ch1==(ord(s[i])-97):\\n                            word1+=1\\n                            remain1-=1\\n\\n                        if ch2==(ord(s[i])-97):\\n                            word2+=1\\n                        \\n                        if word2<word1 and remain1>=1:\\n                            word1=0\\n                            word2=0\\n                           \\n                        if word2>0 and word1>0:\\n                            maxi=max(maxi,word2-word1)     \\n                                          \\n        return maxi\\n        \\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current solution involves two nested loops over 26 possible characters plus a loop over the length of the string inside them, yielding a time complexity of `O(26*26*N)`. Even though the character loops are not too large, this can still cause a time limit exceeded error for long strings because of the third loop.\\n\\nThe problem might be solved more efficiently by exploiting the hint: creating a prefix sum array and applying two pointers. Here is an optimized solution with time complexity `O(26*N)`:\\n\\n```python\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for ch1 in range(26):\\n            for ch2 in range(26):\\n                if ch1 == ch2:\\n                    continue\\n                prefix = [0] * (n + 1)\\n                for i in range(n):\\n                    prefix[i + 1] = prefix[i] + (1 if ord(s[i]) - 97 == ch1 else -1 if ord(s[i]) - 97 == ch2 else 0)\\n                min_prefix = 0\\n                for i in range(1, n + 1):\\n                    ans = max(ans, prefix[i] - min_prefix)\\n                    min_prefix = min(min_prefix, prefix[i])\\n        return ans\\n```\\n\\nThe core idea here is that we iterate through every possible pair of characters. For each pair, we construct a prefix sum array where the character corresponding to `ch1` is represented by `1`, the character corresponding to `ch2` by `-1`, and every other character by `0`.\\n\\nThen, we iterate over the prefix sum array, tracking the minimum prefix sum we\\'ve seen (`min_prefix`) and updating our answer (`ans`) as the maximum difference between the current prefix sum and the minimum prefix sum. This process effectively finds the subarray with the largest sum for this particular mapping of characters to `1` and `-1`, which corresponds to the string segment with the largest variance between the two characters.\\n\\nFinally, we return the largest variance we\\'ve found over all pairs of characters."
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "Try to ignore letters that are not present in the string. Also consider using letters directly without calculating chars."
                    },
                    {
                        "username": "nonme",
                        "content": ":( Sorry, it is possible that the version of your browser is too low to load the code-editor, please try to update browser to revert to using code-editor.\\n\\nOh no goodbye my streak"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Time Limit Exceeded\\n138 / 138 testcases passed\\nLast Executed Input\\nUse Testcase\\ns =\\n\\uD83D\\uDE11"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it\\'s a bad output, but LC says you should treat it as any other time out, it is just annoying that you don\\'t get the testCase that actually fails. "
                    }
                ]
            },
            {
                "id": 1962765,
                "content": [
                    {
                        "username": "mlychndn",
                        "content": "On which case It will return 3 \"icexiahccknibwuwgi\", Any one can help"
                    },
                    {
                        "username": "pkorchak",
                        "content": "got it, I missed that we can choose any chars pair in the selected substring"
                    },
                    {
                        "username": "groverception",
                        "content": "[@pkorchak](/pkorchak) Because once you find the count of individual character you only have to take difference of minimum and maximum in that lot . so in the whole string string : {\"i\":4,\"c\":3,\"e\":1,\"x\":1,\"a\":1,\"h\":1,\"k\":1,\"n\":1,\"b\":1,\"w\":2,\"u\":1,\"g\":1} Max count is 4 which is of \\'i\\' and least count is any single character so difference is 3 ...."
                    },
                    {
                        "username": "julkar9",
                        "content": "4 i\\'s and one b or k or any single character with single occurrence"
                    },
                    {
                        "username": "pkorchak",
                        "content": "My solution also fails on that test and I can\\'t understand why that shouldn\\'t be 2..."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Summer and Hard problems ruined my strike"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "I tried brute force with `26 N^2` complexity, it passes 123/138 testcases. Am I missing something?"
                    },
                    {
                        "username": "hero080",
                        "content": "I did $26 + N^2$ and it still got TLE.\\n\\nWe can do much better though:\\n$26 N$ (better than the editorial solution $26^2 N$)\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "Stacks_And_Queues",
                        "content": "![image](https://assets.leetcode.com/users/images/3664cc0f-4c40-4a3f-995c-dbc7d12fa933_1652544354.9046297.png)\\n\\n\\nidk what was going on here... but as you can see my answer below \"Run Code Status: Finished\" matches the expected answer above... But for some reason it kept saying my output was 3 and not 1.\\n\\nMaybe it\\'s too early in the morning and it\\'s something really obvious.. But am I missing something here?"
                    },
                    {
                        "username": "Limon020",
                        "content": "good question, I learned Kadane\\'s algo"
                    },
                    {
                        "username": "manas150902",
                        "content": "Please correct me\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        unordered_set<char> st(s.begin(),s.end());\\n        int ans=0;\\n        for(auto a: st)\\n        {\\n            for(auto b: st)\\n            {\\n                if(a==b)\\n                continue;\\n                int f1=0,f2=0;\\n                for(int i=0;i<s.size();i++)\\n                {\\n                    if(s[i]==a)\\n                    f1++;\\n                    else if(s[i]==b)\\n                    f2++;\\n\\n                    if(f2==0)\\n                    continue;\\n\\n                    if(f1-f2==-1)\\n                    {\\n                        f1=0;\\n                        f2=0;\\n                        continue;\\n                    }\\n                    ans=max(ans,f1-f2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nInput\\ns =\\n\"lripaa\"\\nOutput\\n0\\nExpected\\n1\\n"
                    },
                    {
                        "username": "reassurance",
                        "content": "Her: Breakup hurts the most\n\nHim:  (shows her this) **TLE 122/138**\n\nHer: I am wrong\n\nPS: RIP 2 pointer approach"
                    },
                    {
                        "username": "WarGames",
                        "content": "What does \\u201CTime Limit Exceeded\\u201D mean? I don\\'t see timing constraints in the requirements. "
                    },
                    {
                        "username": "tifv",
                        "content": "[@WarGames](/WarGames) Time constraints can usually be inferred from input constraints. For example, in this problem the length in the input is $n = 10^{4}$, which means that solutions with $O(n)$ and $O(n \\\\cdot \\\\log(n))$ asymptotic time complexity would likely be accepted, and solutions with $O(n^2)$ complexity and higher are unlikely to pass."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@tifv](/tifv) nice to know, but to know it before starting coding would result in a different approach, though this did just waste time."
                    },
                    {
                        "username": "tifv",
                        "content": "Time is always a constraint, though it is never listed explicitly (and, possibly, is different for different languages). \\u201CTime Limit Exceeded\\u201D means you have to find a more efficient solution."
                    },
                    {
                        "username": "KieuA7702",
                        "content": "Anyone get  the right answer for this case?\\n\"fsoxzotgvxguvudpgntfujuvrkgkfwqalayujcbryotoyslfwhhwfxgwrbitncjpvpowejsyboaeqhpvgkjxijisnrjbawpedhrlablukuhzxhlrclmbbszoloeqqfhguocowsadhxkkvxxupwxyvqdqcagxldmzsuvjqjedteoizobbmtlnzmllaxbysymnhactdqyhipvazsqpnwulnsguchspaycvtbzdnhzrjjlbjmtvhtrcqcutthlyjjrhyjilayiqsjusojpypnuspxfxvcffpiebmlfdoqebsiqtflsddoxmcpooqkkjkgsgenvpwszzhqbqbaognwgdswtmiishmwgiknqfixlzqgbcsmfbfupbzvzbxexrdcoilspuae\""
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I\\'m getting same answer 13 but correct answer is 14 have you solved it?"
                    },
                    {
                        "username": "WarGames",
                        "content": "Yes, i get 14, and confirmed to be correct."
                    },
                    {
                        "username": "vogiaan1904",
                        "content": "the string can include numbers and symbols like  / ! @ & %,.... right ?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It says \\u201C`s` consists of lowercase English letters\\u201D right in the constraints."
                    }
                ]
            },
            {
                "id": 1962756,
                "content": [
                    {
                        "username": "mlychndn",
                        "content": "On which case It will return 3 \"icexiahccknibwuwgi\", Any one can help"
                    },
                    {
                        "username": "pkorchak",
                        "content": "got it, I missed that we can choose any chars pair in the selected substring"
                    },
                    {
                        "username": "groverception",
                        "content": "[@pkorchak](/pkorchak) Because once you find the count of individual character you only have to take difference of minimum and maximum in that lot . so in the whole string string : {\"i\":4,\"c\":3,\"e\":1,\"x\":1,\"a\":1,\"h\":1,\"k\":1,\"n\":1,\"b\":1,\"w\":2,\"u\":1,\"g\":1} Max count is 4 which is of \\'i\\' and least count is any single character so difference is 3 ...."
                    },
                    {
                        "username": "julkar9",
                        "content": "4 i\\'s and one b or k or any single character with single occurrence"
                    },
                    {
                        "username": "pkorchak",
                        "content": "My solution also fails on that test and I can\\'t understand why that shouldn\\'t be 2..."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Summer and Hard problems ruined my strike"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "I tried brute force with `26 N^2` complexity, it passes 123/138 testcases. Am I missing something?"
                    },
                    {
                        "username": "hero080",
                        "content": "I did $26 + N^2$ and it still got TLE.\\n\\nWe can do much better though:\\n$26 N$ (better than the editorial solution $26^2 N$)\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "Stacks_And_Queues",
                        "content": "![image](https://assets.leetcode.com/users/images/3664cc0f-4c40-4a3f-995c-dbc7d12fa933_1652544354.9046297.png)\\n\\n\\nidk what was going on here... but as you can see my answer below \"Run Code Status: Finished\" matches the expected answer above... But for some reason it kept saying my output was 3 and not 1.\\n\\nMaybe it\\'s too early in the morning and it\\'s something really obvious.. But am I missing something here?"
                    },
                    {
                        "username": "Limon020",
                        "content": "good question, I learned Kadane\\'s algo"
                    },
                    {
                        "username": "manas150902",
                        "content": "Please correct me\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        unordered_set<char> st(s.begin(),s.end());\\n        int ans=0;\\n        for(auto a: st)\\n        {\\n            for(auto b: st)\\n            {\\n                if(a==b)\\n                continue;\\n                int f1=0,f2=0;\\n                for(int i=0;i<s.size();i++)\\n                {\\n                    if(s[i]==a)\\n                    f1++;\\n                    else if(s[i]==b)\\n                    f2++;\\n\\n                    if(f2==0)\\n                    continue;\\n\\n                    if(f1-f2==-1)\\n                    {\\n                        f1=0;\\n                        f2=0;\\n                        continue;\\n                    }\\n                    ans=max(ans,f1-f2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nInput\\ns =\\n\"lripaa\"\\nOutput\\n0\\nExpected\\n1\\n"
                    },
                    {
                        "username": "reassurance",
                        "content": "Her: Breakup hurts the most\n\nHim:  (shows her this) **TLE 122/138**\n\nHer: I am wrong\n\nPS: RIP 2 pointer approach"
                    },
                    {
                        "username": "WarGames",
                        "content": "What does \\u201CTime Limit Exceeded\\u201D mean? I don\\'t see timing constraints in the requirements. "
                    },
                    {
                        "username": "tifv",
                        "content": "[@WarGames](/WarGames) Time constraints can usually be inferred from input constraints. For example, in this problem the length in the input is $n = 10^{4}$, which means that solutions with $O(n)$ and $O(n \\\\cdot \\\\log(n))$ asymptotic time complexity would likely be accepted, and solutions with $O(n^2)$ complexity and higher are unlikely to pass."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@tifv](/tifv) nice to know, but to know it before starting coding would result in a different approach, though this did just waste time."
                    },
                    {
                        "username": "tifv",
                        "content": "Time is always a constraint, though it is never listed explicitly (and, possibly, is different for different languages). \\u201CTime Limit Exceeded\\u201D means you have to find a more efficient solution."
                    },
                    {
                        "username": "KieuA7702",
                        "content": "Anyone get  the right answer for this case?\\n\"fsoxzotgvxguvudpgntfujuvrkgkfwqalayujcbryotoyslfwhhwfxgwrbitncjpvpowejsyboaeqhpvgkjxijisnrjbawpedhrlablukuhzxhlrclmbbszoloeqqfhguocowsadhxkkvxxupwxyvqdqcagxldmzsuvjqjedteoizobbmtlnzmllaxbysymnhactdqyhipvazsqpnwulnsguchspaycvtbzdnhzrjjlbjmtvhtrcqcutthlyjjrhyjilayiqsjusojpypnuspxfxvcffpiebmlfdoqebsiqtflsddoxmcpooqkkjkgsgenvpwszzhqbqbaognwgdswtmiishmwgiknqfixlzqgbcsmfbfupbzvzbxexrdcoilspuae\""
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I\\'m getting same answer 13 but correct answer is 14 have you solved it?"
                    },
                    {
                        "username": "WarGames",
                        "content": "Yes, i get 14, and confirmed to be correct."
                    },
                    {
                        "username": "vogiaan1904",
                        "content": "the string can include numbers and symbols like  / ! @ & %,.... right ?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It says \\u201C`s` consists of lowercase English letters\\u201D right in the constraints."
                    }
                ]
            },
            {
                "id": 1962381,
                "content": [
                    {
                        "username": "mlychndn",
                        "content": "On which case It will return 3 \"icexiahccknibwuwgi\", Any one can help"
                    },
                    {
                        "username": "pkorchak",
                        "content": "got it, I missed that we can choose any chars pair in the selected substring"
                    },
                    {
                        "username": "groverception",
                        "content": "[@pkorchak](/pkorchak) Because once you find the count of individual character you only have to take difference of minimum and maximum in that lot . so in the whole string string : {\"i\":4,\"c\":3,\"e\":1,\"x\":1,\"a\":1,\"h\":1,\"k\":1,\"n\":1,\"b\":1,\"w\":2,\"u\":1,\"g\":1} Max count is 4 which is of \\'i\\' and least count is any single character so difference is 3 ...."
                    },
                    {
                        "username": "julkar9",
                        "content": "4 i\\'s and one b or k or any single character with single occurrence"
                    },
                    {
                        "username": "pkorchak",
                        "content": "My solution also fails on that test and I can\\'t understand why that shouldn\\'t be 2..."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Summer and Hard problems ruined my strike"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "I tried brute force with `26 N^2` complexity, it passes 123/138 testcases. Am I missing something?"
                    },
                    {
                        "username": "hero080",
                        "content": "I did $26 + N^2$ and it still got TLE.\\n\\nWe can do much better though:\\n$26 N$ (better than the editorial solution $26^2 N$)\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "Stacks_And_Queues",
                        "content": "![image](https://assets.leetcode.com/users/images/3664cc0f-4c40-4a3f-995c-dbc7d12fa933_1652544354.9046297.png)\\n\\n\\nidk what was going on here... but as you can see my answer below \"Run Code Status: Finished\" matches the expected answer above... But for some reason it kept saying my output was 3 and not 1.\\n\\nMaybe it\\'s too early in the morning and it\\'s something really obvious.. But am I missing something here?"
                    },
                    {
                        "username": "Limon020",
                        "content": "good question, I learned Kadane\\'s algo"
                    },
                    {
                        "username": "manas150902",
                        "content": "Please correct me\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        unordered_set<char> st(s.begin(),s.end());\\n        int ans=0;\\n        for(auto a: st)\\n        {\\n            for(auto b: st)\\n            {\\n                if(a==b)\\n                continue;\\n                int f1=0,f2=0;\\n                for(int i=0;i<s.size();i++)\\n                {\\n                    if(s[i]==a)\\n                    f1++;\\n                    else if(s[i]==b)\\n                    f2++;\\n\\n                    if(f2==0)\\n                    continue;\\n\\n                    if(f1-f2==-1)\\n                    {\\n                        f1=0;\\n                        f2=0;\\n                        continue;\\n                    }\\n                    ans=max(ans,f1-f2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nInput\\ns =\\n\"lripaa\"\\nOutput\\n0\\nExpected\\n1\\n"
                    },
                    {
                        "username": "reassurance",
                        "content": "Her: Breakup hurts the most\n\nHim:  (shows her this) **TLE 122/138**\n\nHer: I am wrong\n\nPS: RIP 2 pointer approach"
                    },
                    {
                        "username": "WarGames",
                        "content": "What does \\u201CTime Limit Exceeded\\u201D mean? I don\\'t see timing constraints in the requirements. "
                    },
                    {
                        "username": "tifv",
                        "content": "[@WarGames](/WarGames) Time constraints can usually be inferred from input constraints. For example, in this problem the length in the input is $n = 10^{4}$, which means that solutions with $O(n)$ and $O(n \\\\cdot \\\\log(n))$ asymptotic time complexity would likely be accepted, and solutions with $O(n^2)$ complexity and higher are unlikely to pass."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@tifv](/tifv) nice to know, but to know it before starting coding would result in a different approach, though this did just waste time."
                    },
                    {
                        "username": "tifv",
                        "content": "Time is always a constraint, though it is never listed explicitly (and, possibly, is different for different languages). \\u201CTime Limit Exceeded\\u201D means you have to find a more efficient solution."
                    },
                    {
                        "username": "KieuA7702",
                        "content": "Anyone get  the right answer for this case?\\n\"fsoxzotgvxguvudpgntfujuvrkgkfwqalayujcbryotoyslfwhhwfxgwrbitncjpvpowejsyboaeqhpvgkjxijisnrjbawpedhrlablukuhzxhlrclmbbszoloeqqfhguocowsadhxkkvxxupwxyvqdqcagxldmzsuvjqjedteoizobbmtlnzmllaxbysymnhactdqyhipvazsqpnwulnsguchspaycvtbzdnhzrjjlbjmtvhtrcqcutthlyjjrhyjilayiqsjusojpypnuspxfxvcffpiebmlfdoqebsiqtflsddoxmcpooqkkjkgsgenvpwszzhqbqbaognwgdswtmiishmwgiknqfixlzqgbcsmfbfupbzvzbxexrdcoilspuae\""
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I\\'m getting same answer 13 but correct answer is 14 have you solved it?"
                    },
                    {
                        "username": "WarGames",
                        "content": "Yes, i get 14, and confirmed to be correct."
                    },
                    {
                        "username": "vogiaan1904",
                        "content": "the string can include numbers and symbols like  / ! @ & %,.... right ?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It says \\u201C`s` consists of lowercase English letters\\u201D right in the constraints."
                    }
                ]
            },
            {
                "id": 1576751,
                "content": [
                    {
                        "username": "mlychndn",
                        "content": "On which case It will return 3 \"icexiahccknibwuwgi\", Any one can help"
                    },
                    {
                        "username": "pkorchak",
                        "content": "got it, I missed that we can choose any chars pair in the selected substring"
                    },
                    {
                        "username": "groverception",
                        "content": "[@pkorchak](/pkorchak) Because once you find the count of individual character you only have to take difference of minimum and maximum in that lot . so in the whole string string : {\"i\":4,\"c\":3,\"e\":1,\"x\":1,\"a\":1,\"h\":1,\"k\":1,\"n\":1,\"b\":1,\"w\":2,\"u\":1,\"g\":1} Max count is 4 which is of \\'i\\' and least count is any single character so difference is 3 ...."
                    },
                    {
                        "username": "julkar9",
                        "content": "4 i\\'s and one b or k or any single character with single occurrence"
                    },
                    {
                        "username": "pkorchak",
                        "content": "My solution also fails on that test and I can\\'t understand why that shouldn\\'t be 2..."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Summer and Hard problems ruined my strike"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "I tried brute force with `26 N^2` complexity, it passes 123/138 testcases. Am I missing something?"
                    },
                    {
                        "username": "hero080",
                        "content": "I did $26 + N^2$ and it still got TLE.\\n\\nWe can do much better though:\\n$26 N$ (better than the editorial solution $26^2 N$)\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "Stacks_And_Queues",
                        "content": "![image](https://assets.leetcode.com/users/images/3664cc0f-4c40-4a3f-995c-dbc7d12fa933_1652544354.9046297.png)\\n\\n\\nidk what was going on here... but as you can see my answer below \"Run Code Status: Finished\" matches the expected answer above... But for some reason it kept saying my output was 3 and not 1.\\n\\nMaybe it\\'s too early in the morning and it\\'s something really obvious.. But am I missing something here?"
                    },
                    {
                        "username": "Limon020",
                        "content": "good question, I learned Kadane\\'s algo"
                    },
                    {
                        "username": "manas150902",
                        "content": "Please correct me\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        unordered_set<char> st(s.begin(),s.end());\\n        int ans=0;\\n        for(auto a: st)\\n        {\\n            for(auto b: st)\\n            {\\n                if(a==b)\\n                continue;\\n                int f1=0,f2=0;\\n                for(int i=0;i<s.size();i++)\\n                {\\n                    if(s[i]==a)\\n                    f1++;\\n                    else if(s[i]==b)\\n                    f2++;\\n\\n                    if(f2==0)\\n                    continue;\\n\\n                    if(f1-f2==-1)\\n                    {\\n                        f1=0;\\n                        f2=0;\\n                        continue;\\n                    }\\n                    ans=max(ans,f1-f2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nInput\\ns =\\n\"lripaa\"\\nOutput\\n0\\nExpected\\n1\\n"
                    },
                    {
                        "username": "reassurance",
                        "content": "Her: Breakup hurts the most\n\nHim:  (shows her this) **TLE 122/138**\n\nHer: I am wrong\n\nPS: RIP 2 pointer approach"
                    },
                    {
                        "username": "WarGames",
                        "content": "What does \\u201CTime Limit Exceeded\\u201D mean? I don\\'t see timing constraints in the requirements. "
                    },
                    {
                        "username": "tifv",
                        "content": "[@WarGames](/WarGames) Time constraints can usually be inferred from input constraints. For example, in this problem the length in the input is $n = 10^{4}$, which means that solutions with $O(n)$ and $O(n \\\\cdot \\\\log(n))$ asymptotic time complexity would likely be accepted, and solutions with $O(n^2)$ complexity and higher are unlikely to pass."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@tifv](/tifv) nice to know, but to know it before starting coding would result in a different approach, though this did just waste time."
                    },
                    {
                        "username": "tifv",
                        "content": "Time is always a constraint, though it is never listed explicitly (and, possibly, is different for different languages). \\u201CTime Limit Exceeded\\u201D means you have to find a more efficient solution."
                    },
                    {
                        "username": "KieuA7702",
                        "content": "Anyone get  the right answer for this case?\\n\"fsoxzotgvxguvudpgntfujuvrkgkfwqalayujcbryotoyslfwhhwfxgwrbitncjpvpowejsyboaeqhpvgkjxijisnrjbawpedhrlablukuhzxhlrclmbbszoloeqqfhguocowsadhxkkvxxupwxyvqdqcagxldmzsuvjqjedteoizobbmtlnzmllaxbysymnhactdqyhipvazsqpnwulnsguchspaycvtbzdnhzrjjlbjmtvhtrcqcutthlyjjrhyjilayiqsjusojpypnuspxfxvcffpiebmlfdoqebsiqtflsddoxmcpooqkkjkgsgenvpwszzhqbqbaognwgdswtmiishmwgiknqfixlzqgbcsmfbfupbzvzbxexrdcoilspuae\""
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I\\'m getting same answer 13 but correct answer is 14 have you solved it?"
                    },
                    {
                        "username": "WarGames",
                        "content": "Yes, i get 14, and confirmed to be correct."
                    },
                    {
                        "username": "vogiaan1904",
                        "content": "the string can include numbers and symbols like  / ! @ & %,.... right ?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It says \\u201C`s` consists of lowercase English letters\\u201D right in the constraints."
                    }
                ]
            },
            {
                "id": 2067728,
                "content": [
                    {
                        "username": "mlychndn",
                        "content": "On which case It will return 3 \"icexiahccknibwuwgi\", Any one can help"
                    },
                    {
                        "username": "pkorchak",
                        "content": "got it, I missed that we can choose any chars pair in the selected substring"
                    },
                    {
                        "username": "groverception",
                        "content": "[@pkorchak](/pkorchak) Because once you find the count of individual character you only have to take difference of minimum and maximum in that lot . so in the whole string string : {\"i\":4,\"c\":3,\"e\":1,\"x\":1,\"a\":1,\"h\":1,\"k\":1,\"n\":1,\"b\":1,\"w\":2,\"u\":1,\"g\":1} Max count is 4 which is of \\'i\\' and least count is any single character so difference is 3 ...."
                    },
                    {
                        "username": "julkar9",
                        "content": "4 i\\'s and one b or k or any single character with single occurrence"
                    },
                    {
                        "username": "pkorchak",
                        "content": "My solution also fails on that test and I can\\'t understand why that shouldn\\'t be 2..."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Summer and Hard problems ruined my strike"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "I tried brute force with `26 N^2` complexity, it passes 123/138 testcases. Am I missing something?"
                    },
                    {
                        "username": "hero080",
                        "content": "I did $26 + N^2$ and it still got TLE.\\n\\nWe can do much better though:\\n$26 N$ (better than the editorial solution $26^2 N$)\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "Stacks_And_Queues",
                        "content": "![image](https://assets.leetcode.com/users/images/3664cc0f-4c40-4a3f-995c-dbc7d12fa933_1652544354.9046297.png)\\n\\n\\nidk what was going on here... but as you can see my answer below \"Run Code Status: Finished\" matches the expected answer above... But for some reason it kept saying my output was 3 and not 1.\\n\\nMaybe it\\'s too early in the morning and it\\'s something really obvious.. But am I missing something here?"
                    },
                    {
                        "username": "Limon020",
                        "content": "good question, I learned Kadane\\'s algo"
                    },
                    {
                        "username": "manas150902",
                        "content": "Please correct me\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        unordered_set<char> st(s.begin(),s.end());\\n        int ans=0;\\n        for(auto a: st)\\n        {\\n            for(auto b: st)\\n            {\\n                if(a==b)\\n                continue;\\n                int f1=0,f2=0;\\n                for(int i=0;i<s.size();i++)\\n                {\\n                    if(s[i]==a)\\n                    f1++;\\n                    else if(s[i]==b)\\n                    f2++;\\n\\n                    if(f2==0)\\n                    continue;\\n\\n                    if(f1-f2==-1)\\n                    {\\n                        f1=0;\\n                        f2=0;\\n                        continue;\\n                    }\\n                    ans=max(ans,f1-f2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nInput\\ns =\\n\"lripaa\"\\nOutput\\n0\\nExpected\\n1\\n"
                    },
                    {
                        "username": "reassurance",
                        "content": "Her: Breakup hurts the most\n\nHim:  (shows her this) **TLE 122/138**\n\nHer: I am wrong\n\nPS: RIP 2 pointer approach"
                    },
                    {
                        "username": "WarGames",
                        "content": "What does \\u201CTime Limit Exceeded\\u201D mean? I don\\'t see timing constraints in the requirements. "
                    },
                    {
                        "username": "tifv",
                        "content": "[@WarGames](/WarGames) Time constraints can usually be inferred from input constraints. For example, in this problem the length in the input is $n = 10^{4}$, which means that solutions with $O(n)$ and $O(n \\\\cdot \\\\log(n))$ asymptotic time complexity would likely be accepted, and solutions with $O(n^2)$ complexity and higher are unlikely to pass."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@tifv](/tifv) nice to know, but to know it before starting coding would result in a different approach, though this did just waste time."
                    },
                    {
                        "username": "tifv",
                        "content": "Time is always a constraint, though it is never listed explicitly (and, possibly, is different for different languages). \\u201CTime Limit Exceeded\\u201D means you have to find a more efficient solution."
                    },
                    {
                        "username": "KieuA7702",
                        "content": "Anyone get  the right answer for this case?\\n\"fsoxzotgvxguvudpgntfujuvrkgkfwqalayujcbryotoyslfwhhwfxgwrbitncjpvpowejsyboaeqhpvgkjxijisnrjbawpedhrlablukuhzxhlrclmbbszoloeqqfhguocowsadhxkkvxxupwxyvqdqcagxldmzsuvjqjedteoizobbmtlnzmllaxbysymnhactdqyhipvazsqpnwulnsguchspaycvtbzdnhzrjjlbjmtvhtrcqcutthlyjjrhyjilayiqsjusojpypnuspxfxvcffpiebmlfdoqebsiqtflsddoxmcpooqkkjkgsgenvpwszzhqbqbaognwgdswtmiishmwgiknqfixlzqgbcsmfbfupbzvzbxexrdcoilspuae\""
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I\\'m getting same answer 13 but correct answer is 14 have you solved it?"
                    },
                    {
                        "username": "WarGames",
                        "content": "Yes, i get 14, and confirmed to be correct."
                    },
                    {
                        "username": "vogiaan1904",
                        "content": "the string can include numbers and symbols like  / ! @ & %,.... right ?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It says \\u201C`s` consists of lowercase English letters\\u201D right in the constraints."
                    }
                ]
            },
            {
                "id": 2064566,
                "content": [
                    {
                        "username": "mlychndn",
                        "content": "On which case It will return 3 \"icexiahccknibwuwgi\", Any one can help"
                    },
                    {
                        "username": "pkorchak",
                        "content": "got it, I missed that we can choose any chars pair in the selected substring"
                    },
                    {
                        "username": "groverception",
                        "content": "[@pkorchak](/pkorchak) Because once you find the count of individual character you only have to take difference of minimum and maximum in that lot . so in the whole string string : {\"i\":4,\"c\":3,\"e\":1,\"x\":1,\"a\":1,\"h\":1,\"k\":1,\"n\":1,\"b\":1,\"w\":2,\"u\":1,\"g\":1} Max count is 4 which is of \\'i\\' and least count is any single character so difference is 3 ...."
                    },
                    {
                        "username": "julkar9",
                        "content": "4 i\\'s and one b or k or any single character with single occurrence"
                    },
                    {
                        "username": "pkorchak",
                        "content": "My solution also fails on that test and I can\\'t understand why that shouldn\\'t be 2..."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Summer and Hard problems ruined my strike"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "I tried brute force with `26 N^2` complexity, it passes 123/138 testcases. Am I missing something?"
                    },
                    {
                        "username": "hero080",
                        "content": "I did $26 + N^2$ and it still got TLE.\\n\\nWe can do much better though:\\n$26 N$ (better than the editorial solution $26^2 N$)\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "Stacks_And_Queues",
                        "content": "![image](https://assets.leetcode.com/users/images/3664cc0f-4c40-4a3f-995c-dbc7d12fa933_1652544354.9046297.png)\\n\\n\\nidk what was going on here... but as you can see my answer below \"Run Code Status: Finished\" matches the expected answer above... But for some reason it kept saying my output was 3 and not 1.\\n\\nMaybe it\\'s too early in the morning and it\\'s something really obvious.. But am I missing something here?"
                    },
                    {
                        "username": "Limon020",
                        "content": "good question, I learned Kadane\\'s algo"
                    },
                    {
                        "username": "manas150902",
                        "content": "Please correct me\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        unordered_set<char> st(s.begin(),s.end());\\n        int ans=0;\\n        for(auto a: st)\\n        {\\n            for(auto b: st)\\n            {\\n                if(a==b)\\n                continue;\\n                int f1=0,f2=0;\\n                for(int i=0;i<s.size();i++)\\n                {\\n                    if(s[i]==a)\\n                    f1++;\\n                    else if(s[i]==b)\\n                    f2++;\\n\\n                    if(f2==0)\\n                    continue;\\n\\n                    if(f1-f2==-1)\\n                    {\\n                        f1=0;\\n                        f2=0;\\n                        continue;\\n                    }\\n                    ans=max(ans,f1-f2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nInput\\ns =\\n\"lripaa\"\\nOutput\\n0\\nExpected\\n1\\n"
                    },
                    {
                        "username": "reassurance",
                        "content": "Her: Breakup hurts the most\n\nHim:  (shows her this) **TLE 122/138**\n\nHer: I am wrong\n\nPS: RIP 2 pointer approach"
                    },
                    {
                        "username": "WarGames",
                        "content": "What does \\u201CTime Limit Exceeded\\u201D mean? I don\\'t see timing constraints in the requirements. "
                    },
                    {
                        "username": "tifv",
                        "content": "[@WarGames](/WarGames) Time constraints can usually be inferred from input constraints. For example, in this problem the length in the input is $n = 10^{4}$, which means that solutions with $O(n)$ and $O(n \\\\cdot \\\\log(n))$ asymptotic time complexity would likely be accepted, and solutions with $O(n^2)$ complexity and higher are unlikely to pass."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@tifv](/tifv) nice to know, but to know it before starting coding would result in a different approach, though this did just waste time."
                    },
                    {
                        "username": "tifv",
                        "content": "Time is always a constraint, though it is never listed explicitly (and, possibly, is different for different languages). \\u201CTime Limit Exceeded\\u201D means you have to find a more efficient solution."
                    },
                    {
                        "username": "KieuA7702",
                        "content": "Anyone get  the right answer for this case?\\n\"fsoxzotgvxguvudpgntfujuvrkgkfwqalayujcbryotoyslfwhhwfxgwrbitncjpvpowejsyboaeqhpvgkjxijisnrjbawpedhrlablukuhzxhlrclmbbszoloeqqfhguocowsadhxkkvxxupwxyvqdqcagxldmzsuvjqjedteoizobbmtlnzmllaxbysymnhactdqyhipvazsqpnwulnsguchspaycvtbzdnhzrjjlbjmtvhtrcqcutthlyjjrhyjilayiqsjusojpypnuspxfxvcffpiebmlfdoqebsiqtflsddoxmcpooqkkjkgsgenvpwszzhqbqbaognwgdswtmiishmwgiknqfixlzqgbcsmfbfupbzvzbxexrdcoilspuae\""
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I\\'m getting same answer 13 but correct answer is 14 have you solved it?"
                    },
                    {
                        "username": "WarGames",
                        "content": "Yes, i get 14, and confirmed to be correct."
                    },
                    {
                        "username": "vogiaan1904",
                        "content": "the string can include numbers and symbols like  / ! @ & %,.... right ?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It says \\u201C`s` consists of lowercase English letters\\u201D right in the constraints."
                    }
                ]
            },
            {
                "id": 2030016,
                "content": [
                    {
                        "username": "mlychndn",
                        "content": "On which case It will return 3 \"icexiahccknibwuwgi\", Any one can help"
                    },
                    {
                        "username": "pkorchak",
                        "content": "got it, I missed that we can choose any chars pair in the selected substring"
                    },
                    {
                        "username": "groverception",
                        "content": "[@pkorchak](/pkorchak) Because once you find the count of individual character you only have to take difference of minimum and maximum in that lot . so in the whole string string : {\"i\":4,\"c\":3,\"e\":1,\"x\":1,\"a\":1,\"h\":1,\"k\":1,\"n\":1,\"b\":1,\"w\":2,\"u\":1,\"g\":1} Max count is 4 which is of \\'i\\' and least count is any single character so difference is 3 ...."
                    },
                    {
                        "username": "julkar9",
                        "content": "4 i\\'s and one b or k or any single character with single occurrence"
                    },
                    {
                        "username": "pkorchak",
                        "content": "My solution also fails on that test and I can\\'t understand why that shouldn\\'t be 2..."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Summer and Hard problems ruined my strike"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "I tried brute force with `26 N^2` complexity, it passes 123/138 testcases. Am I missing something?"
                    },
                    {
                        "username": "hero080",
                        "content": "I did $26 + N^2$ and it still got TLE.\\n\\nWe can do much better though:\\n$26 N$ (better than the editorial solution $26^2 N$)\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "Stacks_And_Queues",
                        "content": "![image](https://assets.leetcode.com/users/images/3664cc0f-4c40-4a3f-995c-dbc7d12fa933_1652544354.9046297.png)\\n\\n\\nidk what was going on here... but as you can see my answer below \"Run Code Status: Finished\" matches the expected answer above... But for some reason it kept saying my output was 3 and not 1.\\n\\nMaybe it\\'s too early in the morning and it\\'s something really obvious.. But am I missing something here?"
                    },
                    {
                        "username": "Limon020",
                        "content": "good question, I learned Kadane\\'s algo"
                    },
                    {
                        "username": "manas150902",
                        "content": "Please correct me\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        unordered_set<char> st(s.begin(),s.end());\\n        int ans=0;\\n        for(auto a: st)\\n        {\\n            for(auto b: st)\\n            {\\n                if(a==b)\\n                continue;\\n                int f1=0,f2=0;\\n                for(int i=0;i<s.size();i++)\\n                {\\n                    if(s[i]==a)\\n                    f1++;\\n                    else if(s[i]==b)\\n                    f2++;\\n\\n                    if(f2==0)\\n                    continue;\\n\\n                    if(f1-f2==-1)\\n                    {\\n                        f1=0;\\n                        f2=0;\\n                        continue;\\n                    }\\n                    ans=max(ans,f1-f2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nInput\\ns =\\n\"lripaa\"\\nOutput\\n0\\nExpected\\n1\\n"
                    },
                    {
                        "username": "reassurance",
                        "content": "Her: Breakup hurts the most\n\nHim:  (shows her this) **TLE 122/138**\n\nHer: I am wrong\n\nPS: RIP 2 pointer approach"
                    },
                    {
                        "username": "WarGames",
                        "content": "What does \\u201CTime Limit Exceeded\\u201D mean? I don\\'t see timing constraints in the requirements. "
                    },
                    {
                        "username": "tifv",
                        "content": "[@WarGames](/WarGames) Time constraints can usually be inferred from input constraints. For example, in this problem the length in the input is $n = 10^{4}$, which means that solutions with $O(n)$ and $O(n \\\\cdot \\\\log(n))$ asymptotic time complexity would likely be accepted, and solutions with $O(n^2)$ complexity and higher are unlikely to pass."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@tifv](/tifv) nice to know, but to know it before starting coding would result in a different approach, though this did just waste time."
                    },
                    {
                        "username": "tifv",
                        "content": "Time is always a constraint, though it is never listed explicitly (and, possibly, is different for different languages). \\u201CTime Limit Exceeded\\u201D means you have to find a more efficient solution."
                    },
                    {
                        "username": "KieuA7702",
                        "content": "Anyone get  the right answer for this case?\\n\"fsoxzotgvxguvudpgntfujuvrkgkfwqalayujcbryotoyslfwhhwfxgwrbitncjpvpowejsyboaeqhpvgkjxijisnrjbawpedhrlablukuhzxhlrclmbbszoloeqqfhguocowsadhxkkvxxupwxyvqdqcagxldmzsuvjqjedteoizobbmtlnzmllaxbysymnhactdqyhipvazsqpnwulnsguchspaycvtbzdnhzrjjlbjmtvhtrcqcutthlyjjrhyjilayiqsjusojpypnuspxfxvcffpiebmlfdoqebsiqtflsddoxmcpooqkkjkgsgenvpwszzhqbqbaognwgdswtmiishmwgiknqfixlzqgbcsmfbfupbzvzbxexrdcoilspuae\""
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I\\'m getting same answer 13 but correct answer is 14 have you solved it?"
                    },
                    {
                        "username": "WarGames",
                        "content": "Yes, i get 14, and confirmed to be correct."
                    },
                    {
                        "username": "vogiaan1904",
                        "content": "the string can include numbers and symbols like  / ! @ & %,.... right ?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It says \\u201C`s` consists of lowercase English letters\\u201D right in the constraints."
                    }
                ]
            },
            {
                "id": 2006398,
                "content": [
                    {
                        "username": "mlychndn",
                        "content": "On which case It will return 3 \"icexiahccknibwuwgi\", Any one can help"
                    },
                    {
                        "username": "pkorchak",
                        "content": "got it, I missed that we can choose any chars pair in the selected substring"
                    },
                    {
                        "username": "groverception",
                        "content": "[@pkorchak](/pkorchak) Because once you find the count of individual character you only have to take difference of minimum and maximum in that lot . so in the whole string string : {\"i\":4,\"c\":3,\"e\":1,\"x\":1,\"a\":1,\"h\":1,\"k\":1,\"n\":1,\"b\":1,\"w\":2,\"u\":1,\"g\":1} Max count is 4 which is of \\'i\\' and least count is any single character so difference is 3 ...."
                    },
                    {
                        "username": "julkar9",
                        "content": "4 i\\'s and one b or k or any single character with single occurrence"
                    },
                    {
                        "username": "pkorchak",
                        "content": "My solution also fails on that test and I can\\'t understand why that shouldn\\'t be 2..."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Summer and Hard problems ruined my strike"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "I tried brute force with `26 N^2` complexity, it passes 123/138 testcases. Am I missing something?"
                    },
                    {
                        "username": "hero080",
                        "content": "I did $26 + N^2$ and it still got TLE.\\n\\nWe can do much better though:\\n$26 N$ (better than the editorial solution $26^2 N$)\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "Stacks_And_Queues",
                        "content": "![image](https://assets.leetcode.com/users/images/3664cc0f-4c40-4a3f-995c-dbc7d12fa933_1652544354.9046297.png)\\n\\n\\nidk what was going on here... but as you can see my answer below \"Run Code Status: Finished\" matches the expected answer above... But for some reason it kept saying my output was 3 and not 1.\\n\\nMaybe it\\'s too early in the morning and it\\'s something really obvious.. But am I missing something here?"
                    },
                    {
                        "username": "Limon020",
                        "content": "good question, I learned Kadane\\'s algo"
                    },
                    {
                        "username": "manas150902",
                        "content": "Please correct me\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        unordered_set<char> st(s.begin(),s.end());\\n        int ans=0;\\n        for(auto a: st)\\n        {\\n            for(auto b: st)\\n            {\\n                if(a==b)\\n                continue;\\n                int f1=0,f2=0;\\n                for(int i=0;i<s.size();i++)\\n                {\\n                    if(s[i]==a)\\n                    f1++;\\n                    else if(s[i]==b)\\n                    f2++;\\n\\n                    if(f2==0)\\n                    continue;\\n\\n                    if(f1-f2==-1)\\n                    {\\n                        f1=0;\\n                        f2=0;\\n                        continue;\\n                    }\\n                    ans=max(ans,f1-f2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nInput\\ns =\\n\"lripaa\"\\nOutput\\n0\\nExpected\\n1\\n"
                    },
                    {
                        "username": "reassurance",
                        "content": "Her: Breakup hurts the most\n\nHim:  (shows her this) **TLE 122/138**\n\nHer: I am wrong\n\nPS: RIP 2 pointer approach"
                    },
                    {
                        "username": "WarGames",
                        "content": "What does \\u201CTime Limit Exceeded\\u201D mean? I don\\'t see timing constraints in the requirements. "
                    },
                    {
                        "username": "tifv",
                        "content": "[@WarGames](/WarGames) Time constraints can usually be inferred from input constraints. For example, in this problem the length in the input is $n = 10^{4}$, which means that solutions with $O(n)$ and $O(n \\\\cdot \\\\log(n))$ asymptotic time complexity would likely be accepted, and solutions with $O(n^2)$ complexity and higher are unlikely to pass."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@tifv](/tifv) nice to know, but to know it before starting coding would result in a different approach, though this did just waste time."
                    },
                    {
                        "username": "tifv",
                        "content": "Time is always a constraint, though it is never listed explicitly (and, possibly, is different for different languages). \\u201CTime Limit Exceeded\\u201D means you have to find a more efficient solution."
                    },
                    {
                        "username": "KieuA7702",
                        "content": "Anyone get  the right answer for this case?\\n\"fsoxzotgvxguvudpgntfujuvrkgkfwqalayujcbryotoyslfwhhwfxgwrbitncjpvpowejsyboaeqhpvgkjxijisnrjbawpedhrlablukuhzxhlrclmbbszoloeqqfhguocowsadhxkkvxxupwxyvqdqcagxldmzsuvjqjedteoizobbmtlnzmllaxbysymnhactdqyhipvazsqpnwulnsguchspaycvtbzdnhzrjjlbjmtvhtrcqcutthlyjjrhyjilayiqsjusojpypnuspxfxvcffpiebmlfdoqebsiqtflsddoxmcpooqkkjkgsgenvpwszzhqbqbaognwgdswtmiishmwgiknqfixlzqgbcsmfbfupbzvzbxexrdcoilspuae\""
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I\\'m getting same answer 13 but correct answer is 14 have you solved it?"
                    },
                    {
                        "username": "WarGames",
                        "content": "Yes, i get 14, and confirmed to be correct."
                    },
                    {
                        "username": "vogiaan1904",
                        "content": "the string can include numbers and symbols like  / ! @ & %,.... right ?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It says \\u201C`s` consists of lowercase English letters\\u201D right in the constraints."
                    }
                ]
            },
            {
                "id": 1969547,
                "content": [
                    {
                        "username": "mlychndn",
                        "content": "On which case It will return 3 \"icexiahccknibwuwgi\", Any one can help"
                    },
                    {
                        "username": "pkorchak",
                        "content": "got it, I missed that we can choose any chars pair in the selected substring"
                    },
                    {
                        "username": "groverception",
                        "content": "[@pkorchak](/pkorchak) Because once you find the count of individual character you only have to take difference of minimum and maximum in that lot . so in the whole string string : {\"i\":4,\"c\":3,\"e\":1,\"x\":1,\"a\":1,\"h\":1,\"k\":1,\"n\":1,\"b\":1,\"w\":2,\"u\":1,\"g\":1} Max count is 4 which is of \\'i\\' and least count is any single character so difference is 3 ...."
                    },
                    {
                        "username": "julkar9",
                        "content": "4 i\\'s and one b or k or any single character with single occurrence"
                    },
                    {
                        "username": "pkorchak",
                        "content": "My solution also fails on that test and I can\\'t understand why that shouldn\\'t be 2..."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Summer and Hard problems ruined my strike"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "I tried brute force with `26 N^2` complexity, it passes 123/138 testcases. Am I missing something?"
                    },
                    {
                        "username": "hero080",
                        "content": "I did $26 + N^2$ and it still got TLE.\\n\\nWe can do much better though:\\n$26 N$ (better than the editorial solution $26^2 N$)\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "Stacks_And_Queues",
                        "content": "![image](https://assets.leetcode.com/users/images/3664cc0f-4c40-4a3f-995c-dbc7d12fa933_1652544354.9046297.png)\\n\\n\\nidk what was going on here... but as you can see my answer below \"Run Code Status: Finished\" matches the expected answer above... But for some reason it kept saying my output was 3 and not 1.\\n\\nMaybe it\\'s too early in the morning and it\\'s something really obvious.. But am I missing something here?"
                    },
                    {
                        "username": "Limon020",
                        "content": "good question, I learned Kadane\\'s algo"
                    },
                    {
                        "username": "manas150902",
                        "content": "Please correct me\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        unordered_set<char> st(s.begin(),s.end());\\n        int ans=0;\\n        for(auto a: st)\\n        {\\n            for(auto b: st)\\n            {\\n                if(a==b)\\n                continue;\\n                int f1=0,f2=0;\\n                for(int i=0;i<s.size();i++)\\n                {\\n                    if(s[i]==a)\\n                    f1++;\\n                    else if(s[i]==b)\\n                    f2++;\\n\\n                    if(f2==0)\\n                    continue;\\n\\n                    if(f1-f2==-1)\\n                    {\\n                        f1=0;\\n                        f2=0;\\n                        continue;\\n                    }\\n                    ans=max(ans,f1-f2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nInput\\ns =\\n\"lripaa\"\\nOutput\\n0\\nExpected\\n1\\n"
                    },
                    {
                        "username": "reassurance",
                        "content": "Her: Breakup hurts the most\n\nHim:  (shows her this) **TLE 122/138**\n\nHer: I am wrong\n\nPS: RIP 2 pointer approach"
                    },
                    {
                        "username": "WarGames",
                        "content": "What does \\u201CTime Limit Exceeded\\u201D mean? I don\\'t see timing constraints in the requirements. "
                    },
                    {
                        "username": "tifv",
                        "content": "[@WarGames](/WarGames) Time constraints can usually be inferred from input constraints. For example, in this problem the length in the input is $n = 10^{4}$, which means that solutions with $O(n)$ and $O(n \\\\cdot \\\\log(n))$ asymptotic time complexity would likely be accepted, and solutions with $O(n^2)$ complexity and higher are unlikely to pass."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@tifv](/tifv) nice to know, but to know it before starting coding would result in a different approach, though this did just waste time."
                    },
                    {
                        "username": "tifv",
                        "content": "Time is always a constraint, though it is never listed explicitly (and, possibly, is different for different languages). \\u201CTime Limit Exceeded\\u201D means you have to find a more efficient solution."
                    },
                    {
                        "username": "KieuA7702",
                        "content": "Anyone get  the right answer for this case?\\n\"fsoxzotgvxguvudpgntfujuvrkgkfwqalayujcbryotoyslfwhhwfxgwrbitncjpvpowejsyboaeqhpvgkjxijisnrjbawpedhrlablukuhzxhlrclmbbszoloeqqfhguocowsadhxkkvxxupwxyvqdqcagxldmzsuvjqjedteoizobbmtlnzmllaxbysymnhactdqyhipvazsqpnwulnsguchspaycvtbzdnhzrjjlbjmtvhtrcqcutthlyjjrhyjilayiqsjusojpypnuspxfxvcffpiebmlfdoqebsiqtflsddoxmcpooqkkjkgsgenvpwszzhqbqbaognwgdswtmiishmwgiknqfixlzqgbcsmfbfupbzvzbxexrdcoilspuae\""
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I\\'m getting same answer 13 but correct answer is 14 have you solved it?"
                    },
                    {
                        "username": "WarGames",
                        "content": "Yes, i get 14, and confirmed to be correct."
                    },
                    {
                        "username": "vogiaan1904",
                        "content": "the string can include numbers and symbols like  / ! @ & %,.... right ?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It says \\u201C`s` consists of lowercase English letters\\u201D right in the constraints."
                    }
                ]
            },
            {
                "id": 1965109,
                "content": [
                    {
                        "username": "mlychndn",
                        "content": "On which case It will return 3 \"icexiahccknibwuwgi\", Any one can help"
                    },
                    {
                        "username": "pkorchak",
                        "content": "got it, I missed that we can choose any chars pair in the selected substring"
                    },
                    {
                        "username": "groverception",
                        "content": "[@pkorchak](/pkorchak) Because once you find the count of individual character you only have to take difference of minimum and maximum in that lot . so in the whole string string : {\"i\":4,\"c\":3,\"e\":1,\"x\":1,\"a\":1,\"h\":1,\"k\":1,\"n\":1,\"b\":1,\"w\":2,\"u\":1,\"g\":1} Max count is 4 which is of \\'i\\' and least count is any single character so difference is 3 ...."
                    },
                    {
                        "username": "julkar9",
                        "content": "4 i\\'s and one b or k or any single character with single occurrence"
                    },
                    {
                        "username": "pkorchak",
                        "content": "My solution also fails on that test and I can\\'t understand why that shouldn\\'t be 2..."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Summer and Hard problems ruined my strike"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "I tried brute force with `26 N^2` complexity, it passes 123/138 testcases. Am I missing something?"
                    },
                    {
                        "username": "hero080",
                        "content": "I did $26 + N^2$ and it still got TLE.\\n\\nWe can do much better though:\\n$26 N$ (better than the editorial solution $26^2 N$)\\nhttps://leetcode.com/problems/substring-with-largest-variance/solutions/3738776/beat-100-on-k-most-optimal-solution-k-times-faster/"
                    },
                    {
                        "username": "Stacks_And_Queues",
                        "content": "![image](https://assets.leetcode.com/users/images/3664cc0f-4c40-4a3f-995c-dbc7d12fa933_1652544354.9046297.png)\\n\\n\\nidk what was going on here... but as you can see my answer below \"Run Code Status: Finished\" matches the expected answer above... But for some reason it kept saying my output was 3 and not 1.\\n\\nMaybe it\\'s too early in the morning and it\\'s something really obvious.. But am I missing something here?"
                    },
                    {
                        "username": "Limon020",
                        "content": "good question, I learned Kadane\\'s algo"
                    },
                    {
                        "username": "manas150902",
                        "content": "Please correct me\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        unordered_set<char> st(s.begin(),s.end());\\n        int ans=0;\\n        for(auto a: st)\\n        {\\n            for(auto b: st)\\n            {\\n                if(a==b)\\n                continue;\\n                int f1=0,f2=0;\\n                for(int i=0;i<s.size();i++)\\n                {\\n                    if(s[i]==a)\\n                    f1++;\\n                    else if(s[i]==b)\\n                    f2++;\\n\\n                    if(f2==0)\\n                    continue;\\n\\n                    if(f1-f2==-1)\\n                    {\\n                        f1=0;\\n                        f2=0;\\n                        continue;\\n                    }\\n                    ans=max(ans,f1-f2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nInput\\ns =\\n\"lripaa\"\\nOutput\\n0\\nExpected\\n1\\n"
                    },
                    {
                        "username": "reassurance",
                        "content": "Her: Breakup hurts the most\n\nHim:  (shows her this) **TLE 122/138**\n\nHer: I am wrong\n\nPS: RIP 2 pointer approach"
                    },
                    {
                        "username": "WarGames",
                        "content": "What does \\u201CTime Limit Exceeded\\u201D mean? I don\\'t see timing constraints in the requirements. "
                    },
                    {
                        "username": "tifv",
                        "content": "[@WarGames](/WarGames) Time constraints can usually be inferred from input constraints. For example, in this problem the length in the input is $n = 10^{4}$, which means that solutions with $O(n)$ and $O(n \\\\cdot \\\\log(n))$ asymptotic time complexity would likely be accepted, and solutions with $O(n^2)$ complexity and higher are unlikely to pass."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@tifv](/tifv) nice to know, but to know it before starting coding would result in a different approach, though this did just waste time."
                    },
                    {
                        "username": "tifv",
                        "content": "Time is always a constraint, though it is never listed explicitly (and, possibly, is different for different languages). \\u201CTime Limit Exceeded\\u201D means you have to find a more efficient solution."
                    },
                    {
                        "username": "KieuA7702",
                        "content": "Anyone get  the right answer for this case?\\n\"fsoxzotgvxguvudpgntfujuvrkgkfwqalayujcbryotoyslfwhhwfxgwrbitncjpvpowejsyboaeqhpvgkjxijisnrjbawpedhrlablukuhzxhlrclmbbszoloeqqfhguocowsadhxkkvxxupwxyvqdqcagxldmzsuvjqjedteoizobbmtlnzmllaxbysymnhactdqyhipvazsqpnwulnsguchspaycvtbzdnhzrjjlbjmtvhtrcqcutthlyjjrhyjilayiqsjusojpypnuspxfxvcffpiebmlfdoqebsiqtflsddoxmcpooqkkjkgsgenvpwszzhqbqbaognwgdswtmiishmwgiknqfixlzqgbcsmfbfupbzvzbxexrdcoilspuae\""
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I\\'m getting same answer 13 but correct answer is 14 have you solved it?"
                    },
                    {
                        "username": "WarGames",
                        "content": "Yes, i get 14, and confirmed to be correct."
                    },
                    {
                        "username": "vogiaan1904",
                        "content": "the string can include numbers and symbols like  / ! @ & %,.... right ?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It says \\u201C`s` consists of lowercase English letters\\u201D right in the constraints."
                    }
                ]
            },
            {
                "id": 1963630,
                "content": [
                    {
                        "username": "rcomesan",
                        "content": "Why is \"abba\" expected solution 1 instead of 2? Aren\\'t we allowed to take \"bb\" substring here? I\\'m a bit confused since the description says that the 2 characters \"may or may not be the same\"."
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@tifv](/tifv) Oh you\\'re right. Thank you!"
                    },
                    {
                        "username": "tifv",
                        "content": "The \"bb\" substring has the maximum number of occurrences equal 2 (for letter \"b\") and the minimum number of occurrences equal 2 (also for letter \"b\"). The letter \"a\" is not in the substring, so it does not count (it is not a character \\u201Cpresent in the string\\u201D, as mentioned in the problem statement).\\n\\nThe note that characters \\u201Cmay or may not be the same\\u201D refers to this specific case, when there is only one distinct character in the string. This implies that the same character may be counted for the minimum and the maximum number of occurrences. This is only relevant for strings that have only one distinct character; you can ignore this sentence for all other cases."
                    },
                    {
                        "username": "feng3245",
                        "content": "Am getting TLE and the input was s = \n??? What is going on here?\non 138/138 non the less really what's going on here"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@tifv](/tifv) Did some thinking it\\'s takes 25x times as a more optimal solution but come on it\\'s by a const..."
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, a solution can pass all the testcases but be found to exceed the time limit after the fact."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I dont get testcases, when question is hard then leetcode should emphasize on test case explanations"
                    },
                    {
                        "username": "i_vaibhavraheja",
                        "content": "121 test cases could be passed with brute force solution O(n*n*26)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Too Hard for me!"
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "hints are really good this time"
                    },
                    {
                        "username": "user7478F",
                        "content": "Basically, we have to find the maximum variance between two characters in a substring, where a string could consist of any number of characters of english alphabets,\\nso we can two variable suppose(x,y) and in a string consisting different characters, like aabsdbbabaaaabdbddd, when we compute maximum variance for (x,y).. we can calculate for a,d considering aadaaaaad as substring. and the variance would be 5 here.. similarly we have to calculate for all possibilites"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Brute Force O(N^3) passes 117/138 tests :D"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "The task says `Note the two characters may or may not be the same.`. \\nCan I see an example with the variance for the same characters? I think only different characters are considered. "
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s correct, the current approach only considers the case where the two characters are different. If we want to account for the possibility of the two characters being the same, we need to slightly modify the approach.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yeah, that sentence makes no sense, just ignore it. I think they mean that \\'aaaaa\\' is valid and has output 0. "
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "Again hard questionss...\\uD83D\\uDE11"
                    }
                ]
            },
            {
                "id": 1963601,
                "content": [
                    {
                        "username": "rcomesan",
                        "content": "Why is \"abba\" expected solution 1 instead of 2? Aren\\'t we allowed to take \"bb\" substring here? I\\'m a bit confused since the description says that the 2 characters \"may or may not be the same\"."
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@tifv](/tifv) Oh you\\'re right. Thank you!"
                    },
                    {
                        "username": "tifv",
                        "content": "The \"bb\" substring has the maximum number of occurrences equal 2 (for letter \"b\") and the minimum number of occurrences equal 2 (also for letter \"b\"). The letter \"a\" is not in the substring, so it does not count (it is not a character \\u201Cpresent in the string\\u201D, as mentioned in the problem statement).\\n\\nThe note that characters \\u201Cmay or may not be the same\\u201D refers to this specific case, when there is only one distinct character in the string. This implies that the same character may be counted for the minimum and the maximum number of occurrences. This is only relevant for strings that have only one distinct character; you can ignore this sentence for all other cases."
                    },
                    {
                        "username": "feng3245",
                        "content": "Am getting TLE and the input was s = \n??? What is going on here?\non 138/138 non the less really what's going on here"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@tifv](/tifv) Did some thinking it\\'s takes 25x times as a more optimal solution but come on it\\'s by a const..."
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, a solution can pass all the testcases but be found to exceed the time limit after the fact."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I dont get testcases, when question is hard then leetcode should emphasize on test case explanations"
                    },
                    {
                        "username": "i_vaibhavraheja",
                        "content": "121 test cases could be passed with brute force solution O(n*n*26)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Too Hard for me!"
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "hints are really good this time"
                    },
                    {
                        "username": "user7478F",
                        "content": "Basically, we have to find the maximum variance between two characters in a substring, where a string could consist of any number of characters of english alphabets,\\nso we can two variable suppose(x,y) and in a string consisting different characters, like aabsdbbabaaaabdbddd, when we compute maximum variance for (x,y).. we can calculate for a,d considering aadaaaaad as substring. and the variance would be 5 here.. similarly we have to calculate for all possibilites"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Brute Force O(N^3) passes 117/138 tests :D"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "The task says `Note the two characters may or may not be the same.`. \\nCan I see an example with the variance for the same characters? I think only different characters are considered. "
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s correct, the current approach only considers the case where the two characters are different. If we want to account for the possibility of the two characters being the same, we need to slightly modify the approach.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yeah, that sentence makes no sense, just ignore it. I think they mean that \\'aaaaa\\' is valid and has output 0. "
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "Again hard questionss...\\uD83D\\uDE11"
                    }
                ]
            },
            {
                "id": 1963444,
                "content": [
                    {
                        "username": "rcomesan",
                        "content": "Why is \"abba\" expected solution 1 instead of 2? Aren\\'t we allowed to take \"bb\" substring here? I\\'m a bit confused since the description says that the 2 characters \"may or may not be the same\"."
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@tifv](/tifv) Oh you\\'re right. Thank you!"
                    },
                    {
                        "username": "tifv",
                        "content": "The \"bb\" substring has the maximum number of occurrences equal 2 (for letter \"b\") and the minimum number of occurrences equal 2 (also for letter \"b\"). The letter \"a\" is not in the substring, so it does not count (it is not a character \\u201Cpresent in the string\\u201D, as mentioned in the problem statement).\\n\\nThe note that characters \\u201Cmay or may not be the same\\u201D refers to this specific case, when there is only one distinct character in the string. This implies that the same character may be counted for the minimum and the maximum number of occurrences. This is only relevant for strings that have only one distinct character; you can ignore this sentence for all other cases."
                    },
                    {
                        "username": "feng3245",
                        "content": "Am getting TLE and the input was s = \n??? What is going on here?\non 138/138 non the less really what's going on here"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@tifv](/tifv) Did some thinking it\\'s takes 25x times as a more optimal solution but come on it\\'s by a const..."
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, a solution can pass all the testcases but be found to exceed the time limit after the fact."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I dont get testcases, when question is hard then leetcode should emphasize on test case explanations"
                    },
                    {
                        "username": "i_vaibhavraheja",
                        "content": "121 test cases could be passed with brute force solution O(n*n*26)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Too Hard for me!"
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "hints are really good this time"
                    },
                    {
                        "username": "user7478F",
                        "content": "Basically, we have to find the maximum variance between two characters in a substring, where a string could consist of any number of characters of english alphabets,\\nso we can two variable suppose(x,y) and in a string consisting different characters, like aabsdbbabaaaabdbddd, when we compute maximum variance for (x,y).. we can calculate for a,d considering aadaaaaad as substring. and the variance would be 5 here.. similarly we have to calculate for all possibilites"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Brute Force O(N^3) passes 117/138 tests :D"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "The task says `Note the two characters may or may not be the same.`. \\nCan I see an example with the variance for the same characters? I think only different characters are considered. "
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s correct, the current approach only considers the case where the two characters are different. If we want to account for the possibility of the two characters being the same, we need to slightly modify the approach.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yeah, that sentence makes no sense, just ignore it. I think they mean that \\'aaaaa\\' is valid and has output 0. "
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "Again hard questionss...\\uD83D\\uDE11"
                    }
                ]
            },
            {
                "id": 1963385,
                "content": [
                    {
                        "username": "rcomesan",
                        "content": "Why is \"abba\" expected solution 1 instead of 2? Aren\\'t we allowed to take \"bb\" substring here? I\\'m a bit confused since the description says that the 2 characters \"may or may not be the same\"."
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@tifv](/tifv) Oh you\\'re right. Thank you!"
                    },
                    {
                        "username": "tifv",
                        "content": "The \"bb\" substring has the maximum number of occurrences equal 2 (for letter \"b\") and the minimum number of occurrences equal 2 (also for letter \"b\"). The letter \"a\" is not in the substring, so it does not count (it is not a character \\u201Cpresent in the string\\u201D, as mentioned in the problem statement).\\n\\nThe note that characters \\u201Cmay or may not be the same\\u201D refers to this specific case, when there is only one distinct character in the string. This implies that the same character may be counted for the minimum and the maximum number of occurrences. This is only relevant for strings that have only one distinct character; you can ignore this sentence for all other cases."
                    },
                    {
                        "username": "feng3245",
                        "content": "Am getting TLE and the input was s = \n??? What is going on here?\non 138/138 non the less really what's going on here"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@tifv](/tifv) Did some thinking it\\'s takes 25x times as a more optimal solution but come on it\\'s by a const..."
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, a solution can pass all the testcases but be found to exceed the time limit after the fact."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I dont get testcases, when question is hard then leetcode should emphasize on test case explanations"
                    },
                    {
                        "username": "i_vaibhavraheja",
                        "content": "121 test cases could be passed with brute force solution O(n*n*26)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Too Hard for me!"
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "hints are really good this time"
                    },
                    {
                        "username": "user7478F",
                        "content": "Basically, we have to find the maximum variance between two characters in a substring, where a string could consist of any number of characters of english alphabets,\\nso we can two variable suppose(x,y) and in a string consisting different characters, like aabsdbbabaaaabdbddd, when we compute maximum variance for (x,y).. we can calculate for a,d considering aadaaaaad as substring. and the variance would be 5 here.. similarly we have to calculate for all possibilites"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Brute Force O(N^3) passes 117/138 tests :D"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "The task says `Note the two characters may or may not be the same.`. \\nCan I see an example with the variance for the same characters? I think only different characters are considered. "
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s correct, the current approach only considers the case where the two characters are different. If we want to account for the possibility of the two characters being the same, we need to slightly modify the approach.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yeah, that sentence makes no sense, just ignore it. I think they mean that \\'aaaaa\\' is valid and has output 0. "
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "Again hard questionss...\\uD83D\\uDE11"
                    }
                ]
            },
            {
                "id": 1963359,
                "content": [
                    {
                        "username": "rcomesan",
                        "content": "Why is \"abba\" expected solution 1 instead of 2? Aren\\'t we allowed to take \"bb\" substring here? I\\'m a bit confused since the description says that the 2 characters \"may or may not be the same\"."
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@tifv](/tifv) Oh you\\'re right. Thank you!"
                    },
                    {
                        "username": "tifv",
                        "content": "The \"bb\" substring has the maximum number of occurrences equal 2 (for letter \"b\") and the minimum number of occurrences equal 2 (also for letter \"b\"). The letter \"a\" is not in the substring, so it does not count (it is not a character \\u201Cpresent in the string\\u201D, as mentioned in the problem statement).\\n\\nThe note that characters \\u201Cmay or may not be the same\\u201D refers to this specific case, when there is only one distinct character in the string. This implies that the same character may be counted for the minimum and the maximum number of occurrences. This is only relevant for strings that have only one distinct character; you can ignore this sentence for all other cases."
                    },
                    {
                        "username": "feng3245",
                        "content": "Am getting TLE and the input was s = \n??? What is going on here?\non 138/138 non the less really what's going on here"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@tifv](/tifv) Did some thinking it\\'s takes 25x times as a more optimal solution but come on it\\'s by a const..."
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, a solution can pass all the testcases but be found to exceed the time limit after the fact."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I dont get testcases, when question is hard then leetcode should emphasize on test case explanations"
                    },
                    {
                        "username": "i_vaibhavraheja",
                        "content": "121 test cases could be passed with brute force solution O(n*n*26)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Too Hard for me!"
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "hints are really good this time"
                    },
                    {
                        "username": "user7478F",
                        "content": "Basically, we have to find the maximum variance between two characters in a substring, where a string could consist of any number of characters of english alphabets,\\nso we can two variable suppose(x,y) and in a string consisting different characters, like aabsdbbabaaaabdbddd, when we compute maximum variance for (x,y).. we can calculate for a,d considering aadaaaaad as substring. and the variance would be 5 here.. similarly we have to calculate for all possibilites"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Brute Force O(N^3) passes 117/138 tests :D"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "The task says `Note the two characters may or may not be the same.`. \\nCan I see an example with the variance for the same characters? I think only different characters are considered. "
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s correct, the current approach only considers the case where the two characters are different. If we want to account for the possibility of the two characters being the same, we need to slightly modify the approach.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yeah, that sentence makes no sense, just ignore it. I think they mean that \\'aaaaa\\' is valid and has output 0. "
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "Again hard questionss...\\uD83D\\uDE11"
                    }
                ]
            },
            {
                "id": 1963306,
                "content": [
                    {
                        "username": "rcomesan",
                        "content": "Why is \"abba\" expected solution 1 instead of 2? Aren\\'t we allowed to take \"bb\" substring here? I\\'m a bit confused since the description says that the 2 characters \"may or may not be the same\"."
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@tifv](/tifv) Oh you\\'re right. Thank you!"
                    },
                    {
                        "username": "tifv",
                        "content": "The \"bb\" substring has the maximum number of occurrences equal 2 (for letter \"b\") and the minimum number of occurrences equal 2 (also for letter \"b\"). The letter \"a\" is not in the substring, so it does not count (it is not a character \\u201Cpresent in the string\\u201D, as mentioned in the problem statement).\\n\\nThe note that characters \\u201Cmay or may not be the same\\u201D refers to this specific case, when there is only one distinct character in the string. This implies that the same character may be counted for the minimum and the maximum number of occurrences. This is only relevant for strings that have only one distinct character; you can ignore this sentence for all other cases."
                    },
                    {
                        "username": "feng3245",
                        "content": "Am getting TLE and the input was s = \n??? What is going on here?\non 138/138 non the less really what's going on here"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@tifv](/tifv) Did some thinking it\\'s takes 25x times as a more optimal solution but come on it\\'s by a const..."
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, a solution can pass all the testcases but be found to exceed the time limit after the fact."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I dont get testcases, when question is hard then leetcode should emphasize on test case explanations"
                    },
                    {
                        "username": "i_vaibhavraheja",
                        "content": "121 test cases could be passed with brute force solution O(n*n*26)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Too Hard for me!"
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "hints are really good this time"
                    },
                    {
                        "username": "user7478F",
                        "content": "Basically, we have to find the maximum variance between two characters in a substring, where a string could consist of any number of characters of english alphabets,\\nso we can two variable suppose(x,y) and in a string consisting different characters, like aabsdbbabaaaabdbddd, when we compute maximum variance for (x,y).. we can calculate for a,d considering aadaaaaad as substring. and the variance would be 5 here.. similarly we have to calculate for all possibilites"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Brute Force O(N^3) passes 117/138 tests :D"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "The task says `Note the two characters may or may not be the same.`. \\nCan I see an example with the variance for the same characters? I think only different characters are considered. "
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s correct, the current approach only considers the case where the two characters are different. If we want to account for the possibility of the two characters being the same, we need to slightly modify the approach.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yeah, that sentence makes no sense, just ignore it. I think they mean that \\'aaaaa\\' is valid and has output 0. "
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "Again hard questionss...\\uD83D\\uDE11"
                    }
                ]
            },
            {
                "id": 1963232,
                "content": [
                    {
                        "username": "rcomesan",
                        "content": "Why is \"abba\" expected solution 1 instead of 2? Aren\\'t we allowed to take \"bb\" substring here? I\\'m a bit confused since the description says that the 2 characters \"may or may not be the same\"."
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@tifv](/tifv) Oh you\\'re right. Thank you!"
                    },
                    {
                        "username": "tifv",
                        "content": "The \"bb\" substring has the maximum number of occurrences equal 2 (for letter \"b\") and the minimum number of occurrences equal 2 (also for letter \"b\"). The letter \"a\" is not in the substring, so it does not count (it is not a character \\u201Cpresent in the string\\u201D, as mentioned in the problem statement).\\n\\nThe note that characters \\u201Cmay or may not be the same\\u201D refers to this specific case, when there is only one distinct character in the string. This implies that the same character may be counted for the minimum and the maximum number of occurrences. This is only relevant for strings that have only one distinct character; you can ignore this sentence for all other cases."
                    },
                    {
                        "username": "feng3245",
                        "content": "Am getting TLE and the input was s = \n??? What is going on here?\non 138/138 non the less really what's going on here"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@tifv](/tifv) Did some thinking it\\'s takes 25x times as a more optimal solution but come on it\\'s by a const..."
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, a solution can pass all the testcases but be found to exceed the time limit after the fact."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I dont get testcases, when question is hard then leetcode should emphasize on test case explanations"
                    },
                    {
                        "username": "i_vaibhavraheja",
                        "content": "121 test cases could be passed with brute force solution O(n*n*26)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Too Hard for me!"
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "hints are really good this time"
                    },
                    {
                        "username": "user7478F",
                        "content": "Basically, we have to find the maximum variance between two characters in a substring, where a string could consist of any number of characters of english alphabets,\\nso we can two variable suppose(x,y) and in a string consisting different characters, like aabsdbbabaaaabdbddd, when we compute maximum variance for (x,y).. we can calculate for a,d considering aadaaaaad as substring. and the variance would be 5 here.. similarly we have to calculate for all possibilites"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Brute Force O(N^3) passes 117/138 tests :D"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "The task says `Note the two characters may or may not be the same.`. \\nCan I see an example with the variance for the same characters? I think only different characters are considered. "
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s correct, the current approach only considers the case where the two characters are different. If we want to account for the possibility of the two characters being the same, we need to slightly modify the approach.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yeah, that sentence makes no sense, just ignore it. I think they mean that \\'aaaaa\\' is valid and has output 0. "
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "Again hard questionss...\\uD83D\\uDE11"
                    }
                ]
            },
            {
                "id": 1963188,
                "content": [
                    {
                        "username": "rcomesan",
                        "content": "Why is \"abba\" expected solution 1 instead of 2? Aren\\'t we allowed to take \"bb\" substring here? I\\'m a bit confused since the description says that the 2 characters \"may or may not be the same\"."
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@tifv](/tifv) Oh you\\'re right. Thank you!"
                    },
                    {
                        "username": "tifv",
                        "content": "The \"bb\" substring has the maximum number of occurrences equal 2 (for letter \"b\") and the minimum number of occurrences equal 2 (also for letter \"b\"). The letter \"a\" is not in the substring, so it does not count (it is not a character \\u201Cpresent in the string\\u201D, as mentioned in the problem statement).\\n\\nThe note that characters \\u201Cmay or may not be the same\\u201D refers to this specific case, when there is only one distinct character in the string. This implies that the same character may be counted for the minimum and the maximum number of occurrences. This is only relevant for strings that have only one distinct character; you can ignore this sentence for all other cases."
                    },
                    {
                        "username": "feng3245",
                        "content": "Am getting TLE and the input was s = \n??? What is going on here?\non 138/138 non the less really what's going on here"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@tifv](/tifv) Did some thinking it\\'s takes 25x times as a more optimal solution but come on it\\'s by a const..."
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, a solution can pass all the testcases but be found to exceed the time limit after the fact."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I dont get testcases, when question is hard then leetcode should emphasize on test case explanations"
                    },
                    {
                        "username": "i_vaibhavraheja",
                        "content": "121 test cases could be passed with brute force solution O(n*n*26)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Too Hard for me!"
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "hints are really good this time"
                    },
                    {
                        "username": "user7478F",
                        "content": "Basically, we have to find the maximum variance between two characters in a substring, where a string could consist of any number of characters of english alphabets,\\nso we can two variable suppose(x,y) and in a string consisting different characters, like aabsdbbabaaaabdbddd, when we compute maximum variance for (x,y).. we can calculate for a,d considering aadaaaaad as substring. and the variance would be 5 here.. similarly we have to calculate for all possibilites"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Brute Force O(N^3) passes 117/138 tests :D"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "The task says `Note the two characters may or may not be the same.`. \\nCan I see an example with the variance for the same characters? I think only different characters are considered. "
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s correct, the current approach only considers the case where the two characters are different. If we want to account for the possibility of the two characters being the same, we need to slightly modify the approach.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yeah, that sentence makes no sense, just ignore it. I think they mean that \\'aaaaa\\' is valid and has output 0. "
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "Again hard questionss...\\uD83D\\uDE11"
                    }
                ]
            },
            {
                "id": 1963165,
                "content": [
                    {
                        "username": "rcomesan",
                        "content": "Why is \"abba\" expected solution 1 instead of 2? Aren\\'t we allowed to take \"bb\" substring here? I\\'m a bit confused since the description says that the 2 characters \"may or may not be the same\"."
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@tifv](/tifv) Oh you\\'re right. Thank you!"
                    },
                    {
                        "username": "tifv",
                        "content": "The \"bb\" substring has the maximum number of occurrences equal 2 (for letter \"b\") and the minimum number of occurrences equal 2 (also for letter \"b\"). The letter \"a\" is not in the substring, so it does not count (it is not a character \\u201Cpresent in the string\\u201D, as mentioned in the problem statement).\\n\\nThe note that characters \\u201Cmay or may not be the same\\u201D refers to this specific case, when there is only one distinct character in the string. This implies that the same character may be counted for the minimum and the maximum number of occurrences. This is only relevant for strings that have only one distinct character; you can ignore this sentence for all other cases."
                    },
                    {
                        "username": "feng3245",
                        "content": "Am getting TLE and the input was s = \n??? What is going on here?\non 138/138 non the less really what's going on here"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@tifv](/tifv) Did some thinking it\\'s takes 25x times as a more optimal solution but come on it\\'s by a const..."
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, a solution can pass all the testcases but be found to exceed the time limit after the fact."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I dont get testcases, when question is hard then leetcode should emphasize on test case explanations"
                    },
                    {
                        "username": "i_vaibhavraheja",
                        "content": "121 test cases could be passed with brute force solution O(n*n*26)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Too Hard for me!"
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "hints are really good this time"
                    },
                    {
                        "username": "user7478F",
                        "content": "Basically, we have to find the maximum variance between two characters in a substring, where a string could consist of any number of characters of english alphabets,\\nso we can two variable suppose(x,y) and in a string consisting different characters, like aabsdbbabaaaabdbddd, when we compute maximum variance for (x,y).. we can calculate for a,d considering aadaaaaad as substring. and the variance would be 5 here.. similarly we have to calculate for all possibilites"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Brute Force O(N^3) passes 117/138 tests :D"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "The task says `Note the two characters may or may not be the same.`. \\nCan I see an example with the variance for the same characters? I think only different characters are considered. "
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s correct, the current approach only considers the case where the two characters are different. If we want to account for the possibility of the two characters being the same, we need to slightly modify the approach.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yeah, that sentence makes no sense, just ignore it. I think they mean that \\'aaaaa\\' is valid and has output 0. "
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "Again hard questionss...\\uD83D\\uDE11"
                    }
                ]
            },
            {
                "id": 1963135,
                "content": [
                    {
                        "username": "rcomesan",
                        "content": "Why is \"abba\" expected solution 1 instead of 2? Aren\\'t we allowed to take \"bb\" substring here? I\\'m a bit confused since the description says that the 2 characters \"may or may not be the same\"."
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@tifv](/tifv) Oh you\\'re right. Thank you!"
                    },
                    {
                        "username": "tifv",
                        "content": "The \"bb\" substring has the maximum number of occurrences equal 2 (for letter \"b\") and the minimum number of occurrences equal 2 (also for letter \"b\"). The letter \"a\" is not in the substring, so it does not count (it is not a character \\u201Cpresent in the string\\u201D, as mentioned in the problem statement).\\n\\nThe note that characters \\u201Cmay or may not be the same\\u201D refers to this specific case, when there is only one distinct character in the string. This implies that the same character may be counted for the minimum and the maximum number of occurrences. This is only relevant for strings that have only one distinct character; you can ignore this sentence for all other cases."
                    },
                    {
                        "username": "feng3245",
                        "content": "Am getting TLE and the input was s = \n??? What is going on here?\non 138/138 non the less really what's going on here"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@tifv](/tifv) Did some thinking it\\'s takes 25x times as a more optimal solution but come on it\\'s by a const..."
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, a solution can pass all the testcases but be found to exceed the time limit after the fact."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I dont get testcases, when question is hard then leetcode should emphasize on test case explanations"
                    },
                    {
                        "username": "i_vaibhavraheja",
                        "content": "121 test cases could be passed with brute force solution O(n*n*26)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Too Hard for me!"
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "hints are really good this time"
                    },
                    {
                        "username": "user7478F",
                        "content": "Basically, we have to find the maximum variance between two characters in a substring, where a string could consist of any number of characters of english alphabets,\\nso we can two variable suppose(x,y) and in a string consisting different characters, like aabsdbbabaaaabdbddd, when we compute maximum variance for (x,y).. we can calculate for a,d considering aadaaaaad as substring. and the variance would be 5 here.. similarly we have to calculate for all possibilites"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Brute Force O(N^3) passes 117/138 tests :D"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "The task says `Note the two characters may or may not be the same.`. \\nCan I see an example with the variance for the same characters? I think only different characters are considered. "
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s correct, the current approach only considers the case where the two characters are different. If we want to account for the possibility of the two characters being the same, we need to slightly modify the approach.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yeah, that sentence makes no sense, just ignore it. I think they mean that \\'aaaaa\\' is valid and has output 0. "
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "Again hard questionss...\\uD83D\\uDE11"
                    }
                ]
            },
            {
                "id": 1963094,
                "content": [
                    {
                        "username": "Ashish_4k",
                        "content": "\"aaaabbbcaaa\" can anyone explain how in this question aaaacaaa is a substring how cuz expected o/p is 6 for this"
                    },
                    {
                        "username": "peihao61",
                        "content": "[@Ashish_4k](/Ashish_4k) Please use substring \"bccccccc\" or \"cccccccb\". It will be the answer."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@sachin269](/sachin269) any idea for this \"aaaabbbcccccccbbaa\""
                    },
                    {
                        "username": "sachin269",
                        "content": "[@Ashish_4k](/Ashish_4k) now consider pair (c, a) the output is 6 is obviously  as 6 is the maximum variance"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kngvikashpatel](/kngvikashpatel) for this \"aaaabbbcccccccbbaa\" also it gives 6 as ans decription could have been more proper like first it asks for any two and in the 2nd line substring of any 2"
                    },
                    {
                        "username": "kngvikashpatel",
                        "content": "number of a - number of c (any two character not necessarily most frequent)"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "You are allowed to choose ANY TWO characters. In this case, if you choose all occurences of \\'a\\' - all occurences of \\'c\\', then only you get the best answer, you can just ignore \\'b\\' because it does not give is the largest differenec. So you need to check for all combination of lowercase letters"
                    },
                    {
                        "username": "sachin269",
                        "content": "ig the output iss for combination of pair(a, c) over whole string here substring as the whole complete string being considered"
                    },
                    {
                        "username": "peihao61",
                        "content": "Please take all string in this case.\\na: 7\\nb: 3\\nc: 1\\n\\nAns => 7 - 1 = 6"
                    },
                    {
                        "username": "arghyadas",
                        "content": "I\\'m able to write the recursive solution but unable to memoize\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Blazing_ROHIT",
                        "content": "same here "
                    },
                    {
                        "username": "sachin269",
                        "content": "Can you post the recursive solution please I want to know ..\\nThanks :)"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "DP (map) + DFS + BackTracking gives TLE. So sad.."
                    },
                    {
                        "username": "dgordiy",
                        "content": "After rereading the task and examples more and more times I\\'ve realised that the task is not clear at all."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is not Hard, this is Hard as ****!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Oh boy!"
                    },
                    {
                        "username": "sanskar01",
                        "content": "Not for me:("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "as I guessed, it is the HARD weekend"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Couldn\\'t solve it got TLE two times now. Finding it really hard bruh\\nI am getting the brute force one but cannot upsolve "
                    },
                    {
                        "username": "fizgenix",
                        "content": "hi can someone please help me with this code, gives error at 76th test case \\nclass Solution {\\npublic:\\n    int solve(string &sub){\\n        vector<int>freq(26,0);\\n        for(auto i:sub){\\n            freq[i-\\'a\\']++;\\n        }\\n        int x=*max_element(freq.begin(), freq.end());\\n        int y=x;\\n        for(auto i:freq){\\n            if(i>0 && i<x)\\n                y=i;\\n        }        \\n        return x-y;\\n    }\\n\\n    int largestVariance(string s) {\\n        //check for each substring\\n        int ans=0;\\n        int j=3;\\n        while(j<=s.size()){\\n            for(int i=0;i<=s.size()-j;i++){\\n                string sub= s.substr(i,j);\\n                cout<<sub<<\" \";\\n                int val= solve(sub);\\n                ans=max(val,ans);\\n            }\\n            j++;\\n            cout<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is trying to generate all substrings of the string and then checking for the variance in each of these substrings. This approach has a time complexity of O(n^4) where n is the length of the string. This is because generating all substrings takes O(n^3) and for each substring, you\\'re calculating the variance which takes O(n). Therefore, the total time complexity is O(n^4) which is why your solution is timing out for larger test cases.\\n\\nThe problem you\\'re trying to solve falls under the category of problems where we\\'re interested in the differences between frequency counts of different characters in substrings. For these types of problems, we typically need to use a different approach because generating all substrings would be too slow. One common approach is to use a prefix sum array or a frequency count array.\\n\\nIn this case, however, a more efficient approach would involve using two pointers to maintain the current substring and a frequency count array to keep track of the characters in the current substring. You can then update your pointers and your frequency count array as you iterate through the string and update your max variance as you go.\\n\\nHere is an idea on how you could modify your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i < 26; ++i) {\\n            for(int j = i; j < 26; ++j) {\\n                vector<int> freq(26, 0);\\n                int max_freq = 0, min_freq = n;\\n                for(char c: s) {\\n                    if(c-\\'a\\' != i && c-\\'a\\' != j) continue;\\n                    freq[c-\\'a\\']++;\\n                    max_freq = max(max_freq, freq[c-\\'a\\']);\\n                    if(c-\\'a\\' == i) min_freq = min(min_freq, freq[c-\\'a\\']);\\n                }\\n                ans = max(ans, max_freq - min_freq);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIn this code, for each pair of characters (i, j), you\\'re iterating through the string and updating your frequency count array. You\\'re also keeping track of the max frequency and the min frequency for each pair of characters and updating your answer as you go. This way, you\\'re only iterating through the string 26 * 26 = 676 times which is much more efficient than your current approach.\\n\\nPlease note that you also have to consider the case where the two characters are the same. So, if i == j, you shouldn\\'t update the min_freq in the loop, because it should always be 0 in this case. You might want to add a check for this inside your loop."
                    }
                ]
            },
            {
                "id": 1963069,
                "content": [
                    {
                        "username": "Ashish_4k",
                        "content": "\"aaaabbbcaaa\" can anyone explain how in this question aaaacaaa is a substring how cuz expected o/p is 6 for this"
                    },
                    {
                        "username": "peihao61",
                        "content": "[@Ashish_4k](/Ashish_4k) Please use substring \"bccccccc\" or \"cccccccb\". It will be the answer."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@sachin269](/sachin269) any idea for this \"aaaabbbcccccccbbaa\""
                    },
                    {
                        "username": "sachin269",
                        "content": "[@Ashish_4k](/Ashish_4k) now consider pair (c, a) the output is 6 is obviously  as 6 is the maximum variance"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kngvikashpatel](/kngvikashpatel) for this \"aaaabbbcccccccbbaa\" also it gives 6 as ans decription could have been more proper like first it asks for any two and in the 2nd line substring of any 2"
                    },
                    {
                        "username": "kngvikashpatel",
                        "content": "number of a - number of c (any two character not necessarily most frequent)"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "You are allowed to choose ANY TWO characters. In this case, if you choose all occurences of \\'a\\' - all occurences of \\'c\\', then only you get the best answer, you can just ignore \\'b\\' because it does not give is the largest differenec. So you need to check for all combination of lowercase letters"
                    },
                    {
                        "username": "sachin269",
                        "content": "ig the output iss for combination of pair(a, c) over whole string here substring as the whole complete string being considered"
                    },
                    {
                        "username": "peihao61",
                        "content": "Please take all string in this case.\\na: 7\\nb: 3\\nc: 1\\n\\nAns => 7 - 1 = 6"
                    },
                    {
                        "username": "arghyadas",
                        "content": "I\\'m able to write the recursive solution but unable to memoize\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Blazing_ROHIT",
                        "content": "same here "
                    },
                    {
                        "username": "sachin269",
                        "content": "Can you post the recursive solution please I want to know ..\\nThanks :)"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "DP (map) + DFS + BackTracking gives TLE. So sad.."
                    },
                    {
                        "username": "dgordiy",
                        "content": "After rereading the task and examples more and more times I\\'ve realised that the task is not clear at all."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is not Hard, this is Hard as ****!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Oh boy!"
                    },
                    {
                        "username": "sanskar01",
                        "content": "Not for me:("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "as I guessed, it is the HARD weekend"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Couldn\\'t solve it got TLE two times now. Finding it really hard bruh\\nI am getting the brute force one but cannot upsolve "
                    },
                    {
                        "username": "fizgenix",
                        "content": "hi can someone please help me with this code, gives error at 76th test case \\nclass Solution {\\npublic:\\n    int solve(string &sub){\\n        vector<int>freq(26,0);\\n        for(auto i:sub){\\n            freq[i-\\'a\\']++;\\n        }\\n        int x=*max_element(freq.begin(), freq.end());\\n        int y=x;\\n        for(auto i:freq){\\n            if(i>0 && i<x)\\n                y=i;\\n        }        \\n        return x-y;\\n    }\\n\\n    int largestVariance(string s) {\\n        //check for each substring\\n        int ans=0;\\n        int j=3;\\n        while(j<=s.size()){\\n            for(int i=0;i<=s.size()-j;i++){\\n                string sub= s.substr(i,j);\\n                cout<<sub<<\" \";\\n                int val= solve(sub);\\n                ans=max(val,ans);\\n            }\\n            j++;\\n            cout<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is trying to generate all substrings of the string and then checking for the variance in each of these substrings. This approach has a time complexity of O(n^4) where n is the length of the string. This is because generating all substrings takes O(n^3) and for each substring, you\\'re calculating the variance which takes O(n). Therefore, the total time complexity is O(n^4) which is why your solution is timing out for larger test cases.\\n\\nThe problem you\\'re trying to solve falls under the category of problems where we\\'re interested in the differences between frequency counts of different characters in substrings. For these types of problems, we typically need to use a different approach because generating all substrings would be too slow. One common approach is to use a prefix sum array or a frequency count array.\\n\\nIn this case, however, a more efficient approach would involve using two pointers to maintain the current substring and a frequency count array to keep track of the characters in the current substring. You can then update your pointers and your frequency count array as you iterate through the string and update your max variance as you go.\\n\\nHere is an idea on how you could modify your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i < 26; ++i) {\\n            for(int j = i; j < 26; ++j) {\\n                vector<int> freq(26, 0);\\n                int max_freq = 0, min_freq = n;\\n                for(char c: s) {\\n                    if(c-\\'a\\' != i && c-\\'a\\' != j) continue;\\n                    freq[c-\\'a\\']++;\\n                    max_freq = max(max_freq, freq[c-\\'a\\']);\\n                    if(c-\\'a\\' == i) min_freq = min(min_freq, freq[c-\\'a\\']);\\n                }\\n                ans = max(ans, max_freq - min_freq);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIn this code, for each pair of characters (i, j), you\\'re iterating through the string and updating your frequency count array. You\\'re also keeping track of the max frequency and the min frequency for each pair of characters and updating your answer as you go. This way, you\\'re only iterating through the string 26 * 26 = 676 times which is much more efficient than your current approach.\\n\\nPlease note that you also have to consider the case where the two characters are the same. So, if i == j, you shouldn\\'t update the min_freq in the loop, because it should always be 0 in this case. You might want to add a check for this inside your loop."
                    }
                ]
            },
            {
                "id": 1962945,
                "content": [
                    {
                        "username": "Ashish_4k",
                        "content": "\"aaaabbbcaaa\" can anyone explain how in this question aaaacaaa is a substring how cuz expected o/p is 6 for this"
                    },
                    {
                        "username": "peihao61",
                        "content": "[@Ashish_4k](/Ashish_4k) Please use substring \"bccccccc\" or \"cccccccb\". It will be the answer."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@sachin269](/sachin269) any idea for this \"aaaabbbcccccccbbaa\""
                    },
                    {
                        "username": "sachin269",
                        "content": "[@Ashish_4k](/Ashish_4k) now consider pair (c, a) the output is 6 is obviously  as 6 is the maximum variance"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kngvikashpatel](/kngvikashpatel) for this \"aaaabbbcccccccbbaa\" also it gives 6 as ans decription could have been more proper like first it asks for any two and in the 2nd line substring of any 2"
                    },
                    {
                        "username": "kngvikashpatel",
                        "content": "number of a - number of c (any two character not necessarily most frequent)"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "You are allowed to choose ANY TWO characters. In this case, if you choose all occurences of \\'a\\' - all occurences of \\'c\\', then only you get the best answer, you can just ignore \\'b\\' because it does not give is the largest differenec. So you need to check for all combination of lowercase letters"
                    },
                    {
                        "username": "sachin269",
                        "content": "ig the output iss for combination of pair(a, c) over whole string here substring as the whole complete string being considered"
                    },
                    {
                        "username": "peihao61",
                        "content": "Please take all string in this case.\\na: 7\\nb: 3\\nc: 1\\n\\nAns => 7 - 1 = 6"
                    },
                    {
                        "username": "arghyadas",
                        "content": "I\\'m able to write the recursive solution but unable to memoize\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Blazing_ROHIT",
                        "content": "same here "
                    },
                    {
                        "username": "sachin269",
                        "content": "Can you post the recursive solution please I want to know ..\\nThanks :)"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "DP (map) + DFS + BackTracking gives TLE. So sad.."
                    },
                    {
                        "username": "dgordiy",
                        "content": "After rereading the task and examples more and more times I\\'ve realised that the task is not clear at all."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is not Hard, this is Hard as ****!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Oh boy!"
                    },
                    {
                        "username": "sanskar01",
                        "content": "Not for me:("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "as I guessed, it is the HARD weekend"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Couldn\\'t solve it got TLE two times now. Finding it really hard bruh\\nI am getting the brute force one but cannot upsolve "
                    },
                    {
                        "username": "fizgenix",
                        "content": "hi can someone please help me with this code, gives error at 76th test case \\nclass Solution {\\npublic:\\n    int solve(string &sub){\\n        vector<int>freq(26,0);\\n        for(auto i:sub){\\n            freq[i-\\'a\\']++;\\n        }\\n        int x=*max_element(freq.begin(), freq.end());\\n        int y=x;\\n        for(auto i:freq){\\n            if(i>0 && i<x)\\n                y=i;\\n        }        \\n        return x-y;\\n    }\\n\\n    int largestVariance(string s) {\\n        //check for each substring\\n        int ans=0;\\n        int j=3;\\n        while(j<=s.size()){\\n            for(int i=0;i<=s.size()-j;i++){\\n                string sub= s.substr(i,j);\\n                cout<<sub<<\" \";\\n                int val= solve(sub);\\n                ans=max(val,ans);\\n            }\\n            j++;\\n            cout<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is trying to generate all substrings of the string and then checking for the variance in each of these substrings. This approach has a time complexity of O(n^4) where n is the length of the string. This is because generating all substrings takes O(n^3) and for each substring, you\\'re calculating the variance which takes O(n). Therefore, the total time complexity is O(n^4) which is why your solution is timing out for larger test cases.\\n\\nThe problem you\\'re trying to solve falls under the category of problems where we\\'re interested in the differences between frequency counts of different characters in substrings. For these types of problems, we typically need to use a different approach because generating all substrings would be too slow. One common approach is to use a prefix sum array or a frequency count array.\\n\\nIn this case, however, a more efficient approach would involve using two pointers to maintain the current substring and a frequency count array to keep track of the characters in the current substring. You can then update your pointers and your frequency count array as you iterate through the string and update your max variance as you go.\\n\\nHere is an idea on how you could modify your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i < 26; ++i) {\\n            for(int j = i; j < 26; ++j) {\\n                vector<int> freq(26, 0);\\n                int max_freq = 0, min_freq = n;\\n                for(char c: s) {\\n                    if(c-\\'a\\' != i && c-\\'a\\' != j) continue;\\n                    freq[c-\\'a\\']++;\\n                    max_freq = max(max_freq, freq[c-\\'a\\']);\\n                    if(c-\\'a\\' == i) min_freq = min(min_freq, freq[c-\\'a\\']);\\n                }\\n                ans = max(ans, max_freq - min_freq);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIn this code, for each pair of characters (i, j), you\\'re iterating through the string and updating your frequency count array. You\\'re also keeping track of the max frequency and the min frequency for each pair of characters and updating your answer as you go. This way, you\\'re only iterating through the string 26 * 26 = 676 times which is much more efficient than your current approach.\\n\\nPlease note that you also have to consider the case where the two characters are the same. So, if i == j, you shouldn\\'t update the min_freq in the loop, because it should always be 0 in this case. You might want to add a check for this inside your loop."
                    }
                ]
            },
            {
                "id": 1962873,
                "content": [
                    {
                        "username": "Ashish_4k",
                        "content": "\"aaaabbbcaaa\" can anyone explain how in this question aaaacaaa is a substring how cuz expected o/p is 6 for this"
                    },
                    {
                        "username": "peihao61",
                        "content": "[@Ashish_4k](/Ashish_4k) Please use substring \"bccccccc\" or \"cccccccb\". It will be the answer."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@sachin269](/sachin269) any idea for this \"aaaabbbcccccccbbaa\""
                    },
                    {
                        "username": "sachin269",
                        "content": "[@Ashish_4k](/Ashish_4k) now consider pair (c, a) the output is 6 is obviously  as 6 is the maximum variance"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kngvikashpatel](/kngvikashpatel) for this \"aaaabbbcccccccbbaa\" also it gives 6 as ans decription could have been more proper like first it asks for any two and in the 2nd line substring of any 2"
                    },
                    {
                        "username": "kngvikashpatel",
                        "content": "number of a - number of c (any two character not necessarily most frequent)"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "You are allowed to choose ANY TWO characters. In this case, if you choose all occurences of \\'a\\' - all occurences of \\'c\\', then only you get the best answer, you can just ignore \\'b\\' because it does not give is the largest differenec. So you need to check for all combination of lowercase letters"
                    },
                    {
                        "username": "sachin269",
                        "content": "ig the output iss for combination of pair(a, c) over whole string here substring as the whole complete string being considered"
                    },
                    {
                        "username": "peihao61",
                        "content": "Please take all string in this case.\\na: 7\\nb: 3\\nc: 1\\n\\nAns => 7 - 1 = 6"
                    },
                    {
                        "username": "arghyadas",
                        "content": "I\\'m able to write the recursive solution but unable to memoize\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Blazing_ROHIT",
                        "content": "same here "
                    },
                    {
                        "username": "sachin269",
                        "content": "Can you post the recursive solution please I want to know ..\\nThanks :)"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "DP (map) + DFS + BackTracking gives TLE. So sad.."
                    },
                    {
                        "username": "dgordiy",
                        "content": "After rereading the task and examples more and more times I\\'ve realised that the task is not clear at all."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is not Hard, this is Hard as ****!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Oh boy!"
                    },
                    {
                        "username": "sanskar01",
                        "content": "Not for me:("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "as I guessed, it is the HARD weekend"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Couldn\\'t solve it got TLE two times now. Finding it really hard bruh\\nI am getting the brute force one but cannot upsolve "
                    },
                    {
                        "username": "fizgenix",
                        "content": "hi can someone please help me with this code, gives error at 76th test case \\nclass Solution {\\npublic:\\n    int solve(string &sub){\\n        vector<int>freq(26,0);\\n        for(auto i:sub){\\n            freq[i-\\'a\\']++;\\n        }\\n        int x=*max_element(freq.begin(), freq.end());\\n        int y=x;\\n        for(auto i:freq){\\n            if(i>0 && i<x)\\n                y=i;\\n        }        \\n        return x-y;\\n    }\\n\\n    int largestVariance(string s) {\\n        //check for each substring\\n        int ans=0;\\n        int j=3;\\n        while(j<=s.size()){\\n            for(int i=0;i<=s.size()-j;i++){\\n                string sub= s.substr(i,j);\\n                cout<<sub<<\" \";\\n                int val= solve(sub);\\n                ans=max(val,ans);\\n            }\\n            j++;\\n            cout<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is trying to generate all substrings of the string and then checking for the variance in each of these substrings. This approach has a time complexity of O(n^4) where n is the length of the string. This is because generating all substrings takes O(n^3) and for each substring, you\\'re calculating the variance which takes O(n). Therefore, the total time complexity is O(n^4) which is why your solution is timing out for larger test cases.\\n\\nThe problem you\\'re trying to solve falls under the category of problems where we\\'re interested in the differences between frequency counts of different characters in substrings. For these types of problems, we typically need to use a different approach because generating all substrings would be too slow. One common approach is to use a prefix sum array or a frequency count array.\\n\\nIn this case, however, a more efficient approach would involve using two pointers to maintain the current substring and a frequency count array to keep track of the characters in the current substring. You can then update your pointers and your frequency count array as you iterate through the string and update your max variance as you go.\\n\\nHere is an idea on how you could modify your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i < 26; ++i) {\\n            for(int j = i; j < 26; ++j) {\\n                vector<int> freq(26, 0);\\n                int max_freq = 0, min_freq = n;\\n                for(char c: s) {\\n                    if(c-\\'a\\' != i && c-\\'a\\' != j) continue;\\n                    freq[c-\\'a\\']++;\\n                    max_freq = max(max_freq, freq[c-\\'a\\']);\\n                    if(c-\\'a\\' == i) min_freq = min(min_freq, freq[c-\\'a\\']);\\n                }\\n                ans = max(ans, max_freq - min_freq);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIn this code, for each pair of characters (i, j), you\\'re iterating through the string and updating your frequency count array. You\\'re also keeping track of the max frequency and the min frequency for each pair of characters and updating your answer as you go. This way, you\\'re only iterating through the string 26 * 26 = 676 times which is much more efficient than your current approach.\\n\\nPlease note that you also have to consider the case where the two characters are the same. So, if i == j, you shouldn\\'t update the min_freq in the loop, because it should always be 0 in this case. You might want to add a check for this inside your loop."
                    }
                ]
            },
            {
                "id": 1962864,
                "content": [
                    {
                        "username": "Ashish_4k",
                        "content": "\"aaaabbbcaaa\" can anyone explain how in this question aaaacaaa is a substring how cuz expected o/p is 6 for this"
                    },
                    {
                        "username": "peihao61",
                        "content": "[@Ashish_4k](/Ashish_4k) Please use substring \"bccccccc\" or \"cccccccb\". It will be the answer."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@sachin269](/sachin269) any idea for this \"aaaabbbcccccccbbaa\""
                    },
                    {
                        "username": "sachin269",
                        "content": "[@Ashish_4k](/Ashish_4k) now consider pair (c, a) the output is 6 is obviously  as 6 is the maximum variance"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kngvikashpatel](/kngvikashpatel) for this \"aaaabbbcccccccbbaa\" also it gives 6 as ans decription could have been more proper like first it asks for any two and in the 2nd line substring of any 2"
                    },
                    {
                        "username": "kngvikashpatel",
                        "content": "number of a - number of c (any two character not necessarily most frequent)"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "You are allowed to choose ANY TWO characters. In this case, if you choose all occurences of \\'a\\' - all occurences of \\'c\\', then only you get the best answer, you can just ignore \\'b\\' because it does not give is the largest differenec. So you need to check for all combination of lowercase letters"
                    },
                    {
                        "username": "sachin269",
                        "content": "ig the output iss for combination of pair(a, c) over whole string here substring as the whole complete string being considered"
                    },
                    {
                        "username": "peihao61",
                        "content": "Please take all string in this case.\\na: 7\\nb: 3\\nc: 1\\n\\nAns => 7 - 1 = 6"
                    },
                    {
                        "username": "arghyadas",
                        "content": "I\\'m able to write the recursive solution but unable to memoize\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Blazing_ROHIT",
                        "content": "same here "
                    },
                    {
                        "username": "sachin269",
                        "content": "Can you post the recursive solution please I want to know ..\\nThanks :)"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "DP (map) + DFS + BackTracking gives TLE. So sad.."
                    },
                    {
                        "username": "dgordiy",
                        "content": "After rereading the task and examples more and more times I\\'ve realised that the task is not clear at all."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is not Hard, this is Hard as ****!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Oh boy!"
                    },
                    {
                        "username": "sanskar01",
                        "content": "Not for me:("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "as I guessed, it is the HARD weekend"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Couldn\\'t solve it got TLE two times now. Finding it really hard bruh\\nI am getting the brute force one but cannot upsolve "
                    },
                    {
                        "username": "fizgenix",
                        "content": "hi can someone please help me with this code, gives error at 76th test case \\nclass Solution {\\npublic:\\n    int solve(string &sub){\\n        vector<int>freq(26,0);\\n        for(auto i:sub){\\n            freq[i-\\'a\\']++;\\n        }\\n        int x=*max_element(freq.begin(), freq.end());\\n        int y=x;\\n        for(auto i:freq){\\n            if(i>0 && i<x)\\n                y=i;\\n        }        \\n        return x-y;\\n    }\\n\\n    int largestVariance(string s) {\\n        //check for each substring\\n        int ans=0;\\n        int j=3;\\n        while(j<=s.size()){\\n            for(int i=0;i<=s.size()-j;i++){\\n                string sub= s.substr(i,j);\\n                cout<<sub<<\" \";\\n                int val= solve(sub);\\n                ans=max(val,ans);\\n            }\\n            j++;\\n            cout<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is trying to generate all substrings of the string and then checking for the variance in each of these substrings. This approach has a time complexity of O(n^4) where n is the length of the string. This is because generating all substrings takes O(n^3) and for each substring, you\\'re calculating the variance which takes O(n). Therefore, the total time complexity is O(n^4) which is why your solution is timing out for larger test cases.\\n\\nThe problem you\\'re trying to solve falls under the category of problems where we\\'re interested in the differences between frequency counts of different characters in substrings. For these types of problems, we typically need to use a different approach because generating all substrings would be too slow. One common approach is to use a prefix sum array or a frequency count array.\\n\\nIn this case, however, a more efficient approach would involve using two pointers to maintain the current substring and a frequency count array to keep track of the characters in the current substring. You can then update your pointers and your frequency count array as you iterate through the string and update your max variance as you go.\\n\\nHere is an idea on how you could modify your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i < 26; ++i) {\\n            for(int j = i; j < 26; ++j) {\\n                vector<int> freq(26, 0);\\n                int max_freq = 0, min_freq = n;\\n                for(char c: s) {\\n                    if(c-\\'a\\' != i && c-\\'a\\' != j) continue;\\n                    freq[c-\\'a\\']++;\\n                    max_freq = max(max_freq, freq[c-\\'a\\']);\\n                    if(c-\\'a\\' == i) min_freq = min(min_freq, freq[c-\\'a\\']);\\n                }\\n                ans = max(ans, max_freq - min_freq);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIn this code, for each pair of characters (i, j), you\\'re iterating through the string and updating your frequency count array. You\\'re also keeping track of the max frequency and the min frequency for each pair of characters and updating your answer as you go. This way, you\\'re only iterating through the string 26 * 26 = 676 times which is much more efficient than your current approach.\\n\\nPlease note that you also have to consider the case where the two characters are the same. So, if i == j, you shouldn\\'t update the min_freq in the loop, because it should always be 0 in this case. You might want to add a check for this inside your loop."
                    }
                ]
            },
            {
                "id": 1962863,
                "content": [
                    {
                        "username": "Ashish_4k",
                        "content": "\"aaaabbbcaaa\" can anyone explain how in this question aaaacaaa is a substring how cuz expected o/p is 6 for this"
                    },
                    {
                        "username": "peihao61",
                        "content": "[@Ashish_4k](/Ashish_4k) Please use substring \"bccccccc\" or \"cccccccb\". It will be the answer."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@sachin269](/sachin269) any idea for this \"aaaabbbcccccccbbaa\""
                    },
                    {
                        "username": "sachin269",
                        "content": "[@Ashish_4k](/Ashish_4k) now consider pair (c, a) the output is 6 is obviously  as 6 is the maximum variance"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kngvikashpatel](/kngvikashpatel) for this \"aaaabbbcccccccbbaa\" also it gives 6 as ans decription could have been more proper like first it asks for any two and in the 2nd line substring of any 2"
                    },
                    {
                        "username": "kngvikashpatel",
                        "content": "number of a - number of c (any two character not necessarily most frequent)"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "You are allowed to choose ANY TWO characters. In this case, if you choose all occurences of \\'a\\' - all occurences of \\'c\\', then only you get the best answer, you can just ignore \\'b\\' because it does not give is the largest differenec. So you need to check for all combination of lowercase letters"
                    },
                    {
                        "username": "sachin269",
                        "content": "ig the output iss for combination of pair(a, c) over whole string here substring as the whole complete string being considered"
                    },
                    {
                        "username": "peihao61",
                        "content": "Please take all string in this case.\\na: 7\\nb: 3\\nc: 1\\n\\nAns => 7 - 1 = 6"
                    },
                    {
                        "username": "arghyadas",
                        "content": "I\\'m able to write the recursive solution but unable to memoize\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Blazing_ROHIT",
                        "content": "same here "
                    },
                    {
                        "username": "sachin269",
                        "content": "Can you post the recursive solution please I want to know ..\\nThanks :)"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "DP (map) + DFS + BackTracking gives TLE. So sad.."
                    },
                    {
                        "username": "dgordiy",
                        "content": "After rereading the task and examples more and more times I\\'ve realised that the task is not clear at all."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is not Hard, this is Hard as ****!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Oh boy!"
                    },
                    {
                        "username": "sanskar01",
                        "content": "Not for me:("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "as I guessed, it is the HARD weekend"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Couldn\\'t solve it got TLE two times now. Finding it really hard bruh\\nI am getting the brute force one but cannot upsolve "
                    },
                    {
                        "username": "fizgenix",
                        "content": "hi can someone please help me with this code, gives error at 76th test case \\nclass Solution {\\npublic:\\n    int solve(string &sub){\\n        vector<int>freq(26,0);\\n        for(auto i:sub){\\n            freq[i-\\'a\\']++;\\n        }\\n        int x=*max_element(freq.begin(), freq.end());\\n        int y=x;\\n        for(auto i:freq){\\n            if(i>0 && i<x)\\n                y=i;\\n        }        \\n        return x-y;\\n    }\\n\\n    int largestVariance(string s) {\\n        //check for each substring\\n        int ans=0;\\n        int j=3;\\n        while(j<=s.size()){\\n            for(int i=0;i<=s.size()-j;i++){\\n                string sub= s.substr(i,j);\\n                cout<<sub<<\" \";\\n                int val= solve(sub);\\n                ans=max(val,ans);\\n            }\\n            j++;\\n            cout<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is trying to generate all substrings of the string and then checking for the variance in each of these substrings. This approach has a time complexity of O(n^4) where n is the length of the string. This is because generating all substrings takes O(n^3) and for each substring, you\\'re calculating the variance which takes O(n). Therefore, the total time complexity is O(n^4) which is why your solution is timing out for larger test cases.\\n\\nThe problem you\\'re trying to solve falls under the category of problems where we\\'re interested in the differences between frequency counts of different characters in substrings. For these types of problems, we typically need to use a different approach because generating all substrings would be too slow. One common approach is to use a prefix sum array or a frequency count array.\\n\\nIn this case, however, a more efficient approach would involve using two pointers to maintain the current substring and a frequency count array to keep track of the characters in the current substring. You can then update your pointers and your frequency count array as you iterate through the string and update your max variance as you go.\\n\\nHere is an idea on how you could modify your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i < 26; ++i) {\\n            for(int j = i; j < 26; ++j) {\\n                vector<int> freq(26, 0);\\n                int max_freq = 0, min_freq = n;\\n                for(char c: s) {\\n                    if(c-\\'a\\' != i && c-\\'a\\' != j) continue;\\n                    freq[c-\\'a\\']++;\\n                    max_freq = max(max_freq, freq[c-\\'a\\']);\\n                    if(c-\\'a\\' == i) min_freq = min(min_freq, freq[c-\\'a\\']);\\n                }\\n                ans = max(ans, max_freq - min_freq);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIn this code, for each pair of characters (i, j), you\\'re iterating through the string and updating your frequency count array. You\\'re also keeping track of the max frequency and the min frequency for each pair of characters and updating your answer as you go. This way, you\\'re only iterating through the string 26 * 26 = 676 times which is much more efficient than your current approach.\\n\\nPlease note that you also have to consider the case where the two characters are the same. So, if i == j, you shouldn\\'t update the min_freq in the loop, because it should always be 0 in this case. You might want to add a check for this inside your loop."
                    }
                ]
            },
            {
                "id": 1962860,
                "content": [
                    {
                        "username": "Ashish_4k",
                        "content": "\"aaaabbbcaaa\" can anyone explain how in this question aaaacaaa is a substring how cuz expected o/p is 6 for this"
                    },
                    {
                        "username": "peihao61",
                        "content": "[@Ashish_4k](/Ashish_4k) Please use substring \"bccccccc\" or \"cccccccb\". It will be the answer."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@sachin269](/sachin269) any idea for this \"aaaabbbcccccccbbaa\""
                    },
                    {
                        "username": "sachin269",
                        "content": "[@Ashish_4k](/Ashish_4k) now consider pair (c, a) the output is 6 is obviously  as 6 is the maximum variance"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kngvikashpatel](/kngvikashpatel) for this \"aaaabbbcccccccbbaa\" also it gives 6 as ans decription could have been more proper like first it asks for any two and in the 2nd line substring of any 2"
                    },
                    {
                        "username": "kngvikashpatel",
                        "content": "number of a - number of c (any two character not necessarily most frequent)"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "You are allowed to choose ANY TWO characters. In this case, if you choose all occurences of \\'a\\' - all occurences of \\'c\\', then only you get the best answer, you can just ignore \\'b\\' because it does not give is the largest differenec. So you need to check for all combination of lowercase letters"
                    },
                    {
                        "username": "sachin269",
                        "content": "ig the output iss for combination of pair(a, c) over whole string here substring as the whole complete string being considered"
                    },
                    {
                        "username": "peihao61",
                        "content": "Please take all string in this case.\\na: 7\\nb: 3\\nc: 1\\n\\nAns => 7 - 1 = 6"
                    },
                    {
                        "username": "arghyadas",
                        "content": "I\\'m able to write the recursive solution but unable to memoize\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Blazing_ROHIT",
                        "content": "same here "
                    },
                    {
                        "username": "sachin269",
                        "content": "Can you post the recursive solution please I want to know ..\\nThanks :)"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "DP (map) + DFS + BackTracking gives TLE. So sad.."
                    },
                    {
                        "username": "dgordiy",
                        "content": "After rereading the task and examples more and more times I\\'ve realised that the task is not clear at all."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is not Hard, this is Hard as ****!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Oh boy!"
                    },
                    {
                        "username": "sanskar01",
                        "content": "Not for me:("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "as I guessed, it is the HARD weekend"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Couldn\\'t solve it got TLE two times now. Finding it really hard bruh\\nI am getting the brute force one but cannot upsolve "
                    },
                    {
                        "username": "fizgenix",
                        "content": "hi can someone please help me with this code, gives error at 76th test case \\nclass Solution {\\npublic:\\n    int solve(string &sub){\\n        vector<int>freq(26,0);\\n        for(auto i:sub){\\n            freq[i-\\'a\\']++;\\n        }\\n        int x=*max_element(freq.begin(), freq.end());\\n        int y=x;\\n        for(auto i:freq){\\n            if(i>0 && i<x)\\n                y=i;\\n        }        \\n        return x-y;\\n    }\\n\\n    int largestVariance(string s) {\\n        //check for each substring\\n        int ans=0;\\n        int j=3;\\n        while(j<=s.size()){\\n            for(int i=0;i<=s.size()-j;i++){\\n                string sub= s.substr(i,j);\\n                cout<<sub<<\" \";\\n                int val= solve(sub);\\n                ans=max(val,ans);\\n            }\\n            j++;\\n            cout<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is trying to generate all substrings of the string and then checking for the variance in each of these substrings. This approach has a time complexity of O(n^4) where n is the length of the string. This is because generating all substrings takes O(n^3) and for each substring, you\\'re calculating the variance which takes O(n). Therefore, the total time complexity is O(n^4) which is why your solution is timing out for larger test cases.\\n\\nThe problem you\\'re trying to solve falls under the category of problems where we\\'re interested in the differences between frequency counts of different characters in substrings. For these types of problems, we typically need to use a different approach because generating all substrings would be too slow. One common approach is to use a prefix sum array or a frequency count array.\\n\\nIn this case, however, a more efficient approach would involve using two pointers to maintain the current substring and a frequency count array to keep track of the characters in the current substring. You can then update your pointers and your frequency count array as you iterate through the string and update your max variance as you go.\\n\\nHere is an idea on how you could modify your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i < 26; ++i) {\\n            for(int j = i; j < 26; ++j) {\\n                vector<int> freq(26, 0);\\n                int max_freq = 0, min_freq = n;\\n                for(char c: s) {\\n                    if(c-\\'a\\' != i && c-\\'a\\' != j) continue;\\n                    freq[c-\\'a\\']++;\\n                    max_freq = max(max_freq, freq[c-\\'a\\']);\\n                    if(c-\\'a\\' == i) min_freq = min(min_freq, freq[c-\\'a\\']);\\n                }\\n                ans = max(ans, max_freq - min_freq);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIn this code, for each pair of characters (i, j), you\\'re iterating through the string and updating your frequency count array. You\\'re also keeping track of the max frequency and the min frequency for each pair of characters and updating your answer as you go. This way, you\\'re only iterating through the string 26 * 26 = 676 times which is much more efficient than your current approach.\\n\\nPlease note that you also have to consider the case where the two characters are the same. So, if i == j, you shouldn\\'t update the min_freq in the loop, because it should always be 0 in this case. You might want to add a check for this inside your loop."
                    }
                ]
            },
            {
                "id": 1962813,
                "content": [
                    {
                        "username": "Ashish_4k",
                        "content": "\"aaaabbbcaaa\" can anyone explain how in this question aaaacaaa is a substring how cuz expected o/p is 6 for this"
                    },
                    {
                        "username": "peihao61",
                        "content": "[@Ashish_4k](/Ashish_4k) Please use substring \"bccccccc\" or \"cccccccb\". It will be the answer."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@sachin269](/sachin269) any idea for this \"aaaabbbcccccccbbaa\""
                    },
                    {
                        "username": "sachin269",
                        "content": "[@Ashish_4k](/Ashish_4k) now consider pair (c, a) the output is 6 is obviously  as 6 is the maximum variance"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kngvikashpatel](/kngvikashpatel) for this \"aaaabbbcccccccbbaa\" also it gives 6 as ans decription could have been more proper like first it asks for any two and in the 2nd line substring of any 2"
                    },
                    {
                        "username": "kngvikashpatel",
                        "content": "number of a - number of c (any two character not necessarily most frequent)"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "You are allowed to choose ANY TWO characters. In this case, if you choose all occurences of \\'a\\' - all occurences of \\'c\\', then only you get the best answer, you can just ignore \\'b\\' because it does not give is the largest differenec. So you need to check for all combination of lowercase letters"
                    },
                    {
                        "username": "sachin269",
                        "content": "ig the output iss for combination of pair(a, c) over whole string here substring as the whole complete string being considered"
                    },
                    {
                        "username": "peihao61",
                        "content": "Please take all string in this case.\\na: 7\\nb: 3\\nc: 1\\n\\nAns => 7 - 1 = 6"
                    },
                    {
                        "username": "arghyadas",
                        "content": "I\\'m able to write the recursive solution but unable to memoize\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Blazing_ROHIT",
                        "content": "same here "
                    },
                    {
                        "username": "sachin269",
                        "content": "Can you post the recursive solution please I want to know ..\\nThanks :)"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "DP (map) + DFS + BackTracking gives TLE. So sad.."
                    },
                    {
                        "username": "dgordiy",
                        "content": "After rereading the task and examples more and more times I\\'ve realised that the task is not clear at all."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is not Hard, this is Hard as ****!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Oh boy!"
                    },
                    {
                        "username": "sanskar01",
                        "content": "Not for me:("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "as I guessed, it is the HARD weekend"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Couldn\\'t solve it got TLE two times now. Finding it really hard bruh\\nI am getting the brute force one but cannot upsolve "
                    },
                    {
                        "username": "fizgenix",
                        "content": "hi can someone please help me with this code, gives error at 76th test case \\nclass Solution {\\npublic:\\n    int solve(string &sub){\\n        vector<int>freq(26,0);\\n        for(auto i:sub){\\n            freq[i-\\'a\\']++;\\n        }\\n        int x=*max_element(freq.begin(), freq.end());\\n        int y=x;\\n        for(auto i:freq){\\n            if(i>0 && i<x)\\n                y=i;\\n        }        \\n        return x-y;\\n    }\\n\\n    int largestVariance(string s) {\\n        //check for each substring\\n        int ans=0;\\n        int j=3;\\n        while(j<=s.size()){\\n            for(int i=0;i<=s.size()-j;i++){\\n                string sub= s.substr(i,j);\\n                cout<<sub<<\" \";\\n                int val= solve(sub);\\n                ans=max(val,ans);\\n            }\\n            j++;\\n            cout<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is trying to generate all substrings of the string and then checking for the variance in each of these substrings. This approach has a time complexity of O(n^4) where n is the length of the string. This is because generating all substrings takes O(n^3) and for each substring, you\\'re calculating the variance which takes O(n). Therefore, the total time complexity is O(n^4) which is why your solution is timing out for larger test cases.\\n\\nThe problem you\\'re trying to solve falls under the category of problems where we\\'re interested in the differences between frequency counts of different characters in substrings. For these types of problems, we typically need to use a different approach because generating all substrings would be too slow. One common approach is to use a prefix sum array or a frequency count array.\\n\\nIn this case, however, a more efficient approach would involve using two pointers to maintain the current substring and a frequency count array to keep track of the characters in the current substring. You can then update your pointers and your frequency count array as you iterate through the string and update your max variance as you go.\\n\\nHere is an idea on how you could modify your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i < 26; ++i) {\\n            for(int j = i; j < 26; ++j) {\\n                vector<int> freq(26, 0);\\n                int max_freq = 0, min_freq = n;\\n                for(char c: s) {\\n                    if(c-\\'a\\' != i && c-\\'a\\' != j) continue;\\n                    freq[c-\\'a\\']++;\\n                    max_freq = max(max_freq, freq[c-\\'a\\']);\\n                    if(c-\\'a\\' == i) min_freq = min(min_freq, freq[c-\\'a\\']);\\n                }\\n                ans = max(ans, max_freq - min_freq);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIn this code, for each pair of characters (i, j), you\\'re iterating through the string and updating your frequency count array. You\\'re also keeping track of the max frequency and the min frequency for each pair of characters and updating your answer as you go. This way, you\\'re only iterating through the string 26 * 26 = 676 times which is much more efficient than your current approach.\\n\\nPlease note that you also have to consider the case where the two characters are the same. So, if i == j, you shouldn\\'t update the min_freq in the loop, because it should always be 0 in this case. You might want to add a check for this inside your loop."
                    }
                ]
            },
            {
                "id": 1962799,
                "content": [
                    {
                        "username": "Ashish_4k",
                        "content": "\"aaaabbbcaaa\" can anyone explain how in this question aaaacaaa is a substring how cuz expected o/p is 6 for this"
                    },
                    {
                        "username": "peihao61",
                        "content": "[@Ashish_4k](/Ashish_4k) Please use substring \"bccccccc\" or \"cccccccb\". It will be the answer."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@sachin269](/sachin269) any idea for this \"aaaabbbcccccccbbaa\""
                    },
                    {
                        "username": "sachin269",
                        "content": "[@Ashish_4k](/Ashish_4k) now consider pair (c, a) the output is 6 is obviously  as 6 is the maximum variance"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kngvikashpatel](/kngvikashpatel) for this \"aaaabbbcccccccbbaa\" also it gives 6 as ans decription could have been more proper like first it asks for any two and in the 2nd line substring of any 2"
                    },
                    {
                        "username": "kngvikashpatel",
                        "content": "number of a - number of c (any two character not necessarily most frequent)"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "You are allowed to choose ANY TWO characters. In this case, if you choose all occurences of \\'a\\' - all occurences of \\'c\\', then only you get the best answer, you can just ignore \\'b\\' because it does not give is the largest differenec. So you need to check for all combination of lowercase letters"
                    },
                    {
                        "username": "sachin269",
                        "content": "ig the output iss for combination of pair(a, c) over whole string here substring as the whole complete string being considered"
                    },
                    {
                        "username": "peihao61",
                        "content": "Please take all string in this case.\\na: 7\\nb: 3\\nc: 1\\n\\nAns => 7 - 1 = 6"
                    },
                    {
                        "username": "arghyadas",
                        "content": "I\\'m able to write the recursive solution but unable to memoize\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Blazing_ROHIT",
                        "content": "same here "
                    },
                    {
                        "username": "sachin269",
                        "content": "Can you post the recursive solution please I want to know ..\\nThanks :)"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "DP (map) + DFS + BackTracking gives TLE. So sad.."
                    },
                    {
                        "username": "dgordiy",
                        "content": "After rereading the task and examples more and more times I\\'ve realised that the task is not clear at all."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is not Hard, this is Hard as ****!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Oh boy!"
                    },
                    {
                        "username": "sanskar01",
                        "content": "Not for me:("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "as I guessed, it is the HARD weekend"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Couldn\\'t solve it got TLE two times now. Finding it really hard bruh\\nI am getting the brute force one but cannot upsolve "
                    },
                    {
                        "username": "fizgenix",
                        "content": "hi can someone please help me with this code, gives error at 76th test case \\nclass Solution {\\npublic:\\n    int solve(string &sub){\\n        vector<int>freq(26,0);\\n        for(auto i:sub){\\n            freq[i-\\'a\\']++;\\n        }\\n        int x=*max_element(freq.begin(), freq.end());\\n        int y=x;\\n        for(auto i:freq){\\n            if(i>0 && i<x)\\n                y=i;\\n        }        \\n        return x-y;\\n    }\\n\\n    int largestVariance(string s) {\\n        //check for each substring\\n        int ans=0;\\n        int j=3;\\n        while(j<=s.size()){\\n            for(int i=0;i<=s.size()-j;i++){\\n                string sub= s.substr(i,j);\\n                cout<<sub<<\" \";\\n                int val= solve(sub);\\n                ans=max(val,ans);\\n            }\\n            j++;\\n            cout<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is trying to generate all substrings of the string and then checking for the variance in each of these substrings. This approach has a time complexity of O(n^4) where n is the length of the string. This is because generating all substrings takes O(n^3) and for each substring, you\\'re calculating the variance which takes O(n). Therefore, the total time complexity is O(n^4) which is why your solution is timing out for larger test cases.\\n\\nThe problem you\\'re trying to solve falls under the category of problems where we\\'re interested in the differences between frequency counts of different characters in substrings. For these types of problems, we typically need to use a different approach because generating all substrings would be too slow. One common approach is to use a prefix sum array or a frequency count array.\\n\\nIn this case, however, a more efficient approach would involve using two pointers to maintain the current substring and a frequency count array to keep track of the characters in the current substring. You can then update your pointers and your frequency count array as you iterate through the string and update your max variance as you go.\\n\\nHere is an idea on how you could modify your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i < 26; ++i) {\\n            for(int j = i; j < 26; ++j) {\\n                vector<int> freq(26, 0);\\n                int max_freq = 0, min_freq = n;\\n                for(char c: s) {\\n                    if(c-\\'a\\' != i && c-\\'a\\' != j) continue;\\n                    freq[c-\\'a\\']++;\\n                    max_freq = max(max_freq, freq[c-\\'a\\']);\\n                    if(c-\\'a\\' == i) min_freq = min(min_freq, freq[c-\\'a\\']);\\n                }\\n                ans = max(ans, max_freq - min_freq);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIn this code, for each pair of characters (i, j), you\\'re iterating through the string and updating your frequency count array. You\\'re also keeping track of the max frequency and the min frequency for each pair of characters and updating your answer as you go. This way, you\\'re only iterating through the string 26 * 26 = 676 times which is much more efficient than your current approach.\\n\\nPlease note that you also have to consider the case where the two characters are the same. So, if i == j, you shouldn\\'t update the min_freq in the loop, because it should always be 0 in this case. You might want to add a check for this inside your loop."
                    }
                ]
            },
            {
                "id": 1962787,
                "content": [
                    {
                        "username": "Ashish_4k",
                        "content": "\"aaaabbbcaaa\" can anyone explain how in this question aaaacaaa is a substring how cuz expected o/p is 6 for this"
                    },
                    {
                        "username": "peihao61",
                        "content": "[@Ashish_4k](/Ashish_4k) Please use substring \"bccccccc\" or \"cccccccb\". It will be the answer."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@sachin269](/sachin269) any idea for this \"aaaabbbcccccccbbaa\""
                    },
                    {
                        "username": "sachin269",
                        "content": "[@Ashish_4k](/Ashish_4k) now consider pair (c, a) the output is 6 is obviously  as 6 is the maximum variance"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kngvikashpatel](/kngvikashpatel) for this \"aaaabbbcccccccbbaa\" also it gives 6 as ans decription could have been more proper like first it asks for any two and in the 2nd line substring of any 2"
                    },
                    {
                        "username": "kngvikashpatel",
                        "content": "number of a - number of c (any two character not necessarily most frequent)"
                    },
                    {
                        "username": "ATLAS2002",
                        "content": "You are allowed to choose ANY TWO characters. In this case, if you choose all occurences of \\'a\\' - all occurences of \\'c\\', then only you get the best answer, you can just ignore \\'b\\' because it does not give is the largest differenec. So you need to check for all combination of lowercase letters"
                    },
                    {
                        "username": "sachin269",
                        "content": "ig the output iss for combination of pair(a, c) over whole string here substring as the whole complete string being considered"
                    },
                    {
                        "username": "peihao61",
                        "content": "Please take all string in this case.\\na: 7\\nb: 3\\nc: 1\\n\\nAns => 7 - 1 = 6"
                    },
                    {
                        "username": "arghyadas",
                        "content": "I\\'m able to write the recursive solution but unable to memoize\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Blazing_ROHIT",
                        "content": "same here "
                    },
                    {
                        "username": "sachin269",
                        "content": "Can you post the recursive solution please I want to know ..\\nThanks :)"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "DP (map) + DFS + BackTracking gives TLE. So sad.."
                    },
                    {
                        "username": "dgordiy",
                        "content": "After rereading the task and examples more and more times I\\'ve realised that the task is not clear at all."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is not Hard, this is Hard as ****!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Oh boy!"
                    },
                    {
                        "username": "sanskar01",
                        "content": "Not for me:("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "as I guessed, it is the HARD weekend"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Couldn\\'t solve it got TLE two times now. Finding it really hard bruh\\nI am getting the brute force one but cannot upsolve "
                    },
                    {
                        "username": "fizgenix",
                        "content": "hi can someone please help me with this code, gives error at 76th test case \\nclass Solution {\\npublic:\\n    int solve(string &sub){\\n        vector<int>freq(26,0);\\n        for(auto i:sub){\\n            freq[i-\\'a\\']++;\\n        }\\n        int x=*max_element(freq.begin(), freq.end());\\n        int y=x;\\n        for(auto i:freq){\\n            if(i>0 && i<x)\\n                y=i;\\n        }        \\n        return x-y;\\n    }\\n\\n    int largestVariance(string s) {\\n        //check for each substring\\n        int ans=0;\\n        int j=3;\\n        while(j<=s.size()){\\n            for(int i=0;i<=s.size()-j;i++){\\n                string sub= s.substr(i,j);\\n                cout<<sub<<\" \";\\n                int val= solve(sub);\\n                ans=max(val,ans);\\n            }\\n            j++;\\n            cout<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is trying to generate all substrings of the string and then checking for the variance in each of these substrings. This approach has a time complexity of O(n^4) where n is the length of the string. This is because generating all substrings takes O(n^3) and for each substring, you\\'re calculating the variance which takes O(n). Therefore, the total time complexity is O(n^4) which is why your solution is timing out for larger test cases.\\n\\nThe problem you\\'re trying to solve falls under the category of problems where we\\'re interested in the differences between frequency counts of different characters in substrings. For these types of problems, we typically need to use a different approach because generating all substrings would be too slow. One common approach is to use a prefix sum array or a frequency count array.\\n\\nIn this case, however, a more efficient approach would involve using two pointers to maintain the current substring and a frequency count array to keep track of the characters in the current substring. You can then update your pointers and your frequency count array as you iterate through the string and update your max variance as you go.\\n\\nHere is an idea on how you could modify your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int largestVariance(string s) {\\n        int ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i < 26; ++i) {\\n            for(int j = i; j < 26; ++j) {\\n                vector<int> freq(26, 0);\\n                int max_freq = 0, min_freq = n;\\n                for(char c: s) {\\n                    if(c-\\'a\\' != i && c-\\'a\\' != j) continue;\\n                    freq[c-\\'a\\']++;\\n                    max_freq = max(max_freq, freq[c-\\'a\\']);\\n                    if(c-\\'a\\' == i) min_freq = min(min_freq, freq[c-\\'a\\']);\\n                }\\n                ans = max(ans, max_freq - min_freq);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIn this code, for each pair of characters (i, j), you\\'re iterating through the string and updating your frequency count array. You\\'re also keeping track of the max frequency and the min frequency for each pair of characters and updating your answer as you go. This way, you\\'re only iterating through the string 26 * 26 = 676 times which is much more efficient than your current approach.\\n\\nPlease note that you also have to consider the case where the two characters are the same. So, if i == j, you shouldn\\'t update the min_freq in the loop, because it should always be 0 in this case. You might want to add a check for this inside your loop."
                    }
                ]
            },
            {
                "id": 1962736,
                "content": [
                    {
                        "username": "charucjoshi",
                        "content": "Why reverse?\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem of finding the maximum variance between two characters in a string, reversing the string can handle the cases where the second character (character represented by -1) appears before the first character (character represented by 1). \\n\\nLet\\'s take these examples:\\n\\n1. \"dzzzz\" \\nHere, if we consider \\'d\\' as 1 and \\'z\\' as -1, by scanning from left to right, we see that the string begins with \\'d\\', and so our variance starts with 1 and keeps decreasing with every \\'z\\' encountered, which gives us a minimal variance of -3. If we reverse the string, we get \"zzzzd\", and now our variance starts with -1 and keeps increasing with every \\'z\\', giving us a maximal variance of -1, which is greater than the original minimal variance of -3.\\n\\n2. \"zzzzd\"\\nHere, if we consider \\'d\\' as 1 and \\'z\\' as -1, by scanning from left to right, our variance starts with -1 and keeps decreasing with every \\'z\\', which gives us a minimal variance of -4. If we reverse the string, we get \"dzzzz\", and now our variance starts with 1 and keeps decreasing with every \\'z\\', giving us a maximal variance of -3, which is greater than the original minimal variance of -4.\\n\\nSo, by reversing the string, we can ensure that we always start with the second character and hence are able to find a maximal variance when the second character appears before the first character in the original string.\\n\\nHowever, in your implementation, you would need to implement both checks, one for the original string and another for the reversed string, and then take the maximum variance found in both checks as the answer."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Dry run these two cases : \"dzzzz\" and \"zzzzd\",with reversing the string and without reversing, you will figure out."
                    },
                    {
                        "username": "Thomaswang0822",
                        "content": "WTH Python submission threw a TLE on an empty input for the last test case."
                    },
                    {
                        "username": "ZQGao",
                        "content": "Why python TLE with 26 * 26 * n algorithm?\\n```python\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        ans = 0\\n        for i in range(26):\\n            for j in range(26):\\n                if i == j:\\n                    continue\\n                diff = 0\\n                diffWithJ = float(\\'-inf\\')\\n                for k in range(len(s)):\\n                    if s[k] == chr(i + ord(\\'a\\')):\\n                        diff += 1\\n                        diffWithJ += 1\\n                    elif s[k] == chr(j + ord(\\'a\\')):\\n                        diff -= 1\\n                        diffWithJ = diff\\n                    if diff < 0:\\n                        diff = 0\\n                        diffWithJ = -1\\n                    if diffWithJ > ans:\\n                        ans = diffWithJ\\n\\n        return ans\\n\\n\\n\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your algorithm is O(26 * 26 * n), which should be feasible for n <= 10^5. However, the constant factors in Python are significantly larger than in languages like C++ or Java due to its dynamic typing and other features, so a Python program will often run slower than an equivalent program in C++ or Java.\n\nMoreover, Python's performance can be influenced by many other factors, such as the specific implementation of the Python interpreter you're using, the specific operations you're performing, and how you're using Python's built-in data structures.\n\nThere are ways to optimize Python code to make it run faster, such as using built-in functions and libraries whenever possible, avoiding unnecessary looping, and using efficient data structures.\n\nIn your case, you could try optimizing your code by calculating `chr(i + ord('a'))` and `chr(j + ord('a'))` outside the loop over `k`, to avoid repeating these calculations for every character in the string. Here's a possible way to do that:\n\n```python\nclass Solution:\n    def largestVariance(self, s: str) -> int:\n        ans = 0\n        for i in range(26):\n            for j in range(26):\n                if i == j:\n                    continue\n                char_i = chr(i + ord('a'))\n                char_j = chr(j + ord('a'))\n                diff = 0\n                diffWithJ = float('-inf')\n                for k in range(len(s)):\n                    if s[k] == char_i:\n                        diff += 1\n                        diffWithJ += 1\n                    elif s[k] == char_j:\n                        diff -= 1\n                        diffWithJ = diff\n                    if diff < 0:\n                        diff = 0\n                        diffWithJ = -1\n                    if diffWithJ > ans:\n                        ans = diffWithJ\n\n        return ans\n```\n\nAlso, since the `continue` statement in your `if i == j:` check just skips to the next iteration of the inner loop, you could eliminate this check altogether by changing the range of `j` in the outer loop to `range(i+1, 26)`, assuming `i` and `j` can be the same. "
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "Try to ignore letters that are not present in the string. And also consider using letters directly without calculating chars."
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Wait. Even so, what did the description mean?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference"
                    },
                    {
                        "username": "huikinglam02",
                        "content": "Have to say this question is rather hard haha"
                    },
                    {
                        "username": "voodooism",
                        "content": "I\\'ve read the problem, hints, all the comments here and editorial. Still don\\'t understand the question..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference"
                    },
                    {
                        "username": "psionl0",
                        "content": "136 out of 138 testcases passed. The 137th testcase gave a WRONG ANSWER (85 instead of 86).\\nSince it is virtually impossible to trace through the code with an input of this size, I tried copying the editorial solution just in case there was a subtle fault in my logic.\\nTHE EDITORIAL SOLUTION GIVES THE SAME WRONG ANSWER!\\n\\nCheck Mate. (There goes my streak)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@katalma](/katalma) Actually I converted the code to C as I was copying it (the code is virtually identical). I copy/pasted the Java solution to see if the same error would occur but it didn\\'t. Major Frustration."
                    },
                    {
                        "username": "katalma",
                        "content": "for meg the editorial copy paste worked. At least the Java version. "
                    },
                    {
                        "username": "sector28",
                        "content": "passing 126/135 tests but it\\'s never ending"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "It felt really nice passing 122 / 138 cases on my first attempt when i was so confused about the question guess i understood it right "
                    },
                    {
                        "username": "SabihaKhan",
                        "content": "To have a variance more than 0, a substring must contain 2 diff characters and difference of their number of occurrence should be more than 0.\\nThe difference of their number of occurrence is variance.\\n\\nIn Example 1:\\n\\nInput: s = \"aababbb\"\\nOutput: 3\\n\\nExplanation:\\n- Variance 0 for substrings \"a\", \"aa\", \"ab\", \"abab\", \"aababb\", \"ba\", \"b\", \"bb\", and \"bbb\".->            these substrings either only contain 1 type of characters or contains 2 character with same count. \\n\\n- Variance 1 for substrings \"aab\", \"aba\", \"abb\", \"aabab\", \"ababb\", \"aababbb\", and \"bab\".->  these substring contains 2 diff characters and diff of there occurrence is 1.\\n- Variance 2 for substrings \"aaba\", \"ababbb\", \"abbb\", and\\n \"babb\". -> these substring contains 2 diff characters and diff of there occurrence is 2.\\n- Variance 3 for substring \"babbb\". -> these substring contains 2 diff characters and diff of there occurrence is 3."
                    }
                ]
            },
            {
                "id": 1962729,
                "content": [
                    {
                        "username": "charucjoshi",
                        "content": "Why reverse?\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem of finding the maximum variance between two characters in a string, reversing the string can handle the cases where the second character (character represented by -1) appears before the first character (character represented by 1). \\n\\nLet\\'s take these examples:\\n\\n1. \"dzzzz\" \\nHere, if we consider \\'d\\' as 1 and \\'z\\' as -1, by scanning from left to right, we see that the string begins with \\'d\\', and so our variance starts with 1 and keeps decreasing with every \\'z\\' encountered, which gives us a minimal variance of -3. If we reverse the string, we get \"zzzzd\", and now our variance starts with -1 and keeps increasing with every \\'z\\', giving us a maximal variance of -1, which is greater than the original minimal variance of -3.\\n\\n2. \"zzzzd\"\\nHere, if we consider \\'d\\' as 1 and \\'z\\' as -1, by scanning from left to right, our variance starts with -1 and keeps decreasing with every \\'z\\', which gives us a minimal variance of -4. If we reverse the string, we get \"dzzzz\", and now our variance starts with 1 and keeps decreasing with every \\'z\\', giving us a maximal variance of -3, which is greater than the original minimal variance of -4.\\n\\nSo, by reversing the string, we can ensure that we always start with the second character and hence are able to find a maximal variance when the second character appears before the first character in the original string.\\n\\nHowever, in your implementation, you would need to implement both checks, one for the original string and another for the reversed string, and then take the maximum variance found in both checks as the answer."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Dry run these two cases : \"dzzzz\" and \"zzzzd\",with reversing the string and without reversing, you will figure out."
                    },
                    {
                        "username": "Thomaswang0822",
                        "content": "WTH Python submission threw a TLE on an empty input for the last test case."
                    },
                    {
                        "username": "ZQGao",
                        "content": "Why python TLE with 26 * 26 * n algorithm?\\n```python\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        ans = 0\\n        for i in range(26):\\n            for j in range(26):\\n                if i == j:\\n                    continue\\n                diff = 0\\n                diffWithJ = float(\\'-inf\\')\\n                for k in range(len(s)):\\n                    if s[k] == chr(i + ord(\\'a\\')):\\n                        diff += 1\\n                        diffWithJ += 1\\n                    elif s[k] == chr(j + ord(\\'a\\')):\\n                        diff -= 1\\n                        diffWithJ = diff\\n                    if diff < 0:\\n                        diff = 0\\n                        diffWithJ = -1\\n                    if diffWithJ > ans:\\n                        ans = diffWithJ\\n\\n        return ans\\n\\n\\n\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your algorithm is O(26 * 26 * n), which should be feasible for n <= 10^5. However, the constant factors in Python are significantly larger than in languages like C++ or Java due to its dynamic typing and other features, so a Python program will often run slower than an equivalent program in C++ or Java.\n\nMoreover, Python's performance can be influenced by many other factors, such as the specific implementation of the Python interpreter you're using, the specific operations you're performing, and how you're using Python's built-in data structures.\n\nThere are ways to optimize Python code to make it run faster, such as using built-in functions and libraries whenever possible, avoiding unnecessary looping, and using efficient data structures.\n\nIn your case, you could try optimizing your code by calculating `chr(i + ord('a'))` and `chr(j + ord('a'))` outside the loop over `k`, to avoid repeating these calculations for every character in the string. Here's a possible way to do that:\n\n```python\nclass Solution:\n    def largestVariance(self, s: str) -> int:\n        ans = 0\n        for i in range(26):\n            for j in range(26):\n                if i == j:\n                    continue\n                char_i = chr(i + ord('a'))\n                char_j = chr(j + ord('a'))\n                diff = 0\n                diffWithJ = float('-inf')\n                for k in range(len(s)):\n                    if s[k] == char_i:\n                        diff += 1\n                        diffWithJ += 1\n                    elif s[k] == char_j:\n                        diff -= 1\n                        diffWithJ = diff\n                    if diff < 0:\n                        diff = 0\n                        diffWithJ = -1\n                    if diffWithJ > ans:\n                        ans = diffWithJ\n\n        return ans\n```\n\nAlso, since the `continue` statement in your `if i == j:` check just skips to the next iteration of the inner loop, you could eliminate this check altogether by changing the range of `j` in the outer loop to `range(i+1, 26)`, assuming `i` and `j` can be the same. "
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "Try to ignore letters that are not present in the string. And also consider using letters directly without calculating chars."
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Wait. Even so, what did the description mean?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference"
                    },
                    {
                        "username": "huikinglam02",
                        "content": "Have to say this question is rather hard haha"
                    },
                    {
                        "username": "voodooism",
                        "content": "I\\'ve read the problem, hints, all the comments here and editorial. Still don\\'t understand the question..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference"
                    },
                    {
                        "username": "psionl0",
                        "content": "136 out of 138 testcases passed. The 137th testcase gave a WRONG ANSWER (85 instead of 86).\\nSince it is virtually impossible to trace through the code with an input of this size, I tried copying the editorial solution just in case there was a subtle fault in my logic.\\nTHE EDITORIAL SOLUTION GIVES THE SAME WRONG ANSWER!\\n\\nCheck Mate. (There goes my streak)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@katalma](/katalma) Actually I converted the code to C as I was copying it (the code is virtually identical). I copy/pasted the Java solution to see if the same error would occur but it didn\\'t. Major Frustration."
                    },
                    {
                        "username": "katalma",
                        "content": "for meg the editorial copy paste worked. At least the Java version. "
                    },
                    {
                        "username": "sector28",
                        "content": "passing 126/135 tests but it\\'s never ending"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "It felt really nice passing 122 / 138 cases on my first attempt when i was so confused about the question guess i understood it right "
                    },
                    {
                        "username": "SabihaKhan",
                        "content": "To have a variance more than 0, a substring must contain 2 diff characters and difference of their number of occurrence should be more than 0.\\nThe difference of their number of occurrence is variance.\\n\\nIn Example 1:\\n\\nInput: s = \"aababbb\"\\nOutput: 3\\n\\nExplanation:\\n- Variance 0 for substrings \"a\", \"aa\", \"ab\", \"abab\", \"aababb\", \"ba\", \"b\", \"bb\", and \"bbb\".->            these substrings either only contain 1 type of characters or contains 2 character with same count. \\n\\n- Variance 1 for substrings \"aab\", \"aba\", \"abb\", \"aabab\", \"ababb\", \"aababbb\", and \"bab\".->  these substring contains 2 diff characters and diff of there occurrence is 1.\\n- Variance 2 for substrings \"aaba\", \"ababbb\", \"abbb\", and\\n \"babb\". -> these substring contains 2 diff characters and diff of there occurrence is 2.\\n- Variance 3 for substring \"babbb\". -> these substring contains 2 diff characters and diff of there occurrence is 3."
                    }
                ]
            },
            {
                "id": 1962724,
                "content": [
                    {
                        "username": "charucjoshi",
                        "content": "Why reverse?\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem of finding the maximum variance between two characters in a string, reversing the string can handle the cases where the second character (character represented by -1) appears before the first character (character represented by 1). \\n\\nLet\\'s take these examples:\\n\\n1. \"dzzzz\" \\nHere, if we consider \\'d\\' as 1 and \\'z\\' as -1, by scanning from left to right, we see that the string begins with \\'d\\', and so our variance starts with 1 and keeps decreasing with every \\'z\\' encountered, which gives us a minimal variance of -3. If we reverse the string, we get \"zzzzd\", and now our variance starts with -1 and keeps increasing with every \\'z\\', giving us a maximal variance of -1, which is greater than the original minimal variance of -3.\\n\\n2. \"zzzzd\"\\nHere, if we consider \\'d\\' as 1 and \\'z\\' as -1, by scanning from left to right, our variance starts with -1 and keeps decreasing with every \\'z\\', which gives us a minimal variance of -4. If we reverse the string, we get \"dzzzz\", and now our variance starts with 1 and keeps decreasing with every \\'z\\', giving us a maximal variance of -3, which is greater than the original minimal variance of -4.\\n\\nSo, by reversing the string, we can ensure that we always start with the second character and hence are able to find a maximal variance when the second character appears before the first character in the original string.\\n\\nHowever, in your implementation, you would need to implement both checks, one for the original string and another for the reversed string, and then take the maximum variance found in both checks as the answer."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Dry run these two cases : \"dzzzz\" and \"zzzzd\",with reversing the string and without reversing, you will figure out."
                    },
                    {
                        "username": "Thomaswang0822",
                        "content": "WTH Python submission threw a TLE on an empty input for the last test case."
                    },
                    {
                        "username": "ZQGao",
                        "content": "Why python TLE with 26 * 26 * n algorithm?\\n```python\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        ans = 0\\n        for i in range(26):\\n            for j in range(26):\\n                if i == j:\\n                    continue\\n                diff = 0\\n                diffWithJ = float(\\'-inf\\')\\n                for k in range(len(s)):\\n                    if s[k] == chr(i + ord(\\'a\\')):\\n                        diff += 1\\n                        diffWithJ += 1\\n                    elif s[k] == chr(j + ord(\\'a\\')):\\n                        diff -= 1\\n                        diffWithJ = diff\\n                    if diff < 0:\\n                        diff = 0\\n                        diffWithJ = -1\\n                    if diffWithJ > ans:\\n                        ans = diffWithJ\\n\\n        return ans\\n\\n\\n\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your algorithm is O(26 * 26 * n), which should be feasible for n <= 10^5. However, the constant factors in Python are significantly larger than in languages like C++ or Java due to its dynamic typing and other features, so a Python program will often run slower than an equivalent program in C++ or Java.\n\nMoreover, Python's performance can be influenced by many other factors, such as the specific implementation of the Python interpreter you're using, the specific operations you're performing, and how you're using Python's built-in data structures.\n\nThere are ways to optimize Python code to make it run faster, such as using built-in functions and libraries whenever possible, avoiding unnecessary looping, and using efficient data structures.\n\nIn your case, you could try optimizing your code by calculating `chr(i + ord('a'))` and `chr(j + ord('a'))` outside the loop over `k`, to avoid repeating these calculations for every character in the string. Here's a possible way to do that:\n\n```python\nclass Solution:\n    def largestVariance(self, s: str) -> int:\n        ans = 0\n        for i in range(26):\n            for j in range(26):\n                if i == j:\n                    continue\n                char_i = chr(i + ord('a'))\n                char_j = chr(j + ord('a'))\n                diff = 0\n                diffWithJ = float('-inf')\n                for k in range(len(s)):\n                    if s[k] == char_i:\n                        diff += 1\n                        diffWithJ += 1\n                    elif s[k] == char_j:\n                        diff -= 1\n                        diffWithJ = diff\n                    if diff < 0:\n                        diff = 0\n                        diffWithJ = -1\n                    if diffWithJ > ans:\n                        ans = diffWithJ\n\n        return ans\n```\n\nAlso, since the `continue` statement in your `if i == j:` check just skips to the next iteration of the inner loop, you could eliminate this check altogether by changing the range of `j` in the outer loop to `range(i+1, 26)`, assuming `i` and `j` can be the same. "
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "Try to ignore letters that are not present in the string. And also consider using letters directly without calculating chars."
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Wait. Even so, what did the description mean?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference"
                    },
                    {
                        "username": "huikinglam02",
                        "content": "Have to say this question is rather hard haha"
                    },
                    {
                        "username": "voodooism",
                        "content": "I\\'ve read the problem, hints, all the comments here and editorial. Still don\\'t understand the question..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference"
                    },
                    {
                        "username": "psionl0",
                        "content": "136 out of 138 testcases passed. The 137th testcase gave a WRONG ANSWER (85 instead of 86).\\nSince it is virtually impossible to trace through the code with an input of this size, I tried copying the editorial solution just in case there was a subtle fault in my logic.\\nTHE EDITORIAL SOLUTION GIVES THE SAME WRONG ANSWER!\\n\\nCheck Mate. (There goes my streak)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@katalma](/katalma) Actually I converted the code to C as I was copying it (the code is virtually identical). I copy/pasted the Java solution to see if the same error would occur but it didn\\'t. Major Frustration."
                    },
                    {
                        "username": "katalma",
                        "content": "for meg the editorial copy paste worked. At least the Java version. "
                    },
                    {
                        "username": "sector28",
                        "content": "passing 126/135 tests but it\\'s never ending"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "It felt really nice passing 122 / 138 cases on my first attempt when i was so confused about the question guess i understood it right "
                    },
                    {
                        "username": "SabihaKhan",
                        "content": "To have a variance more than 0, a substring must contain 2 diff characters and difference of their number of occurrence should be more than 0.\\nThe difference of their number of occurrence is variance.\\n\\nIn Example 1:\\n\\nInput: s = \"aababbb\"\\nOutput: 3\\n\\nExplanation:\\n- Variance 0 for substrings \"a\", \"aa\", \"ab\", \"abab\", \"aababb\", \"ba\", \"b\", \"bb\", and \"bbb\".->            these substrings either only contain 1 type of characters or contains 2 character with same count. \\n\\n- Variance 1 for substrings \"aab\", \"aba\", \"abb\", \"aabab\", \"ababb\", \"aababbb\", and \"bab\".->  these substring contains 2 diff characters and diff of there occurrence is 1.\\n- Variance 2 for substrings \"aaba\", \"ababbb\", \"abbb\", and\\n \"babb\". -> these substring contains 2 diff characters and diff of there occurrence is 2.\\n- Variance 3 for substring \"babbb\". -> these substring contains 2 diff characters and diff of there occurrence is 3."
                    }
                ]
            },
            {
                "id": 1962708,
                "content": [
                    {
                        "username": "charucjoshi",
                        "content": "Why reverse?\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem of finding the maximum variance between two characters in a string, reversing the string can handle the cases where the second character (character represented by -1) appears before the first character (character represented by 1). \\n\\nLet\\'s take these examples:\\n\\n1. \"dzzzz\" \\nHere, if we consider \\'d\\' as 1 and \\'z\\' as -1, by scanning from left to right, we see that the string begins with \\'d\\', and so our variance starts with 1 and keeps decreasing with every \\'z\\' encountered, which gives us a minimal variance of -3. If we reverse the string, we get \"zzzzd\", and now our variance starts with -1 and keeps increasing with every \\'z\\', giving us a maximal variance of -1, which is greater than the original minimal variance of -3.\\n\\n2. \"zzzzd\"\\nHere, if we consider \\'d\\' as 1 and \\'z\\' as -1, by scanning from left to right, our variance starts with -1 and keeps decreasing with every \\'z\\', which gives us a minimal variance of -4. If we reverse the string, we get \"dzzzz\", and now our variance starts with 1 and keeps decreasing with every \\'z\\', giving us a maximal variance of -3, which is greater than the original minimal variance of -4.\\n\\nSo, by reversing the string, we can ensure that we always start with the second character and hence are able to find a maximal variance when the second character appears before the first character in the original string.\\n\\nHowever, in your implementation, you would need to implement both checks, one for the original string and another for the reversed string, and then take the maximum variance found in both checks as the answer."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Dry run these two cases : \"dzzzz\" and \"zzzzd\",with reversing the string and without reversing, you will figure out."
                    },
                    {
                        "username": "Thomaswang0822",
                        "content": "WTH Python submission threw a TLE on an empty input for the last test case."
                    },
                    {
                        "username": "ZQGao",
                        "content": "Why python TLE with 26 * 26 * n algorithm?\\n```python\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        ans = 0\\n        for i in range(26):\\n            for j in range(26):\\n                if i == j:\\n                    continue\\n                diff = 0\\n                diffWithJ = float(\\'-inf\\')\\n                for k in range(len(s)):\\n                    if s[k] == chr(i + ord(\\'a\\')):\\n                        diff += 1\\n                        diffWithJ += 1\\n                    elif s[k] == chr(j + ord(\\'a\\')):\\n                        diff -= 1\\n                        diffWithJ = diff\\n                    if diff < 0:\\n                        diff = 0\\n                        diffWithJ = -1\\n                    if diffWithJ > ans:\\n                        ans = diffWithJ\\n\\n        return ans\\n\\n\\n\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your algorithm is O(26 * 26 * n), which should be feasible for n <= 10^5. However, the constant factors in Python are significantly larger than in languages like C++ or Java due to its dynamic typing and other features, so a Python program will often run slower than an equivalent program in C++ or Java.\n\nMoreover, Python's performance can be influenced by many other factors, such as the specific implementation of the Python interpreter you're using, the specific operations you're performing, and how you're using Python's built-in data structures.\n\nThere are ways to optimize Python code to make it run faster, such as using built-in functions and libraries whenever possible, avoiding unnecessary looping, and using efficient data structures.\n\nIn your case, you could try optimizing your code by calculating `chr(i + ord('a'))` and `chr(j + ord('a'))` outside the loop over `k`, to avoid repeating these calculations for every character in the string. Here's a possible way to do that:\n\n```python\nclass Solution:\n    def largestVariance(self, s: str) -> int:\n        ans = 0\n        for i in range(26):\n            for j in range(26):\n                if i == j:\n                    continue\n                char_i = chr(i + ord('a'))\n                char_j = chr(j + ord('a'))\n                diff = 0\n                diffWithJ = float('-inf')\n                for k in range(len(s)):\n                    if s[k] == char_i:\n                        diff += 1\n                        diffWithJ += 1\n                    elif s[k] == char_j:\n                        diff -= 1\n                        diffWithJ = diff\n                    if diff < 0:\n                        diff = 0\n                        diffWithJ = -1\n                    if diffWithJ > ans:\n                        ans = diffWithJ\n\n        return ans\n```\n\nAlso, since the `continue` statement in your `if i == j:` check just skips to the next iteration of the inner loop, you could eliminate this check altogether by changing the range of `j` in the outer loop to `range(i+1, 26)`, assuming `i` and `j` can be the same. "
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "Try to ignore letters that are not present in the string. And also consider using letters directly without calculating chars."
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Wait. Even so, what did the description mean?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference"
                    },
                    {
                        "username": "huikinglam02",
                        "content": "Have to say this question is rather hard haha"
                    },
                    {
                        "username": "voodooism",
                        "content": "I\\'ve read the problem, hints, all the comments here and editorial. Still don\\'t understand the question..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference"
                    },
                    {
                        "username": "psionl0",
                        "content": "136 out of 138 testcases passed. The 137th testcase gave a WRONG ANSWER (85 instead of 86).\\nSince it is virtually impossible to trace through the code with an input of this size, I tried copying the editorial solution just in case there was a subtle fault in my logic.\\nTHE EDITORIAL SOLUTION GIVES THE SAME WRONG ANSWER!\\n\\nCheck Mate. (There goes my streak)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@katalma](/katalma) Actually I converted the code to C as I was copying it (the code is virtually identical). I copy/pasted the Java solution to see if the same error would occur but it didn\\'t. Major Frustration."
                    },
                    {
                        "username": "katalma",
                        "content": "for meg the editorial copy paste worked. At least the Java version. "
                    },
                    {
                        "username": "sector28",
                        "content": "passing 126/135 tests but it\\'s never ending"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "It felt really nice passing 122 / 138 cases on my first attempt when i was so confused about the question guess i understood it right "
                    },
                    {
                        "username": "SabihaKhan",
                        "content": "To have a variance more than 0, a substring must contain 2 diff characters and difference of their number of occurrence should be more than 0.\\nThe difference of their number of occurrence is variance.\\n\\nIn Example 1:\\n\\nInput: s = \"aababbb\"\\nOutput: 3\\n\\nExplanation:\\n- Variance 0 for substrings \"a\", \"aa\", \"ab\", \"abab\", \"aababb\", \"ba\", \"b\", \"bb\", and \"bbb\".->            these substrings either only contain 1 type of characters or contains 2 character with same count. \\n\\n- Variance 1 for substrings \"aab\", \"aba\", \"abb\", \"aabab\", \"ababb\", \"aababbb\", and \"bab\".->  these substring contains 2 diff characters and diff of there occurrence is 1.\\n- Variance 2 for substrings \"aaba\", \"ababbb\", \"abbb\", and\\n \"babb\". -> these substring contains 2 diff characters and diff of there occurrence is 2.\\n- Variance 3 for substring \"babbb\". -> these substring contains 2 diff characters and diff of there occurrence is 3."
                    }
                ]
            },
            {
                "id": 1962706,
                "content": [
                    {
                        "username": "charucjoshi",
                        "content": "Why reverse?\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem of finding the maximum variance between two characters in a string, reversing the string can handle the cases where the second character (character represented by -1) appears before the first character (character represented by 1). \\n\\nLet\\'s take these examples:\\n\\n1. \"dzzzz\" \\nHere, if we consider \\'d\\' as 1 and \\'z\\' as -1, by scanning from left to right, we see that the string begins with \\'d\\', and so our variance starts with 1 and keeps decreasing with every \\'z\\' encountered, which gives us a minimal variance of -3. If we reverse the string, we get \"zzzzd\", and now our variance starts with -1 and keeps increasing with every \\'z\\', giving us a maximal variance of -1, which is greater than the original minimal variance of -3.\\n\\n2. \"zzzzd\"\\nHere, if we consider \\'d\\' as 1 and \\'z\\' as -1, by scanning from left to right, our variance starts with -1 and keeps decreasing with every \\'z\\', which gives us a minimal variance of -4. If we reverse the string, we get \"dzzzz\", and now our variance starts with 1 and keeps decreasing with every \\'z\\', giving us a maximal variance of -3, which is greater than the original minimal variance of -4.\\n\\nSo, by reversing the string, we can ensure that we always start with the second character and hence are able to find a maximal variance when the second character appears before the first character in the original string.\\n\\nHowever, in your implementation, you would need to implement both checks, one for the original string and another for the reversed string, and then take the maximum variance found in both checks as the answer."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Dry run these two cases : \"dzzzz\" and \"zzzzd\",with reversing the string and without reversing, you will figure out."
                    },
                    {
                        "username": "Thomaswang0822",
                        "content": "WTH Python submission threw a TLE on an empty input for the last test case."
                    },
                    {
                        "username": "ZQGao",
                        "content": "Why python TLE with 26 * 26 * n algorithm?\\n```python\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        ans = 0\\n        for i in range(26):\\n            for j in range(26):\\n                if i == j:\\n                    continue\\n                diff = 0\\n                diffWithJ = float(\\'-inf\\')\\n                for k in range(len(s)):\\n                    if s[k] == chr(i + ord(\\'a\\')):\\n                        diff += 1\\n                        diffWithJ += 1\\n                    elif s[k] == chr(j + ord(\\'a\\')):\\n                        diff -= 1\\n                        diffWithJ = diff\\n                    if diff < 0:\\n                        diff = 0\\n                        diffWithJ = -1\\n                    if diffWithJ > ans:\\n                        ans = diffWithJ\\n\\n        return ans\\n\\n\\n\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your algorithm is O(26 * 26 * n), which should be feasible for n <= 10^5. However, the constant factors in Python are significantly larger than in languages like C++ or Java due to its dynamic typing and other features, so a Python program will often run slower than an equivalent program in C++ or Java.\n\nMoreover, Python's performance can be influenced by many other factors, such as the specific implementation of the Python interpreter you're using, the specific operations you're performing, and how you're using Python's built-in data structures.\n\nThere are ways to optimize Python code to make it run faster, such as using built-in functions and libraries whenever possible, avoiding unnecessary looping, and using efficient data structures.\n\nIn your case, you could try optimizing your code by calculating `chr(i + ord('a'))` and `chr(j + ord('a'))` outside the loop over `k`, to avoid repeating these calculations for every character in the string. Here's a possible way to do that:\n\n```python\nclass Solution:\n    def largestVariance(self, s: str) -> int:\n        ans = 0\n        for i in range(26):\n            for j in range(26):\n                if i == j:\n                    continue\n                char_i = chr(i + ord('a'))\n                char_j = chr(j + ord('a'))\n                diff = 0\n                diffWithJ = float('-inf')\n                for k in range(len(s)):\n                    if s[k] == char_i:\n                        diff += 1\n                        diffWithJ += 1\n                    elif s[k] == char_j:\n                        diff -= 1\n                        diffWithJ = diff\n                    if diff < 0:\n                        diff = 0\n                        diffWithJ = -1\n                    if diffWithJ > ans:\n                        ans = diffWithJ\n\n        return ans\n```\n\nAlso, since the `continue` statement in your `if i == j:` check just skips to the next iteration of the inner loop, you could eliminate this check altogether by changing the range of `j` in the outer loop to `range(i+1, 26)`, assuming `i` and `j` can be the same. "
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "Try to ignore letters that are not present in the string. And also consider using letters directly without calculating chars."
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Wait. Even so, what did the description mean?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference"
                    },
                    {
                        "username": "huikinglam02",
                        "content": "Have to say this question is rather hard haha"
                    },
                    {
                        "username": "voodooism",
                        "content": "I\\'ve read the problem, hints, all the comments here and editorial. Still don\\'t understand the question..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference"
                    },
                    {
                        "username": "psionl0",
                        "content": "136 out of 138 testcases passed. The 137th testcase gave a WRONG ANSWER (85 instead of 86).\\nSince it is virtually impossible to trace through the code with an input of this size, I tried copying the editorial solution just in case there was a subtle fault in my logic.\\nTHE EDITORIAL SOLUTION GIVES THE SAME WRONG ANSWER!\\n\\nCheck Mate. (There goes my streak)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@katalma](/katalma) Actually I converted the code to C as I was copying it (the code is virtually identical). I copy/pasted the Java solution to see if the same error would occur but it didn\\'t. Major Frustration."
                    },
                    {
                        "username": "katalma",
                        "content": "for meg the editorial copy paste worked. At least the Java version. "
                    },
                    {
                        "username": "sector28",
                        "content": "passing 126/135 tests but it\\'s never ending"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "It felt really nice passing 122 / 138 cases on my first attempt when i was so confused about the question guess i understood it right "
                    },
                    {
                        "username": "SabihaKhan",
                        "content": "To have a variance more than 0, a substring must contain 2 diff characters and difference of their number of occurrence should be more than 0.\\nThe difference of their number of occurrence is variance.\\n\\nIn Example 1:\\n\\nInput: s = \"aababbb\"\\nOutput: 3\\n\\nExplanation:\\n- Variance 0 for substrings \"a\", \"aa\", \"ab\", \"abab\", \"aababb\", \"ba\", \"b\", \"bb\", and \"bbb\".->            these substrings either only contain 1 type of characters or contains 2 character with same count. \\n\\n- Variance 1 for substrings \"aab\", \"aba\", \"abb\", \"aabab\", \"ababb\", \"aababbb\", and \"bab\".->  these substring contains 2 diff characters and diff of there occurrence is 1.\\n- Variance 2 for substrings \"aaba\", \"ababbb\", \"abbb\", and\\n \"babb\". -> these substring contains 2 diff characters and diff of there occurrence is 2.\\n- Variance 3 for substring \"babbb\". -> these substring contains 2 diff characters and diff of there occurrence is 3."
                    }
                ]
            },
            {
                "id": 1962699,
                "content": [
                    {
                        "username": "charucjoshi",
                        "content": "Why reverse?\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem of finding the maximum variance between two characters in a string, reversing the string can handle the cases where the second character (character represented by -1) appears before the first character (character represented by 1). \\n\\nLet\\'s take these examples:\\n\\n1. \"dzzzz\" \\nHere, if we consider \\'d\\' as 1 and \\'z\\' as -1, by scanning from left to right, we see that the string begins with \\'d\\', and so our variance starts with 1 and keeps decreasing with every \\'z\\' encountered, which gives us a minimal variance of -3. If we reverse the string, we get \"zzzzd\", and now our variance starts with -1 and keeps increasing with every \\'z\\', giving us a maximal variance of -1, which is greater than the original minimal variance of -3.\\n\\n2. \"zzzzd\"\\nHere, if we consider \\'d\\' as 1 and \\'z\\' as -1, by scanning from left to right, our variance starts with -1 and keeps decreasing with every \\'z\\', which gives us a minimal variance of -4. If we reverse the string, we get \"dzzzz\", and now our variance starts with 1 and keeps decreasing with every \\'z\\', giving us a maximal variance of -3, which is greater than the original minimal variance of -4.\\n\\nSo, by reversing the string, we can ensure that we always start with the second character and hence are able to find a maximal variance when the second character appears before the first character in the original string.\\n\\nHowever, in your implementation, you would need to implement both checks, one for the original string and another for the reversed string, and then take the maximum variance found in both checks as the answer."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Dry run these two cases : \"dzzzz\" and \"zzzzd\",with reversing the string and without reversing, you will figure out."
                    },
                    {
                        "username": "Thomaswang0822",
                        "content": "WTH Python submission threw a TLE on an empty input for the last test case."
                    },
                    {
                        "username": "ZQGao",
                        "content": "Why python TLE with 26 * 26 * n algorithm?\\n```python\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        ans = 0\\n        for i in range(26):\\n            for j in range(26):\\n                if i == j:\\n                    continue\\n                diff = 0\\n                diffWithJ = float(\\'-inf\\')\\n                for k in range(len(s)):\\n                    if s[k] == chr(i + ord(\\'a\\')):\\n                        diff += 1\\n                        diffWithJ += 1\\n                    elif s[k] == chr(j + ord(\\'a\\')):\\n                        diff -= 1\\n                        diffWithJ = diff\\n                    if diff < 0:\\n                        diff = 0\\n                        diffWithJ = -1\\n                    if diffWithJ > ans:\\n                        ans = diffWithJ\\n\\n        return ans\\n\\n\\n\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your algorithm is O(26 * 26 * n), which should be feasible for n <= 10^5. However, the constant factors in Python are significantly larger than in languages like C++ or Java due to its dynamic typing and other features, so a Python program will often run slower than an equivalent program in C++ or Java.\n\nMoreover, Python's performance can be influenced by many other factors, such as the specific implementation of the Python interpreter you're using, the specific operations you're performing, and how you're using Python's built-in data structures.\n\nThere are ways to optimize Python code to make it run faster, such as using built-in functions and libraries whenever possible, avoiding unnecessary looping, and using efficient data structures.\n\nIn your case, you could try optimizing your code by calculating `chr(i + ord('a'))` and `chr(j + ord('a'))` outside the loop over `k`, to avoid repeating these calculations for every character in the string. Here's a possible way to do that:\n\n```python\nclass Solution:\n    def largestVariance(self, s: str) -> int:\n        ans = 0\n        for i in range(26):\n            for j in range(26):\n                if i == j:\n                    continue\n                char_i = chr(i + ord('a'))\n                char_j = chr(j + ord('a'))\n                diff = 0\n                diffWithJ = float('-inf')\n                for k in range(len(s)):\n                    if s[k] == char_i:\n                        diff += 1\n                        diffWithJ += 1\n                    elif s[k] == char_j:\n                        diff -= 1\n                        diffWithJ = diff\n                    if diff < 0:\n                        diff = 0\n                        diffWithJ = -1\n                    if diffWithJ > ans:\n                        ans = diffWithJ\n\n        return ans\n```\n\nAlso, since the `continue` statement in your `if i == j:` check just skips to the next iteration of the inner loop, you could eliminate this check altogether by changing the range of `j` in the outer loop to `range(i+1, 26)`, assuming `i` and `j` can be the same. "
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "Try to ignore letters that are not present in the string. And also consider using letters directly without calculating chars."
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Wait. Even so, what did the description mean?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference"
                    },
                    {
                        "username": "huikinglam02",
                        "content": "Have to say this question is rather hard haha"
                    },
                    {
                        "username": "voodooism",
                        "content": "I\\'ve read the problem, hints, all the comments here and editorial. Still don\\'t understand the question..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference"
                    },
                    {
                        "username": "psionl0",
                        "content": "136 out of 138 testcases passed. The 137th testcase gave a WRONG ANSWER (85 instead of 86).\\nSince it is virtually impossible to trace through the code with an input of this size, I tried copying the editorial solution just in case there was a subtle fault in my logic.\\nTHE EDITORIAL SOLUTION GIVES THE SAME WRONG ANSWER!\\n\\nCheck Mate. (There goes my streak)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@katalma](/katalma) Actually I converted the code to C as I was copying it (the code is virtually identical). I copy/pasted the Java solution to see if the same error would occur but it didn\\'t. Major Frustration."
                    },
                    {
                        "username": "katalma",
                        "content": "for meg the editorial copy paste worked. At least the Java version. "
                    },
                    {
                        "username": "sector28",
                        "content": "passing 126/135 tests but it\\'s never ending"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "It felt really nice passing 122 / 138 cases on my first attempt when i was so confused about the question guess i understood it right "
                    },
                    {
                        "username": "SabihaKhan",
                        "content": "To have a variance more than 0, a substring must contain 2 diff characters and difference of their number of occurrence should be more than 0.\\nThe difference of their number of occurrence is variance.\\n\\nIn Example 1:\\n\\nInput: s = \"aababbb\"\\nOutput: 3\\n\\nExplanation:\\n- Variance 0 for substrings \"a\", \"aa\", \"ab\", \"abab\", \"aababb\", \"ba\", \"b\", \"bb\", and \"bbb\".->            these substrings either only contain 1 type of characters or contains 2 character with same count. \\n\\n- Variance 1 for substrings \"aab\", \"aba\", \"abb\", \"aabab\", \"ababb\", \"aababbb\", and \"bab\".->  these substring contains 2 diff characters and diff of there occurrence is 1.\\n- Variance 2 for substrings \"aaba\", \"ababbb\", \"abbb\", and\\n \"babb\". -> these substring contains 2 diff characters and diff of there occurrence is 2.\\n- Variance 3 for substring \"babbb\". -> these substring contains 2 diff characters and diff of there occurrence is 3."
                    }
                ]
            },
            {
                "id": 1962638,
                "content": [
                    {
                        "username": "charucjoshi",
                        "content": "Why reverse?\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem of finding the maximum variance between two characters in a string, reversing the string can handle the cases where the second character (character represented by -1) appears before the first character (character represented by 1). \\n\\nLet\\'s take these examples:\\n\\n1. \"dzzzz\" \\nHere, if we consider \\'d\\' as 1 and \\'z\\' as -1, by scanning from left to right, we see that the string begins with \\'d\\', and so our variance starts with 1 and keeps decreasing with every \\'z\\' encountered, which gives us a minimal variance of -3. If we reverse the string, we get \"zzzzd\", and now our variance starts with -1 and keeps increasing with every \\'z\\', giving us a maximal variance of -1, which is greater than the original minimal variance of -3.\\n\\n2. \"zzzzd\"\\nHere, if we consider \\'d\\' as 1 and \\'z\\' as -1, by scanning from left to right, our variance starts with -1 and keeps decreasing with every \\'z\\', which gives us a minimal variance of -4. If we reverse the string, we get \"dzzzz\", and now our variance starts with 1 and keeps decreasing with every \\'z\\', giving us a maximal variance of -3, which is greater than the original minimal variance of -4.\\n\\nSo, by reversing the string, we can ensure that we always start with the second character and hence are able to find a maximal variance when the second character appears before the first character in the original string.\\n\\nHowever, in your implementation, you would need to implement both checks, one for the original string and another for the reversed string, and then take the maximum variance found in both checks as the answer."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Dry run these two cases : \"dzzzz\" and \"zzzzd\",with reversing the string and without reversing, you will figure out."
                    },
                    {
                        "username": "Thomaswang0822",
                        "content": "WTH Python submission threw a TLE on an empty input for the last test case."
                    },
                    {
                        "username": "ZQGao",
                        "content": "Why python TLE with 26 * 26 * n algorithm?\\n```python\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        ans = 0\\n        for i in range(26):\\n            for j in range(26):\\n                if i == j:\\n                    continue\\n                diff = 0\\n                diffWithJ = float(\\'-inf\\')\\n                for k in range(len(s)):\\n                    if s[k] == chr(i + ord(\\'a\\')):\\n                        diff += 1\\n                        diffWithJ += 1\\n                    elif s[k] == chr(j + ord(\\'a\\')):\\n                        diff -= 1\\n                        diffWithJ = diff\\n                    if diff < 0:\\n                        diff = 0\\n                        diffWithJ = -1\\n                    if diffWithJ > ans:\\n                        ans = diffWithJ\\n\\n        return ans\\n\\n\\n\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your algorithm is O(26 * 26 * n), which should be feasible for n <= 10^5. However, the constant factors in Python are significantly larger than in languages like C++ or Java due to its dynamic typing and other features, so a Python program will often run slower than an equivalent program in C++ or Java.\n\nMoreover, Python's performance can be influenced by many other factors, such as the specific implementation of the Python interpreter you're using, the specific operations you're performing, and how you're using Python's built-in data structures.\n\nThere are ways to optimize Python code to make it run faster, such as using built-in functions and libraries whenever possible, avoiding unnecessary looping, and using efficient data structures.\n\nIn your case, you could try optimizing your code by calculating `chr(i + ord('a'))` and `chr(j + ord('a'))` outside the loop over `k`, to avoid repeating these calculations for every character in the string. Here's a possible way to do that:\n\n```python\nclass Solution:\n    def largestVariance(self, s: str) -> int:\n        ans = 0\n        for i in range(26):\n            for j in range(26):\n                if i == j:\n                    continue\n                char_i = chr(i + ord('a'))\n                char_j = chr(j + ord('a'))\n                diff = 0\n                diffWithJ = float('-inf')\n                for k in range(len(s)):\n                    if s[k] == char_i:\n                        diff += 1\n                        diffWithJ += 1\n                    elif s[k] == char_j:\n                        diff -= 1\n                        diffWithJ = diff\n                    if diff < 0:\n                        diff = 0\n                        diffWithJ = -1\n                    if diffWithJ > ans:\n                        ans = diffWithJ\n\n        return ans\n```\n\nAlso, since the `continue` statement in your `if i == j:` check just skips to the next iteration of the inner loop, you could eliminate this check altogether by changing the range of `j` in the outer loop to `range(i+1, 26)`, assuming `i` and `j` can be the same. "
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "Try to ignore letters that are not present in the string. And also consider using letters directly without calculating chars."
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Wait. Even so, what did the description mean?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference"
                    },
                    {
                        "username": "huikinglam02",
                        "content": "Have to say this question is rather hard haha"
                    },
                    {
                        "username": "voodooism",
                        "content": "I\\'ve read the problem, hints, all the comments here and editorial. Still don\\'t understand the question..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference"
                    },
                    {
                        "username": "psionl0",
                        "content": "136 out of 138 testcases passed. The 137th testcase gave a WRONG ANSWER (85 instead of 86).\\nSince it is virtually impossible to trace through the code with an input of this size, I tried copying the editorial solution just in case there was a subtle fault in my logic.\\nTHE EDITORIAL SOLUTION GIVES THE SAME WRONG ANSWER!\\n\\nCheck Mate. (There goes my streak)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@katalma](/katalma) Actually I converted the code to C as I was copying it (the code is virtually identical). I copy/pasted the Java solution to see if the same error would occur but it didn\\'t. Major Frustration."
                    },
                    {
                        "username": "katalma",
                        "content": "for meg the editorial copy paste worked. At least the Java version. "
                    },
                    {
                        "username": "sector28",
                        "content": "passing 126/135 tests but it\\'s never ending"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "It felt really nice passing 122 / 138 cases on my first attempt when i was so confused about the question guess i understood it right "
                    },
                    {
                        "username": "SabihaKhan",
                        "content": "To have a variance more than 0, a substring must contain 2 diff characters and difference of their number of occurrence should be more than 0.\\nThe difference of their number of occurrence is variance.\\n\\nIn Example 1:\\n\\nInput: s = \"aababbb\"\\nOutput: 3\\n\\nExplanation:\\n- Variance 0 for substrings \"a\", \"aa\", \"ab\", \"abab\", \"aababb\", \"ba\", \"b\", \"bb\", and \"bbb\".->            these substrings either only contain 1 type of characters or contains 2 character with same count. \\n\\n- Variance 1 for substrings \"aab\", \"aba\", \"abb\", \"aabab\", \"ababb\", \"aababbb\", and \"bab\".->  these substring contains 2 diff characters and diff of there occurrence is 1.\\n- Variance 2 for substrings \"aaba\", \"ababbb\", \"abbb\", and\\n \"babb\". -> these substring contains 2 diff characters and diff of there occurrence is 2.\\n- Variance 3 for substring \"babbb\". -> these substring contains 2 diff characters and diff of there occurrence is 3."
                    }
                ]
            },
            {
                "id": 1962581,
                "content": [
                    {
                        "username": "charucjoshi",
                        "content": "Why reverse?\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem of finding the maximum variance between two characters in a string, reversing the string can handle the cases where the second character (character represented by -1) appears before the first character (character represented by 1). \\n\\nLet\\'s take these examples:\\n\\n1. \"dzzzz\" \\nHere, if we consider \\'d\\' as 1 and \\'z\\' as -1, by scanning from left to right, we see that the string begins with \\'d\\', and so our variance starts with 1 and keeps decreasing with every \\'z\\' encountered, which gives us a minimal variance of -3. If we reverse the string, we get \"zzzzd\", and now our variance starts with -1 and keeps increasing with every \\'z\\', giving us a maximal variance of -1, which is greater than the original minimal variance of -3.\\n\\n2. \"zzzzd\"\\nHere, if we consider \\'d\\' as 1 and \\'z\\' as -1, by scanning from left to right, our variance starts with -1 and keeps decreasing with every \\'z\\', which gives us a minimal variance of -4. If we reverse the string, we get \"dzzzz\", and now our variance starts with 1 and keeps decreasing with every \\'z\\', giving us a maximal variance of -3, which is greater than the original minimal variance of -4.\\n\\nSo, by reversing the string, we can ensure that we always start with the second character and hence are able to find a maximal variance when the second character appears before the first character in the original string.\\n\\nHowever, in your implementation, you would need to implement both checks, one for the original string and another for the reversed string, and then take the maximum variance found in both checks as the answer."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Dry run these two cases : \"dzzzz\" and \"zzzzd\",with reversing the string and without reversing, you will figure out."
                    },
                    {
                        "username": "Thomaswang0822",
                        "content": "WTH Python submission threw a TLE on an empty input for the last test case."
                    },
                    {
                        "username": "ZQGao",
                        "content": "Why python TLE with 26 * 26 * n algorithm?\\n```python\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        ans = 0\\n        for i in range(26):\\n            for j in range(26):\\n                if i == j:\\n                    continue\\n                diff = 0\\n                diffWithJ = float(\\'-inf\\')\\n                for k in range(len(s)):\\n                    if s[k] == chr(i + ord(\\'a\\')):\\n                        diff += 1\\n                        diffWithJ += 1\\n                    elif s[k] == chr(j + ord(\\'a\\')):\\n                        diff -= 1\\n                        diffWithJ = diff\\n                    if diff < 0:\\n                        diff = 0\\n                        diffWithJ = -1\\n                    if diffWithJ > ans:\\n                        ans = diffWithJ\\n\\n        return ans\\n\\n\\n\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your algorithm is O(26 * 26 * n), which should be feasible for n <= 10^5. However, the constant factors in Python are significantly larger than in languages like C++ or Java due to its dynamic typing and other features, so a Python program will often run slower than an equivalent program in C++ or Java.\n\nMoreover, Python's performance can be influenced by many other factors, such as the specific implementation of the Python interpreter you're using, the specific operations you're performing, and how you're using Python's built-in data structures.\n\nThere are ways to optimize Python code to make it run faster, such as using built-in functions and libraries whenever possible, avoiding unnecessary looping, and using efficient data structures.\n\nIn your case, you could try optimizing your code by calculating `chr(i + ord('a'))` and `chr(j + ord('a'))` outside the loop over `k`, to avoid repeating these calculations for every character in the string. Here's a possible way to do that:\n\n```python\nclass Solution:\n    def largestVariance(self, s: str) -> int:\n        ans = 0\n        for i in range(26):\n            for j in range(26):\n                if i == j:\n                    continue\n                char_i = chr(i + ord('a'))\n                char_j = chr(j + ord('a'))\n                diff = 0\n                diffWithJ = float('-inf')\n                for k in range(len(s)):\n                    if s[k] == char_i:\n                        diff += 1\n                        diffWithJ += 1\n                    elif s[k] == char_j:\n                        diff -= 1\n                        diffWithJ = diff\n                    if diff < 0:\n                        diff = 0\n                        diffWithJ = -1\n                    if diffWithJ > ans:\n                        ans = diffWithJ\n\n        return ans\n```\n\nAlso, since the `continue` statement in your `if i == j:` check just skips to the next iteration of the inner loop, you could eliminate this check altogether by changing the range of `j` in the outer loop to `range(i+1, 26)`, assuming `i` and `j` can be the same. "
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "Try to ignore letters that are not present in the string. And also consider using letters directly without calculating chars."
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Wait. Even so, what did the description mean?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference"
                    },
                    {
                        "username": "huikinglam02",
                        "content": "Have to say this question is rather hard haha"
                    },
                    {
                        "username": "voodooism",
                        "content": "I\\'ve read the problem, hints, all the comments here and editorial. Still don\\'t understand the question..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference"
                    },
                    {
                        "username": "psionl0",
                        "content": "136 out of 138 testcases passed. The 137th testcase gave a WRONG ANSWER (85 instead of 86).\\nSince it is virtually impossible to trace through the code with an input of this size, I tried copying the editorial solution just in case there was a subtle fault in my logic.\\nTHE EDITORIAL SOLUTION GIVES THE SAME WRONG ANSWER!\\n\\nCheck Mate. (There goes my streak)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@katalma](/katalma) Actually I converted the code to C as I was copying it (the code is virtually identical). I copy/pasted the Java solution to see if the same error would occur but it didn\\'t. Major Frustration."
                    },
                    {
                        "username": "katalma",
                        "content": "for meg the editorial copy paste worked. At least the Java version. "
                    },
                    {
                        "username": "sector28",
                        "content": "passing 126/135 tests but it\\'s never ending"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "It felt really nice passing 122 / 138 cases on my first attempt when i was so confused about the question guess i understood it right "
                    },
                    {
                        "username": "SabihaKhan",
                        "content": "To have a variance more than 0, a substring must contain 2 diff characters and difference of their number of occurrence should be more than 0.\\nThe difference of their number of occurrence is variance.\\n\\nIn Example 1:\\n\\nInput: s = \"aababbb\"\\nOutput: 3\\n\\nExplanation:\\n- Variance 0 for substrings \"a\", \"aa\", \"ab\", \"abab\", \"aababb\", \"ba\", \"b\", \"bb\", and \"bbb\".->            these substrings either only contain 1 type of characters or contains 2 character with same count. \\n\\n- Variance 1 for substrings \"aab\", \"aba\", \"abb\", \"aabab\", \"ababb\", \"aababbb\", and \"bab\".->  these substring contains 2 diff characters and diff of there occurrence is 1.\\n- Variance 2 for substrings \"aaba\", \"ababbb\", \"abbb\", and\\n \"babb\". -> these substring contains 2 diff characters and diff of there occurrence is 2.\\n- Variance 3 for substring \"babbb\". -> these substring contains 2 diff characters and diff of there occurrence is 3."
                    }
                ]
            },
            {
                "id": 1962527,
                "content": [
                    {
                        "username": "charucjoshi",
                        "content": "Why reverse?\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem of finding the maximum variance between two characters in a string, reversing the string can handle the cases where the second character (character represented by -1) appears before the first character (character represented by 1). \\n\\nLet\\'s take these examples:\\n\\n1. \"dzzzz\" \\nHere, if we consider \\'d\\' as 1 and \\'z\\' as -1, by scanning from left to right, we see that the string begins with \\'d\\', and so our variance starts with 1 and keeps decreasing with every \\'z\\' encountered, which gives us a minimal variance of -3. If we reverse the string, we get \"zzzzd\", and now our variance starts with -1 and keeps increasing with every \\'z\\', giving us a maximal variance of -1, which is greater than the original minimal variance of -3.\\n\\n2. \"zzzzd\"\\nHere, if we consider \\'d\\' as 1 and \\'z\\' as -1, by scanning from left to right, our variance starts with -1 and keeps decreasing with every \\'z\\', which gives us a minimal variance of -4. If we reverse the string, we get \"dzzzz\", and now our variance starts with 1 and keeps decreasing with every \\'z\\', giving us a maximal variance of -3, which is greater than the original minimal variance of -4.\\n\\nSo, by reversing the string, we can ensure that we always start with the second character and hence are able to find a maximal variance when the second character appears before the first character in the original string.\\n\\nHowever, in your implementation, you would need to implement both checks, one for the original string and another for the reversed string, and then take the maximum variance found in both checks as the answer."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Dry run these two cases : \"dzzzz\" and \"zzzzd\",with reversing the string and without reversing, you will figure out."
                    },
                    {
                        "username": "Thomaswang0822",
                        "content": "WTH Python submission threw a TLE on an empty input for the last test case."
                    },
                    {
                        "username": "ZQGao",
                        "content": "Why python TLE with 26 * 26 * n algorithm?\\n```python\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        ans = 0\\n        for i in range(26):\\n            for j in range(26):\\n                if i == j:\\n                    continue\\n                diff = 0\\n                diffWithJ = float(\\'-inf\\')\\n                for k in range(len(s)):\\n                    if s[k] == chr(i + ord(\\'a\\')):\\n                        diff += 1\\n                        diffWithJ += 1\\n                    elif s[k] == chr(j + ord(\\'a\\')):\\n                        diff -= 1\\n                        diffWithJ = diff\\n                    if diff < 0:\\n                        diff = 0\\n                        diffWithJ = -1\\n                    if diffWithJ > ans:\\n                        ans = diffWithJ\\n\\n        return ans\\n\\n\\n\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your algorithm is O(26 * 26 * n), which should be feasible for n <= 10^5. However, the constant factors in Python are significantly larger than in languages like C++ or Java due to its dynamic typing and other features, so a Python program will often run slower than an equivalent program in C++ or Java.\n\nMoreover, Python's performance can be influenced by many other factors, such as the specific implementation of the Python interpreter you're using, the specific operations you're performing, and how you're using Python's built-in data structures.\n\nThere are ways to optimize Python code to make it run faster, such as using built-in functions and libraries whenever possible, avoiding unnecessary looping, and using efficient data structures.\n\nIn your case, you could try optimizing your code by calculating `chr(i + ord('a'))` and `chr(j + ord('a'))` outside the loop over `k`, to avoid repeating these calculations for every character in the string. Here's a possible way to do that:\n\n```python\nclass Solution:\n    def largestVariance(self, s: str) -> int:\n        ans = 0\n        for i in range(26):\n            for j in range(26):\n                if i == j:\n                    continue\n                char_i = chr(i + ord('a'))\n                char_j = chr(j + ord('a'))\n                diff = 0\n                diffWithJ = float('-inf')\n                for k in range(len(s)):\n                    if s[k] == char_i:\n                        diff += 1\n                        diffWithJ += 1\n                    elif s[k] == char_j:\n                        diff -= 1\n                        diffWithJ = diff\n                    if diff < 0:\n                        diff = 0\n                        diffWithJ = -1\n                    if diffWithJ > ans:\n                        ans = diffWithJ\n\n        return ans\n```\n\nAlso, since the `continue` statement in your `if i == j:` check just skips to the next iteration of the inner loop, you could eliminate this check altogether by changing the range of `j` in the outer loop to `range(i+1, 26)`, assuming `i` and `j` can be the same. "
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "Try to ignore letters that are not present in the string. And also consider using letters directly without calculating chars."
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Wait. Even so, what did the description mean?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference"
                    },
                    {
                        "username": "huikinglam02",
                        "content": "Have to say this question is rather hard haha"
                    },
                    {
                        "username": "voodooism",
                        "content": "I\\'ve read the problem, hints, all the comments here and editorial. Still don\\'t understand the question..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference"
                    },
                    {
                        "username": "psionl0",
                        "content": "136 out of 138 testcases passed. The 137th testcase gave a WRONG ANSWER (85 instead of 86).\\nSince it is virtually impossible to trace through the code with an input of this size, I tried copying the editorial solution just in case there was a subtle fault in my logic.\\nTHE EDITORIAL SOLUTION GIVES THE SAME WRONG ANSWER!\\n\\nCheck Mate. (There goes my streak)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@katalma](/katalma) Actually I converted the code to C as I was copying it (the code is virtually identical). I copy/pasted the Java solution to see if the same error would occur but it didn\\'t. Major Frustration."
                    },
                    {
                        "username": "katalma",
                        "content": "for meg the editorial copy paste worked. At least the Java version. "
                    },
                    {
                        "username": "sector28",
                        "content": "passing 126/135 tests but it\\'s never ending"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "It felt really nice passing 122 / 138 cases on my first attempt when i was so confused about the question guess i understood it right "
                    },
                    {
                        "username": "SabihaKhan",
                        "content": "To have a variance more than 0, a substring must contain 2 diff characters and difference of their number of occurrence should be more than 0.\\nThe difference of their number of occurrence is variance.\\n\\nIn Example 1:\\n\\nInput: s = \"aababbb\"\\nOutput: 3\\n\\nExplanation:\\n- Variance 0 for substrings \"a\", \"aa\", \"ab\", \"abab\", \"aababb\", \"ba\", \"b\", \"bb\", and \"bbb\".->            these substrings either only contain 1 type of characters or contains 2 character with same count. \\n\\n- Variance 1 for substrings \"aab\", \"aba\", \"abb\", \"aabab\", \"ababb\", \"aababbb\", and \"bab\".->  these substring contains 2 diff characters and diff of there occurrence is 1.\\n- Variance 2 for substrings \"aaba\", \"ababbb\", \"abbb\", and\\n \"babb\". -> these substring contains 2 diff characters and diff of there occurrence is 2.\\n- Variance 3 for substring \"babbb\". -> these substring contains 2 diff characters and diff of there occurrence is 3."
                    }
                ]
            },
            {
                "id": 1962521,
                "content": [
                    {
                        "username": "charucjoshi",
                        "content": "Why reverse?\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem of finding the maximum variance between two characters in a string, reversing the string can handle the cases where the second character (character represented by -1) appears before the first character (character represented by 1). \\n\\nLet\\'s take these examples:\\n\\n1. \"dzzzz\" \\nHere, if we consider \\'d\\' as 1 and \\'z\\' as -1, by scanning from left to right, we see that the string begins with \\'d\\', and so our variance starts with 1 and keeps decreasing with every \\'z\\' encountered, which gives us a minimal variance of -3. If we reverse the string, we get \"zzzzd\", and now our variance starts with -1 and keeps increasing with every \\'z\\', giving us a maximal variance of -1, which is greater than the original minimal variance of -3.\\n\\n2. \"zzzzd\"\\nHere, if we consider \\'d\\' as 1 and \\'z\\' as -1, by scanning from left to right, our variance starts with -1 and keeps decreasing with every \\'z\\', which gives us a minimal variance of -4. If we reverse the string, we get \"dzzzz\", and now our variance starts with 1 and keeps decreasing with every \\'z\\', giving us a maximal variance of -3, which is greater than the original minimal variance of -4.\\n\\nSo, by reversing the string, we can ensure that we always start with the second character and hence are able to find a maximal variance when the second character appears before the first character in the original string.\\n\\nHowever, in your implementation, you would need to implement both checks, one for the original string and another for the reversed string, and then take the maximum variance found in both checks as the answer."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Dry run these two cases : \"dzzzz\" and \"zzzzd\",with reversing the string and without reversing, you will figure out."
                    },
                    {
                        "username": "Thomaswang0822",
                        "content": "WTH Python submission threw a TLE on an empty input for the last test case."
                    },
                    {
                        "username": "ZQGao",
                        "content": "Why python TLE with 26 * 26 * n algorithm?\\n```python\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def largestVariance(self, s: str) -> int:\\n        ans = 0\\n        for i in range(26):\\n            for j in range(26):\\n                if i == j:\\n                    continue\\n                diff = 0\\n                diffWithJ = float(\\'-inf\\')\\n                for k in range(len(s)):\\n                    if s[k] == chr(i + ord(\\'a\\')):\\n                        diff += 1\\n                        diffWithJ += 1\\n                    elif s[k] == chr(j + ord(\\'a\\')):\\n                        diff -= 1\\n                        diffWithJ = diff\\n                    if diff < 0:\\n                        diff = 0\\n                        diffWithJ = -1\\n                    if diffWithJ > ans:\\n                        ans = diffWithJ\\n\\n        return ans\\n\\n\\n\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your algorithm is O(26 * 26 * n), which should be feasible for n <= 10^5. However, the constant factors in Python are significantly larger than in languages like C++ or Java due to its dynamic typing and other features, so a Python program will often run slower than an equivalent program in C++ or Java.\n\nMoreover, Python's performance can be influenced by many other factors, such as the specific implementation of the Python interpreter you're using, the specific operations you're performing, and how you're using Python's built-in data structures.\n\nThere are ways to optimize Python code to make it run faster, such as using built-in functions and libraries whenever possible, avoiding unnecessary looping, and using efficient data structures.\n\nIn your case, you could try optimizing your code by calculating `chr(i + ord('a'))` and `chr(j + ord('a'))` outside the loop over `k`, to avoid repeating these calculations for every character in the string. Here's a possible way to do that:\n\n```python\nclass Solution:\n    def largestVariance(self, s: str) -> int:\n        ans = 0\n        for i in range(26):\n            for j in range(26):\n                if i == j:\n                    continue\n                char_i = chr(i + ord('a'))\n                char_j = chr(j + ord('a'))\n                diff = 0\n                diffWithJ = float('-inf')\n                for k in range(len(s)):\n                    if s[k] == char_i:\n                        diff += 1\n                        diffWithJ += 1\n                    elif s[k] == char_j:\n                        diff -= 1\n                        diffWithJ = diff\n                    if diff < 0:\n                        diff = 0\n                        diffWithJ = -1\n                    if diffWithJ > ans:\n                        ans = diffWithJ\n\n        return ans\n```\n\nAlso, since the `continue` statement in your `if i == j:` check just skips to the next iteration of the inner loop, you could eliminate this check altogether by changing the range of `j` in the outer loop to `range(i+1, 26)`, assuming `i` and `j` can be the same. "
                    },
                    {
                        "username": "AndreiNepsha",
                        "content": "Try to ignore letters that are not present in the string. And also consider using letters directly without calculating chars."
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Wait. Even so, what did the description mean?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference"
                    },
                    {
                        "username": "huikinglam02",
                        "content": "Have to say this question is rather hard haha"
                    },
                    {
                        "username": "voodooism",
                        "content": "I\\'ve read the problem, hints, all the comments here and editorial. Still don\\'t understand the question..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Find the subString with the highest difference between the most frequent and the least frequent element in that substring and return that difference"
                    },
                    {
                        "username": "psionl0",
                        "content": "136 out of 138 testcases passed. The 137th testcase gave a WRONG ANSWER (85 instead of 86).\\nSince it is virtually impossible to trace through the code with an input of this size, I tried copying the editorial solution just in case there was a subtle fault in my logic.\\nTHE EDITORIAL SOLUTION GIVES THE SAME WRONG ANSWER!\\n\\nCheck Mate. (There goes my streak)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@katalma](/katalma) Actually I converted the code to C as I was copying it (the code is virtually identical). I copy/pasted the Java solution to see if the same error would occur but it didn\\'t. Major Frustration."
                    },
                    {
                        "username": "katalma",
                        "content": "for meg the editorial copy paste worked. At least the Java version. "
                    },
                    {
                        "username": "sector28",
                        "content": "passing 126/135 tests but it\\'s never ending"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "It felt really nice passing 122 / 138 cases on my first attempt when i was so confused about the question guess i understood it right "
                    },
                    {
                        "username": "SabihaKhan",
                        "content": "To have a variance more than 0, a substring must contain 2 diff characters and difference of their number of occurrence should be more than 0.\\nThe difference of their number of occurrence is variance.\\n\\nIn Example 1:\\n\\nInput: s = \"aababbb\"\\nOutput: 3\\n\\nExplanation:\\n- Variance 0 for substrings \"a\", \"aa\", \"ab\", \"abab\", \"aababb\", \"ba\", \"b\", \"bb\", and \"bbb\".->            these substrings either only contain 1 type of characters or contains 2 character with same count. \\n\\n- Variance 1 for substrings \"aab\", \"aba\", \"abb\", \"aabab\", \"ababb\", \"aababbb\", and \"bab\".->  these substring contains 2 diff characters and diff of there occurrence is 1.\\n- Variance 2 for substrings \"aaba\", \"ababbb\", \"abbb\", and\\n \"babb\". -> these substring contains 2 diff characters and diff of there occurrence is 2.\\n- Variance 3 for substring \"babbb\". -> these substring contains 2 diff characters and diff of there occurrence is 3."
                    }
                ]
            }
        ]
    }
]