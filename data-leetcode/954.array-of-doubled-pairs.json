[
    {
        "title": "Largest Component Size by Common Factor",
        "question_content": "You are given an integer array of unique positive integers nums. Consider the following graph:\n\n\tThere are nums.length nodes, labeled nums[0] to nums[nums.length - 1],\n\tThere is an undirected edge between nums[i] and nums[j] if nums[i] and nums[j] share a common factor greater than 1.\n\nReturn the size of the largest connected component in the graph.\n&nbsp;\nExample 1:\n\nInput: nums = [4,6,15,35]\nOutput: 4\n\nExample 2:\n\nInput: nums = [20,50,9,63]\nOutput: 2\n\nExample 3:\n\nInput: nums = [2,3,6,7,4,12,21,39]\nOutput: 8\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 2 * 104\n\t1 <= nums[i] <= 105\n\tAll the values of nums are unique.",
        "solutions": [
            {
                "id": 819919,
                "title": "python-union-find-solution-explained",
                "content": "If you try to run usual dfs/bfs on this problem, you will get TLE, so we need to think something smarter. Note, that if two numbers has common factor more than `1`, it means that they have **prime** common factor. So, let us for example consider all even numbers: they all have prime common factor `2`, so we can immediatly say, that they should be in the same group. Consider all numbers which are divisible by `3`, they also can be put in the same group. There is special data stucture: Disjoint set (https://en.wikipedia.org/wiki/Disjoint-set_data_structure), which is very suitable for these type of problems.\\n\\nLet us consider example `[2,3,6,7,4,12,21,39]` an go through my code:\\n\\n1. `primes_set(self,n)` return set of unique prive divisors of number `n`, for example for `n = 12` it returns set `[2,3]` and for `n=39` it returns set `[3,13]`.\\n2. Now, what is `primes` defaultdict? For each found prime, we put indexes of numbers from `A`, which are divisible by this prime. For our example we have: `2: [0,2,4,5], 3:[1,2,5,6,7], 7:[3,6], 13:[7]`. So, what we need to do now? We need to union `0-2-4-5`, `1-2-5-6-7` and `3-6`.\\n3. That exaclty what we do on the next step: iterate over our `primes` and create connections with `UF.union(indexes[i], indexes[i+1])`\\n4. Finally, when we made all connections, we need to find the biggest group: so we find parent for each number and find the bigges frequency.\\n\\n**Complexity**: this is interesting part. Let `n` be length of `A` and let `m` be the biggest possible number. Function `primes_set` is quite heavy: for each number we need to check all numbers before its square root (if number is prime we can not do better with this approach), so complexity of `primes_set` is `O(sqrt(m))`. We apply this function `n` times, so overall complexity of this function will be `O(n*sqrt(m))`. We also have other parts of algorithm, where we put prime numbers to dictionary, complexity will be `O(n*log(m))` at most, because each number has no more, than `log(m)` different prime divisors. We also have the same number of `union()` calls, which will work as `O(1)` if we use it with ranks, and slower if we use it without ranks as I did, but still fast enough to be better than our bottleneck: `O(n*sqrt(m))` complexity for prime factors generation. That is why I use Union Find without ranks: if you want to improve algorighm, you need to deal with `primes_set()` function.\\nSpace complexity is `O(n*log(m))` to keep all prime factors and to keep our `DSU` data structure.\\n\\n```\\nclass DSU:\\n    def __init__(self, N):\\n        self.p = list(range(N))\\n\\n    def find(self, x):\\n        if self.p[x] != x:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        self.p[xr] = yr\\n\\nclass Solution:\\n    def primes_set(self,n):\\n        for i in range(2, int(math.sqrt(n))+1):\\n            if n % i == 0:\\n                return self.primes_set(n//i) | set([i])\\n        return set([n])\\n\\n    def largestComponentSize(self, A):\\n        n = len(A)\\n        UF = DSU(n)\\n        primes = defaultdict(list)\\n        for i, num in enumerate(A):\\n            pr_set = self.primes_set(num)\\n            for q in pr_set: primes[q].append(i)\\n\\n        for _, indexes in primes.items():\\n            for i in range(len(indexes)-1):\\n                UF.union(indexes[i], indexes[i+1])\\n\\n        return max(Counter([UF.find(i) for i in range(n)]).values())\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass DSU:\\n    def __init__(self, N):\\n        self.p = list(range(N))\\n\\n    def find(self, x):\\n        if self.p[x] != x:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        self.p[xr] = yr\\n\\nclass Solution:\\n    def primes_set(self,n):\\n        for i in range(2, int(math.sqrt(n))+1):\\n            if n % i == 0:\\n                return self.primes_set(n//i) | set([i])\\n        return set([n])\\n\\n    def largestComponentSize(self, A):\\n        n = len(A)\\n        UF = DSU(n)\\n        primes = defaultdict(list)\\n        for i, num in enumerate(A):\\n            pr_set = self.primes_set(num)\\n            for q in pr_set: primes[q].append(i)\\n\\n        for _, indexes in primes.items():\\n            for i in range(len(indexes)-1):\\n                UF.union(indexes[i], indexes[i+1])\\n\\n        return max(Counter([UF.find(i) for i in range(n)]).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592263,
                "title": "c-3-simple-solution-w-explanation-disjoint-set-union-sieve-of-eratosthenes",
                "content": "We are given an array `nums` each element of which denotes a node in the graph. There is an edge between two elements if they share a common factor. We need to return the largest connected component in this graph.\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Union-Find)***\\n\\nThe problem statement can be stated in simpler terms as - two element belong to same group if they share a common factor. We need to find largest of such groups. \\n\\nFor eg. If we have numbers `[2,3,5,6,25]`, then we can see `2` & `6` share a common factor. So lets say they belong to group `A`. `3` & `6` also share a common factor, so 3 belongs to group `A` as well. `5` and `25` is another pair sharing a common factor so they belong to one group, lets say `B`. So, out of all these groups, `A` is the largest and it will be our answer.\\n\\nThere\\'s a common Data Structure that can be used in such problems - **[Disjoint Set Union](https://en.wikipedia.org/wiki/Disjoint-set_data_structure)**. \\n\\n<blockquote>\\n<details>\\n<summary><b>Brief Description of DSU</b></summary>\\n\\nDisjoin Set Union or DSU involes two basic operations -\\n* **`find(x)`**: finds the id which represents the component that a node belongs to\\n* **`union(x, y)`**: joins the two components into a single component. This involves finding the representative of x-component (by `find(x)`) and y-component (by `find(y)`) and assigning them a common  representative (same parent).\\n\\nIn simple implementation, we can only maintain a `par` array denoting parent of each node and define a `find` function that finds representative/parent of component that a given node belongs to. In more optimized versions, we use path compression in `find` function along with either use a rank or size to group elements based on their component rank/size to ensure that even in the worst case, DSU doesnt form a skewed tree. You can read on more about it **[here](https://cp-algorithms.com/data_structures/disjoint_set_union.html)**\\n\\n</details>\\n</blockquote>\\n\\nHere, we use DSU to group elements of `nums` and its factors into a single component. Once this is done, all elements of `nums` that share a common factor will belong to the same component and will have the same parent in DSU. Then we can just iterate over `nums`, and find the parent of component that it belongs to. We keep count of number of times that each parent is seen. The largest group will be the one whose parent is seen maximum number of times.\\n\\nWe can find the factors of a number in `O(sqrt(N))` time and union each factor with that number itself.\\n\\n```cpp\\n// a standard Disjoint Set Union class template\\nclass DSU {\\n    public:\\n    vector<int> par, sz;\\n    DSU(int n) : par(n), sz(n,1) {\\n        iota(begin(par), end(par), 0);                         // initializes each node\\'s parent to be itself - fills as [0,1,2,3,...,n]\\n    }\\n    int find(int x) {\\n        if(par[x] == x) return x;                              // x is itself the parent of the component that it belongs to\\n        return par[x] = find(par[x]);                          // update parent of x before returning for each call -path compression\\n    }\\n    bool Union(int x, int y) {\\n        int xp = find(x), yp = find(y);                        // find parents of x and y, i.e, representatives of components that x and y belong to\\n        if(xp == yp) return false;                             // x and y already belong to same component - not possible to union\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];   // union by size - join smaller sized to bigger one\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = size(nums), ans = 1;\\n        DSU ds(*max_element(begin(nums), end(nums)) + 1);      // max(nums) is largest element that will be stored in DSU\\n        unordered_map<int, int> mp;                            // maintains {parent of component: frequency}\\n        for(auto c : nums) \\n            for(int f = 2; f <= sqrt(c); f++)                  // finding factors of each element\\n                if(c % f == 0)                                 // if f divides c, then f & c/f are its factor. So union them\\n                    ds.Union(c, f), \\n                    ds.Union(c, c/f);\\n        \\n        for(int i = 0; i < n; i++)                             // iterate and find parent that is seen most. It\\'ll give the largest group\\n            ans = max(ans, ++mp[ds.find(nums[i])]);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n***Time Complexity :*** `O(N * sqrt(M))`, where `N` is the number of elements in `nums` and `M` is the maximum element in `nums`. The time complexity of each `find` call after union-by-size and path compression comes out to be `O(\\u03B1(n))`, where `\\u03B1(n)` is the inverse Ackermann function. It doesn\\'t exceed 4 for any <code>n < 10<sup>600</sup></code> and hence is practically constant. We take each `N` elements from `nums` and iterate upto `sqrt(num[i])`. Thus the overall time comes out to `O(N * sqrt(M))`.\\n***Space Complexity :*** `O(M)`, for DSU\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Union-Find w/ Prime Factorization)***\\n\\nWe can see that if two numbers belong to the same group due to some common factor, they should also have some common prime factor. This allows us to use slightly different approach where we find all prime factors of a number and union the elements based on the common prime factors amongst them. This can reduce the space used by DSU to `O(N)` down from `O(M)` by allowing us to perform union on indices of elements instead of elements & its factors, although we do incur a cost of storing primes and elements in `nums` that it divides.\\n\\n```cpp\\nclass UnionFind {\\n    public:\\n    vector<int> par, sz;\\n    UnionFind(int n) : par(n), sz(n,1) {\\n        iota(begin(par), end(par), 0);\\n    }\\n    int find(int x) {\\n        if(par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xp = find(x), yp = find(y);\\n        if(xp == yp) return false;\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = size(nums), ans = 1;\\n        UnionFind uf(n + 1);\\n        unordered_map<int, vector<int>> mp;             // stores {p : [indices of nums for which p is prime factor]}\\n        for(int i = 0; i < n; i++) {                    // prime factorize nums[i]\\n            int cur = nums[i];\\n            if(cur % 2 == 0) {                          // 2 is prime factor of nums[i]\\n                mp[2].push_back(i);\\n                while(cur % 2 == 0) cur >>= 1;\\n            }\\n            for(int p = 3; p <= sqrt(cur); p += 2)      // now check for all odd numbers if it is factor of nums[i]\\n                if(cur % p == 0) {                      // p is prime factor of nums[i]\\n                    mp[p].push_back(i);\\n                    while(cur % p == 0) cur /= p;\\n                }\\n            \\n            if(cur > 1) mp[cur].push_back(i);           // nums[i] itself is prime\\n        }\\n        \\n        for(auto& [prime, ids] : mp)                    // union all element index that have same prime\\n            for(int i = 0; i < size(ids)-1; i++) \\n                uf.Union(ids[i], ids[i+1]);\\n        \\n        return *max_element(begin(uf.sz), end(uf.sz));  // return largest component\\n    }\\n};\\n```\\n\\nHowever, we can add another small optimization for space. Instead of storing all the primes as a vector in the hashmap and then performing union on the indices of element that each prime divides, we can just put the 1st index of element we find that a prime `p` divides and then for every subsequent indices, we just union them there itself. This saves space and also eliminate the last step of iterating over each prime and then unioning the indices. \\n\\nThe following code will make this optimization clear -\\n\\n```cpp\\nclass UnionFind {\\n    public:\\n    vector<int> par, sz;\\n    UnionFind(int n) : par(n), sz(n,1) {\\n        iota(begin(par), end(par), 0);\\n    }\\n    int find(int x) {\\n        if(par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xp = find(x), yp = find(y);\\n        if(xp == yp) return false;\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = size(nums), ans = 1;\\n        UnionFind uf(n + 1);\\n        unordered_map<int, int> mp;                    // stores {p : 1st found index i such that nums[i] % p == 0}\\n        auto putOrUnion = [&](int p, int i){           // puts 1st found index of element that p divides into hashmap\\n            if(mp.count(p)) uf.Union(mp[p], i);        // and if already exists, directly union them\\n            else mp[p] = i;\\n        };\\n        for(int i = 0; i < n; i++) {                   // prime factorize nums[i]\\n            int cur = nums[i];\\n            if(cur % 2 == 0) {                        \\n                putOrUnion(2, i);\\n                while(cur % 2 == 0) cur >>= 1;\\n            }\\n            for(int p = 3; p <= sqrt(cur); p += 2)   \\n                if(cur % p == 0) {                 \\n                    putOrUnion(p, i);\\n                    while(cur % p == 0) cur /= p;\\n                }\\n            if(cur > 1) putOrUnion(cur, i);            // nums[i] itself is prime   \\n        }\\n        return *max_element(begin(uf.sz), end(uf.sz)); // return largest component\\n    }\\n};\\n```\\n\\n***Time Complexity :*** `O(N * sqrt(M))` same as above\\n***Space Complexity :*** \\n* 1st Implementation: <code>O(N + \\u2211\\u03C9(nums<sub>i</sub>))</code> \\n* 2nd Implementation: `O(N + \\u03C0(M))`\\n \\nwhere `\\u03C9(n)` is the **[prime omega function](https://en.wikipedia.org/wiki/Prime_omega_function)** and `\\u03C0(n)` is the **[prime counting function](https://en.wikipedia.org/wiki/Prime-counting_function)** which is approximately equal to `O(n/logn)`. Let me know if there\\'s a better way to describe the space complexity or if there\\'s a mistake in this analysis.\\n\\n\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Union-Find w/ Prime Factorization using Sieve of Eratosthenes)***\\n\\nWe can use sieve of Eratosthenes to compute prime factorization queries in better time complexity than O(sqrt(M)). The logic is similar to above but we have just changed the way we compute prime factors for each element in `nums`. \\n\\n<blockquote>\\n<details>\\n\\n<summary>Similar to 1st implementation in <code>Solution - II</code></summary>\\n\\n```cpp\\nclass UnionFind {\\n    public:\\n    vector<int> par, sz;\\n    UnionFind(int n) : par(n), sz(n,1) {\\n        iota(begin(par), end(par), 0);\\n    }\\n    int find(int x) {\\n        if(par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xp = find(x), yp = find(y);\\n        if(xp == yp) return false;\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = size(nums), M = *max_element(begin(nums), end(nums)), ans = 1;\\n        auto spf = sieve(M+1);\\n        UnionFind uf(n + 1);\\n        unordered_map<int, vector<int>> mp;           // stores {p : [indices of nums for which p is prime factor]}\\n        for(int i = 0; i < n; i++)                    // prime factorize nums[i]\\n            for(auto p : getPrimes(nums[i], spf))\\n                mp[p].push_back(i);\\n        \\n        for(auto& [prime, ids] : mp)                  // union all element index that have same prime\\n            for(int i = 0; i < size(ids)-1; i++) \\n                uf.Union(ids[i], ids[i+1]);\\n        \\n        return *max_element(begin(uf.sz), end(uf.sz));\\n    }\\n    \\n    vector<int> sieve(int M) {\\n        vector<int> spf(M+1);\\n        iota(begin(spf), end(spf), 0);\\n        for(int i = 2; i*i < M; i++) \\n            if(spf[i] == i) \\n                for(int j = i*i; j < M; j += i)\\n                    if(spf[j] == j)\\n                        spf[j] = i;            \\n        return spf;\\n    }\\n\\n    vector<int> getPrimes(int x, vector<int>& spf) {\\n        vector<int> primes;\\n        while (x != 1) {\\n            int p = spf[x];\\n            primes.push_back(p);\\n            while(x % p == 0) x /= p;\\n        }\\n        return primes;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** `O((N+M)logM)`\\n***Space Complexity :*** <code>O(M + \\u2211\\u03C9(nums<sub>i</sub>))</code>\\n\\n</details>\\n</blockquote>\\n\\n```cpp\\nclass UnionFind {\\n    public:\\n    vector<int> par, sz;\\n    UnionFind(int n) : par(n), sz(n,1) {\\n        iota(begin(par), end(par), 0);\\n    }\\n    int find(int x) {\\n        if(par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xp = find(x), yp = find(y);\\n        if(xp == yp) return false;\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = size(nums), ans = 1;\\n        auto spf = sieve(*max_element(begin(nums), end(nums))+1);\\n        UnionFind uf(n + 1);\\n        unordered_map<int, int> mp;                      // stores {p : 1st found index i such that nums[i] % p == 0}\\n        for(int i = 0; i < n; i++)                       // prime factorize nums[i]\\n            for(auto p : getPrimes(nums[i], spf))\\n                if(mp.count(p)) uf.Union(i, mp[p]);\\n                else mp[p] = i;\\n        \\n        return *max_element(begin(uf.sz), end(uf.sz));\\n    }\\n    \\n    vector<int> sieve(int M) {\\n        vector<int> spf(M+1);\\n        iota(begin(spf), end(spf), 0);\\n        for(int i = 2; i*i < M; i++) \\n            if(spf[i] == i) \\n                for(int j = i*i; j < M; j += i)\\n                    if(spf[j] == j)\\n                        spf[j] = i;            \\n        return spf;\\n    }\\n\\n    vector<int> getPrimes(int x, vector<int>& spf) {\\n        vector<int> primes;\\n        while (x != 1) {\\n            int p = spf[x];\\n            primes.push_back(p);\\n            while(x % p == 0) x /= p;\\n        }\\n        return primes;\\n    }\\n};\\n```\\n\\n\\n\\n***Time Complexity :*** `O(M*log(logM) + N*logM)`, we require `O(M*log(logM))` time to initially compute the sieve.Then, every query to `getPrimes` will require `O(logM)` and this is queried for `N` times. So overall time complexity becomes `O(M*loglogM + NlogM)`.\\n\\n***Space Complexity :*** `O(M)`, for sieve\\n\\nYou can search **`sieve of eratosthenes GFG`** to read more about it on GFG from where this implementation is referred (unfortunately LC doesn\\'t allow external links or even names of sites in post \\u2639\\uFE0F).\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\n// a standard Disjoint Set Union class template\\nclass DSU {\\n    public:\\n    vector<int> par, sz;\\n    DSU(int n) : par(n), sz(n,1) {\\n        iota(begin(par), end(par), 0);                         // initializes each node\\'s parent to be itself - fills as [0,1,2,3,...,n]\\n    }\\n    int find(int x) {\\n        if(par[x] == x) return x;                              // x is itself the parent of the component that it belongs to\\n        return par[x] = find(par[x]);                          // update parent of x before returning for each call -path compression\\n    }\\n    bool Union(int x, int y) {\\n        int xp = find(x), yp = find(y);                        // find parents of x and y, i.e, representatives of components that x and y belong to\\n        if(xp == yp) return false;                             // x and y already belong to same component - not possible to union\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];   // union by size - join smaller sized to bigger one\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = size(nums), ans = 1;\\n        DSU ds(*max_element(begin(nums), end(nums)) + 1);      // max(nums) is largest element that will be stored in DSU\\n        unordered_map<int, int> mp;                            // maintains {parent of component: frequency}\\n        for(auto c : nums) \\n            for(int f = 2; f <= sqrt(c); f++)                  // finding factors of each element\\n                if(c % f == 0)                                 // if f divides c, then f & c/f are its factor. So union them\\n                    ds.Union(c, f), \\n                    ds.Union(c, c/f);\\n        \\n        for(int i = 0; i < n; i++)                             // iterate and find parent that is seen most. It\\'ll give the largest group\\n            ans = max(ans, ++mp[ds.find(nums[i])]);\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass UnionFind {\\n    public:\\n    vector<int> par, sz;\\n    UnionFind(int n) : par(n), sz(n,1) {\\n        iota(begin(par), end(par), 0);\\n    }\\n    int find(int x) {\\n        if(par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xp = find(x), yp = find(y);\\n        if(xp == yp) return false;\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = size(nums), ans = 1;\\n        UnionFind uf(n + 1);\\n        unordered_map<int, vector<int>> mp;             // stores {p : [indices of nums for which p is prime factor]}\\n        for(int i = 0; i < n; i++) {                    // prime factorize nums[i]\\n            int cur = nums[i];\\n            if(cur % 2 == 0) {                          // 2 is prime factor of nums[i]\\n                mp[2].push_back(i);\\n                while(cur % 2 == 0) cur >>= 1;\\n            }\\n            for(int p = 3; p <= sqrt(cur); p += 2)      // now check for all odd numbers if it is factor of nums[i]\\n                if(cur % p == 0) {                      // p is prime factor of nums[i]\\n                    mp[p].push_back(i);\\n                    while(cur % p == 0) cur /= p;\\n                }\\n            \\n            if(cur > 1) mp[cur].push_back(i);           // nums[i] itself is prime\\n        }\\n        \\n        for(auto& [prime, ids] : mp)                    // union all element index that have same prime\\n            for(int i = 0; i < size(ids)-1; i++) \\n                uf.Union(ids[i], ids[i+1]);\\n        \\n        return *max_element(begin(uf.sz), end(uf.sz));  // return largest component\\n    }\\n};\\n```\n```cpp\\nclass UnionFind {\\n    public:\\n    vector<int> par, sz;\\n    UnionFind(int n) : par(n), sz(n,1) {\\n        iota(begin(par), end(par), 0);\\n    }\\n    int find(int x) {\\n        if(par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xp = find(x), yp = find(y);\\n        if(xp == yp) return false;\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = size(nums), ans = 1;\\n        UnionFind uf(n + 1);\\n        unordered_map<int, int> mp;                    // stores {p : 1st found index i such that nums[i] % p == 0}\\n        auto putOrUnion = [&](int p, int i){           // puts 1st found index of element that p divides into hashmap\\n            if(mp.count(p)) uf.Union(mp[p], i);        // and if already exists, directly union them\\n            else mp[p] = i;\\n        };\\n        for(int i = 0; i < n; i++) {                   // prime factorize nums[i]\\n            int cur = nums[i];\\n            if(cur % 2 == 0) {                        \\n                putOrUnion(2, i);\\n                while(cur % 2 == 0) cur >>= 1;\\n            }\\n            for(int p = 3; p <= sqrt(cur); p += 2)   \\n                if(cur % p == 0) {                 \\n                    putOrUnion(p, i);\\n                    while(cur % p == 0) cur /= p;\\n                }\\n            if(cur > 1) putOrUnion(cur, i);            // nums[i] itself is prime   \\n        }\\n        return *max_element(begin(uf.sz), end(uf.sz)); // return largest component\\n    }\\n};\\n```\n```cpp\\nclass UnionFind {\\n    public:\\n    vector<int> par, sz;\\n    UnionFind(int n) : par(n), sz(n,1) {\\n        iota(begin(par), end(par), 0);\\n    }\\n    int find(int x) {\\n        if(par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xp = find(x), yp = find(y);\\n        if(xp == yp) return false;\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = size(nums), M = *max_element(begin(nums), end(nums)), ans = 1;\\n        auto spf = sieve(M+1);\\n        UnionFind uf(n + 1);\\n        unordered_map<int, vector<int>> mp;           // stores {p : [indices of nums for which p is prime factor]}\\n        for(int i = 0; i < n; i++)                    // prime factorize nums[i]\\n            for(auto p : getPrimes(nums[i], spf))\\n                mp[p].push_back(i);\\n        \\n        for(auto& [prime, ids] : mp)                  // union all element index that have same prime\\n            for(int i = 0; i < size(ids)-1; i++) \\n                uf.Union(ids[i], ids[i+1]);\\n        \\n        return *max_element(begin(uf.sz), end(uf.sz));\\n    }\\n    \\n    vector<int> sieve(int M) {\\n        vector<int> spf(M+1);\\n        iota(begin(spf), end(spf), 0);\\n        for(int i = 2; i*i < M; i++) \\n            if(spf[i] == i) \\n                for(int j = i*i; j < M; j += i)\\n                    if(spf[j] == j)\\n                        spf[j] = i;            \\n        return spf;\\n    }\\n\\n    vector<int> getPrimes(int x, vector<int>& spf) {\\n        vector<int> primes;\\n        while (x != 1) {\\n            int p = spf[x];\\n            primes.push_back(p);\\n            while(x % p == 0) x /= p;\\n        }\\n        return primes;\\n    }\\n};\\n```\n```cpp\\nclass UnionFind {\\n    public:\\n    vector<int> par, sz;\\n    UnionFind(int n) : par(n), sz(n,1) {\\n        iota(begin(par), end(par), 0);\\n    }\\n    int find(int x) {\\n        if(par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xp = find(x), yp = find(y);\\n        if(xp == yp) return false;\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = size(nums), ans = 1;\\n        auto spf = sieve(*max_element(begin(nums), end(nums))+1);\\n        UnionFind uf(n + 1);\\n        unordered_map<int, int> mp;                      // stores {p : 1st found index i such that nums[i] % p == 0}\\n        for(int i = 0; i < n; i++)                       // prime factorize nums[i]\\n            for(auto p : getPrimes(nums[i], spf))\\n                if(mp.count(p)) uf.Union(i, mp[p]);\\n                else mp[p] = i;\\n        \\n        return *max_element(begin(uf.sz), end(uf.sz));\\n    }\\n    \\n    vector<int> sieve(int M) {\\n        vector<int> spf(M+1);\\n        iota(begin(spf), end(spf), 0);\\n        for(int i = 2; i*i < M; i++) \\n            if(spf[i] == i) \\n                for(int j = i*i; j < M; j += i)\\n                    if(spf[j] == j)\\n                        spf[j] = i;            \\n        return spf;\\n    }\\n\\n    vector<int> getPrimes(int x, vector<int>& spf) {\\n        vector<int> primes;\\n        while (x != 1) {\\n            int p = spf[x];\\n            primes.push_back(p);\\n            while(x % p == 0) x /= p;\\n        }\\n        return primes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200959,
                "title": "simplest-solution-union-find-only-no-prime-calculation",
                "content": "Union Find template. The only additional stuff is one hashmap which is used to convert factor to the node index in A for union. \\nHashMap: key is the factor, val is the index in A\\nTime complexity: O(N*sqrt(Max val of A[i]))\\n```\\nclass Solution {\\n    class UF {\\n        int[] parent;\\n        int[] size;\\n        int max;\\n        public UF (int N){\\n            parent = new int[N];\\n            size = new int[N];\\n            max = 1;\\n            for (int i = 0; i < N; i++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        public int find(int x){\\n            if (x == parent[x]){\\n                return x;\\n            }\\n            return parent[x] = find(parent[x]);\\n        }\\n        public void union(int x, int y){\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX != rootY){\\n                parent[rootX] = rootY;\\n                size[rootY] += size[rootX];\\n                max = Math.max(max, size[rootY]);\\n            }\\n        }\\n    }\\n    public int largestComponentSize(int[] A) {\\n        int N = A.length;\\n        Map<Integer, Integer> map = new HashMap<>();// key is the factor, val is the node index\\n        UF uf = new UF(N);\\n        for (int i = 0; i < N; i++){\\n            int a = A[i];\\n            for (int j = 2; j * j <= a; j++){\\n                if (a % j == 0){\\n                    if (!map.containsKey(j)){//this means that no index has claimed the factor yet\\n                        map.put(j, i);\\n                    }else{//this means that one index already claimed, so union that one with current\\n                        uf.union(i, map.get(j));\\n                    }\\n                    if (!map.containsKey(a/j)){\\n                        map.put(a/j, i);\\n                    }else{\\n                        uf.union(i, map.get(a/j));\\n                    }\\n                }\\n            }\\n            if (!map.containsKey(a)){//a could be factor too. Don\\'t miss this\\n                map.put(a, i);\\n            }else{\\n                uf.union(i, map.get(a));\\n            }\\n        }\\n        return uf.max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class UF {\\n        int[] parent;\\n        int[] size;\\n        int max;\\n        public UF (int N){\\n            parent = new int[N];\\n            size = new int[N];\\n            max = 1;\\n            for (int i = 0; i < N; i++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        public int find(int x){\\n            if (x == parent[x]){\\n                return x;\\n            }\\n            return parent[x] = find(parent[x]);\\n        }\\n        public void union(int x, int y){\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX != rootY){\\n                parent[rootX] = rootY;\\n                size[rootY] += size[rootX];\\n                max = Math.max(max, size[rootY]);\\n            }\\n        }\\n    }\\n    public int largestComponentSize(int[] A) {\\n        int N = A.length;\\n        Map<Integer, Integer> map = new HashMap<>();// key is the factor, val is the node index\\n        UF uf = new UF(N);\\n        for (int i = 0; i < N; i++){\\n            int a = A[i];\\n            for (int j = 2; j * j <= a; j++){\\n                if (a % j == 0){\\n                    if (!map.containsKey(j)){//this means that no index has claimed the factor yet\\n                        map.put(j, i);\\n                    }else{//this means that one index already claimed, so union that one with current\\n                        uf.union(i, map.get(j));\\n                    }\\n                    if (!map.containsKey(a/j)){\\n                        map.put(a/j, i);\\n                    }else{\\n                        uf.union(i, map.get(a/j));\\n                    }\\n                }\\n            }\\n            if (!map.containsKey(a)){//a could be factor too. Don\\'t miss this\\n                map.put(a, i);\\n            }else{\\n                uf.union(i, map.get(a));\\n            }\\n        }\\n        return uf.max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201046,
                "title": "c-232ms-union-find-solution",
                "content": "[reference](https://www.youtube.com/watch?v=GTX0kw63Tn0)\\n### Intuition\\n\\n(1) Union each number with all its factor;\\n(2) Count the most frequent parent.\\n\\n```\\n// W: the largest number\\n// Time Complexity: O(n*sqrt(W))\\n// Space Complexity: O(W)\\n\\nclass UnionFindSet {\\npublic:\\n    UnionFindSet(int n) : _parent(n) {\\n        for (int i=0; i<n; i++) {\\n            _parent[i] = i;\\n        }\\n    }\\n    \\n    void Union(int x, int y) {\\n        _parent[Find(x)] = _parent[Find(y)];\\n    }\\n    \\n    int Find(int x) {\\n        if (_parent[x] != x) {\\n            _parent[x] = Find(_parent[x]);\\n        }\\n        return _parent[x];\\n    }\\n    \\nprivate:\\n    vector<int> _parent;\\n};\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& A) {\\n        int n = *max_element(A.begin(), A.end());\\n        UnionFindSet ufs(n+1);\\n        for (int &a : A) {\\n            for (int k = 2; k <= sqrt(a); k++) {\\n                if (a % k == 0) {\\n                    ufs.Union(a, k);\\n                    ufs.Union(a, a / k);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int, int> mp;\\n        int ans = 1;\\n        for (int &a : A) {\\n            ans = max(ans, ++mp[ufs.Find(a)]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// W: the largest number\\n// Time Complexity: O(n*sqrt(W))\\n// Space Complexity: O(W)\\n\\nclass UnionFindSet {\\npublic:\\n    UnionFindSet(int n) : _parent(n) {\\n        for (int i=0; i<n; i++) {\\n            _parent[i] = i;\\n        }\\n    }\\n    \\n    void Union(int x, int y) {\\n        _parent[Find(x)] = _parent[Find(y)];\\n    }\\n    \\n    int Find(int x) {\\n        if (_parent[x] != x) {\\n            _parent[x] = Find(_parent[x]);\\n        }\\n        return _parent[x];\\n    }\\n    \\nprivate:\\n    vector<int> _parent;\\n};\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& A) {\\n        int n = *max_element(A.begin(), A.end());\\n        UnionFindSet ufs(n+1);\\n        for (int &a : A) {\\n            for (int k = 2; k <= sqrt(a); k++) {\\n                if (a % k == 0) {\\n                    ufs.Union(a, k);\\n                    ufs.Union(a, a / k);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int, int> mp;\\n        int ans = 1;\\n        for (int &a : A) {\\n            ans = max(ans, ++mp[ufs.Find(a)]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200546,
                "title": "prime-factorization-and-union-find",
                "content": "1. Calculate all prime numbers less than `100000`.\\n2. For each number in `A`, we say `A[i]`\\n\\ta. Do Prime Factorization(Brute force using the primes set in step 1), we say the prime factor is `p`.\\n\\tb. If `p` has presented in the `primeToIndex`, union `i` and `primeToIndex[p]`.\\n\\tc. Update `primeToIndex[p]` to `i`.\\n3. Return the maximum count.\\n\\nTime complexity: `O(NP)`, where `P` is the count of prime numbers < `100000`. I think this is an upperbound time complexity.\\n```\\nclass Solution {\\n    int max = 0;\\n    public int largestComponentSize(int[] A) {\\n        boolean[] isPrime = new boolean[100001];\\n        Arrays.fill(isPrime, true);\\n        Set<Integer> primes = new HashSet<>();\\n        // all primes less than 100000\\n        for (int i = 2; i <= 100000; i++) {\\n            if (isPrime[i]) {\\n                primes.add(i);\\n                for (int j = 2; j * i <= 100000; j++) {\\n                    isPrime[j * i] = false;\\n                }\\n            }\\n        }\\n        int n = A.length;\\n        int[] counts = new int[n];\\n        int[] parents = new int[n];\\n        int[] primeToIndex = new int[100001];\\n        Arrays.fill(primeToIndex, -1);\\n        for (int i = 0; i < n; i++) {\\n            parents[i] = i;\\n            counts[i] = 1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int a = A[i];\\n            for (int p : primes) {\\n                if (primes.contains(a)) { // Optimization\\n                    p = a;\\n                }\\n                if (a % p == 0) {\\n                    if (primeToIndex[p] > -1) {\\n                        union(parents, counts, primeToIndex[p], i);\\n                    }\\n                    primeToIndex[p] = i;\\n                    while (a % p == 0) {\\n                        a /= p;\\n                    }\\n                }\\n                if (a == 1) {\\n                    break;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    private int find(int[] parents, int a) {\\n        if (parents[a] != a) {\\n            parents[a] = find(parents, parents[a]);\\n        }\\n        return parents[a];\\n    }\\n    private void union(int[] parents, int[] counts, int a, int b) {\\n        int root1 = find(parents, a), root2 = find(parents, b);\\n        if (root1 == root2) {\\n            return;\\n        }\\n        int count = counts[root2] + counts[root1];\\n        max = Math.max(count, max);\\n        parents[root1] = root2;\\n        counts[root2] = count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    public int largestComponentSize(int[] A) {\\n        boolean[] isPrime = new boolean[100001];\\n        Arrays.fill(isPrime, true);\\n        Set<Integer> primes = new HashSet<>();\\n        // all primes less than 100000\\n        for (int i = 2; i <= 100000; i++) {\\n            if (isPrime[i]) {\\n                primes.add(i);\\n                for (int j = 2; j * i <= 100000; j++) {\\n                    isPrime[j * i] = false;\\n                }\\n            }\\n        }\\n        int n = A.length;\\n        int[] counts = new int[n];\\n        int[] parents = new int[n];\\n        int[] primeToIndex = new int[100001];\\n        Arrays.fill(primeToIndex, -1);\\n        for (int i = 0; i < n; i++) {\\n            parents[i] = i;\\n            counts[i] = 1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int a = A[i];\\n            for (int p : primes) {\\n                if (primes.contains(a)) { // Optimization\\n                    p = a;\\n                }\\n                if (a % p == 0) {\\n                    if (primeToIndex[p] > -1) {\\n                        union(parents, counts, primeToIndex[p], i);\\n                    }\\n                    primeToIndex[p] = i;\\n                    while (a % p == 0) {\\n                        a /= p;\\n                    }\\n                }\\n                if (a == 1) {\\n                    break;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    private int find(int[] parents, int a) {\\n        if (parents[a] != a) {\\n            parents[a] = find(parents, parents[a]);\\n        }\\n        return parents[a];\\n    }\\n    private void union(int[] parents, int[] counts, int a, int b) {\\n        int root1 = find(parents, a), root2 = find(parents, b);\\n        if (root1 == root2) {\\n            return;\\n        }\\n        int count = counts[root2] + counts[root1];\\n        max = Math.max(count, max);\\n        parents[root1] = root2;\\n        counts[root2] = count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200643,
                "title": "python-1112-ms-beats-100-union-find-and-prime-factor-decomposition-with-optimization",
                "content": "Using the input of first example,We can firstly do Prime factor decomposition for each number in A, then we can get the map:```{2: [4, 6], 3: [6, 15], 5: [15, 35], 7: [35]})```, in which values are all multiples of the key(```must be prime```). Then we can regard the first multiple as the root of all the multiples, connect each multiple with the root. In this example, we connect 6 with 4(```root```), connect 15 with 6(```root```), connect 35 with 15(```root```), because there is only one multiple in ```7: [35]```, so no connection. At the end, we can get the largest size 4, which is the result. The root of all the numbers in A is the number ```4```.\\n```\\nclass UnionFind(object):\\n    def uf(self, n):  \\n        self.uf = [i for i in range(n)]\\n        self.size = [1] * n\\n        \\n    def find(self, x):  \\n        while x != self.uf[x]:\\n            self.uf[x] = self.uf[self.uf[x]]\\n            x = self.uf[x]\\n        return self.uf[x]\\n\\n    def union(self, x, y):  \\n        x_root = self.find(x)\\n        y_root = self.find(y)\\n        if x_root == y_root:\\n            return\\n        self.uf[x_root] = y_root\\n        self.size[y_root] += self.size[x_root]\\n        self.size[x_root] = 0\\n\\n\\nclass Solution(object):\\n    def largestComponentSize(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def primeFactors(n):  # Prime factor decomposition\\n            out = set()\\n            while n % 2 == 0: \\n                out.add(2)\\n                n //= 2\\n            for i in range(3, int(math.sqrt(n))+1, 2): \\n                while n % i== 0: \\n                    out.add(i) \\n                    n //= i \\n            if n > 2: \\n                out.add(n)\\n            return out\\n        \\n        idx_lookup = {A[i]: i for i in range(len(A))} # in order to find idx in uf\\n        uf = UnionFind()\\n        uf.uf(len(A))\\n        primeAndItsMultiples = collections.defaultdict(list) # {2: [4, 6], 3: [6, 15], 5: [15, 35], 7: [35]})\\n        \\n        for i in A:\\n            factors = primeFactors(i)\\n            for f in factors:\\n                primeAndItsMultiples[f].append(i)\\n\\n        # we don\\'t need to connect all the multiples of a prime, \\n        # just use the first multiple as their root\\n        for idx, multiples in primeAndItsMultiples.items():\\n            if multiples:\\n                root = multiples[0] # use the first multiple as their root\\n                for node in multiples[1:]:\\n                    uf.union(idx_lookup[node], idx_lookup[root]) # connect node with root\\n                    \\n        return max(uf.size)\\n```\\n\\nInspired by `yanx1` in the comment below,  `idx_lookup` and `primeAndItsMultiples` are kind of unnecessary... all we need is a dict primeToIndex that record the index of the element in A who has p as a prime factor.\\n\\nThis allows the runtime to be reduced to `1112 ms`\\n\\n\\n\\n```python\\nclass UnionFind(object):\\n    def uf(self, n):  \\n        self.uf = [i for i in range(n)]\\n        self.size = [1] * n\\n        \\n    def find(self, x):  \\n        while x != self.uf[x]:\\n            self.uf[x] = self.uf[self.uf[x]]\\n            x = self.uf[x]\\n        return self.uf[x]\\n\\n    def union(self, x, y):  \\n        x_root = self.find(x)\\n        y_root = self.find(y)\\n        if x_root == y_root:\\n            return\\n        self.uf[x_root] = y_root\\n        self.size[y_root] += self.size[x_root]\\n        self.size[x_root] = 0\\n\\n\\nclass Solution(object):\\n    def largestComponentSize(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def primeFactors(n):  # Prime factor decomposition\\n            out = set()\\n            while n % 2 == 0: \\n                out.add(2)\\n                n //= 2\\n            for i in range(3, int(math.sqrt(n))+1, 2): \\n                while n % i== 0: \\n                    out.add(i) \\n                    n //= i \\n            if n > 2: \\n                out.add(n)\\n            return out\\n        \\n        uf = UnionFind()\\n        uf.uf(len(A))\\n        \\n        primeToIndex = {} \\n        for i,a in enumerate(A):\\n            primes = primeFactors(a)\\n            for p in primes:\\n                if p in primeToIndex:\\n                    uf.union(i, primeToIndex[p])\\n                primeToIndex[p] = i\\n        return max(uf.size)\\n```\\nYou can also check the solution [here](https://github.com/apachecn/awesome-algorithm/blob/master/docs/Leetcode_Solutions/Python/952._Largest_Component_Size_by_Common_Factor.md).",
                "solutionTags": [],
                "code": "```{2: [4, 6], 3: [6, 15], 5: [15, 35], 7: [35]})```\n```must be prime```\n```root```\n```root```\n```root```\n```7: [35]```\n```4```\n```\\nclass UnionFind(object):\\n    def uf(self, n):  \\n        self.uf = [i for i in range(n)]\\n        self.size = [1] * n\\n        \\n    def find(self, x):  \\n        while x != self.uf[x]:\\n            self.uf[x] = self.uf[self.uf[x]]\\n            x = self.uf[x]\\n        return self.uf[x]\\n\\n    def union(self, x, y):  \\n        x_root = self.find(x)\\n        y_root = self.find(y)\\n        if x_root == y_root:\\n            return\\n        self.uf[x_root] = y_root\\n        self.size[y_root] += self.size[x_root]\\n        self.size[x_root] = 0\\n\\n\\nclass Solution(object):\\n    def largestComponentSize(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def primeFactors(n):  # Prime factor decomposition\\n            out = set()\\n            while n % 2 == 0: \\n                out.add(2)\\n                n //= 2\\n            for i in range(3, int(math.sqrt(n))+1, 2): \\n                while n % i== 0: \\n                    out.add(i) \\n                    n //= i \\n            if n > 2: \\n                out.add(n)\\n            return out\\n        \\n        idx_lookup = {A[i]: i for i in range(len(A))} # in order to find idx in uf\\n        uf = UnionFind()\\n        uf.uf(len(A))\\n        primeAndItsMultiples = collections.defaultdict(list) # {2: [4, 6], 3: [6, 15], 5: [15, 35], 7: [35]})\\n        \\n        for i in A:\\n            factors = primeFactors(i)\\n            for f in factors:\\n                primeAndItsMultiples[f].append(i)\\n\\n        # we don\\'t need to connect all the multiples of a prime, \\n        # just use the first multiple as their root\\n        for idx, multiples in primeAndItsMultiples.items():\\n            if multiples:\\n                root = multiples[0] # use the first multiple as their root\\n                for node in multiples[1:]:\\n                    uf.union(idx_lookup[node], idx_lookup[root]) # connect node with root\\n                    \\n        return max(uf.size)\\n```\n```python\\nclass UnionFind(object):\\n    def uf(self, n):  \\n        self.uf = [i for i in range(n)]\\n        self.size = [1] * n\\n        \\n    def find(self, x):  \\n        while x != self.uf[x]:\\n            self.uf[x] = self.uf[self.uf[x]]\\n            x = self.uf[x]\\n        return self.uf[x]\\n\\n    def union(self, x, y):  \\n        x_root = self.find(x)\\n        y_root = self.find(y)\\n        if x_root == y_root:\\n            return\\n        self.uf[x_root] = y_root\\n        self.size[y_root] += self.size[x_root]\\n        self.size[x_root] = 0\\n\\n\\nclass Solution(object):\\n    def largestComponentSize(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def primeFactors(n):  # Prime factor decomposition\\n            out = set()\\n            while n % 2 == 0: \\n                out.add(2)\\n                n //= 2\\n            for i in range(3, int(math.sqrt(n))+1, 2): \\n                while n % i== 0: \\n                    out.add(i) \\n                    n //= i \\n            if n > 2: \\n                out.add(n)\\n            return out\\n        \\n        uf = UnionFind()\\n        uf.uf(len(A))\\n        \\n        primeToIndex = {} \\n        for i,a in enumerate(A):\\n            primes = primeFactors(a)\\n            for p in primes:\\n                if p in primeToIndex:\\n                    uf.union(i, primeToIndex[p])\\n                primeToIndex[p] = i\\n        return max(uf.size)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592584,
                "title": "c-brute-to-optimal-solution",
                "content": "## Method 1\\n\\nFrom question it can be clearly observed that two numbers have an edge if their gcd is >1. Using this we can try to construct the graph and then perform dfs/bfs to find largest connected component.\\n\\n### Code\\n```\\nclass Solution {\\n    \\n    void recur(int node,unordered_map<int,vector<int>> &mp,unordered_map<int,bool> &vis)\\n    {\\n        vis[node] = 1;\\n        // int cnt = 0;\\n        for(auto &val : mp[node])\\n        {\\n            if(vis.find(val) == vis.end())\\n            {\\n                recur(val,mp,vis);\\n            }\\n        }\\n    }\\n    \\n    int dfs(unordered_map<int,vector<int>> &mp)\\n    {\\n        int res = 0,prev = 0;\\n        unordered_map<int,bool> vis;\\n        for(auto &[key,value] : mp)\\n        {\\n            if(vis.find(key) == vis.end())\\n            {\\n                recur(key,mp,vis);\\n            }\\n            \\n            int len = vis.size() - prev;\\n            res = max(len,res);\\n            prev = vis.size();\\n        }\\n        \\n        return res;\\n    }\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(__gcd(nums[i] , nums[j]) > 1)\\n                {\\n                    mp[nums[i]].push_back(nums[j]);\\n                    mp[nums[j]].push_back(nums[i]);\\n                }\\n            }\\n        }\\n        \\n        return dfs(mp);\\n    }\\n};\\n```\\n\\n**Time Complexity :**  O(n^2 * logn)\\n**Space Complexity :** O(n) [for map]\\n\\n## Method 2\\n\\nSince we only need connected components so instead of creating the whole graph , we can use something called Disjoint Set Union.\\n\\n### Code\\n\\n```\\nclass Solution {\\n    map<int,int> rank;\\n    map<int,int> par;\\n    \\n    void init(vector<int> &nums)\\n    {\\n        for(auto &val : nums) rank[val] = 1 , par[val] = val;\\n    }\\n    \\n    int findPar(int u)\\n    {\\n        if(par[u] == u) return u;\\n        \\n        return par[u] = findPar(par[u]);\\n    }\\n    \\n    void unn(int u,int v)\\n    {\\n        int x = findPar(u) , y = findPar(v);\\n        if(rank[x] > rank[y]) par[y] = x;\\n        else if(rank[x] < rank[y]) par[x] = y;\\n        else par[x] = y , rank[y]++;\\n    }\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        init(nums);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(__gcd(nums[i],nums[j]) > 1)\\n                {\\n                    unn(nums[i],nums[j]);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int,int> mp;\\n        for(auto &val : nums) mp[findPar(val)]++;\\n        \\n        int res = 0, len = 0;\\n        \\n        for(auto &[key,value] : mp)\\n        {\\n            if(value > len) len = value;\\n        }\\n        \\n        return len;\\n        \\n    }\\n};\\n```\\n\\n**Time Complexity :** O(n^2)\\n**Space Complexity :** O(n) [for rank and par map]\\n\\n## Method 3 (Optimal)\\n\\nWe know that elements having same factors can be put in one set. So we\\'ll calculate factors of every element in nums and then put elements with same factor in same set.\\n\\n```\\nclass Solution {\\n    void init(vector<int> &par)\\n    {\\n        for(int i=0;i<=100001;i++)\\n            par.push_back(i);\\n    }\\n    \\n    int findPar(int u,vector<int> &par)\\n    {\\n        if(par[u] == u) return u;\\n        \\n        return par[u] = findPar(par[u],par);\\n    }\\n    \\n    void unn(int u,int v,vector<int> &par)\\n    {\\n        int x = findPar(u,par) , y = findPar(v,par);\\n        if(x != y) par[x] = y;\\n    }\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        vector<int> par;\\n        init(par);\\n        \\n        for(auto &val : nums)\\n        {\\n            for(int k=2;k<=sqrt(val);k++)\\n            {\\n                if(val%k == 0)\\n                {\\n                    unn(val,k,par);\\n                    unn(val,val/k,par);\\n                }\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        unordered_map<int,int> mp;\\n        \\n        for(auto &val : nums)\\n        {\\n            int x = findPar(val,par);\\n            mp[x]++;\\n            cnt = max(cnt,mp[x]);\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\\n\\n**Time Complexity :** O(n * sqrt(max element in nums))\\n**Space Complexity :** O(n) [for parent array]\\n",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    \\n    void recur(int node,unordered_map<int,vector<int>> &mp,unordered_map<int,bool> &vis)\\n    {\\n        vis[node] = 1;\\n        // int cnt = 0;\\n        for(auto &val : mp[node])\\n        {\\n            if(vis.find(val) == vis.end())\\n            {\\n                recur(val,mp,vis);\\n            }\\n        }\\n    }\\n    \\n    int dfs(unordered_map<int,vector<int>> &mp)\\n    {\\n        int res = 0,prev = 0;\\n        unordered_map<int,bool> vis;\\n        for(auto &[key,value] : mp)\\n        {\\n            if(vis.find(key) == vis.end())\\n            {\\n                recur(key,mp,vis);\\n            }\\n            \\n            int len = vis.size() - prev;\\n            res = max(len,res);\\n            prev = vis.size();\\n        }\\n        \\n        return res;\\n    }\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(__gcd(nums[i] , nums[j]) > 1)\\n                {\\n                    mp[nums[i]].push_back(nums[j]);\\n                    mp[nums[j]].push_back(nums[i]);\\n                }\\n            }\\n        }\\n        \\n        return dfs(mp);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    map<int,int> rank;\\n    map<int,int> par;\\n    \\n    void init(vector<int> &nums)\\n    {\\n        for(auto &val : nums) rank[val] = 1 , par[val] = val;\\n    }\\n    \\n    int findPar(int u)\\n    {\\n        if(par[u] == u) return u;\\n        \\n        return par[u] = findPar(par[u]);\\n    }\\n    \\n    void unn(int u,int v)\\n    {\\n        int x = findPar(u) , y = findPar(v);\\n        if(rank[x] > rank[y]) par[y] = x;\\n        else if(rank[x] < rank[y]) par[x] = y;\\n        else par[x] = y , rank[y]++;\\n    }\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        init(nums);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(__gcd(nums[i],nums[j]) > 1)\\n                {\\n                    unn(nums[i],nums[j]);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int,int> mp;\\n        for(auto &val : nums) mp[findPar(val)]++;\\n        \\n        int res = 0, len = 0;\\n        \\n        for(auto &[key,value] : mp)\\n        {\\n            if(value > len) len = value;\\n        }\\n        \\n        return len;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    void init(vector<int> &par)\\n    {\\n        for(int i=0;i<=100001;i++)\\n            par.push_back(i);\\n    }\\n    \\n    int findPar(int u,vector<int> &par)\\n    {\\n        if(par[u] == u) return u;\\n        \\n        return par[u] = findPar(par[u],par);\\n    }\\n    \\n    void unn(int u,int v,vector<int> &par)\\n    {\\n        int x = findPar(u,par) , y = findPar(v,par);\\n        if(x != y) par[x] = y;\\n    }\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        vector<int> par;\\n        init(par);\\n        \\n        for(auto &val : nums)\\n        {\\n            for(int k=2;k<=sqrt(val);k++)\\n            {\\n                if(val%k == 0)\\n                {\\n                    unn(val,k,par);\\n                    unn(val,val/k,par);\\n                }\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        unordered_map<int,int> mp;\\n        \\n        for(auto &val : nums)\\n        {\\n            int x = findPar(val,par);\\n            mp[x]++;\\n            cnt = max(cnt,mp[x]);\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200712,
                "title": "fast-than-100-concise-java-solution",
                "content": "step 1. foreach element make it as distinct min prime factor save it to a map\\n(key is prime factor, value is element index set).\\neg. {10, 30, 18}->{2: {0,1,2}, 3 {1,2}, 5: {0,1}}\\n\\nstep 2. foreach set do union and find max cnt\\n\\n```\\n    int[] par;\\n    int[] cnt;\\n    private int find(int i) {\\n        if (i == par[i]) return i;\\n        return par[i] = find(par[i]);\\n    }\\n    private void union(int i, int j) {\\n        int pi = find(i);\\n        int pj = find(j);\\n        if (pi == pj) return ;\\n        par[pi] = pj;\\n        cnt[pj] += cnt[pi];\\n    }\\n    public int largestComponentSize(int[] A) {\\n        int N = A.length;\\n        par = new int[N];\\n        cnt = new int[N];\\n        Map<Integer, Set<Integer>> prime2Idx = new HashMap<>();\\n        for (int i = 0; i < N; i++) {\\n            int d = 2, x = A[i];\\n            while (d * d <= x) {\\n                if (x % d == 0) {\\n                    while (x % d == 0) x /= d;\\n                    prime2Idx.putIfAbsent(d, new HashSet<>());\\n                    prime2Idx.get(d).add(i);\\n                }\\n                d++;\\n            }\\n            if (x > 1) {\\n                prime2Idx.putIfAbsent(x, new HashSet<>());\\n                prime2Idx.get(x).add(i);\\n            }\\n        }\\n        for (int i = 0; i < N; i++) par[i] = i;\\n        Arrays.fill(cnt, 1);\\n        int max = 1;\\n        for (Set<Integer> s : prime2Idx.values()) {\\n            int fir = s.iterator().next();\\n            for (int idx : s) {\\n                union(idx, fir);\\n                max = Math.max(cnt[find(idx)],max);\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int[] par;\\n    int[] cnt;\\n    private int find(int i) {\\n        if (i == par[i]) return i;\\n        return par[i] = find(par[i]);\\n    }\\n    private void union(int i, int j) {\\n        int pi = find(i);\\n        int pj = find(j);\\n        if (pi == pj) return ;\\n        par[pi] = pj;\\n        cnt[pj] += cnt[pi];\\n    }\\n    public int largestComponentSize(int[] A) {\\n        int N = A.length;\\n        par = new int[N];\\n        cnt = new int[N];\\n        Map<Integer, Set<Integer>> prime2Idx = new HashMap<>();\\n        for (int i = 0; i < N; i++) {\\n            int d = 2, x = A[i];\\n            while (d * d <= x) {\\n                if (x % d == 0) {\\n                    while (x % d == 0) x /= d;\\n                    prime2Idx.putIfAbsent(d, new HashSet<>());\\n                    prime2Idx.get(d).add(i);\\n                }\\n                d++;\\n            }\\n            if (x > 1) {\\n                prime2Idx.putIfAbsent(x, new HashSet<>());\\n                prime2Idx.get(x).add(i);\\n            }\\n        }\\n        for (int i = 0; i < N; i++) par[i] = i;\\n        Arrays.fill(cnt, 1);\\n        int max = 1;\\n        for (Set<Integer> s : prime2Idx.values()) {\\n            int fir = s.iterator().next();\\n            for (int idx : s) {\\n                union(idx, fir);\\n                max = Math.max(cnt[find(idx)],max);\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 788988,
                "title": "c-simple-compact-union-find-97-space-and-time",
                "content": "Time Complexity is **O(N * sqrt(max(arr[i]))**.\\nThe idea is that for every number we find and link all of its  factors to a unique parent number. Then simply count the numbers which has the given parent and output the maximum such frequency.\\n```\\nint parent[100001];\\nint find (int x)\\n{\\n    if(parent[x]==-1)\\n        return x;\\n    else return parent[x]=find(parent[x]);\\n}\\nbool uni(int x,int y)\\n{\\n    int xp=find(x);\\n    int yp=find(y);\\n    if(xp!=yp)\\n        parent[yp]=xp;\\n    else return false;\\n    return true;\\n}\\nint largestComponentSize(vector<int>& arr) \\n{\\n    unordered_map<int,int> memo;\\n    memset(parent,-1,sizeof(parent));\\n    int ret=0;\\n    for(int x:arr)\\n    {\\n       int flag=0;\\n        for(int i=2;i*i<=x;++i)\\n            if(x%i==0)\\n            {\\n                uni(i,x);\\n                uni(x,x/i);\\n                flag=1;\\n            }\\n    }\\n    for(int x:arr)\\n        ret=max(ret,++memo[find(x)]);\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nint parent[100001];\\nint find (int x)\\n{\\n    if(parent[x]==-1)\\n        return x;\\n    else return parent[x]=find(parent[x]);\\n}\\nbool uni(int x,int y)\\n{\\n    int xp=find(x);\\n    int yp=find(y);\\n    if(xp!=yp)\\n        parent[yp]=xp;\\n    else return false;\\n    return true;\\n}\\nint largestComponentSize(vector<int>& arr) \\n{\\n    unordered_map<int,int> memo;\\n    memset(parent,-1,sizeof(parent));\\n    int ret=0;\\n    for(int x:arr)\\n    {\\n       int flag=0;\\n        for(int i=2;i*i<=x;++i)\\n            if(x%i==0)\\n            {\\n                uni(i,x);\\n                uni(x,x/i);\\n                flag=1;\\n            }\\n    }\\n    for(int x:arr)\\n        ret=max(ret,++memo[find(x)]);\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 349437,
                "title": "java-simple-o-n-sqrt-w-union-find-solution",
                "content": "We maintain a union set where several elements are connected if and only if they have any common factor greater than 1.\\nWe only have to connect each element in *A* with all its factors greater than 1, according to the nature of union set. We can do this by simply checking all the integers ranging from 2 to sqrt(A[i]).\\n```\\nclass Solution {\\n    \\n    int[] p;\\n    \\n    int get(int x){\\n        return p[x]==x ? x : (p[x]=get(p[x])) ;\\n    }\\n    \\n    void add(int x, int y){\\n        p[get(x)]=p[get(y)];\\n    }\\n    \\n    public int largestComponentSize(int[] A) {\\n        int mx=0;\\n        for(int i:A) mx=Math.max(i, mx);\\n        p=new int[mx+1];\\n        for(int i=1;i<=mx;++i) p[i]=i;\\n        for(int i:A)\\n            for(int j=(int)Math.sqrt(i);j>=2;--j)\\n                if(i%j==0){\\n                    add(i, j);\\n                    add(i, i/j);\\n                }\\n        Map<Integer, Integer> map=new HashMap<Integer, Integer>();\\n        int res=0;\\n        for(int i:A){\\n            int j=get(i);\\n            if(!map.containsKey(j)) map.put(j, 1);\\n            else map.put(j, map.get(j)+1);\\n            res=Math.max(res, map.get(j));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int[] p;\\n    \\n    int get(int x){\\n        return p[x]==x ? x : (p[x]=get(p[x])) ;\\n    }\\n    \\n    void add(int x, int y){\\n        p[get(x)]=p[get(y)];\\n    }\\n    \\n    public int largestComponentSize(int[] A) {\\n        int mx=0;\\n        for(int i:A) mx=Math.max(i, mx);\\n        p=new int[mx+1];\\n        for(int i=1;i<=mx;++i) p[i]=i;\\n        for(int i:A)\\n            for(int j=(int)Math.sqrt(i);j>=2;--j)\\n                if(i%j==0){\\n                    add(i, j);\\n                    add(i, i/j);\\n                }\\n        Map<Integer, Integer> map=new HashMap<Integer, Integer>();\\n        int res=0;\\n        for(int i:A){\\n            int j=get(i);\\n            if(!map.containsKey(j)) map.put(j, 1);\\n            else map.put(j, map.get(j)+1);\\n            res=Math.max(res, map.get(j));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581394,
                "title": "python-1032ms-beat-100-time-space",
                "content": "**Step 1: get primes less than sqrt(max(A))\\nStep 2: compute factors for each number in A\\nStep 3: use union-find to link two primes if they are factors of the same number in A\\nStep 4: for each number in A, add to its union (the union represented by its smallest prime)**\\n```\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        primes = []\\n        for x in range(2, int(max(A)**0.5)+1):\\n            for y in primes:\\n                if x % y == 0:\\n                    break\\n            else:\\n                primes.append(x)\\n    \\n        factors = collections.defaultdict(list)         # compute factors of each \\'a\\'\\n        for a in A:\\n            x = a\\n            for p in primes:\\n                if p*p > x:\\n                    break\\n                if x % p == 0:\\n                    factors[a].append(p)\\n                    while x % p == 0:\\n                        x //= p\\n            if x > 1:                                   # a new prime found\\n                factors[a].append(x)\\n                primes.append(x)\\n                \\n        primes = list(set(primes))\\n        n = len(primes)\\n        p2i = {p: i for i,p in enumerate(primes)}       # prime to index\\n        \\n        parent = [i for i in range(n)]                  # union-find on primes\\n        \\n        def find(i):\\n            if i != parent[i]:\\n                parent[i] = find(parent[i])\\n            return parent[i]\\n        \\n        def union(i,j):\\n            pi, pj = find(i), find(j)\\n            if pi != pj:\\n                parent[pi] = pj\\n\\n        for a in A:\\n            if factors[a]:\\n                p0 = factors[a][0]\\n                for p in factors[a][1:]:                # link two primes if they are factors of \\'a\\'\\n                    union(p2i[p0], p2i[p])\\n        \\n        count = collections.Counter(find(p2i[factors[a][0]]) for a in A if factors[a])      # each \\'a\\' corresponds to a prime index\\n        return max(count.values())\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        primes = []\\n        for x in range(2, int(max(A)**0.5)+1):\\n            for y in primes:\\n                if x % y == 0:\\n                    break\\n            else:\\n                primes.append(x)\\n    \\n        factors = collections.defaultdict(list)         # compute factors of each \\'a\\'\\n        for a in A:\\n            x = a\\n            for p in primes:\\n                if p*p > x:\\n                    break\\n                if x % p == 0:\\n                    factors[a].append(p)\\n                    while x % p == 0:\\n                        x //= p\\n            if x > 1:                                   # a new prime found\\n                factors[a].append(x)\\n                primes.append(x)\\n                \\n        primes = list(set(primes))\\n        n = len(primes)\\n        p2i = {p: i for i,p in enumerate(primes)}       # prime to index\\n        \\n        parent = [i for i in range(n)]                  # union-find on primes\\n        \\n        def find(i):\\n            if i != parent[i]:\\n                parent[i] = find(parent[i])\\n            return parent[i]\\n        \\n        def union(i,j):\\n            pi, pj = find(i), find(j)\\n            if pi != pj:\\n                parent[pi] = pj\\n\\n        for a in A:\\n            if factors[a]:\\n                p0 = factors[a][0]\\n                for p in factors[a][1:]:                # link two primes if they are factors of \\'a\\'\\n                    union(p2i[p0], p2i[p])\\n        \\n        count = collections.Counter(find(p2i[factors[a][0]]) for a in A if factors[a])      # each \\'a\\' corresponds to a prime index\\n        return max(count.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592323,
                "title": "c-disjoint-set-union-find-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    vector<int> rank;\\n    \\n    int find(int x){\\n        if(parent[x]==x) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    void unionDsu(int x, int y){\\n        int _x = find(x), _y = find(y);\\n        if(_x == _y) return;\\n        if (rank[_x] < rank[_y]){\\n            parent[_x] = _y;\\n        }else if(rank[_x] > rank[_y]){\\n            parent[_y] = _x;\\n        }else{\\n            parent[_y] = _x;\\n            rank[_x]+=1;\\n        }\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int size = *max_element(nums.begin(), nums.end());\\n        parent.resize(size+1);\\n        for(int i=0; i<size+1; ++i) parent[i]=i;\\n        rank.resize(size+1,1);\\n        \\n        for(int i=0; i<nums.size(); ++i){\\n            for(int j=2; j<=sqrt(nums[i]); ++j){\\n                if(nums[i]%j==0){\\n                    unionDsu(nums[i], j);\\n                    unionDsu(nums[i]/j, j);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int,int> map;\\n        for(int i=0; i<nums.size(); ++i){\\n            int _x = find(nums[i]);\\n            map[_x]++;\\n        }\\n        \\n        int maxCount = 0;\\n        for(auto &m : map) maxCount = max(maxCount, m.second);\\n        \\n        return maxCount;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    vector<int> rank;\\n    \\n    int find(int x){\\n        if(parent[x]==x) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    void unionDsu(int x, int y){\\n        int _x = find(x), _y = find(y);\\n        if(_x == _y) return;\\n        if (rank[_x] < rank[_y]){\\n            parent[_x] = _y;\\n        }else if(rank[_x] > rank[_y]){\\n            parent[_y] = _x;\\n        }else{\\n            parent[_y] = _x;\\n            rank[_x]+=1;\\n        }\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int size = *max_element(nums.begin(), nums.end());\\n        parent.resize(size+1);\\n        for(int i=0; i<size+1; ++i) parent[i]=i;\\n        rank.resize(size+1,1);\\n        \\n        for(int i=0; i<nums.size(); ++i){\\n            for(int j=2; j<=sqrt(nums[i]); ++j){\\n                if(nums[i]%j==0){\\n                    unionDsu(nums[i], j);\\n                    unionDsu(nums[i]/j, j);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int,int> map;\\n        for(int i=0; i<nums.size(); ++i){\\n            int _x = find(nums[i]);\\n            map[_x]++;\\n        }\\n        \\n        int maxCount = 0;\\n        for(auto &m : map) maxCount = max(maxCount, m.second);\\n        \\n        return maxCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592773,
                "title": "java-solution-using-disjoint-set-union-hashmap",
                "content": "```\\nclass DSU {\\n    ArrayList<Integer> parent = new ArrayList();\\n    public DSU (int n) {\\n        for (int i = 0; i < n; i++)\\n            parent.add(i);\\n    }\\n    int findParent(int n) {\\n        if(parent.get(n) == n)\\n            return n;\\n        parent.set(n, findParent(parent.get(n)));\\n        return parent.get(n);\\n    }\\n    void union(int u, int v) {\\n        int uParent = findParent(u);\\n        int vParent = findParent(v);\\n        \\n        if(uParent != vParent)\\n            parent.set(uParent, parent.get(vParent));\\n    }\\n}\\nclass Solution {\\n    public int largestComponentSize(int[] nums) {\\n        int n = nums.length;\\n        int x = nums[0];\\n        for (int num : nums)\\n            x = Math.max(x, num);\\n        DSU dsu = new DSU(x + 1);\\n        \\n        for (int num : nums) {\\n            for (int i = 2; i * i <= num; i++) {\\n                if (num % i == 0) {\\n                    dsu.union(num, i);\\n                    dsu.union(num, num/i);\\n                }\\n            }\\n        }\\n        Map<Integer, Integer> map = new HashMap();\\n        int ans = 1;\\n        for (int num : nums) {\\n            int par = dsu.findParent(num);\\n            map.put(par, map.getOrDefault(par, 0) + 1);\\n            ans = Math.max(ans, map.get(par));\\n        }\\n        return ans;\\n    }\\n}\\n```\\nPlease **upvote** :-)",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass DSU {\\n    ArrayList<Integer> parent = new ArrayList();\\n    public DSU (int n) {\\n        for (int i = 0; i < n; i++)\\n            parent.add(i);\\n    }\\n    int findParent(int n) {\\n        if(parent.get(n) == n)\\n            return n;\\n        parent.set(n, findParent(parent.get(n)));\\n        return parent.get(n);\\n    }\\n    void union(int u, int v) {\\n        int uParent = findParent(u);\\n        int vParent = findParent(v);\\n        \\n        if(uParent != vParent)\\n            parent.set(uParent, parent.get(vParent));\\n    }\\n}\\nclass Solution {\\n    public int largestComponentSize(int[] nums) {\\n        int n = nums.length;\\n        int x = nums[0];\\n        for (int num : nums)\\n            x = Math.max(x, num);\\n        DSU dsu = new DSU(x + 1);\\n        \\n        for (int num : nums) {\\n            for (int i = 2; i * i <= num; i++) {\\n                if (num % i == 0) {\\n                    dsu.union(num, i);\\n                    dsu.union(num, num/i);\\n                }\\n            }\\n        }\\n        Map<Integer, Integer> map = new HashMap();\\n        int ans = 1;\\n        for (int num : nums) {\\n            int par = dsu.findParent(num);\\n            map.put(par, map.getOrDefault(par, 0) + 1);\\n            ans = Math.max(ans, map.get(par));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820994,
                "title": "cpp-union-find-using-map-with-explanation",
                "content": "tldr: By using map we can save the space from max(array) to sqrt(max(array)).\\n\\nThis question is basically asking the largest connected component in a forest. In order to do so, we need to find a way to \"group\" all the nodes whose common divisor (one by one, not among any two) is greater than 1 together to a single tree, and we need a \"root\" as an id to quantify how many kids does this tree hold. This leads to Union-Find.\\n\\n---\\nstep 1 build the graph:\\n* start with all the nodes themselves, they are \"self-connected\"\\n---\\nstep 2 find all the divisor of current node\\n* after we put node value to the tree, we also need to group all the divisor >= 2 with current root node.\\n* this can be done with sqrt(n) times, since any two divisor a * b < n, a has to be less than sqrt(n).\\n---\\nstep 3 check the root and do the counting\\n* now we have built our tree, and we can easily find the root node (or id) for each node, we can just count the number of id and find the max.\\n```cpp\\nclass Solution {\\npublic:\\n    unordered_map<int, int> p;\\n    \\n    int find(int a) {\\n        if (!p.count(a)) return p[a] = a;\\n        if (p[a] == a) return a;\\n        return p[a] = find(p[a]);\\n    }\\n    \\n    int largestComponentSize(vector<int>& A) {\\n        int n = A.size();\\n        for (int a : A)\\n            p[a] = a;\\n        for (int a : A) \\n            for (int i = 2; i <= sqrt(a); ++i)\\n                if (a % i == 0) {\\n                    p[find(a)] = p[find(i)];\\n                    p[find(a)] = p[find(a / i)];\\n                }\\n        unordered_map<int, int> cnt;\\n        int res = 1;\\n        for (int a : A)\\n            res = max(res, ++cnt[find(a)]);\\n        return res;\\n    }\\n};\\n```\\n\\nQ&A:\\nwhy \\n```cpp\\nfor (int a : A) \\n\\tfor (int i = 2; i <= sqrt(a); ++i)\\n\\t\\tif (a % i == 0) {\\n\\t\\t\\tp[find(a)] = p[find(i)];\\n\\t\\t\\tp[find(a)] = p[find(a / i)];\\n\\t\\t}\\n```\\ninstead of\\n```cpp\\nfor (int a : A) \\n\\tfor (int i = 2; i <= sqrt(a); ++i) {\\n\\t\\tint root = find(a);\\n\\t\\tif (a % i == 0) {\\n\\t\\t\\tp[root] = p[find(i)];\\n\\t\\t\\tp[root] = p[find(a / i)];\\n\\t\\t}\\n\\t}\\n```\\nBecause our root is going to change every time when the p map is updated.\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    unordered_map<int, int> p;\\n    \\n    int find(int a) {\\n        if (!p.count(a)) return p[a] = a;\\n        if (p[a] == a) return a;\\n        return p[a] = find(p[a]);\\n    }\\n    \\n    int largestComponentSize(vector<int>& A) {\\n        int n = A.size();\\n        for (int a : A)\\n            p[a] = a;\\n        for (int a : A) \\n            for (int i = 2; i <= sqrt(a); ++i)\\n                if (a % i == 0) {\\n                    p[find(a)] = p[find(i)];\\n                    p[find(a)] = p[find(a / i)];\\n                }\\n        unordered_map<int, int> cnt;\\n        int res = 1;\\n        for (int a : A)\\n            res = max(res, ++cnt[find(a)]);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nfor (int a : A) \\n\\tfor (int i = 2; i <= sqrt(a); ++i)\\n\\t\\tif (a % i == 0) {\\n\\t\\t\\tp[find(a)] = p[find(i)];\\n\\t\\t\\tp[find(a)] = p[find(a / i)];\\n\\t\\t}\\n```\n```cpp\\nfor (int a : A) \\n\\tfor (int i = 2; i <= sqrt(a); ++i) {\\n\\t\\tint root = find(a);\\n\\t\\tif (a % i == 0) {\\n\\t\\t\\tp[root] = p[find(i)];\\n\\t\\t\\tp[root] = p[find(a / i)];\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593150,
                "title": "c-simple-solution-using-depth-first-search-and-prime-factorization",
                "content": "```\\nclass Solution {\\n    final int MAX = (int)1e5;\\n    boolean[] vis;\\n    int[] occ;\\n    int[] LPF; // Least prime factor\\n    \\n    int dfs(int x) {\\n        if (x > MAX || vis[x] == true) return 0;\\n        vis[x] = true;\\n        \\n        int cnt = occ[x];\\n        \\n        if (x == LPF[x]) { // if prime\\n            for (int i = x+x; i <= MAX; i += x) {\\n                cnt += dfs(i);\\n            }\\n        }\\n        else if (occ[x] > 0) { // if cotains in nums array\\n            for (x = x; x > 1; x /= LPF[x]) { // Log(x) prime factorization \\n                cnt += dfs(LPF[x]);\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    public int largestComponentSize(int[] nums) {\\n        occ = new int[MAX+10];\\n        for (int num : nums) occ[num]++;\\n        \\n        LPF = new int[MAX+10];\\n        for (int i = 2; i <= MAX; i++) {\\n            if (LPF[i] == 0) {\\n                for (int j = i; j <= MAX; j += i) {\\n                    if (LPF[j] == 0) LPF[j] = i;\\n                }\\n            }\\n        }\\n        \\n        vis = new boolean[MAX+10];\\n        int ans = 0;\\n        for (int i = 2; i <= MAX; i++) {\\n            ans = Math.max(ans, dfs(i));\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    final int MAX = (int)1e5;\\n    boolean[] vis;\\n    int[] occ;\\n    int[] LPF; // Least prime factor\\n    \\n    int dfs(int x) {\\n        if (x > MAX || vis[x] == true) return 0;\\n        vis[x] = true;\\n        \\n        int cnt = occ[x];\\n        \\n        if (x == LPF[x]) { // if prime\\n            for (int i = x+x; i <= MAX; i += x) {\\n                cnt += dfs(i);\\n            }\\n        }\\n        else if (occ[x] > 0) { // if cotains in nums array\\n            for (x = x; x > 1; x /= LPF[x]) { // Log(x) prime factorization \\n                cnt += dfs(LPF[x]);\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    public int largestComponentSize(int[] nums) {\\n        occ = new int[MAX+10];\\n        for (int num : nums) occ[num]++;\\n        \\n        LPF = new int[MAX+10];\\n        for (int i = 2; i <= MAX; i++) {\\n            if (LPF[i] == 0) {\\n                for (int j = i; j <= MAX; j += i) {\\n                    if (LPF[j] == 0) LPF[j] = i;\\n                }\\n            }\\n        }\\n        \\n        vis = new boolean[MAX+10];\\n        int ans = 0;\\n        for (int i = 2; i <= MAX; i++) {\\n            ans = Math.max(ans, dfs(i));\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821162,
                "title": "java-2-simple-solutions-one-using-dfs-and-another-using-union-find",
                "content": "Here I have given 2 solutions one using dfs and another using union-find. Bothe approach share the same initial preprocessing steps! The only thing that is different is thet in union find we check size of every root node where as in dfs implementation we use dfs to find size of every connected component.\\n\\n**1. Using DFS**\\n```\\nclass Solution {\\n    \\n    ArrayList<Integer>[] graph;\\n    boolean[] visited;\\n    int count=0;\\n    \\n\\tpublic int largestComponentSize(int[] A) {\\n\\t\\t\\n\\t\\t//Getting prime factors of every element in the array A\\n        HashSet<Integer> primes[] = new HashSet[A.length];\\n        for(int i=0; i<A.length; i++){\\n            primes[i] = primeFact(A[i]);\\n        }\\n\\t\\t\\n\\t\\t//Generating HashMap with every prime factor as key and list of elements\\' index that has that particular number as prime factor as value\\n        HashMap<Integer, ArrayList<Integer>> mapping = new HashMap<>();\\n        for(int i=0; i<primes.length; i++){\\n            for(int fact: primes[i]){\\n                if(!mapping.containsKey(fact))\\n                    mapping.put(fact, new ArrayList<Integer>());\\n                mapping.get(fact).add(i);\\n            }\\n        }\\n\\t\\t\\n        //Initializing graph\\n        graph = new ArrayList[A.length];\\n        visited = new boolean[A.length];\\n        for(int i=0; i<A.length; i++)\\n            graph[i]=new ArrayList<>();\\n        \\n\\t\\t//Adding edges between nodes that share common prime factors\\n\\t\\t//There will be duplicate node in this adjacency list. We can use HashSet but overhead is big! \\n\\t\\t//As during dfs we do use visited array so every node is visited once so duplicate entries don\\'t bother that much\\n        for(ArrayList<Integer> arr:mapping.values()){\\n            for(int i=1; i<arr.size(); i++){\\n                graph[arr.get(i-1)].add(arr.get(i));\\n                graph[arr.get(i)].add(arr.get(i-1));\\n            }\\n        }\\n        \\n\\t\\t//finding the size of largest connected component\\n        int max = 0;\\n        for(int i=0; i<A.length; i++){\\n            if(!visited[i]){\\n                count=0;\\n                dfs(i);\\n                max = Math.max(max, count);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private void dfs(int node){\\n        visited[node]=true;\\n        count++;\\n        for(int nbr:graph[node]){\\n            if(!visited[nbr]){\\n                dfs(nbr);\\n            }\\n        }\\n    }\\n    \\n    private HashSet<Integer> primeFact(int n){\\n        HashSet<Integer> ans = new HashSet<>();\\n        if(n==1)\\n            return ans;\\n        \\n        while(n%2==0){\\n            ans.add(2);\\n            n/=2;\\n        }\\n        for(int i=3; i<=Math.sqrt(n); i+=2){\\n            // System.out.println(n%i);\\n            while(n%i==0){\\n                n/=i;\\n                ans.add(i);\\n            }\\n        }\\n        if(n>2)\\n            ans.add(n);\\n        return ans;\\n    }\\n}\\n```\\n\\n**2. Using Union Find(More effiecient)**\\n\\n```\\nclass Solution {\\n    \\n    int[] sz, id;\\n    \\n    public int largestComponentSize(int[] A) {\\n\\t\\n\\t\\t//Getting prime factors of every element in the array A\\n        HashSet<Integer> primes[] = new HashSet[A.length];\\n        for(int i=0; i<A.length; i++){\\n            primes[i] = primeFact(A[i]);\\n        }\\n\\t\\t\\n\\t\\t//Generating HashMap with every prime factor as key and list of elements\\' index that has that particular number as prime factor as value\\n        HashMap<Integer, ArrayList<Integer>> mapping = new HashMap<>();\\n        for(int i=0; i<primes.length; i++){\\n            for(int fact: primes[i]){\\n                if(!mapping.containsKey(fact))\\n                    mapping.put(fact, new ArrayList<Integer>());\\n                mapping.get(fact).add(i);\\n            }\\n        }\\n        \\n\\t\\t//Initializing arrays for union-find \\n        this.sz = new int[A.length];\\n        this.id = new int[A.length];\\n        \\n        for(int i=0; i<id.length; i++){\\n            sz[i]=1; //Initial size of each componenet is 1\\n            id[i]=i; //Initially every node is root node \\n        }\\n        \\n\\t\\t//Calling union with elements that share same prime factore\\n        for(ArrayList<Integer> arr:mapping.values())\\n            for(int i=1; i<arr.size(); i++)\\n                union(arr.get(i-1), arr.get(i));\\n        \\n\\t\\t//finding the size of largest component size in disjoint set\\n        int max = 0;\\n        for(int i=0; i<A.length; i++){\\n            max = Math.max(max, this.sz[find(i)]);\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int find(int node){\\n\\t\\t\\n\\t\\t//Finding root node\\n        int root = node;\\n        while(root!=this.id[root]){\\n            root = this.id[root];\\n        }\\n        \\n\\t\\t//Path Compression\\n\\t\\twhile(node!=root){\\n            int tmp = this.id[node];\\n            this.id[node] = root;\\n            node = tmp;\\n        }\\n        return root;\\n    }\\n    \\n    private void union(int i, int j){\\n        int root1 = find(i);\\n        int root2 = find(j);\\n        \\n        if(root1==root2)\\n            return;\\n        \\n\\t\\t//Merging smaller component into larger one\\n        if(this.sz[root1]<=this.sz[root2]){\\n            this.sz[root2]+=this.sz[root1];\\n            this.id[root1]=root2;\\n        }else{\\n            this.sz[root1]+=this.sz[root2];\\n            this.id[root2]=root1;\\n        }\\n    }\\n    \\n    private HashSet<Integer> primeFact(int n){\\n        HashSet<Integer> ans = new HashSet<>();\\n        if(n==1){\\n            return ans;\\n        }\\n\\t\\t\\n        while(n%2==0){\\n            ans.add(2);\\n            n/=2;\\n        }\\n        for(int i=3; i<=Math.sqrt(n); i+=2){\\n            while(n%i==0){\\n                n/=i;\\n                ans.add(i);\\n            }\\n        }\\n        if(n>2)\\n            ans.add(n);\\n        return ans;\\n    }\\n}\\n```\\n\\nHere time complexity of both approach is more or less same. In both approach first thing that is different that in dfs one we create graph by adding edges and in the later one we call union function and create components with that. We know that union method\\'s amortized time complexity effectively becomes small constant with path compression. \\n\\nNow main difference is in the last part where we find the size of the largest component! In the dfs approach we call the dfs in loop and keep track of size of each component. This approach is little ineffecient as there are duplicate nodes in the adjacency list but it doesn\\'t affect that much due to the use of visited array but we do run a loop for every nbr in the adj list. Where as in the union find we find size of the root for every node so find has amortized complexity of contant and we do that also n times so this may be little bit more efficient in some cases but it doen\\'t make that much difference.",
                "solutionTags": [
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    \\n    ArrayList<Integer>[] graph;\\n    boolean[] visited;\\n    int count=0;\\n    \\n\\tpublic int largestComponentSize(int[] A) {\\n\\t\\t\\n\\t\\t//Getting prime factors of every element in the array A\\n        HashSet<Integer> primes[] = new HashSet[A.length];\\n        for(int i=0; i<A.length; i++){\\n            primes[i] = primeFact(A[i]);\\n        }\\n\\t\\t\\n\\t\\t//Generating HashMap with every prime factor as key and list of elements\\' index that has that particular number as prime factor as value\\n        HashMap<Integer, ArrayList<Integer>> mapping = new HashMap<>();\\n        for(int i=0; i<primes.length; i++){\\n            for(int fact: primes[i]){\\n                if(!mapping.containsKey(fact))\\n                    mapping.put(fact, new ArrayList<Integer>());\\n                mapping.get(fact).add(i);\\n            }\\n        }\\n\\t\\t\\n        //Initializing graph\\n        graph = new ArrayList[A.length];\\n        visited = new boolean[A.length];\\n        for(int i=0; i<A.length; i++)\\n            graph[i]=new ArrayList<>();\\n        \\n\\t\\t//Adding edges between nodes that share common prime factors\\n\\t\\t//There will be duplicate node in this adjacency list. We can use HashSet but overhead is big! \\n\\t\\t//As during dfs we do use visited array so every node is visited once so duplicate entries don\\'t bother that much\\n        for(ArrayList<Integer> arr:mapping.values()){\\n            for(int i=1; i<arr.size(); i++){\\n                graph[arr.get(i-1)].add(arr.get(i));\\n                graph[arr.get(i)].add(arr.get(i-1));\\n            }\\n        }\\n        \\n\\t\\t//finding the size of largest connected component\\n        int max = 0;\\n        for(int i=0; i<A.length; i++){\\n            if(!visited[i]){\\n                count=0;\\n                dfs(i);\\n                max = Math.max(max, count);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private void dfs(int node){\\n        visited[node]=true;\\n        count++;\\n        for(int nbr:graph[node]){\\n            if(!visited[nbr]){\\n                dfs(nbr);\\n            }\\n        }\\n    }\\n    \\n    private HashSet<Integer> primeFact(int n){\\n        HashSet<Integer> ans = new HashSet<>();\\n        if(n==1)\\n            return ans;\\n        \\n        while(n%2==0){\\n            ans.add(2);\\n            n/=2;\\n        }\\n        for(int i=3; i<=Math.sqrt(n); i+=2){\\n            // System.out.println(n%i);\\n            while(n%i==0){\\n                n/=i;\\n                ans.add(i);\\n            }\\n        }\\n        if(n>2)\\n            ans.add(n);\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    int[] sz, id;\\n    \\n    public int largestComponentSize(int[] A) {\\n\\t\\n\\t\\t//Getting prime factors of every element in the array A\\n        HashSet<Integer> primes[] = new HashSet[A.length];\\n        for(int i=0; i<A.length; i++){\\n            primes[i] = primeFact(A[i]);\\n        }\\n\\t\\t\\n\\t\\t//Generating HashMap with every prime factor as key and list of elements\\' index that has that particular number as prime factor as value\\n        HashMap<Integer, ArrayList<Integer>> mapping = new HashMap<>();\\n        for(int i=0; i<primes.length; i++){\\n            for(int fact: primes[i]){\\n                if(!mapping.containsKey(fact))\\n                    mapping.put(fact, new ArrayList<Integer>());\\n                mapping.get(fact).add(i);\\n            }\\n        }\\n        \\n\\t\\t//Initializing arrays for union-find \\n        this.sz = new int[A.length];\\n        this.id = new int[A.length];\\n        \\n        for(int i=0; i<id.length; i++){\\n            sz[i]=1; //Initial size of each componenet is 1\\n            id[i]=i; //Initially every node is root node \\n        }\\n        \\n\\t\\t//Calling union with elements that share same prime factore\\n        for(ArrayList<Integer> arr:mapping.values())\\n            for(int i=1; i<arr.size(); i++)\\n                union(arr.get(i-1), arr.get(i));\\n        \\n\\t\\t//finding the size of largest component size in disjoint set\\n        int max = 0;\\n        for(int i=0; i<A.length; i++){\\n            max = Math.max(max, this.sz[find(i)]);\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int find(int node){\\n\\t\\t\\n\\t\\t//Finding root node\\n        int root = node;\\n        while(root!=this.id[root]){\\n            root = this.id[root];\\n        }\\n        \\n\\t\\t//Path Compression\\n\\t\\twhile(node!=root){\\n            int tmp = this.id[node];\\n            this.id[node] = root;\\n            node = tmp;\\n        }\\n        return root;\\n    }\\n    \\n    private void union(int i, int j){\\n        int root1 = find(i);\\n        int root2 = find(j);\\n        \\n        if(root1==root2)\\n            return;\\n        \\n\\t\\t//Merging smaller component into larger one\\n        if(this.sz[root1]<=this.sz[root2]){\\n            this.sz[root2]+=this.sz[root1];\\n            this.id[root1]=root2;\\n        }else{\\n            this.sz[root1]+=this.sz[root2];\\n            this.id[root2]=root1;\\n        }\\n    }\\n    \\n    private HashSet<Integer> primeFact(int n){\\n        HashSet<Integer> ans = new HashSet<>();\\n        if(n==1){\\n            return ans;\\n        }\\n\\t\\t\\n        while(n%2==0){\\n            ans.add(2);\\n            n/=2;\\n        }\\n        for(int i=3; i<=Math.sqrt(n); i+=2){\\n            while(n%i==0){\\n                n/=i;\\n                ans.add(i);\\n            }\\n        }\\n        if(n>2)\\n            ans.add(n);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592465,
                "title": "simplest-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // M = MAX ELEMENT\\n    // TIME COMPLEXITY:- O(MLOG(M))\\n    // SPQACE COMPLEXITY:- O(M)\\n    \\n     // finds the parent of a connected component\\n    int find_set(int x,vector<pair<int,int>>& parent){\\n        return parent[x].first==x?x:parent[x].first = find_set(parent[x].first,parent);\\n    }\\n    \\n    // unites two connected component if they have different parent\\'s\\n    void union_set(int x,int y,vector<pair<int,int>>& parent,vector<int>& comp){\\n        int xroot = find_set(x,parent),yroot = find_set(y,parent);\\n        if(xroot==yroot)\\n            return; // have same parent\\n        \\n        // rank compression \\n        if(parent[xroot].second==parent[yroot].second)\\n            parent[xroot].second++;\\n        if(parent[xroot].second>parent[yroot].second){\\n            parent[yroot].first = xroot;\\n            comp[xroot] += comp[yroot]; // increase the component size on merging\\n        }\\n        else{\\n            parent[xroot].first = yroot;\\n            comp[yroot] += comp[xroot]; // increase the component size on merging\\n        }\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int N = *max_element(nums.begin(),nums.end());\\n        vector<bool> isPresent(N+1,false);\\n        \\n        for(auto& c:nums)\\n            isPresent[c] = true;\\n        \\n        // use NlogN time to mark all numbers which have same factor i\\n        vector<int> adj[N+1];\\n        for(int i=2;i<=N;i++){\\n            for(int j=i;j<=N;j+=i){\\n                if(isPresent[j])\\n                    adj[i].push_back(j);\\n            }\\n        }\\n        \\n        // parent[i].first = store parent of the connected component\\n        // parent[i].second = store rank of the connected component\\n        // comp[i] will store size of connected component\\n        \\n        vector<int> comp(N+1);\\n        vector<pair<int,int>> parent;\\n        for(int i=0;i<=N;i++){\\n            if(isPresent[i])\\n                comp[i] = 1;\\n            parent.push_back({i,0});\\n        }\\n        \\n        // unite two numbers which has same factor i\\n        for(int i=1;i<=N;i++){\\n            for(int j=1;j<adj[i].size();j++)\\n                union_set(adj[i][j-1],adj[i][j],parent,comp);\\n        }\\n        \\n        // find the maximum size of connected component\\n        int ans = 0;\\n        for(auto& c:comp)\\n            ans = max(ans,c);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // M = MAX ELEMENT\\n    // TIME COMPLEXITY:- O(MLOG(M))\\n    // SPQACE COMPLEXITY:- O(M)\\n    \\n     // finds the parent of a connected component\\n    int find_set(int x,vector<pair<int,int>>& parent){\\n        return parent[x].first==x?x:parent[x].first = find_set(parent[x].first,parent);\\n    }\\n    \\n    // unites two connected component if they have different parent\\'s\\n    void union_set(int x,int y,vector<pair<int,int>>& parent,vector<int>& comp){\\n        int xroot = find_set(x,parent),yroot = find_set(y,parent);\\n        if(xroot==yroot)\\n            return; // have same parent\\n        \\n        // rank compression \\n        if(parent[xroot].second==parent[yroot].second)\\n            parent[xroot].second++;\\n        if(parent[xroot].second>parent[yroot].second){\\n            parent[yroot].first = xroot;\\n            comp[xroot] += comp[yroot]; // increase the component size on merging\\n        }\\n        else{\\n            parent[xroot].first = yroot;\\n            comp[yroot] += comp[xroot]; // increase the component size on merging\\n        }\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int N = *max_element(nums.begin(),nums.end());\\n        vector<bool> isPresent(N+1,false);\\n        \\n        for(auto& c:nums)\\n            isPresent[c] = true;\\n        \\n        // use NlogN time to mark all numbers which have same factor i\\n        vector<int> adj[N+1];\\n        for(int i=2;i<=N;i++){\\n            for(int j=i;j<=N;j+=i){\\n                if(isPresent[j])\\n                    adj[i].push_back(j);\\n            }\\n        }\\n        \\n        // parent[i].first = store parent of the connected component\\n        // parent[i].second = store rank of the connected component\\n        // comp[i] will store size of connected component\\n        \\n        vector<int> comp(N+1);\\n        vector<pair<int,int>> parent;\\n        for(int i=0;i<=N;i++){\\n            if(isPresent[i])\\n                comp[i] = 1;\\n            parent.push_back({i,0});\\n        }\\n        \\n        // unite two numbers which has same factor i\\n        for(int i=1;i<=N;i++){\\n            for(int j=1;j<adj[i].size();j++)\\n                union_set(adj[i][j-1],adj[i][j],parent,comp);\\n        }\\n        \\n        // find the maximum size of connected component\\n        int ans = 0;\\n        for(auto& c:comp)\\n            ans = max(ans,c);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570148,
                "title": "c-232-ms-union-find-factorisation",
                "content": "## Approach\\n<hr>\\nWe know from the problem statement, that if any two number have a common factor, they need to be put in the same set. For this, we can iterate over the list, factorize the number, for each of its factor (not 1 and number itself), we should unite the sets using [Disjoin set Union](https://cp-algorithms.com/data_structures/disjoint_set_union.html) (use path compession for efficiency).\\n\\nFor instance, if we have [4, 6]\\n`factorize 4`: `2`\\n`unite(4, 2)`\\n`factorize 6`: `2, 3`\\n`unite(6, 2)`\\n`unite(6, 3)`\\n\\nat the end we see that 4 and 6 belong to the same set.\\nwe use `unordered_map` to store parents and their frequency at the end and get parent with maximum size.\\n\\n## Code\\n<hr>\\n\\n```cpp\\nstruct DSU {\\n\\tvector<int> e;\\n\\tDSU(int N) { e = vector<int>(N, -1); }\\n\\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\\n\\tbool same_set(int a, int b) { return get(a) == get(b); }\\n\\tint size(int x) { return -e[get(x)]; }\\n\\tbool unite(int x, int y) { \\n\\t\\tx = get(x), y = get(y);\\n\\t\\tif (x == y) return false;\\n\\t\\tif (e[x] > e[y]) swap(x, y);\\n\\t\\te[x] += e[y]; e[y] = x;\\n\\t\\treturn true;\\n\\t}\\n};\\n\\nint largestComponentSize(vector<int>& nums) {\\n\\tDSU dsu(*max_element(nums.begin(), nums.end()) + 1); //create DSU struct with nodes 0, 1, 2, ... max element of the vector\\n\\tfor(auto i: nums){\\n\\t\\tfor(int j = 2;j*j<=i;j++){ //factorize each number\\n\\t\\t\\tif(i%j == 0){\\n\\t\\t\\t\\tdsu.unite(j, i);\\n\\t\\t\\t\\tdsu.unite(i/j, i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tint ans = 1;\\n\\tunordered_map<int, int> freq;\\n\\tfor(auto i: nums){\\n\\t\\tint p = dsu.get(i); //get parent\\n\\t\\tfreq[p]++;\\n\\t\\tans = max(ans, freq[p]);\\n\\t}\\n\\treturn ans;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\nstruct DSU {\\n\\tvector<int> e;\\n\\tDSU(int N) { e = vector<int>(N, -1); }\\n\\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\\n\\tbool same_set(int a, int b) { return get(a) == get(b); }\\n\\tint size(int x) { return -e[get(x)]; }\\n\\tbool unite(int x, int y) { \\n\\t\\tx = get(x), y = get(y);\\n\\t\\tif (x == y) return false;\\n\\t\\tif (e[x] > e[y]) swap(x, y);\\n\\t\\te[x] += e[y]; e[y] = x;\\n\\t\\treturn true;\\n\\t}\\n};\\n\\nint largestComponentSize(vector<int>& nums) {\\n\\tDSU dsu(*max_element(nums.begin(), nums.end()) + 1); //create DSU struct with nodes 0, 1, 2, ... max element of the vector\\n\\tfor(auto i: nums){\\n\\t\\tfor(int j = 2;j*j<=i;j++){ //factorize each number\\n\\t\\t\\tif(i%j == 0){\\n\\t\\t\\t\\tdsu.unite(j, i);\\n\\t\\t\\t\\tdsu.unite(i/j, i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tint ans = 1;\\n\\tunordered_map<int, int> freq;\\n\\tfor(auto i: nums){\\n\\t\\tint p = dsu.get(i); //get parent\\n\\t\\tfreq[p]++;\\n\\t\\tans = max(ans, freq[p]);\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820371,
                "title": "swift-solution-beats-100",
                "content": "This problem was nearly impossible in Swift. I was using Union Find with Path Compression and Weights and it was giving TLE. I finally realized that the Path Compression was causing too many array assignments and strangely enough, the solution was faster without path compression. The `group(_ r: Int)` method does not use path compression while the`root(_ r: Int)` method does. I replaced all calls to `root(_ r: Int)` with `group(_ r: Int)` and it provided a 10x improvement.\\n\\n**Solution**\\n```swift\\nclass Solution {\\n    func largestComponentSize(_ A: [Int]) -> Int {\\n        var uf = UnionFind((A.max() ?? 0) + 1)\\n        var map = [Int: Int]()\\n        \\n        for num in A {\\n            let primes = factors(num)\\n            map[num] = primes[0]\\n            \\n            for i in 0 ..< primes.count - 1 where primes[i] != primes[i+1] {\\n                uf.union(primes[i], primes[i+1])\\n            }\\n        }\\n         \\n        var count = [Int: Int]()\\n        for num in A {\\n            var group = uf.group(map[num]!)\\n            count[group, default: 0] += 1\\n        }\\n        \\n        return count.values.max() ?? 0\\n    }\\n    \\n    func factors(_ num: Int) -> [Int] {\\n        var result = [Int]() \\n        var factor = 2 \\n        var num = num\\n        \\n        var prev = 1\\n        while num >= factor * factor {\\n            if num % factor == 0 {\\n                if factor != prev {\\n                    result.append(factor)\\n                }\\n                prev = factor\\n                num = num / factor\\n            } else {\\n                factor += 1\\n            }\\n        }\\n        \\n        result.append(num) \\n        return result\\n    }\\n}\\n\\n\\n\\n// MARK: Union Find \\n\\npublic class UnionFind {\\n\\t\\n\\t// MARK: Properties \\n\\n\\tpublic private(set) var arr: [Int]\\n\\tpublic private(set) var size: [Int]\\n\\n\\n\\t// MARK: Initialization \\n\\t\\n\\t/// Initializes Union Find with n objects \\n\\tpublic init(_ n: Int) {\\n\\t\\tself.arr = Array(0 ..< n) \\n\\t\\tself.size = Array(repeating: 1, count: n) \\n\\t}\\n\\n\\n\\t// MARK: Methods \\n\\n\\t/// Connects the set containing p with the set containing q\\n\\tpublic func union(_ p: Int, _ q: Int) {\\n\\t\\tlet pid = group(p) \\n\\t\\tlet qid = group(q) \\n        guard pid != qid else { return }\\n\\t\\tlet (small, big) = size[pid] < size[qid] ? \\n\\t\\t\\t(pid, qid) : (qid, pid) \\n\\t\\tsize[big] += size[small]\\n\\t\\tarr[small] = big \\n\\t}\\n\\n\\t/// Returns true if and only if p and q are connected \\n\\tpublic func find(_ p: Int, _ q: Int) -> Bool {\\n\\t\\tlet pid = group(p)\\n\\t\\tlet qid = group(q)\\n\\t\\treturn pid == qid \\n\\t}\\n\\n\\t/// Returns the root of r and performs path compression \\n\\tpublic func root(_ r: Int) -> Int {\\n\\t\\tvar r = r \\n\\t\\twhile arr[r] != r {\\n\\t\\t\\tarr[r] = arr[arr[r]]\\n\\t\\t\\tr = arr[r]\\n\\t\\t}\\n\\t\\treturn r \\n\\t}\\n    \\n    public func group(_ r: Int) -> Int {\\n        var r = r \\n        while arr[r] != r {\\n            r = arr[r]\\n        }\\n        return r \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func largestComponentSize(_ A: [Int]) -> Int {\\n        var uf = UnionFind((A.max() ?? 0) + 1)\\n        var map = [Int: Int]()\\n        \\n        for num in A {\\n            let primes = factors(num)\\n            map[num] = primes[0]\\n            \\n            for i in 0 ..< primes.count - 1 where primes[i] != primes[i+1] {\\n                uf.union(primes[i], primes[i+1])\\n            }\\n        }\\n         \\n        var count = [Int: Int]()\\n        for num in A {\\n            var group = uf.group(map[num]!)\\n            count[group, default: 0] += 1\\n        }\\n        \\n        return count.values.max() ?? 0\\n    }\\n    \\n    func factors(_ num: Int) -> [Int] {\\n        var result = [Int]() \\n        var factor = 2 \\n        var num = num\\n        \\n        var prev = 1\\n        while num >= factor * factor {\\n            if num % factor == 0 {\\n                if factor != prev {\\n                    result.append(factor)\\n                }\\n                prev = factor\\n                num = num / factor\\n            } else {\\n                factor += 1\\n            }\\n        }\\n        \\n        result.append(num) \\n        return result\\n    }\\n}\\n\\n\\n\\n// MARK: Union Find \\n\\npublic class UnionFind {\\n\\t\\n\\t// MARK: Properties \\n\\n\\tpublic private(set) var arr: [Int]\\n\\tpublic private(set) var size: [Int]\\n\\n\\n\\t// MARK: Initialization \\n\\t\\n\\t/// Initializes Union Find with n objects \\n\\tpublic init(_ n: Int) {\\n\\t\\tself.arr = Array(0 ..< n) \\n\\t\\tself.size = Array(repeating: 1, count: n) \\n\\t}\\n\\n\\n\\t// MARK: Methods \\n\\n\\t/// Connects the set containing p with the set containing q\\n\\tpublic func union(_ p: Int, _ q: Int) {\\n\\t\\tlet pid = group(p) \\n\\t\\tlet qid = group(q) \\n        guard pid != qid else { return }\\n\\t\\tlet (small, big) = size[pid] < size[qid] ? \\n\\t\\t\\t(pid, qid) : (qid, pid) \\n\\t\\tsize[big] += size[small]\\n\\t\\tarr[small] = big \\n\\t}\\n\\n\\t/// Returns true if and only if p and q are connected \\n\\tpublic func find(_ p: Int, _ q: Int) -> Bool {\\n\\t\\tlet pid = group(p)\\n\\t\\tlet qid = group(q)\\n\\t\\treturn pid == qid \\n\\t}\\n\\n\\t/// Returns the root of r and performs path compression \\n\\tpublic func root(_ r: Int) -> Int {\\n\\t\\tvar r = r \\n\\t\\twhile arr[r] != r {\\n\\t\\t\\tarr[r] = arr[arr[r]]\\n\\t\\t\\tr = arr[r]\\n\\t\\t}\\n\\t\\treturn r \\n\\t}\\n    \\n    public func group(_ r: Int) -> Int {\\n        var r = r \\n        while arr[r] != r {\\n            r = arr[r]\\n        }\\n        return r \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819957,
                "title": "java-short-and-concise",
                "content": "```java\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n        Map<Integer,Integer> parent = new HashMap<>();\\n\\n        for (int num : A)\\n            for (int fact = 2; fact*fact<=num; fact++)\\n                if (num % fact == 0){\\n                    union(num,fact,parent);\\n                    union(num,num/fact,parent);\\n                }\\n\\n        int max = 1;\\n        Map<Integer,Integer> freq = new HashMap<>();\\n        for (Integer v : A) {\\n            int f = find(v,parent);\\n            if (freq.containsKey(f)) {\\n                freq.put(f, freq.get(f)+1);\\n                max=Math.max(max,freq.get(f));\\n            }\\n            else freq.put(f,1);\\n        }\\n        return max;\\n    }\\n    \\n    public void union(int n, int m, Map<Integer,Integer> p) {\\n        int findN = find(n,p);\\n        int findM = find(m,p);\\n        if (findN < findM) p.put(findM,findN);\\n        else p.put(findN,findM);\\n    }\\n\\n    public int find(Integer i, Map<Integer,Integer> parent) {\\n        if (parent.get(i) == null) parent.put(i,i);\\n        while (i != parent.get(i)) i = parent.get(i);\\n        return i;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int largestComponentSize(int[] A) {\\n        Map<Integer,Integer> parent = new HashMap<>();\\n\\n        for (int num : A)\\n            for (int fact = 2; fact*fact<=num; fact++)\\n                if (num % fact == 0){\\n                    union(num,fact,parent);\\n                    union(num,num/fact,parent);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 200583,
                "title": "simple-c-uf-without-primes",
                "content": "Fairly minimal C++ solution without unnecessary cruft like finding all primes, etc\\n\\nI\\'m using UF indices 1..100000  to represent factors (initially all having size=0) and 100001+i to represent the element A[i] (with initial size=1). I brute force all factors of each A[i] on the fly as I iterate through A and merge() them with the element\\'s index:\\n\\n```\\nclass Solution {\\n    int parent[121000], size[121000];\\n\\npublic:\\n    int largestComponentSize(vector<int>& A) {\\n        for (int i = 0; i < 121000; i++) parent[i] = i;\\n        memset(size, 0, sizeof(size));\\n\\n        for (int i = 0; i < A.size(); i++) {\\n            size[100001 + i] = 1;\\n            for (int p = 2; p*p <= A[i]; p++) {\\n                if (A[i] % p == 0) {\\n                    merge(p, 100001+i);\\n                    merge(A[i]/p, 100001+i);\\n                }\\n            }\\n            merge(A[i], 100001+i);\\n        }\\n\\n        int max_cc = 1;\\n        for (int i = 0; i < A.size(); i++)\\n            max_cc = max(max_cc, size[find(100001+i)]);\\n        return max_cc;\\n    }\\n\\n    int find(int i) {\\n        if (parent[i] != i) parent[i] = find(parent[i]);\\n        return parent[i];\\n    }\\n\\n    void merge(int i, int j) {\\n        i = find(i);\\n        j = find(j);\\n        if (i == j) return;\\n        size[i] += size[j];\\n        parent[j] = i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int parent[121000], size[121000];\\n\\npublic:\\n    int largestComponentSize(vector<int>& A) {\\n        for (int i = 0; i < 121000; i++) parent[i] = i;\\n        memset(size, 0, sizeof(size));\\n\\n        for (int i = 0; i < A.size(); i++) {\\n            size[100001 + i] = 1;\\n            for (int p = 2; p*p <= A[i]; p++) {\\n                if (A[i] % p == 0) {\\n                    merge(p, 100001+i);\\n                    merge(A[i]/p, 100001+i);\\n                }\\n            }\\n            merge(A[i], 100001+i);\\n        }\\n\\n        int max_cc = 1;\\n        for (int i = 0; i < A.size(); i++)\\n            max_cc = max(max_cc, size[find(100001+i)]);\\n        return max_cc;\\n    }\\n\\n    int find(int i) {\\n        if (parent[i] != i) parent[i] = find(parent[i]);\\n        return parent[i];\\n    }\\n\\n    void merge(int i, int j) {\\n        i = find(i);\\n        j = find(j);\\n        if (i == j) return;\\n        size[i] += size[j];\\n        parent[j] = i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593045,
                "title": "python-union-find-clean-and-easy-to-understand-with-explanation",
                "content": "```\\nclass UnionFindSet(object):\\n    def __init__(self):\\n        self.data = collections.defaultdict(int)\\n\\n    def find(self, x):\\n        while x <> self.data[x]:\\n            x = self.data[x]\\n        return x\\n\\n    def union(self, x, y):\\n        if x not in self.data:\\n            self.data[x] = x\\n        if y not in self.data:\\n            self.data[y] = y\\n        self.data[self.find(x)] = self.find(y)\\n\\n    def speedup(self):\\n        for x in self.data.keys():\\n            self.data[x] = self.find(x)\\n\\n\\nclass Solution(object):\\n    def largestComponentSize(self, nums):\\n        # First of all, generate all prime numbers less than or equal to the max(nums) sequentially. \\n        # It is true that this part of the code is intuitive and easy to understand, but its execution efficiency is not\\n        # high. I added a more efficient version in the comment area below, but it might not be that easy to understand.\\n        primes = []\\n        for num in range(2, max(nums) + 1):\\n            flag = True\\n            for prime in primes:\\n                if num % prime == 0:\\n                    flag = False\\n                    break\\n                if prime * prime > num:\\n                    break\\n            if flag:\\n                primes.append(num)\\n\\n        # Secondly, find the smallest prime factor of each number.\\n        primes = set(primes)\\n        smallest_prime_factor = range(max(nums) + 1)\\n        for num in range(1, max(nums) + 1):\\n            if num in primes:\\n                continue\\n            for prime in primes:\\n                if num % prime == 0:\\n                    smallest_prime_factor[num] = prime\\n                    break\\n\\n        # Thirdly, find all prime factors of each number, and generate a dictionary with prime factors as the key and\\n        # the list of numbers as the value.\\n        prime_factors = collections.defaultdict(list)\\n        for num in nums:\\n            n = num\\n            while smallest_prime_factor[n] < n:\\n                prime_factors[smallest_prime_factor[n]].append(num)\\n                n //= smallest_prime_factor[n]\\n            prime_factors[smallest_prime_factor[n]].append(num)\\n\\n        # Fourthly, use UnionFindSet to connect numbers with common prime factors.\\n        uf = UnionFindSet()\\n        for nums in prime_factors.values():\\n            for i in range(1, len(nums)):\\n                uf.union(nums[i], nums[0])\\n        uf.speedup()\\n\\n        # Finally, returns the number of elements in the largest subset.\\n        # Notice that if no edge could union, the UnionFindSet is empty.\\n        if len(uf.data) == 0:\\n            return 1\\n        return collections.Counter(uf.data.values()).most_common(1)[0][1]\\n```\\n\\n**Please UPVOTE!**",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFindSet(object):\\n    def __init__(self):\\n        self.data = collections.defaultdict(int)\\n\\n    def find(self, x):\\n        while x <> self.data[x]:\\n            x = self.data[x]\\n        return x\\n\\n    def union(self, x, y):\\n        if x not in self.data:\\n            self.data[x] = x\\n        if y not in self.data:\\n            self.data[y] = y\\n        self.data[self.find(x)] = self.find(y)\\n\\n    def speedup(self):\\n        for x in self.data.keys():\\n            self.data[x] = self.find(x)\\n\\n\\nclass Solution(object):\\n    def largestComponentSize(self, nums):\\n        # First of all, generate all prime numbers less than or equal to the max(nums) sequentially. \\n        # It is true that this part of the code is intuitive and easy to understand, but its execution efficiency is not\\n        # high. I added a more efficient version in the comment area below, but it might not be that easy to understand.\\n        primes = []\\n        for num in range(2, max(nums) + 1):\\n            flag = True\\n            for prime in primes:\\n                if num % prime == 0:\\n                    flag = False\\n                    break\\n                if prime * prime > num:\\n                    break\\n            if flag:\\n                primes.append(num)\\n\\n        # Secondly, find the smallest prime factor of each number.\\n        primes = set(primes)\\n        smallest_prime_factor = range(max(nums) + 1)\\n        for num in range(1, max(nums) + 1):\\n            if num in primes:\\n                continue\\n            for prime in primes:\\n                if num % prime == 0:\\n                    smallest_prime_factor[num] = prime\\n                    break\\n\\n        # Thirdly, find all prime factors of each number, and generate a dictionary with prime factors as the key and\\n        # the list of numbers as the value.\\n        prime_factors = collections.defaultdict(list)\\n        for num in nums:\\n            n = num\\n            while smallest_prime_factor[n] < n:\\n                prime_factors[smallest_prime_factor[n]].append(num)\\n                n //= smallest_prime_factor[n]\\n            prime_factors[smallest_prime_factor[n]].append(num)\\n\\n        # Fourthly, use UnionFindSet to connect numbers with common prime factors.\\n        uf = UnionFindSet()\\n        for nums in prime_factors.values():\\n            for i in range(1, len(nums)):\\n                uf.union(nums[i], nums[0])\\n        uf.speedup()\\n\\n        # Finally, returns the number of elements in the largest subset.\\n        # Notice that if no edge could union, the UnionFindSet is empty.\\n        if len(uf.data) == 0:\\n            return 1\\n        return collections.Counter(uf.data.values()).most_common(1)[0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546345,
                "title": "python3-union-find",
                "content": "\\n`O(MlogM)` using sieve\\n```\\nclass UnionFind: \\n    \\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [1]*n\\n        \\n    def find(self, p): \\n        if p != self.parent[p]: \\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, p, q): \\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False \\n        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt\\n        self.parent[prt] = qrt\\n        self.rank[qrt] += self.rank[prt]\\n        return True \\n\\n\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        m = max(A)\\n        uf = UnionFind(m+1)\\n        seen = set(A)\\n        \\n        # modified sieve of eratosthenes \\n        sieve = [1]*(m+1)\\n        sieve[0] = sieve[1] = 0 \\n        for k in range(m//2+1): \\n            if sieve[k]: \\n                prev = k if k in seen else 0\\n                for x in range(2*k, m+1, k): \\n                    sieve[x] = 0\\n                    if x in seen: \\n                        if prev: uf.union(prev, x)\\n                        else: prev = x\\n        return max(uf.rank)\\n```\\n\\n**Related problems**\\n[952. Largest Component Size by Common Factor](https://leetcode.com/problems/largest-component-size-by-common-factor/discuss/1546345/Python3-union-find)\\n[1998. GCD Sort of an Array](https://leetcode.com/problems/gcd-sort-of-an-array/discuss/1445278/Python3-union-find)\\n\\nAlternative implemetation `O(Nsqrt(M))` assuming `O(1)` union & find.\\n```\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        m = max(nums)\\n        uf = UnionFind(m+1)\\n        for x in nums: \\n            for p in range(2, int(sqrt(x))+1): \\n                if x%p == 0: \\n                    uf.union(x, p)\\n                    uf.union(x, x//p)\\n        freq = Counter(uf.find(x) for x in nums)\\n        return max(freq.values())\\n```\\n\\nAlternative implementation using `spf` `O((M+N)logM)`\\n```\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        m = max(nums)\\n        spf = list(range(m+1))\\n        for x in range(4, m+1, 2): spf[x] = 2\\n        for x in range(3, int(sqrt(m+1))+1): \\n            if spf[x] == x: \\n                for xx in range(x*x, m+1, x): \\n                    spf[xx] = x \\n        \\n        uf = UnionFind(len(nums))\\n        mp = {}\\n        for i, x in enumerate(nums): \\n            while x > 1: \\n                if spf[x] in mp: uf.union(i, mp[spf[x]])\\n                else: mp[spf[x]] = i\\n                x //= spf[x]\\n        return max(uf.rank)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind: \\n    \\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [1]*n\\n        \\n    def find(self, p): \\n        if p != self.parent[p]: \\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, p, q): \\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False \\n        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt\\n        self.parent[prt] = qrt\\n        self.rank[qrt] += self.rank[prt]\\n        return True \\n\\n\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        m = max(A)\\n        uf = UnionFind(m+1)\\n        seen = set(A)\\n        \\n        # modified sieve of eratosthenes \\n        sieve = [1]*(m+1)\\n        sieve[0] = sieve[1] = 0 \\n        for k in range(m//2+1): \\n            if sieve[k]: \\n                prev = k if k in seen else 0\\n                for x in range(2*k, m+1, k): \\n                    sieve[x] = 0\\n                    if x in seen: \\n                        if prev: uf.union(prev, x)\\n                        else: prev = x\\n        return max(uf.rank)\\n```\n```\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        m = max(nums)\\n        uf = UnionFind(m+1)\\n        for x in nums: \\n            for p in range(2, int(sqrt(x))+1): \\n                if x%p == 0: \\n                    uf.union(x, p)\\n                    uf.union(x, x//p)\\n        freq = Counter(uf.find(x) for x in nums)\\n        return max(freq.values())\\n```\n```\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        m = max(nums)\\n        spf = list(range(m+1))\\n        for x in range(4, m+1, 2): spf[x] = 2\\n        for x in range(3, int(sqrt(m+1))+1): \\n            if spf[x] == x: \\n                for xx in range(x*x, m+1, x): \\n                    spf[xx] = x \\n        \\n        uf = UnionFind(len(nums))\\n        mp = {}\\n        for i, x in enumerate(nums): \\n            while x > 1: \\n                if spf[x] in mp: uf.union(i, mp[spf[x]])\\n                else: mp[spf[x]] = i\\n                x //= spf[x]\\n        return max(uf.rank)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819974,
                "title": "largest-component-javascript-356ms-beats-90",
                "content": "### Ideas to the solution\\n\\n* It doesn\\'t need to have the entire graph, and we only need to have connected components with minimal connections.\\n* Using [union-find algorithm](https://en.wikipedia.org/wiki/Disjoint-set_data_structure), we can efficiently group two numbers divided by a divisor. However, running this algorithm will take O(N^2), and it causes TLE. \\n* A key idea is that two numbers divided by a prime number belong to the same component together. Furthermore, K numbers are divided by a prime number will be in the same component. Running the union operation for (X1, X2), (X1, X3), ..., (X1, XK) will group the number together. Here, X1 ... XK is a set of numbers that are divided by a prime number.\\n* So, using Eratosthenes\\' sieve, we can collect prime numbers less than or equal to the maximum number (M) of the input and run the union operations.\\n* My initial solution runs Eratosthenes\\' sieve from 2 to M. It was accepted, but it took 4600 ms. After I got AC, I tried to find where I could optimize. \\n* After review my code, I realized that it only needs to run the sieve up to sqrt(M) with prime factorizations for every time it performs a union operation for a prime number. Later the sieve, it needs to find numbers that still need to be factorized, and those numbers are prime numbers that are not counted by the sieve. Running additional union operations the same yet-to-factorized numbers (prime numbers) and measuring the maximum component will complete the algorithm. \\n\\n```\\nvar largestComponentSize = function(A) {\\n  const n = A.length;\\n  let parent = new Array(n).fill().map((_,i)=>i);\\n  let cnt = new Array(n).fill(1);\\n  let find  = (i) => parent[i] == i? i : find(parent[i]);\\n  let union = (i, j) => {\\n    let p = find(i);\\n    let q = find(j);\\n    \\n    if(p === q) return;\\n    \\n    if(cnt[p]<cnt[q]) {\\n      [p,q] = [q,p];\\n    }\\n    cnt[p] += cnt[q];\\n    parent[q] = p;\\n  }\\n  \\n  const m = Math.max(...A);\\n  let p = new Array(m+1).fill(true);\\n  const root = Math.floor(Math.sqrt(m));\\n  for(let i=2;i<=root;i++) if(p[i]) {\\n    let k = -1;\\n    for(let j=0;j<n;++j) {\\n      if(A[j]%i===0) {\\n        while(A[j] % i === 0)\\n          A[j] = Math.floor(A[j]/i);\\n        if(k===-1) k = j;\\n        else union(k, j);\\n      }\\n    } \\n    for(let j=i*i;j<=m;j+=i) p[j] = false;\\n  }\\n  \\n  A = A.map((x,i)=>[x,i]).filter(x=>x[0]>1).sort((a,b)=>a[0]-b[0]);\\n  for(let i=1;i<A.length;++i) {\\n    if(A[i-1][0]===A[i][0]) {\\n      union(A[i-1][1], A[i][1]);\\n    }\\n  }\\n  \\n  return Math.max(...cnt);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\nvar largestComponentSize = function(A) {\\n  const n = A.length;\\n  let parent = new Array(n).fill().map((_,i)=>i);\\n  let cnt = new Array(n).fill(1);\\n  let find  = (i) => parent[i] == i? i : find(parent[i]);\\n  let union = (i, j) => {\\n    let p = find(i);\\n    let q = find(j);\\n    \\n    if(p === q) return;\\n    \\n    if(cnt[p]<cnt[q]) {\\n      [p,q] = [q,p];\\n    }\\n    cnt[p] += cnt[q];\\n    parent[q] = p;\\n  }\\n  \\n  const m = Math.max(...A);\\n  let p = new Array(m+1).fill(true);\\n  const root = Math.floor(Math.sqrt(m));\\n  for(let i=2;i<=root;i++) if(p[i]) {\\n    let k = -1;\\n    for(let j=0;j<n;++j) {\\n      if(A[j]%i===0) {\\n        while(A[j] % i === 0)\\n          A[j] = Math.floor(A[j]/i);\\n        if(k===-1) k = j;\\n        else union(k, j);\\n      }\\n    } \\n    for(let j=i*i;j<=m;j+=i) p[j] = false;\\n  }\\n  \\n  A = A.map((x,i)=>[x,i]).filter(x=>x[0]>1).sort((a,b)=>a[0]-b[0]);\\n  for(let i=1;i<A.length;++i) {\\n    if(A[i-1][0]===A[i][0]) {\\n      union(A[i-1][1], A[i][1]);\\n    }\\n  }\\n  \\n  return Math.max(...cnt);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 204260,
                "title": "a-few-solutions",
                "content": "For each number `x` in the input array `A`, use an associative array `m` to map factors of `x` to `x`.  There are 3 use cases to consider for each factor of `x`:\\n\\n* **Case 1:** `x` as a factor of itself\\n* **Case 2:** the i<sup>th</sup> factor of `x`\\n* **Case 3:** the j<sup>th</sup> factor of `x`, where `j` = `x / i`\\n\\nSince we are using union-find to track the parent representatives `P` of each disjoint set, we only need to track a single member `x` of each set for each factor `x`, `i`, `j` for case 1, 2, 3 correspondingly.  As sets are joined, their length `L` is accumulated and tracked by each parent reprentative.  Return the maxmium length of any parent reprensentative\\'s set.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun largestComponentSize(A: IntArray, N: Int = (1e5 + 1).toInt()): Int {\\n        var P = IntArray(N) { it }              // \\uD83D\\uDE42 parent representative of disjoint sets\\n        var L = IntArray(N) { 1 }               // \\uD83E\\uDD25 length of parent representative\\'s set\\n        fun find(x: Int): Int {\\n            if (P[x] == x)\\n                return x\\n            P[x] = find(P[x])\\n            return P[x]\\n        }\\n        fun union(a_: Int, b_: Int) {\\n            var (a, b) = listOf(a_, b_)\\n            a = find(a)\\n            b = find(b)\\n            if (a == b)\\n                return\\n            P[a] = b; L[b] += L[a]  // arbitrary choice\\n        }\\n        var m = mutableMapOf<Int, Int>()  // x,i,j factors of x -> x\\n        for (x in A) {\\n            if (m.contains(x)) union(m[x]!!, x) else m[x] = x      // case 1: x as a factor of itself\\n            for (i in 2..Math.floor(Math.sqrt(x.toDouble())).toInt()) {\\n                if (x % i != 0)\\n                    continue\\n                var j = x / i\\n                if (m.contains(i)) union(m[i]!!, x) else m[i] = x  // case 2: i-th factor of x\\n                if (m.contains(j)) union(m[j]!!, x) else m[j] = x  // case 3: j-th factor of x\\n            }\\n        }\\n        return L.max()!!  // \\uD83C\\uDFAF maximum length of any parent representative\\'s set\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet largestComponentSize = (A, N = 100001, m = {}) => {\\n    let P = [...Array(N).keys()],              // \\uD83D\\uDE42 parent representative of disjoint sets\\n        L = Array(N).fill(1);                  // \\uD83E\\uDD25 length of parent representative\\'s set\\n    let find = x => P[x] = x == P[x] ? P[x] : find(P[x]);\\n    let union = (a, b) => {\\n        a = find(a);\\n        b = find(b);\\n        if (a == b)\\n            return;\\n        P[b] = a;  // arbitrary choice\\n        L[a] += L[b];\\n    }\\n    for (let x of A) {\\n        m[x] ? union(m[x], x) : m[x] = x;      // case 1: x as a factor of itself\\n        for (let i = 2; i * i <= x; ++i) {\\n            if (x % i)\\n                continue;\\n            let j = Math.floor(x / i);\\n            m[i] ? union(m[i], x) : m[i] = x;  // case 2: i-th factor of x\\n            m[j] ? union(m[j], x) : m[j] = x;  // case 3: j-th factor of x\\n        }\\n    }\\n    return Math.max(...L);                     // \\uD83C\\uDFAF maximum length of any parent representative\\'s set\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def largestComponentSize(self, A: List[int], N = 100001) -> int:\\n        m = {}\\n        P = [i for i in range(N)]   # \\uD83D\\uDE42 parent representative of disjoint sets\\n        L = [1] * N                 # \\uD83E\\uDD25 length of parent representative\\'s set\\n        def find(x):\\n            P[x] = P[x] if x == P[x] else find(P[x])\\n            return P[x]\\n        def union(a, b):\\n            a = find(a)\\n            b = find(b)\\n            if a == b:\\n                return\\n            P[b] = a  # arbitrary choice\\n            L[a] += L[b]\\n        for x in A:\\n            m[x] = x if x not in m else m[x]; union(m[x], x)      # case 1: x as a factor of itself\\n            for i in range(2, floor(sqrt(x)) + 1):\\n                if x % i:\\n                    continue\\n                j = x // i\\n                m[i] = x if i not in m else m[i]; union(m[i], x)  # case 2: i-th factor of x\\n                m[j] = x if j not in m else m[j]; union(m[j], x)  # case 3: j-th factor of x\\n        return max(L)  # \\uD83C\\uDFAF maximum length of any parent representative\\'s set\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    using fun = function<int(int)>;\\n    int largestComponentSize(VI& A, int N = 100001, Map m = {}) {\\n        VI P(N); iota(P.begin(), P.end(), 0);               // \\uD83D\\uDE42 parent representative of disjoint sets\\n        VI L(N, 1);                                         // \\uD83E\\uDD25 length of parent representative\\'s set\\n        fun find = [&](auto x) { return P[x] = x == P[x] ? P[x] : find(P[x]); };\\n        auto _union = [&](auto a, auto b) {\\n            a = find(a);\\n            b = find(b);\\n            if (a == b)\\n                return;\\n            P[b] = a;  // arbitrary choice\\n            L[a] += L[b];\\n        };\\n        for (auto x: A) {\\n            if (m[x]) _union(m[x], x); else m[x] = x;      // case 1: x as a factor of itself\\n            for (auto i{ 2 }; i * i <= x; ++i) {\\n                if (x % i)\\n                    continue;\\n                auto j = x / i;\\n                if (m[i]) _union(m[i], x); else m[i] = x;  // case 2: i-th factor of x\\n                if (m[j]) _union(m[j], x); else m[j] = x;  // case 3: j-th factor of x\\n            }\\n        }\\n        return *max_element(L.begin(), L.end());           // \\uD83C\\uDFAF maximum length of any parent representative\\'s set\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun largestComponentSize(A: IntArray, N: Int = (1e5 + 1).toInt()): Int {\\n        var P = IntArray(N) { it }              // \\uD83D\\uDE42 parent representative of disjoint sets\\n        var L = IntArray(N) { 1 }               // \\uD83E\\uDD25 length of parent representative\\'s set\\n        fun find(x: Int): Int {\\n            if (P[x] == x)\\n                return x\\n            P[x] = find(P[x])\\n            return P[x]\\n        }\\n        fun union(a_: Int, b_: Int) {\\n            var (a, b) = listOf(a_, b_)\\n            a = find(a)\\n            b = find(b)\\n            if (a == b)\\n                return\\n            P[a] = b; L[b] += L[a]  // arbitrary choice\\n        }\\n        var m = mutableMapOf<Int, Int>()  // x,i,j factors of x -> x\\n        for (x in A) {\\n            if (m.contains(x)) union(m[x]!!, x) else m[x] = x      // case 1: x as a factor of itself\\n            for (i in 2..Math.floor(Math.sqrt(x.toDouble())).toInt()) {\\n                if (x % i != 0)\\n                    continue\\n                var j = x / i\\n                if (m.contains(i)) union(m[i]!!, x) else m[i] = x  // case 2: i-th factor of x\\n                if (m.contains(j)) union(m[j]!!, x) else m[j] = x  // case 3: j-th factor of x\\n            }\\n        }\\n        return L.max()!!  // \\uD83C\\uDFAF maximum length of any parent representative\\'s set\\n    }\\n}\\n```\n```\\nlet largestComponentSize = (A, N = 100001, m = {}) => {\\n    let P = [...Array(N).keys()],              // \\uD83D\\uDE42 parent representative of disjoint sets\\n        L = Array(N).fill(1);                  // \\uD83E\\uDD25 length of parent representative\\'s set\\n    let find = x => P[x] = x == P[x] ? P[x] : find(P[x]);\\n    let union = (a, b) => {\\n        a = find(a);\\n        b = find(b);\\n        if (a == b)\\n            return;\\n        P[b] = a;  // arbitrary choice\\n        L[a] += L[b];\\n    }\\n    for (let x of A) {\\n        m[x] ? union(m[x], x) : m[x] = x;      // case 1: x as a factor of itself\\n        for (let i = 2; i * i <= x; ++i) {\\n            if (x % i)\\n                continue;\\n            let j = Math.floor(x / i);\\n            m[i] ? union(m[i], x) : m[i] = x;  // case 2: i-th factor of x\\n            m[j] ? union(m[j], x) : m[j] = x;  // case 3: j-th factor of x\\n        }\\n    }\\n    return Math.max(...L);                     // \\uD83C\\uDFAF maximum length of any parent representative\\'s set\\n};\\n```\n```\\nclass Solution:\\n    def largestComponentSize(self, A: List[int], N = 100001) -> int:\\n        m = {}\\n        P = [i for i in range(N)]   # \\uD83D\\uDE42 parent representative of disjoint sets\\n        L = [1] * N                 # \\uD83E\\uDD25 length of parent representative\\'s set\\n        def find(x):\\n            P[x] = P[x] if x == P[x] else find(P[x])\\n            return P[x]\\n        def union(a, b):\\n            a = find(a)\\n            b = find(b)\\n            if a == b:\\n                return\\n            P[b] = a  # arbitrary choice\\n            L[a] += L[b]\\n        for x in A:\\n            m[x] = x if x not in m else m[x]; union(m[x], x)      # case 1: x as a factor of itself\\n            for i in range(2, floor(sqrt(x)) + 1):\\n                if x % i:\\n                    continue\\n                j = x // i\\n                m[i] = x if i not in m else m[i]; union(m[i], x)  # case 2: i-th factor of x\\n                m[j] = x if j not in m else m[j]; union(m[j], x)  # case 3: j-th factor of x\\n        return max(L)  # \\uD83C\\uDFAF maximum length of any parent representative\\'s set\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    using fun = function<int(int)>;\\n    int largestComponentSize(VI& A, int N = 100001, Map m = {}) {\\n        VI P(N); iota(P.begin(), P.end(), 0);               // \\uD83D\\uDE42 parent representative of disjoint sets\\n        VI L(N, 1);                                         // \\uD83E\\uDD25 length of parent representative\\'s set\\n        fun find = [&](auto x) { return P[x] = x == P[x] ? P[x] : find(P[x]); };\\n        auto _union = [&](auto a, auto b) {\\n            a = find(a);\\n            b = find(b);\\n            if (a == b)\\n                return;\\n            P[b] = a;  // arbitrary choice\\n            L[a] += L[b];\\n        };\\n        for (auto x: A) {\\n            if (m[x]) _union(m[x], x); else m[x] = x;      // case 1: x as a factor of itself\\n            for (auto i{ 2 }; i * i <= x; ++i) {\\n                if (x % i)\\n                    continue;\\n                auto j = x / i;\\n                if (m[i]) _union(m[i], x); else m[i] = x;  // case 2: i-th factor of x\\n                if (m[j]) _union(m[j], x); else m[j] = x;  // case 3: j-th factor of x\\n            }\\n        }\\n        return *max_element(L.begin(), L.end());           // \\uD83C\\uDFAF maximum length of any parent representative\\'s set\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202298,
                "title": "c-84-ms-o-n-65",
                "content": "For each number, we find all prime factors, group these factors using union-find, and count how many numbers are in each group.\\n\\nSince the maximum value is 100,000,  we only need primes till 313 (317 * 317 = 100,489). The intuition here is that we do not need to care about large primes as they won\\'t connect to any other number. So, our union-find structure only needs to have 65 elements.\\n\\nNow, numbers like 2, 3, 401, 802, 1203 are tricky (all in the same group). 802 (2 * 401) adds a previous prime to group \"2\", and 1203 (3 * 401) joins groups \"2\" and \"3\". So, we do need to track large primes, *but only when they appear in the input sequence*.\\n\\nIf after trying all 65 factors the remainder is greater than 1, it\\'s a large prime. We use a hash map to track our large primes and the factor it\\'s \\'connected\\' to.\\n```\\nvector<int> factors = {\\n    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101,\\n    103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,\\n    199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313\\n};\\nvoid uf_union(vector<int>& uf, int p1, int p2) {\\n  auto pp1 = uf_find(uf, p1), pp2 = uf_find(uf, p2);\\n  if (pp1 != pp2) uf[pp1] += uf[pp2], uf[pp2] = pp1;\\n}\\nint uf_find(vector<int>& uf, int p) {\\n  if (uf[p] <= 0) return p;\\n  return uf[p] = uf_find(uf, uf[p]);\\n}\\nint largestComponentSize(vector<int>& A) {\\n  unordered_map<int, int> primes;\\n  vector<int> uf(factors.size(), 0);\\n  for (auto a : A) {\\n    auto last_f = -1;\\n    for (auto i = 0; i < factors.size() && factors[i] <= a; ++i) {\\n      if (a % factors[i] == 0) {\\n        while (a % factors[i] == 0) a /= factors[i];\\n        if (last_f >= 0) uf_union(uf, i, last_f);\\n        last_f = i;\\n      }\\n    }\\n    if (a > 1) {\\n      auto it = primes.find(a);\\n      if (it != primes.end()) {\\n        if (last_f != -1 && it->second != -1) uf_union(uf, last_f, it->second);\\n        else if (last_f != -1 || it->second != -1) uf[uf_find(uf, max(last_f, it->second))] -= 1;\\n      }\\n      if (it == primes.end() || last_f >= 0) primes[a] = last_f;\\n    }\\n    if (last_f >= 0) uf[uf_find(uf, last_f)] -= 1;\\n  }\\n  return -*min_element(begin(uf), end(uf));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> factors = {\\n    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101,\\n    103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,\\n    199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313\\n};\\nvoid uf_union(vector<int>& uf, int p1, int p2) {\\n  auto pp1 = uf_find(uf, p1), pp2 = uf_find(uf, p2);\\n  if (pp1 != pp2) uf[pp1] += uf[pp2], uf[pp2] = pp1;\\n}\\nint uf_find(vector<int>& uf, int p) {\\n  if (uf[p] <= 0) return p;\\n  return uf[p] = uf_find(uf, uf[p]);\\n}\\nint largestComponentSize(vector<int>& A) {\\n  unordered_map<int, int> primes;\\n  vector<int> uf(factors.size(), 0);\\n  for (auto a : A) {\\n    auto last_f = -1;\\n    for (auto i = 0; i < factors.size() && factors[i] <= a; ++i) {\\n      if (a % factors[i] == 0) {\\n        while (a % factors[i] == 0) a /= factors[i];\\n        if (last_f >= 0) uf_union(uf, i, last_f);\\n        last_f = i;\\n      }\\n    }\\n    if (a > 1) {\\n      auto it = primes.find(a);\\n      if (it != primes.end()) {\\n        if (last_f != -1 && it->second != -1) uf_union(uf, last_f, it->second);\\n        else if (last_f != -1 || it->second != -1) uf[uf_find(uf, max(last_f, it->second))] -= 1;\\n      }\\n      if (it == primes.end() || last_f >= 0) primes[a] = last_f;\\n    }\\n    if (last_f >= 0) uf[uf_find(uf, last_f)] -= 1;\\n  }\\n  return -*min_element(begin(uf), end(uf));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3785309,
                "title": "c-dfs-uses-linear-sieve-eratosthenes-sieve-prime-number-theory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2 kinds of sieve methods are implemented,. One is Linear Sieve which has elapsed time only O(M) of the time complexity. The other is the famous Eratosthenes\\' Sieve Method with TC O(M log log M).\\n\\nBased on the Sieve\\'s result, DFS is the algorithm to solve this question. It is doable. Use the similar tricks like the sieve method to build up the adjacent list.\\n\\nPrime Number Theory can be used to reserve the memory allocation and speed up the code.\\n\\nPrime Number Theory says\\nthe number of {primes <=M }~M/log(M)\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n# Visualize Eratosthenes\\' Sieve\\n[https://youtu.be/7GGhURLPnIs](https://youtu.be/7GGhURLPnIs)\\n\\n# Math explains Eratosthenes\\' Sieve\\n[Please Turn on English subtitles if neccessary]\\n[https://youtu.be/GxoMWxXLKMc](https://youtu.be/GxoMWxXLKMc)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(M)$$ where M=max(nums[:])\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(M)$$\\n# Code using Linear Sieve & DFS\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<bool> sieve;\\n    vector<int> prime;\\n    vector<vector<int>> commonFactor;\\n    vector<int> num_state;\\n\\n    void linearSieve(int n) {\\n        sieve.assign(n + 1, false);\\n        prime.reserve((int)(n/log(n)));// Use Prime Number Theory\\n        for (int i = 2; i <= n; i++) {\\n            if (!sieve[i]) prime.push_back(i); // When not sieved, i is a prime\\n            for (int j = 0; i * prime[j] <= n; j++) {\\n                sieve[i * prime[j]] = true;\\n                if (i % prime[j] == 0) break;\\n            }\\n        }\\n    }\\n\\n    void build_commonFactor_path(vector<int>& nums, int M) {\\n        num_state.assign(M + 1, 0);\\n        commonFactor.resize(M + 1, vector<int>());\\n\\n        for (int x : nums)\\n            num_state[x] = 1;\\n\\n        for (int p : prime) {//Probably M/log(M) primes\\n            if (num_state[p] != 1)\\n                num_state[p] = -1;\\n\\n            for (int i = p * 2; i <= M; i += p) {\\n                if (num_state[i] == 1) {\\n                    commonFactor[i].push_back(p);\\n                    commonFactor[p].push_back(i);\\n                }\\n            }\\n        }\\n    }\\n\\n    void dfs(int i, int& sz) {\\n        if (num_state[i] == 1)\\n            sz++;\\n        num_state[i] = 2;\\n\\n        for (int x : commonFactor[i]) {\\n            if (num_state[x] == 1 || num_state[x] == -1) {\\n                dfs(x, sz);\\n            }\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n        n = nums.size();\\n        int M = *max_element(nums.begin(), nums.end());\\n        linearSieve(M);\\n        build_commonFactor_path(nums, M);\\n        int ans = 0;\\n        for (int i : nums) {\\n            if (num_state[i] == 1) {\\n                int sz = 0;\\n                dfs(i, sz);\\n                ans = max(ans, sz);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n# Code using Eratosthenes\\' Sieve  with TC O(M log log(M)). In real test, it is faster than the linear Sieve, since M is not large enough\\n```\\n    int n;\\n    vector<int> prime;\\n    vector<vector<int>> commonFactor;\\n    vector<bool> isPrime;\\n    \\n    void Sieve(int n){//TC: O(n log log n)\\n        isPrime.assign(n+1, 1);\\n        isPrime[0]=isPrime[1]=0;\\n        int&& n_sqrt=int(sqrt(n));\\n        for(int i=2; i<=n_sqrt; i++){\\n            if (isPrime[i]){\\n                for(int j=i*i ; j<=n; j+=i)\\n                    isPrime[j]=0;\\n            }\\n        }\\n        prime.reserve((int)(n/log(n)));//Use Prime Number Theory\\n        for(int i=2; i<=n; i++)\\n            if (isPrime[i]) prime.push_back(i);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<bool> sieve;\\n    vector<int> prime;\\n    vector<vector<int>> commonFactor;\\n    vector<int> num_state;\\n\\n    void linearSieve(int n) {\\n        sieve.assign(n + 1, false);\\n        prime.reserve((int)(n/log(n)));// Use Prime Number Theory\\n        for (int i = 2; i <= n; i++) {\\n            if (!sieve[i]) prime.push_back(i); // When not sieved, i is a prime\\n            for (int j = 0; i * prime[j] <= n; j++) {\\n                sieve[i * prime[j]] = true;\\n                if (i % prime[j] == 0) break;\\n            }\\n        }\\n    }\\n\\n    void build_commonFactor_path(vector<int>& nums, int M) {\\n        num_state.assign(M + 1, 0);\\n        commonFactor.resize(M + 1, vector<int>());\\n\\n        for (int x : nums)\\n            num_state[x] = 1;\\n\\n        for (int p : prime) {//Probably M/log(M) primes\\n            if (num_state[p] != 1)\\n                num_state[p] = -1;\\n\\n            for (int i = p * 2; i <= M; i += p) {\\n                if (num_state[i] == 1) {\\n                    commonFactor[i].push_back(p);\\n                    commonFactor[p].push_back(i);\\n                }\\n            }\\n        }\\n    }\\n\\n    void dfs(int i, int& sz) {\\n        if (num_state[i] == 1)\\n            sz++;\\n        num_state[i] = 2;\\n\\n        for (int x : commonFactor[i]) {\\n            if (num_state[x] == 1 || num_state[x] == -1) {\\n                dfs(x, sz);\\n            }\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n        n = nums.size();\\n        int M = *max_element(nums.begin(), nums.end());\\n        linearSieve(M);\\n        build_commonFactor_path(nums, M);\\n        int ans = 0;\\n        for (int i : nums) {\\n            if (num_state[i] == 1) {\\n                int sz = 0;\\n                dfs(i, sz);\\n                ans = max(ans, sz);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\n```\\n    int n;\\n    vector<int> prime;\\n    vector<vector<int>> commonFactor;\\n    vector<bool> isPrime;\\n    \\n    void Sieve(int n){//TC: O(n log log n)\\n        isPrime.assign(n+1, 1);\\n        isPrime[0]=isPrime[1]=0;\\n        int&& n_sqrt=int(sqrt(n));\\n        for(int i=2; i<=n_sqrt; i++){\\n            if (isPrime[i]){\\n                for(int j=i*i ; j<=n; j+=i)\\n                    isPrime[j]=0;\\n            }\\n        }\\n        prime.reserve((int)(n/log(n)));//Use Prime Number Theory\\n        for(int i=2; i<=n; i++)\\n            if (isPrime[i]) prime.push_back(i);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617573,
                "title": "c-union-find",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nint find(int a,vector<int> &p){\\n    if(a == p[a])return a;\\n    return p[a] = find(p[a],p);\\n}\\nvoid unon(int a,int b,vector<int> &s,vector<int> &p){\\n    int x = find(a,p),y = find(b,p);\\n    if(x != y){\\n        if(s[y]<s[x])swap(x,y);\\n        p[x] = y;\\n        s[y] += s[x];\\n    }\\n}\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = 1e5+1,i;\\n        vector<int> s(n),p(n);\\n        for(i = 0; i < n; i++){\\n            s[i] = 1, p[i] = i;\\n        }\\n        for(auto &j: nums){\\n            for(i = 2; i <= sqrt(j); i++){\\n                if(j%i==0){\\n                    unon(i,j,s,p);\\n                    unon(j/i,j,s,p);\\n                }\\n            }\\n        }\\n        n = 0;\\n        unordered_map<int,int> mp;\\n        for(auto &i: nums){\\n            mp[find(i,p)]++;\\n            n = max(n,mp[find(i,p)]);\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Union Find",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint find(int a,vector<int> &p){\\n    if(a == p[a])return a;\\n    return p[a] = find(p[a],p);\\n}\\nvoid unon(int a,int b,vector<int> &s,vector<int> &p){\\n    int x = find(a,p),y = find(b,p);\\n    if(x != y){\\n        if(s[y]<s[x])swap(x,y);\\n        p[x] = y;\\n        s[y] += s[x];\\n    }\\n}\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = 1e5+1,i;\\n        vector<int> s(n),p(n);\\n        for(i = 0; i < n; i++){\\n            s[i] = 1, p[i] = i;\\n        }\\n        for(auto &j: nums){\\n            for(i = 2; i <= sqrt(j); i++){\\n                if(j%i==0){\\n                    unon(i,j,s,p);\\n                    unon(j/i,j,s,p);\\n                }\\n            }\\n        }\\n        n = 0;\\n        unordered_map<int,int> mp;\\n        for(auto &i: nums){\\n            mp[find(i,p)]++;\\n            n = max(n,mp[find(i,p)]);\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724652,
                "title": "c-sieve-of-eratosthenes-normal-dfs-without-dsu",
                "content": "class Solution {\\npublic:\\n\\n\\n    vector<vector<int>> g; // graph\\n    vector<int> isPrime, inArr,vis; // inArr[i] = 1, if i is present in nums\\n    int cnt;\\n    \\n    void dfs(int node){\\n        vis[node] = 1;\\n        if(inArr[node]) cnt++; // count only if element (here node) is present in nums\\n        for(auto &v: g[node]){\\n            if(!vis[v]){\\n                dfs(v);\\n            }\\n        }\\n    }\\n    \\n    void sieve(int n){ // normal sieve\\n        isPrime.assign(n+1,1);\\n        isPrime[0] = isPrime[1] = 0;\\n        for(int i = 2; i*i <= n; i++){\\n            if(isPrime[i]){\\n                for(long long j = i*i; j <= sqrt(n); j += i){\\n                    isPrime[j] = 0;\\n                }\\n            }\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n\\t\\n        int maxVal = -1;\\n        for(auto &x: nums) maxVal = max(maxVal,x); // maxvalue in nums\\n        sieve(maxVal+1);\\n\\t\\tg.resize(maxVal+1); \\n        inArr.assign(maxVal+1,0); vis.assign(maxVal+1,0);\\n        \\n        for(auto &x: nums) inArr[x] = 1;\\n        // creating graph\\n        for(int i = 1; i <= maxVal; i++){\\n            if(isPrime[i]){    // connecting nums[i] with its primes\\n                for(long long j = i*2; j <= maxVal; j += i){\\n                    if(inArr[j]){\\n                        g[i].push_back(j);\\n                        g[j].push_back(i);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int ans = -1; \\n        for(auto &x: nums){\\n            if(!vis[x]){\\n                cnt = 0;\\n                dfs(x);\\n                ans = max(ans,cnt); // counting size of maximum sized component\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\nThis method extends the idea of sieve, here the elements of nums are connected with their prime factors and size of connected component is calculated for only those which are present in nums.\\n\\nExample: [4, 6, 15, 35]\\n\\n2: its prime: connect 2 and its multiples (which are present in nums) with it (here 4 and 6)\\n3: its prime: connect 3 and its multiples (which are present in nums) with it (here 6 and 15)\\n5: its prime: connect 5 and its multiples (which are present in nums) with it (here 15 and 35)\\n7: its prime: connect 7 and its multiples (which are present in nums) with it (here 35 only)\\n\\nFinal graph will look like\\n\\n2 -- 4 -- 6 -- 3 -- 15 -- 5 -- 35 -- 7 (or print g for adjacency list view)\\n\\nCount elements which are present in nums to find the maximum size of connected component.",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n    vector<vector<int>> g; // graph\\n    vector<int> isPrime, inArr,vis; // inArr[i] = 1, if i is present in nums\\n    int cnt;\\n    \\n    void dfs(int node){\\n        vis[node] = 1;\\n        if(inArr[node]) cnt++; // count only if element (here node) is present in nums\\n        for(auto &v: g[node]){\\n            if(!vis[v]){\\n                dfs(v);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1592576,
                "title": "python-solution-using-disjoint-set-union-and-prime-factorization",
                "content": "**Time Complexity:** O(N log(M))\\n**Space Complexity:** O(M)\\nwhere N is the number of element and M is the maximum value among all elements\\n\\nTo have a factor greater than 1, two numbers must have common primes in their prime factorization. Using this information, we can merge elements having common primes with Disjoint Set Union\\n\\n```\\nclass DSU:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.ranks = [1 for i in range(n)]\\n    \\n    def find(self, u):\\n        if self.parent[u] == u:\\n            return u\\n        self.parent[u] = self.find(self.parent[u])\\n        return self.parent[u]\\n    \\n    def merge(self, u, v):\\n        u, v = self.find(u), self.find(v)\\n        if u == v:\\n            return\\n        \\n        if self.ranks[u] < self.ranks[v]:\\n            u, v = v, u\\n        self.ranks[u] += self.ranks[v]\\n        self.parent[v] = u\\n\\n\\nclass PrimeFactorizer:\\n    def __init__(self, mx):\\n        self.spf = [i for i in range(mx)]\\n        self.mx = mx\\n        self.sieve()\\n    \\n    def sieve(self):\\n        limit = int(sqrt(self.mx)) + 1\\n        \\n        for i in range(2, limit):\\n            if self.spf[i] != i:\\n                continue\\n            for j in range(i*i, self.mx, i):\\n                if self.spf[j] == j:\\n                    self.spf[j] = i\\n    \\n    def getPrimes(self, n):\\n        primes = []\\n        \\n        while n > 1:\\n            prime = self.spf[n]\\n            primes.append(prime)\\n            while n % prime == 0:\\n                n //= prime\\n        \\n        return primes\\n\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        max_num = max(nums)\\n        mp = defaultdict(list)\\n        \\n        dsu = DSU(len(nums))\\n        prime_factorizer = PrimeFactorizer(max_num + 1)\\n        \\n        for idx, num in enumerate(nums):\\n            for prime in prime_factorizer.getPrimes(num):\\n                mp[prime].append(idx)\\n        \\n        for prime in mp:\\n            for i in range(1, len(mp[prime])):\\n                dsu.merge(mp[prime][i], mp[prime][i-1])\\n        \\n        return max(dsu.ranks)\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.ranks = [1 for i in range(n)]\\n    \\n    def find(self, u):\\n        if self.parent[u] == u:\\n            return u\\n        self.parent[u] = self.find(self.parent[u])\\n        return self.parent[u]\\n    \\n    def merge(self, u, v):\\n        u, v = self.find(u), self.find(v)\\n        if u == v:\\n            return\\n        \\n        if self.ranks[u] < self.ranks[v]:\\n            u, v = v, u\\n        self.ranks[u] += self.ranks[v]\\n        self.parent[v] = u\\n\\n\\nclass PrimeFactorizer:\\n    def __init__(self, mx):\\n        self.spf = [i for i in range(mx)]\\n        self.mx = mx\\n        self.sieve()\\n    \\n    def sieve(self):\\n        limit = int(sqrt(self.mx)) + 1\\n        \\n        for i in range(2, limit):\\n            if self.spf[i] != i:\\n                continue\\n            for j in range(i*i, self.mx, i):\\n                if self.spf[j] == j:\\n                    self.spf[j] = i\\n    \\n    def getPrimes(self, n):\\n        primes = []\\n        \\n        while n > 1:\\n            prime = self.spf[n]\\n            primes.append(prime)\\n            while n % prime == 0:\\n                n //= prime\\n        \\n        return primes\\n\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        max_num = max(nums)\\n        mp = defaultdict(list)\\n        \\n        dsu = DSU(len(nums))\\n        prime_factorizer = PrimeFactorizer(max_num + 1)\\n        \\n        for idx, num in enumerate(nums):\\n            for prime in prime_factorizer.getPrimes(num):\\n                mp[prime].append(idx)\\n        \\n        for prime in mp:\\n            for i in range(1, len(mp[prime])):\\n                dsu.merge(mp[prime][i], mp[prime][i-1])\\n        \\n        return max(dsu.ranks)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592297,
                "title": "brute-force-to-optimal-c-simple-to-understand",
                "content": "1) **Brute Force colution** :\\n\\t\\n* \\tFind the greatest common divisors between two values.\\n* \\tIf GCD is greater than 1, then merge it \\n* \\tDo DFS for all unvisited value, print the maximum count of component.\\n```\\nclass Solution {\\n    private :\\n    int findGCD(int a, int b)\\n    {\\n        if(a == 0)\\n            return b;\\n        \\n        return findGCD(b%a, a);\\n    }\\n        \\n    \\n    bool isCommon(int u, int v)\\n    {\\n        // find gcd \\n        int gcd = findGCD(u, v);\\n        \\n        // gcd should be > 1\\n        return gcd > 1;\\n    }\\n    \\n    void dfs(int u, vector<int> adj[], int &curCount, vector<bool> &vis)\\n    {\\n        curCount++;\\n        \\n        vis[u] = true;\\n        \\n        for(auto v : adj[u])\\n        {\\n            if(!vis[v])\\n            {\\n                dfs(v, adj, curCount, vis);\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        vector<int> adj[n];\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i + 1; j < n; j++)\\n            {\\n                // if both values have common value, then add it to adjacent\\n                if(isCommon(nums[i], nums[j]))\\n                {\\n                    adj[i].push_back(j);\\n                    adj[j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        vector<bool> vis(n, false);\\n        int maxi = 0;\\n        \\n        // do dfs to find size of each component and print the maxi\\n        for(int i = 0; i < n; i++)\\n        {\\n           if(!vis[i])\\n           {\\n               int curCount = 0;\\n               \\n               dfs(i, adj, curCount, vis);\\n               \\n               maxi = max(maxi, curCount);\\n           }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```\\n\\n2) Optimal solution (using union-find algorithm)\\n\\n```\\nclass DSU\\n{\\n    private:\\n    vector<int> parent;\\n    \\n    public:\\n    DSU(int n)\\n    {\\n        for(int i = 0; i < n; i++)\\n        {\\n            parent.push_back(i);\\n        }\\n    }\\n    \\n    int findParent(int node)\\n    {\\n        if(parent[node] == node)\\n            return node;\\n        \\n        return parent[node] = findParent(parent[node]);\\n    }\\n    \\n    void _union(int u, int v)\\n    {\\n        int uParent = findParent(u);\\n        int vParent = findParent(v);\\n        \\n        if(uParent != vParent)\\n            parent[uParent] = parent[vParent];\\n    }\\n};\\n\\nclass Solution {\\n  \\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        \\n        int n = *max_element(nums.begin(), nums.end());\\n         \\n        DSU dsu(n+1);\\n        \\n        // do union for each element with all of the element\\'s factors\\n        for(auto &val : nums)\\n        {\\n            for(int i = 2; i * i <= val; i++)\\n            {\\n                if(val % i == 0)\\n                {\\n                    dsu._union(val, i);\\n                    dsu._union(val, val/i);\\n                    \\n                }\\n            }\\n        }\\n        \\n        \\n        unordered_map<int,int> mp;\\n        int res = 1;\\n        \\n        // count the number of parent for each value\\n        for(auto val : nums)\\n        {\\n            res = max(res, ++mp[dsu.findParent(val)]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    private :\\n    int findGCD(int a, int b)\\n    {\\n        if(a == 0)\\n            return b;\\n        \\n        return findGCD(b%a, a);\\n    }\\n        \\n    \\n    bool isCommon(int u, int v)\\n    {\\n        // find gcd \\n        int gcd = findGCD(u, v);\\n        \\n        // gcd should be > 1\\n        return gcd > 1;\\n    }\\n    \\n    void dfs(int u, vector<int> adj[], int &curCount, vector<bool> &vis)\\n    {\\n        curCount++;\\n        \\n        vis[u] = true;\\n        \\n        for(auto v : adj[u])\\n        {\\n            if(!vis[v])\\n            {\\n                dfs(v, adj, curCount, vis);\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        vector<int> adj[n];\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i + 1; j < n; j++)\\n            {\\n                // if both values have common value, then add it to adjacent\\n                if(isCommon(nums[i], nums[j]))\\n                {\\n                    adj[i].push_back(j);\\n                    adj[j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        vector<bool> vis(n, false);\\n        int maxi = 0;\\n        \\n        // do dfs to find size of each component and print the maxi\\n        for(int i = 0; i < n; i++)\\n        {\\n           if(!vis[i])\\n           {\\n               int curCount = 0;\\n               \\n               dfs(i, adj, curCount, vis);\\n               \\n               maxi = max(maxi, curCount);\\n           }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```\n```\\nclass DSU\\n{\\n    private:\\n    vector<int> parent;\\n    \\n    public:\\n    DSU(int n)\\n    {\\n        for(int i = 0; i < n; i++)\\n        {\\n            parent.push_back(i);\\n        }\\n    }\\n    \\n    int findParent(int node)\\n    {\\n        if(parent[node] == node)\\n            return node;\\n        \\n        return parent[node] = findParent(parent[node]);\\n    }\\n    \\n    void _union(int u, int v)\\n    {\\n        int uParent = findParent(u);\\n        int vParent = findParent(v);\\n        \\n        if(uParent != vParent)\\n            parent[uParent] = parent[vParent];\\n    }\\n};\\n\\nclass Solution {\\n  \\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        \\n        int n = *max_element(nums.begin(), nums.end());\\n         \\n        DSU dsu(n+1);\\n        \\n        // do union for each element with all of the element\\'s factors\\n        for(auto &val : nums)\\n        {\\n            for(int i = 2; i * i <= val; i++)\\n            {\\n                if(val % i == 0)\\n                {\\n                    dsu._union(val, i);\\n                    dsu._union(val, val/i);\\n                    \\n                }\\n            }\\n        }\\n        \\n        \\n        unordered_map<int,int> mp;\\n        int res = 1;\\n        \\n        // count the number of parent for each value\\n        for(auto val : nums)\\n        {\\n            res = max(res, ++mp[dsu.findParent(val)]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449216,
                "title": "c-union-find-sieve",
                "content": "Interesting Union Find Problems: \\n\\n- [959. Regions Cut By Slashes](https://leetcode.com/problems/regions-cut-by-slashes/) [Medium] \\n- [947. Most Stones Removed with Same Row or Column](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/) [Medium]\\n- [990. Satisfiability of Equality Equations](https://leetcode.com/problems/satisfiability-of-equality-equations/) [Medium]\\n- [952. Largest Component Size by Common Factor](https://leetcode.com/problems/largest-component-size-by-common-factor/) [Hard] - current question\\n- [1627. Graph Connectivity With Threshold](https://leetcode.com/problems/graph-connectivity-with-threshold/) [Hard]\\n- [1998. GCD Sort of an Array](https://leetcode.com/problems/gcd-sort-of-an-array/) [Hard]\\n\\n```\\nclass UnionFind {\\n    vector<int> parent, size;\\npublic:\\n    UnionFind(int n) {\\n        parent.resize(n); size.resize(n);\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i, size[i] = 1;\\n        }\\n    }\\n    \\n    int Find(int x) {\\n        if (x == parent[x]) return x;\\n        return parent[x] = Find(parent[x]); // Path compression\\n    }\\n    \\n    bool Union(int u, int v) {\\n        int pu = Find(u), pv = Find(v);\\n        if (pu == pv) return false; // Return False if u and v are already part of the same component\\n        if (size[pu] > size[pv]) { // Union by larger size\\n            size[pu] += size[pv];\\n            parent[pv] = pu;\\n        } else {\\n            size[pv] += size[pu];\\n            parent[pu] = pv;\\n        }\\n        return true;\\n    }\\n    \\n    int getComponentSize(int x) {\\n        return size[Find(x)];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> spf; // spf[x] is the smallest prime factor of number x, where x >= 2\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int maxNum = *max_element(nums.begin(), nums.end());\\n        UnionFind uf(maxNum + 1);\\n        sieve(maxNum);\\n        \\n        for (int x : nums) {\\n            for (int pf : getPrimeFactors(x)) {\\n                uf.Union(pf, x);\\n            }\\n        }\\n        \\n        int res = 1; // max_component_size\\n        map<int, int> component_size;\\n        for (int x : nums) {\\n            int parent = uf.Find(x);\\n            component_size[parent]++;\\n            res = max(res, component_size[parent]);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    void sieve(int n) {\\n        spf.resize(n+1);\\n        for (int i = 2; i <= n; ++i)\\n            spf[i] = i;\\n\\n        for (int i = 2; i * i <= n; i++) {\\n            if (spf[i] != i) continue; // skip if `i` is not a prime number\\n            for (int j = 2*i; j <= n; j += i) {\\n                if (spf[j] > i) { \\n                    spf[j] = i;\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<int> getPrimeFactors(int n) { // O(logN)\\n        vector<int> factors;\\n        while (n > 1) {\\n            factors.push_back(spf[n]);\\n            int s = spf[n]; // smallest prime factor\\n            while (n % s == 0) { n /= s;}\\n        }\\n        return factors;\\n    }\\n    \\n};\\n```\\n\\nReferences: \\n- https://leetcode.com/problems/gcd-sort-of-an-array/discuss/1445180/C%2B%2BPython-Union-Find-and-Sieve-and-Sorting-Clean-and-Concise\\n",
                "solutionTags": [],
                "code": "```\\nclass UnionFind {\\n    vector<int> parent, size;\\npublic:\\n    UnionFind(int n) {\\n        parent.resize(n); size.resize(n);\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i, size[i] = 1;\\n        }\\n    }\\n    \\n    int Find(int x) {\\n        if (x == parent[x]) return x;\\n        return parent[x] = Find(parent[x]); // Path compression\\n    }\\n    \\n    bool Union(int u, int v) {\\n        int pu = Find(u), pv = Find(v);\\n        if (pu == pv) return false; // Return False if u and v are already part of the same component\\n        if (size[pu] > size[pv]) { // Union by larger size\\n            size[pu] += size[pv];\\n            parent[pv] = pu;\\n        } else {\\n            size[pv] += size[pu];\\n            parent[pu] = pv;\\n        }\\n        return true;\\n    }\\n    \\n    int getComponentSize(int x) {\\n        return size[Find(x)];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> spf; // spf[x] is the smallest prime factor of number x, where x >= 2\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int maxNum = *max_element(nums.begin(), nums.end());\\n        UnionFind uf(maxNum + 1);\\n        sieve(maxNum);\\n        \\n        for (int x : nums) {\\n            for (int pf : getPrimeFactors(x)) {\\n                uf.Union(pf, x);\\n            }\\n        }\\n        \\n        int res = 1; // max_component_size\\n        map<int, int> component_size;\\n        for (int x : nums) {\\n            int parent = uf.Find(x);\\n            component_size[parent]++;\\n            res = max(res, component_size[parent]);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    void sieve(int n) {\\n        spf.resize(n+1);\\n        for (int i = 2; i <= n; ++i)\\n            spf[i] = i;\\n\\n        for (int i = 2; i * i <= n; i++) {\\n            if (spf[i] != i) continue; // skip if `i` is not a prime number\\n            for (int j = 2*i; j <= n; j += i) {\\n                if (spf[j] > i) { \\n                    spf[j] = i;\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<int> getPrimeFactors(int n) { // O(logN)\\n        vector<int> factors;\\n        while (n > 1) {\\n            factors.push_back(spf[n]);\\n            int s = spf[n]; // smallest prime factor\\n            while (n % s == 0) { n /= s;}\\n        }\\n        return factors;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467052,
                "title": "c-easy-understanding-union-find-solution",
                "content": "\\tclass dsu{\\n\\t\\tpublic:\\n\\t\\tvector<int> arr;\\n\\t\\tdsu(int n):arr(n){\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tarr[i]=i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\tvoid merge(int a, int b){\\n\\t\\t\\tarr[find(arr[a])]=arr[find(arr[b])];\\n\\t\\t}\\n\\n\\n\\t\\tint find(int x){\\n\\t\\t\\tif(arr[x]!=x){\\n\\t\\t\\t\\tarr[x]=find(arr[x]);\\n\\t\\t\\t}\\n\\t\\t\\treturn arr[x];\\n\\t\\t}\\n\\n\\n\\t};\\n\\tclass Solution {\\n\\n\\tpublic:\\n\\t\\tint largestComponentSize(vector<int>& A) {\\n\\t\\t\\tint n=*max_element(A.begin(),A.end());\\n\\t\\t\\tdsu DSU(n+1);\\n\\t\\t\\tfor(auto x:A){\\n\\t\\t\\t\\tint temp=sqrt(x);\\n\\t\\t\\t\\tfor(int k=2;k<=temp;k++){\\n\\t\\t\\t\\t\\tif(x%k==0){\\n\\t\\t\\t\\t\\t\\tDSU.merge(x,k);\\n\\t\\t\\t\\t\\t\\tDSU.merge(x,x/k);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tunordered_map<int,int> m;\\n\\t\\t\\tint res=1;\\n\\t\\t\\tfor(auto v:A){\\n\\t\\t\\t\\tm[DSU.find(v)]+=1;\\n\\t\\t\\t\\tres=max(res,m[DSU.find(v)]);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "class Solution {\\n\\n\\tpublic:\\n\\t\\tint largestComponentSize(vector<int>& A) {\\n\\t\\t\\tint n=*max_element(A.begin(),A.end());\\n\\t\\t\\tdsu DSU(n+1);\\n\\t\\t\\tfor(auto x:A){\\n\\t\\t\\t\\tint temp=sqrt(x);\\n\\t\\t\\t\\tfor(int k=2;k<=temp;k++){\\n\\t\\t\\t\\t\\tif(x%k==0){\\n\\t\\t\\t\\t\\t\\tDSU.merge(x,k);\\n\\t\\t\\t\\t\\t\\tDSU.merge(x,x/k);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3529307,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int arr[(int)(1e5+5)];\\n    int visit[(int)(1e5+5)]={0};\\n    int member[(int)(1e5+5)];\\n    constexpr void build(vector<int>& primes, pair<int,int>* sp, int N){\\n        if(primes.empty()){\\n            visit[0] = visit[1] = 1;\\n            sp[1].first = sp[1].second = 1;\\n            for(int i=2;i<=1e5;i++){\\n                if(!visit[i]){\\n                    primes.push_back(i);\\n                    sp[i].first=i;\\n                    sp[i].second = i;\\n                }for (int j=0; i*primes[j]<=1e5; j++){\\n                     visit[i*primes[j]] = 1;\\n                     sp[i*primes[j]].first = primes[j];\\n                     sp[i*primes[j]].second = sp[i].first == primes[j] ? sp[i].second : i;\\n                     if(i%primes[j]==0)break;\\n                 }\\n            }\\n        }\\n        for(int i=0;i<=N;i++){\\n            arr[i] = i;\\n        }\\n    }\\n    int find(int x){\\n        while(arr[x]!=x)\\n            x=arr[x];\\n        return x;\\n    }\\n    void uni(int x, int y){\\n        x = find(x), y = find(y);\\n        if(x==y)return;\\n        member[y]+=member[x];\\n        member[x]=0;\\n        arr[x] = y;\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n        static vector<int> primes;\\n        static pair<int,int> sp[(int)(1e5+5)];\\n        build(primes, sp, *max_element(nums.begin(),nums.end()));\\n        int ans=1;\\n        for(auto& it:nums){\\n            int pre=sp[it].first;\\n            it = sp[it].second;\\n            while(it!=sp[it].first){\\n                uni(sp[it].first, pre);\\n                pre = sp[it].first;\\n                it = sp[it].second;\\n            }\\n            uni(sp[it].first, pre);\\n            member[find(pre)]++;\\n            ans = max(member[find(pre)], ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nMAXN = 10**5 + 5\\nspf = list(range(MAXN))\\n\\ndef sieve():\\n\\tspf[1] = 1\\n\\n\\tfor i in range(4, MAXN, 2):\\n\\t\\tspf[i] = 2\\n\\n\\tfor i in range(3, ceil(sqrt(MAXN))):\\n\\t\\tif (spf[i] == i):\\n\\t\\t\\tfor j in range(i * i, MAXN, i):\\n\\t\\t\\t\\tif (spf[j] == j):\\n\\t\\t\\t\\t\\tspf[j] = i\\n\\ndef factors(x: int):\\n\\tfactors_set = set()\\n\\n\\twhile x != 1:\\n\\t\\tfactors_set.add(spf[x])\\n\\t\\tx //= spf[x]\\n\\n\\treturn factors_set\\n\\nsieve()\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        df = {}\\n        uf = UnionFind(len(nums))\\n        for pos, num in enumerate(nums):\\n            for factor in factors(num):\\n                if factor in df:\\n                    uf.union(pos, df[factor])\\n                else:\\n                    df[factor] = pos\\n                    \\n        return uf.mx\\n            \\nclass UnionFind:\\n    def __init__(self, n: int):\\n        self.root_lookup = list(range(n))\\n        self.rank_lookup = [1] * n\\n        self.mx = 1\\n\\n    def find(self, num: int):\\n        root = self.root_lookup[num]\\n        while root != self.root_lookup[root]:\\n              root = self.root_lookup[root]\\n        self.root_lookup[num] = root\\n        return root\\n    \\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        if xr == yr:\\n            return False\\n        if self.rank_lookup[xr] < self.rank_lookup[yr]:\\n            xr, yr = yr, xr\\n        self.root_lookup[yr] = xr\\n        self.rank_lookup[xr] += self.rank_lookup[yr]\\n        self.mx = max(self.mx,self.rank_lookup[xr])\\n        return True\\n```\\n\\n```Java []\\nclass Solution {\\n    public int gcd(int a, int b) {\\n        if(a < b) {\\n            int h = a;\\n            a = b;\\n            b = h;\\n        }\\n        while(b > 0) {\\n            int h = b;\\n            b = a % b;\\n            a = h;\\n        }\\n        return a;\\n    }\\n    public int largestComponentSize(int[] nums) {\\n        int n = nums.length;\\n        int max = 1;\\n        for(int num : nums) {\\n            max = Math.max(max, num);\\n        }\\n        int[] m = new int[max + 1];\\n        Arrays.fill(m, -1);\\n        boolean[] check = new boolean[max + 1];\\n        for(int i = 0; i < n; i++) {\\n            m[nums[i]] = i;\\n        }\\n        UnionFind uf = new UnionFind(n);\\n        for(int p = 2; p <= max; p++) {\\n            if(check[p])\\n                continue;\\n\\n            int first = -1;\\n            for(int div = p; div <= max; div += p) {\\n                if(m[div] >= 0) {\\n                    if(first == -1) {\\n                        first = m[div];\\n                    } else {\\n                        uf.join(first, m[div]);\\n                    }\\n                }\\n                check[div] = true;\\n            }\\n        }\\n        return uf.getMaxComponent();\\n    }\\n}\\npublic class UnionFind {\\n    private int[] parent;\\n    private int[] size;\\n    private int maxSize;\\n\\n    public UnionFind(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        maxSize = 1;\\n\\n        for(int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    public int find(int x) {\\n        return x != parent[x] ? parent[x] = find(parent[x]) : x;\\n    }\\n    public void join(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n\\n        if(x != y) {\\n            if(size[x] < size[y]) {\\n                int h = x;\\n                x = y;\\n                y = h;\\n            }\\n            size[x] += size[y];\\n            maxSize = Math.max(maxSize, size[x]);\\n            parent[y] = x;\\n        }\\n    }\\n    public int getMaxComponent() {\\n        return maxSize;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int arr[(int)(1e5+5)];\\n    int visit[(int)(1e5+5)]={0};\\n    int member[(int)(1e5+5)];\\n    constexpr void build(vector<int>& primes, pair<int,int>* sp, int N){\\n        if(primes.empty()){\\n            visit[0] = visit[1] = 1;\\n            sp[1].first = sp[1].second = 1;\\n            for(int i=2;i<=1e5;i++){\\n                if(!visit[i]){\\n                    primes.push_back(i);\\n                    sp[i].first=i;\\n                    sp[i].second = i;\\n                }for (int j=0; i*primes[j]<=1e5; j++){\\n                     visit[i*primes[j]] = 1;\\n                     sp[i*primes[j]].first = primes[j];\\n                     sp[i*primes[j]].second = sp[i].first == primes[j] ? sp[i].second : i;\\n                     if(i%primes[j]==0)break;\\n                 }\\n            }\\n        }\\n        for(int i=0;i<=N;i++){\\n            arr[i] = i;\\n        }\\n    }\\n    int find(int x){\\n        while(arr[x]!=x)\\n            x=arr[x];\\n        return x;\\n    }\\n    void uni(int x, int y){\\n        x = find(x), y = find(y);\\n        if(x==y)return;\\n        member[y]+=member[x];\\n        member[x]=0;\\n        arr[x] = y;\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n        static vector<int> primes;\\n        static pair<int,int> sp[(int)(1e5+5)];\\n        build(primes, sp, *max_element(nums.begin(),nums.end()));\\n        int ans=1;\\n        for(auto& it:nums){\\n            int pre=sp[it].first;\\n            it = sp[it].second;\\n            while(it!=sp[it].first){\\n                uni(sp[it].first, pre);\\n                pre = sp[it].first;\\n                it = sp[it].second;\\n            }\\n            uni(sp[it].first, pre);\\n            member[find(pre)]++;\\n            ans = max(member[find(pre)], ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nMAXN = 10**5 + 5\\nspf = list(range(MAXN))\\n\\ndef sieve():\\n\\tspf[1] = 1\\n\\n\\tfor i in range(4, MAXN, 2):\\n\\t\\tspf[i] = 2\\n\\n\\tfor i in range(3, ceil(sqrt(MAXN))):\\n\\t\\tif (spf[i] == i):\\n\\t\\t\\tfor j in range(i * i, MAXN, i):\\n\\t\\t\\t\\tif (spf[j] == j):\\n\\t\\t\\t\\t\\tspf[j] = i\\n\\ndef factors(x: int):\\n\\tfactors_set = set()\\n\\n\\twhile x != 1:\\n\\t\\tfactors_set.add(spf[x])\\n\\t\\tx //= spf[x]\\n\\n\\treturn factors_set\\n\\nsieve()\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        df = {}\\n        uf = UnionFind(len(nums))\\n        for pos, num in enumerate(nums):\\n            for factor in factors(num):\\n                if factor in df:\\n                    uf.union(pos, df[factor])\\n                else:\\n                    df[factor] = pos\\n                    \\n        return uf.mx\\n            \\nclass UnionFind:\\n    def __init__(self, n: int):\\n        self.root_lookup = list(range(n))\\n        self.rank_lookup = [1] * n\\n        self.mx = 1\\n\\n    def find(self, num: int):\\n        root = self.root_lookup[num]\\n        while root != self.root_lookup[root]:\\n              root = self.root_lookup[root]\\n        self.root_lookup[num] = root\\n        return root\\n    \\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        if xr == yr:\\n            return False\\n        if self.rank_lookup[xr] < self.rank_lookup[yr]:\\n            xr, yr = yr, xr\\n        self.root_lookup[yr] = xr\\n        self.rank_lookup[xr] += self.rank_lookup[yr]\\n        self.mx = max(self.mx,self.rank_lookup[xr])\\n        return True\\n```\n```Java []\\nclass Solution {\\n    public int gcd(int a, int b) {\\n        if(a < b) {\\n            int h = a;\\n            a = b;\\n            b = h;\\n        }\\n        while(b > 0) {\\n            int h = b;\\n            b = a % b;\\n            a = h;\\n        }\\n        return a;\\n    }\\n    public int largestComponentSize(int[] nums) {\\n        int n = nums.length;\\n        int max = 1;\\n        for(int num : nums) {\\n            max = Math.max(max, num);\\n        }\\n        int[] m = new int[max + 1];\\n        Arrays.fill(m, -1);\\n        boolean[] check = new boolean[max + 1];\\n        for(int i = 0; i < n; i++) {\\n            m[nums[i]] = i;\\n        }\\n        UnionFind uf = new UnionFind(n);\\n        for(int p = 2; p <= max; p++) {\\n            if(check[p])\\n                continue;\\n\\n            int first = -1;\\n            for(int div = p; div <= max; div += p) {\\n                if(m[div] >= 0) {\\n                    if(first == -1) {\\n                        first = m[div];\\n                    } else {\\n                        uf.join(first, m[div]);\\n                    }\\n                }\\n                check[div] = true;\\n            }\\n        }\\n        return uf.getMaxComponent();\\n    }\\n}\\npublic class UnionFind {\\n    private int[] parent;\\n    private int[] size;\\n    private int maxSize;\\n\\n    public UnionFind(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        maxSize = 1;\\n\\n        for(int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    public int find(int x) {\\n        return x != parent[x] ? parent[x] = find(parent[x]) : x;\\n    }\\n    public void join(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n\\n        if(x != y) {\\n            if(size[x] < size[y]) {\\n                int h = x;\\n                x = y;\\n                y = h;\\n            }\\n            size[x] += size[y];\\n            maxSize = Math.max(maxSize, size[x]);\\n            parent[y] = x;\\n        }\\n    }\\n    public int getMaxComponent() {\\n        return maxSize;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645270,
                "title": "union-by-size-prime-factorization",
                "content": "# Intuition  \\nLargest component by size => Union by size\\nShares common factor => we need to check all prime factors\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMake a hash table of integer , set.\\nIn the hash table the key will be the array element (unique)\\nand value will be a set of all prime factors of it.\\nThen union each array elements with it\\'s prime factors.\\n\\nused sieve of eratosthenes to generate all prime factors in logn.\\nAt first for each array elements size[element] = 1 and\\nsize of all other numbers will be 0.  So after union size of prime factors will not be counted.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * max number of prime factors among all nums[i]) + O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:   O( max( nums[ i ] ) )\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int parent [];\\n    int size [];\\n    public int largestComponentSize(int[] nums) {\\n     int max = nums[0] ;\\n     HashMap<Integer,HashSet<Integer>> primeFactors = new HashMap<>();\\n     for(int val : nums)   max = Math.max(max,val);\\n     int seive [] = new int[max + 1];\\n     parent = new int[max + 1];\\n     size  = new int[max + 1];\\n\\n     for(int i = 0; i < seive.length ; i++)   parent[i] = seive[i] = i;\\n\\n     for(int i = 2; i*i < seive.length ; i++){\\n         if(seive[i] == i){\\n             for(int j = i; j < seive.length ; j+=i){\\n                 if(seive[j] == j) seive[j] = i;\\n             }\\n         }\\n     }\\n\\n     for(int i = 0; i < nums.length ; i++){\\n         int val = nums[i];\\n         size[val] = 1;\\n         HashSet<Integer> set = new HashSet<>();\\n        addFactors(val,seive,set);\\n         primeFactors.put(val,set);\\n     }\\n\\n\\n\\n\\n         for(int val : nums){\\n             for(int fac : primeFactors.get(val)){\\n             if(val % fac == 0){\\n                 if(findparent(fac) != findparent(val)) {\\n                  union(fac , val);\\n                 }\\n             }\\n         }\\n         }\\n     \\n\\n    \\n            int ans = 1;\\n            for(int val : size) {\\n                ans = Math.max(ans,val);\\n            }\\n            return ans;\\n     \\n\\n    }\\n\\n    public int findparent(int node){\\n         if(parent[node] == node) return node;\\n         return parent[node] = findparent(parent[node]);\\n    }\\n\\n    public void union(int u , int v){\\n      u = findparent(u);\\n      v = findparent(v);\\n      if(size[u] > size[v]){\\n          parent[v] = u;\\n          size[u]+=size[v];\\n      }else {\\n        parent[u] = v;\\n          size[v]+=size[u];\\n      }\\n    }\\n\\n    public void addFactors(int val, int seive [] , HashSet<Integer> set){\\n          while(val > 1){\\n              set.add(seive[val]);\\n              val = val/seive[val];\\n          }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int parent [];\\n    int size [];\\n    public int largestComponentSize(int[] nums) {\\n     int max = nums[0] ;\\n     HashMap<Integer,HashSet<Integer>> primeFactors = new HashMap<>();\\n     for(int val : nums)   max = Math.max(max,val);\\n     int seive [] = new int[max + 1];\\n     parent = new int[max + 1];\\n     size  = new int[max + 1];\\n\\n     for(int i = 0; i < seive.length ; i++)   parent[i] = seive[i] = i;\\n\\n     for(int i = 2; i*i < seive.length ; i++){\\n         if(seive[i] == i){\\n             for(int j = i; j < seive.length ; j+=i){\\n                 if(seive[j] == j) seive[j] = i;\\n             }\\n         }\\n     }\\n\\n     for(int i = 0; i < nums.length ; i++){\\n         int val = nums[i];\\n         size[val] = 1;\\n         HashSet<Integer> set = new HashSet<>();\\n        addFactors(val,seive,set);\\n         primeFactors.put(val,set);\\n     }\\n\\n\\n\\n\\n         for(int val : nums){\\n             for(int fac : primeFactors.get(val)){\\n             if(val % fac == 0){\\n                 if(findparent(fac) != findparent(val)) {\\n                  union(fac , val);\\n                 }\\n             }\\n         }\\n         }\\n     \\n\\n    \\n            int ans = 1;\\n            for(int val : size) {\\n                ans = Math.max(ans,val);\\n            }\\n            return ans;\\n     \\n\\n    }\\n\\n    public int findparent(int node){\\n         if(parent[node] == node) return node;\\n         return parent[node] = findparent(parent[node]);\\n    }\\n\\n    public void union(int u , int v){\\n      u = findparent(u);\\n      v = findparent(v);\\n      if(size[u] > size[v]){\\n          parent[v] = u;\\n          size[u]+=size[v];\\n      }else {\\n        parent[u] = v;\\n          size[v]+=size[u];\\n      }\\n    }\\n\\n    public void addFactors(int val, int seive [] , HashSet<Integer> set){\\n          while(val > 1){\\n              set.add(seive[val]);\\n              val = val/seive[val];\\n          }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593686,
                "title": "c-union-find-every-line-explained",
                "content": "* Idea is to have multiple sets for each factor i.e. one set which has all numbers divisible by 2, one set with all numbers divisible by 3 etc.\\n* Once we encounter any number which is divisible by say 2 and 3, we join the two sets (i.e. set for factor 2 and set for factor 3)\\n* At the end we return the set with max numbers in it.\\n```\\npublic class Solution {\\n    Dictionary<int, int> dict = new Dictionary<int, int>(); // key is the factor, value is index of first num with that factor\\n    UnionFind uf;                                           // unionfind will maintain multiple sets for each factor\\n    public int LargestComponentSize(int[] nums) {\\n        var n = nums.Length;\\n        uf = new UnionFind(n);\\n        \\n        for (int i = 0; i < n; i++){                    // for each number in input array\\n            var num = nums[i];                          // the current number we are processing\\n            StartNewSetOrJoin(num, i, num);             // the number is a factor of itself\\n            for (int j = 2; j*j <= num; j++){           // j*j <= num because we want to only check factors till square root of num\\n                if (num % j == 0){                      // if j is a factor of num\\n                    StartNewSetOrJoin(num, i, j);       // add current num to set of factor j\\n                    StartNewSetOrJoin(num, i, num/j);   // obviously num/j is also a factor of num \\n                }\\n            }\\n        }\\n        \\n        return uf.max;\\n    }\\n    \\n    private void StartNewSetOrJoin(int num, int numIdx, int factor){\\n        if (!dict.ContainsKey(factor)){         // no number has had this factor yet\\n            dict[factor] = numIdx;              // so a new set starts with current number\\n        }else{                                  // if there is already a set with current factor as parent\\n            uf.Union(numIdx, dict[factor]);     // join current number with that set\\n        }\\n    }\\n}\\n\\n\\npublic class UnionFind{\\n    int[] parent;                           // it stores index of first node in a set\\n    int[] size;                             // keeps track of size of a set\\n    public int max;                         // this we maintain so that we don\\'t have to do a loop later to get biggest set\\n    \\n    public UnionFind(int n){\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 1;                            // all disjoint sets have one node\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;                  // all are self parent initially\\n            size[i] = 1;                    // size of all disjoint sets is 1 initially\\n        }\\n    }\\n    \\n    public int Find(int n){\\n        if(parent[n] != n)                  // if there are multiple nodes in current set\\n            parent[n] = Find(parent[n]);    // find parent node of the set\\n        return parent[n];                   // and then return the parent\\n    }\\n    \\n    public void Union(int n1, int n2){\\n        var n1_p = Find(n1);                // find parent of number 1\\n        var n2_p = Find(n2);                // find parent of number 2\\n        if(n1_p != n2_p){                   // if parent of number 1 and number 2 are not same, then we need to join two sets\\n            parent[n1_p] = n2_p;            // make n2\\'s parent as common parent for both sets. ideally smaller set should update its parent\\n            size[n2_p] += size[n1_p];       // update size of the merged set\\n            max = Math.Max(max, size[n2_p]);// update the max size of any set\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\npublic class Solution {\\n    Dictionary<int, int> dict = new Dictionary<int, int>(); // key is the factor, value is index of first num with that factor\\n    UnionFind uf;                                           // unionfind will maintain multiple sets for each factor\\n    public int LargestComponentSize(int[] nums) {\\n        var n = nums.Length;\\n        uf = new UnionFind(n);\\n        \\n        for (int i = 0; i < n; i++){                    // for each number in input array\\n            var num = nums[i];                          // the current number we are processing\\n            StartNewSetOrJoin(num, i, num);             // the number is a factor of itself\\n            for (int j = 2; j*j <= num; j++){           // j*j <= num because we want to only check factors till square root of num\\n                if (num % j == 0){                      // if j is a factor of num\\n                    StartNewSetOrJoin(num, i, j);       // add current num to set of factor j\\n                    StartNewSetOrJoin(num, i, num/j);   // obviously num/j is also a factor of num \\n                }\\n            }\\n        }\\n        \\n        return uf.max;\\n    }\\n    \\n    private void StartNewSetOrJoin(int num, int numIdx, int factor){\\n        if (!dict.ContainsKey(factor)){         // no number has had this factor yet\\n            dict[factor] = numIdx;              // so a new set starts with current number\\n        }else{                                  // if there is already a set with current factor as parent\\n            uf.Union(numIdx, dict[factor]);     // join current number with that set\\n        }\\n    }\\n}\\n\\n\\npublic class UnionFind{\\n    int[] parent;                           // it stores index of first node in a set\\n    int[] size;                             // keeps track of size of a set\\n    public int max;                         // this we maintain so that we don\\'t have to do a loop later to get biggest set\\n    \\n    public UnionFind(int n){\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 1;                            // all disjoint sets have one node\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;                  // all are self parent initially\\n            size[i] = 1;                    // size of all disjoint sets is 1 initially\\n        }\\n    }\\n    \\n    public int Find(int n){\\n        if(parent[n] != n)                  // if there are multiple nodes in current set\\n            parent[n] = Find(parent[n]);    // find parent node of the set\\n        return parent[n];                   // and then return the parent\\n    }\\n    \\n    public void Union(int n1, int n2){\\n        var n1_p = Find(n1);                // find parent of number 1\\n        var n2_p = Find(n2);                // find parent of number 2\\n        if(n1_p != n2_p){                   // if parent of number 1 and number 2 are not same, then we need to join two sets\\n            parent[n1_p] = n2_p;            // make n2\\'s parent as common parent for both sets. ideally smaller set should update its parent\\n            size[n2_p] += size[n1_p];       // update size of the merged set\\n            max = Math.Max(max, size[n2_p]);// update the max size of any set\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592949,
                "title": "c-union-find",
                "content": "Approach 1: Union-find\\n```\\nclass DSU {\\npublic:\\n  DSU(int n): p_(n) {\\n    for (int i = 0; i < n; ++i)\\n      p_[i] = i;\\n  }\\n  \\n  void Union(int x, int y) {\\n    p_[Find(x)] = p_[Find(y)];\\n  }\\n  \\n  int Find(int x) {\\n    if (p_[x] != x) p_[x] = Find(p_[x]);\\n    return p_[x];\\n  }\\nprivate:\\n  vector<int> p_;\\n};\\n \\nclass Solution {\\npublic:\\n  int largestComponentSize(vector<int>& A) {    \\n    int n = *max_element(begin(A), end(A));\\n    DSU dsu(n + 1);\\n    for (int a : A) {\\n      int t = sqrt(a);\\n      for (int k = 2; k <= t; ++k)\\n        if (a % k == 0) {\\n          dsu.Union(a, k);\\n          dsu.Union(a, a / k);\\n        }\\n    }\\n    unordered_map<int, int> c;\\n    int ans = 1;\\n    for (int a : A)\\n      ans = max(ans, ++c[dsu.Find(a)]);    \\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass DSU {\\npublic:\\n  DSU(int n): p_(n) {\\n    for (int i = 0; i < n; ++i)\\n      p_[i] = i;\\n  }\\n  \\n  void Union(int x, int y) {\\n    p_[Find(x)] = p_[Find(y)];\\n  }\\n  \\n  int Find(int x) {\\n    if (p_[x] != x) p_[x] = Find(p_[x]);\\n    return p_[x];\\n  }\\nprivate:\\n  vector<int> p_;\\n};\\n \\nclass Solution {\\npublic:\\n  int largestComponentSize(vector<int>& A) {    \\n    int n = *max_element(begin(A), end(A));\\n    DSU dsu(n + 1);\\n    for (int a : A) {\\n      int t = sqrt(a);\\n      for (int k = 2; k <= t; ++k)\\n        if (a % k == 0) {\\n          dsu.Union(a, k);\\n          dsu.Union(a, a / k);\\n        }\\n    }\\n    unordered_map<int, int> c;\\n    int ans = 1;\\n    for (int a : A)\\n      ans = max(ans, ++c[dsu.Find(a)]);    \\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592788,
                "title": "java-code",
                "content": "```\\nclass Solution {\\n\\tprivate class UnionFind {\\n\\t\\tprivate int[] parent;\\n\\n\\t\\tprivate UnionFind(int n){\\n\\t\\t\\tparent = new int[n];\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tparent[i] = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprivate int getAbsoluteParent(int i){\\n\\t\\t\\tif(parent[i]==i){\\n\\t\\t\\t\\t// absolute parent\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t\\tparent[i]=getAbsoluteParent(parent[i]);\\n\\t\\t\\treturn parent[i];\\n\\t\\t}\\n\\n\\t\\tprivate void unify(int i, int j){\\n\\t\\t\\tint absoluteParentI = getAbsoluteParent(i);\\n\\t\\t\\tint absoluteParentJ = getAbsoluteParent(j);\\n\\t\\t\\tif(absoluteParentI!=absoluteParentJ){\\n\\t\\t\\t\\t// 7->2, 21->2 (7,21)\\n\\t\\t\\t\\tparent[absoluteParentJ] = absoluteParentI;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\n\\tpublic int largestComponentSize(int[] nums) {\\n\\t\\tint max=0;\\n\\t\\tfor(int el:nums) {\\n\\t\\t\\tmax = Math.max(el, max);\\n\\t\\t}\\n\\t\\tUnionFind uf = new UnionFind(max+1);\\n\\n\\t\\tfor(int i:nums) {\\n\\t\\t\\tfor(int j=2;j*j<=i;j++) {\\n\\t\\t\\t\\tif(i%j==0){ // j is a factor of i\\n\\t\\t\\t\\t\\tuf.unify( j,i); // i=21, j=3\\n\\t\\t\\t\\t\\tuf.unify(i/j,i); // (21,3), (21,21/3(7))\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//<Parent, Freq>\\n\\t\\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n\\t\\tint maxComponet = 0;\\n\\t\\tfor(int el:nums){\\n\\t\\t\\tint parent = uf.getAbsoluteParent(el);\\n\\t\\t\\tmap.put(parent, map.getOrDefault(parent, 0) + 1);\\n\\t\\t\\tmaxComponet= Math.max(maxComponet, map.get(parent));\\n\\t\\t}\\n\\n\\n\\n\\t\\treturn maxComponet;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tprivate class UnionFind {\\n\\t\\tprivate int[] parent;\\n\\n\\t\\tprivate UnionFind(int n){\\n\\t\\t\\tparent = new int[n];\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tparent[i] = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprivate int getAbsoluteParent(int i){\\n\\t\\t\\tif(parent[i]==i){\\n\\t\\t\\t\\t// absolute parent\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t\\tparent[i]=getAbsoluteParent(parent[i]);\\n\\t\\t\\treturn parent[i];\\n\\t\\t}\\n\\n\\t\\tprivate void unify(int i, int j){\\n\\t\\t\\tint absoluteParentI = getAbsoluteParent(i);\\n\\t\\t\\tint absoluteParentJ = getAbsoluteParent(j);\\n\\t\\t\\tif(absoluteParentI!=absoluteParentJ){\\n\\t\\t\\t\\t// 7->2, 21->2 (7,21)\\n\\t\\t\\t\\tparent[absoluteParentJ] = absoluteParentI;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\n\\tpublic int largestComponentSize(int[] nums) {\\n\\t\\tint max=0;\\n\\t\\tfor(int el:nums) {\\n\\t\\t\\tmax = Math.max(el, max);\\n\\t\\t}\\n\\t\\tUnionFind uf = new UnionFind(max+1);\\n\\n\\t\\tfor(int i:nums) {\\n\\t\\t\\tfor(int j=2;j*j<=i;j++) {\\n\\t\\t\\t\\tif(i%j==0){ // j is a factor of i\\n\\t\\t\\t\\t\\tuf.unify( j,i); // i=21, j=3\\n\\t\\t\\t\\t\\tuf.unify(i/j,i); // (21,3), (21,21/3(7))\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//<Parent, Freq>\\n\\t\\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n\\t\\tint maxComponet = 0;\\n\\t\\tfor(int el:nums){\\n\\t\\t\\tint parent = uf.getAbsoluteParent(el);\\n\\t\\t\\tmap.put(parent, map.getOrDefault(parent, 0) + 1);\\n\\t\\t\\tmaxComponet= Math.max(maxComponet, map.get(parent));\\n\\t\\t}\\n\\n\\n\\n\\t\\treturn maxComponet;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546376,
                "title": "c-952-largest-component-size-by-common-factor",
                "content": "\\n```\\nclass UnionFind {\\npublic: \\n    vector<int> parent, rank; \\n    UnionFind(int n) {\\n        parent.resize(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        rank.resize(n); \\n        fill(rank.begin(), rank.end(), 1); \\n    }\\n    \\n    int find(int p) {\\n        if (p != parent[p]) \\n            parent[p] = find(parent[p]); \\n        return parent[p]; \\n    }\\n    \\n    bool connect(int p, int q) {\\n        int prt = find(p), qrt = find(q); \\n        if (prt == qrt) return false; \\n        if (rank[prt] > rank[qrt]) swap(prt, qrt); \\n        parent[prt] = qrt; \\n        rank[qrt] += rank[prt]; \\n        return true; \\n    }\\n}; \\n\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int m = *max_element(nums.begin(), nums.end()); \\n        vector<bool> seen(m+1); \\n        for (auto& x : nums) seen[x] = true; \\n        UnionFind* uf = new UnionFind(m+1); \\n        vector<bool> sieve(m+1, true); \\n        sieve[0] = sieve[1] = false; \\n        for (int x = 2; x <= m/2; ++x) \\n            if (sieve[x]) {\\n                int prev = seen[x] ? x : 0; \\n                for (int xx = 2*x; xx <= m; xx += x) {\\n                    sieve[xx] = false; \\n                    if (seen[xx]) \\n                        if (prev) uf->connect(prev, xx); \\n                        else prev = xx; \\n                }\\n            }\\n        int ans = *max_element(uf->rank.begin(), uf->rank.end()); \\n        delete uf; \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass UnionFind {\\npublic: \\n    vector<int> parent, rank; \\n    UnionFind(int n) {\\n        parent.resize(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        rank.resize(n); \\n        fill(rank.begin(), rank.end(), 1); \\n    }\\n    \\n    int find(int p) {\\n        if (p != parent[p]) \\n            parent[p] = find(parent[p]); \\n        return parent[p]; \\n    }\\n    \\n    bool connect(int p, int q) {\\n        int prt = find(p), qrt = find(q); \\n        if (prt == qrt) return false; \\n        if (rank[prt] > rank[qrt]) swap(prt, qrt); \\n        parent[prt] = qrt; \\n        rank[qrt] += rank[prt]; \\n        return true; \\n    }\\n}; \\n\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int m = *max_element(nums.begin(), nums.end()); \\n        vector<bool> seen(m+1); \\n        for (auto& x : nums) seen[x] = true; \\n        UnionFind* uf = new UnionFind(m+1); \\n        vector<bool> sieve(m+1, true); \\n        sieve[0] = sieve[1] = false; \\n        for (int x = 2; x <= m/2; ++x) \\n            if (sieve[x]) {\\n                int prev = seen[x] ? x : 0; \\n                for (int xx = 2*x; xx <= m; xx += x) {\\n                    sieve[xx] = false; \\n                    if (seen[xx]) \\n                        if (prev) uf->connect(prev, xx); \\n                        else prev = xx; \\n                }\\n            }\\n        int ans = *max_element(uf->rank.begin(), uf->rank.end()); \\n        delete uf; \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453397,
                "title": "easy-c-union-find-based-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(int x, vector<int> &parent)\\n    {\\n        if(x==parent[x])\\n        {\\n            return x;\\n        }\\n        return parent[x] = find(parent[x],parent);\\n    }\\n    void merge(int a,int b,vector<int> &parent,vector<int> &rank)\\n    {\\n        int pa = find(a,parent);\\n        int pb = find(b,parent);\\n        if(pa!=pb)\\n        {\\n            if(rank[pa]<rank[pb])\\n            {\\n                swap(pa,pb);\\n            }\\n            parent[pb] = pa;\\n            if(rank[pa]==rank[pb])\\n            {\\n                rank[pa]++;\\n            }\\n        }\\n    }\\n    \\n    unordered_set<int> get_factors(int n, vector<int> &sieve)\\n    {\\n        unordered_set<int> f;\\n        while(n>1)\\n        {\\n            f.insert(sieve[n]);\\n            n = n/sieve[n];\\n        }\\n        return f;\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxx = *max_element(nums.begin(),nums.end());\\n        vector<int> parent(maxx+1);\\n        for(int i =0;i<=maxx;i++)\\n        {\\n            parent[i] = i;\\n        }\\n        vector<int> rank(maxx+1,0);\\n        \\n        //create the factor sieve\\n        vector<int> sieve(maxx+1);\\n        for(int i=0;i<=maxx;i++)\\n        {\\n            sieve[i] = i;\\n        }\\n        for(int i=2;(i*i)<=maxx;i++)\\n        {\\n            if(sieve[i]==i)\\n            {\\n                for(int j = i*i;j<=maxx;j+=i)\\n                {\\n                    if(sieve[j]==j)\\n                    {\\n                        sieve[j] = i;\\n                    }\\n                }\\n            }\\n        }\\n        //\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int curr = nums[i];\\n            unordered_set<int> fac = get_factors(curr,sieve);\\n            for(int f:fac)\\n            {\\n                merge(f,curr,parent,rank);\\n            }\\n        }\\n        map<int,int> mp;\\n        int ans= 1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pc = find(nums[i],parent);\\n            mp[pc]++;\\n            ans = max(ans,mp[pc]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int x, vector<int> &parent)\\n    {\\n        if(x==parent[x])\\n        {\\n            return x;\\n        }\\n        return parent[x] = find(parent[x],parent);\\n    }\\n    void merge(int a,int b,vector<int> &parent,vector<int> &rank)\\n    {\\n        int pa = find(a,parent);\\n        int pb = find(b,parent);\\n        if(pa!=pb)\\n        {\\n            if(rank[pa]<rank[pb])\\n            {\\n                swap(pa,pb);\\n            }\\n            parent[pb] = pa;\\n            if(rank[pa]==rank[pb])\\n            {\\n                rank[pa]++;\\n            }\\n        }\\n    }\\n    \\n    unordered_set<int> get_factors(int n, vector<int> &sieve)\\n    {\\n        unordered_set<int> f;\\n        while(n>1)\\n        {\\n            f.insert(sieve[n]);\\n            n = n/sieve[n];\\n        }\\n        return f;\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxx = *max_element(nums.begin(),nums.end());\\n        vector<int> parent(maxx+1);\\n        for(int i =0;i<=maxx;i++)\\n        {\\n            parent[i] = i;\\n        }\\n        vector<int> rank(maxx+1,0);\\n        \\n        //create the factor sieve\\n        vector<int> sieve(maxx+1);\\n        for(int i=0;i<=maxx;i++)\\n        {\\n            sieve[i] = i;\\n        }\\n        for(int i=2;(i*i)<=maxx;i++)\\n        {\\n            if(sieve[i]==i)\\n            {\\n                for(int j = i*i;j<=maxx;j+=i)\\n                {\\n                    if(sieve[j]==j)\\n                    {\\n                        sieve[j] = i;\\n                    }\\n                }\\n            }\\n        }\\n        //\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int curr = nums[i];\\n            unordered_set<int> fac = get_factors(curr,sieve);\\n            for(int f:fac)\\n            {\\n                merge(f,curr,parent,rank);\\n            }\\n        }\\n        map<int,int> mp;\\n        int ans= 1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pc = find(nums[i],parent);\\n            mp[pc]++;\\n            ans = max(ans,mp[pc]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841771,
                "title": "union-find-using-path-compression-with-commented-code",
                "content": "```\\nclass Solution {\\n    static class UF {\\n        int[] size;\\n        int[] parent;\\n        int max;\\n        \\n        public UF(int n) {\\n            size = new int[n];\\n            parent= new int[n];\\n            for(int i=0; i<n; i++) {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        \\n        int find(int x) {\\n            int temp = x;\\n            while(parent[x] != x) {\\n                x = parent[x];\\n            }\\n            \\n            while(temp != x) {\\n                int ptemp = parent[temp];\\n                parent[temp] = x;\\n                temp = ptemp;\\n            }\\n            return x;\\n        }\\n        \\n        public void union(int x, int y) {\\n            int px = find(x);\\n            int py = find(y);\\n            if(px == py) return;\\n            \\n            if(size[px] > size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max= Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max= Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n    public int largestComponentSize(int[] A) {\\n        int n = A.length;\\n        UF uf = new UF(n);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i=0; i<n; i++) {\\n            int num = A[i];\\n            // to compute the factorization we need to go upto sqrt(num) times\\n            for(int j=2; j*j <=num; ++j) {\\n                // if j is one of the factor of num\\n                if(num%j == 0) {\\n                    if(map.containsKey(j)){\\n                        uf.union(i, map.get(j));\\n                    } else {\\n                        map.put(j, i);\\n                    }\\n                \\n                    if(map.containsKey(num/j)){\\n                        uf.union(i, map.get(num/j));\\n                    } else {\\n                        map.put(num/j, i);\\n                    }\\n                }\\n                \\n            }\\n            \\n            // if factor is not possible\\n            // then number itself is an factor\\n            if(map.containsKey(num)) {\\n                uf.union(i, map.get(num));\\n            } else {\\n                map.put(num, i);\\n            }\\n        }\\n        \\n        return uf.max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static class UF {\\n        int[] size;\\n        int[] parent;\\n        int max;\\n        \\n        public UF(int n) {\\n            size = new int[n];\\n            parent= new int[n];\\n            for(int i=0; i<n; i++) {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        \\n        int find(int x) {\\n            int temp = x;\\n            while(parent[x] != x) {\\n                x = parent[x];\\n            }\\n            \\n            while(temp != x) {\\n                int ptemp = parent[temp];\\n                parent[temp] = x;\\n                temp = ptemp;\\n            }\\n            return x;\\n        }\\n        \\n        public void union(int x, int y) {\\n            int px = find(x);\\n            int py = find(y);\\n            if(px == py) return;\\n            \\n            if(size[px] > size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max= Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max= Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n    public int largestComponentSize(int[] A) {\\n        int n = A.length;\\n        UF uf = new UF(n);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i=0; i<n; i++) {\\n            int num = A[i];\\n            // to compute the factorization we need to go upto sqrt(num) times\\n            for(int j=2; j*j <=num; ++j) {\\n                // if j is one of the factor of num\\n                if(num%j == 0) {\\n                    if(map.containsKey(j)){\\n                        uf.union(i, map.get(j));\\n                    } else {\\n                        map.put(j, i);\\n                    }\\n                \\n                    if(map.containsKey(num/j)){\\n                        uf.union(i, map.get(num/j));\\n                    } else {\\n                        map.put(num/j, i);\\n                    }\\n                }\\n                \\n            }\\n            \\n            // if factor is not possible\\n            // then number itself is an factor\\n            if(map.containsKey(num)) {\\n                uf.union(i, map.get(num));\\n            } else {\\n                map.put(num, i);\\n            }\\n        }\\n        \\n        return uf.max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822954,
                "title": "c-and-python-explained-2-solutions-based-on-sieve-o-n-log-m-o-m",
                "content": "I suggest reading this post only after you understood the `O(n*sqrt(m)) `solution.\\n\\nIn this problem we need to find the largest component where the numbers share a common factor.\\nFor this let us create these components, and then simply find the one which has more numbers.\\n\\n1. How can we create the components?\\n The main idea is to use prime factor decomposition (i.e. 42 = 2 * 3 * 7). Let us build a dictionary (unordered_map) with keys - prime numbers, and values - the numbers which have this prime in their decomposition.\\n 2. Why do we build this dictionary?\\n Because we need to connect the numbers fast. If we know that 3 numbers (let them be 2, 6, 8) have 2 as their common factor, then we know that 2, 6 and 8 are in the same component.\\n 3. How can we decompose our numbers?\\n There are 2 approaches with time complexities `O(sqrt(k))` and `O(log(k))` for each number k. The latter one is faster but it requires more space, we will use this one. There we should build a specific Sieve. In the `O(sqrt(k))` approach we go through each number `i = 1...sqrt(k)`, and check if `k mod i = 0` (i.e. we find the smallest prime factor which divides our number k). Now, what if we know already for every number k which is its smallest prime factor? Then, we can find its decomposition by dividing the given number recursively with its smallest prime factor till it becomes 1. Take 12, you divide it by 2 (you get 6), then one more time by 2 (you get 3), and then divide by 3 (you get 1, you stop the process, and you know that 12 = 2 * 2 * 3). In the original Sieve we have `Sieve[i] = true` if `i - prime`, else false. In our Sieve, which we will call \\'spf\\' (smallest prime factor), `spf[i] = i` if `i - prime`, and each time we get a prime number, we make `spf[2i], spf[3i], spf[4i] ... = i`. Also we should check if \\'i\\' isn\\'t already a smallest prime factor of another number. \\n 4. What\\'s next?\\n Now, we know how to create components for every unique prime, however there is a problem, we still need to connect the components which share at least one number. For example if we have 3 numbers (let them be 3, 5, 15), we will have 2 components (the former for the prime 3 (3, 15), and the latter for the prime 5 (5, 15)) but for this problem 3, 5 and 15 should be in the same component.\\n 5. How can we fix that?\\n I will show 2 solutions, one in C++ with DSU (Disjoint Set Union) - `O(n*logn)`, and another in Python with BFS - `O(n)`\\n \\n**C++ with DSU**\\n1. We build the Sieve and the primes dictionary.\\n2. We create the DSU, and then we join the numbers which share the same factor.\\n3. We count how many elements we have in each component and return the largest one.\\n```\\nclass Solution { // Sieve + DSU\\npublic:\\n    vector<int> parent, spf;\\n    void sieve(int N, vector<int> &spf) {\\n        spf = vector<int> (N);           // N = max(A) + 1\\n        for(int i = 1; i < N; ++i)       // Initially, we mark smallest prime factor for every number to be itself. \\n            spf[i] = i;\\n        for(int i = 2; i < N; i += 2)    // Like in the Sieve, it\\'s easier to mark even numbers separately \\n            spf[i] = 2;\\n        for(int i = 3; i < N; i += 2)\\n            if (spf[i] == i)             // If spf[i] == i, our number is prime\\n                for(int j = i; j < N; j += i)\\n                    if (spf[j] == j)     // Before we mark each 2i, 3i, 4i ..., we should check if it wasn\\'t already marked. Take 6, it is marked by 2 but it can also be marked by 3.\\n                        spf[j] = i;\\n    }\\n    int find(int node) {\\n        return node == parent[node] ? parent[node] : parent[node] = find(parent[node]);   \\n    }\\n    int largestComponentSize(vector<int>& A) {\\n        sieve(*max_element(A.begin(), A.end()) + 1, spf); // 1\\n        unordered_map <int, unordered_set<int>> primes;\\n        for(int i = 0; i < A.size(); ++i) {\\n            int num = A[i];\\n            while(num != 1) {\\n                primes[spf[num]].insert(i);\\n                num /= spf[num]; \\n            }\\n        }\\n        \\n        parent = vector<int> (A.size()); // 2\\n        for(int i = 0; i < A.size(); ++i)\\n            parent[i] = i;\\n        for(auto [_, x]: primes) {\\n            int i = *x.begin();\\n            x.erase(x.begin());\\n            for(int j: x)\\n                parent[find(i)] = find(j);\\n        }\\n        \\n        vector<int> components(A.size()); // 3\\n        for(int x: parent)\\n            components[find(x)]++;\\n        return *max_element(components.begin(), components.end());\\n    }\\n};\\n```\\n\\n**Python with BFS**\\n1. We build the Sieve and the primes dictionary.\\n2. For each number that we haven\\'t visited yet, we run a BFS over the primes in its decomposition.\\n3. For each prime, we find other numbers which have this prime in their decomposition, and we increment the number of components in our current (\\'cur\\') component. Also, we add to our queue other factors which we haven\\'t visited.\\n```\\nclass Solution:  # Sieve + BFS \\n    \\n    def largestComponentSize(self, A: List[int]) -> int:\\n        \\n        def sieve():\\n            i = 2\\n            while i < len(spf):\\n                spf[i] = 2\\n                i += 2\\n            i = 3\\n            while i * i < len(spf):\\n                if spf[i] == i:\\n                    j = i\\n                    while j < len(spf):\\n                        if spf[j] == j:\\n                            spf[j] = i\\n                        j += i\\n                i += 2\\n        \\n        spf, di, factors, visited_nums, visited_factors, ans = [i for i in range(max(A) + 1)], defaultdict(set), defaultdict(set), set(), set(), 1\\n        \\n        sieve()  # 1\\n        \\n        for num in A:\\n            x = num\\n            while x != 1:\\n                di[spf[x]].add(num)\\n                factors[num].add(spf[x])\\n                x //= spf[x]\\n        \\n        for num in A:  # 2\\n            if num in visited_nums:\\n                continue\\n                \\n            visited_nums.add(num)\\n            cur, queue = 1, deque([])\\n            for factor in factors[num]:\\n                queue.append(factor)\\n                \\n            while queue: \\n                factor = queue.popleft()\\n                visited_factors.add(factor)\\n                for next_num in di[factor]:  # 3\\n                    if next_num in visited_nums:\\n                        continue\\n                        \\n                    visited_nums.add(next_num)\\n                    cur += 1\\n                    for next_factor in factors[next_num]:\\n                        if next_factor in visited_factors:\\n                            continue\\n                        \\n                        visited_factors.add(next_factor)\\n                        queue.append(next_factor)\\n                \\n            ans = max(ans, cur)\\n        \\n        return ans\\n        \\n        \\n            \\n```\\n\\nEven if the DSU is slower than the BFS, the time complexities of both solutions are the same due to the Sieve.\\n\\n`TC - O(n*log(m))`, where m is the biggest number in our array\\n`SC - O(m)`",
                "solutionTags": [],
                "code": "```\\nclass Solution { // Sieve + DSU\\npublic:\\n    vector<int> parent, spf;\\n    void sieve(int N, vector<int> &spf) {\\n        spf = vector<int> (N);           // N = max(A) + 1\\n        for(int i = 1; i < N; ++i)       // Initially, we mark smallest prime factor for every number to be itself. \\n            spf[i] = i;\\n        for(int i = 2; i < N; i += 2)    // Like in the Sieve, it\\'s easier to mark even numbers separately \\n            spf[i] = 2;\\n        for(int i = 3; i < N; i += 2)\\n            if (spf[i] == i)             // If spf[i] == i, our number is prime\\n                for(int j = i; j < N; j += i)\\n                    if (spf[j] == j)     // Before we mark each 2i, 3i, 4i ..., we should check if it wasn\\'t already marked. Take 6, it is marked by 2 but it can also be marked by 3.\\n                        spf[j] = i;\\n    }\\n    int find(int node) {\\n        return node == parent[node] ? parent[node] : parent[node] = find(parent[node]);   \\n    }\\n    int largestComponentSize(vector<int>& A) {\\n        sieve(*max_element(A.begin(), A.end()) + 1, spf); // 1\\n        unordered_map <int, unordered_set<int>> primes;\\n        for(int i = 0; i < A.size(); ++i) {\\n            int num = A[i];\\n            while(num != 1) {\\n                primes[spf[num]].insert(i);\\n                num /= spf[num]; \\n            }\\n        }\\n        \\n        parent = vector<int> (A.size()); // 2\\n        for(int i = 0; i < A.size(); ++i)\\n            parent[i] = i;\\n        for(auto [_, x]: primes) {\\n            int i = *x.begin();\\n            x.erase(x.begin());\\n            for(int j: x)\\n                parent[find(i)] = find(j);\\n        }\\n        \\n        vector<int> components(A.size()); // 3\\n        for(int x: parent)\\n            components[find(x)]++;\\n        return *max_element(components.begin(), components.end());\\n    }\\n};\\n```\n```\\nclass Solution:  # Sieve + BFS \\n    \\n    def largestComponentSize(self, A: List[int]) -> int:\\n        \\n        def sieve():\\n            i = 2\\n            while i < len(spf):\\n                spf[i] = 2\\n                i += 2\\n            i = 3\\n            while i * i < len(spf):\\n                if spf[i] == i:\\n                    j = i\\n                    while j < len(spf):\\n                        if spf[j] == j:\\n                            spf[j] = i\\n                        j += i\\n                i += 2\\n        \\n        spf, di, factors, visited_nums, visited_factors, ans = [i for i in range(max(A) + 1)], defaultdict(set), defaultdict(set), set(), set(), 1\\n        \\n        sieve()  # 1\\n        \\n        for num in A:\\n            x = num\\n            while x != 1:\\n                di[spf[x]].add(num)\\n                factors[num].add(spf[x])\\n                x //= spf[x]\\n        \\n        for num in A:  # 2\\n            if num in visited_nums:\\n                continue\\n                \\n            visited_nums.add(num)\\n            cur, queue = 1, deque([])\\n            for factor in factors[num]:\\n                queue.append(factor)\\n                \\n            while queue: \\n                factor = queue.popleft()\\n                visited_factors.add(factor)\\n                for next_num in di[factor]:  # 3\\n                    if next_num in visited_nums:\\n                        continue\\n                        \\n                    visited_nums.add(next_num)\\n                    cur += 1\\n                    for next_factor in factors[next_num]:\\n                        if next_factor in visited_factors:\\n                            continue\\n                        \\n                        visited_factors.add(next_factor)\\n                        queue.append(next_factor)\\n                \\n            ans = max(ans, cur)\\n        \\n        return ans\\n        \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 822315,
                "title": "python3-official-solution-with-improvement-largest-component-size-by-common-factor",
                "content": "```\\nclass UF:        \\n    def __init__(self) -> None:\\n        self.parent = {}\\n        self.sz = {}\\n        self.count = 0\\n        \\n    def add(self, p):    \\n        if p not in self.parent:\\n            self.parent[p] = p\\n            self.sz[p] = 1\\n            self.count += 1\\n                          \\n    def find(self, p: int) -> int:\\n        while p != self.parent[p]:\\n            self.parent[p] = self.parent[self.parent[p]]\\n            p = self.parent[p]\\n        return p  \\n              \\n    def union(self, p: int, q: int) -> None:\\n        i = self.find(p)\\n        j = self.find(q)             \\n        if i == j:    \\n            return \\n        if self.sz[i] > self.sz[j]:                 \\n            self.parent[j] = i\\n            self.sz[i] += self.sz[j]\\n        else:             \\n            self.parent[i] = j\\n            self.sz[j] += self.sz[i]                                           \\n        self.count -= 1 \\n        \\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        def fac(n): \\n            for i in range(2, int(n**0.5)+1):\\n                if n % i == 0:\\n                    n //= i\\n                    return set((i,)) | fac(n)\\n            return set((n,))\\n        \\n        @lru_cache(None) \\n        def group_id(p):\\n            return uf.find(p)\\n        \\n        uf = UF()\\n        c = Counter() \\n        for n in A:\\n            factors = fac(n)\\n            if (key := tuple(sorted(factors))) not in c:\\n                p = factors.pop()\\n                uf.add(p)\\n                for q in factors:\\n                    uf.add(q)\\n                    uf.union(p, q)\\n            c[key] += 1\\n        if uf.count == 1:\\n            return len(A)            \\n        groups = Counter()\\n        for factors, value in c.items():\\n            groups[group_id(factors[0])] += value\\n        return groups.most_common()[0][1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass UF:        \\n    def __init__(self) -> None:\\n        self.parent = {}\\n        self.sz = {}\\n        self.count = 0\\n        \\n    def add(self, p):    \\n        if p not in self.parent:\\n            self.parent[p] = p\\n            self.sz[p] = 1\\n            self.count += 1\\n                          \\n    def find(self, p: int) -> int:\\n        while p != self.parent[p]:\\n            self.parent[p] = self.parent[self.parent[p]]\\n            p = self.parent[p]\\n        return p  \\n              \\n    def union(self, p: int, q: int) -> None:\\n        i = self.find(p)\\n        j = self.find(q)             \\n        if i == j:    \\n            return \\n        if self.sz[i] > self.sz[j]:                 \\n            self.parent[j] = i\\n            self.sz[i] += self.sz[j]\\n        else:             \\n            self.parent[i] = j\\n            self.sz[j] += self.sz[i]                                           \\n        self.count -= 1 \\n        \\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        def fac(n): \\n            for i in range(2, int(n**0.5)+1):\\n                if n % i == 0:\\n                    n //= i\\n                    return set((i,)) | fac(n)\\n            return set((n,))\\n        \\n        @lru_cache(None) \\n        def group_id(p):\\n            return uf.find(p)\\n        \\n        uf = UF()\\n        c = Counter() \\n        for n in A:\\n            factors = fac(n)\\n            if (key := tuple(sorted(factors))) not in c:\\n                p = factors.pop()\\n                uf.add(p)\\n                for q in factors:\\n                    uf.add(q)\\n                    uf.union(p, q)\\n            c[key] += 1\\n        if uf.count == 1:\\n            return len(A)            \\n        groups = Counter()\\n        for factors, value in c.items():\\n            groups[group_id(factors[0])] += value\\n        return groups.most_common()[0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821306,
                "title": "easy-java-implementation",
                "content": "```\\nclass Solution {\\n    public int find(int x,int[] parent)\\n    {\\n        if(parent[x]==-1)\\n            return x;\\n        else\\n            parent[x]=find(parent[x],parent);\\n        return parent[x];\\n    }\\n    public void union(int x,int y,int[] parent)\\n    {\\n        int xp=find(x,parent);\\n        int yp=find(y,parent);\\n        if(xp!=yp)\\n        {\\n            parent[yp]=xp;\\n        }\\n        return;\\n    }\\n    public int largestComponentSize(int[] nums) {\\n        int[] parent=new int[100001];\\n        Arrays.fill(parent,-1);\\n        int i;\\n        for(i=0;i<nums.length;i++)\\n        {\\n            for(int k=2;k<=Math.sqrt(nums[i]);k++)\\n            {\\n                if(nums[i]%k==0)\\n                {\\n                    union(nums[i],k,parent);\\n                    union(nums[i],nums[i]/k,parent);\\n                }\\n            }\\n        }\\n        int count=0;\\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\\n        for(i=0;i<nums.length;i++)\\n        {\\n            int p=find(nums[i],parent);\\n            count=Math.max(count,map.getOrDefault(p,0)+1);\\n            map.put(p,map.getOrDefault(p,0)+1);\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int find(int x,int[] parent)\\n    {\\n        if(parent[x]==-1)\\n            return x;\\n        else\\n            parent[x]=find(parent[x],parent);\\n        return parent[x];\\n    }\\n    public void union(int x,int y,int[] parent)\\n    {\\n        int xp=find(x,parent);\\n        int yp=find(y,parent);\\n        if(xp!=yp)\\n        {\\n            parent[yp]=xp;\\n        }\\n        return;\\n    }\\n    public int largestComponentSize(int[] nums) {\\n        int[] parent=new int[100001];\\n        Arrays.fill(parent,-1);\\n        int i;\\n        for(i=0;i<nums.length;i++)\\n        {\\n            for(int k=2;k<=Math.sqrt(nums[i]);k++)\\n            {\\n                if(nums[i]%k==0)\\n                {\\n                    union(nums[i],k,parent);\\n                    union(nums[i],nums[i]/k,parent);\\n                }\\n            }\\n        }\\n        int count=0;\\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\\n        for(i=0;i<nums.length;i++)\\n        {\\n            int p=find(nums[i],parent);\\n            count=Math.max(count,map.getOrDefault(p,0)+1);\\n            map.put(p,map.getOrDefault(p,0)+1);\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821179,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 300 ms, faster than 50.00% of Go online submissions for Largest Component Size by Common Factor.\\nMemory Usage: 8.6 MB, less than 50.00% of Go online submissions for Largest Component Size by Common Factor.\\n\\n```go\\ntype DSU struct {\\n    parent []int\\n}\\n\\nfunc (d *DSU) find(x int) int {\\n    if d.parent[x] != x { d.parent[x] = d.find(d.parent[x]) }\\n    return d.parent[x]\\n}\\n\\nfunc (d *DSU) union(x, y int) {\\n    d.parent[d.find(x)] = d.parent[d.find(y)]\\n}\\n\\nfunc Constructor(n int) *DSU {\\n    s := make([]int, n)\\n    for i := 0; i < n; i++ { s[i] = i }\\n    return &DSU{ s }\\n}\\n\\nfunc largestComponentSize(A []int) int {\\n    ans, max, cache := 1, 0, make(map[int]int)\\n    for _, a := range A { if a > max { max = a } }\\n    DSU := Constructor(max + 1)\\n    for _, a := range A {\\n        for k := 2; k <= int(math.Sqrt(float64(a))); k++ {\\n            if a % k == 0 {\\n                DSU.union(a, k)\\n                DSU.union(a, a / k)\\n            }\\n        }\\n    }\\n    for _, a := range A {\\n        r := DSU.find(a)\\n        cache[r]++\\n        if cache[r] > ans { ans = cache[r] }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\ntype DSU struct {\\n    parent []int\\n}\\n\\nfunc (d *DSU) find(x int) int {\\n    if d.parent[x] != x { d.parent[x] = d.find(d.parent[x]) }\\n    return d.parent[x]\\n}\\n\\nfunc (d *DSU) union(x, y int) {\\n    d.parent[d.find(x)] = d.parent[d.find(y)]\\n}\\n\\nfunc Constructor(n int) *DSU {\\n    s := make([]int, n)\\n    for i := 0; i < n; i++ { s[i] = i }\\n    return &DSU{ s }\\n}\\n\\nfunc largestComponentSize(A []int) int {\\n    ans, max, cache := 1, 0, make(map[int]int)\\n    for _, a := range A { if a > max { max = a } }\\n    DSU := Constructor(max + 1)\\n    for _, a := range A {\\n        for k := 2; k <= int(math.Sqrt(float64(a))); k++ {\\n            if a % k == 0 {\\n                DSU.union(a, k)\\n                DSU.union(a, a / k)\\n            }\\n        }\\n    }\\n    for _, a := range A {\\n        r := DSU.find(a)\\n        cache[r]++\\n        if cache[r] > ans { ans = cache[r] }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820634,
                "title": "c-union-find-solution",
                "content": "I first tried using graph implemented as adjacency matrix and performed depth first search using stack. This worked for 74/100 test cases but exceeded time limit for the 75th case. \\n\\nI referred to [Algorithms made easy - @khushbugupta \\'s video](https://www.youtube.com/watch?v=2mva2YRgrW8) on union-find and implemented the same in C.\\n\\n```\\nint find_max(int* arr, int ASize)\\n{\\n    int max = arr[0];\\n    for(int i = 1; i < ASize; ++i)\\n    {\\n        max = arr[i] > max ? arr[i] : max;\\n    }\\n    return max;\\n}\\n\\nint find(int* arr, int x)\\n{\\n    if(arr[x] != x)\\n    {\\n        arr[x] = find(arr, arr[x]);\\n    }\\n    return arr[x];\\n}\\n\\nvoid unionn(int* arr, int x, int y)\\n{\\n    arr[find(arr, x)] = arr[find(arr, y)];\\n}\\n\\nint maximum(int x, int y)\\n{\\n    return x > y ? x : y;\\n}\\n\\nint largestComponentSize(int* A, int ASize)\\n{\\n    int max = find_max(A, ASize);\\n    int* relationships = (int*)malloc((max+1) * sizeof(int));\\n    for(int i = 0; i < max+1; ++i)\\n    {\\n        relationships[i] = i;\\n    }\\n    int num;\\n    for(int i = 0; i < ASize; ++i)\\n    {\\n        num = A[i];\\n        for(int j = 2; j <= sqrt(num); ++j)\\n        {\\n            if(num % j == 0)\\n            {\\n                unionn(relationships, num, j);\\n                unionn(relationships, num, num/j);\\n            }\\n        }\\n    }\\n    //the value at res_dict[i] denotes the number of nodes which have relationship with i\\n    int* res_dict = (int*)calloc(max+1, sizeof(int));\\n    int prime_num;\\n    int res = 0;\\n    for(int i = 0; i < ASize; ++i)\\n    {\\n        prime_num = find(relationships, A[i]);\\n        ++res_dict[prime_num];\\n        res = maximum(res, res_dict[prime_num]);\\n    }\\n    return res;\\n}\\n\\n\\n\\n//OWN ATTEMPT : EXCEEDED TIME LIMIT AFTER BEING SUCCESSFUL FOR 74/100 TEST CASES\\n/*int gcd(int a, int b) \\n{ \\n    if (a == 0) \\n        return b; \\n    return gcd(b%a, a); \\n}\\n\\n\\nint** construct_graph(int* A, int ASize) //construct a graph (adjacency matrix) with the given constraints\\n{\\n    int** graph = (int**)malloc(ASize * sizeof(int*));\\n    for(int i = 0; i < ASize; ++i)\\n    {\\n        graph[i] = (int*)malloc(ASize * sizeof(int));\\n    }\\n    for(int i = 0; i < ASize; ++i)\\n    {\\n        for(int j = i+1; j < ASize; ++j)\\n        {\\n            if(gcd(A[i], A[j]) != 1)\\n            {\\n                graph[i][j] = graph[j][i] = 1;\\n            }\\n            else\\n            {\\n                graph[i][j] = graph[j][i] = 0;\\n            }\\n        }\\n    }\\n    return graph;\\n}\\n\\n\\nstruct stack{\\n    int* arr;\\n    int top;\\n    int capacity;\\n};\\n\\ntypedef struct stack stack;\\n\\nstack* init_stack(int capacity)\\n{\\n    stack* st = (stack*)malloc(sizeof(stack));\\n    st -> top = -1;\\n    st -> capacity = capacity;\\n    st -> arr = (int*)malloc(capacity * sizeof(int));\\n    return st;\\n}\\n\\nint is_Full(stack* st)\\n{\\n    return st -> top == st -> capacity -1;\\n}\\n\\nint is_Empty(stack* st)\\n{\\n    return st -> top == -1;\\n}\\n\\nvoid push(stack* st, int key)\\n{\\n    if(!is_Full(st))\\n        st -> arr[++st -> top] = key;\\n}\\n\\nint pop(stack* st)\\n{\\n    if(!is_Empty(st))\\n        return st -> arr[st->top--];\\n    return -1;\\n}\\n\\nint find_length(int* A, int ASize, int** graph, int key_index, int* visited)\\n{\\n    int count = 0;\\n    stack* st = init_stack(ASize);\\n    int* inStack = (int*)calloc(ASize, sizeof(int));\\n    int node_index = key_index;\\n    push(st, node_index);\\n    inStack[node_index] = 1;\\n    while(!is_Empty(st))\\n    {\\n        node_index = pop(st);\\n        ++count;\\n        visited[node_index] = 1;\\n        for(int i = 0; i < ASize; ++i)\\n        {\\n            if(graph[node_index][i] && visited[i] == 0 && !inStack[i])\\n            {\\n                push(st, i);\\n                inStack[i] = 1;\\n            }\\n        }\\n    }\\n    return count;\\n}\\n\\nint largestComponentSize(int* A, int ASize){\\n    int** graph = construct_graph(A, ASize);\\n    int* visited = (int*)calloc(ASize, sizeof(int));\\n    int res = 0;\\n    int sub_graph_length;\\n    for(int i = 0; i < ASize; ++i)\\n    {\\n        if(visited[i] == 0)\\n        {\\n            sub_graph_length = find_length(A, ASize, graph, i, visited);\\n            if(sub_graph_length > res)\\n                res = sub_graph_length;\\n        }\\n    }\\n    return res;\\n}*/\\n```",
                "solutionTags": [],
                "code": "```\\nint find_max(int* arr, int ASize)\\n{\\n    int max = arr[0];\\n    for(int i = 1; i < ASize; ++i)\\n    {\\n        max = arr[i] > max ? arr[i] : max;\\n    }\\n    return max;\\n}\\n\\nint find(int* arr, int x)\\n{\\n    if(arr[x] != x)\\n    {\\n        arr[x] = find(arr, arr[x]);\\n    }\\n    return arr[x];\\n}\\n\\nvoid unionn(int* arr, int x, int y)\\n{\\n    arr[find(arr, x)] = arr[find(arr, y)];\\n}\\n\\nint maximum(int x, int y)\\n{\\n    return x > y ? x : y;\\n}\\n\\nint largestComponentSize(int* A, int ASize)\\n{\\n    int max = find_max(A, ASize);\\n    int* relationships = (int*)malloc((max+1) * sizeof(int));\\n    for(int i = 0; i < max+1; ++i)\\n    {\\n        relationships[i] = i;\\n    }\\n    int num;\\n    for(int i = 0; i < ASize; ++i)\\n    {\\n        num = A[i];\\n        for(int j = 2; j <= sqrt(num); ++j)\\n        {\\n            if(num % j == 0)\\n            {\\n                unionn(relationships, num, j);\\n                unionn(relationships, num, num/j);\\n            }\\n        }\\n    }\\n    //the value at res_dict[i] denotes the number of nodes which have relationship with i\\n    int* res_dict = (int*)calloc(max+1, sizeof(int));\\n    int prime_num;\\n    int res = 0;\\n    for(int i = 0; i < ASize; ++i)\\n    {\\n        prime_num = find(relationships, A[i]);\\n        ++res_dict[prime_num];\\n        res = maximum(res, res_dict[prime_num]);\\n    }\\n    return res;\\n}\\n\\n\\n\\n//OWN ATTEMPT : EXCEEDED TIME LIMIT AFTER BEING SUCCESSFUL FOR 74/100 TEST CASES\\n/*int gcd(int a, int b) \\n{ \\n    if (a == 0) \\n        return b; \\n    return gcd(b%a, a); \\n}\\n\\n\\nint** construct_graph(int* A, int ASize) //construct a graph (adjacency matrix) with the given constraints\\n{\\n    int** graph = (int**)malloc(ASize * sizeof(int*));\\n    for(int i = 0; i < ASize; ++i)\\n    {\\n        graph[i] = (int*)malloc(ASize * sizeof(int));\\n    }\\n    for(int i = 0; i < ASize; ++i)\\n    {\\n        for(int j = i+1; j < ASize; ++j)\\n        {\\n            if(gcd(A[i], A[j]) != 1)\\n            {\\n                graph[i][j] = graph[j][i] = 1;\\n            }\\n            else\\n            {\\n                graph[i][j] = graph[j][i] = 0;\\n            }\\n        }\\n    }\\n    return graph;\\n}\\n\\n\\nstruct stack{\\n    int* arr;\\n    int top;\\n    int capacity;\\n};\\n\\ntypedef struct stack stack;\\n\\nstack* init_stack(int capacity)\\n{\\n    stack* st = (stack*)malloc(sizeof(stack));\\n    st -> top = -1;\\n    st -> capacity = capacity;\\n    st -> arr = (int*)malloc(capacity * sizeof(int));\\n    return st;\\n}\\n\\nint is_Full(stack* st)\\n{\\n    return st -> top == st -> capacity -1;\\n}\\n\\nint is_Empty(stack* st)\\n{\\n    return st -> top == -1;\\n}\\n\\nvoid push(stack* st, int key)\\n{\\n    if(!is_Full(st))\\n        st -> arr[++st -> top] = key;\\n}\\n\\nint pop(stack* st)\\n{\\n    if(!is_Empty(st))\\n        return st -> arr[st->top--];\\n    return -1;\\n}\\n\\nint find_length(int* A, int ASize, int** graph, int key_index, int* visited)\\n{\\n    int count = 0;\\n    stack* st = init_stack(ASize);\\n    int* inStack = (int*)calloc(ASize, sizeof(int));\\n    int node_index = key_index;\\n    push(st, node_index);\\n    inStack[node_index] = 1;\\n    while(!is_Empty(st))\\n    {\\n        node_index = pop(st);\\n        ++count;\\n        visited[node_index] = 1;\\n        for(int i = 0; i < ASize; ++i)\\n        {\\n            if(graph[node_index][i] && visited[i] == 0 && !inStack[i])\\n            {\\n                push(st, i);\\n                inStack[i] = 1;\\n            }\\n        }\\n    }\\n    return count;\\n}\\n\\nint largestComponentSize(int* A, int ASize){\\n    int** graph = construct_graph(A, ASize);\\n    int* visited = (int*)calloc(ASize, sizeof(int));\\n    int res = 0;\\n    int sub_graph_length;\\n    for(int i = 0; i < ASize; ++i)\\n    {\\n        if(visited[i] == 0)\\n        {\\n            sub_graph_length = find_length(A, ASize, graph, i, visited);\\n            if(sub_graph_length > res)\\n                res = sub_graph_length;\\n        }\\n    }\\n    return res;\\n}*/\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 820496,
                "title": "union-find-java",
                "content": "n^2 brute force union find exceeds the time limit, uses a map here.\\n```\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n        UF uf = new UF(A.length);\\n        \\n        Map<Integer, Integer> map = new HashMap<>();        \\n        for (int i = 0; i < A.length; i++)\\n        {            \\n            for (int j = 2; j * j <= A[i]; j++)\\n            {\\n                if (A[i] % j == 0)\\n                {\\n                    if (map.containsKey(j) && uf.find(i) != map.get(j))\\n                    {\\n                        uf.union(i, map.get(j));\\n                    }\\n                    else if (!map.containsKey(j))\\n                    {\\n                        map.put(j, i);\\n                    }\\n                    \\n                    if (map.containsKey(A[i] / j) && uf.find(i) != map.get(A[i] / j))\\n                    {\\n                        uf.union(i, map.get(A[i] / j));\\n                    }\\n                    else if (!map.containsKey(A[i] / j))\\n                    {\\n                        map.put(A[i] / j, i);\\n                    }\\n                }\\n            }\\n            \\n            if (map.containsKey(A[i]) && uf.find(i) != map.get(A[i]))\\n            {\\n                uf.union(i, map.get(A[i]));\\n            }\\n            else if (!map.containsKey(A[i]))\\n            {\\n                map.put(A[i], i);\\n            }\\n        }\\n        \\n        int[] counts = new int[A.length];\\n        int max = 0;\\n        \\n        for (int i = 0; i < A.length; i++)\\n        {\\n            counts[uf.find(i)]++;\\n            max = Math.max(max, counts[uf.find(i)]);\\n        }\\n        \\n        return max;\\n    }\\n    \\n    class UF\\n    {\\n        int[] roots;\\n        \\n        public UF(int length)\\n        {\\n            roots = new int[length];\\n            \\n            for (int i = 0; i < roots.length; i++)\\n            {\\n                roots[i] = i;\\n            }       \\n        }\\n        \\n        public void union(int i, int j)\\n        {   \\n            roots[find(i)] = roots[find(j)];\\n        }\\n        \\n        public int find(int i)\\n        {\\n            if (roots[i] != i)\\n            {\\n                roots[i] = find(roots[i]);\\n            }\\n            \\n            return roots[i];\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int largestComponentSize(int[] A) {\\n        UF uf = new UF(A.length);\\n        \\n        Map<Integer, Integer> map = new HashMap<>();        \\n        for (int i = 0; i < A.length; i++)\\n        {            \\n            for (int j = 2; j * j <= A[i]; j++)\\n            {\\n                if (A[i] % j == 0)\\n                {\\n                    if (map.containsKey(j) && uf.find(i) != map.get(j))\\n                    {\\n                        uf.union(i, map.get(j));\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 662628,
                "title": "union-find-prime-factorization-c-solution",
                "content": "```\\nclass Solution {\\n    vector<int> parent;\\npublic:\\n    int find(int x){\\n        if(parent[x]==-1) return x;\\n        return parent[x]=find(parent[x]);\\n    }\\n    void unio(int x,int y){\\n        int xd=find(x);\\n        int yd=find(y);\\n        if(xd!=yd){\\n            parent[xd]=yd;\\n        }\\n    }\\n    int largestComponentSize(vector<int>& A) {\\n        parent.resize(1000000+1,-1);\\n        for(auto a:A){\\n            int n=a;\\n            int count=0;\\n            while(n%2==0){\\n                n>>=1;\\n                count++;\\n            }\\n            if(count){\\n                unio(a,2);\\n            }\\n            for(int i=3;i<=sqrt(n);i++){\\n                int c=0;\\n                while(n%i==0){\\n                    n=n/i;\\n                    c++;\\n                }\\n                if(c){\\n                    unio(a,i);\\n                }\\n            }\\n            if(n>2){\\n                unio(a,n);\\n            }\\n        }\\n        unordered_map<int,int> mp;\\n        for(auto a:A){\\n            mp[find(a)]++;\\n        }\\n        int ans=1;\\n        for(auto m:mp){\\n            ans=max(ans,m.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> parent;\\npublic:\\n    int find(int x){\\n        if(parent[x]==-1) return x;\\n        return parent[x]=find(parent[x]);\\n    }\\n    void unio(int x,int y){\\n        int xd=find(x);\\n        int yd=find(y);\\n        if(xd!=yd){\\n            parent[xd]=yd;\\n        }\\n    }\\n    int largestComponentSize(vector<int>& A) {\\n        parent.resize(1000000+1,-1);\\n        for(auto a:A){\\n            int n=a;\\n            int count=0;\\n            while(n%2==0){\\n                n>>=1;\\n                count++;\\n            }\\n            if(count){\\n                unio(a,2);\\n            }\\n            for(int i=3;i<=sqrt(n);i++){\\n                int c=0;\\n                while(n%i==0){\\n                    n=n/i;\\n                    c++;\\n                }\\n                if(c){\\n                    unio(a,i);\\n                }\\n            }\\n            if(n>2){\\n                unio(a,n);\\n            }\\n        }\\n        unordered_map<int,int> mp;\\n        for(auto a:A){\\n            mp[find(a)]++;\\n        }\\n        int ans=1;\\n        for(auto m:mp){\\n            ans=max(ans,m.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640347,
                "title": "union-find-javascript-648ms",
                "content": "```\\n/**\\n * @param {number[]} A\\n * @return {number}\\n */\\n//UnionFind - 648ms - beats 100%\\n\\nvar largestComponentSize = function(A) {\\n    const p = []\\n    for(let num of A) {\\n        const set = getFactors(num)  // get the set of all the factors\\n        for(let factor of set.values()) {  \\n            p[find(factor)] = find(num) // union the number with all the factors\\n        }\\n    }\\n    \\n    const cntMap = new Map()\\n    for(let num of A) {   // for all the input numbers, count the related numbers via their parents \\n        const parent = find(num)\\n        cntMap.set(parent, (cntMap.get(parent) || 0) + 1) \\n    }\\n    return Math.max(...cntMap.values())\\n    \\n    function find(a) {\\n        if(!p[a]) p[a] = a\\n        while(p[a] !== a) {\\n            p[a] = p[p[a]]\\n            a = p[a]\\n        }\\n        return a\\n    }\\n    \\n    function getFactors(number) {\\n        const res = new Set()  // use set to guarantee no duplicates, no need to add number itself here. \\n        for (let i = 2; i * i <= number; i++) { \\n            if (number % i === 0) {\\n                res.add(i)\\n                res.add(number / i)\\n            }\\n        }\\n        return res\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @return {number}\\n */\\n//UnionFind - 648ms - beats 100%\\n\\nvar largestComponentSize = function(A) {\\n    const p = []\\n    for(let num of A) {\\n        const set = getFactors(num)  // get the set of all the factors\\n        for(let factor of set.values()) {  \\n            p[find(factor)] = find(num) // union the number with all the factors\\n        }\\n    }\\n    \\n    const cntMap = new Map()\\n    for(let num of A) {   // for all the input numbers, count the related numbers via their parents \\n        const parent = find(num)\\n        cntMap.set(parent, (cntMap.get(parent) || 0) + 1) \\n    }\\n    return Math.max(...cntMap.values())\\n    \\n    function find(a) {\\n        if(!p[a]) p[a] = a\\n        while(p[a] !== a) {\\n            p[a] = p[p[a]]\\n            a = p[a]\\n        }\\n        return a\\n    }\\n    \\n    function getFactors(number) {\\n        const res = new Set()  // use set to guarantee no duplicates, no need to add number itself here. \\n        for (let i = 2; i * i <= number; i++) { \\n            if (number % i === 0) {\\n                res.add(i)\\n                res.add(number / i)\\n            }\\n        }\\n        return res\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 476793,
                "title": "accepted-c-dsu-solution",
                "content": "```\\n    public class Solution\\n    {\\n        private class Unions\\n        {\\n            private readonly int[] _parents;\\n            private readonly int[] _ranks;\\n\\n            public Unions(int n)\\n            {\\n                _parents = new int[n];\\n                _ranks = new int[n];\\n                for (int i = 0; i < n; i++)\\n                {\\n                    _parents[i] = i;\\n                }\\n            }\\n\\n            public int Find(int x)\\n            {\\n                if (x != _parents[x])\\n                {\\n                    x = Find(_parents[x]);\\n                }\\n                return _parents[x];\\n            }\\n\\n            public bool Union(int x, int y)\\n            {\\n                int px = Find(x);\\n                int py = Find(y);\\n                if (px == py)\\n                {\\n                    return false;\\n                }\\n                if (_ranks[px] > _ranks[py])\\n                {\\n                    _parents[py] = px;\\n                    _ranks[px]++;\\n                }\\n                else\\n                {\\n                    _parents[px] = py;\\n                    _ranks[py]++;\\n                }\\n                return true;\\n            }\\n        }\\n\\n        public int LargestComponentSize(int[] nums)\\n        {\\n            IDictionary<int, int> factor2Root = new Dictionary<int, int>();\\n            Unions dsu = new Unions(nums.Length);\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                int currentNum = nums[i];\\n\\n                int factor = 2;\\n                while (factor * factor <= currentNum)\\n                {\\n                    if (currentNum % factor != 0)\\n                    {\\n                        factor++;\\n                        continue;\\n                    }\\n\\n                    if (factor2Root.ContainsKey(factor))\\n                    {\\n                        dsu.Union(i, factor2Root[factor]);\\n                    }\\n\\n                    factor2Root[factor] = dsu.Find(i);\\n\\n                    while (currentNum % factor == 0)\\n                    {\\n                        currentNum /= factor;\\n                    }\\n\\n                    factor++;\\n                }\\n\\n\\n                if (factor2Root.ContainsKey(nums[i]))\\n                {\\n                    dsu.Union(i, factor2Root[nums[i]]);\\n                }\\n                factor2Root[nums[i]] = dsu.Find(i);\\n\\n\\n\\n                if (currentNum != 1)\\n                {\\n                    if (factor2Root.ContainsKey(currentNum))\\n                    {\\n                        dsu.Union(i, factor2Root[currentNum]);\\n                    }\\n                    factor2Root[currentNum] = dsu.Find(i);\\n                }\\n            }\\n\\n            IDictionary<int, int> roots2Count = new Dictionary<int, int>();\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                var r = dsu.Find(i);\\n                if (!roots2Count.ContainsKey(r))\\n                {\\n                    roots2Count[r] = 0;\\n                }\\n\\n                roots2Count[r]++;\\n            }\\n\\n\\n            return roots2Count.Values.Max();\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private class Unions\\n        {\\n            private readonly int[] _parents;\\n            private readonly int[] _ranks;\\n\\n            public Unions(int n)\\n            {\\n                _parents = new int[n];\\n                _ranks = new int[n];\\n                for (int i = 0; i < n; i++)\\n                {\\n                    _parents[i] = i;\\n                }\\n            }\\n\\n            public int Find(int x)\\n            {\\n                if (x != _parents[x])\\n                {\\n                    x = Find(_parents[x]);\\n                }\\n                return _parents[x];\\n            }\\n\\n            public bool Union(int x, int y)\\n            {\\n                int px = Find(x);\\n                int py = Find(y);\\n                if (px == py)\\n                {\\n                    return false;\\n                }\\n                if (_ranks[px] > _ranks[py])\\n                {\\n                    _parents[py] = px;\\n                    _ranks[px]++;\\n                }\\n                else\\n                {\\n                    _parents[px] = py;\\n                    _ranks[py]++;\\n                }\\n                return true;\\n            }\\n        }\\n\\n        public int LargestComponentSize(int[] nums)\\n        {\\n            IDictionary<int, int> factor2Root = new Dictionary<int, int>();\\n            Unions dsu = new Unions(nums.Length);\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                int currentNum = nums[i];\\n\\n                int factor = 2;\\n                while (factor * factor <= currentNum)\\n                {\\n                    if (currentNum % factor != 0)\\n                    {\\n                        factor++;\\n                        continue;\\n                    }\\n\\n                    if (factor2Root.ContainsKey(factor))\\n                    {\\n                        dsu.Union(i, factor2Root[factor]);\\n                    }\\n\\n                    factor2Root[factor] = dsu.Find(i);\\n\\n                    while (currentNum % factor == 0)\\n                    {\\n                        currentNum /= factor;\\n                    }\\n\\n                    factor++;\\n                }\\n\\n\\n                if (factor2Root.ContainsKey(nums[i]))\\n                {\\n                    dsu.Union(i, factor2Root[nums[i]]);\\n                }\\n                factor2Root[nums[i]] = dsu.Find(i);\\n\\n\\n\\n                if (currentNum != 1)\\n                {\\n                    if (factor2Root.ContainsKey(currentNum))\\n                    {\\n                        dsu.Union(i, factor2Root[currentNum]);\\n                    }\\n                    factor2Root[currentNum] = dsu.Find(i);\\n                }\\n            }\\n\\n            IDictionary<int, int> roots2Count = new Dictionary<int, int>();\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                var r = dsu.Find(i);\\n                if (!roots2Count.ContainsKey(r))\\n                {\\n                    roots2Count[r] = 0;\\n                }\\n\\n                roots2Count[r]++;\\n            }\\n\\n\\n            return roots2Count.Values.Max();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204482,
                "title": "elegant-solution-using-kotlin-with-sieve-of-eratosthenes-bfs-o-1-000-000",
                "content": "The idea is to construct a Bipartite Graph with left vertices contain prime numbers, right vertices contain A[i]\\n```\\n2    A[0]\\n3    A[1]\\n5    A[2]\\n7    A[3]\\n...\\n```\\nand edges connect `left[l]` with `right[r]` satisfying `right[r] mod left[l] = 0`\\nThe number of edges will < the complexity of Sieve of Eratosthenes, which is ~ `1000000`\\nSo the problem become simple: find the largest connected component using `BFS` or `DFS`\\nFor the sake of this problem, it\\'s possible that A[i] = A[j], so instead of A in the right vertices, we instead use count map to count the number of occurance of each unique A member.\\nComplexity: O (100000 * 10) for both `Sieve of Eratosthenes` and `BFS`\\n```\\nclass Solution {\\n    fun largestComponentSize(A: IntArray): Int {\\n        val count = A.toList().groupingBy { it }.eachCount().toMutableMap()\\n        val left = mutableMapOf<Int, MutableSet<Int>>()\\n        val right = mutableMapOf<Int, MutableSet<Int>>()\\n        val prime = BooleanArray(100001, { _ -> true })\\n        for (p in 2 until 100001) {\\n            if (prime[p]) {\\n                for (d in IntProgression.fromClosedRange(p, 100000, p)) {\\n                    if (d > p) prime[d] = false\\n                    if (count.containsKey(d)) {\\n                        left.computeIfAbsent(p, { _ -> hashSetOf() }).add(d)\\n                        right.computeIfAbsent(d, { _ -> hashSetOf() }).add(p)\\n                    }\\n                }\\n            }\\n        }\\n\\n        var max = 0\\n        while (left.isNotEmpty()) {\\n            val queue = mutableSetOf<Int>()\\n            var sum = 0\\n            queue.add(left.keys.first())\\n            while (queue.isNotEmpty()) {\\n                val l = queue.first().also { queue.remove(it) }\\n                val rs = left.remove(l) ?: emptyList<Int>()\\n                for (r in rs) {\\n                    sum += count.remove(r) ?: 0\\n                    queue.addAll((right.remove(r) ?: mutableSetOf()).toList())\\n                }\\n            }\\n            max = kotlin.math.max(max, sum)\\n        }\\n\\n        return max\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n2    A[0]\\n3    A[1]\\n5    A[2]\\n7    A[3]\\n...\\n```\n```\\nclass Solution {\\n    fun largestComponentSize(A: IntArray): Int {\\n        val count = A.toList().groupingBy { it }.eachCount().toMutableMap()\\n        val left = mutableMapOf<Int, MutableSet<Int>>()\\n        val right = mutableMapOf<Int, MutableSet<Int>>()\\n        val prime = BooleanArray(100001, { _ -> true })\\n        for (p in 2 until 100001) {\\n            if (prime[p]) {\\n                for (d in IntProgression.fromClosedRange(p, 100000, p)) {\\n                    if (d > p) prime[d] = false\\n                    if (count.containsKey(d)) {\\n                        left.computeIfAbsent(p, { _ -> hashSetOf() }).add(d)\\n                        right.computeIfAbsent(d, { _ -> hashSetOf() }).add(p)\\n                    }\\n                }\\n            }\\n        }\\n\\n        var max = 0\\n        while (left.isNotEmpty()) {\\n            val queue = mutableSetOf<Int>()\\n            var sum = 0\\n            queue.add(left.keys.first())\\n            while (queue.isNotEmpty()) {\\n                val l = queue.first().also { queue.remove(it) }\\n                val rs = left.remove(l) ?: emptyList<Int>()\\n                for (r in rs) {\\n                    sum += count.remove(r) ?: 0\\n                    queue.addAll((right.remove(r) ?: mutableSetOf()).toList())\\n                }\\n            }\\n            max = kotlin.math.max(max, sum)\\n        }\\n\\n        return max\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203266,
                "title": "java-solution-without-prime-factor",
                "content": "```\\n    int[] parent;\\n    int[] size;\\n    int res=0;\\n    public int largestComponentSize(int[] A) {\\n        parent=new int[A.length];\\n        size=new int[A.length];\\n        Map<Integer, List<Integer>> map=new HashMap<>();\\n        Map<Integer, Integer> pos=new HashMap<>();\\n        for(int i=0;i<A.length;i++) {\\n            parent[i]=-1;\\n            size[i]=1;\\n            pos.put(A[i], i);\\n            for(int j=1;j<=Math.sqrt(A[i]);j++) {\\n                if(A[i]%j==0) {\\n                    if(!map.containsKey(j)) map.put(j, new ArrayList<Integer>());\\n                    map.get(j).add(A[i]);\\n                    if(!map.containsKey(A[i]/j)) map.put(A[i]/j, new ArrayList<Integer>());\\n                    map.get(A[i]/j).add(A[i]);\\n                }\\n            }\\n        }\\n        map.remove(1);\\n        for(int i : map.keySet()) {\\n            List<Integer> cur=map.get(i);\\n            for(int j=0;j<cur.size()-1;j++) union(pos.get(cur.get(j)), pos.get(cur.get(j+1)));\\n        }\\n        return res;\\n    }\\n    \\n    public int find(int x) {\\n        while(parent[x]!=-1) x=parent[x];\\n        return x;\\n    }\\n    \\n    public void union(int x, int y) {\\n        int px=find(x), py=find(y);\\n        if(px!=py) {\\n            if(size[px]<size[py]) {\\n                parent[px]=py;\\n                size[py]+=size[px];\\n                res=Math.max(res, size[py]);\\n            }\\n            else {\\n                parent[py]=px;\\n                size[px]+=size[py];\\n                res=Math.max(res, size[px]);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "```\\n    int[] parent;\\n    int[] size;\\n    int res=0;\\n    public int largestComponentSize(int[] A) {\\n        parent=new int[A.length];\\n        size=new int[A.length];\\n        Map<Integer, List<Integer>> map=new HashMap<>();\\n        Map<Integer, Integer> pos=new HashMap<>();\\n        for(int i=0;i<A.length;i++) {\\n            parent[i]=-1;\\n            size[i]=1;\\n            pos.put(A[i], i);\\n            for(int j=1;j<=Math.sqrt(A[i]);j++) {\\n                if(A[i]%j==0) {\\n                    if(!map.containsKey(j)) map.put(j, new ArrayList<Integer>());\\n                    map.get(j).add(A[i]);\\n                    if(!map.containsKey(A[i]/j)) map.put(A[i]/j, new ArrayList<Integer>());\\n                    map.get(A[i]/j).add(A[i]);\\n                }\\n            }\\n        }\\n        map.remove(1);\\n        for(int i : map.keySet()) {\\n            List<Integer> cur=map.get(i);\\n            for(int j=0;j<cur.size()-1;j++) union(pos.get(cur.get(j)), pos.get(cur.get(j+1)));\\n        }\\n        return res;\\n    }\\n    \\n    public int find(int x) {\\n        while(parent[x]!=-1) x=parent[x];\\n        return x;\\n    }\\n    \\n    public void union(int x, int y) {\\n        int px=find(x), py=find(y);\\n        if(px!=py) {\\n            if(size[px]<size[py]) {\\n                parent[px]=py;\\n                size[py]+=size[px];\\n                res=Math.max(res, size[py]);\\n            }\\n            else {\\n                parent[py]=px;\\n                size[px]+=size[py];\\n                res=Math.max(res, size[px]);\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 202425,
                "title": "o-nlg-n-full-solution-with-explanation",
                "content": "since the maximum value of n<=100000, which means our solution must have atmost \\nT(n)<=O(nlg(n).\\nThe main crux of problem is to connect the two number having a divisor greater than 1.\\nAgain we know every number  can we written as multiple of prime numbers (prime factorisation).\\nWe will use sieve ***REFER*** [https://www.geeksforgeeks.org/prime-factorization-using-sieve-olog-n-multiple-queries/](http://)\\nI will tell anyway the psudo code of prime factorisation\\nprime_fact(n):\\nwhile(n%2==0):\\nn=n/2;        // 2 is prime factor\\nfor(i=3;i<=sqrt(n);i++):\\n\\twhile(n%i):\\n\\t\\tn=n/i;  // 3 is prime factor\\nif(n>2): \\nn                // n is primefacor\\n\\nWe will use MAP to store mapping from prime number to respective index.\\nThen will use Disjoint Union Find Data Structure with path compression  ***REFER***\\n[https://drive.google.com/file/d/1Zky8tK6GKRcoLUZMFdxqsEF0hTFSm1Pn/view?usp=sharing]\\n\\n\\n```\\nint find_root(vector<int>&id,int i){\\n    while(i!=id[i]){\\n        id[i]=id[id[i]]; //pathcompression;\\n        i=id[i];\\n    }\\n    return i;\\n}\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& A) {\\n        map<int,vector<int>>mymap;\\n        vector<int>id(A.size());\\n        vector<int>size(A.size(),1);\\n        for(int i=0;i<A.size();i++){\\n            id[i]=i;\\n        }\\n           \\n        int n;\\n        \\n        for(int i=0;i<A.size();i++){\\n            n=A[i];\\n            bool temp=false;\\n            while(n%2==0){\\n                n=n/2;\\n                temp=true;\\n             }\\n            if(temp==true) mymap[2].push_back(i);\\n            for(int k=3;k<=sqrt(n);k++){\\n                \\n                temp=false;\\n                while(n%k==0){\\n                    n=n/k;\\n                    temp=true;\\n                }\\n                \\n                if(temp==true) mymap[k].push_back(i);\\n            }\\n            \\n            if(n>2){\\n                mymap[n].push_back(i);\\n            }\\n            \\n        }\\n        \\n        int maxi=1;\\n        \\n        for(auto it=mymap.begin();it!=mymap.end();it++){\\n            \\n            for(int k=0;k<it->second.size()-1;k++){\\n                int pa=find_root(id,it->second[k]);\\n                int pb=find_root(id,it->second[k+1]);\\n                if(pa!=pb){\\n                    \\n                    if(size[pa]>size[pb]){\\n                        id[pb]=pa;\\n                        size[pa]+=size[pb];\\n                        maxi=max(maxi,size[pa]);\\n                    }\\n                    else{\\n                        id[pa]=pb;\\n                        size[pb]+=size[pa];\\n                        maxi=max(maxi,size[pb]);\\n                    }\\n                    \\n                }\\n                  \\n            }\\n            \\n        }\\n        return maxi;   \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint find_root(vector<int>&id,int i){\\n    while(i!=id[i]){\\n        id[i]=id[id[i]]; //pathcompression;\\n        i=id[i];\\n    }\\n    return i;\\n}\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& A) {\\n        map<int,vector<int>>mymap;\\n        vector<int>id(A.size());\\n        vector<int>size(A.size(),1);\\n        for(int i=0;i<A.size();i++){\\n            id[i]=i;\\n        }\\n           \\n        int n;\\n        \\n        for(int i=0;i<A.size();i++){\\n            n=A[i];\\n            bool temp=false;\\n            while(n%2==0){\\n                n=n/2;\\n                temp=true;\\n             }\\n            if(temp==true) mymap[2].push_back(i);\\n            for(int k=3;k<=sqrt(n);k++){\\n                \\n                temp=false;\\n                while(n%k==0){\\n                    n=n/k;\\n                    temp=true;\\n                }\\n                \\n                if(temp==true) mymap[k].push_back(i);\\n            }\\n            \\n            if(n>2){\\n                mymap[n].push_back(i);\\n            }\\n            \\n        }\\n        \\n        int maxi=1;\\n        \\n        for(auto it=mymap.begin();it!=mymap.end();it++){\\n            \\n            for(int k=0;k<it->second.size()-1;k++){\\n                int pa=find_root(id,it->second[k]);\\n                int pb=find_root(id,it->second[k+1]);\\n                if(pa!=pb){\\n                    \\n                    if(size[pa]>size[pb]){\\n                        id[pb]=pa;\\n                        size[pa]+=size[pb];\\n                        maxi=max(maxi,size[pa]);\\n                    }\\n                    else{\\n                        id[pa]=pb;\\n                        size[pb]+=size[pa];\\n                        maxi=max(maxi,size[pb]);\\n                    }\\n                    \\n                }\\n                  \\n            }\\n            \\n        }\\n        return maxi;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200618,
                "title": "python-1396ms-faster-than-official-2224ms-method",
                "content": "maybe you are curious about step 3. step 3 is to deal with the prime number which is larger than m ** 0.5. step 1,2,4 are very intuitive tbh. For the running time, they are not consistent for each run. I have submitted several times and below are the report.\\na few seconds ago\\tAccepted\\t1396 ms\\tpython\\na few seconds ago\\tAccepted\\t1572 ms\\tpython\\na few seconds ago\\tAccepted\\t1836 ms\\tpython\\na few seconds ago\\tAccepted\\t1696 ms\\tpython\\na few seconds ago\\tAccepted\\t1396 ms\\tpython\\n3 minutes ago\\tAccepted\\t1408 ms\\tpython\\n3 minutes ago\\tAccepted\\t1448 ms\\tpython\\n3 minutes ago\\tAccepted\\t1944 ms\\tpython\\n4 minutes ago\\tAccepted\\t1536 ms\\tpython\\n4 minutes ago\\tAccepted\\t1648 ms\\tpython\\n4 minutes ago\\tAccepted\\t1384 ms\\tpython\\n\\n\\n```\\nclass Solution(object):\\n    def largestComponentSize(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        parent = range(len(A))\\n        # Union Find\\n        def Findparent(i):\\n            if parent[i] != i:\\n                parent[i] = Findparent(parent[i])\\n            return parent[i]\\n\\n        # step 1: Sieve of Eratosthenes, only consider the prime number <= m ** 0.5 \\n        m = int(max(A) ** 0.5) + 1\\n        R = [1] * m\\n        prime = []\\n        for i in xrange(2, m):\\n            if R[i] == 1:\\n                prime.append(i)\\n            for j in xrange(i*i, m, i):\\n                R[j] = 0\\n        \\n        # step 2: check every prime number and do some prunes to narrow the search space\\n        B = range(len(A))\\n        for p in prime:\\n            tempB = []\\n            L = -1\\n            # print A, B, parent\\n            for idx in B:\\n                if A[idx] % p == 0:\\n                    if L == -1:\\n                        L = idx\\n                        a = Findparent(L)\\n                    else:\\n                        b = Findparent(idx)\\n                        parent[b] = a\\n                    while A[idx] % p == 0:\\n                        A[idx] /= p      \\n                if A[idx] > p:\\n                    tempB.append(idx)     \\n            B = tempB\\n        \\n        # step 3: deal with the number with primes > m ** 0.5 as its factors\\n        D = {}\\n        for idx in B:\\n            if A[idx] not in D:\\n                D[A[idx]] = []\\n            D[A[idx]].append(idx)\\n        # print D\\n        for i in D:\\n            if len(D[i]) > 1:\\n                a = Findparent(D[i][0])\\n                for j in xrange(1,len(D[i])):\\n                    b = Findparent(D[i][j])\\n                    parent[b] = a\\n               \\n        # step 4: do the counting\\n        D = {}\\n        for i in xrange(len(parent)):\\n            a = Findparent(i)\\n            if a not in D:\\n                D[a] = 0\\n            D[a] += 1\\n        return max(D.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestComponentSize(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        parent = range(len(A))\\n        # Union Find\\n        def Findparent(i):\\n            if parent[i] != i:\\n                parent[i] = Findparent(parent[i])\\n            return parent[i]\\n\\n        # step 1: Sieve of Eratosthenes, only consider the prime number <= m ** 0.5 \\n        m = int(max(A) ** 0.5) + 1\\n        R = [1] * m\\n        prime = []\\n        for i in xrange(2, m):\\n            if R[i] == 1:\\n                prime.append(i)\\n            for j in xrange(i*i, m, i):\\n                R[j] = 0\\n        \\n        # step 2: check every prime number and do some prunes to narrow the search space\\n        B = range(len(A))\\n        for p in prime:\\n            tempB = []\\n            L = -1\\n            # print A, B, parent\\n            for idx in B:\\n                if A[idx] % p == 0:\\n                    if L == -1:\\n                        L = idx\\n                        a = Findparent(L)\\n                    else:\\n                        b = Findparent(idx)\\n                        parent[b] = a\\n                    while A[idx] % p == 0:\\n                        A[idx] /= p      \\n                if A[idx] > p:\\n                    tempB.append(idx)     \\n            B = tempB\\n        \\n        # step 3: deal with the number with primes > m ** 0.5 as its factors\\n        D = {}\\n        for idx in B:\\n            if A[idx] not in D:\\n                D[A[idx]] = []\\n            D[A[idx]].append(idx)\\n        # print D\\n        for i in D:\\n            if len(D[i]) > 1:\\n                a = Findparent(D[i][0])\\n                for j in xrange(1,len(D[i])):\\n                    b = Findparent(D[i][j])\\n                    parent[b] = a\\n               \\n        # step 4: do the counting\\n        D = {}\\n        for i in xrange(len(parent)):\\n            a = Findparent(i)\\n            if a not in D:\\n                D[a] = 0\\n            D[a] += 1\\n        return max(D.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200614,
                "title": "accepted-python-prime-factorization-union-find-optimization",
                "content": "The idea is that we only establish sets tagged by prime numbers.\\nAnd we combine these sets according to the factorization of numbers in list A.\\nSo we can largely reduce the number of elements in Union Find.\\n\\nFor example:\\n```\\nA = [3, 4, 5, 6, 12]\\n3 = 3\\n4 = 2*2\\n5 = 5\\n6 = 2*3\\n12 = 2*2*3\\n```\\n\\nAt the beginning, we have some empty sets tagged by prime numbers 2, 3, 5, etc:\\nSET(tag = 2) has 0 elements.\\nSET(tag = 3) has 0 elements.\\nSET(tag = 5) has 0 elements.\\n\\nThen we check every number in the list A.\\n3 has prime factors: 3, so SET(tag = 3) now has 1 element.\\n\\n4 has prime factors: 2, so SET(tag = 2) now has 1 element.\\n\\n5 has prime factors: 5, so SET(tag = 5) now has 1 element.\\n\\n6 has prime factors: 2 and 3, so SET(tag = 2) now has 2 element. And we combine SET(tag = 3) with SET(tag = 2). Now SET(tag =2) has 3 elements. SET(tag = 3) also has 3 elements. It is obvious because SET(tag =2) and SET(tag =3) are the same set now.\\n\\n12 has prime factors: 2 andd 3, so SET(tag = 2) now has 4 element. And we combine SET(tag = 3) with SET(tag = 2) if they are not combined before. In this case, they have been already combined. Also SET(tag = 3) has 4 elements since it represents the same set as SET(tag = 2) does.\\n\\nSET(tag = 2) has 4 elements.\\nSET(tag = 3) has 4 elements.\\nSET(tag = 5) has 1 elements.\\n\\nThe answer is 4.\\n\\nThe 9,592nd prime is 99,991. The 9,593rd prime is 100,003.\\nSo by my method, we will have at most 9592 elements in the Union Find.\\n\\n2^17 = 131072 > 100000 and 2^16 = 65536. So a number under 10^5 has at most 16 factors. Actually numbers under 10^5 has 2.66 different prime factors on average. For Union Find, if m operations, either Union or Find, are applied to n elements, the total run time is O(m log n), where log is the iterated logarithm. (https://en.wikipedia.org/wiki/Proof_of_O(log*n)_time_complexity_of_union%E2%80%93find)\\n\\nSo considering this problem, the worst time complexcity is O(N m log n) = O (20000*2.66 * log2 9592) = O(703709).\\n\\n\\n```\\nclass Solution(object):\\n    def largestComponentSize(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def prime(n):\\n            if n <= 1:\\n                return 0\\n            for i in range(2,int(math.sqrt(n)+1)):\\n                if n%i == 0:\\n                    return 0\\n            return 1\\n\\n        def find(x):\\n            if x != UF[x]:\\n                UF[x] = find(UF[x])\\n            return UF[x]\\n        \\n        def union(x, y):\\n            xx, yy = find(x), find(y)\\n            if xx != yy:\\n                sum_UF[xx] += sum_UF[yy]\\n                UF[yy] = xx\\n        \\n        m = max(int((max(A))**0.5)+2, 3)\\n        primes = []\\n        for i in range(2,m+1):\\n            if prime(i):\\n                primes.append(i)\\n                \\n        sum_UF = {}\\n        UF = {}\\n        \\n        for x in A:\\n            if x == 1:\\n                continue\\n            tmp = x\\n            prime_factors = []\\n            i = 0\\n            while (i < len(primes)) and (primes[i] <= tmp**0.5):\\n                if tmp % primes[i] == 0:\\n                    prime_factors.append(primes[i])\\n                    while tmp % primes[i] == 0:\\n                        tmp = tmp // primes[i]\\n                i += 1\\n            if tmp != 1:\\n                prime_factors.append(tmp)\\n            \\n            for p in prime_factors:\\n                if p not in UF:\\n                    UF[p] = p\\n                    sum_UF[p] = 0\\n            \\n            sum_UF[find(prime_factors[0])] += 1\\n            if len(prime_factors) > 1:\\n                for i in range(1,len(prime_factors),1):\\n                    union(prime_factors[0], prime_factors[i])\\n            \\n        ans = 1\\n        for x in sum_UF:\\n            ans = max(ans,sum_UF[x])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nA = [3, 4, 5, 6, 12]\\n3 = 3\\n4 = 2*2\\n5 = 5\\n6 = 2*3\\n12 = 2*2*3\\n```\n```\\nclass Solution(object):\\n    def largestComponentSize(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def prime(n):\\n            if n <= 1:\\n                return 0\\n            for i in range(2,int(math.sqrt(n)+1)):\\n                if n%i == 0:\\n                    return 0\\n            return 1\\n\\n        def find(x):\\n            if x != UF[x]:\\n                UF[x] = find(UF[x])\\n            return UF[x]\\n        \\n        def union(x, y):\\n            xx, yy = find(x), find(y)\\n            if xx != yy:\\n                sum_UF[xx] += sum_UF[yy]\\n                UF[yy] = xx\\n        \\n        m = max(int((max(A))**0.5)+2, 3)\\n        primes = []\\n        for i in range(2,m+1):\\n            if prime(i):\\n                primes.append(i)\\n                \\n        sum_UF = {}\\n        UF = {}\\n        \\n        for x in A:\\n            if x == 1:\\n                continue\\n            tmp = x\\n            prime_factors = []\\n            i = 0\\n            while (i < len(primes)) and (primes[i] <= tmp**0.5):\\n                if tmp % primes[i] == 0:\\n                    prime_factors.append(primes[i])\\n                    while tmp % primes[i] == 0:\\n                        tmp = tmp // primes[i]\\n                i += 1\\n            if tmp != 1:\\n                prime_factors.append(tmp)\\n            \\n            for p in prime_factors:\\n                if p not in UF:\\n                    UF[p] = p\\n                    sum_UF[p] = 0\\n            \\n            sum_UF[find(prime_factors[0])] += 1\\n            if len(prime_factors) > 1:\\n                for i in range(1,len(prime_factors),1):\\n                    union(prime_factors[0], prime_factors[i])\\n            \\n        ans = 1\\n        for x in sum_UF:\\n            ans = max(ans,sum_UF[x])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200613,
                "title": "c-sieve-of-erastosthenes-219ms-roughly-o-n-log-2-n",
                "content": "Solution runs on 219ms (maybe there is a little bit more room for improvement, like using rank on DSU).\\nTime complexity: O((n * log(log(n))) * ackermann function(|A|)). Where n is the max number in the array.\\nA rough analysis would be around O(n * log^2(n)), assuming the ackermann would result in around O(log n).\\nAlgorithm:\\nUse Sieve of Erastosthenes to generate all primes.\\nWhile doing this, for each number we are going to mark as non-prime number,\\nwe can also check if the number is in our initial array.\\nIf yes, merge them together.\\n```\\nclass Solution {\\npublic:\\n    int p[100100], sz[100100];\\n    \\n    int find(int x) {\\n        return x == p[x] ? x : p[x] = find(p[x]);\\n    }\\n    \\n    void merge(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        if(x == y) return;\\n        sz[x] += sz[y];\\n        p[y] = x;\\n    }\\n    \\n    int largestComponentSize(vector<int>& A) {\\n        bool mark[100100] = {0}, used[100100] = {0};\\n        for(int x : A) {\\n            mark[x] = 1;\\n            p[x] = x;\\n            sz[x] = 1;\\n        }\\n        // Sieve of erastosthenes\\n        for(long long i = 2; i <= 100000; i++) {\\n            if(!used[i]) {\\n                int last = -1;\\n                // i is a prime, union all numbers which has i as its factor.\\n                for(long long j = i; j <= 100000; j += i) {\\n                    used[j] = 1;\\n                    if(mark[j]) {\\n                        if(last != -1) merge(last, j);\\n                        last = j;\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int x : A) ans = max(ans, sz[x]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int p[100100], sz[100100];\\n    \\n    int find(int x) {\\n        return x == p[x] ? x : p[x] = find(p[x]);\\n    }\\n    \\n    void merge(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        if(x == y) return;\\n        sz[x] += sz[y];\\n        p[y] = x;\\n    }\\n    \\n    int largestComponentSize(vector<int>& A) {\\n        bool mark[100100] = {0}, used[100100] = {0};\\n        for(int x : A) {\\n            mark[x] = 1;\\n            p[x] = x;\\n            sz[x] = 1;\\n        }\\n        // Sieve of erastosthenes\\n        for(long long i = 2; i <= 100000; i++) {\\n            if(!used[i]) {\\n                int last = -1;\\n                // i is a prime, union all numbers which has i as its factor.\\n                for(long long j = i; j <= 100000; j += i) {\\n                    used[j] = 1;\\n                    if(mark[j]) {\\n                        if(last != -1) merge(last, j);\\n                        last = j;\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int x : A) ans = max(ans, sz[x]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200581,
                "title": "for-those-who-are-stuck-with-tle-even-though-unionfind-is-used",
                "content": "It\\'s easy to come up with unionfind (UF) as the solution. And there is good algorithm to generate all the prime numbers no bigger than n (denote as P(n)).\\n\\nHowever, a O(nP(n)) solution is still too slow. The tricky part is here: don\\'t waste time on trying prime number p on every A[i]. Consider how you calculate the prime numbers under n: choose a number 2, mark all its multiples as false (non-prime). Then you go to 3, and 5, ... (4 is skipped because it has been marked in the round of 2). Together the time complexity is A[i]max(1/2+1/3+1/5+...). This is smaller than the famous Harmonic series (https://en.wikipedia.org/wiki/Harmonic_series_(mathematics) which grows very slowly.\\n\\nSimilar idea can be used after we have our candidate prime numbers. We choose a prime number (say, 2) and find are the multiple of 2\\'s in the given array A. If so, union them together (Actually union all the index with the first i where A[i]%2==0). Then do the case of 3, 5, 7, .... By HashMap (with A[i] as key and i as value). every prime number (denote as p) needs A[i]max/p steps. And the total time complexity for the second half is O(A[i]max*(1/2+1/3+1/5+...). This should pass the test cases.\\n\\n```\\nint[] id,size;\\n    public int largestComponentSize(int[] A) {\\n        Arrays.sort(A);\\n        int n = A.length;\\n        id = new int[n];\\n        size = new int[n];\\n        for(int i=0;i<n;i++){\\n            id[i] = i;\\n            size[i] = 1;\\n        }\\n        int max = Math.max(10,A[A.length-1]);\\n\\t\\t\\n\\t\\t// find out all the prime numbers that are no bigger than A[i]_max\\n        boolean[] pri = new boolean[max+1];\\n        Arrays.fill(pri,true);\\n        ArrayList<Integer> prime = new ArrayList<>();\\n        for(int i=2;i<=max;i++){\\n            if(!pri[i]) continue;\\n            prime.add(i);\\n            for(int j=i;j<=max;j+=i) pri[j]=false;\\n        }\\n\\t\\t\\n        HashMap<Integer,Integer> node = new HashMap<>();\\n        for(int i=0;i<A.length;i++) node.put(A[i],i);\\n        for(int w:prime){\\n            int last = -1;\\n\\t\\t\\t// last >= 0 means that there is at least one A[i] that is a multiple of w. Union all other index with it\\n            for(int i=w;i<=A[n-1];i+=w){\\n                if(!node.containsKey(i)) continue;\\n                if(last<0) last = node.get(i);\\n                else{\\n                    union(last,node.get(i));\\n                }\\n            }\\n        }\\n        int ans = 1;\\n        for(int i=0;i<n;i++){\\n            ans = Math.max(ans,size[find(i)]);\\n        }\\n        return ans;\\n    }\\n    public int find(int p){\\n        while(p!=id[p]){\\n            id[p] = id[id[p]];\\n            p = id[p];\\n        }\\n        return id[p];\\n    }\\n    public void union(int p, int q){\\n        int i = find(p);\\n        int j = find(q);\\n        if(i==j) return;\\n        if(size[i]<size[j]){\\n            id[i]=j;\\n            size[j]+=size[i];\\n        }else{\\n            id[j]=i;\\n            size[i]+=size[j];\\n        }\\n    }\\n\\t```\\nSorry for the weird English I might have used. Please feel free to ask any question.\\n",
                "solutionTags": [],
                "code": "```\\nint[] id,size;\\n    public int largestComponentSize(int[] A) {\\n        Arrays.sort(A);\\n        int n = A.length;\\n        id = new int[n];\\n        size = new int[n];\\n        for(int i=0;i<n;i++){\\n            id[i] = i;\\n            size[i] = 1;\\n        }\\n        int max = Math.max(10,A[A.length-1]);\\n\\t\\t\\n\\t\\t// find out all the prime numbers that are no bigger than A[i]_max\\n        boolean[] pri = new boolean[max+1];\\n        Arrays.fill(pri,true);\\n        ArrayList<Integer> prime = new ArrayList<>();\\n        for(int i=2;i<=max;i++){\\n            if(!pri[i]) continue;\\n            prime.add(i);\\n            for(int j=i;j<=max;j+=i) pri[j]=false;\\n        }\\n\\t\\t\\n        HashMap<Integer,Integer> node = new HashMap<>();\\n        for(int i=0;i<A.length;i++) node.put(A[i],i);\\n        for(int w:prime){\\n            int last = -1;\\n\\t\\t\\t// last >= 0 means that there is at least one A[i] that is a multiple of w. Union all other index with it\\n            for(int i=w;i<=A[n-1];i+=w){\\n                if(!node.containsKey(i)) continue;\\n                if(last<0) last = node.get(i);\\n                else{\\n                    union(last,node.get(i));\\n                }\\n            }\\n        }\\n        int ans = 1;\\n        for(int i=0;i<n;i++){\\n            ans = Math.max(ans,size[find(i)]);\\n        }\\n        return ans;\\n    }\\n    public int find(int p){\\n        while(p!=id[p]){\\n            id[p] = id[id[p]];\\n            p = id[p];\\n        }\\n        return id[p];\\n    }\\n    public void union(int p, int q){\\n        int i = find(p);\\n        int j = find(q);\\n        if(i==j) return;\\n        if(size[i]<size[j]){\\n            id[i]=j;\\n            size[j]+=size[i];\\n        }else{\\n            id[j]=i;\\n            size[i]+=size[j];\\n        }\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3442124,
                "title": "union-find-c-soltuion-sieve-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> dsu,si;\\n    int find(int i)\\n    {\\n        if(i==dsu[i])return i;\\n        return dsu[i] = find(dsu[i]);\\n    }\\n    void f(int u ,int v)\\n    {\\n        int uu = find(u);\\n        int vv = find(v);\\n        if(uu==vv)return ;\\n        if(si[uu]<si[vv])\\n        {\\n            dsu[uu] = vv;\\n            si[vv]+=si[uu];\\n        }\\n        else \\n        {\\n            dsu[vv] = uu;\\n            si[uu]+=si[vv];\\n        }\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n      int n = nums.size(),x=0;\\n        dsu.resize(1e6);\\n        si.resize(1e6,1);\\n        for(int i=0;i<1e6;i++)\\n        {\\n            dsu[i] = i;\\n        }\\n        unordered_set<int>s;\\n        for(auto it:nums)\\n        {\\n          s.insert(it);\\n            x = max(x,it);\\n        }\\n        for(int i=2;i<=x;i++)\\n        {\\n            int last =-1;\\n            for(int j=i;j<=x;j+=i)\\n            {\\n                if(s.find(j)!=s.end())\\n                {\\n                    if(last==-1)last = j;\\n                else\\n                {\\n                    f(last,j);\\n                    last  = j;\\n                }\\n                }\\n               \\n            }\\n        }\\n        int res=0;\\n        for(auto it:si)\\n        {\\n          res = max(res,it);\\n        }\\n        return res;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dsu,si;\\n    int find(int i)\\n    {\\n        if(i==dsu[i])return i;\\n        return dsu[i] = find(dsu[i]);\\n    }\\n    void f(int u ,int v)\\n    {\\n        int uu = find(u);\\n        int vv = find(v);\\n        if(uu==vv)return ;\\n        if(si[uu]<si[vv])\\n        {\\n            dsu[uu] = vv;\\n            si[vv]+=si[uu];\\n        }\\n        else \\n        {\\n            dsu[vv] = uu;\\n            si[uu]+=si[vv];\\n        }\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n      int n = nums.size(),x=0;\\n        dsu.resize(1e6);\\n        si.resize(1e6,1);\\n        for(int i=0;i<1e6;i++)\\n        {\\n            dsu[i] = i;\\n        }\\n        unordered_set<int>s;\\n        for(auto it:nums)\\n        {\\n          s.insert(it);\\n            x = max(x,it);\\n        }\\n        for(int i=2;i<=x;i++)\\n        {\\n            int last =-1;\\n            for(int j=i;j<=x;j+=i)\\n            {\\n                if(s.find(j)!=s.end())\\n                {\\n                    if(last==-1)last = j;\\n                else\\n                {\\n                    f(last,j);\\n                    last  = j;\\n                }\\n                }\\n               \\n            }\\n        }\\n        int res=0;\\n        for(auto it:si)\\n        {\\n          res = max(res,it);\\n        }\\n        return res;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729366,
                "title": "connect-only-when-the-factor-is-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> p;\\n    vector<int> r;\\n    int gcd(int a , int b)\\n    {\\n          return b == 0 ? a : gcd(b, a % b);\\n    }\\n    \\n    int find(int k)\\n    {\\n        if(p[k] == k)\\n            return k;\\n        return p[k] = find(p[k]);\\n    }\\n    \\n    void unon(int a, int b)\\n    {\\n        int pa = find(a);\\n        int pb = find(b);\\n        if(pa == pb)\\n            return;\\n        if(r[pa]>r[pb]){\\n            p[pb] = pa;\\n            r[pa]+=r[pb];\\n        }\\n        else{\\n            p[pa] = pb;\\n            r[pb]+=r[pa];\\n        }\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int ii = 0;\\n        p.resize(100002);\\n        r.resize(100002);\\n        for(int i=0;i<100002;i++)\\n        {\\n            p[i] = i;\\n            r[i] = 1;\\n        }\\n        \\n        \\n        \\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n            for(int j=2;j<=sqrt(nums[i]);j++)\\n            {\\n                if(nums[i]%j==0)\\n                {\\n                    unon(nums[i],j);\\n                    unon(nums[i],nums[i]/j);\\n                }\\n            }\\n        \\n        \\n        unordered_map<int, int> mp;\\n        for(auto i: nums)\\n        {\\n            int y = find(i);\\n            mp[y]++;\\n        }\\n        int res = 0;\\n        for(auto i: mp)\\n        {\\n            res = max(res,i.second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> p;\\n    vector<int> r;\\n    int gcd(int a , int b)\\n    {\\n          return b == 0 ? a : gcd(b, a % b);\\n    }\\n    \\n    int find(int k)\\n    {\\n        if(p[k] == k)\\n            return k;\\n        return p[k] = find(p[k]);\\n    }\\n    \\n    void unon(int a, int b)\\n    {\\n        int pa = find(a);\\n        int pb = find(b);\\n        if(pa == pb)\\n            return;\\n        if(r[pa]>r[pb]){\\n            p[pb] = pa;\\n            r[pa]+=r[pb];\\n        }\\n        else{\\n            p[pa] = pb;\\n            r[pb]+=r[pa];\\n        }\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int ii = 0;\\n        p.resize(100002);\\n        r.resize(100002);\\n        for(int i=0;i<100002;i++)\\n        {\\n            p[i] = i;\\n            r[i] = 1;\\n        }\\n        \\n        \\n        \\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n            for(int j=2;j<=sqrt(nums[i]);j++)\\n            {\\n                if(nums[i]%j==0)\\n                {\\n                    unon(nums[i],j);\\n                    unon(nums[i],nums[i]/j);\\n                }\\n            }\\n        \\n        \\n        unordered_map<int, int> mp;\\n        for(auto i: nums)\\n        {\\n            int y = find(i);\\n            mp[y]++;\\n        }\\n        int res = 0;\\n        for(auto i: mp)\\n        {\\n            res = max(res,i.second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099232,
                "title": "java-solution-with-unionfind",
                "content": "```\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n\\n        int maxValue = Arrays.stream(A).reduce(A[0], (x, y) -> x > y ? x : y);\\n        \\n        UnionFind uf = new UnionFind(maxValue + 1);\\n        \\n        // Attribute each element to all the groups that lead by its factors.\\n        for (int num : A) {\\n            for (int factor = 2; factor < (int)(Math.sqrt(num)) + 1; ++factor)\\n                if (num % factor == 0) {\\n                    uf.union(num, factor);\\n                    uf.union(num, num / factor);\\n                }\\n        }\\n\\n        int maxGroupSize = 0;\\n        HashMap<Integer, Integer> groupCount = new HashMap<>();\\n        for (int num : A) {\\n            Integer groupId = uf.find(num);\\n            Integer count = groupCount.getOrDefault(groupId, 0);\\n            groupCount.put(groupId, count+1);\\n            maxGroupSize = Math.max(maxGroupSize, count+1);\\n        }\\n\\n        return maxGroupSize;\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] parents;\\n    int[] ranks;\\n\\n    public UnionFind(int n) {\\n        this.parents = new int[n];\\n        this.ranks = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            this.parents[i] = i;\\n            this.ranks[i] = 1;\\n        }\\n    }\\n\\n    public int find(int x) {\\n        if (parents[x] != x) parents[x] = find(parents[x]);\\n\\n        return parents[x];\\n    }\\n\\n    public void union(int x, int y) {\\n        int xRoot = find(x);\\n        int yRoot = find(y);\\n\\n        if (xRoot == yRoot) return;\\n\\n        if (ranks[xRoot] < ranks[yRoot]) {\\n            parents[xRoot] = yRoot;\\n        } else {\\n            parents[yRoot] = xRoot;\\n        }\\n\\n        if (ranks[xRoot] == ranks[yRoot]) {\\n            ranks[xRoot]++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n\\n        int maxValue = Arrays.stream(A).reduce(A[0], (x, y) -> x > y ? x : y);\\n        \\n        UnionFind uf = new UnionFind(maxValue + 1);\\n        \\n        // Attribute each element to all the groups that lead by its factors.\\n        for (int num : A) {\\n            for (int factor = 2; factor < (int)(Math.sqrt(num)) + 1; ++factor)\\n                if (num % factor == 0) {\\n                    uf.union(num, factor);\\n                    uf.union(num, num / factor);\\n                }\\n        }\\n\\n        int maxGroupSize = 0;\\n        HashMap<Integer, Integer> groupCount = new HashMap<>();\\n        for (int num : A) {\\n            Integer groupId = uf.find(num);\\n            Integer count = groupCount.getOrDefault(groupId, 0);\\n            groupCount.put(groupId, count+1);\\n            maxGroupSize = Math.max(maxGroupSize, count+1);\\n        }\\n\\n        return maxGroupSize;\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] parents;\\n    int[] ranks;\\n\\n    public UnionFind(int n) {\\n        this.parents = new int[n];\\n        this.ranks = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            this.parents[i] = i;\\n            this.ranks[i] = 1;\\n        }\\n    }\\n\\n    public int find(int x) {\\n        if (parents[x] != x) parents[x] = find(parents[x]);\\n\\n        return parents[x];\\n    }\\n\\n    public void union(int x, int y) {\\n        int xRoot = find(x);\\n        int yRoot = find(y);\\n\\n        if (xRoot == yRoot) return;\\n\\n        if (ranks[xRoot] < ranks[yRoot]) {\\n            parents[xRoot] = yRoot;\\n        } else {\\n            parents[yRoot] = xRoot;\\n        }\\n\\n        if (ranks[xRoot] == ranks[yRoot]) {\\n            ranks[xRoot]++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097394,
                "title": "c-o-nlogn-solution-using-dfs-and-sieve-of-eratosthenes-easy-to-understand",
                "content": "In this approach, I\\'m using Sieve of Eratosthenes to compute all the prime numbers till 10^5 and then store them in an array `primelist`. Then, I can compute unique prime factors for each number in LogN using the `factors()` function. \\n\\nFor every unique prime factor of nums[i], if a previous number in the array had the same prime factor (hashmap `m` is used to store this information), then this number is connected to that node (Just that node is sufficient. No need to connect to all previous nodes that had this prime factor because we only to need to calculate the component size and hence all the connections need not to be made. If we try to connect all the edges, then the number of edges can be n^2 which is not at all feasible because n <= 10^4). if none of the previous numbers had the same prime factor, then this index is stored for that particular prime factor in the hashmap `m`.\\n\\nThe maximum number of unique prime factors that a number <= 10^5 is 6. So, the maximum number of edges in the graph is n * 6 which is feasible. \\n\\nNow, we can just run a simple DFS to calculate the maximum component size in the graph.\\n\\n```\\nclass Solution {\\nprivate:\\n    vector<bool> sieve(int n) {\\n        vector<bool> prime(n + 1);\\n        for (int i = 0; i <= n; i++)\\n            prime[i] = 1;\\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == 1) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = 0;\\n            }\\n        }\\n        prime[1] = prime[0] = 0;\\n        return prime;\\n    }\\n    vector<int> factors(int n, vector<int> &primelist) {\\n        vector<int> facs;\\n        for (int i = 0; primelist[i] * primelist[i] <= n && i < primelist.size(); i++) {\\n            if (n % primelist[i] == 0) {\\n                facs.push_back(primelist[i]);\\n                while (n % primelist[i] == 0) {\\n                    n /= primelist[i];\\n                }\\n            }\\n        }\\n        if (n > 1) facs.push_back(n);\\n        return facs;\\n    }\\n    void dfs(vector<vector<int>> &gr, int node, vector<int> &vis, int &compSize) {\\n        if(vis[node]) return;\\n        vis[node] = 1;\\n        compSize++;\\n        for(auto x : gr[node]) {\\n            dfs(gr, x, vis, compSize);\\n        }\\n    }\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> gr(n);\\n        vector<bool> prime = sieve(1e5 + 6);\\n        vector<int> primelist;\\n\\t\\t// Getting all the primes till 10^5 as maximum value of nums[i] is 10^5\\n        for (int i = 2; i <= 1e5 + 5; i++) if (prime[i]) primelist.push_back(i);\\n        unordered_map<int, int> m; // to store the index of the node with prime factor x\\n        for(int i = 0; i < n; i++) {\\n            vector<int> facs = factors(nums[i], primelist);\\n            for(auto j : facs) {\\n                if(m.find(j) == m.end()) { // prime factor had not occured before\\n                    m[j] = i; // j is the prime factor and its index is i\\n                } else {\\n\\t\\t\\t\\t    // prime factor has already been seen before in a previous number and nums[i] is connected to that number\\n                    gr[i].push_back(m[j]);\\n                    gr[m[j]].push_back(i);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        vector<int> vis(n);\\n        for(int i = 0; i < n; i++) { // running a simple dfs to calculate the maximum component size\\n            if(!vis[i]) {\\n                int compSize = 0;\\n                dfs(gr, i, vis, compSize);\\n                ans = max(ans, compSize);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<bool> sieve(int n) {\\n        vector<bool> prime(n + 1);\\n        for (int i = 0; i <= n; i++)\\n            prime[i] = 1;\\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == 1) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = 0;\\n            }\\n        }\\n        prime[1] = prime[0] = 0;\\n        return prime;\\n    }\\n    vector<int> factors(int n, vector<int> &primelist) {\\n        vector<int> facs;\\n        for (int i = 0; primelist[i] * primelist[i] <= n && i < primelist.size(); i++) {\\n            if (n % primelist[i] == 0) {\\n                facs.push_back(primelist[i]);\\n                while (n % primelist[i] == 0) {\\n                    n /= primelist[i];\\n                }\\n            }\\n        }\\n        if (n > 1) facs.push_back(n);\\n        return facs;\\n    }\\n    void dfs(vector<vector<int>> &gr, int node, vector<int> &vis, int &compSize) {\\n        if(vis[node]) return;\\n        vis[node] = 1;\\n        compSize++;\\n        for(auto x : gr[node]) {\\n            dfs(gr, x, vis, compSize);\\n        }\\n    }\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> gr(n);\\n        vector<bool> prime = sieve(1e5 + 6);\\n        vector<int> primelist;\\n\\t\\t// Getting all the primes till 10^5 as maximum value of nums[i] is 10^5\\n        for (int i = 2; i <= 1e5 + 5; i++) if (prime[i]) primelist.push_back(i);\\n        unordered_map<int, int> m; // to store the index of the node with prime factor x\\n        for(int i = 0; i < n; i++) {\\n            vector<int> facs = factors(nums[i], primelist);\\n            for(auto j : facs) {\\n                if(m.find(j) == m.end()) { // prime factor had not occured before\\n                    m[j] = i; // j is the prime factor and its index is i\\n                } else {\\n\\t\\t\\t\\t    // prime factor has already been seen before in a previous number and nums[i] is connected to that number\\n                    gr[i].push_back(m[j]);\\n                    gr[m[j]].push_back(i);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        vector<int> vis(n);\\n        for(int i = 0; i < n; i++) { // running a simple dfs to calculate the maximum component size\\n            if(!vis[i]) {\\n                int compSize = 0;\\n                dfs(gr, i, vis, compSize);\\n                ans = max(ans, compSize);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078280,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Union Find***\\n\\n* ***Time Complexity : O(N * sqrt(N))***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> parent;\\n    \\n    vector<int> rank;\\n    \\n    int find(int x)\\n    {\\n        if(parent[x] == x)\\n        {\\n            return x;\\n        }\\n        \\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    void _union(int x, int y)\\n    {\\n        int x_par = find(x);\\n        \\n        int y_par = find(y);\\n        \\n        if(x_par == y_par)\\n        {\\n            return;\\n        }\\n        if(rank[x_par] > rank[y_par])\\n        {\\n            parent[y_par] = x_par;\\n        }\\n        else if(rank[x_par] < rank[y_par])\\n        {\\n            parent[x_par] = y_par;\\n        }\\n        else\\n        {\\n            parent[y_par] = x_par;\\n            \\n            rank[x_par]++;\\n        }\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int size = *max_element(nums.begin(), nums.end());\\n        \\n        parent.resize(size + 1);\\n        \\n        rank.resize(size + 1);\\n        \\n        for(int i = 0; i <= size; i++)\\n        {\\n            parent[i] = i;\\n            \\n            rank[i] = 1;\\n        }\\n        \\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 2; j <= sqrt(nums[i]); j++)\\n            {\\n                if(nums[i] % j == 0)\\n                {\\n                    _union(nums[i], j);\\n                    \\n                    _union(nums[i], nums[i] / j);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int, int> mp;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int x_par = find(nums[i]);\\n            \\n            mp[x_par]++;\\n            \\n            maxi = max(maxi, mp[x_par]);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> parent;\\n    \\n    vector<int> rank;\\n    \\n    int find(int x)\\n    {\\n        if(parent[x] == x)\\n        {\\n            return x;\\n        }\\n        \\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    void _union(int x, int y)\\n    {\\n        int x_par = find(x);\\n        \\n        int y_par = find(y);\\n        \\n        if(x_par == y_par)\\n        {\\n            return;\\n        }\\n        if(rank[x_par] > rank[y_par])\\n        {\\n            parent[y_par] = x_par;\\n        }\\n        else if(rank[x_par] < rank[y_par])\\n        {\\n            parent[x_par] = y_par;\\n        }\\n        else\\n        {\\n            parent[y_par] = x_par;\\n            \\n            rank[x_par]++;\\n        }\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int size = *max_element(nums.begin(), nums.end());\\n        \\n        parent.resize(size + 1);\\n        \\n        rank.resize(size + 1);\\n        \\n        for(int i = 0; i <= size; i++)\\n        {\\n            parent[i] = i;\\n            \\n            rank[i] = 1;\\n        }\\n        \\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 2; j <= sqrt(nums[i]); j++)\\n            {\\n                if(nums[i] % j == 0)\\n                {\\n                    _union(nums[i], j);\\n                    \\n                    _union(nums[i], nums[i] / j);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int, int> mp;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int x_par = find(nums[i]);\\n            \\n            mp[x_par]++;\\n            \\n            maxi = max(maxi, mp[x_par]);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905677,
                "title": "python-sol-union-find-explained",
                "content": "# EXPLANATION\\n```\\nUnion and Find is must !!\\nOne way is to find GCD of every pair and if GCD > 1 means they have an edge so do union \\nBut this method will give TLE \\n\\nNow a better solution is by using factors\\nFactors of 21 are : 3 , 7 \\nFactors of 63 are : 3 , 7 , 9 , 21\\n\\nSo for 21 we have a child 3 and 7\\nFor 63 we have child 3 \\nBut 3\\'s parent is 21 so 21 and 63 will be joined\\n```\\n\\n# CODE\\n```\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        \\n        def find(node):\\n            if parent[node] == -1: return node\\n            else:\\n                parent[node] = find(parent[node])\\n                return parent[node]\\n        \\n        def union(idx1,idx2):\\n            par1,par2 = find(idx1),find(idx2)\\n            if par1!=par2:\\n                if rank[par1] > rank[par2]:\\n                    parent[par2] = par1\\n                elif rank[par2] > rank[par1]:\\n                    parent[par1] = par2\\n                else:\\n                    parent[par2] = par1\\n                    rank[par1] += 1\\n        \\n        n = len(nums)\\n        parent = defaultdict(lambda:-1)\\n        rank = defaultdict(lambda:0)\\n        for i in range(n):\\n            limit = int(nums[i]**0.5)\\n            for j in range(2,limit+1):\\n                if nums[i] % j == 0:\\n                    union(nums[i],j)\\n                    union(nums[i],nums[i]//j)\\n        count = defaultdict(lambda:0)\\n        best = -1\\n        for num in nums:\\n            par = find(num)\\n            tmp = count[par] + 1\\n            if tmp > best: best = tmp\\n            count[par] = tmp\\n        return best\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nUnion and Find is must !!\\nOne way is to find GCD of every pair and if GCD > 1 means they have an edge so do union \\nBut this method will give TLE \\n\\nNow a better solution is by using factors\\nFactors of 21 are : 3 , 7 \\nFactors of 63 are : 3 , 7 , 9 , 21\\n\\nSo for 21 we have a child 3 and 7\\nFor 63 we have child 3 \\nBut 3\\'s parent is 21 so 21 and 63 will be joined\\n```\n```\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        \\n        def find(node):\\n            if parent[node] == -1: return node\\n            else:\\n                parent[node] = find(parent[node])\\n                return parent[node]\\n        \\n        def union(idx1,idx2):\\n            par1,par2 = find(idx1),find(idx2)\\n            if par1!=par2:\\n                if rank[par1] > rank[par2]:\\n                    parent[par2] = par1\\n                elif rank[par2] > rank[par1]:\\n                    parent[par1] = par2\\n                else:\\n                    parent[par2] = par1\\n                    rank[par1] += 1\\n        \\n        n = len(nums)\\n        parent = defaultdict(lambda:-1)\\n        rank = defaultdict(lambda:0)\\n        for i in range(n):\\n            limit = int(nums[i]**0.5)\\n            for j in range(2,limit+1):\\n                if nums[i] % j == 0:\\n                    union(nums[i],j)\\n                    union(nums[i],nums[i]//j)\\n        count = defaultdict(lambda:0)\\n        best = -1\\n        for num in nums:\\n            par = find(num)\\n            tmp = count[par] + 1\\n            if tmp > best: best = tmp\\n            count[par] = tmp\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796746,
                "title": "union-find-algorithm-o-nlogn-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int parent[100001];\\n    int rank[100001];\\n    \\n    int findparent(int node){\\n        if(parent[node]==node){\\n            return node;\\n        }\\n        \\n        return parent[node]=findparent(parent[node]);\\n    }\\n    \\n    void unionp(int x,int y){\\n        x=findparent(x);\\n        y=findparent(y);\\n        if(x==y){\\n            return;\\n        }\\n        if(rank[x]>rank[y]){\\n               parent[y]=x;\\n        }else if(rank[x]<rank[y]){\\n               parent[x]=y;\\n           \\n        }else{\\n               parent[x]=y;\\n               rank[y]++;\\n           \\n        }\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        for(int i=0;i<100001;i++){\\n            rank[i]=0;\\n            parent[i]=i;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=2;j<=sqrt(nums[i]);j++){\\n                if(nums[i]%j==0){\\n                    unionp(nums[i],j);\\n                    unionp(nums[i],nums[i]/j);\\n                }\\n            }\\n        }\\n        int maxsize=0;\\n        map<int,int> m;\\n        for(int i=0;i<nums.size();i++){\\n           int x=findparent(nums[i]);\\n            m[x]++;\\n            if(maxsize<m[x]){\\n                maxsize=m[x];\\n            }\\n           \\n        }\\n        return maxsize;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int parent[100001];\\n    int rank[100001];\\n    \\n    int findparent(int node){\\n        if(parent[node]==node){\\n            return node;\\n        }\\n        \\n        return parent[node]=findparent(parent[node]);\\n    }\\n    \\n    void unionp(int x,int y){\\n        x=findparent(x);\\n        y=findparent(y);\\n        if(x==y){\\n            return;\\n        }\\n        if(rank[x]>rank[y]){\\n               parent[y]=x;\\n        }else if(rank[x]<rank[y]){\\n               parent[x]=y;\\n           \\n        }else{\\n               parent[x]=y;\\n               rank[y]++;\\n           \\n        }\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        for(int i=0;i<100001;i++){\\n            rank[i]=0;\\n            parent[i]=i;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=2;j<=sqrt(nums[i]);j++){\\n                if(nums[i]%j==0){\\n                    unionp(nums[i],j);\\n                    unionp(nums[i],nums[i]/j);\\n                }\\n            }\\n        }\\n        int maxsize=0;\\n        map<int,int> m;\\n        for(int i=0;i<nums.size();i++){\\n           int x=findparent(nums[i]);\\n            m[x]++;\\n            if(maxsize<m[x]){\\n                maxsize=m[x];\\n            }\\n           \\n        }\\n        return maxsize;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598090,
                "title": "java-using-union-find-o-n-sqrt-m",
                "content": "```\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n        int max = 0;\\n        for(int a : A) {\\n            max = Math.max(max, a);\\n        }\\n        \\n        int[] roots = new int[max + 1],sizes = new int[max + 1];\\n        for(int idx = 1; idx <= max; idx++){\\n            roots[idx] = idx;\\n        }\\n        \\n        for(int a : A){\\n            if(a == 1){\\n                sizes[a] = 1;\\n                continue;\\n            }\\n            \\n            int sqrt = (int) Math.sqrt(a);\\n            int thisRoot = getRoot(roots, a);\\n            sizes[thisRoot]++;\\n            \\n            for(int factor = 1; factor <= sqrt; factor++){\\n                if(a % factor == 0){\\n                    int otherFactor = a / factor;\\n                    int factorRoot = getRoot(roots, factor);\\n                    int otherFactorRoot = getRoot(roots, otherFactor);\\n                    \\n                    if(factor != 1){\\n                        union(roots, thisRoot, factor, sizes);\\n                    }\\n                    union(roots, thisRoot, otherFactorRoot, sizes);\\n                }\\n            }\\n        }\\n        \\n        int maxConnection = 0;\\n        for(int size : sizes){\\n            maxConnection = Math.max(maxConnection, size);\\n        }\\n        \\n        return maxConnection;\\n    }\\n    \\n    public void union(int[] roots, int a, int b, int[] sizes){\\n        int rootA = getRoot(roots, a);\\n        int rootB = getRoot(roots, b);\\n        if(rootA != rootB){    \\n            sizes[rootA] += sizes[rootB];\\n            roots[rootB] = rootA;\\n        }\\n    }\\n    \\n    public int getRoot(int[] roots, int a){\\n        if(roots[a] == a){\\n            return a;\\n        }\\n        return roots[a] = getRoot(roots, roots[a]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n        int max = 0;\\n        for(int a : A) {\\n            max = Math.max(max, a);\\n        }\\n        \\n        int[] roots = new int[max + 1],sizes = new int[max + 1];\\n        for(int idx = 1; idx <= max; idx++){\\n            roots[idx] = idx;\\n        }\\n        \\n        for(int a : A){\\n            if(a == 1){\\n                sizes[a] = 1;\\n                continue;\\n            }\\n            \\n            int sqrt = (int) Math.sqrt(a);\\n            int thisRoot = getRoot(roots, a);\\n            sizes[thisRoot]++;\\n            \\n            for(int factor = 1; factor <= sqrt; factor++){\\n                if(a % factor == 0){\\n                    int otherFactor = a / factor;\\n                    int factorRoot = getRoot(roots, factor);\\n                    int otherFactorRoot = getRoot(roots, otherFactor);\\n                    \\n                    if(factor != 1){\\n                        union(roots, thisRoot, factor, sizes);\\n                    }\\n                    union(roots, thisRoot, otherFactorRoot, sizes);\\n                }\\n            }\\n        }\\n        \\n        int maxConnection = 0;\\n        for(int size : sizes){\\n            maxConnection = Math.max(maxConnection, size);\\n        }\\n        \\n        return maxConnection;\\n    }\\n    \\n    public void union(int[] roots, int a, int b, int[] sizes){\\n        int rootA = getRoot(roots, a);\\n        int rootB = getRoot(roots, b);\\n        if(rootA != rootB){    \\n            sizes[rootA] += sizes[rootB];\\n            roots[rootB] = rootA;\\n        }\\n    }\\n    \\n    public int getRoot(int[] roots, int a){\\n        if(roots[a] == a){\\n            return a;\\n        }\\n        return roots[a] = getRoot(roots, roots[a]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596937,
                "title": "python-solution-o-n-sqrt-max-nums-time-o-max-nums-space-union-find-faster-than-31",
                "content": "\\t# Union Find Set  \\n\\tclass UnionFindSet: \\n\\t\\tdef __init__(self, n): \\n\\t\\t\\tself.parents = [i for i in range(n+1)]\\n\\t\\t\\tself.ranks = [1 for _ in range(n+1)]\\n\\n\\t\\tdef find(self, u): \\n\\t\\t\\twhile u != self.parents[u]: \\n\\t\\t\\t\\tself.parents[u] = self.parents[self.parents[u]]\\n\\t\\t\\t\\tu = self.parents[u]\\n\\t\\t\\treturn u\\n\\n\\t\\tdef union(self, u, v): \\n\\t\\t\\tu_parent = self.find(u)\\n\\t\\t\\tv_parent = self.find(v)\\n\\t\\t\\tif u_parent == v_parent: \\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tif self.ranks[u_parent] > self.ranks[v_parent]:   \\n\\t\\t\\t\\tself.parents[v_parent] = u_parent\\n\\t\\t\\telif self.ranks[u_parent] < self.ranks[v_parent]: \\n\\t\\t\\t\\tself.parents[u_parent] = v_parent\\n\\t\\t\\telif self.ranks[u_parent] == self.ranks[v_parent]: \\n\\t\\t\\t\\tself.parents[v_parent] = u_parent\\n\\t\\t\\t\\tself.ranks[u_parent] += 1\\n\\t\\t\\treturn True    \\n\\n\\n\\tclass Solution(object):\\n\\t\\tdef largestComponentSize(self, nums):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type nums: List[int]\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tmax_num = max(nums)\\n\\t\\t\\tunion_find_set = UnionFindSet(max_num+1)\\n\\n\\t\\t\\tfor num in nums: \\n\\t\\t\\t\\tsqrt_num = int(num**(1/2.0))+1\\n\\t\\t\\t\\tfor i in range(2, sqrt_num): \\n\\t\\t\\t\\t\\tif num%i==0: \\n\\t\\t\\t\\t\\t\\tunion_find_set.union(num, i) \\n\\t\\t\\t\\t\\t\\tunion_find_set.union(num, num/i)\\n\\n\\t\\t\\tfrom collections import defaultdict\\n\\t\\t\\tres = defaultdict(int)            \\n\\t\\t\\tfor num in nums: \\n\\t\\t\\t\\tres[union_find_set.find(num)] += 1\\n\\t\\t\\t# print(res.values())    \\n\\t\\t\\treturn max(res.values())\\n\\n",
                "solutionTags": [],
                "code": "\\t# Union Find Set  \\n\\tclass UnionFindSet: \\n\\t\\tdef __init__(self, n): \\n\\t\\t\\tself.parents = [i for i in range(n+1)]\\n\\t\\t\\tself.ranks = [1 for _ in range(n+1)]\\n\\n\\t\\tdef find(self, u): \\n\\t\\t\\twhile u != self.parents[u]: \\n\\t\\t\\t\\tself.parents[u] = self.parents[self.parents[u]]\\n\\t\\t\\t\\tu = self.parents[u]\\n\\t\\t\\treturn u\\n\\n\\t\\tdef union(self, u, v): \\n\\t\\t\\tu_parent = self.find(u)\\n\\t\\t\\tv_parent = self.find(v)\\n\\t\\t\\tif u_parent == v_parent: \\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tif self.ranks[u_parent] > self.ranks[v_parent]:   \\n\\t\\t\\t\\tself.parents[v_parent] = u_parent\\n\\t\\t\\telif self.ranks[u_parent] < self.ranks[v_parent]: \\n\\t\\t\\t\\tself.parents[u_parent] = v_parent\\n\\t\\t\\telif self.ranks[u_parent] == self.ranks[v_parent]: \\n\\t\\t\\t\\tself.parents[v_parent] = u_parent\\n\\t\\t\\t\\tself.ranks[u_parent] += 1\\n\\t\\t\\treturn True    \\n\\n\\n\\tclass Solution(object):\\n\\t\\tdef largestComponentSize(self, nums):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type nums: List[int]\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tmax_num = max(nums)\\n\\t\\t\\tunion_find_set = UnionFindSet(max_num+1)\\n\\n\\t\\t\\tfor num in nums: \\n\\t\\t\\t\\tsqrt_num = int(num**(1/2.0))+1\\n\\t\\t\\t\\tfor i in range(2, sqrt_num): \\n\\t\\t\\t\\t\\tif num%i==0: \\n\\t\\t\\t\\t\\t\\tunion_find_set.union(num, i) \\n\\t\\t\\t\\t\\t\\tunion_find_set.union(num, num/i)\\n\\n\\t\\t\\tfrom collections import defaultdict\\n\\t\\t\\tres = defaultdict(int)            \\n\\t\\t\\tfor num in nums: \\n\\t\\t\\t\\tres[union_find_set.find(num)] += 1\\n\\t\\t\\t# print(res.values())    \\n\\t\\t\\treturn max(res.values())\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1593363,
                "title": "python-union-find-simple-solution",
                "content": "```\\nimport math\\n\\n\\nclass DisjointSet:\\n    def __init__(self, vertices):\\n        self.parent = {}\\n        self.rank = {}\\n        for vertex in range(len(vertices)):\\n            self.parent[vertex] = vertex\\n            self.rank[vertex] = 0\\n\\n    def find(self, u):\\n        if self.parent[u] != u:\\n            self.parent[u] = self.find(self.parent[u])\\n        return self.parent[u]\\n\\n    def union(self, u, v):\\n        x = self.find(u)\\n        y = self.find(v)\\n        if x != y:\\n            if self.rank[x] > self.rank[y]:\\n                self.parent[y] = x\\n            elif self.rank[y] > self.rank[x]:\\n                self.parent[x] = y\\n            else:\\n                self.parent[y] = x\\n                self.rank[x] += 1\\n        \\n        \\nclass Solution:\\n    def getPrimesFactors(self, num):\\n        for i in range(2, int(math.sqrt(num))+1):\\n            if num % i == 0:\\n                return self.getPrimesFactors(num//i) | {i}\\n        return {num}\\n\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        primeFactors = {}\\n        for index, num in enumerate(nums):\\n            for prime in self.getPrimesFactors(num):\\n                if prime in primeFactors:\\n                    primeFactors[prime].append(index)\\n                else:\\n                    primeFactors[prime] = [index]\\n\\n        djs = DisjointSet(nums)\\n        for indexes in primeFactors.values():\\n            for index in range(len(indexes) - 1):\\n                djs.union(indexes[index], indexes[index + 1])\\n\\n        longestConnectedComponentLength = 1\\n        components = {}\\n        for index in range(len(nums)):\\n            x = djs.find(index)\\n            if x in components:\\n                components[x] += 1\\n                longestConnectedComponentLength = max(longestConnectedComponentLength, components[x])\\n            else:\\n                components[x] = 1\\n\\n        return longestConnectedComponentLength\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nimport math\\n\\n\\nclass DisjointSet:\\n    def __init__(self, vertices):\\n        self.parent = {}\\n        self.rank = {}\\n        for vertex in range(len(vertices)):\\n            self.parent[vertex] = vertex\\n            self.rank[vertex] = 0\\n\\n    def find(self, u):\\n        if self.parent[u] != u:\\n            self.parent[u] = self.find(self.parent[u])\\n        return self.parent[u]\\n\\n    def union(self, u, v):\\n        x = self.find(u)\\n        y = self.find(v)\\n        if x != y:\\n            if self.rank[x] > self.rank[y]:\\n                self.parent[y] = x\\n            elif self.rank[y] > self.rank[x]:\\n                self.parent[x] = y\\n            else:\\n                self.parent[y] = x\\n                self.rank[x] += 1\\n        \\n        \\nclass Solution:\\n    def getPrimesFactors(self, num):\\n        for i in range(2, int(math.sqrt(num))+1):\\n            if num % i == 0:\\n                return self.getPrimesFactors(num//i) | {i}\\n        return {num}\\n\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        primeFactors = {}\\n        for index, num in enumerate(nums):\\n            for prime in self.getPrimesFactors(num):\\n                if prime in primeFactors:\\n                    primeFactors[prime].append(index)\\n                else:\\n                    primeFactors[prime] = [index]\\n\\n        djs = DisjointSet(nums)\\n        for indexes in primeFactors.values():\\n            for index in range(len(indexes) - 1):\\n                djs.union(indexes[index], indexes[index + 1])\\n\\n        longestConnectedComponentLength = 1\\n        components = {}\\n        for index in range(len(nums)):\\n            x = djs.find(index)\\n            if x in components:\\n                components[x] += 1\\n                longestConnectedComponentLength = max(longestConnectedComponentLength, components[x])\\n            else:\\n                components[x] = 1\\n\\n        return longestConnectedComponentLength\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593214,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    \\n    \\n    public int  find(int x,int ds[]){\\n        if(ds[x]==0)\\n            return x;\\n        return find(ds[x],ds);\\n    }\\n    \\n    \\n    \\n    public int largestComponentSize(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        for(int i:nums)\\n            max=Math.max(max,i);\\n          int ds[]=new int[max+1];\\n          int size[]=new int[max+1];\\n        Arrays.fill(size,1);\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int curr=nums[i];\\n            for(int j=2;j<=Math.sqrt(curr);j++){\\n                if(curr%j==0){\\n                    int x=find(curr,ds);\\n                    int y=find(j,ds);\\n                    if(x!=y){\\n                        if(size[x]>size[y])\\n                        {\\n                            ds[y]=x;\\n                            size[x]+=size[y];\\n                        }\\n                        else{\\n                            ds[x]=y;\\n                            size[y]+=size[x];\\n                            x=y;\\n                        }\\n                        \\n                        \\n                        \\n                    }\\n                    y=find(curr/j,ds);\\n                    if(x!=y){\\n                        if(size[x]>size[y]){\\n                        ds[y]=x;\\n                        size[x]+=size[y];\\n                        }\\n                        else{\\n                            ds[x]=y;\\n                            size[y]+=size[x];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int count[]=new int[max+1];\\n        int res=1;\\n        for(int i=0;i<nums.length;i++){\\n           res=Math.max(++count[find(nums[i],ds)],res);\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    \\n    public int  find(int x,int ds[]){\\n        if(ds[x]==0)\\n            return x;\\n        return find(ds[x],ds);\\n    }\\n    \\n    \\n    \\n    public int largestComponentSize(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        for(int i:nums)\\n            max=Math.max(max,i);\\n          int ds[]=new int[max+1];\\n          int size[]=new int[max+1];\\n        Arrays.fill(size,1);\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int curr=nums[i];\\n            for(int j=2;j<=Math.sqrt(curr);j++){\\n                if(curr%j==0){\\n                    int x=find(curr,ds);\\n                    int y=find(j,ds);\\n                    if(x!=y){\\n                        if(size[x]>size[y])\\n                        {\\n                            ds[y]=x;\\n                            size[x]+=size[y];\\n                        }\\n                        else{\\n                            ds[x]=y;\\n                            size[y]+=size[x];\\n                            x=y;\\n                        }\\n                        \\n                        \\n                        \\n                    }\\n                    y=find(curr/j,ds);\\n                    if(x!=y){\\n                        if(size[x]>size[y]){\\n                        ds[y]=x;\\n                        size[x]+=size[y];\\n                        }\\n                        else{\\n                            ds[x]=y;\\n                            size[y]+=size[x];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int count[]=new int[max+1];\\n        int res=1;\\n        for(int i=0;i<nums.length;i++){\\n           res=Math.max(++count[find(nums[i],ds)],res);\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593197,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(int x,vector<int>&p){\\n        if(p[x]==-1) return x;\\n        p[x]=find(p[x],p);\\n        return p[x];\\n    }\\n    void Union(int x,int y,vector<int>&p){\\n        x=find(x,p);\\n        y=find(y,p);\\n        if(x!=y) p[y]=x;\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n        vector<int>p(100001,-1);\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=2;j*j<=nums[i];j++){\\n                if(nums[i]%j==0) {\\n                    Union(nums[i],j,p);\\n                    Union(nums[i],nums[i]/j,p);\\n                }\\n            }\\n        }\\n        unordered_map<int,int> mp;\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int p1 = find(nums[i],p);\\n            count = max(count,1+mp[p1]);\\n            mp[p1]+=1;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int find(int x,vector<int>&p){\\n        if(p[x]==-1) return x;\\n        p[x]=find(p[x],p);\\n        return p[x];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1593177,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int find(int x,int []parent){\\n        if(parent[x] == -1)return x;\\n        parent[x] = find(parent[x],parent);\\n        return parent[x];\\n    }\\n    \\n    public void union(int x,int y,int[] parent){\\n        int xp = find(x,parent);\\n        int yp = find(y,parent);\\n        if(xp != yp){\\n            parent[yp] = xp;\\n        }\\n    }\\n    \\n    public int largestComponentSize(int[] nums) {\\n        int n = nums.length;\\n        int[] parent = new int[100001];\\n        Arrays.fill(parent,-1);\\n            \\n        for(int i = 0;i<n;i++){\\n            for(int k = 2;k<= Math.sqrt(nums[i]);k++){\\n                if(nums[i] % k == 0){\\n                    union(nums[i],k,parent);\\n                    union(nums[i],nums[i]/k,parent);\\n                }\\n            }\\n        }\\n        \\n        int count = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i= 0;i<n;i++){\\n            int p = find(nums[i],parent);\\n            count = Math.max(count,1 + map.getOrDefault(p,0));\\n            map.put(p,1+map.getOrDefault(p,0));\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int find(int x,int []parent){\\n        if(parent[x] == -1)return x;\\n        parent[x] = find(parent[x],parent);\\n        return parent[x];\\n    }\\n    \\n    public void union(int x,int y,int[] parent){\\n        int xp = find(x,parent);\\n        int yp = find(y,parent);\\n        if(xp != yp){\\n            parent[yp] = xp;\\n        }\\n    }\\n    \\n    public int largestComponentSize(int[] nums) {\\n        int n = nums.length;\\n        int[] parent = new int[100001];\\n        Arrays.fill(parent,-1);\\n            \\n        for(int i = 0;i<n;i++){\\n            for(int k = 2;k<= Math.sqrt(nums[i]);k++){\\n                if(nums[i] % k == 0){\\n                    union(nums[i],k,parent);\\n                    union(nums[i],nums[i]/k,parent);\\n                }\\n            }\\n        }\\n        \\n        int count = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i= 0;i<n;i++){\\n            int p = find(nums[i],parent);\\n            count = Math.max(count,1 + map.getOrDefault(p,0));\\n            map.put(p,1+map.getOrDefault(p,0));\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593029,
                "title": "largest-component-size-by-common-factor-c-using-sieve-and-union",
                "content": "```\\nclass Solution {\\npublic:\\n\\t/*function to get root or parent*/\\n    int getRoot(vector<int>& root, int x)\\n    {\\n        if(x == root[x])\\n            return x;\\n        else\\n            return root[x] = getRoot(root, root[x]); \\n    }\\n\\t/*get all prime factors of x in a vector*/\\n     vector<int> getPrimes(int x, vector<int>& s) {\\n        vector<int> primes;\\n        while (x > 1) {\\n            int p = s[x];\\n            if(p == 0)\\n                p = x;\\n            primes.push_back(p);\\n\\t\\t\\t// Edit: uncomment next 2 lines and comment last x/=p to remove duplicate same primes, taken from other solution.\\n\\t\\t\\t// while(x % p == 0)\\n            //    x /= p;\\n            x /= p;\\n        }\\n        return primes;\\n    }\\n\\t/*union a and b by making roots same*/\\n    void unions(int a, int b, vector<int>& root)\\n    {\\n        int aR = getRoot(root, a);\\n        int bR = getRoot(root, b);\\n        if(aR > bR)  // if a is greater, make root of b as a\\n            root[bR] = root[aR];\\n        else\\n            root[aR] = root[bR];\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n        int n=nums.size();\\n        int i,j,M=0;\\n\\t\\tint ans=1; //minimum answer can be 1.\\n        for(i=0;i<n;i++)\\n        {\\n            M = max(M,nums[i]); // get the maximum number.\\n        }\\n        vector<int>sieve(M+1); // used for sieve of eratosthenes\\n        vector<int>count(M+1);  // count_i stores the count of all numbers having root = i\\n        vector<int>root(M+1);  // stores the root\\n        for(i=0;i<=M;i++)\\n        {\\n            root[i] = i; // make each number its on root\\n        }\\n        for(i=2;i*i<=M;i++)\\n        {\\n            if(sieve[i]) // prime number will have 0 value\\n                continue;\\n            for(j=i*i;j<=M;j+=i)\\n            {\\n                sieve[j] = i; // the smallest prime value will be stored here\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(nums[i]==1) //ignore 1\\n                continue;\\n            vector<int>v = getPrimes(nums[i], sieve); //get the prime factors\\n            for(j=0; j<v.size()-1; j++)\\n            {\\n                unions(v[j], v[j+1], root); // union them i.e make their root same.\\n            }\\n            unions(v[j], nums[i], root); // union the number with one of their factors\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            int r = getRoot(root, nums[i]); // find the root i.e. the bucket in which this number will fall\\n            count[r]++; //increase the count of that bucket\\n            ans = max(ans, count[r]); // check max\\n        }\\n        return ans; // return the ans\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t/*function to get root or parent*/\\n    int getRoot(vector<int>& root, int x)\\n    {\\n        if(x == root[x])\\n            return x;\\n        else\\n            return root[x] = getRoot(root, root[x]); \\n    }\\n\\t/*get all prime factors of x in a vector*/\\n     vector<int> getPrimes(int x, vector<int>& s) {\\n        vector<int> primes;\\n        while (x > 1) {\\n            int p = s[x];\\n            if(p == 0)\\n                p = x;\\n            primes.push_back(p);\\n\\t\\t\\t// Edit: uncomment next 2 lines and comment last x/=p to remove duplicate same primes, taken from other solution.\\n\\t\\t\\t// while(x % p == 0)\\n            //    x /= p;\\n            x /= p;\\n        }\\n        return primes;\\n    }\\n\\t/*union a and b by making roots same*/\\n    void unions(int a, int b, vector<int>& root)\\n    {\\n        int aR = getRoot(root, a);\\n        int bR = getRoot(root, b);\\n        if(aR > bR)  // if a is greater, make root of b as a\\n            root[bR] = root[aR];\\n        else\\n            root[aR] = root[bR];\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n        int n=nums.size();\\n        int i,j,M=0;\\n\\t\\tint ans=1; //minimum answer can be 1.\\n        for(i=0;i<n;i++)\\n        {\\n            M = max(M,nums[i]); // get the maximum number.\\n        }\\n        vector<int>sieve(M+1); // used for sieve of eratosthenes\\n        vector<int>count(M+1);  // count_i stores the count of all numbers having root = i\\n        vector<int>root(M+1);  // stores the root\\n        for(i=0;i<=M;i++)\\n        {\\n            root[i] = i; // make each number its on root\\n        }\\n        for(i=2;i*i<=M;i++)\\n        {\\n            if(sieve[i]) // prime number will have 0 value\\n                continue;\\n            for(j=i*i;j<=M;j+=i)\\n            {\\n                sieve[j] = i; // the smallest prime value will be stored here\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(nums[i]==1) //ignore 1\\n                continue;\\n            vector<int>v = getPrimes(nums[i], sieve); //get the prime factors\\n            for(j=0; j<v.size()-1; j++)\\n            {\\n                unions(v[j], v[j+1], root); // union them i.e make their root same.\\n            }\\n            unions(v[j], nums[i], root); // union the number with one of their factors\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            int r = getRoot(root, nums[i]); // find the root i.e. the bucket in which this number will fall\\n            count[r]++; //increase the count of that bucket\\n            ans = max(ans, count[r]); // check max\\n        }\\n        return ans; // return the ans\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592831,
                "title": "golang-union-find-standard-template",
                "content": "typical union find template can be used, we use a factor map to keep track of the most recent group belonging to that factor, it does not have to be most updated since we always union using the parent of the group regardless. here I say \"most updated\" meaning that group does not necessarily have to be the parent group, it could be a child belonging to another parent group.\\n\\nto consider 2 indices eligible to be union, means that the value at their index must share a common factor.\\nexample, consider array: [2,3,4,5] and index 0 and 2.\\nindex 0: value -> 2\\nindex 2: value -> 4\\nthis is considered a good pair to union because they share a common factor of 2.\\n\\nIf you like to visualise things as a graph, then a common factor of 2 is like an edge connecting 2 vertex/nodes representing index 0 and index 2 for the above case.\\n\\n\\n```\\nfunc largestComponentSize(nums []int) int {\\n    factorMap := make(map[int]int) // factor -> number (note: store first one is good enough, we map it back to the parent group in the uf always)\\n    \\n    uf := NewUnionFind(len(nums))\\n    for i, num := range nums {\\n        for _, factor := range genFactor(num) {\\n            if otherIdx, exist := factorMap[factor]; exist {\\n                uf.union(i, otherIdx)\\n            }\\n            factorMap[factor] = i\\n        }\\n    }\\n    \\n    return uf.findLargestComponentSize()\\n}\\n\\n// generates all factors of num, not inclusive of 1\\nfunc genFactor(num int) []int {\\n    res := make([]int, 0)\\n    for i := 2; i<=int(math.Sqrt(float64(num))); i++ {\\n        if num % i == 0 {\\n            res = append(res, i)\\n            if i != num/i {\\n                res = append(res, num/i)\\n            }\\n        }\\n    }\\n    res = append(res, num)  // put in num itself, we do not consider 1 in the loop\\n    \\n    return res\\n}\\n\\n// mapping groups by index\\ntype UnionFind struct {\\n    parents []int\\n    size []int\\n}\\n\\nfunc NewUnionFind(n int) *UnionFind {\\n    parents := make([]int, n)\\n    size := make([]int, n)\\n    for i := range parents {\\n        parents[i] = i\\n        size[i] = 1\\n    }\\n    \\n    return &UnionFind{parents: parents, size: size}\\n}\\n\\nfunc (u *UnionFind) find(x int) int {\\n    if u.parents[x] == x {\\n        return x\\n    }\\n    root := u.find(u.parents[x])\\n    u.parents[x] = root\\n    \\n    return root\\n}\\n\\nfunc (u *UnionFind) union(x, y int) {\\n    rootX := u.find(x)\\n    rootY := u.find(y)\\n    if rootX != rootY {\\n        u.parents[rootY] = rootX\\n        u.size[rootX] += u.size[rootY]\\n    }\\n}\\n\\nfunc (u *UnionFind) findLargestComponentSize() int {\\n    res := 0\\n    for _, s := range u.size {\\n        if s > res {\\n            res = s\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc largestComponentSize(nums []int) int {\\n    factorMap := make(map[int]int) // factor -> number (note: store first one is good enough, we map it back to the parent group in the uf always)\\n    \\n    uf := NewUnionFind(len(nums))\\n    for i, num := range nums {\\n        for _, factor := range genFactor(num) {\\n            if otherIdx, exist := factorMap[factor]; exist {\\n                uf.union(i, otherIdx)\\n            }\\n            factorMap[factor] = i\\n        }\\n    }\\n    \\n    return uf.findLargestComponentSize()\\n}\\n\\n// generates all factors of num, not inclusive of 1\\nfunc genFactor(num int) []int {\\n    res := make([]int, 0)\\n    for i := 2; i<=int(math.Sqrt(float64(num))); i++ {\\n        if num % i == 0 {\\n            res = append(res, i)\\n            if i != num/i {\\n                res = append(res, num/i)\\n            }\\n        }\\n    }\\n    res = append(res, num)  // put in num itself, we do not consider 1 in the loop\\n    \\n    return res\\n}\\n\\n// mapping groups by index\\ntype UnionFind struct {\\n    parents []int\\n    size []int\\n}\\n\\nfunc NewUnionFind(n int) *UnionFind {\\n    parents := make([]int, n)\\n    size := make([]int, n)\\n    for i := range parents {\\n        parents[i] = i\\n        size[i] = 1\\n    }\\n    \\n    return &UnionFind{parents: parents, size: size}\\n}\\n\\nfunc (u *UnionFind) find(x int) int {\\n    if u.parents[x] == x {\\n        return x\\n    }\\n    root := u.find(u.parents[x])\\n    u.parents[x] = root\\n    \\n    return root\\n}\\n\\nfunc (u *UnionFind) union(x, y int) {\\n    rootX := u.find(x)\\n    rootY := u.find(y)\\n    if rootX != rootY {\\n        u.parents[rootY] = rootX\\n        u.size[rootX] += u.size[rootY]\\n    }\\n}\\n\\nfunc (u *UnionFind) findLargestComponentSize() int {\\n    res := 0\\n    for _, s := range u.size {\\n        if s > res {\\n            res = s\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592790,
                "title": "js-union-find-in-33-lines-beats-100-space-time",
                "content": "This executes in 444 ms, with no prime-factor optimizations:\\n\\n```js\\nvar largestComponentSize = function(nums) {\\n  const rootByFactor = new Map();\\n  const parents = new Array(nums.length);\\n  \\n  function addFactor(i, factor) {\\n    if (rootByFactor.has(factor)) {\\n      let r = rootByFactor.get(factor);\\n      while (parents[i] != i) i = parents[i];\\n      while (parents[r] != r) r = parents[r];\\n      parents[i] = r;\\n    }\\n    rootByFactor.set(factor, parents[i]);\\n  }\\n  \\n  for (const [i, num] of nums.entries()) {\\n    parents[i] = i;\\n    addFactor(i, num);\\n    for (let factor = 2; factor * factor <= num; ++factor) {\\n      if (num % factor == 0) {\\n        addFactor(i, factor);\\n        addFactor(i, num / factor);\\n      }\\n    }\\n  }\\n  \\n  let largest = 0;\\n  const sums = new Array(nums.length).fill(0);\\n  for (let r of parents) {\\n    while (parents[r] != r) r = parents[r];\\n    largest = Math.max(largest, ++sums[r]);\\n  }\\n  return largest;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```js\\nvar largestComponentSize = function(nums) {\\n  const rootByFactor = new Map();\\n  const parents = new Array(nums.length);\\n  \\n  function addFactor(i, factor) {\\n    if (rootByFactor.has(factor)) {\\n      let r = rootByFactor.get(factor);\\n      while (parents[i] != i) i = parents[i];\\n      while (parents[r] != r) r = parents[r];\\n      parents[i] = r;\\n    }\\n    rootByFactor.set(factor, parents[i]);\\n  }\\n  \\n  for (const [i, num] of nums.entries()) {\\n    parents[i] = i;\\n    addFactor(i, num);\\n    for (let factor = 2; factor * factor <= num; ++factor) {\\n      if (num % factor == 0) {\\n        addFactor(i, factor);\\n        addFactor(i, num / factor);\\n      }\\n    }\\n  }\\n  \\n  let largest = 0;\\n  const sums = new Array(nums.length).fill(0);\\n  for (let r of parents) {\\n    while (parents[r] != r) r = parents[r];\\n    largest = Math.max(largest, ++sums[r]);\\n  }\\n  return largest;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592460,
                "title": "approach-using-union-find",
                "content": "```\\npublic class Solution {\\n    public int LargestComponentSize(int[] nums) {\\n        var set = new UnionFindSet(nums.Max() + 1);\\n        \\n        // Calculate primes set for all elements\\n        foreach (var num in nums) {\\n            for (var k = 2; k * k <= num; ++k) {\\n                if (num % k == 0) {\\n                    set.Union(num, k);\\n                    set.Union(num, num / k);\\n                }\\n            }\\n        }\\n        \\n        // Count the apperance of parents, return the maxium one.\\n        // All connected nodes will point to same parent\\n        var map = new Dictionary<int, int>();\\n        var result = 1;\\n        foreach (var num in nums) {\\n            var count = set.Find(num);\\n            map[count] = (map.ContainsKey(count) ? map[count] : 0) + 1;\\n            result = Math.Max(result, map[count]);\\n        }        \\n        return result;\\n    }\\n    \\n    public class UnionFindSet {\\n        private int[] parent;\\n        \\n        public UnionFindSet(int size) {\\n            parent = new int[size];\\n            for (int i = 0; i < parent.Length; ++i) {\\n                parent[i] = i;\\n            }\\n        }\\n        public void Union(int x, int y) {\\n            parent[Find(x)] = parent[Find(y)];\\n        }\\n        public int Find(int x) {\\n            if (parent[x] != x) {\\n                parent[x] = Find(parent[x]);\\n            }\\n            return parent[x];\\n        }        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\npublic class Solution {\\n    public int LargestComponentSize(int[] nums) {\\n        var set = new UnionFindSet(nums.Max() + 1);\\n        \\n        // Calculate primes set for all elements\\n        foreach (var num in nums) {\\n            for (var k = 2; k * k <= num; ++k) {\\n                if (num % k == 0) {\\n                    set.Union(num, k);\\n                    set.Union(num, num / k);\\n                }\\n            }\\n        }\\n        \\n        // Count the apperance of parents, return the maxium one.\\n        // All connected nodes will point to same parent\\n        var map = new Dictionary<int, int>();\\n        var result = 1;\\n        foreach (var num in nums) {\\n            var count = set.Find(num);\\n            map[count] = (map.ContainsKey(count) ? map[count] : 0) + 1;\\n            result = Math.Max(result, map[count]);\\n        }        \\n        return result;\\n    }\\n    \\n    public class UnionFindSet {\\n        private int[] parent;\\n        \\n        public UnionFindSet(int size) {\\n            parent = new int[size];\\n            for (int i = 0; i < parent.Length; ++i) {\\n                parent[i] = i;\\n            }\\n        }\\n        public void Union(int x, int y) {\\n            parent[Find(x)] = parent[Find(y)];\\n        }\\n        public int Find(int x) {\\n            if (parent[x] != x) {\\n                parent[x] = Find(parent[x]);\\n            }\\n            return parent[x];\\n        }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592428,
                "title": "rust-unionfind-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nstruct UnionFind {\\n    parent: Vec<usize>,\\n}\\n\\nimpl UnionFind {\\n    fn new(n: usize) -> Self {\\n        Self {\\n            parent: (0..n).collect(),\\n        }\\n    }\\n    fn union(&mut self, x: usize, y: usize) {\\n        let x = self.find(x);\\n        let y = self.find(y);\\n        self.parent[y] = x\\n    }\\n    fn find(&mut self, x: usize) -> usize {\\n        if x != self.parent[x] {\\n            self.parent[x] = self.find(self.parent[x]);\\n        }\\n        self.parent[x]\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn largest_component_size(nums: Vec<i32>) -> i32 {\\n        let mut sieve = (0..100_001).collect::<Vec<_>>();\\n        for i in (2..).take_while(|&i| i * i < 100_001) {\\n            if sieve[i] == i as i32 {\\n                for j in (i..100_001).step_by(i) {\\n                    sieve[j] = sieve[j].min(i as i32);\\n                }\\n            }\\n        }\\n        let mut hm = HashMap::new();\\n        for (i, &num) in nums.iter().enumerate() {\\n            let mut n = num;\\n            while n > 1 {\\n                let p = sieve[n as usize];\\n                hm.entry(p).or_insert_with(Vec::new).push(i);\\n                n /= p as i32;\\n            }\\n        }\\n        let mut uf = UnionFind::new(nums.len());\\n        for v in hm.values_mut() {\\n            v.dedup();\\n            v.windows(2).for_each(|w| uf.union(w[0], w[1]));\\n        }\\n        let mut counts = vec![0; nums.len()];\\n        for i in 0..nums.len() {\\n            counts[uf.find(i)] += 1;\\n        }\\n        *counts.iter().max().unwrap() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Union Find"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nstruct UnionFind {\\n    parent: Vec<usize>,\\n}\\n\\nimpl UnionFind {\\n    fn new(n: usize) -> Self {\\n        Self {\\n            parent: (0..n).collect(),\\n        }\\n    }\\n    fn union(&mut self, x: usize, y: usize) {\\n        let x = self.find(x);\\n        let y = self.find(y);\\n        self.parent[y] = x\\n    }\\n    fn find(&mut self, x: usize) -> usize {\\n        if x != self.parent[x] {\\n            self.parent[x] = self.find(self.parent[x]);\\n        }\\n        self.parent[x]\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn largest_component_size(nums: Vec<i32>) -> i32 {\\n        let mut sieve = (0..100_001).collect::<Vec<_>>();\\n        for i in (2..).take_while(|&i| i * i < 100_001) {\\n            if sieve[i] == i as i32 {\\n                for j in (i..100_001).step_by(i) {\\n                    sieve[j] = sieve[j].min(i as i32);\\n                }\\n            }\\n        }\\n        let mut hm = HashMap::new();\\n        for (i, &num) in nums.iter().enumerate() {\\n            let mut n = num;\\n            while n > 1 {\\n                let p = sieve[n as usize];\\n                hm.entry(p).or_insert_with(Vec::new).push(i);\\n                n /= p as i32;\\n            }\\n        }\\n        let mut uf = UnionFind::new(nums.len());\\n        for v in hm.values_mut() {\\n            v.dedup();\\n            v.windows(2).for_each(|w| uf.union(w[0], w[1]));\\n        }\\n        let mut counts = vec![0; nums.len()];\\n        for i in 0..nums.len() {\\n            counts[uf.find(i)] += 1;\\n        }\\n        *counts.iter().max().unwrap() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592244,
                "title": "my-c-solution",
                "content": "```\\nint parent[100001];\\n\\nint find(int x)\\n{\\n    if(parent[x] == -1)\\n        return x;\\n    else \\n        return parent[x] = find(parent[x]);\\n}\\nbool uni(int a, int b)\\n{\\n    int x = find(a);\\n    int y = find(b);\\n    if(x != y)\\n        parent[y] = x;\\n    else \\n        return false;\\n    return true;\\n}\\n\\nint largestComponentSize(int* nums, int numsSize){\\n    int temp[100001] = {0};\\n    int ret = 0;\\n    for(int i = 0; i < 100001; i++)\\n        parent[i] = -1;\\n    for(int i = 0; i < numsSize; i++)\\n        for(int j = 2; j*j <= nums[i]; j++)\\n            if(nums[i] % j == 0)\\n            {\\n                uni(j, nums[i]);\\n                uni(nums[i], nums[i]/j);\\n            }\\n    for(int i = 0; i < numsSize; i++)\\n        ret = ret > ++temp[find(nums[i])] ? ret : temp[find(nums[i])];\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nint parent[100001];\\n\\nint find(int x)\\n{\\n    if(parent[x] == -1)\\n        return x;\\n    else \\n        return parent[x] = find(parent[x]);\\n}\\nbool uni(int a, int b)\\n{\\n    int x = find(a);\\n    int y = find(b);\\n    if(x != y)\\n        parent[y] = x;\\n    else \\n        return false;\\n    return true;\\n}\\n\\nint largestComponentSize(int* nums, int numsSize){\\n    int temp[100001] = {0};\\n    int ret = 0;\\n    for(int i = 0; i < 100001; i++)\\n        parent[i] = -1;\\n    for(int i = 0; i < numsSize; i++)\\n        for(int j = 2; j*j <= nums[i]; j++)\\n            if(nums[i] % j == 0)\\n            {\\n                uni(j, nums[i]);\\n                uni(nums[i], nums[i]/j);\\n            }\\n    for(int i = 0; i < numsSize; i++)\\n        ret = ret > ++temp[find(nums[i])] ? ret : temp[find(nums[i])];\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592177,
                "title": "rust-solution",
                "content": "```\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn largest_component_size(nums: Vec<i32>) -> i32 {\\n        let mut par: Vec<i32> = vec![0; 100001];\\n        let mut rank: Vec<i32> = vec![0; 100001];\\n        let mut ans: i32 = 1;\\n        \\n        for i in 1..=100000{\\n            par[i] = i as i32;\\n        }\\n        \\n        for i in 0..nums.len() {\\n            rank[nums[i] as usize] = 1;\\n        }\\n        \\n        for i in 0..nums.len() {\\n            let mut j: usize = 2;\\n            while j*j <= nums[i] as usize  {\\n                if(nums[i] as usize % j == 0)\\n                {\\n                    Solution::union(j, nums[i] as usize, &mut par, &mut rank, &mut ans);\\n                    Solution::union(j, (nums[i] as usize/j), &mut par, &mut rank, &mut ans);\\n                }\\n                j+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    fn find(x: usize, par: &mut Vec<i32>) -> usize {\\n        return if par[x] == x as i32 {x} else {par[x] = Solution::find(par[x] as usize, par) as i32; return par[x] as usize};\\n    }\\n    \\n    fn union(a: usize, b: usize, par: &mut Vec<i32>, rank: &mut Vec<i32>, ans: &mut i32) {\\n        \\n        let a = Solution::find(a, par); \\n        let b = Solution::find(b, par);\\n        \\n        if(a==b) {return;}\\n        \\n        if(rank[a]>=rank[b]){\\n            par[b]=a as i32; rank[a] += rank[b];\\n        }\\n        \\n        else {\\n            rank[b] += rank[a]; par[a]=b as i32;\\n        }\\n        *ans = max(*ans, max(rank[a],rank[b]));\\n    }\\n}",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn largest_component_size(nums: Vec<i32>) -> i32 {\\n        let mut par: Vec<i32> = vec![0; 100001];\\n        let mut rank: Vec<i32> = vec![0; 100001];\\n        let mut ans: i32 = 1;\\n        \\n        for i in 1..=100000{\\n            par[i] = i as i32;\\n        }\\n        \\n        for i in 0..nums.len() {\\n            rank[nums[i] as usize] = 1;\\n        }\\n        \\n        for i in 0..nums.len() {\\n            let mut j: usize = 2;\\n            while j*j <= nums[i] as usize  {\\n                if(nums[i] as usize % j == 0)\\n                {\\n                    Solution::union(j, nums[i] as usize, &mut par, &mut rank, &mut ans);\\n                    Solution::union(j, (nums[i] as usize/j), &mut par, &mut rank, &mut ans);\\n                }\\n                j+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    fn find(x: usize, par: &mut Vec<i32>) -> usize {\\n        return if par[x] == x as i32 {x} else {par[x] = Solution::find(par[x] as usize, par) as i32; return par[x] as usize};\\n    }\\n    \\n    fn union(a: usize, b: usize, par: &mut Vec<i32>, rank: &mut Vec<i32>, ans: &mut i32) {\\n        \\n        let a = Solution::find(a, par); \\n        let b = Solution::find(b, par);\\n        \\n        if(a==b) {return;}\\n        \\n        if(rank[a]>=rank[b]){\\n            par[b]=a as i32; rank[a] += rank[b];\\n        }\\n        \\n        else {\\n            rank[b] += rank[a]; par[a]=b as i32;\\n        }\\n        *ans = max(*ans, max(rank[a],rank[b]));\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1533268,
                "title": "java-find-and-union-graph-question",
                "content": "```\\nclass Solution {\\n    int find(int x, int[] parent){\\n            if(parent[x] == -1) return x;\\n        \\n        parent[x] = find(parent[x], parent);\\n        return parent[x];\\n        }\\n    \\n    void union(int x, int y, int[] parent){\\n        int xp = find(x,parent);\\n        int yp = find(y,parent);\\n        if(xp!= yp) parent[yp] = xp;\\n    }\\n    public int largestComponentSize(int[] A) {\\n        int n = A.length;\\n        int[] parent = new int[100001];\\n        for(int i=0;i<100001;i++) parent[i] = -1;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int k=2;k<=Math.sqrt(A[i]);k++){\\n                if(A[i]%k == 0){\\n                    union(A[i],k,parent);\\n                    union(A[i],A[i]/k,parent);\\n                }\\n            }\\n        }\\n        int count=0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            int p = find(A[i],parent);\\n            count = Math.max(count, 1+hm.getOrDefault(p,0));\\n            hm.put(p,1+hm.getOrDefault(p,0));\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int find(int x, int[] parent){\\n            if(parent[x] == -1) return x;\\n        \\n        parent[x] = find(parent[x], parent);\\n        return parent[x];\\n        }\\n    \\n    void union(int x, int y, int[] parent){\\n        int xp = find(x,parent);\\n        int yp = find(y,parent);\\n        if(xp!= yp) parent[yp] = xp;\\n    }\\n    public int largestComponentSize(int[] A) {\\n        int n = A.length;\\n        int[] parent = new int[100001];\\n        for(int i=0;i<100001;i++) parent[i] = -1;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int k=2;k<=Math.sqrt(A[i]);k++){\\n                if(A[i]%k == 0){\\n                    union(A[i],k,parent);\\n                    union(A[i],A[i]/k,parent);\\n                }\\n            }\\n        }\\n        int count=0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            int p = find(A[i],parent);\\n            count = Math.max(count, 1+hm.getOrDefault(p,0));\\n            hm.put(p,1+hm.getOrDefault(p,0));\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459058,
                "title": "c-optimized-union-find-linq",
                "content": "```\\npublic class Solution {\\n    public class UnionFind {\\n        private int[] root;\\n        private int[] rank;\\n\\n        // O(n)\\n        public UnionFind(int vertices){\\n            root = new int[vertices];\\n            rank = new int[vertices];\\n            for(int i = 0; i < vertices; i++){\\n                root[i] = i;\\n                rank[i] = 1;\\n            }\\n        }\\n\\n        // O(1), average\\n        public int Find(int x){\\n            if(x == root[x]){\\n                return x;\\n            }\\n            return root[x] = Find(root[x]);\\n        }\\n\\n        // O(1), average\\n        public void Union(int x, int y){\\n            int xRoot = Find(x);\\n            int yRoot = Find(y);\\n            if(xRoot != yRoot){\\n                if(rank[xRoot] > rank[yRoot]){\\n                    root[yRoot] = xRoot;\\n                } else if(rank[xRoot] < rank[yRoot]){\\n                    root[xRoot] = yRoot;\\n                } else {\\n                    root[yRoot] = xRoot;\\n                    rank[xRoot]++;\\n                }\\n            }\\n        }\\n    }\\n\\n    public int LargestComponentSize(int[] nums) {\\n        int maxValue = nums.Aggregate((x, y) => x > y ? x : y); // Uses LINQ\\'s reduce method to find largest value\\n        UnionFind ds = new UnionFind(maxValue + 1); // +1 to hold just enough items, without +1 out of bounds\\n\\n        foreach(int num in nums){\\n            for(int factor = 2; factor < (int)(Math.Sqrt(num)) + 1; ++factor){\\n                if(num % factor == 0){\\n                    ds.Union(num, factor);\\n                    ds.Union(num, num / factor);\\n                }\\n            }\\n        }\\n\\n        int maxGroupSize = 0;\\n        Dictionary<int, int> groupCount = new Dictionary<int, int>();\\n        foreach(int num in nums){\\n            int groupID = ds.Find(num);\\n            if(!groupCount.ContainsKey(groupID)){\\n                groupCount.Add(groupID, 0);\\n            }\\n            groupCount[groupID]++;\\n            maxGroupSize = Math.Max(maxGroupSize, groupCount[groupID]);\\n        }\\n\\n        return maxGroupSize;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\npublic class Solution {\\n    public class UnionFind {\\n        private int[] root;\\n        private int[] rank;\\n\\n        // O(n)\\n        public UnionFind(int vertices){\\n            root = new int[vertices];\\n            rank = new int[vertices];\\n            for(int i = 0; i < vertices; i++){\\n                root[i] = i;\\n                rank[i] = 1;\\n            }\\n        }\\n\\n        // O(1), average\\n        public int Find(int x){\\n            if(x == root[x]){\\n                return x;\\n            }\\n            return root[x] = Find(root[x]);\\n        }\\n\\n        // O(1), average\\n        public void Union(int x, int y){\\n            int xRoot = Find(x);\\n            int yRoot = Find(y);\\n            if(xRoot != yRoot){\\n                if(rank[xRoot] > rank[yRoot]){\\n                    root[yRoot] = xRoot;\\n                } else if(rank[xRoot] < rank[yRoot]){\\n                    root[xRoot] = yRoot;\\n                } else {\\n                    root[yRoot] = xRoot;\\n                    rank[xRoot]++;\\n                }\\n            }\\n        }\\n    }\\n\\n    public int LargestComponentSize(int[] nums) {\\n        int maxValue = nums.Aggregate((x, y) => x > y ? x : y); // Uses LINQ\\'s reduce method to find largest value\\n        UnionFind ds = new UnionFind(maxValue + 1); // +1 to hold just enough items, without +1 out of bounds\\n\\n        foreach(int num in nums){\\n            for(int factor = 2; factor < (int)(Math.Sqrt(num)) + 1; ++factor){\\n                if(num % factor == 0){\\n                    ds.Union(num, factor);\\n                    ds.Union(num, num / factor);\\n                }\\n            }\\n        }\\n\\n        int maxGroupSize = 0;\\n        Dictionary<int, int> groupCount = new Dictionary<int, int>();\\n        foreach(int num in nums){\\n            int groupID = ds.Find(num);\\n            if(!groupCount.ContainsKey(groupID)){\\n                groupCount.Add(groupID, 0);\\n            }\\n            groupCount[groupID]++;\\n            maxGroupSize = Math.Max(maxGroupSize, groupCount[groupID]);\\n        }\\n\\n        return maxGroupSize;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445730,
                "title": "python-union-find-sieve-of-eratosthenes",
                "content": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parents = [i for i in range(n+1)]\\n        self.ranks = [0] * (n+1)\\n    \\n    def find(self, x):\\n        if x != self.parents[x]:\\n            self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n    \\n    def union(self, x, y):\\n        root_x, root_y = self.find(x), self.find(y)\\n        if self.ranks[root_x] < self.ranks[root_y]:\\n            self.parents[root_x] = root_y\\n        elif self.ranks[root_x] > self.ranks[root_y]:\\n            self.parents[root_y] = root_x\\n        else:\\n            self.parents[root_x] = root_y\\n            self.ranks[root_y] += 1\\n        \\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        nums_set = set(nums)\\n        max_num = max(nums)\\n        uf = UnionFind(max_num)\\n        is_prime = [True for _ in range(max_num+1)]\\n        for num in range(2, max_num+1):\\n            if is_prime[num]:\\n                for composite in range(num, max_num+1, num):\\n                    if composite != num:\\n                        is_prime[composite] = False\\n                    if composite in nums_set:\\n                        uf.union(num, composite)\\n        \\n        cluster_to_cnt = defaultdict(int)\\n        for num in nums:\\n            cluster_to_cnt[uf.find(num)] += 1\\n        return max([cnt for _, cnt in cluster_to_cnt.items()])\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parents = [i for i in range(n+1)]\\n        self.ranks = [0] * (n+1)\\n    \\n    def find(self, x):\\n        if x != self.parents[x]:\\n            self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n    \\n    def union(self, x, y):\\n        root_x, root_y = self.find(x), self.find(y)\\n        if self.ranks[root_x] < self.ranks[root_y]:\\n            self.parents[root_x] = root_y\\n        elif self.ranks[root_x] > self.ranks[root_y]:\\n            self.parents[root_y] = root_x\\n        else:\\n            self.parents[root_x] = root_y\\n            self.ranks[root_y] += 1\\n        \\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        nums_set = set(nums)\\n        max_num = max(nums)\\n        uf = UnionFind(max_num)\\n        is_prime = [True for _ in range(max_num+1)]\\n        for num in range(2, max_num+1):\\n            if is_prime[num]:\\n                for composite in range(num, max_num+1, num):\\n                    if composite != num:\\n                        is_prime[composite] = False\\n                    if composite in nums_set:\\n                        uf.union(num, composite)\\n        \\n        cluster_to_cnt = defaultdict(int)\\n        for num in nums:\\n            cluster_to_cnt[uf.find(num)] += 1\\n        return max([cnt for _, cnt in cluster_to_cnt.items()])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439740,
                "title": "python-soluton-sieve-of-eratosthenes-and-union-find",
                "content": "We use Sieve of Eratosthenes to find all element with common prime factor, the connet them with Union set.\\n```\\nclass Uni:\\n\\n    def __init__(self, arr):\\n        self.arr = {i:i for i in arr}\\n        self.sz = {i:1 for i in arr}\\n    \\n    def find(self, x):\\n        if x != self.arr[x]: self.arr[x] = self.find(self.arr[x])\\n        return self.arr[x]\\n    \\n    def same(self, x, y):\\n        return self.find(x) == self.find(y)\\n    \\n    def merge(self, x, y):\\n        x, y = self.find(x), self.find(y)\\n        if x == y: return\\n        if x > y: x, y = y, x\\n        self.sz[x] += self.sz[y]\\n        self.arr[y] = self.arr[x]\\n\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        uni = Uni(nums)\\n        bound = max(nums) + 1\\n        isprime = [True] * bound\\n        nums = set(nums)\\n        for i in range(2, bound):\\n            if not isprime[i]: continue\\n            last = None\\n            for j in range(i, bound, i):\\n                isprime[j] = False\\n                if j in nums:\\n                    if last is None: last = j\\n                    else: uni.merge(last, j)\\n        return max(uni.sz.values())",
                "solutionTags": [],
                "code": "We use Sieve of Eratosthenes to find all element with common prime factor, the connet them with Union set.\\n```\\nclass Uni:\\n\\n    def __init__(self, arr):\\n        self.arr = {i:i for i in arr}\\n        self.sz = {i:1 for i in arr}\\n    \\n    def find(self, x):\\n        if x != self.arr[x]: self.arr[x] = self.find(self.arr[x])\\n        return self.arr[x]\\n    \\n    def same(self, x, y):\\n        return self.find(x) == self.find(y)\\n    \\n    def merge(self, x, y):\\n        x, y = self.find(x), self.find(y)\\n        if x == y: return\\n        if x > y: x, y = y, x\\n        self.sz[x] += self.sz[y]\\n        self.arr[y] = self.arr[x]\\n\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        uni = Uni(nums)\\n        bound = max(nums) + 1\\n        isprime = [True] * bound\\n        nums = set(nums)\\n        for i in range(2, bound):\\n            if not isprime[i]: continue\\n            last = None\\n            for j in range(i, bound, i):\\n                isprime[j] = False\\n                if j in nums:\\n                    if last is None: last = j\\n                    else: uni.merge(last, j)\\n        return max(uni.sz.values())",
                "codeTag": "Java"
            },
            {
                "id": 1329265,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int par[100001],rank_[100001],ans;\\n    int find(int x)\\n    {\\n        return (par[x]==x?x:par[x]=find(par[x]));\\n    }\\n    void union_(int a,int b)\\n    {\\n        a=find(a); b=find(b);\\n        if(a==b)return;\\n        if(rank_[a]>=rank_[b])\\n        {\\n            par[b]=a; rank_[a] += rank_[b];\\n        }\\n        else\\n        {\\n            rank_[b] += rank_[a]; par[a]=b;\\n        }\\n        ans = max(ans,max(rank_[a],rank_[b]));\\n    }\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        ans = 1;\\n        for(int i=1;i<=100000;i++)\\n        {\\n            par[i]=i; rank_[i]=0;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n            rank_[nums[i]]=1;\\n        \\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=2;j*j<=nums[i];j++)\\n            {\\n                if(nums[i]%j == 0)\\n                {\\n                    union_(j,nums[i]);\\n                    union_(j,nums[i]/j);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int par[100001],rank_[100001],ans;\\n    int find(int x)\\n    {\\n        return (par[x]==x?x:par[x]=find(par[x]));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1319995,
                "title": "simplest-union-find-solution-with-inline-comments-for-explaination-95-time",
                "content": "**Main Intuition:**\\n1. Do union operation of all numbers with their prime factors\\n2. Answer will be the most frequent parent (or root)\\n```\\n    /* --------------------------------- GENERAL UNION FIND TEMPLATE ----------------------------------- */\\n    \\n    struct vt{\\n        int parent;\\n        int rank;\\n    };\\n    \\n    int ds_find(vector<vt> & ds, int v){\\n        if(ds[v].parent==-1)\\n            return v;\\n        \\n        return ds[v].parent = ds_find(ds, ds[v].parent);\\n    }\\n    \\n    void ds_union(vector<vt> & ds, int v1, int v2){\\n        if(ds[v1].rank < ds[v2].rank)\\n            ds[v1].parent = v2;\\n        \\n        else if(ds[v1].rank > ds[v2].rank)\\n            ds[v2].parent = v1;\\n        \\n        else{\\n            ds[v1].parent = v2;\\n            ds[v2].rank++;\\n        }\\n    }\\n    \\n    /* ------------------------------------------------------------------------------------------------- */\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int mx = *max_element(nums.begin(), nums.end());\\n        \\n        vector<vt> ds (mx+1, {-1, 0});\\n        \\n        /* Iterate array nums */\\n        \\n        for(int num : nums){\\n            int sqr_root = sqrt(num);\\n            \\n            /* For each element, find prime factors (by iterating from 2 to sqrt(num)) */\\n            \\n            for(int i=2; i<=sqr_root; i++){\\n                \\n                /* Do union operation of num with its every prime factor */\\n                \\n                if(num%i==0){\\n                    \\n                    /* We need to do find operation everytime because root may change anytime */\\n                    \\n                    int root1 = ds_find(ds, num);\\n                    int root2 = ds_find(ds, i);\\n                    \\n                    if(root1!=root2)\\n                        ds_union(ds, root1, root2);\\n                    \\n                    root1 = ds_find(ds, num); \\n                    root2 = ds_find(ds, num/i);\\n                    \\n                    if(root1!=root2)\\n                        ds_union(ds, root1, root2);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int, int> mp;     // ----> will contains frequency of roots of each element\\n        int ans = 1;\\n        \\n        for(int num : nums){\\n            int root = ds_find(ds, num);\\n            mp[root]++;\\n            \\n            ans = max(ans, mp[root]);  // ----> Ans will be the max frequency of all roots\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    /* --------------------------------- GENERAL UNION FIND TEMPLATE ----------------------------------- */\\n    \\n    struct vt{\\n        int parent;\\n        int rank;\\n    };\\n    \\n    int ds_find(vector<vt> & ds, int v){\\n        if(ds[v].parent==-1)\\n            return v;\\n        \\n        return ds[v].parent = ds_find(ds, ds[v].parent);\\n    }\\n    \\n    void ds_union(vector<vt> & ds, int v1, int v2){\\n        if(ds[v1].rank < ds[v2].rank)\\n            ds[v1].parent = v2;\\n        \\n        else if(ds[v1].rank > ds[v2].rank)\\n            ds[v2].parent = v1;\\n        \\n        else{\\n            ds[v1].parent = v2;\\n            ds[v2].rank++;\\n        }\\n    }\\n    \\n    /* ------------------------------------------------------------------------------------------------- */\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int mx = *max_element(nums.begin(), nums.end());\\n        \\n        vector<vt> ds (mx+1, {-1, 0});\\n        \\n        /* Iterate array nums */\\n        \\n        for(int num : nums){\\n            int sqr_root = sqrt(num);\\n            \\n            /* For each element, find prime factors (by iterating from 2 to sqrt(num)) */\\n            \\n            for(int i=2; i<=sqr_root; i++){\\n                \\n                /* Do union operation of num with its every prime factor */\\n                \\n                if(num%i==0){\\n                    \\n                    /* We need to do find operation everytime because root may change anytime */\\n                    \\n                    int root1 = ds_find(ds, num);\\n                    int root2 = ds_find(ds, i);\\n                    \\n                    if(root1!=root2)\\n                        ds_union(ds, root1, root2);\\n                    \\n                    root1 = ds_find(ds, num); \\n                    root2 = ds_find(ds, num/i);\\n                    \\n                    if(root1!=root2)\\n                        ds_union(ds, root1, root2);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int, int> mp;     // ----> will contains frequency of roots of each element\\n        int ans = 1;\\n        \\n        for(int num : nums){\\n            int root = ds_find(ds, num);\\n            mp[root]++;\\n            \\n            ans = max(ans, mp[root]);  // ----> Ans will be the max frequency of all roots\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1235995,
                "title": "3-separate-class-easy-to-understand-unionfind-class-sieve-class-c",
                "content": "```\\nclass UnionFind {\\n    public:\\n        vector < int > par, SIZ;\\n        UnionFind( int sz = 100005 ) {\\n            for ( int i = 0; i < sz; ++i ) {\\n                par.push_back( i );\\n                SIZ.push_back( 0 );\\n            }\\n        }\\n\\n        int find_root( int u ) {\\n            if ( par[ u ] != u )\\n                par[ u ] = find_root( par[ u ] );\\n\\n                return par[ u ];\\n        }\\n\\n        void merge( int u, int v ) {\\n            if ( find_root( u ) != find_root( v ) ) {\\n                if ( SIZ[ par[ u ] ] <= SIZ[ par[ v ] ] )   swap( u, v );\\n\\n                SIZ[ par[ u ] ] += SIZ[ par[ v ] ];\\n                par[ par[ v ] ] = par[ u ];\\n            }\\n        }\\n};\\n\\nclass Sieve {\\n    public:     \\n        vector < int > sie;\\n        vector < int > spf;  \\n    \\n        Sieve( int MSS ) {    \\n            spf.resize( MSS + 7, 0 );\\n            for ( int i = 2; i < MSS; ++i ) {  \\n                if ( spf[ i ] == 0 ) {\\n                    spf[ i ] = i;   \\n                    sie.push_back( i );  \\n                }    \\n                for ( int j = 0; j < sie.size() && i * sie[ j ] <= MSS && sie[ j ] <= spf[ i ]; ++j ) \\n                    spf[ i * sie[ j ] ] = sie[ j ]; \\n            }\\n        }\\n};\\n\\nclass Solution {\\n    public:\\n        Sieve Sv = Sieve( 100005 );\\n    \\n        int largestComponentSize( vector < int > &Arr ) {\\n            UnionFind UF = UnionFind();\\n            \\n            for ( int A : Arr ) {\\n                if ( A == 1 ) {\\n                    UF.SIZ[ A ] = 1;\\n                    continue;\\n                }\\n                vector < int > E;\\n                while ( A != 1 ) {\\n                    E.push_back( Sv.spf[ A ] );\\n                    A /= Sv.spf[ A ]; \\n                }\\n                \\n                UF.SIZ[ UF.find_root( E[ 0 ] ) ]++;\\n                \\n                for ( int i = 1; i < E.size(); ++i ) \\n                    UF.merge( E[ 0 ], E[ i ] );\\n            }\\n            \\n            return *max_element( UF.SIZ.begin(), UF.SIZ.end() );\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind {\\n    public:\\n        vector < int > par, SIZ;\\n        UnionFind( int sz = 100005 ) {\\n            for ( int i = 0; i < sz; ++i ) {\\n                par.push_back( i );\\n                SIZ.push_back( 0 );\\n            }\\n        }\\n\\n        int find_root( int u ) {\\n            if ( par[ u ] != u )\\n                par[ u ] = find_root( par[ u ] );\\n\\n                return par[ u ];\\n        }\\n\\n        void merge( int u, int v ) {\\n            if ( find_root( u ) != find_root( v ) ) {\\n                if ( SIZ[ par[ u ] ] <= SIZ[ par[ v ] ] )   swap( u, v );\\n\\n                SIZ[ par[ u ] ] += SIZ[ par[ v ] ];\\n                par[ par[ v ] ] = par[ u ];\\n            }\\n        }\\n};\\n\\nclass Sieve {\\n    public:     \\n        vector < int > sie;\\n        vector < int > spf;  \\n    \\n        Sieve( int MSS ) {    \\n            spf.resize( MSS + 7, 0 );\\n            for ( int i = 2; i < MSS; ++i ) {  \\n                if ( spf[ i ] == 0 ) {\\n                    spf[ i ] = i;   \\n                    sie.push_back( i );  \\n                }    \\n                for ( int j = 0; j < sie.size() && i * sie[ j ] <= MSS && sie[ j ] <= spf[ i ]; ++j ) \\n                    spf[ i * sie[ j ] ] = sie[ j ]; \\n            }\\n        }\\n};\\n\\nclass Solution {\\n    public:\\n        Sieve Sv = Sieve( 100005 );\\n    \\n        int largestComponentSize( vector < int > &Arr ) {\\n            UnionFind UF = UnionFind();\\n            \\n            for ( int A : Arr ) {\\n                if ( A == 1 ) {\\n                    UF.SIZ[ A ] = 1;\\n                    continue;\\n                }\\n                vector < int > E;\\n                while ( A != 1 ) {\\n                    E.push_back( Sv.spf[ A ] );\\n                    A /= Sv.spf[ A ]; \\n                }\\n                \\n                UF.SIZ[ UF.find_root( E[ 0 ] ) ]++;\\n                \\n                for ( int i = 1; i < E.size(); ++i ) \\n                    UF.merge( E[ 0 ], E[ i ] );\\n            }\\n            \\n            return *max_element( UF.SIZ.begin(), UF.SIZ.end() );\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217549,
                "title": "c-union-find-prime-fact",
                "content": "```\\nclass Solution {\\npublic:\\n    int parent[100001];\\n    int find(int x)\\n    {\\n        if(parent[x]!=x)\\n            parent[x]=find(parent[x]);\\n        return parent[x];\\n    }\\n    void Union(int x,int y)\\n    {\\n        int px=find(x),py=find(y);\\n        parent[py]=px;\\n    }\\n    int largestComponentSize(vector<int>& nums) \\n    {\\n        for(int i=0;i<=100000;i++)\\n            parent[i]=i;\\n        for(auto x:nums)\\n        {\\n            int i=2;\\n            int n=x;\\n            while(i*i<=n)\\n            {\\n                bool flag=false;\\n                while(n%i==0)\\n                {\\n                    flag=true;\\n                    n/=i;\\n                }\\n                if(flag)\\n                    Union(x,i);\\n                i++;\\n            }\\n            if(n>2)\\n                Union(x,n);\\n        }\\n        int res=0;\\n        unordered_map<int,int>m;\\n        for(auto x:nums)\\n        {\\n            int pa=find(x);\\n            m[pa]++;\\n            res=max(res,m[pa]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int parent[100001];\\n    int find(int x)\\n    {\\n        if(parent[x]!=x)\\n            parent[x]=find(parent[x]);\\n        return parent[x];\\n    }\\n    void Union(int x,int y)\\n    {\\n        int px=find(x),py=find(y);\\n        parent[py]=px;\\n    }\\n    int largestComponentSize(vector<int>& nums) \\n    {\\n        for(int i=0;i<=100000;i++)\\n            parent[i]=i;\\n        for(auto x:nums)\\n        {\\n            int i=2;\\n            int n=x;\\n            while(i*i<=n)\\n            {\\n                bool flag=false;\\n                while(n%i==0)\\n                {\\n                    flag=true;\\n                    n/=i;\\n                }\\n                if(flag)\\n                    Union(x,i);\\n                i++;\\n            }\\n            if(n>2)\\n                Union(x,n);\\n        }\\n        int res=0;\\n        unordered_map<int,int>m;\\n        for(auto x:nums)\\n        {\\n            int pa=find(x);\\n            m[pa]++;\\n            res=max(res,m[pa]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831987,
                "title": "python-484ms-beats100-unionfind-primedecomposition-explained",
                "content": "\\tfrom collections import defaultdict\\n\\n   \\n\\tclass Solution:\\n\\t\\tMAXA = 100001\\n\\t\\tisPrime=[0 for _ in range(MAXA+1)]\\n\\t\\tisPrime[0]=-1;isPrime[1]=-1 #0 and 1 are not prime numbers\\n\\t\\tfor i in range(2, MAXA):\\n\\t\\t\\tif isPrime[i]==0: #i is prime\\n\\t\\t\\t\\tfor multiple in range(i*i,MAXA+1,i):\\n\\t\\t\\t\\t\\tif isPrime[multiple]==0:\\n\\t\\t\\t\\t\\t\\tisPrime[multiple]=i\\n\\t\\t\\t\\tisPrime[i] = i # let i store itself for consistency\\n\\n\\t\\tdef largestComponentSize(self, A: List[int]) -> int:\\n\\t\\t\\tlabel = defaultdict(int)\\n\\n\\t\\t\\tdef findRoot(key):\\n\\t\\t\\t\\tif label[key] > 0:\\n\\t\\t\\t\\t\\tlabel[key] = findRoot(label[key])\\n\\t\\t\\t\\t\\treturn label[key]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn key\\n\\n\\t\\t\\tdef mergeRoot(k1, k2):\\n\\t\\t\\t\\tr1, r2 = findRoot(k1), findRoot(k2)  \\n\\t\\t\\t\\tif r1 != r2:\\n\\t\\t\\t\\t\\tr1, r2 = min(r1, r2), max(r1, r2)\\n\\t\\t\\t\\t\\tlabel[r1] += label[r2]\\n\\t\\t\\t\\t\\tlabel[r2] = r1\\n\\t\\t\\t\\treturn r1\\n\\n\\t\\t\\tfor x in A:\\n\\t\\t\\t\\troot_id = 0\\n\\t\\t\\t\\twhile Solution.isPrime[x]!=-1:\\n\\t\\t\\t\\t\\tp = Solution.isPrime[x]\\n\\t\\t\\t\\t\\troot_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\\n\\t\\t\\t\\t\\tx //= p\\n\\t\\t\\t\\tlabel[root_id] -= 1\\n\\n\\t\\t\\treturn -min(label.values())\\n# Explaination\\nDenote *MAXA = UpperBound(A)*\\nIn solution.isPrime, the *smallest prime factor* of that number is stored, for prime numbers, the number itself is stored to keep consistency.\\nThe Generation itself takes an upperbound of *NumberOfPrimesLessThan(MAXA)\\\\*MAXA* which is about *MAXA\\\\*log(MAXA)* for non-trivial *MAXA*.\\nBy using that, we could decompose all the numbers simply by looking up the isPrime array recursivly, which would take about *O(log(MAXA)))* time for each prime factor decomposition.\\nFor UnionFind, the merge and ~O(1) time since we maintain the UnionFind to be at most 2 layers, and the merge itself takes O(1) time, the overall time complexity for this solution is *O(N+MAXA\\\\*log(MAXA))*. \\n\\n# Why this is so fast\\nDue to the nature of the leetcode judge machine, the precomputaion part is not counted for the total time spent if you put them in the class part, so the complexity is reduced to O(N) which makes it faster than most solutions. Which means if someone tried to manually calculate all the prime factors for every numebr from 2 to MAXA, he/she can be even faster than this answer, If you put the calculation os isPrime inside the function, it would take ~2000ms to finish,\\n\\n# Alternative solution [980ms beats 99.6%]\\nIf you don\\'t want to play dirty, here\\'s another solution for you:\\n```\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        small_primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317)\\n        label = defaultdict(int)\\n       \\n        def findRoot(key):\\n            if label[key] > 0:\\n                label[key] = findRoot(label[key])\\n                return label[key]\\n            else:\\n                return key\\n        \\n        def mergeRoot(k1, k2):\\n            r1, r2 = findRoot(k1), findRoot(k2)  \\n            if r1 != r2:\\n                r1, r2 = min(r1, r2), max(r1, r2)\\n                label[r1] += label[r2]\\n                label[r2] = r1\\n            return r1\\n\\n        for x in A:\\n            root_id = 0\\n            t = sqrt(x) + 1\\n            for p in small_primes:\\n                if p > t:\\n                    break\\n                elif x % p == 0:\\n                    root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\\n                    while x % p == 0:\\n                        x //= p\\n            if x != 1:\\n                root_id = findRoot(x) if root_id == 0 else mergeRoot(root_id, x)\\n            label[root_id] -= 1\\n        \\n        return -min(label.values())\\n```\\nIn this, we pre-calculated all primes that\\'s smaller that *sqrt(MAXA)*, any number can\\'t be divided by that must be a prime number, which means a new group, and can also be merged using UnionFind. \\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        small_primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317)\\n        label = defaultdict(int)\\n       \\n        def findRoot(key):\\n            if label[key] > 0:\\n                label[key] = findRoot(label[key])\\n                return label[key]\\n            else:\\n                return key\\n        \\n        def mergeRoot(k1, k2):\\n            r1, r2 = findRoot(k1), findRoot(k2)  \\n            if r1 != r2:\\n                r1, r2 = min(r1, r2), max(r1, r2)\\n                label[r1] += label[r2]\\n                label[r2] = r1\\n            return r1\\n\\n        for x in A:\\n            root_id = 0\\n            t = sqrt(x) + 1\\n            for p in small_primes:\\n                if p > t:\\n                    break\\n                elif x % p == 0:\\n                    root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\\n                    while x % p == 0:\\n                        x //= p\\n            if x != 1:\\n                root_id = findRoot(x) if root_id == 0 else mergeRoot(root_id, x)\\n            label[root_id] -= 1\\n        \\n        return -min(label.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831250,
                "title": "python-faster-than-100-union-find-with-sieve-pre-calculation",
                "content": "```\\nclass UF:\\n    def __init__(self,n):\\n        self.p=[i for i in range(n)]  # parent array\\n        self.s=[1]*n  # size array\\n        \\n    def find(self,x): # find the representative/root of x\\n        if self.p[x]!=x:\\n            self.p[x]=self.find(self.p[x])\\n        return self.p[x]\\n\\nclass Solution:\\n    M=100000\\n    sieve=[0]*(M+1) # stores the largest prime divisor of integers up to M\\n    for i in range(2,M+1):\\n        if sieve[i]!=0:\\n            continue\\n        for j in range(1,M//i+1):\\n            sieve[j*i]=i\\n        \\n    def largestComponentSize(self, A: List[int]) -> int:   \\n        g=UF(len(A))\\n        primes=defaultdict(list) # {q:[nums]} list of integers that\\'s divisible by prime q\\n        for i,num in enumerate(A):\\n            while num>1:\\n                q=self.sieve[num]\\n                primes[q].append(i) # add the ith element to be divisible by q\\n                while num%q==0:\\n                    num//=q\\n                    \\n        for l in primes.values():\\n            root=g.find(l[0]) # representative/root of the 1st integer divisible by q\\n            for i in l[1:]: # joins all components with root\\n                node=g.find(i)\\n                if node!=root:\\n                    if g.s[root]<g.s[node]: # connect the smaller set to the larger one (for efficiency)\\n                        root,node=node,root\\n                    g.p[node]=root\\n                    g.s[root]+=g.s[node]\\n        \\n        return max(g.s)\\n```",
                "solutionTags": [],
                "code": "```\\nclass UF:\\n    def __init__(self,n):\\n        self.p=[i for i in range(n)]  # parent array\\n        self.s=[1]*n  # size array\\n        \\n    def find(self,x): # find the representative/root of x\\n        if self.p[x]!=x:\\n            self.p[x]=self.find(self.p[x])\\n        return self.p[x]\\n\\nclass Solution:\\n    M=100000\\n    sieve=[0]*(M+1) # stores the largest prime divisor of integers up to M\\n    for i in range(2,M+1):\\n        if sieve[i]!=0:\\n            continue\\n        for j in range(1,M//i+1):\\n            sieve[j*i]=i\\n        \\n    def largestComponentSize(self, A: List[int]) -> int:   \\n        g=UF(len(A))\\n        primes=defaultdict(list) # {q:[nums]} list of integers that\\'s divisible by prime q\\n        for i,num in enumerate(A):\\n            while num>1:\\n                q=self.sieve[num]\\n                primes[q].append(i) # add the ith element to be divisible by q\\n                while num%q==0:\\n                    num//=q\\n                    \\n        for l in primes.values():\\n            root=g.find(l[0]) # representative/root of the 1st integer divisible by q\\n            for i in l[1:]: # joins all components with root\\n                node=g.find(i)\\n                if node!=root:\\n                    if g.s[root]<g.s[node]: # connect the smaller set to the larger one (for efficiency)\\n                        root,node=node,root\\n                    g.p[node]=root\\n                    g.s[root]+=g.s[node]\\n        \\n        return max(g.s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826136,
                "title": "c-prime-factorization-union-find-similar-to-official-solution",
                "content": "Pairwise iteration leads to TLE, hence we have to use prime factorization.\\n(1) `factored[i]` stores the list of unique prime factors of `A[i]`\\n(2) `primes` stores the unique prime factors of all numbers in `A`, and each prime is assigned an index as value of the map (starting from 0) which corresponds to the index of `pre`\\n(3) Initialize `pre` and apply union find to it, which actually groups all primes. (the number of groups in `pre` is the number of groups in `A`)\\n(4) Since we need to calculate the number of nodes in the largest group, we iterate through `A` again, find the root of `A[i]`, and add it to a counter to count the number.\\n\\n```\\nClass Solution {\\n    int find(int root, vector<int> &pre) {\\n        if (root == pre[root]) return root;\\n        int son = root;\\n        int tmp;\\n        while (root != pre[root]) {\\n            root = pre[root];\\n        }\\n        while (son != root) {\\n            tmp = pre[son];\\n            pre[son] = root;\\n            son = tmp;\\n        }\\n        return root;\\n    }\\n    \\npublic:\\n    int largestComponentSize(vector<int>& A) {\\n        vector<vector<int>> factored(A.size());\\n        for (int i = 0; i < A.size(); i++) {\\n            int d = 2, x = A[i];\\n            while (d*d <= x) {\\n                if (x%d == 0) {\\n                    while (x%d == 0) {\\n                        x /= d;\\n                    }\\n                    factored[i].push_back(d);\\n                }\\n                d++;\\n            }\\n            if (x > 1 || factored[i].size()==0) factored[i].push_back(x);\\n        }\\n        unordered_map<int, int> primes;\\n        int t = 0;\\n        for (auto vec : factored) {\\n            for (int v : vec) {\\n                if (!primes.count(v)) {\\n                    primes[v] = t;\\n                    t++;\\n                }\\n            }\\n        }\\n        vector<int> pre(primes.size());\\n        for (int i = 0; i < pre.size(); i++) {\\n            pre[i] = i;\\n        }\\n        for (int i = 0; i < A.size(); i++) {\\n            if (factored[i].size() < 2) continue;\\n            for (int j = 1; j < factored[i].size(); j++) {\\n                pre[find(primes[factored[i][j]], pre)] = find(primes[factored[i][0]], pre);\\n            }\\n        }\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < A.size(); i++) {\\n            int root = find(primes[factored[i][0]], pre);\\n            if (count.count(root)) count[root] += 1;\\n            else count[root] = 1;\\n        }\\n        int lcs = 0;\\n        for (auto it=count.begin(); it!=count.end(); it++) {\\n            lcs = max(lcs, it->second);\\n        }\\n        return lcs;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nClass Solution {\\n    int find(int root, vector<int> &pre) {\\n        if (root == pre[root]) return root;\\n        int son = root;\\n        int tmp;\\n        while (root != pre[root]) {\\n            root = pre[root];\\n        }\\n        while (son != root) {\\n            tmp = pre[son];\\n            pre[son] = root;\\n            son = tmp;\\n        }\\n        return root;\\n    }\\n    \\npublic:\\n    int largestComponentSize(vector<int>& A) {\\n        vector<vector<int>> factored(A.size());\\n        for (int i = 0; i < A.size(); i++) {\\n            int d = 2, x = A[i];\\n            while (d*d <= x) {\\n                if (x%d == 0) {\\n                    while (x%d == 0) {\\n                        x /= d;\\n                    }\\n                    factored[i].push_back(d);\\n                }\\n                d++;\\n            }\\n            if (x > 1 || factored[i].size()==0) factored[i].push_back(x);\\n        }\\n        unordered_map<int, int> primes;\\n        int t = 0;\\n        for (auto vec : factored) {\\n            for (int v : vec) {\\n                if (!primes.count(v)) {\\n                    primes[v] = t;\\n                    t++;\\n                }\\n            }\\n        }\\n        vector<int> pre(primes.size());\\n        for (int i = 0; i < pre.size(); i++) {\\n            pre[i] = i;\\n        }\\n        for (int i = 0; i < A.size(); i++) {\\n            if (factored[i].size() < 2) continue;\\n            for (int j = 1; j < factored[i].size(); j++) {\\n                pre[find(primes[factored[i][j]], pre)] = find(primes[factored[i][0]], pre);\\n            }\\n        }\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < A.size(); i++) {\\n            int root = find(primes[factored[i][0]], pre);\\n            if (count.count(root)) count[root] += 1;\\n            else count[root] = 1;\\n        }\\n        int lcs = 0;\\n        for (auto it=count.begin(); it!=count.end(); it++) {\\n            lcs = max(lcs, it->second);\\n        }\\n        return lcs;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 822451,
                "title": "fastest-solution-based-on-elements-factorization-disjoint-set-union-union-find",
                "content": "1. Find unique prime factors of each element (brute force, no magic).\\n2. Build directed graph (from indexes of elements in original array A) using https://cp-algorithms.com/data_structures/disjoint_set_union.html\\n3. Count nodes in each connected group\\n4. Return max group size\\n```\\npublic class Solution\\n{\\n    public int LargestComponentSize(int[] A)\\n    {\\n        var parents = new int[A.Length];\\n        var parentByDivisor = new Dictionary<int,int>();\\n        \\n        for(int i=0; i < A.Length; i++)\\n        {\\n            parents[i] = i;\\n            var divs = GetUniqueDivisors(A[i]);\\n\\n            foreach(var divisor in divs)\\n            {\\n                if(parentByDivisor.TryGetValue(divisor, out var p))\\n                {\\n                    var root = FindParent(parents, p);\\n                    parents[root] = i;\\n                }\\n                parentByDivisor[divisor] = i;\\n            }\\n        }\\n\\n        var count = new int[A.Length];\\n        for (int i = 0; i < A.Length; i++)\\n        {\\n            var root = FindParent(parents, i);\\n            count[root]++;\\n        }\\n\\n        return count.Max();\\n    }\\n\\n    private int FindParent(int[] parents, int i)\\n    {\\n        if (parents[i] != i)\\n        {\\n            parents[i] = FindParent(parents, parents[i]);\\n        }\\n\\n        return parents[i];\\n    }\\n\\n    private HashSet<int> GetUniqueDivisors(int x)\\n    {\\n        var result = new HashSet<int>();\\n        \\n        while(x % 2 == 0)\\n        {\\n            result.Add(2);\\n            x >>= 1;\\n        }\\n        \\n        for (int i = 3; i*i <= x; i += 2)\\n        {\\n            while(x % i == 0)\\n            {\\n                result.Add(i);\\n                x /= i;\\n            }\\n        }\\n\\n        if(x > 1) result.Add(x);\\n\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int LargestComponentSize(int[] A)\\n    {\\n        var parents = new int[A.Length];\\n        var parentByDivisor = new Dictionary<int,int>();\\n        \\n        for(int i=0; i < A.Length; i++)\\n        {\\n            parents[i] = i;\\n            var divs = GetUniqueDivisors(A[i]);\\n\\n            foreach(var divisor in divs)\\n            {\\n                if(parentByDivisor.TryGetValue(divisor, out var p))\\n                {\\n                    var root = FindParent(parents, p);\\n                    parents[root] = i;\\n                }\\n                parentByDivisor[divisor] = i;\\n            }\\n        }\\n\\n        var count = new int[A.Length];\\n        for (int i = 0; i < A.Length; i++)\\n        {\\n            var root = FindParent(parents, i);\\n            count[root]++;\\n        }\\n\\n        return count.Max();\\n    }\\n\\n    private int FindParent(int[] parents, int i)\\n    {\\n        if (parents[i] != i)\\n        {\\n            parents[i] = FindParent(parents, parents[i]);\\n        }\\n\\n        return parents[i];\\n    }\\n\\n    private HashSet<int> GetUniqueDivisors(int x)\\n    {\\n        var result = new HashSet<int>();\\n        \\n        while(x % 2 == 0)\\n        {\\n            result.Add(2);\\n            x >>= 1;\\n        }\\n        \\n        for (int i = 3; i*i <= x; i += 2)\\n        {\\n            while(x % i == 0)\\n            {\\n                result.Add(i);\\n                x /= i;\\n            }\\n        }\\n\\n        if(x > 1) result.Add(x);\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822192,
                "title": "simple-c-approach",
                "content": "```\\nclass Solution {\\npublic:\\n   int parent[100001];\\n    int findParent(int child) {\\n        if(parent[child]==-1) return child;\\n        return parent[child] = findParent(parent[child]);\\n    }\\n    void union_value(int child1, int child2) {\\n        int p_value1 = findParent(child1);\\n        int p_value2 = findParent(child2);\\n        if(p_value1 != p_value2) \\n            parent[p_value2] = p_value1;\\n        \\n    }\\n    \\n    int largestComponentSize(vector<int>& A) {\\n        int ans = 0;\\n        memset(parent, -1, sizeof parent);\\n        \\n        for(int x:A) \\n            for(int j=2; j<= sqrt(x); ++j) \\n                if(x%j == 0) \\n                    {union_value(j, x); union_value(x,x/j);}\\n             \\n        unordered_map<int, int> reference;\\n        for(auto child : A) \\n            ans = max(ans, 1 + reference[findParent(child)]++);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   int parent[100001];\\n    int findParent(int child) {\\n        if(parent[child]==-1) return child;\\n        return parent[child] = findParent(parent[child]);\\n    }\\n    void union_value(int child1, int child2) {\\n        int p_value1 = findParent(child1);\\n        int p_value2 = findParent(child2);\\n        if(p_value1 != p_value2) \\n            parent[p_value2] = p_value1;\\n        \\n    }\\n    \\n    int largestComponentSize(vector<int>& A) {\\n        int ans = 0;\\n        memset(parent, -1, sizeof parent);\\n        \\n        for(int x:A) \\n            for(int j=2; j<= sqrt(x); ++j) \\n                if(x%j == 0) \\n                    {union_value(j, x); union_value(x,x/j);}\\n             \\n        unordered_map<int, int> reference;\\n        for(auto child : A) \\n            ans = max(ans, 1 + reference[findParent(child)]++);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820805,
                "title": "python-simple-solution-works-perfectly-on-all-testcases-but-gets-tle-when-submitted",
                "content": "**Can anyone please tell me why I get a TLE when I submit, but if I run each testcase separately it works perfectly ?????**\\n```\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        n = max(A)\\n        prime_list = [0] * n\\n        \\n        def primes():\\n            for num in range(2, n//2+1):\\n                for i in range(2, num // 2 + 1):\\n                    if (num % i) == 0:\\n                        break\\n                else:\\n                    prime_list[num-1] = 1\\n        primes()\\n        \\n        def get_prime_divisors(n):\\n            s = set()\\n            for i in range(2, n//2+1):\\n                if n % i == 0 and prime_list[i-1] == 1:\\n                    s.add(i)\\n            if prime_list[n-1] == 1:\\n                s.add(n)\\n            return s\\n                    \\n        save = defaultdict(set)\\n        for num in A:\\n            s = get_prime_divisors(num)\\n            #print(s)\\n            for prime in s:\\n                save[prime].add(num)\\n                    \\n        for key, val in save.items():\\n            for val2 in save.values():\\n                if len(val & val2) > 0:\\n                    save[key] |= val2\\n\\n        return max([len(x) for x in save.values()])\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        n = max(A)\\n        prime_list = [0] * n\\n        \\n        def primes():\\n            for num in range(2, n//2+1):\\n                for i in range(2, num // 2 + 1):\\n                    if (num % i) == 0:\\n                        break\\n                else:\\n                    prime_list[num-1] = 1\\n        primes()\\n        \\n        def get_prime_divisors(n):\\n            s = set()\\n            for i in range(2, n//2+1):\\n                if n % i == 0 and prime_list[i-1] == 1:\\n                    s.add(i)\\n            if prime_list[n-1] == 1:\\n                s.add(n)\\n            return s\\n                    \\n        save = defaultdict(set)\\n        for num in A:\\n            s = get_prime_divisors(num)\\n            #print(s)\\n            for prime in s:\\n                save[prime].add(num)\\n                    \\n        for key, val in save.items():\\n            for val2 in save.values():\\n                if len(val & val2) > 0:\\n                    save[key] |= val2\\n\\n        return max([len(x) for x in save.values()])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820610,
                "title": "java-union-and-find-technique-maintain-parentmap",
                "content": "```\\nclass Solution {\\n\\t\\n\\tprivate int findParent (int parentKey, HashMap<Integer, Integer> parent) {\\n\\t\\t\\n\\t\\tif (!parent.containsKey (parentKey)) {\\n\\t\\t\\tparent.put (parentKey, parentKey);\\n\\t\\t}\\n\\t\\t\\n\\t\\twhile (parentKey != parent.get (parentKey)) {\\n\\t\\t\\tparentKey = parent.get (parentKey);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn parentKey;\\n\\t}\\n\\t\\n\\tprivate void union (int num, int factor, HashMap<Integer, Integer> parent) {\\n\\t\\t\\n\\t\\tint numParent = findParent (num, parent);\\n\\t\\tint factorParent = findParent (factor, parent);\\n\\t\\t\\n\\t\\tif (numParent < factorParent) {\\n\\t\\t\\tparent.put (factorParent, numParent);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent.put (numParent, factorParent);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic int largestComponentSize (int[] A) {\\n\\t\\t\\n\\t\\tHashMap<Integer, Integer> parent = new HashMap <>();\\n\\t\\t\\n\\t\\tfor (int num : A) {\\n\\t\\t\\tfor (int factor = 2; factor * factor <= num; factor++) {\\t\\n\\t\\t\\t\\tif (num % factor == 0) {\\n\\t\\t\\t\\t\\tunion (num, factor, parent);\\n\\t\\t\\t\\t\\tif (num / factor != factor) {\\n\\t\\t\\t\\t\\t\\tunion (num, num / factor, parent);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tHashMap<Integer, Integer> connectedComponent = new HashMap <>();\\n\\t\\tint maxComponent = 0;\\n\\t\\t\\n\\t\\tfor (int num : A) {\\n\\t\\t\\tint parentKey = findParent (num, parent);\\n\\t\\t\\tconnectedComponent.put (parentKey, connectedComponent.getOrDefault (parentKey, 0) + 1);\\n\\t\\t\\tmaxComponent = Math.max (maxComponent, connectedComponent.get (parentKey));\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn maxComponent;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tprivate int findParent (int parentKey, HashMap<Integer, Integer> parent) {\\n\\t\\t\\n\\t\\tif (!parent.containsKey (parentKey)) {\\n\\t\\t\\tparent.put (parentKey, parentKey);\\n\\t\\t}\\n\\t\\t\\n\\t\\twhile (parentKey != parent.get (parentKey)) {\\n\\t\\t\\tparentKey = parent.get (parentKey);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn parentKey;\\n\\t}\\n\\t\\n\\tprivate void union (int num, int factor, HashMap<Integer, Integer> parent) {\\n\\t\\t\\n\\t\\tint numParent = findParent (num, parent);\\n\\t\\tint factorParent = findParent (factor, parent);\\n\\t\\t\\n\\t\\tif (numParent < factorParent) {\\n\\t\\t\\tparent.put (factorParent, numParent);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent.put (numParent, factorParent);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic int largestComponentSize (int[] A) {\\n\\t\\t\\n\\t\\tHashMap<Integer, Integer> parent = new HashMap <>();\\n\\t\\t\\n\\t\\tfor (int num : A) {\\n\\t\\t\\tfor (int factor = 2; factor * factor <= num; factor++) {\\t\\n\\t\\t\\t\\tif (num % factor == 0) {\\n\\t\\t\\t\\t\\tunion (num, factor, parent);\\n\\t\\t\\t\\t\\tif (num / factor != factor) {\\n\\t\\t\\t\\t\\t\\tunion (num, num / factor, parent);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tHashMap<Integer, Integer> connectedComponent = new HashMap <>();\\n\\t\\tint maxComponent = 0;\\n\\t\\t\\n\\t\\tfor (int num : A) {\\n\\t\\t\\tint parentKey = findParent (num, parent);\\n\\t\\t\\tconnectedComponent.put (parentKey, connectedComponent.getOrDefault (parentKey, 0) + 1);\\n\\t\\t\\tmaxComponent = Math.max (maxComponent, connectedComponent.get (parentKey));\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn maxComponent;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820524,
                "title": "c-dfs-explanation",
                "content": "Create graph using prime factors of every node value.\\nhow can we know that  x & y are same component or not?\\nLet x=12, y=15;\\n\\nprime factor of 12= 2 * 2 * 3 . [[[ so create a bi-coonected graph by each distinct prime factor value. 12->2, 12->3 ]]]\\nprime factor of 15=3 * 5   [[[  15->3, 15->5 ]]]\\n\\nwhen we traverse the graph then 12 and 15 should be in same graph.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>v[100005];\\n    bool seen[100005];\\n    bool have[100005];\\n    int cnt=0;\\n    void dfs(int x)\\n    {\\n        if(seen[x])return;seen[x]=1;\\n        if(have[x]){\\n            cnt++;\\n   \\n        }\\n        for(int i=0;i<v[x].size();i++)dfs(v[x][i]);\\n    }\\n    int largestComponentSize(vector<int>& A) {\\n        for(int i=0;i<A.size();i++)\\n        {\\n            int take=A[i];\\n            have[take]=1;\\n            if(take<2)continue;\\n            for(long j=2;j*j<=(long)take;j++)\\n            {\\n                \\n                if(take%j==0) {\\n                    while(take%j==0){\\n                        take=take/j;\\n                    }\\n                    v[A[i]].push_back(j);\\n                    v[j].push_back(A[i]);\\n                }\\n            }\\n            if(take>1){\\n                v[take].push_back(A[i]);\\n                v[A[i]].push_back(take);\\n            }\\n        }\\n        int mx=0;\\n        for(int i=0;i<A.size();i++) \\n        {\\n            if(seen[A[i]]==0){\\n                cnt=0;\\n                dfs(A[i]);\\n    \\n                mx=max(mx,cnt);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>v[100005];\\n    bool seen[100005];\\n    bool have[100005];\\n    int cnt=0;\\n    void dfs(int x)\\n    {\\n        if(seen[x])return;seen[x]=1;\\n        if(have[x]){\\n            cnt++;\\n   \\n        }\\n        for(int i=0;i<v[x].size();i++)dfs(v[x][i]);\\n    }\\n    int largestComponentSize(vector<int>& A) {\\n        for(int i=0;i<A.size();i++)\\n        {\\n            int take=A[i];\\n            have[take]=1;\\n            if(take<2)continue;\\n            for(long j=2;j*j<=(long)take;j++)\\n            {\\n                \\n                if(take%j==0) {\\n                    while(take%j==0){\\n                        take=take/j;\\n                    }\\n                    v[A[i]].push_back(j);\\n                    v[j].push_back(A[i]);\\n                }\\n            }\\n            if(take>1){\\n                v[take].push_back(A[i]);\\n                v[A[i]].push_back(take);\\n            }\\n        }\\n        int mx=0;\\n        for(int i=0;i<A.size();i++) \\n        {\\n            if(seen[A[i]]==0){\\n                cnt=0;\\n                dfs(A[i]);\\n    \\n                mx=max(mx,cnt);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820436,
                "title": "simple-explanation-with-video-on-disjoint-set-merge-find-union-find",
                "content": "https://www.youtube.com/watch?v=2mva2YRgrW8&list=PLJtzaiEpVo2xu4h0gYQzvOMboclK_pZMe&index=2&t=0\\n\\t\\n\\tclass Solution {\\n\\t\\tpublic int largestComponentSize(int[] A) {\\n\\n\\t\\t\\tint maxVal = Integer.MIN_VALUE;\\n\\t\\t\\tfor (int a : A) {\\n\\t\\t\\t\\tmaxVal = Math.max(maxVal, a);\\n\\t\\t\\t}\\n\\n\\t\\t\\tUnionFind uf=new UnionFind(maxVal+1);\\n\\t\\t\\tfor(int a:A){\\n\\t\\t\\t\\tfor(int i=2;i<=Math.sqrt(a);i++){\\n\\t\\t\\t\\t\\tif(a%i==0){\\n\\t\\t\\t\\t\\t\\tuf.union(a,i);\\n\\t\\t\\t\\t\\t\\tuf.union(a,a/i);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint max=1;\\n\\t\\t\\tMap<Integer, Integer> map = new HashMap<>();\\n\\n\\t\\t\\tfor(int a:A){\\n\\t\\t\\t\\tint parent=uf.find(a);\\n\\t\\t\\t\\tmap.put(parent,map.getOrDefault(parent,0)+1);\\n\\t\\t\\t\\tmax=Math.max(max,map.get(parent));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\n\\t\\tclass UnionFind{\\n\\n\\t\\t\\tint[] ar;\\n\\n\\t\\t\\tUnionFind(int len){\\n\\t\\t\\t\\tar=new int[len];\\n\\t\\t\\t\\tfor(int i=0;i<len;i++){\\n\\t\\t\\t\\t\\tar[i]=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint find(int x){\\n\\t\\t\\t\\tif(x!=ar[x]){\\n\\t\\t\\t\\t\\tar[x]=find(ar[x]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ar[x];\\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid union(int x,int y){\\n\\t\\t\\t\\tar[find(x)]=ar[find(y)];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int largestComponentSize(int[] A) {\\n\\n\\t\\t\\tint maxVal = Integer.MIN_VALUE;\\n\\t\\t\\tfor (int a : A) {\\n\\t\\t\\t\\tmaxVal = Math.max(maxVal, a);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 820431,
                "title": "java-union-find-with-prime-factors-giving-tle",
                "content": "The following code gives TLE. Im unable to figure what i am missing to improve the speed or eleminate any redundant calculations.\\n\\nHelp is much appreciated.\\n\\n\\n```\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n        // Arrays.sort(A);\\n        int[] graph = new int[A.length];\\n        int maxNum = 0;\\n        for (int i=0; i<graph.length; i++) {\\n            graph[i] = i;\\n            maxNum = Math.max(A[i], maxNum == 0 ? A[i] : maxNum);\\n        }\\n        \\n        // System.out.printf(\"max num is %d\\\\n\", maxNum);\\n        boolean[] isNotPrime = new boolean[maxNum + 1];\\n        \\n        for (int i=2; i*2<=maxNum; i++) {\\n            int prev = -1;\\n            if (!isNotPrime[i]) {\\n                for (int j=0; j<A.length; j++) {\\n                    if (A[j]%i == 0) {\\n                        if (prev != -1) {\\n                            this.union(graph, prev, j);\\n                        }\\n                        prev = j;\\n                    }\\n                }\\n                this.markFactors(isNotPrime, i);\\n            }\\n        }\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int maxParentCount = 0;\\n        for (int i=0; i< A.length; i++) {\\n            int parent = this.find(graph, i);\\n            // System.out.printf(\"parent of %d is %d\\\\n\", A[i], A[parent]);\\n            int parentCount = map.getOrDefault(parent, 1);\\n            map.put(parent, parentCount+1);\\n            \\n            maxParentCount = Math.max(parentCount, maxParentCount);\\n        }\\n        \\n        return maxParentCount;\\n    }\\n    \\n    private void markFactors(boolean[] isNotPrime, int n) {\\n        for (int i=n; i<isNotPrime.length; i++) {\\n            if (i%n == 0) {\\n                isNotPrime[i] = true;\\n            }\\n        }\\n    }\\n    \\n    private int find(int[] graph, int k) {\\n        int num = k;\\n        if (graph[k] == k) {\\n            return k;\\n        }\\n        \\n        graph[k] = this.find(graph, graph[k]);\\n        \\n        return graph[k];\\n    }\\n    \\n    private void union(int[] graph, int x, int y) {\\n        int p = this.find(graph, x);\\n        int q = this.find(graph, y);\\n        \\n        if (p == q) {\\n            return;\\n        }\\n        \\n        graph[q] = p;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n        // Arrays.sort(A);\\n        int[] graph = new int[A.length];\\n        int maxNum = 0;\\n        for (int i=0; i<graph.length; i++) {\\n            graph[i] = i;\\n            maxNum = Math.max(A[i], maxNum == 0 ? A[i] : maxNum);\\n        }\\n        \\n        // System.out.printf(\"max num is %d\\\\n\", maxNum);\\n        boolean[] isNotPrime = new boolean[maxNum + 1];\\n        \\n        for (int i=2; i*2<=maxNum; i++) {\\n            int prev = -1;\\n            if (!isNotPrime[i]) {\\n                for (int j=0; j<A.length; j++) {\\n                    if (A[j]%i == 0) {\\n                        if (prev != -1) {\\n                            this.union(graph, prev, j);\\n                        }\\n                        prev = j;\\n                    }\\n                }\\n                this.markFactors(isNotPrime, i);\\n            }\\n        }\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int maxParentCount = 0;\\n        for (int i=0; i< A.length; i++) {\\n            int parent = this.find(graph, i);\\n            // System.out.printf(\"parent of %d is %d\\\\n\", A[i], A[parent]);\\n            int parentCount = map.getOrDefault(parent, 1);\\n            map.put(parent, parentCount+1);\\n            \\n            maxParentCount = Math.max(parentCount, maxParentCount);\\n        }\\n        \\n        return maxParentCount;\\n    }\\n    \\n    private void markFactors(boolean[] isNotPrime, int n) {\\n        for (int i=n; i<isNotPrime.length; i++) {\\n            if (i%n == 0) {\\n                isNotPrime[i] = true;\\n            }\\n        }\\n    }\\n    \\n    private int find(int[] graph, int k) {\\n        int num = k;\\n        if (graph[k] == k) {\\n            return k;\\n        }\\n        \\n        graph[k] = this.find(graph, graph[k]);\\n        \\n        return graph[k];\\n    }\\n    \\n    private void union(int[] graph, int x, int y) {\\n        int p = this.find(graph, x);\\n        int q = this.find(graph, y);\\n        \\n        if (p == q) {\\n            return;\\n        }\\n        \\n        graph[q] = p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820045,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n        Map<Integer, Integer> parent = new HashMap<>();\\n        \\n        for (int num : A) {\\n            for (int fact = 2; fact * fact <= num; fact++) {\\n                if (num % fact == 0) {\\n                    union(num, fact, parent);\\n                    union(num, num/fact, parent);   \\n                }\\n            }\\n        }\\n        \\n        int maxValue = 1;\\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\\n        \\n        for (int num : A) {\\n            int findNum = find(num, parent);\\n            \\n            frequencyMap.put(findNum, frequencyMap.getOrDefault(findNum, 0) + 1);\\n            \\n            maxValue = Math.max(maxValue, frequencyMap.get(findNum));\\n        }\\n        \\n        return maxValue;\\n    }\\n    \\n    private void union(int n, int m, Map<Integer, Integer> parent) {\\n        int findN = find(n, parent);\\n        int findM = find(m, parent);\\n        \\n        if (findN < findM) parent.put(findM, findN);\\n        else parent.put(findN, findM);\\n    }\\n    \\n    private int find(int num, Map<Integer, Integer> parent) {\\n        if (parent.get(num) == null) parent.put(num, num);\\n        \\n        while (num != parent.get(num)) num = parent.get(num);\\n        \\n        return num;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int largestComponentSize(int[] A) {\\n        Map<Integer, Integer> parent = new HashMap<>();\\n        \\n        for (int num : A) {\\n            for (int fact = 2; fact * fact <= num; fact++) {\\n                if (num % fact == 0) {\\n                    union(num, fact, parent);\\n                    union(num, num/fact, parent);   \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 660072,
                "title": "python3-concise-and-small-easy-to-understand-unlike-other-solutions",
                "content": "```\\ndef largestComponentSize(self, a: List[int]) -> int:\\n\\td = {}    # simple union find data structure\\n\\tdef find(x):\\n\\t\\tif x != d.setdefault(x,x):\\n\\t\\t\\td[x] = find(d[x])\\n\\t\\treturn d[x]\\n\\tdef union(x,y):\\n\\t\\td[find(x)]=find(y)\\n\\n\\tfor n in a:\\n\\t\\tfor i in range(2,int(n**0.5)+1): #just connect all the factors of the number  to the number\\n\\t\\t\\tif n%i: continue\\n\\t\\t\\tunion(n,i)  \\n\\t\\t\\tunion(n,n//i)\\n\\n\\tcounter = Counter(find(i) for i in a) \\n\\treturn max(counter.values())  # return the parent with maximum children\\n        \\n```",
                "solutionTags": [],
                "code": "```\\ndef largestComponentSize(self, a: List[int]) -> int:\\n\\td = {}    # simple union find data structure\\n\\tdef find(x):\\n\\t\\tif x != d.setdefault(x,x):\\n\\t\\t\\td[x] = find(d[x])\\n\\t\\treturn d[x]\\n\\tdef union(x,y):\\n\\t\\td[find(x)]=find(y)\\n\\n\\tfor n in a:\\n\\t\\tfor i in range(2,int(n**0.5)+1): #just connect all the factors of the number  to the number\\n\\t\\t\\tif n%i: continue\\n\\t\\t\\tunion(n,i)  \\n\\t\\t\\tunion(n,n//i)\\n\\n\\tcounter = Counter(find(i) for i in a) \\n\\treturn max(counter.values())  # return the parent with maximum children\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 592210,
                "title": "java-union-find-sol",
                "content": "```\\nclass Solution {\\n    Map<Integer,Integer>map=new HashMap<>();\\n    Map<Integer,Integer>rootmap=new HashMap<>();\\n    int nums[];\\n    public int largestComponentSize(int[] A) {\\n        int max=0;\\n        int res=0;\\n        for(int n:A)max=Math.max(max,n);\\n        nums=new int[max+1];\\n        for(int i=0;i<nums.length;i++)nums[i]=i;\\n        for(int n:A){\\n            List<Integer>list=new ArrayList<>();\\n            for(int i=2;i*i<=n;i++){\\n                if(n%i==0){\\n                    list.add(i);\\n                    list.add(n/i);\\n                }\\n            }\\n            list.add(n);\\n            for(int i=1;i<list.size();i++){\\n                int r1=find(nums,list.get(i-1));\\n                int r2=find(nums,list.get(i));\\n                if(r1!=r2)nums[r2]=r1;\\n            }\\n            int last=list.get(list.size()-1);\\n            if(!map.containsKey(last))map.put(last,0);\\n            map.put(last,map.get(last)+1);\\n        }\\n        for(Integer prime:map.keySet()){\\n            int r=find(nums,prime);\\n            if(!rootmap.containsKey(r))rootmap.put(r,0);\\n            rootmap.put(r,rootmap.get(r)+map.get(prime));\\n        }\\n        for(Integer key:rootmap.keySet()){\\n            res=Math.max(res,rootmap.get(key));\\n        }\\n        return res;\\n    }\\n    public int find(int nums[],int x){\\n        if(nums[x]==x)return x;\\n        int root=find(nums,nums[x]);\\n        nums[x]=root;\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer,Integer>map=new HashMap<>();\\n    Map<Integer,Integer>rootmap=new HashMap<>();\\n    int nums[];\\n    public int largestComponentSize(int[] A) {\\n        int max=0;\\n        int res=0;\\n        for(int n:A)max=Math.max(max,n);\\n        nums=new int[max+1];\\n        for(int i=0;i<nums.length;i++)nums[i]=i;\\n        for(int n:A){\\n            List<Integer>list=new ArrayList<>();\\n            for(int i=2;i*i<=n;i++){\\n                if(n%i==0){\\n                    list.add(i);\\n                    list.add(n/i);\\n                }\\n            }\\n            list.add(n);\\n            for(int i=1;i<list.size();i++){\\n                int r1=find(nums,list.get(i-1));\\n                int r2=find(nums,list.get(i));\\n                if(r1!=r2)nums[r2]=r1;\\n            }\\n            int last=list.get(list.size()-1);\\n            if(!map.containsKey(last))map.put(last,0);\\n            map.put(last,map.get(last)+1);\\n        }\\n        for(Integer prime:map.keySet()){\\n            int r=find(nums,prime);\\n            if(!rootmap.containsKey(r))rootmap.put(r,0);\\n            rootmap.put(r,rootmap.get(r)+map.get(prime));\\n        }\\n        for(Integer key:rootmap.keySet()){\\n            res=Math.max(res,rootmap.get(key));\\n        }\\n        return res;\\n    }\\n    public int find(int nums[],int x){\\n        if(nums[x]==x)return x;\\n        int root=find(nums,nums[x]);\\n        nums[x]=root;\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 341206,
                "title": "c-solution-prime-factorization-union-find",
                "content": "```\\npublic class Solution \\n{\\n    private  Dictionary<int, int> dict = new Dictionary<int, int>();\\n    private  Dictionary<int, int> count = new Dictionary<int, int>();\\n    private  Dictionary<int, List<int>> group = new Dictionary<int, List<int>>();\\n    public int LargestComponentSize(int[] a) \\n    {\\n        var primes = new HashSet<int>();\\n        var isPrime = Enumerable.Repeat(true, 100001).ToArray();\\n        for (int i = 2; i <= 100000; i++) \\n        {\\n            if (isPrime[i]) \\n            {\\n                primes.Add(i);\\n                for (int j = 2; j * i <= 100000; j++) isPrime[j * i] = false;\\n            }\\n        }\\n        \\n        foreach(var num in a)\\n        {\\n            int n = num;\\n            foreach(var prime in primes)\\n            {\\n                if(prime > n) break;\\n                else if(primes.Contains(n))\\n                {\\n                    if(!group.ContainsKey(n)) group[n] = new List<int>();\\n                    group[n].Add(num);\\n                    break;\\n                }\\n                else if(n % prime == 0)\\n                {\\n                    if(!group.ContainsKey(prime)) group[prime] = new List<int>();\\n                    group[prime].Add(num);\\n                    n = n / prime;\\n                }\\n            }\\n        }\\n        \\n       foreach(var kvp in group)\\n       {\\n           var l = kvp.Value;\\n           for(int i = 0; i < l.Count -1 ; i++)\\n           {\\n               int j = i + 1;\\n               int p1 = GetParent(l[i]), p2 = GetParent(l[j]);\\n               if(p1 != p2)\\n               {\\n                    dict[p1] = p2;\\n                    count[p2] = count[p1] + count[p2];\\n                }\\n            }\\n        }\\n        \\n        return count.Values.Max();\\n    }\\n    \\n    private int GetParent( int n)\\n    {\\n       if(!dict.ContainsKey(n))\\n       {\\n           dict[n] = n;\\n           count[n] = 1;\\n       }\\n        if(dict[n] != n) dict[n] = GetParent(dict[n]);\\n        return dict[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    private  Dictionary<int, int> dict = new Dictionary<int, int>();\\n    private  Dictionary<int, int> count = new Dictionary<int, int>();\\n    private  Dictionary<int, List<int>> group = new Dictionary<int, List<int>>();\\n    public int LargestComponentSize(int[] a) \\n    {\\n        var primes = new HashSet<int>();\\n        var isPrime = Enumerable.Repeat(true, 100001).ToArray();\\n        for (int i = 2; i <= 100000; i++) \\n        {\\n            if (isPrime[i]) \\n            {\\n                primes.Add(i);\\n                for (int j = 2; j * i <= 100000; j++) isPrime[j * i] = false;\\n            }\\n        }\\n        \\n        foreach(var num in a)\\n        {\\n            int n = num;\\n            foreach(var prime in primes)\\n            {\\n                if(prime > n) break;\\n                else if(primes.Contains(n))\\n                {\\n                    if(!group.ContainsKey(n)) group[n] = new List<int>();\\n                    group[n].Add(num);\\n                    break;\\n                }\\n                else if(n % prime == 0)\\n                {\\n                    if(!group.ContainsKey(prime)) group[prime] = new List<int>();\\n                    group[prime].Add(num);\\n                    n = n / prime;\\n                }\\n            }\\n        }\\n        \\n       foreach(var kvp in group)\\n       {\\n           var l = kvp.Value;\\n           for(int i = 0; i < l.Count -1 ; i++)\\n           {\\n               int j = i + 1;\\n               int p1 = GetParent(l[i]), p2 = GetParent(l[j]);\\n               if(p1 != p2)\\n               {\\n                    dict[p1] = p2;\\n                    count[p2] = count[p1] + count[p2];\\n                }\\n            }\\n        }\\n        \\n        return count.Values.Max();\\n    }\\n    \\n    private int GetParent( int n)\\n    {\\n       if(!dict.ContainsKey(n))\\n       {\\n           dict[n] = n;\\n           count[n] = 1;\\n       }\\n        if(dict[n] != n) dict[n] = GetParent(dict[n]);\\n        return dict[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296150,
                "title": "python-940-ms-95-efficient-factorization-o-m-log-m-2-where-m-is-largest-element",
                "content": "```\\nfrom collections import defaultdict\\n\\n# to factorize k numbers below N, if k is almost as big as N,\\n# it is more efficient to factorize all numbers by sieving\\n# to save space, only keep an array of the smallest factor for each number\\ndef factorList(n):\\n    lst=[0]*(n+1)\\n    lst[1]=1\\n    for i in range(2,n+1):\\n        if lst[i]==0:\\n            for j in range(i,n+1,i):\\n                lst[j]=i\\n    return lst\\n    \\n\\ndef factors(faclist,n):\\n    while n>1:\\n        curr=faclist[n]\\n        yield curr\\n        n//=curr\\n    \\n# union find from https://medium.com/100-days-of-algorithms/day-41-union-find-d0027148376d\\n# with path compression\\ndef find(data, i):\\n    if i != data[i]:\\n        data[i] = find(data, data[i])\\n    return data[i]\\n\\ndef union(data, i, j):\\n    pi, pj = find(data, i), find(data, j)\\n    if pi != pj:\\n        data[pi] = pj\\n    \\n\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        faclist=factorList(max(A))\\n        # for each prime number save a\\n        # representative, so that we have\\n        # a candidate to \"union\" on\\n        repre={}\\n        data={x:x for x in A}\\n        for n in A:\\n            for fac in factors(faclist,n):\\n                if fac in repre:\\n                    union(data,n,repre[fac])\\n                else:\\n                    repre[fac]=n\\n        counter=defaultdict(lambda :0)\\n        for n in A:\\n            counter[find(data,n)]+=1\\n        return max(counter.values())\\n```\\nlet m be the maximum of all input numbers and n ( so A[i]<m for all i and n<m)\\nthe leading factor in the complexity is the itertion over all distinct prime factors. There are O(m*log(log(m))) such factors at most.\\nfor each factor a \"union\" is done. since union with path compression is at least O(n*log(n)) for n operations, the overall complexity is better than O(m*log(m)^2)",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\n# to factorize k numbers below N, if k is almost as big as N,\\n# it is more efficient to factorize all numbers by sieving\\n# to save space, only keep an array of the smallest factor for each number\\ndef factorList(n):\\n    lst=[0]*(n+1)\\n    lst[1]=1\\n    for i in range(2,n+1):\\n        if lst[i]==0:\\n            for j in range(i,n+1,i):\\n                lst[j]=i\\n    return lst\\n    \\n\\ndef factors(faclist,n):\\n    while n>1:\\n        curr=faclist[n]\\n        yield curr\\n        n//=curr\\n    \\n# union find from https://medium.com/100-days-of-algorithms/day-41-union-find-d0027148376d\\n# with path compression\\ndef find(data, i):\\n    if i != data[i]:\\n        data[i] = find(data, data[i])\\n    return data[i]\\n\\ndef union(data, i, j):\\n    pi, pj = find(data, i), find(data, j)\\n    if pi != pj:\\n        data[pi] = pj\\n    \\n\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        faclist=factorList(max(A))\\n        # for each prime number save a\\n        # representative, so that we have\\n        # a candidate to \"union\" on\\n        repre={}\\n        data={x:x for x in A}\\n        for n in A:\\n            for fac in factors(faclist,n):\\n                if fac in repre:\\n                    union(data,n,repre[fac])\\n                else:\\n                    repre[fac]=n\\n        counter=defaultdict(lambda :0)\\n        for n in A:\\n            counter[find(data,n)]+=1\\n        return max(counter.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 261572,
                "title": "straight-forward-python-solution",
                "content": "```\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        factors = collections.defaultdict(set)\\n        uf = Union_find()\\n        for num in A:\\n            for i in range(2, int(math.sqrt(num)+1), 1):\\n                if num % i == 0:\\n                    uf.union(num, i)\\n                    uf.union(num, num//i)\\n        \\n        count = {}\\n        for num in A:\\n            parent = uf.find(num)\\n            if parent not in count:\\n                count[uf.find(num)] =1\\n            else:\\n                count[uf.find(num)] += 1\\n        \\n        return max(count.values())\\n\\nclass Union_find():\\n    def __init__(self):\\n        self.parents = {}\\n    \\n    def make_set(self, x):\\n        if x not in self.parents:\\n            self.parents[x] = x\\n    \\n    def find(self, x):\\n        if x not in self.parents:\\n            self.make_set(x)\\n            return x\\n        elif self.parents[x] is x:\\n            return x\\n        self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n    \\n    def union(self, x, y):\\n        px = self.find(x)\\n        py = self.find(y)\\n        if px == py:\\n            return \\n\\n        self.parents[px] = py\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        factors = collections.defaultdict(set)\\n        uf = Union_find()\\n        for num in A:\\n            for i in range(2, int(math.sqrt(num)+1), 1):\\n                if num % i == 0:\\n                    uf.union(num, i)\\n                    uf.union(num, num//i)\\n        \\n        count = {}\\n        for num in A:\\n            parent = uf.find(num)\\n            if parent not in count:\\n                count[uf.find(num)] =1\\n            else:\\n                count[uf.find(num)] += 1\\n        \\n        return max(count.values())\\n\\nclass Union_find():\\n    def __init__(self):\\n        self.parents = {}\\n    \\n    def make_set(self, x):\\n        if x not in self.parents:\\n            self.parents[x] = x\\n    \\n    def find(self, x):\\n        if x not in self.parents:\\n            self.make_set(x)\\n            return x\\n        elif self.parents[x] is x:\\n            return x\\n        self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n    \\n    def union(self, x, y):\\n        px = self.find(x)\\n        py = self.find(y)\\n        if px == py:\\n            return \\n\\n        self.parents[px] = py\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 201122,
                "title": "finally-passed-try-many-many-times-c-code-may-help-you-to-solve-your-tle",
                "content": "```\\n    int find(vector<int> &parent, int a) {\\n        if (parent[a] != a) parent[a] = find(parent, parent[a]);\\n        return parent[a];\\n    }\\n    \\n    int largestComponentSize(vector<int>& A) {\\n        int i, j, n, m, max_num = -1;\\n        int res = 1;\\n        vector<int> parent(A.size(), 0);\\n        vector<int> count(A.size(), 1);\\n        \\n        for(i = 0; i < A.size(); ++i) {\\n            parent[i] = i;\\n            max_num = max(max_num, A[i]);\\n        }\\n        \\n        vector<vector<int>> prime(max_num + 1, vector<int>());\\n        \\n        // This is the most time consuming part, so please not do it multi-times like the following one\\n        // First compute all the prime smaller than 100000\\n        // Second check which prime is the prime factor of A[i]\\n\\t// Because we can do them in one loop\\n        for(i = 0; i < A.size(); ++i) {\\n            // this part is very important, especially j * j <= A[i]\\n            for(j = 2; j * j <= A[i]; ++j) {\\n                if(A[i] % j) continue;\\n                // This is a little trick, the j must be a prime at this stage\\n                // Because in pervious loops: while(A[i] % j == 0) A[i] /= j;\\n                prime[j].push_back(i);\\n                while(A[i] % j == 0) A[i] /= j;\\n            }\\n            if (A[i] > 1) prime[A[i]].push_back(i);\\n            \\n            // if you write the code like this, it will get TLE\\n            /*for(j = 2; j <= A[i]; ++j) {\\n                if(A[i] % j) continue;\\n                prime[j].push_back(i);\\n                while(A[i] % j == 0) A[i] /= j;\\n            }*/\\n        }\\n        \\n        /*\\n        // This is the code will get TLE\\n        // Firstly, compute all the prime smaller than 100000\\n        vector<int> prime_num;\\n        for(i = 2; i <= max_num; ++i) {\\n            for(j = 0; j < prime_num.size(); ++j) {\\n                if(i % prime_num[j] == 0) break;\\n            }\\n            if(j == prime_num.size()) prime_num.push_back(i);\\n        }\\n        \\n        // Secondly, check which prime is the prime factor of A[i]\\n        for(i = 0; i < A.size(); ++i) {\\n            for(j = 0; j < prime_num.size(); ++j) {\\n                if(A[i] < prime_num[j] * prime_num[j]) break;\\n                if(A[i] % prime_num[j]) continue;\\n                prime[prime_num[j]].push_back(i);\\n                while(A[i] % prime_num[j] == 0) A[i] /= prime_num[j];\\n            }\\n            if (A[i] > 1) prime[A[i]].push_back(i);\\n        }\\n        */\\n        \\n        for(i = 2; i < prime.size(); ++i) {\\n            if(prime[i].size() < 2) continue;\\n            n = find(parent, prime[i][0]);\\n            for(j = 1; j < prime[i].size(); ++j) {\\n                m = find(parent, prime[i][j]);\\n                if(m != n) {\\n                    parent[m] = n;\\n                    count[n] += count[m];\\n                    res = max(res, count[n]);\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int find(vector<int> &parent, int a) {\\n        if (parent[a] != a) parent[a] = find(parent, parent[a]);\\n        return parent[a];\\n    }\\n    \\n    int largestComponentSize(vector<int>& A) {\\n        int i, j, n, m, max_num = -1;\\n        int res = 1;\\n        vector<int> parent(A.size(), 0);\\n        vector<int> count(A.size(), 1);\\n        \\n        for(i = 0; i < A.size(); ++i) {\\n            parent[i] = i;\\n            max_num = max(max_num, A[i]);\\n        }\\n        \\n        vector<vector<int>> prime(max_num + 1, vector<int>());\\n        \\n        // This is the most time consuming part, so please not do it multi-times like the following one\\n        // First compute all the prime smaller than 100000\\n        // Second check which prime is the prime factor of A[i]\\n\\t// Because we can do them in one loop\\n        for(i = 0; i < A.size(); ++i) {\\n            // this part is very important, especially j * j <= A[i]\\n            for(j = 2; j * j <= A[i]; ++j) {\\n                if(A[i] % j) continue;\\n                // This is a little trick, the j must be a prime at this stage\\n                // Because in pervious loops: while(A[i] % j == 0) A[i] /= j;\\n                prime[j].push_back(i);\\n                while(A[i] % j == 0) A[i] /= j;\\n            }\\n            if (A[i] > 1) prime[A[i]].push_back(i);\\n            \\n            // if you write the code like this, it will get TLE\\n            /*for(j = 2; j <= A[i]; ++j) {\\n                if(A[i] % j) continue;\\n                prime[j].push_back(i);\\n                while(A[i] % j == 0) A[i] /= j;\\n            }*/\\n        }\\n        \\n        /*\\n        // This is the code will get TLE\\n        // Firstly, compute all the prime smaller than 100000\\n        vector<int> prime_num;\\n        for(i = 2; i <= max_num; ++i) {\\n            for(j = 0; j < prime_num.size(); ++j) {\\n                if(i % prime_num[j] == 0) break;\\n            }\\n            if(j == prime_num.size()) prime_num.push_back(i);\\n        }\\n        \\n        // Secondly, check which prime is the prime factor of A[i]\\n        for(i = 0; i < A.size(); ++i) {\\n            for(j = 0; j < prime_num.size(); ++j) {\\n                if(A[i] < prime_num[j] * prime_num[j]) break;\\n                if(A[i] % prime_num[j]) continue;\\n                prime[prime_num[j]].push_back(i);\\n                while(A[i] % prime_num[j] == 0) A[i] /= prime_num[j];\\n            }\\n            if (A[i] > 1) prime[A[i]].push_back(i);\\n        }\\n        */\\n        \\n        for(i = 2; i < prime.size(); ++i) {\\n            if(prime[i].size() < 2) continue;\\n            n = find(parent, prime[i][0]);\\n            for(j = 1; j < prime[i].size(); ++j) {\\n                m = find(parent, prime[i][j]);\\n                if(m != n) {\\n                    parent[m] = n;\\n                    count[n] += count[m];\\n                    res = max(res, count[n]);\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 200842,
                "title": "tle-exact-same-algorithm-in-ruby-and-c",
                "content": "Hey, I was trying to do everything in ruby just for fun and realised even though my algorithm is good enough (Union Find and Factorization) in Ruby (probably due to high constant time instead of asymptotic complexity) I receive a TLE.\\n\\nI used a weighted union find with path compression.\\n\\nI\\'ve reimplemented the same algorithm in C# and got an accepted.\\n\\nHere are the algorithms (My attempt during the contest was using BFS + Factorization, but this was inspired by neal_wu submission, so I was not the \"creator\" of this approach)\\n\\nThe Ruby version (which received TLE):\\n\\n```\\nclass UnionFind\\n  def initialize(n)\\n    @id = (0..n-1).to_a\\n    @sz = @id.map{1}\\n  end\\n  \\n  def largest_size\\n    @sz.max\\n  end\\n  \\n  def unite(p, q)\\n    i = root(p)\\n    j = root(q)\\n    return if i == j\\n    \\n    if @sz[i] < @sz[j]\\n      @id[i] = j\\n      @sz[j] += @sz[i]\\n    else\\n      @id[j] = i\\n      @sz[i] += @sz[j]\\n    end\\n  end\\n  \\n  private\\n  \\n  def root(i)\\n    while i != @id[i]\\n      @id[i] = @id[@id[i]]\\n      i = @id[i]\\n    end\\n    i\\n  end\\nend\\n\\nclass Sieve\\n  def initialize(n)\\n    @lf = (0..n).map{-1}\\n    \\n    (2..n).each do |i|\\n      (i..n).step(i).each{|j| @lf[j] = i} if @lf[i] == -1\\n    end\\n  end\\n  \\n  def prime?(i)\\n    @lf[i] == i\\n  end\\n  \\n  def lowest_factor(i)\\n    @lf[i]\\n  end\\nend\\n\\nMAX = 100000\\n\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef largest_component_size(a)\\n  sieve = Sieve.new(MAX)\\n  uf = UnionFind.new(a.length)\\n  prime_to_index = (0..MAX).map{-1}\\n  \\n  a.each.with_index do |x, i|\\n    while x != 1\\n      p = sieve.lowest_factor(x)\\n      if prime_to_index[p] != -1\\n        uf.unite(i, prime_to_index[p])\\n      else\\n        prime_to_index[p] = i\\n      end\\n      \\n      loop do\\n        x /= p\\n        break if x % p != 0\\n      end\\n    end\\n  end\\n  \\n  uf.largest_size\\nend\\n```\\n\\nThe C# version:\\n\\n```\\nclass UnionFind {\\n  private int[] id;\\n  private int[] sz;\\n  \\n  public UnionFind(int n) {\\n    this.id = new int[n];\\n    this.sz = new int[n];\\n    for(int i = 0; i < n; i++){\\n      this.id[i] = i;\\n      this.sz[i] = 1;\\n    }\\n  }\\n  \\n  public int LargestSize() {\\n    int max = 1;\\n    for(int i = 0; i < this.sz.Length; i++) {\\n      if(this.sz[i] > max) max = this.sz[i];\\n    }\\n    return max;\\n  }\\n  \\n  public void Unite(int p, int q) {\\n    int i = this.Root(p);\\n    int j = this.Root(q);\\n    \\n    if (i == j) return;\\n    \\n    if(this.sz[i] < this.sz[j]) {\\n      this.id[i] = j;\\n      this.sz[j] += this.sz[i];\\n    } else {\\n      this.id[j] = i;\\n      this.sz[i] += this.sz[j];\\n    }\\n  }\\n\\n  private int Root(int i) {\\n    while(i != this.id[i]){\\n      this.id[i] = this.id[this.id[i]];\\n      i = this.id[i];\\n    }\\n    return i;\\n  }\\n}\\n\\npublic class Solution {\\n  public int LargestComponentSize(int[] A) {\\n    var lowest_factor = new int[100001];\\n    initializeSieve(lowest_factor);\\n    \\n    var uf = new UnionFind(A.Length);\\n    \\n    var primeToIndex = new int[100001];\\n    Array.Fill(primeToIndex, -1);\\n    \\n    for(int i = 0; i < A.Length; i++) {\\n      int x = A[i];\\n      while(x > 1){\\n        int p = lowest_factor[x];\\n        \\n        if(primeToIndex[p] == -1) {\\n          primeToIndex[p] = i;\\n        } else {\\n          uf.Unite(i, primeToIndex[p]);\\n        }\\n        \\n        while(x % p == 0) x /= p;\\n      }\\n    }\\n    \\n    return uf.LargestSize();\\n  }\\n  \\n  private void initializeSieve(int[] lowest_factor) {\\n    for(int i = 0; i <= 100000; i++) lowest_factor[i] = -1;\\n    \\n    for(int i = 2; i <= 100000; i++) {\\n      if (lowest_factor[i] == -1) {\\n        for(int j = i; j <= 100000; j = j + i) lowest_factor[j] = i;\\n      }\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind\\n  def initialize(n)\\n    @id = (0..n-1).to_a\\n    @sz = @id.map{1}\\n  end\\n  \\n  def largest_size\\n    @sz.max\\n  end\\n  \\n  def unite(p, q)\\n    i = root(p)\\n    j = root(q)\\n    return if i == j\\n    \\n    if @sz[i] < @sz[j]\\n      @id[i] = j\\n      @sz[j] += @sz[i]\\n    else\\n      @id[j] = i\\n      @sz[i] += @sz[j]\\n    end\\n  end\\n  \\n  private\\n  \\n  def root(i)\\n    while i != @id[i]\\n      @id[i] = @id[@id[i]]\\n      i = @id[i]\\n    end\\n    i\\n  end\\nend\\n\\nclass Sieve\\n  def initialize(n)\\n    @lf = (0..n).map{-1}\\n    \\n    (2..n).each do |i|\\n      (i..n).step(i).each{|j| @lf[j] = i} if @lf[i] == -1\\n    end\\n  end\\n  \\n  def prime?(i)\\n    @lf[i] == i\\n  end\\n  \\n  def lowest_factor(i)\\n    @lf[i]\\n  end\\nend\\n\\nMAX = 100000\\n\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef largest_component_size(a)\\n  sieve = Sieve.new(MAX)\\n  uf = UnionFind.new(a.length)\\n  prime_to_index = (0..MAX).map{-1}\\n  \\n  a.each.with_index do |x, i|\\n    while x != 1\\n      p = sieve.lowest_factor(x)\\n      if prime_to_index[p] != -1\\n        uf.unite(i, prime_to_index[p])\\n      else\\n        prime_to_index[p] = i\\n      end\\n      \\n      loop do\\n        x /= p\\n        break if x % p != 0\\n      end\\n    end\\n  end\\n  \\n  uf.largest_size\\nend\\n```\n```\\nclass UnionFind {\\n  private int[] id;\\n  private int[] sz;\\n  \\n  public UnionFind(int n) {\\n    this.id = new int[n];\\n    this.sz = new int[n];\\n    for(int i = 0; i < n; i++){\\n      this.id[i] = i;\\n      this.sz[i] = 1;\\n    }\\n  }\\n  \\n  public int LargestSize() {\\n    int max = 1;\\n    for(int i = 0; i < this.sz.Length; i++) {\\n      if(this.sz[i] > max) max = this.sz[i];\\n    }\\n    return max;\\n  }\\n  \\n  public void Unite(int p, int q) {\\n    int i = this.Root(p);\\n    int j = this.Root(q);\\n    \\n    if (i == j) return;\\n    \\n    if(this.sz[i] < this.sz[j]) {\\n      this.id[i] = j;\\n      this.sz[j] += this.sz[i];\\n    } else {\\n      this.id[j] = i;\\n      this.sz[i] += this.sz[j];\\n    }\\n  }\\n\\n  private int Root(int i) {\\n    while(i != this.id[i]){\\n      this.id[i] = this.id[this.id[i]];\\n      i = this.id[i];\\n    }\\n    return i;\\n  }\\n}\\n\\npublic class Solution {\\n  public int LargestComponentSize(int[] A) {\\n    var lowest_factor = new int[100001];\\n    initializeSieve(lowest_factor);\\n    \\n    var uf = new UnionFind(A.Length);\\n    \\n    var primeToIndex = new int[100001];\\n    Array.Fill(primeToIndex, -1);\\n    \\n    for(int i = 0; i < A.Length; i++) {\\n      int x = A[i];\\n      while(x > 1){\\n        int p = lowest_factor[x];\\n        \\n        if(primeToIndex[p] == -1) {\\n          primeToIndex[p] = i;\\n        } else {\\n          uf.Unite(i, primeToIndex[p]);\\n        }\\n        \\n        while(x % p == 0) x /= p;\\n      }\\n    }\\n    \\n    return uf.LargestSize();\\n  }\\n  \\n  private void initializeSieve(int[] lowest_factor) {\\n    for(int i = 0; i <= 100000; i++) lowest_factor[i] = -1;\\n    \\n    for(int i = 2; i <= 100000; i++) {\\n      if (lowest_factor[i] == -1) {\\n        for(int j = i; j <= 100000; j = j + i) lowest_factor[j] = i;\\n      }\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200838,
                "title": "java-factorization-dfs-with-explanation",
                "content": "\\nUpdate: Here is a more efficient solution: https://leetcode.com/problems/largest-component-size-by-common-factor/discuss/200923/Prime-Factorization-%2B-DFS-350ms-java\\n\\nProblem consists of two parts:\\n\\ni) Factorize all numbers in A and build a graph.\\nii) find biggest island\\n\\nFactorization for a single integer can be done in `O(sqrt(n))`. A tip here is to iterate until `Math.sqrt(n)` since when you find a factor `f` in that range, you also find the other factor which is `a / f`.\\n\\nCreate `Node` for every item in array and every factor you find and connect them. one thing to keep in mind is factors may or may not exist in array `A` therefore Node has `exists` flag. \\n\\nDo a DFS to find the biggest connected island. Skip the Nodes that do not exist while counting.\\n\\nRuntime : `O(k sqrt(n))` \\nk: # of elements in A + their factors\\nn: largest integer in A\\n\\n```java\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n    \\n        Map<Integer, Node> nodes = new HashMap<>();\\n        for (int a : A) nodes.put(a, new Node(a));\\n        for (int a : A) connectFactorsOf(a, nodes);\\n        \\n        Set<Node> visited = new HashSet<>();\\n        int max = 0;\\n        for (Node n : nodes.values()) {\\n            max = Math.max(max, sink(n, visited));\\n        }\\n        return max;\\n    }\\n    \\n    private int sink(Node n, Set<Node> visited) {\\n        if (visited.contains(n)) return 0;\\n        visited.add(n);\\n        \\n        int count = n.exists ? 1 : 0;\\n        for (Node next : n.neighbors) {\\n            count += sink(next, visited);\\n        }\\n        return count;\\n    }\\n    \\n    private void connectFactorsOf(int a, Map<Integer,Node> nodes) {\\n        Node self = nodes.get(a);\\n        \\n        for (int i=2; i <= (int) Math.sqrt(a); i++) {\\n            if (a%i == 0) {\\n                Node factor = nodes.get(i);\\n                factor = factor == null ? new Node(i, false) : factor;\\n                factor.neighbors.add(self);\\n                self.neighbors.add(factor);\\n                \\n                nodes.put(i, factor);\\n                \\n                int other = a/i;\\n                factor = nodes.get(other);\\n                factor = factor == null ? new Node(other, false) : factor;\\n                factor.neighbors.add(self);\\n                self.neighbors.add(factor);\\n                \\n                nodes.put(other, factor);\\n                \\n            }\\n        }\\n    }\\n    \\n    public class Node {\\n        int val;\\n        boolean exists;\\n        Set<Node> neighbors = new HashSet<>();\\n        \\n        public Node(int val) {this(val, true);}\\n        public Node(int val, boolean exists) {\\n            this.val = val;\\n            this.exists = exists;\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n    \\n        Map<Integer, Node> nodes = new HashMap<>();\\n        for (int a : A) nodes.put(a, new Node(a));\\n        for (int a : A) connectFactorsOf(a, nodes);\\n        \\n        Set<Node> visited = new HashSet<>();\\n        int max = 0;\\n        for (Node n : nodes.values()) {\\n            max = Math.max(max, sink(n, visited));\\n        }\\n        return max;\\n    }\\n    \\n    private int sink(Node n, Set<Node> visited) {\\n        if (visited.contains(n)) return 0;\\n        visited.add(n);\\n        \\n        int count = n.exists ? 1 : 0;\\n        for (Node next : n.neighbors) {\\n            count += sink(next, visited);\\n        }\\n        return count;\\n    }\\n    \\n    private void connectFactorsOf(int a, Map<Integer,Node> nodes) {\\n        Node self = nodes.get(a);\\n        \\n        for (int i=2; i <= (int) Math.sqrt(a); i++) {\\n            if (a%i == 0) {\\n                Node factor = nodes.get(i);\\n                factor = factor == null ? new Node(i, false) : factor;\\n                factor.neighbors.add(self);\\n                self.neighbors.add(factor);\\n                \\n                nodes.put(i, factor);\\n                \\n                int other = a/i;\\n                factor = nodes.get(other);\\n                factor = factor == null ? new Node(other, false) : factor;\\n                factor.neighbors.add(self);\\n                self.neighbors.add(factor);\\n                \\n                nodes.put(other, factor);\\n                \\n            }\\n        }\\n    }\\n    \\n    public class Node {\\n        int val;\\n        boolean exists;\\n        Set<Node> neighbors = new HashSet<>();\\n        \\n        public Node(int val) {this(val, true);}\\n        public Node(int val, boolean exists) {\\n            this.val = val;\\n            this.exists = exists;\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090548,
                "title": "python-union-find-prime-factor-decomposition",
                "content": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.n = n\\n        self.parents = [i for i in range(n)]\\n        self.childrenNum = n * [1]\\n        \\n    def find(self, i):\\n        if self.parents[i] == i:\\n            return i\\n        \\n        return self.find(self.parents[i])\\n    \\n    def union(self, i, j):\\n        x = self.find(i)\\n        y = self.find(j)\\n        if x != y:\\n            self.parents[y] = x\\n            self.childrenNum[x] += self.childrenNum[y]\\n            self.childrenNum[y] = 0\\n        \\n    def getLargestComponent(self):\\n        return max(self.childrenNum)\\n    \\n    def getSize(self):\\n        s = set()\\n        for i in range(self.n):\\n            s.add(self.find(i))\\n        return len(s)\\n        \\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        def primeset(n):\\n            for i in range(2, int(sqrt(n))+1):\\n                if n % i == 0:\\n                    return primeset(n // i) | {i}\\n                \\n            return {n}\\n        \\n        factorset = {}\\n        n = len(nums)\\n        uf = UnionFind(n)\\n        for i in range(n):\\n            fs = primeset(nums[i])\\n            for factor in fs:\\n                if factor not in factorset:\\n                    factorset[factor] = [i]\\n                    \\n                else:\\n                    factorset[factor].append(i)\\n                    \\n        for key, values in factorset.items():\\n            parent = values[0]\\n            for idx in values[1:]:\\n                uf.union(parent, idx)\\n                \\n        return uf.getLargestComponent()\\n\\'\\'\\'\\n\\u601D\\u8DEF\\uFF1A\\n1\\\\\\u4E00\\u5F00\\u59CB\\u7528\\u7684\\u662Fgcd\\u4F1A\\u5BFC\\u81F4TLE\\uFF0C\\u56E0\\u4E3A\\u6BCF\\u4E24\\u4E2A\\u6570\\u4E4B\\u95F4\\u90FD\\u8981gcd\\uFF0C\\u800C\\u4E14\\u6BD4\\u5982gcd(8195,2)\\u7684\\u8BDD\\u5176\\u5B9E\\u8981\\u5F88\\u4E45\\u5F88\\u4E45\\u2026\\n2\\\\\\u6240\\u4EE5\\u6211\\u4EEC\\u4E0D\\u5982\\u7528prime factor decomposition\\uFF0C\\u5373\\u57282...sqrt(nums[i])\\u4E4B\\u95F4\\u627E\\u51FAnums[i]\\u6240\\u6709\\u7684prime factor\\uFF0C\\u6BD4\\u5982nums[1] = 40\\uFF0C\\u662F\\u75312\\u548C5\\u7EC4\\u6210\\u7684\\uFF0C\\u6240\\u4EE5dict[2].append(1), dict[5].append(1)\\u3002\\n3\\\\\\u7B49\\u5230traverse\\u8FC7\\u4E00\\u904D\\u4E4B\\u540E\\uFF0C\\u5728\\u6BCF\\u4E2Aprime factor dict\\u91CC\\u7684\\u7FA4\\u843D\\u91CC\\u5F00\\u59CBunion\\uFF0C\\u6BD4\\u5982\\u4ECE\\u542B\\u6709\\u516C\\u56E0\\u65702\\u7684set\\u5F00\\u59CB\\uFF0Cvalue = dict[2]\\uFF0Cvalue[0]\\u4E3Aparent\\u548Cvalue[1...-1]\\u75AF\\u72C2union\\u3002\\n4\\\\time complexity\\uFF1A\\u611F\\u89C9\\u662FO(n) * O(log2(1e5))\\n\\'\\'\\'\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.n = n\\n        self.parents = [i for i in range(n)]\\n        self.childrenNum = n * [1]\\n        \\n    def find(self, i):\\n        if self.parents[i] == i:\\n            return i\\n        \\n        return self.find(self.parents[i])\\n    \\n    def union(self, i, j):\\n        x = self.find(i)\\n        y = self.find(j)\\n        if x != y:\\n            self.parents[y] = x\\n            self.childrenNum[x] += self.childrenNum[y]\\n            self.childrenNum[y] = 0\\n        \\n    def getLargestComponent(self):\\n        return max(self.childrenNum)\\n    \\n    def getSize(self):\\n        s = set()\\n        for i in range(self.n):\\n            s.add(self.find(i))\\n        return len(s)\\n        \\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        def primeset(n):\\n            for i in range(2, int(sqrt(n))+1):\\n                if n % i == 0:\\n                    return primeset(n // i) | {i}\\n                \\n            return {n}\\n        \\n        factorset = {}\\n        n = len(nums)\\n        uf = UnionFind(n)\\n        for i in range(n):\\n            fs = primeset(nums[i])\\n            for factor in fs:\\n                if factor not in factorset:\\n                    factorset[factor] = [i]\\n                    \\n                else:\\n                    factorset[factor].append(i)\\n                    \\n        for key, values in factorset.items():\\n            parent = values[0]\\n            for idx in values[1:]:\\n                uf.union(parent, idx)\\n                \\n        return uf.getLargestComponent()\\n\\'\\'\\'\\n\\u601D\\u8DEF\\uFF1A\\n1\\\\\\u4E00\\u5F00\\u59CB\\u7528\\u7684\\u662Fgcd\\u4F1A\\u5BFC\\u81F4TLE\\uFF0C\\u56E0\\u4E3A\\u6BCF\\u4E24\\u4E2A\\u6570\\u4E4B\\u95F4\\u90FD\\u8981gcd\\uFF0C\\u800C\\u4E14\\u6BD4\\u5982gcd(8195,2)\\u7684\\u8BDD\\u5176\\u5B9E\\u8981\\u5F88\\u4E45\\u5F88\\u4E45\\u2026\\n2\\\\\\u6240\\u4EE5\\u6211\\u4EEC\\u4E0D\\u5982\\u7528prime factor decomposition\\uFF0C\\u5373\\u57282...sqrt(nums[i])\\u4E4B\\u95F4\\u627E\\u51FAnums[i]\\u6240\\u6709\\u7684prime factor\\uFF0C\\u6BD4\\u5982nums[1] = 40\\uFF0C\\u662F\\u75312\\u548C5\\u7EC4\\u6210\\u7684\\uFF0C\\u6240\\u4EE5dict[2].append(1), dict[5].append(1)\\u3002\\n3\\\\\\u7B49\\u5230traverse\\u8FC7\\u4E00\\u904D\\u4E4B\\u540E\\uFF0C\\u5728\\u6BCF\\u4E2Aprime factor dict\\u91CC\\u7684\\u7FA4\\u843D\\u91CC\\u5F00\\u59CBunion\\uFF0C\\u6BD4\\u5982\\u4ECE\\u542B\\u6709\\u516C\\u56E0\\u65702\\u7684set\\u5F00\\u59CB\\uFF0Cvalue = dict[2]\\uFF0Cvalue[0]\\u4E3Aparent\\u548Cvalue[1...-1]\\u75AF\\u72C2union\\u3002\\n4\\\\time complexity\\uFF1A\\u611F\\u89C9\\u662FO(n) * O(log2(1e5))\\n\\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026481,
                "title": "c-dsu-easy-to-understand",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- **Those elements which have any common prime factor should be one group.**\\n\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n- Create a Union-Find data structure to group integers.\\n- Calculate prime factors for each integer in the array.\\n- **Connect integers with the same prime factors in the Union-Find structure.**\\n- Find the size of the largest connected component.\\n\\n# Complexity\\n### Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- O(n * sqrt(maxElement)), where n is the number of elements in the array, and maxElement is the maximum integer in the array.\\n\\n### Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- O(n) for the parent, componentSize, and pf arrays, and O(maxElement) for the isPresent array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint findSet(int v, vector<int> &parent){\\n    while(v!=parent[v]){\\n        parent[v] = parent[parent[v]];\\n        v = parent[v];\\n    }\\n    return v;\\n}\\n\\nvoid makeSet(int v, vector<int> &parent, vector<int> &componentSize){\\n\\tparent[v] = v;\\n\\tcomponentSize[v] = 1;\\n}\\n\\nvoid unionSets(int a, int b, vector<int> &parent, vector<int> &componentSize){\\n\\ta = findSet(a, parent);\\n\\tb = findSet(b, parent);\\n\\n\\tif (a != b){\\n\\n\\t\\tif (componentSize[a] < componentSize[b]){\\n\\t\\t\\tswap(a, b);\\n\\t\\t}\\n\\t\\tparent[b] = a;\\n\\t\\tcomponentSize[a] += componentSize[b];\\n\\t}\\n}\\n\\nvector<int> findPrimeFactors(int val){\\n\\tvector<int> pf;\\n\\n\\tfor (int i = 2; i * i <= val; i++){\\n\\t\\tif (val % i == 0){\\n\\t\\t\\twhile (val % i == 0){\\n\\t\\t\\t\\tval /= i;\\n\\t\\t\\t}\\n\\t\\t\\tpf.push_back(i);\\n\\t\\t}\\n\\t}\\n\\tif (val > 1){\\n\\t\\tpf.push_back(val);\\n\\t}\\n\\treturn pf;\\n}\\n\\n    int largestComponentSize(vector<int>& arr) {\\n\\n    int n = arr.size();\\n    // parent: Stores the parent of the set.\\n\\t// componentSize: Stores the size of the set.\\n\\tvector<int> parent(n), componentSize(n);\\n\\n\\tfor (int i = 0; i < n; i++){\\n\\t\\tmakeSet(i, parent, componentSize);\\n\\t}\\n\\n\\t// Finding prime factors.\\n\\tvector<int> pf[n];\\n\\tfor (int i = 0; i < n; i++){\\n\\t\\tpf[i] = findPrimeFactors(arr[i]);\\n\\t}\\n\\n\\t// Finding maximum element in the array.\\n\\tint maxElement = 0;\\n\\tfor (int i = 0; i < n; i++){\\n\\t\\tmaxElement = max(maxElement, arr[i]);\\n\\t}\\n\\n\\tvector<int> isPresent(maxElement + 1, -1);\\n\\tfor (int i = 0; i < n; i++){\\n\\n\\t\\tfor (int j = 0; j < pf[i].size(); j++){\\n\\t\\t\\tint x = pf[i][j];\\n\\t\\t\\t\\n\\t\\t\\tif (isPresent[x] != -1){\\n\\t\\t\\t\\tunionSets(isPresent[x], i, parent, componentSize);\\n\\t\\t\\t}\\n\\t\\t\\tisPresent[x] = i;\\n\\t\\t}\\n\\t}\\n\\n\\t// Stores the size of largest component.\\n\\tint ans = 0;\\n\\tfor (int i = 0; i < n; i++){\\n\\t\\tans = max(ans, componentSize[i]);\\n\\t}\\n\\n\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Union Find",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint findSet(int v, vector<int> &parent){\\n    while(v!=parent[v]){\\n        parent[v] = parent[parent[v]];\\n        v = parent[v];\\n    }\\n    return v;\\n}\\n\\nvoid makeSet(int v, vector<int> &parent, vector<int> &componentSize){\\n\\tparent[v] = v;\\n\\tcomponentSize[v] = 1;\\n}\\n\\nvoid unionSets(int a, int b, vector<int> &parent, vector<int> &componentSize){\\n\\ta = findSet(a, parent);\\n\\tb = findSet(b, parent);\\n\\n\\tif (a != b){\\n\\n\\t\\tif (componentSize[a] < componentSize[b]){\\n\\t\\t\\tswap(a, b);\\n\\t\\t}\\n\\t\\tparent[b] = a;\\n\\t\\tcomponentSize[a] += componentSize[b];\\n\\t}\\n}\\n\\nvector<int> findPrimeFactors(int val){\\n\\tvector<int> pf;\\n\\n\\tfor (int i = 2; i * i <= val; i++){\\n\\t\\tif (val % i == 0){\\n\\t\\t\\twhile (val % i == 0){\\n\\t\\t\\t\\tval /= i;\\n\\t\\t\\t}\\n\\t\\t\\tpf.push_back(i);\\n\\t\\t}\\n\\t}\\n\\tif (val > 1){\\n\\t\\tpf.push_back(val);\\n\\t}\\n\\treturn pf;\\n}\\n\\n    int largestComponentSize(vector<int>& arr) {\\n\\n    int n = arr.size();\\n    // parent: Stores the parent of the set.\\n\\t// componentSize: Stores the size of the set.\\n\\tvector<int> parent(n), componentSize(n);\\n\\n\\tfor (int i = 0; i < n; i++){\\n\\t\\tmakeSet(i, parent, componentSize);\\n\\t}\\n\\n\\t// Finding prime factors.\\n\\tvector<int> pf[n];\\n\\tfor (int i = 0; i < n; i++){\\n\\t\\tpf[i] = findPrimeFactors(arr[i]);\\n\\t}\\n\\n\\t// Finding maximum element in the array.\\n\\tint maxElement = 0;\\n\\tfor (int i = 0; i < n; i++){\\n\\t\\tmaxElement = max(maxElement, arr[i]);\\n\\t}\\n\\n\\tvector<int> isPresent(maxElement + 1, -1);\\n\\tfor (int i = 0; i < n; i++){\\n\\n\\t\\tfor (int j = 0; j < pf[i].size(); j++){\\n\\t\\t\\tint x = pf[i][j];\\n\\t\\t\\t\\n\\t\\t\\tif (isPresent[x] != -1){\\n\\t\\t\\t\\tunionSets(isPresent[x], i, parent, componentSize);\\n\\t\\t\\t}\\n\\t\\t\\tisPresent[x] = i;\\n\\t\\t}\\n\\t}\\n\\n\\t// Stores the size of largest component.\\n\\tint ans = 0;\\n\\tfor (int i = 0; i < n; i++){\\n\\t\\tans = max(ans, componentSize[i]);\\n\\t}\\n\\n\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983137,
                "title": "simplest-code-of-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ninstead of all the factors can we use prime factors only?\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfind all the prime factors of a number and use union find \\nfor more clarity refer my code\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int find(int node,vector<int>&par){\\n        if(par[node]==node) return node;\\n        return par[node]=find(par[node],par);\\n    }\\n\\n    void merge(int u,int v,vector<int>&par,vector<int>&rank){\\n        int x=find(u,par),y=find(v,par);\\n        if(x==y) return;\\n\\n        if(rank[x]>=rank[y]){\\n            par[y]=par[x];\\n            rank[x]+=rank[y];\\n        }\\n        else{\\n            par[x]=par[y];\\n            rank[y]+=rank[x];\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n        int mx=*max_element(nums.begin(),nums.end());\\n        vector<int>par(mx+1),rank(mx+1,0);\\n        for(int i=0;i<=mx;i++) par[i]=i;\\n        for(auto i:nums){\\n            if(i==1) continue;\\n            vector<int>fact;\\n            int f=2,num=i;\\n            while(i>1 and f*f<=num){\\n                if(i%f==0) fact.push_back(f);\\n                while(i%f==0) i/=f;\\n                f++;\\n            }\\n            if(i>1) fact.push_back(i);\\n            par[fact[0]]=find(fact[0],par);\\n            rank[par[fact[0]]]++;\\n            for(int k=1;k<fact.size();k++) merge(par[fact[0]],fact[k],par,rank);\\n            // cout<<\"par= \"<<par[fact[0]]<<\" rank= \"<<rank[par[fact[0]]]<<endl;\\n        }\\n        int ans=1;\\n        for(auto i:rank) ans=max(ans,i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int find(int node,vector<int>&par){\\n        if(par[node]==node) return node;\\n        return par[node]=find(par[node],par);\\n    }\\n\\n    void merge(int u,int v,vector<int>&par,vector<int>&rank){\\n        int x=find(u,par),y=find(v,par);\\n        if(x==y) return;\\n\\n        if(rank[x]>=rank[y]){\\n            par[y]=par[x];\\n            rank[x]+=rank[y];\\n        }\\n        else{\\n            par[x]=par[y];\\n            rank[y]+=rank[x];\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n        int mx=*max_element(nums.begin(),nums.end());\\n        vector<int>par(mx+1),rank(mx+1,0);\\n        for(int i=0;i<=mx;i++) par[i]=i;\\n        for(auto i:nums){\\n            if(i==1) continue;\\n            vector<int>fact;\\n            int f=2,num=i;\\n            while(i>1 and f*f<=num){\\n                if(i%f==0) fact.push_back(f);\\n                while(i%f==0) i/=f;\\n                f++;\\n            }\\n            if(i>1) fact.push_back(i);\\n            par[fact[0]]=find(fact[0],par);\\n            rank[par[fact[0]]]++;\\n            for(int k=1;k<fact.size();k++) merge(par[fact[0]],fact[k],par,rank);\\n            // cout<<\"par= \"<<par[fact[0]]<<\" rank= \"<<rank[par[fact[0]]]<<endl;\\n        }\\n        int ans=1;\\n        for(auto i:rank) ans=max(ans,i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3949365,
                "title": "dsu-and-prime-factorisation",
                "content": "\\n# Code\\n```\\nstruct dsu{\\n\\n    vector<int> par;\\n    vector<int> lvl;\\n    dsu(){\\n        par.resize(100001);\\n        iota(par.begin(), par.end(),0);\\n        lvl.assign(100001,0);\\n    }\\n    int get(int a){\\n        if(par[a]==a) return a;\\n        return get(par[a]);\\n    }\\n    void unite(int a, int b){\\n        a=get(a);\\n        b=get(b);\\n        if(a==b) return;\\n        if(lvl[a]<lvl[b]){\\n            swap(a,b);\\n        }\\n        if(lvl[a]==lvl[b]) lvl[a]++;\\n        par[b]=a;\\n        return ;\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    vector<int> primefactors(int n){\\n        vector<int> v;\\n        for(int i=2; i*i<=n; i++){\\n            if(n%i==0){\\n                while(n%i==0){\\n                    n=n/i;\\n                }\\n                v.push_back(i);\\n            }\\n        }\\n        if(n>1) v.push_back(n);\\n        return v;\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n        dsu graph;\\n        int groups=0;\\n        for(auto u: nums){\\n            if(u==1){\\n                groups=1;\\n                continue;\\n            }\\n            vector<int> v=primefactors(u);\\n            int n=v.size();\\n            for(int i=0; i<n; i++){\\n                for(int j=i+1; j<n; j++){\\n                    graph.unite(v[i],v[j]);\\n                }\\n            }\\n        }\\n        map<int,int> mp;\\n        for(auto u: nums){\\n            if(u==1) continue;\\n            vector<int> v=primefactors(u);\\n            int k=graph.get(v[0]);\\n            mp[k]++;\\n            groups=max(groups, mp[k]);\\n        }\\n        return groups;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct dsu{\\n\\n    vector<int> par;\\n    vector<int> lvl;\\n    dsu(){\\n        par.resize(100001);\\n        iota(par.begin(), par.end(),0);\\n        lvl.assign(100001,0);\\n    }\\n    int get(int a){\\n        if(par[a]==a) return a;\\n        return get(par[a]);\\n    }\\n    void unite(int a, int b){\\n        a=get(a);\\n        b=get(b);\\n        if(a==b) return;\\n        if(lvl[a]<lvl[b]){\\n            swap(a,b);\\n        }\\n        if(lvl[a]==lvl[b]) lvl[a]++;\\n        par[b]=a;\\n        return ;\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    vector<int> primefactors(int n){\\n        vector<int> v;\\n        for(int i=2; i*i<=n; i++){\\n            if(n%i==0){\\n                while(n%i==0){\\n                    n=n/i;\\n                }\\n                v.push_back(i);\\n            }\\n        }\\n        if(n>1) v.push_back(n);\\n        return v;\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n        dsu graph;\\n        int groups=0;\\n        for(auto u: nums){\\n            if(u==1){\\n                groups=1;\\n                continue;\\n            }\\n            vector<int> v=primefactors(u);\\n            int n=v.size();\\n            for(int i=0; i<n; i++){\\n                for(int j=i+1; j<n; j++){\\n                    graph.unite(v[i],v[j]);\\n                }\\n            }\\n        }\\n        map<int,int> mp;\\n        for(auto u: nums){\\n            if(u==1) continue;\\n            vector<int> v=primefactors(u);\\n            int k=graph.get(v[0]);\\n            mp[k]++;\\n            groups=max(groups, mp[k]);\\n        }\\n        return groups;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928240,
                "title": "easy-to-understand-sieve-and-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n##### Use sieve algorithm to find the smallest prime factor (spf) for each number in 1 to 10**5\\n1. finding the spf of all numbers also gives us all the prime factors of the number, this is because by successively dividing by the spf we get a smaller number with potentially a differnt spf and continuing we would encounter all the prime factors.\\n\\n##### Union Find\\n1. Create a list for each prime where the list would contain multiples of the prime that belong to the array\\n2. union over all the elements for each prime\\n3. count the frequency of each representative element of union find\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(M\\\\log(M) + N\\\\log(M))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M + N\\\\log(M))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nM = 10**5 + 1\\nspf = [x for x in range(M)]\\nfor i in range(2, M):\\n    if spf[i] != i:\\n        continue\\n    j = i ** 2\\n    while j < M:\\n        spf[j] = min(spf[j], i)\\n        j += i\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        \\n        # Use sieve algorithm to find the smallest prime factor (spf) for each number in 1 to 10**5\\n        #       finding the spf of all numbers also gives us all the prime factors of the number\\n        #       this is because by successivel divifing by the spf gives us smaller number with potentially \\n        #       a differnt spf and so on\\n\\n        # create a list for each prime where the list would contain multiples of the prime that belong to the array\\n        # union over all the elements for each prime\\n        # count the number of times each representative element of the union find\\n        \\n        n = len(nums)\\n        divides = defaultdict(set)\\n        for i, x in enumerate(nums):\\n            num = x\\n            while num > 1:\\n                divides[spf[num]].add(i)\\n                num //= spf[num]\\n        parents = [x for x in range(n)]\\n        def find(a):\\n            if parents[a] != a:\\n                parents[a] = find(parents[a])\\n            return parents[a]\\n        \\n        def union(a, b):\\n            ua, ub = find(a), find(b)\\n            parents[ua] = ub\\n        \\n        for prime in divides:\\n            arr = list(divides[prime])\\n            for x in arr:\\n                union(x, arr[0])\\n        \\n        counts = defaultdict(int)\\n        for i in range(n):\\n            counts[find(i)] += 1\\n        \\n        return max(counts.values())\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math",
                    "Union Find",
                    "Number Theory"
                ],
                "code": "```\\nM = 10**5 + 1\\nspf = [x for x in range(M)]\\nfor i in range(2, M):\\n    if spf[i] != i:\\n        continue\\n    j = i ** 2\\n    while j < M:\\n        spf[j] = min(spf[j], i)\\n        j += i\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        \\n        # Use sieve algorithm to find the smallest prime factor (spf) for each number in 1 to 10**5\\n        #       finding the spf of all numbers also gives us all the prime factors of the number\\n        #       this is because by successivel divifing by the spf gives us smaller number with potentially \\n        #       a differnt spf and so on\\n\\n        # create a list for each prime where the list would contain multiples of the prime that belong to the array\\n        # union over all the elements for each prime\\n        # count the number of times each representative element of the union find\\n        \\n        n = len(nums)\\n        divides = defaultdict(set)\\n        for i, x in enumerate(nums):\\n            num = x\\n            while num > 1:\\n                divides[spf[num]].add(i)\\n                num //= spf[num]\\n        parents = [x for x in range(n)]\\n        def find(a):\\n            if parents[a] != a:\\n                parents[a] = find(parents[a])\\n            return parents[a]\\n        \\n        def union(a, b):\\n            ua, ub = find(a), find(b)\\n            parents[ua] = ub\\n        \\n        for prime in divides:\\n            arr = list(divides[prime])\\n            for x in arr:\\n                union(x, arr[0])\\n        \\n        counts = defaultdict(int)\\n        for i in range(n):\\n            counts[find(i)] += 1\\n        \\n        return max(counts.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924264,
                "title": "using-sieve-and-dfs-union-find",
                "content": "**Using DFS and sieve** \\n\\n```\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n      n,prime,isPresent = max(nums) + 11,[],set(nums) \\n      g,ans,curr = [[] for _ in range(n)],0,0\\n      \\n      \\n      def sieve(n):\\n        primes = [True for _ in range(n)] \\n        for i in range(2,n):\\n          if primes[i] : \\n            for j in range(i*i,n,i): primes[j] = False\\n            prime.append(i) \\n\\n      sieve(n) \\n      for number in prime : \\n        for x in range(2*number,n,number):\\n          if x in isPresent : \\n            g[x].append(number) \\n            g[number].append(x) \\n\\n      visited = [False for _ in range(n)] \\n      def dfs(x):\\n        nonlocal curr\\n        if x in isPresent : curr += 1 \\n        visited[x] = True \\n        for i in g[x] : \\n          if not visited[i] : dfs(i) \\n      \\n      for i in range(n):\\n        curr = 0 \\n        if not visited[i]:\\n          dfs(i) \\n          ans = max(ans ,curr) \\n          \\n      return ans\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n      n,prime,isPresent = max(nums) + 11,[],set(nums) \\n      g,ans,curr = [[] for _ in range(n)],0,0\\n      \\n      \\n      def sieve(n):\\n        primes = [True for _ in range(n)] \\n        for i in range(2,n):\\n          if primes[i] : \\n            for j in range(i*i,n,i): primes[j] = False\\n            prime.append(i) \\n\\n      sieve(n) \\n      for number in prime : \\n        for x in range(2*number,n,number):\\n          if x in isPresent : \\n            g[x].append(number) \\n            g[number].append(x) \\n\\n      visited = [False for _ in range(n)] \\n      def dfs(x):\\n        nonlocal curr\\n        if x in isPresent : curr += 1 \\n        visited[x] = True \\n        for i in g[x] : \\n          if not visited[i] : dfs(i) \\n      \\n      for i in range(n):\\n        curr = 0 \\n        if not visited[i]:\\n          dfs(i) \\n          ans = max(ans ,curr) \\n          \\n      return ans\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878705,
                "title": "typescript-dsu-prime-factor-calcs-max-group-runtime-beats-100",
                "content": "# Complexity\\n- Time complexity:\\nO(N * (logM^2 + sqrt(M)))\\n\\n- Space complexity:\\nO(M+N)\\n\\n# Code\\n```\\nclass DSU {\\n    rank: number[];\\n    root: number[];\\n\\n    constructor (size: number) {\\n        this.rank = new Array(size).fill(1);\\n        this.root = new Array(size).fill(0).map((_, i) => i);\\n    }\\n\\n    find(x: number): number {\\n        if (x === this.root[x]) {\\n            return x;\\n        }\\n        this.root[x] = this.find(this.root[x]);\\n        return this.root[x];\\n    }\\n\\n    union(x: number, y: number): void {\\n        const rootX = this.find(x);\\n        const rootY = this.find(y);\\n\\n        if (rootX !== rootY) {\\n            if (this.rank[rootX] > this.rank[rootY]) {\\n                this.root[rootY] = rootX;\\n            } else if (this.rank[rootX] < this.rank[rootY]) {\\n                this.root[rootX] = rootY;\\n            } else {\\n                this.rank[rootX] += 1;\\n                this.root[rootY] = rootX;\\n            }\\n        }\\n    }\\n\\n    connected(x: number, y: number): boolean {\\n        return this.find(x) == this.find(y);\\n    }\\n}\\n\\n\\nfunction largestComponentSize(nums: number[]): number {\\n    const dsu: DSU = new DSU(Math.max(...nums));\\n\\n    // sieve algo\\n    const primeDecompose = (num: number): number[] => {\\n        let factor: number = 2;\\n        const primeFactors = new Set<number>();\\n        while (num >= factor * factor) {\\n            if (num % factor === 0) {\\n                primeFactors.add(factor);\\n                num /= factor;\\n            } else {\\n                factor++;\\n            }\\n        }\\n        primeFactors.add(num);\\n\\n        return [...primeFactors];\\n    }\\n\\n    const numFactorMap: { [key: number]: number } = {};\\n    for (const num of nums) {\\n      const primeFactors = primeDecompose(num);\\n      numFactorMap[num] = primeFactors[0];\\n\\n      for (let i = 0; i < primeFactors.length - 1; i++) {\\n        dsu.union(primeFactors[i], primeFactors[i + 1]);\\n      }\\n    }\\n\\n    let maxSize: number = 0;\\n    const groupCount: { [key: number]: number } = {};\\n\\n    for (const num of nums) {\\n      const groupId = dsu.find(numFactorMap[num]);\\n      groupCount[groupId] = (groupCount[groupId] || 0) + 1;\\n      maxSize = Math.max(maxSize, groupCount[groupId]);\\n    }\\n\\n    return maxSize;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Math",
                    "Union Find",
                    "Number Theory"
                ],
                "code": "```\\nclass DSU {\\n    rank: number[];\\n    root: number[];\\n\\n    constructor (size: number) {\\n        this.rank = new Array(size).fill(1);\\n        this.root = new Array(size).fill(0).map((_, i) => i);\\n    }\\n\\n    find(x: number): number {\\n        if (x === this.root[x]) {\\n            return x;\\n        }\\n        this.root[x] = this.find(this.root[x]);\\n        return this.root[x];\\n    }\\n\\n    union(x: number, y: number): void {\\n        const rootX = this.find(x);\\n        const rootY = this.find(y);\\n\\n        if (rootX !== rootY) {\\n            if (this.rank[rootX] > this.rank[rootY]) {\\n                this.root[rootY] = rootX;\\n            } else if (this.rank[rootX] < this.rank[rootY]) {\\n                this.root[rootX] = rootY;\\n            } else {\\n                this.rank[rootX] += 1;\\n                this.root[rootY] = rootX;\\n            }\\n        }\\n    }\\n\\n    connected(x: number, y: number): boolean {\\n        return this.find(x) == this.find(y);\\n    }\\n}\\n\\n\\nfunction largestComponentSize(nums: number[]): number {\\n    const dsu: DSU = new DSU(Math.max(...nums));\\n\\n    // sieve algo\\n    const primeDecompose = (num: number): number[] => {\\n        let factor: number = 2;\\n        const primeFactors = new Set<number>();\\n        while (num >= factor * factor) {\\n            if (num % factor === 0) {\\n                primeFactors.add(factor);\\n                num /= factor;\\n            } else {\\n                factor++;\\n            }\\n        }\\n        primeFactors.add(num);\\n\\n        return [...primeFactors];\\n    }\\n\\n    const numFactorMap: { [key: number]: number } = {};\\n    for (const num of nums) {\\n      const primeFactors = primeDecompose(num);\\n      numFactorMap[num] = primeFactors[0];\\n\\n      for (let i = 0; i < primeFactors.length - 1; i++) {\\n        dsu.union(primeFactors[i], primeFactors[i + 1]);\\n      }\\n    }\\n\\n    let maxSize: number = 0;\\n    const groupCount: { [key: number]: number } = {};\\n\\n    for (const num of nums) {\\n      const groupId = dsu.find(numFactorMap[num]);\\n      groupCount[groupId] = (groupCount[groupId] || 0) + 1;\\n      maxSize = Math.max(maxSize, groupCount[groupId]);\\n    }\\n\\n    return maxSize;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842228,
                "title": "python-unionfind-disjointset-factorization",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nfrom math import gcd\\n\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [0] * n\\n\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])  # Path compression\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        root_x = self.find(x)\\n        root_y = self.find(y)\\n\\n        if root_x == root_y:\\n            return False  # Both elements are already in the same set\\n\\n        # Union by rank\\n        if self.rank[root_x] < self.rank[root_y]:\\n            self.parent[root_x] = root_y\\n        elif self.rank[root_x] > self.rank[root_y]:\\n            self.parent[root_y] = root_x\\n        else:\\n            self.parent[root_y] = root_x\\n            self.rank[root_x] += 1\\n        return True  # Elements were successfully merged\\n\\ndef factorize(num):\\n    factors = []\\n    for j in range(2, int(num ** 0.5) + 1):\\n        if num % j == 0:\\n            while num % j == 0:\\n                num //= j\\n            factors.append(j)\\n    if num > 1:\\n        factors.append(num)\\n    return factors\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        max_num = max(nums)\\n        uf = UnionFind(max_num + 1)\\n\\n        # Preprocess and group numbers by their gcd\\n        gcd_groups = defaultdict(list)\\n        for i, num in enumerate(nums):\\n            for f in factorize(num):\\n                gcd_groups[f].append(i)\\n\\n        # Union numbers in each gcd group\\n        for group in gcd_groups.values():\\n            for i in range(len(group) - 1):\\n                uf.union(group[i], group[i + 1])\\n\\n        # Count the size of each component using UnionFind\\n        component_sizes = defaultdict(int)\\n        for i in range(len(nums)):\\n            component_sizes[uf.find(i)] += 1\\n\\n        # Return the size of the largest component\\n        return max(component_sizes.values())\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom math import gcd\\n\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [0] * n\\n\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])  # Path compression\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        root_x = self.find(x)\\n        root_y = self.find(y)\\n\\n        if root_x == root_y:\\n            return False  # Both elements are already in the same set\\n\\n        # Union by rank\\n        if self.rank[root_x] < self.rank[root_y]:\\n            self.parent[root_x] = root_y\\n        elif self.rank[root_x] > self.rank[root_y]:\\n            self.parent[root_y] = root_x\\n        else:\\n            self.parent[root_y] = root_x\\n            self.rank[root_x] += 1\\n        return True  # Elements were successfully merged\\n\\ndef factorize(num):\\n    factors = []\\n    for j in range(2, int(num ** 0.5) + 1):\\n        if num % j == 0:\\n            while num % j == 0:\\n                num //= j\\n            factors.append(j)\\n    if num > 1:\\n        factors.append(num)\\n    return factors\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        max_num = max(nums)\\n        uf = UnionFind(max_num + 1)\\n\\n        # Preprocess and group numbers by their gcd\\n        gcd_groups = defaultdict(list)\\n        for i, num in enumerate(nums):\\n            for f in factorize(num):\\n                gcd_groups[f].append(i)\\n\\n        # Union numbers in each gcd group\\n        for group in gcd_groups.values():\\n            for i in range(len(group) - 1):\\n                uf.union(group[i], group[i + 1])\\n\\n        # Count the size of each component using UnionFind\\n        component_sizes = defaultdict(int)\\n        for i in range(len(nums)):\\n            component_sizes[uf.find(i)] += 1\\n\\n        # Return the size of the largest component\\n        return max(component_sizes.values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767307,
                "title": "disjoint-set-union-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmake an edge if gcd of two elements is >1. for this there is no need implement o(n2) but can be done through making a set for each element that holds the factors\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet {\\n    vector<int> rank, parent, size; \\npublic: \\n    DisjointSet(int n) {\\n        rank.resize(n+1, 0); \\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n    int findsize(int node){\\n        return size[node];\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n            size[ulp_v] += size[ulp_u]; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v]; \\n        }\\n    }\\n}; \\nclass Solution {\\npublic:\\n unordered_set<int> findfact(int n){\\n     unordered_set<int> factors;\\n     for(int i=2;i<=sqrt(n);i++){\\n         if(n%i==0){\\n             while(n%i==0){n=n/i;}\\n             factors.insert(i);\\n         }\\n     }if(n>1)factors.insert(n);\\n     return factors;\\n }\\n    int largestComponentSize(vector<int>& nums) {\\n        int n=nums.size();\\n        DisjointSet ds(n);\\n        unordered_map<int,int> lastind;\\n        for(int i=0;i<n;i++){\\n            unordered_set<int> factors=findfact(nums[i]);\\n            for(int fact:factors){\\n                if(lastind.find(fact)!=lastind.end()){\\n                    ds.unionBySize(i,lastind[fact]);\\n                }\\n                lastind[fact]=i;//store the last element that is divisible bt a factor and make an edge if it also divides the current number.\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,ds.findsize(i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSet {\\n    vector<int> rank, parent, size; \\npublic: \\n    DisjointSet(int n) {\\n        rank.resize(n+1, 0); \\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n    int findsize(int node){\\n        return size[node];\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n            size[ulp_v] += size[ulp_u]; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v]; \\n        }\\n    }\\n}; \\nclass Solution {\\npublic:\\n unordered_set<int> findfact(int n){\\n     unordered_set<int> factors;\\n     for(int i=2;i<=sqrt(n);i++){\\n         if(n%i==0){\\n             while(n%i==0){n=n/i;}\\n             factors.insert(i);\\n         }\\n     }if(n>1)factors.insert(n);\\n     return factors;\\n }\\n    int largestComponentSize(vector<int>& nums) {\\n        int n=nums.size();\\n        DisjointSet ds(n);\\n        unordered_map<int,int> lastind;\\n        for(int i=0;i<n;i++){\\n            unordered_set<int> factors=findfact(nums[i]);\\n            for(int fact:factors){\\n                if(lastind.find(fact)!=lastind.end()){\\n                    ds.unionBySize(i,lastind[fact]);\\n                }\\n                lastind[fact]=i;//store the last element that is divisible bt a factor and make an edge if it also divides the current number.\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,ds.findsize(i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728944,
                "title": "java-optimized-solution-disjoint-set-union",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int count =0;\\n    public int largestComponentSize(int[] nums) {\\n\\n        int n=nums.length;\\n        DisjointSet ds=new DisjointSet(n);\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            int num = nums[i];\\n            for (int factor = 2; factor * factor <= num; factor++) {\\n                if (num % factor == 0) {\\n                    if (!map.containsKey(factor))\\n                        map.put(factor, i);\\n                    else\\n                        ds.unionBySize(i, map.get(factor));\\n\\n                    if (!map.containsKey(num / factor))\\n                        map.put(num / factor, i);\\n                    else \\n                        ds.unionBySize(i, map.get(num / factor));\\n                }\\n            }\\n\\n            if (!map.containsKey(num))\\n                map.put(num, i);\\n            else\\n                ds.unionBySize(i, map.get(num));\\n        }\\n\\n        int max = 1;\\n        int component[] = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int root = ds.findUParent(i);\\n            component[root]++;\\n            max = Math.max(max, component[root]);\\n        }\\n\\n        return max;\\n    }\\n}\\nclass DisjointSet{\\n    List<Integer> rank=new ArrayList<>();\\n    List<Integer> parent=new ArrayList<>();\\n    List<Integer> size=new ArrayList<>();\\n    \\n    public DisjointSet(int n){\\n        for(int i=0;i<=n;i++){\\n            rank.add(0);\\n            parent.add(i);\\n            size.add(1);\\n        }\\n    }\\n    \\n    public int findUParent(int node){\\n        if(node == parent.get(node))\\n            return node;\\n        int ultPar=findUParent(parent.get(node));\\n        //Path Compression\\n        parent.set(node, ultPar);\\n        return parent.get(node);\\n    }\\n\\n    public void unionBySize(int u, int v){\\n        int ultPar_u=findUParent(u);\\n        int ultPar_v=findUParent(v);\\n        if(ultPar_u == ultPar_v)\\n            return;\\n        if(size.get(ultPar_u) < size.get(ultPar_v)){\\n            parent.set(ultPar_u, ultPar_v);\\n            size.set(ultPar_v,size.get(ultPar_v) + size.get(ultPar_u));\\n        }\\n        else{\\n            parent.set(ultPar_v , ultPar_u);\\n            size.set(ultPar_u,size.get(ultPar_v) + size.get(ultPar_u));\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int count =0;\\n    public int largestComponentSize(int[] nums) {\\n\\n        int n=nums.length;\\n        DisjointSet ds=new DisjointSet(n);\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            int num = nums[i];\\n            for (int factor = 2; factor * factor <= num; factor++) {\\n                if (num % factor == 0) {\\n                    if (!map.containsKey(factor))\\n                        map.put(factor, i);\\n                    else\\n                        ds.unionBySize(i, map.get(factor));\\n\\n                    if (!map.containsKey(num / factor))\\n                        map.put(num / factor, i);\\n                    else \\n                        ds.unionBySize(i, map.get(num / factor));\\n                }\\n            }\\n\\n            if (!map.containsKey(num))\\n                map.put(num, i);\\n            else\\n                ds.unionBySize(i, map.get(num));\\n        }\\n\\n        int max = 1;\\n        int component[] = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int root = ds.findUParent(i);\\n            component[root]++;\\n            max = Math.max(max, component[root]);\\n        }\\n\\n        return max;\\n    }\\n}\\nclass DisjointSet{\\n    List<Integer> rank=new ArrayList<>();\\n    List<Integer> parent=new ArrayList<>();\\n    List<Integer> size=new ArrayList<>();\\n    \\n    public DisjointSet(int n){\\n        for(int i=0;i<=n;i++){\\n            rank.add(0);\\n            parent.add(i);\\n            size.add(1);\\n        }\\n    }\\n    \\n    public int findUParent(int node){\\n        if(node == parent.get(node))\\n            return node;\\n        int ultPar=findUParent(parent.get(node));\\n        //Path Compression\\n        parent.set(node, ultPar);\\n        return parent.get(node);\\n    }\\n\\n    public void unionBySize(int u, int v){\\n        int ultPar_u=findUParent(u);\\n        int ultPar_v=findUParent(v);\\n        if(ultPar_u == ultPar_v)\\n            return;\\n        if(size.get(ultPar_u) < size.get(ultPar_v)){\\n            parent.set(ultPar_u, ultPar_v);\\n            size.set(ultPar_v,size.get(ultPar_v) + size.get(ultPar_u));\\n        }\\n        else{\\n            parent.set(ultPar_v , ultPar_u);\\n            size.set(ultPar_u,size.get(ultPar_v) + size.get(ultPar_u));\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722839,
                "title": "my-solutions",
                "content": "**1. Use the Disjoint Set `I`**\\n```\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const int n) : parents_(n), groups_(n, 1), max_group_(1) {\\n      iota(parents_.begin(), parents_.end(), 0);\\n    }\\n    \\n    int find(const int i) {\\n      if (parents_[i] == i) {\\n        return i;\\n      }\\n      \\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    bool do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return false;\\n      }\\n      \\n      const int final_group = groups_[parent_i] + groups_[parent_j];\\n      max_group_ = max(max_group_, final_group);\\n      if (groups_[parent_i] < groups_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n        groups_[parent_j] = final_group;\\n        groups_[parent_i] = 0;\\n      } else {\\n        parents_[parent_j] = parent_i;\\n        groups_[parent_i] = final_group;\\n        groups_[parent_j] = 0;\\n      }\\n      return true;\\n    }\\n    \\n    int max_group() const {\\n      return max_group_;\\n    }\\n    \\n   private:\\n    vector<int> parents_;\\n    vector<int> groups_;\\n    int max_group_;\\n  };\\n  \\n public:\\n  int largestComponentSize(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    unordered_map<int, vector<int>> factor_to_indices;\\n    for (int i = 0; i < n; ++i) {\\n      int num = nums[i];\\n      if (num % 2 == 0) {\\n        factor_to_indices[2].emplace_back(i);\\n        for (; num % 2 == 0; num /= 2) {\\n        }\\n      }\\n      for (int factor = 3; factor * factor <= num; factor += 2) {\\n        if (num % factor == 0) {\\n          factor_to_indices[factor].emplace_back(i);\\n          for (; num % factor == 0; num /= factor) {\\n          }\\n        }\\n      }\\n      if (num > 1) {\\n        factor_to_indices[num].emplace_back(i);\\n      }\\n    }\\n    \\n    DisjointSet ds(n);\\n    for (const auto &[_, indices] : factor_to_indices) {\\n      for (size_t i = 1; i < indices.size(); ++i) {\\n        ds.do_union(indices.front(), indices[i]);\\n      }\\n    }\\n    return ds.max_group();\\n  }\\n};\\n```\\n**2. Use the Disjoint Set `II`**\\n```\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const int n) : parents_(n), ranks_(n) {\\n      iota(parents_.begin(), parents_.end(), 0);\\n    }\\n    \\n    int find(const int i) {\\n      if (parents_[i] == i) {\\n        return i;\\n      }\\n      \\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    bool do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return false;\\n      }\\n      \\n      if (ranks_[parent_i] < ranks_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n      } else if (ranks_[parent_i] > ranks_[parent_j]) {\\n        parents_[parent_j] = parent_i;\\n      } else {\\n        parents_[parent_i] = parent_j;\\n        ++ranks_[parent_j];\\n      }\\n      return true;\\n    }\\n    \\n   private:\\n    vector<int> parents_;\\n    vector<int> ranks_;\\n  };\\n  \\n public:\\n  int largestComponentSize(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    const int max_num = *max_element(nums.begin(), nums.end());\\n    DisjointSet ds(max_num + 1);\\n    \\n    for (int i = 0; i < n; ++i) {\\n      int num = nums[i];\\n      if (num % 2 == 0) {\\n        ds.do_union(2, nums[i]);\\n        for (; num % 2 == 0; num /= 2) {\\n        }\\n      }\\n      for (int factor = 3; factor * factor <= num; factor += 2) {\\n        if (num % factor == 0) {\\n          ds.do_union(factor, nums[i]);\\n          for (; num % factor == 0; num /= factor) {\\n          }\\n        }\\n      }\\n      if (num > 1) {\\n        ds.do_union(num, nums[i]);\\n      }\\n    }\\n    \\n    int ret = 1;\\n    int parent_to_count[max_num + 1];\\n    memset(parent_to_count, 0, sizeof(parent_to_count));\\n    for (const int num : nums) {\\n      ret = max(ret, ++parent_to_count[ds.find(num)]);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const int n) : parents_(n), groups_(n, 1), max_group_(1) {\\n      iota(parents_.begin(), parents_.end(), 0);\\n    }\\n    \\n    int find(const int i) {\\n      if (parents_[i] == i) {\\n        return i;\\n      }\\n      \\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    bool do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return false;\\n      }\\n      \\n      const int final_group = groups_[parent_i] + groups_[parent_j];\\n      max_group_ = max(max_group_, final_group);\\n      if (groups_[parent_i] < groups_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n        groups_[parent_j] = final_group;\\n        groups_[parent_i] = 0;\\n      } else {\\n        parents_[parent_j] = parent_i;\\n        groups_[parent_i] = final_group;\\n        groups_[parent_j] = 0;\\n      }\\n      return true;\\n    }\\n    \\n    int max_group() const {\\n      return max_group_;\\n    }\\n    \\n   private:\\n    vector<int> parents_;\\n    vector<int> groups_;\\n    int max_group_;\\n  };\\n  \\n public:\\n  int largestComponentSize(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    unordered_map<int, vector<int>> factor_to_indices;\\n    for (int i = 0; i < n; ++i) {\\n      int num = nums[i];\\n      if (num % 2 == 0) {\\n        factor_to_indices[2].emplace_back(i);\\n        for (; num % 2 == 0; num /= 2) {\\n        }\\n      }\\n      for (int factor = 3; factor * factor <= num; factor += 2) {\\n        if (num % factor == 0) {\\n          factor_to_indices[factor].emplace_back(i);\\n          for (; num % factor == 0; num /= factor) {\\n          }\\n        }\\n      }\\n      if (num > 1) {\\n        factor_to_indices[num].emplace_back(i);\\n      }\\n    }\\n    \\n    DisjointSet ds(n);\\n    for (const auto &[_, indices] : factor_to_indices) {\\n      for (size_t i = 1; i < indices.size(); ++i) {\\n        ds.do_union(indices.front(), indices[i]);\\n      }\\n    }\\n    return ds.max_group();\\n  }\\n};\\n```\n```\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const int n) : parents_(n), ranks_(n) {\\n      iota(parents_.begin(), parents_.end(), 0);\\n    }\\n    \\n    int find(const int i) {\\n      if (parents_[i] == i) {\\n        return i;\\n      }\\n      \\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    bool do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return false;\\n      }\\n      \\n      if (ranks_[parent_i] < ranks_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n      } else if (ranks_[parent_i] > ranks_[parent_j]) {\\n        parents_[parent_j] = parent_i;\\n      } else {\\n        parents_[parent_i] = parent_j;\\n        ++ranks_[parent_j];\\n      }\\n      return true;\\n    }\\n    \\n   private:\\n    vector<int> parents_;\\n    vector<int> ranks_;\\n  };\\n  \\n public:\\n  int largestComponentSize(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    const int max_num = *max_element(nums.begin(), nums.end());\\n    DisjointSet ds(max_num + 1);\\n    \\n    for (int i = 0; i < n; ++i) {\\n      int num = nums[i];\\n      if (num % 2 == 0) {\\n        ds.do_union(2, nums[i]);\\n        for (; num % 2 == 0; num /= 2) {\\n        }\\n      }\\n      for (int factor = 3; factor * factor <= num; factor += 2) {\\n        if (num % factor == 0) {\\n          ds.do_union(factor, nums[i]);\\n          for (; num % factor == 0; num /= factor) {\\n          }\\n        }\\n      }\\n      if (num > 1) {\\n        ds.do_union(num, nums[i]);\\n      }\\n    }\\n    \\n    int ret = 1;\\n    int parent_to_count[max_num + 1];\\n    memset(parent_to_count, 0, sizeof(parent_to_count));\\n    for (const int num : nums) {\\n      ret = max(ret, ++parent_to_count[ds.find(num)]);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701955,
                "title": "disjoint-set-factoring-sieve-beats-90-fairly-readable",
                "content": "# Intuition\\nThis solution is optimized under the assumption that the input numbers are not too large and we have a large count of numbers to process.  Under these conditions it is sensible to use a single persistent factoring sieve so that we can use the prime factorization of each input number.  We will represent components as sets of prime factors, and for each number merge together all of the sets that contain any prime factor of that number.\\n\\n# Approach\\nWe create a growable Sieve of Eratosthenes where each index in the sieve points to the smallest prime factor of that index. Also associated with the sieve is a vector of primes within the size of the sieve. The sieve provides facilities for prime factorization as well as calculating the prime counting function $$\\\\pi$$ so that primes can be mapped down tightly to contiguous array indices.\\n\\nWe also implement a disjoint set data structure, for which each subset can have a point of data associated with it. In our use case the point of data will be the number of items in the component.\\n\\nThe main loop of the algorithm consists of picking the next number `n`from `nums`, factoring it, and merging together all of the sets corresponding to prime factors of `n`.  During this process we sum up the sizes of all these sets, and finally add 1 more to represent the addition of `n` to the connected component\\n\\n# Complexity\\nLet `n = nums.size()`, and let `N` be the maximum number. Also, although it\\'s not quite accurate, our analysis assumes that disjoint set operations all take time O(1).  Note that the sieve is *static*, so in repeated use the sieve construction term falls off.\\n- Time complexity:\\nO(N(log log N) + nlog N)\\nThe sieve construction contributes the term N(log log N), and the main loop iterating over numbers and factoring them efficiently using the sieve contributes the term nlog N.\\n\\n- Space complexity:\\nO(N) for the sieve.\\n\\n# Code\\n```\\nclass GrowingSieve {\\npublic:\\n    GrowingSieve() {\\n        sieve.push_back(0);\\n        sieve.push_back(1);\\n        sieve.push_back(2);\\n        primes.push_back(2);\\n    }\\n\\n    int nextPrimeFactor(int n) {\\n        if (n < sieve.size()) {\\n            return sieve[n];\\n        }\\n        growSieve(n);\\n        return sieve[n];\\n    }\\n\\n    // This can be optimized considerably with good initial guesses.\\n    int pi(int n) {\\n        while (n > primes.back()) {\\n            growSieve(0);\\n        }\\n        auto bound = upper_bound(primes.begin(), primes.end(), n);\\n        return bound - primes.begin();\\n    }\\n\\nprivate:\\n    vector<int> sieve;\\n    vector<int> primes;\\n\\n    void growSieve(size_t n) {\\n\\n        n = max(2 * sieve.size(), n);\\n        int oldMaxN = sieve.size() - 1;\\n        sieve.reserve(n + 1);\\n        for (int i = sieve.size(); i <= n; i++) {\\n            sieve.push_back(i);\\n        }\\n\\n        for (int prime: primes) {\\n            int nextIndex = prime * (1 + oldMaxN / prime);\\n            for (int i = nextIndex; i <= n; i += prime) {\\n                sieve[i] = min(sieve[i], prime);\\n            }\\n        }\\n\\n        for (int i = oldMaxN + 1; i <= n; i++) {\\n            if (sieve[i] != i) { continue; }\\n            primes.push_back(i);\\n            for (int j = i; j <= n; j += i) {\\n                sieve[j] = min(sieve[j], i);\\n            }\\n        }\\n    }\\n};\\n\\nclass DisjointSet {\\npublic:\\n    DisjointSet(int count = 0) {\\n        grow(count - 1);\\n    }\\n\\n    void grow(int newMaxIndex) {\\n        int n = nodes.size();\\n        for (int i = n; i <= newMaxIndex; i++) {\\n            nodes.push_back(SetNode(i));\\n        }\\n    }\\n\\n    int merge(int node1, int node2) {\\n        int rep1i = representative(node1);\\n        int rep2i = representative(node2);\\n        if (rep1i == rep2i) { return -1; }\\n        SetNode& rep1 = nodes[rep1i];\\n        SetNode& rep2 = nodes[rep2i];\\n        if (rep1.size > rep2.size) {\\n            rep2.parent = rep1i;\\n            rep1.size = rep1.size + rep2.size + 1;\\n            return rep1i;\\n        } else {\\n            rep1.parent = rep2i;\\n            rep2.size = rep1.size + rep2.size + 1;\\n            return rep2i;\\n        }\\n    }\\n\\n    int representative(int node) {\\n        int root = node;\\n        while (root != nodes[root].parent) {\\n            root = nodes[root].parent;\\n        }\\n\\n        int fixer = node;\\n        while (fixer != root) {\\n            int nextFixer = nodes[fixer].parent;\\n            nodes[fixer].parent = root;\\n            fixer = nextFixer;\\n        }\\n\\n        return root;\\n    }\\n\\n    int data(int node) {\\n        return nodes[representative(node)].data;\\n    }\\n\\n    void setData(int node, int data) {\\n        nodes[representative(node)].data = data;\\n    }\\n\\nprivate:\\n    struct SetNode {\\n        SetNode(int id): parent(id), data(0), size(1) {}\\n        int data;\\n        int size;\\n        int parent;\\n    };\\n\\n    vector<SetNode> nodes;\\n};\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        DisjointSet factorSets(0);\\n        int maxSize = 1;\\n        for (int n: nums) {\\n            if (n == 1) { continue; }\\n            int lastPrime = sieve.nextPrimeFactor(n);\\n            int representativeIndex = sieve.pi(lastPrime);\\n            factorSets.grow(representativeIndex);\\n            representativeIndex = factorSets.representative(representativeIndex);\\n            n /= lastPrime;\\n            while (n > 1) {\\n                lastPrime = sieve.nextPrimeFactor(n);\\n                int representativeIndex2 = sieve.pi(lastPrime);\\n                factorSets.grow(representativeIndex2);\\n                representativeIndex2 = factorSets.representative(representativeIndex2);\\n                if (representativeIndex == representativeIndex2) { \\n                    n /= lastPrime;\\n                    continue;\\n                }\\n                int data1 = factorSets.data(representativeIndex);\\n                int data2 = factorSets.data(representativeIndex2);\\n                representativeIndex = factorSets.merge(representativeIndex, representativeIndex2);\\n                factorSets.setData(representativeIndex, data1 + data2);\\n                n /= lastPrime;\\n            }\\n            int size = factorSets.data(representativeIndex) + 1;\\n            factorSets.setData(representativeIndex, size);\\n            maxSize = max(maxSize, size);\\n        }\\n        return maxSize;\\n    }\\n\\nprivate:\\n    static GrowingSieve sieve;\\n};\\n\\nGrowingSieve Solution::sieve = GrowingSieve();\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Union Find",
                    "Number Theory"
                ],
                "code": "```\\nclass GrowingSieve {\\npublic:\\n    GrowingSieve() {\\n        sieve.push_back(0);\\n        sieve.push_back(1);\\n        sieve.push_back(2);\\n        primes.push_back(2);\\n    }\\n\\n    int nextPrimeFactor(int n) {\\n        if (n < sieve.size()) {\\n            return sieve[n];\\n        }\\n        growSieve(n);\\n        return sieve[n];\\n    }\\n\\n    // This can be optimized considerably with good initial guesses.\\n    int pi(int n) {\\n        while (n > primes.back()) {\\n            growSieve(0);\\n        }\\n        auto bound = upper_bound(primes.begin(), primes.end(), n);\\n        return bound - primes.begin();\\n    }\\n\\nprivate:\\n    vector<int> sieve;\\n    vector<int> primes;\\n\\n    void growSieve(size_t n) {\\n\\n        n = max(2 * sieve.size(), n);\\n        int oldMaxN = sieve.size() - 1;\\n        sieve.reserve(n + 1);\\n        for (int i = sieve.size(); i <= n; i++) {\\n            sieve.push_back(i);\\n        }\\n\\n        for (int prime: primes) {\\n            int nextIndex = prime * (1 + oldMaxN / prime);\\n            for (int i = nextIndex; i <= n; i += prime) {\\n                sieve[i] = min(sieve[i], prime);\\n            }\\n        }\\n\\n        for (int i = oldMaxN + 1; i <= n; i++) {\\n            if (sieve[i] != i) { continue; }\\n            primes.push_back(i);\\n            for (int j = i; j <= n; j += i) {\\n                sieve[j] = min(sieve[j], i);\\n            }\\n        }\\n    }\\n};\\n\\nclass DisjointSet {\\npublic:\\n    DisjointSet(int count = 0) {\\n        grow(count - 1);\\n    }\\n\\n    void grow(int newMaxIndex) {\\n        int n = nodes.size();\\n        for (int i = n; i <= newMaxIndex; i++) {\\n            nodes.push_back(SetNode(i));\\n        }\\n    }\\n\\n    int merge(int node1, int node2) {\\n        int rep1i = representative(node1);\\n        int rep2i = representative(node2);\\n        if (rep1i == rep2i) { return -1; }\\n        SetNode& rep1 = nodes[rep1i];\\n        SetNode& rep2 = nodes[rep2i];\\n        if (rep1.size > rep2.size) {\\n            rep2.parent = rep1i;\\n            rep1.size = rep1.size + rep2.size + 1;\\n            return rep1i;\\n        } else {\\n            rep1.parent = rep2i;\\n            rep2.size = rep1.size + rep2.size + 1;\\n            return rep2i;\\n        }\\n    }\\n\\n    int representative(int node) {\\n        int root = node;\\n        while (root != nodes[root].parent) {\\n            root = nodes[root].parent;\\n        }\\n\\n        int fixer = node;\\n        while (fixer != root) {\\n            int nextFixer = nodes[fixer].parent;\\n            nodes[fixer].parent = root;\\n            fixer = nextFixer;\\n        }\\n\\n        return root;\\n    }\\n\\n    int data(int node) {\\n        return nodes[representative(node)].data;\\n    }\\n\\n    void setData(int node, int data) {\\n        nodes[representative(node)].data = data;\\n    }\\n\\nprivate:\\n    struct SetNode {\\n        SetNode(int id): parent(id), data(0), size(1) {}\\n        int data;\\n        int size;\\n        int parent;\\n    };\\n\\n    vector<SetNode> nodes;\\n};\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        DisjointSet factorSets(0);\\n        int maxSize = 1;\\n        for (int n: nums) {\\n            if (n == 1) { continue; }\\n            int lastPrime = sieve.nextPrimeFactor(n);\\n            int representativeIndex = sieve.pi(lastPrime);\\n            factorSets.grow(representativeIndex);\\n            representativeIndex = factorSets.representative(representativeIndex);\\n            n /= lastPrime;\\n            while (n > 1) {\\n                lastPrime = sieve.nextPrimeFactor(n);\\n                int representativeIndex2 = sieve.pi(lastPrime);\\n                factorSets.grow(representativeIndex2);\\n                representativeIndex2 = factorSets.representative(representativeIndex2);\\n                if (representativeIndex == representativeIndex2) { \\n                    n /= lastPrime;\\n                    continue;\\n                }\\n                int data1 = factorSets.data(representativeIndex);\\n                int data2 = factorSets.data(representativeIndex2);\\n                representativeIndex = factorSets.merge(representativeIndex, representativeIndex2);\\n                factorSets.setData(representativeIndex, data1 + data2);\\n                n /= lastPrime;\\n            }\\n            int size = factorSets.data(representativeIndex) + 1;\\n            factorSets.setData(representativeIndex, size);\\n            maxSize = max(maxSize, size);\\n        }\\n        return maxSize;\\n    }\\n\\nprivate:\\n    static GrowingSieve sieve;\\n};\\n\\nGrowingSieve Solution::sieve = GrowingSieve();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687683,
                "title": "ram",
                "content": "class Solution {\\n    public:\\n        \\n        class DSU\\n        {\\n        public:\\n            vector<int> par;\\n            vector<int> rank;\\n            \\n            vector<int> size;\\n            DSU(int n)\\n            {\\n                rank.resize(n,1);\\n                size.resize(n,1);\\n                for(int i=0;i<n;i++)\\n                    par.push_back(i);\\n            }\\n            \\n            int find(int x)\\n            {\\n                if(par[x]==x)\\n                    return x;\\n                return par[x]=find(par[x]);\\n            }\\n            \\n            bool merge(int x,int y)\\n            {\\n                int lx=find(x);\\n                int ly=find(y);\\n                \\n                if(lx==ly)\\n                    return false;\\n                if(rank[lx]>rank[ly])\\n                {\\n                    par[ly]=lx;\\n                    size[lx]+=size[ly];\\n                }\\n                else if(rank[ly]>rank[lx])\\n                {\\n                    par[lx]=ly;\\n                    size[ly]+=size[lx];\\n                }\\n                else\\n                {\\n                    par[ly]=lx;\\n                    size[lx]+=size[ly];\\n                    rank[lx]++;\\n                }\\n                return true;\\n            }\\n            \\n            int max_size()\\n            {\\n                int ans=0;\\n                for(int e:size)\\n                    ans=max(ans,e);\\n                return ans;\\n            }\\n        };\\n        \\n        int largestComponentSize(vector<int>& nums) \\n        {\\n            int n=nums.size();\\n            DSU d(n);\\n            \\n            map<int,int> mpp;\\n            int maxi=0;\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                maxi=max(maxi,nums[i]);\\n                mpp[nums[i]]=i;\\n            }\\n            \\n            vector<bool> space(maxi+1,true);\\n            \\n            for(int i=2;i<=maxi;i++)\\n            {\\n                int last=0;\\n                if(space[i]==true)\\n                {\\n                    int j=i;\\n                    while(j<=maxi)\\n                    {\\n                        space[j]=false;\\n                        if(mpp.count(j)>0)\\n                        {\\n                            if(last!=0)\\n                            {\\n                                d.merge(mpp[last],mpp[j]);\\n                            }\\n                            last=j;\\n                        }\\n                        space[j]=false;\\n                        j+=i;\\n                    }\\n                }\\n            }\\n            return d.max_size();\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        \\n        class DSU\\n        {\\n        public:\\n            vector<int> par;\\n            vector<int> rank;\\n            \\n            vector<int> size;\\n            DSU(int n)\\n            {\\n                rank.resize(n,1);\\n                size.resize(n,1);\\n                for(int i=0;i<n;i++)\\n                    par.push_back(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3669558,
                "title": "union-find-algorithm-graphs-python3",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n\\n        union_find = DisjointSetUnion(max(nums))\\n\\n        for num in nums:\\n            for i in range(2, int(sqrt(num)) + 1):\\n                if(num % i == 0):\\n                    union_find.union(num, i)\\n                    union_find.union(num, num // i)\\n        \\n        greatest_comp_size = 0\\n        comps = defaultdict(int)\\n        for num in nums:\\n            parent = union_find.find(num)\\n            comps[parent] += 1\\n            greatest_comp_size = max(greatest_comp_size, comps[parent])\\n        return greatest_comp_size\\n\\n\\nclass DisjointSetUnion:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n+1)]\\n        self.rank = [0] * (n+1)\\n    \\n    def find(self, x):\\n        if(self.parent[x] != x):\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        root_x = self.find(x)\\n        root_y = self.find(y)\\n\\n        if(root_x == root_y):\\n            return\\n        \\n        rank_x = self.rank[root_x]\\n        rank_y = self.rank[root_y]\\n\\n        if(rank_x > rank_y):\\n            self.parent[root_y] = root_x\\n        elif(rank_x < rank_y):\\n            self.parent[root_x] = root_y\\n        else:\\n            self.parent[root_y] = root_x\\n            self.rank[root_x] += 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n\\n        union_find = DisjointSetUnion(max(nums))\\n\\n        for num in nums:\\n            for i in range(2, int(sqrt(num)) + 1):\\n                if(num % i == 0):\\n                    union_find.union(num, i)\\n                    union_find.union(num, num // i)\\n        \\n        greatest_comp_size = 0\\n        comps = defaultdict(int)\\n        for num in nums:\\n            parent = union_find.find(num)\\n            comps[parent] += 1\\n            greatest_comp_size = max(greatest_comp_size, comps[parent])\\n        return greatest_comp_size\\n\\n\\nclass DisjointSetUnion:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n+1)]\\n        self.rank = [0] * (n+1)\\n    \\n    def find(self, x):\\n        if(self.parent[x] != x):\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        root_x = self.find(x)\\n        root_y = self.find(y)\\n\\n        if(root_x == root_y):\\n            return\\n        \\n        rank_x = self.rank[root_x]\\n        rank_y = self.rank[root_y]\\n\\n        if(rank_x > rank_y):\\n            self.parent[root_y] = root_x\\n        elif(rank_x < rank_y):\\n            self.parent[root_x] = root_y\\n        else:\\n            self.parent[root_y] = root_x\\n            self.rank[root_x] += 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669556,
                "title": "union-find-algorithm-graphs-python3",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n\\n        union_find = DisjointSetUnion(max(nums))\\n\\n        for num in nums:\\n            for i in range(2, int(sqrt(num)) + 1):\\n                if(num % i == 0):\\n                    union_find.union(num, i)\\n                    union_find.union(num, num // i)\\n        \\n        greatest_comp_size = 0\\n        comps = defaultdict(int)\\n        for num in nums:\\n            parent = union_find.find(num)\\n            comps[parent] += 1\\n            greatest_comp_size = max(greatest_comp_size, comps[parent])\\n        return greatest_comp_size\\n\\n\\nclass DisjointSetUnion:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n+1)]\\n        self.rank = [0] * (n+1)\\n    \\n    def find(self, x):\\n        if(self.parent[x] != x):\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        root_x = self.find(x)\\n        root_y = self.find(y)\\n\\n        if(root_x == root_y):\\n            return\\n        \\n        rank_x = self.rank[root_x]\\n        rank_y = self.rank[root_y]\\n\\n        if(rank_x > rank_y):\\n            self.parent[root_y] = root_x\\n        elif(rank_x < rank_y):\\n            self.parent[root_x] = root_y\\n        else:\\n            self.parent[root_y] = root_x\\n            self.rank[root_x] += 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n\\n        union_find = DisjointSetUnion(max(nums))\\n\\n        for num in nums:\\n            for i in range(2, int(sqrt(num)) + 1):\\n                if(num % i == 0):\\n                    union_find.union(num, i)\\n                    union_find.union(num, num // i)\\n        \\n        greatest_comp_size = 0\\n        comps = defaultdict(int)\\n        for num in nums:\\n            parent = union_find.find(num)\\n            comps[parent] += 1\\n            greatest_comp_size = max(greatest_comp_size, comps[parent])\\n        return greatest_comp_size\\n\\n\\nclass DisjointSetUnion:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n+1)]\\n        self.rank = [0] * (n+1)\\n    \\n    def find(self, x):\\n        if(self.parent[x] != x):\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        root_x = self.find(x)\\n        root_y = self.find(y)\\n\\n        if(root_x == root_y):\\n            return\\n        \\n        rank_x = self.rank[root_x]\\n        rank_y = self.rank[root_y]\\n\\n        if(rank_x > rank_y):\\n            self.parent[root_y] = root_x\\n        elif(rank_x < rank_y):\\n            self.parent[root_x] = root_y\\n        else:\\n            self.parent[root_y] = root_x\\n            self.rank[root_x] += 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661433,
                "title": "clear-solution-using-union-find-n-log-m-c",
                "content": "# Intuition\\nThe questions revolves around finding the maximum length of a connected component in a graph. Thus, we should naturally think in direction of **Union Find** Incase you can\\'t figure this out I think you should do some related graph questions before jumping here!\\n\\n# Approach\\nWe know that nums[i] and nums[j] for any i != j  share an edge if both have any common factor greater than 1. \\n\\nSo we can do prime factorisation of all the number and maintain a  {prime , vector of nums} map. Now we will union all the num within mapped to a single prime number as they can be grouped in one connected component. \\n\\nEg : nums: { 4,6,15,35} then map will contain \\n{\\n{2: {4,6}},\\n{3: {6,15}},\\n{5: {15,35}},\\n{7: {35} }\\n}\\n\\nNow we will union all the number within a vector mapped to a prime number. \\nFor 2 we will union 4,6. Similarly we will union 6,15 for prime = 3. And so on.\\n\\nNow our DSU will have one connected component of size 4. Thus we will return 4. In this case we have only one connected component. Try with different numbers!\\n\\nAtlast we will find the maximum size among all the components.\\n\\n# Complexity\\n- Time complexity:\\nConsidering the Union-Find to be constant we have N * sqrt(M) where M is max element in the array.\\n\\n- Space complexity:\\nO(M) where M is max element in array.\\n\\n# Code\\n```\\n struct dsu{\\n     \\n      vector <int> par,size;\\n  \\n     dsu(int n) {\\n      \\n         par.resize(n);\\n         size.resize(n,1);\\n        for (int i=0;i<n;i++) {\\n             par[i]=i;\\n           \\n         }\\n     }\\n     \\n     int find(int x)  {\\n         if (par[x]==x) {return x;}\\n         return par[x]=find(par[x]);\\n     }\\n   \\n     void _union(int x,int y)  {\\n         x=find(x);y=find(y);\\n         if (x!=y) {\\n           // add subtree with larger parent to subtree with smaller parent and update the size\\n            if (x < y) {\\n    par[y]=x;\\n             size[x]+=size[y];size[y]=0;\\n            }\\n            else {\\n                    par[x]=y;\\n             size[y]+=size[x];\\n             size[x]=0;\\n            }\\n         \\n          \\n         }\\n     }\\n     \\n };\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        unordered_map < int , set <int> > mp;\\n    int mx=0;\\n        for (auto i:nums) {\\n         int n=i;mx=max(n,mx);\\n               while (i%2 == 0) {\\n                   i=i/2;\\n                   mp[2].insert(n);\\n               }\\n\\n               for (int j=3;j*j<=i;j++) {\\n                  while (i%j==0) {\\n                       mp[j].insert(n);\\n                       i=i/j;\\n                   }\\n               }\\n\\n               if (i>1) {\\n                   mp[i].insert(n);\\n               }\\n        }\\n     dsu mydsu(mx+1);\\n        for (auto &i:mp) {\\n             int fr=  *((i.second).begin());\\n            for (auto &num:i.second) {\\n                mydsu._union(fr,num);\\n         \\n            }\\n        }\\n\\n        int ans=1;\\n        for (int i=0;i<(mx+1);i++) {\\n            ans=max(ans , mydsu.size[i]);\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\n struct dsu{\\n     \\n      vector <int> par,size;\\n  \\n     dsu(int n) {\\n      \\n         par.resize(n);\\n         size.resize(n,1);\\n        for (int i=0;i<n;i++) {\\n             par[i]=i;\\n           \\n         }\\n     }\\n     \\n     int find(int x)  {\\n         if (par[x]==x) {return x;}\\n         return par[x]=find(par[x]);\\n     }\\n   \\n     void _union(int x,int y)  {\\n         x=find(x);y=find(y);\\n         if (x!=y) {\\n           // add subtree with larger parent to subtree with smaller parent and update the size\\n            if (x < y) {\\n    par[y]=x;\\n             size[x]+=size[y];size[y]=0;\\n            }\\n            else {\\n                    par[x]=y;\\n             size[y]+=size[x];\\n             size[x]=0;\\n            }\\n         \\n          \\n         }\\n     }\\n     \\n };\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        unordered_map < int , set <int> > mp;\\n    int mx=0;\\n        for (auto i:nums) {\\n         int n=i;mx=max(n,mx);\\n               while (i%2 == 0) {\\n                   i=i/2;\\n                   mp[2].insert(n);\\n               }\\n\\n               for (int j=3;j*j<=i;j++) {\\n                  while (i%j==0) {\\n                       mp[j].insert(n);\\n                       i=i/j;\\n                   }\\n               }\\n\\n               if (i>1) {\\n                   mp[i].insert(n);\\n               }\\n        }\\n     dsu mydsu(mx+1);\\n        for (auto &i:mp) {\\n             int fr=  *((i.second).begin());\\n            for (auto &num:i.second) {\\n                mydsu._union(fr,num);\\n         \\n            }\\n        }\\n\\n        int ans=1;\\n        for (int i=0;i<(mx+1);i++) {\\n            ans=max(ans , mydsu.size[i]);\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647459,
                "title": "approach-explained-largest-component-size-using-dsu-easy-to-understand",
                "content": "# Code\\n```\\nclass DisjointSet{\\npublic:\\n    vector<int>rank,size,parent;\\n\\n    DisjointSet(int n){\\n        rank.resize(n+1,0);\\n        size.resize(n+1,1);\\n        parent.resize(n+1);\\n\\n        //Initially,every node is a prent of itself \\n        for(int i=0;i<=n;i++){\\n            parent[i]=i;\\n        }\\n    }\\n\\n    //FIND ULTIMATE PARENT\\n    int findUltimatePrent(int node){\\n            return node==parent[node]?node:parent[node]=findUltimatePrent(parent[node]) ;\\n    }\\n\\n    //UNION BY RANK\\n    void UnionByRank(int u,int v){\\n        int ulp_u = findUltimatePrent(u);\\n        int ulp_v = findUltimatePrent(v);\\n\\n        //4 case \\n\\n        //case 1 :- SAME COMPONENT THAN RETURN \\n        if(ulp_u==ulp_v) return;\\n\\n        //case 2 :- rank[ulp_u] < ranl[ulp_v] \\n        //smaller get connected to larger and parent of smaller updated to larger one\\n        if(rank[ulp_u]<rank[ulp_v]){\\n            parent[ulp_u]=ulp_v;\\n        }\\n\\n         //case 3 :- rank[ulp_u] < ranl[ulp_v] \\n        //smaller get connected to larger and parent of smaller updated to larger one\\n        if(rank[ulp_u]>rank[ulp_v]){\\n            parent[ulp_v]=ulp_u;\\n        }\\n\\n         //case 4 :- rank[ulp_u] == ranl[ulp_v] \\n        //anyone get connected to other one and parent of node getting connected updated\\n        if(rank[ulp_u]==rank[ulp_v]){\\n            parent[ulp_u]=ulp_v; // ulp_u connected to ulp_v\\n            rank[ulp_v]++;// since connected to ulp_v its rank increased\\n        }\\n    }\\n    void UnionBySize(int u,int v){\\n        int ulp_u = findUltimatePrent(u);\\n        int ulp_v = findUltimatePrent(v);\\n\\n        //4 cases \\n\\n        //case 1:- SAME COMPONENT THAN RETURN \\n        if(ulp_u == ulp_v) return;\\n\\n        //case 2: -NOT BELONGING TO SAME COMPONENT \\n         //smaller get connected to larger and parent of smaller updated to larger one\\n         //and size of larger one updated by including size of smaller one\\n        if(size[ulp_u]<size[ulp_v]){\\n            parent[ulp_u]=ulp_v;\\n            size[ulp_v]+=size[ulp_u];\\n        }\\n\\n         //case 3: -NOT BELONGING TO SAME COMPONENT \\n         //smaller get connected to larger and parent of smaller updated to larger one\\n         //and size of larger one updated by including size of smaller one\\n        if(size[ulp_u]>size[ulp_v]){\\n            parent[ulp_v]=ulp_u;\\n            size[ulp_u]+=size[ulp_v];\\n        }\\n\\n         //case 4: -NOT BELONGING TO SAME COMPONENT \\n         //anyone get connected to other node and parent of node getting connected\\n         // is updated to one from whom connected\\n         //and size of node from whom connected is updated by including \\n         //size of node getting connected\\n        if(size[ulp_u]==size[ulp_v]){\\n            parent[ulp_u]=ulp_v; // ulp_u connected to ulp_v\\n            size[ulp_v]+=size[ulp_u]; // size of ulp_v increased by size of ulp_u\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        //2709. Greatest Common Divisor Traversal -> same concept question\\n        \\n        //Time Complexity : O(N * log(max(num)))  \\n        // USE PRIME FACTORIZATION \\n        // STORE EVERY INDEX AS A FACTOR FOR A PRIME NO \\n        //EX. 2-> POSITION WHERE 2 ARE FACTOR OF A NUMBER \\n        // 3 -> , 5-> ...SO ON \\n        //THAN, USE DSU AND MAKE COMPONENT USING INDEX \\n       //THAN, FIND LARGEST SIZE OF A COMPONENT \\n\\n       map<int,vector<int>>factor; \\n       int n = nums.size();\\n       for(int i=0;i<n;i++){\\n           for(int j=2;j*j<=nums[i];j++){\\n               if(nums[i]%j==0){\\n                   //CONTRIBUTION OF PRIME NO AT WHICH INDEX AS FACTOR ARE STORED\\n                   factor[j].push_back(i);\\n                   //ex:- 100%2=0 -> 100/2=50%2 =0 -> 50/2 = 25 -> now,stop\\n                  //  and search for other prime factor\\n                   while(nums[i]%j==0) nums[i]/=j; \\n               }\\n           }\\n           //ex:- 6 -> 6%2=0 -> 6/2=3 \\n           //now,since 3*3=9>6 therefore out of loop \\n           //but,still 3 left to see and store position \\n           if(nums[i]>1) factor[nums[i]].push_back(i) ; \\n       }\\n       \\n       //NOW, APPLY UNION LOGIC\\n       DisjointSet ds(n);\\n       for(auto&it:factor){\\n           vector<int>prime_pos = it.second;\\n           //DO UNION \\n           for(int i=0;i<prime_pos.size()-1;i++){\\n               ds.UnionBySize(prime_pos[i],prime_pos[i+1]);\\n           }\\n       }\\n\\n       //NOW,SEE FOR LARGEST COMPONENT SIZE \\n       int LargestComponent = 0 ;\\n       for(int i=0;i<n;i++){\\n        //   cout<<ds.size[i]<<\" \";\\n           LargestComponent=max(LargestComponent,ds.size[i]);\\n       }\\n       return LargestComponent;\\n    }\\n};\\n```\\n\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet{\\npublic:\\n    vector<int>rank,size,parent;\\n\\n    DisjointSet(int n){\\n        rank.resize(n+1,0);\\n        size.resize(n+1,1);\\n        parent.resize(n+1);\\n\\n        //Initially,every node is a prent of itself \\n        for(int i=0;i<=n;i++){\\n            parent[i]=i;\\n        }\\n    }\\n\\n    //FIND ULTIMATE PARENT\\n    int findUltimatePrent(int node){\\n            return node==parent[node]?node:parent[node]=findUltimatePrent(parent[node]) ;\\n    }\\n\\n    //UNION BY RANK\\n    void UnionByRank(int u,int v){\\n        int ulp_u = findUltimatePrent(u);\\n        int ulp_v = findUltimatePrent(v);\\n\\n        //4 case \\n\\n        //case 1 :- SAME COMPONENT THAN RETURN \\n        if(ulp_u==ulp_v) return;\\n\\n        //case 2 :- rank[ulp_u] < ranl[ulp_v] \\n        //smaller get connected to larger and parent of smaller updated to larger one\\n        if(rank[ulp_u]<rank[ulp_v]){\\n            parent[ulp_u]=ulp_v;\\n        }\\n\\n         //case 3 :- rank[ulp_u] < ranl[ulp_v] \\n        //smaller get connected to larger and parent of smaller updated to larger one\\n        if(rank[ulp_u]>rank[ulp_v]){\\n            parent[ulp_v]=ulp_u;\\n        }\\n\\n         //case 4 :- rank[ulp_u] == ranl[ulp_v] \\n        //anyone get connected to other one and parent of node getting connected updated\\n        if(rank[ulp_u]==rank[ulp_v]){\\n            parent[ulp_u]=ulp_v; // ulp_u connected to ulp_v\\n            rank[ulp_v]++;// since connected to ulp_v its rank increased\\n        }\\n    }\\n    void UnionBySize(int u,int v){\\n        int ulp_u = findUltimatePrent(u);\\n        int ulp_v = findUltimatePrent(v);\\n\\n        //4 cases \\n\\n        //case 1:- SAME COMPONENT THAN RETURN \\n        if(ulp_u == ulp_v) return;\\n\\n        //case 2: -NOT BELONGING TO SAME COMPONENT \\n         //smaller get connected to larger and parent of smaller updated to larger one\\n         //and size of larger one updated by including size of smaller one\\n        if(size[ulp_u]<size[ulp_v]){\\n            parent[ulp_u]=ulp_v;\\n            size[ulp_v]+=size[ulp_u];\\n        }\\n\\n         //case 3: -NOT BELONGING TO SAME COMPONENT \\n         //smaller get connected to larger and parent of smaller updated to larger one\\n         //and size of larger one updated by including size of smaller one\\n        if(size[ulp_u]>size[ulp_v]){\\n            parent[ulp_v]=ulp_u;\\n            size[ulp_u]+=size[ulp_v];\\n        }\\n\\n         //case 4: -NOT BELONGING TO SAME COMPONENT \\n         //anyone get connected to other node and parent of node getting connected\\n         // is updated to one from whom connected\\n         //and size of node from whom connected is updated by including \\n         //size of node getting connected\\n        if(size[ulp_u]==size[ulp_v]){\\n            parent[ulp_u]=ulp_v; // ulp_u connected to ulp_v\\n            size[ulp_v]+=size[ulp_u]; // size of ulp_v increased by size of ulp_u\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        //2709. Greatest Common Divisor Traversal -> same concept question\\n        \\n        //Time Complexity : O(N * log(max(num)))  \\n        // USE PRIME FACTORIZATION \\n        // STORE EVERY INDEX AS A FACTOR FOR A PRIME NO \\n        //EX. 2-> POSITION WHERE 2 ARE FACTOR OF A NUMBER \\n        // 3 -> , 5-> ...SO ON \\n        //THAN, USE DSU AND MAKE COMPONENT USING INDEX \\n       //THAN, FIND LARGEST SIZE OF A COMPONENT \\n\\n       map<int,vector<int>>factor; \\n       int n = nums.size();\\n       for(int i=0;i<n;i++){\\n           for(int j=2;j*j<=nums[i];j++){\\n               if(nums[i]%j==0){\\n                   //CONTRIBUTION OF PRIME NO AT WHICH INDEX AS FACTOR ARE STORED\\n                   factor[j].push_back(i);\\n                   //ex:- 100%2=0 -> 100/2=50%2 =0 -> 50/2 = 25 -> now,stop\\n                  //  and search for other prime factor\\n                   while(nums[i]%j==0) nums[i]/=j; \\n               }\\n           }\\n           //ex:- 6 -> 6%2=0 -> 6/2=3 \\n           //now,since 3*3=9>6 therefore out of loop \\n           //but,still 3 left to see and store position \\n           if(nums[i]>1) factor[nums[i]].push_back(i) ; \\n       }\\n       \\n       //NOW, APPLY UNION LOGIC\\n       DisjointSet ds(n);\\n       for(auto&it:factor){\\n           vector<int>prime_pos = it.second;\\n           //DO UNION \\n           for(int i=0;i<prime_pos.size()-1;i++){\\n               ds.UnionBySize(prime_pos[i],prime_pos[i+1]);\\n           }\\n       }\\n\\n       //NOW,SEE FOR LARGEST COMPONENT SIZE \\n       int LargestComponent = 0 ;\\n       for(int i=0;i<n;i++){\\n        //   cout<<ds.size[i]<<\" \";\\n           LargestComponent=max(LargestComponent,ds.size[i]);\\n       }\\n       return LargestComponent;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3646459,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUnion find \\n\\n# Complexity \\n- Time complexity: O(n * sqrt(m)), where m = max(nums)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def largestComponentSize(nums: Array[Int]): Int = {\\n\\n      val uf = UnionFind(100001)\\n      for (n <- nums) {\\n        var i = 2\\n        while (i * i <= n) {\\n          if (n % i == 0) {\\n            uf.union(n, i)\\n            uf.union(n, n / i)\\n          }\\n          i += 1\\n        }\\n      }\\n      val map = collection.mutable.Map[Int, Int]()\\n      var max = 1\\n      for (n <- nums) {\\n        val root = uf.find(n)\\n        val count = map.getOrElse(root, 0) + 1\\n        map(root) = count\\n        max = math.max(max, count)\\n      }\\n      max\\n    }\\n  }\\n\\n  case class UnionFind(n: Int) {\\n    private val parent = Array.tabulate(n)(identity)\\n    private val size = Array.fill(n)(1)\\n\\n    def find(x: Int): Int = {\\n      if (parent(x) != x) parent(x) = find(parent(x))\\n      parent(x)\\n    }\\n\\n    def union(x: Int, y: Int): Unit = {\\n      val (rootX, rootY) = (find(x), find(y))\\n      if (rootX != rootY) {\\n        if (size(rootX) < size(rootY)) {\\n          parent(rootX) = rootY\\n          size(rootY) += size(rootX)\\n        } else {\\n          parent(rootY) = rootX\\n          size(rootX) += size(rootY)\\n        }\\n      }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def largestComponentSize(nums: Array[Int]): Int = {\\n\\n      val uf = UnionFind(100001)\\n      for (n <- nums) {\\n        var i = 2\\n        while (i * i <= n) {\\n          if (n % i == 0) {\\n            uf.union(n, i)\\n            uf.union(n, n / i)\\n          }\\n          i += 1\\n        }\\n      }\\n      val map = collection.mutable.Map[Int, Int]()\\n      var max = 1\\n      for (n <- nums) {\\n        val root = uf.find(n)\\n        val count = map.getOrElse(root, 0) + 1\\n        map(root) = count\\n        max = math.max(max, count)\\n      }\\n      max\\n    }\\n  }\\n\\n  case class UnionFind(n: Int) {\\n    private val parent = Array.tabulate(n)(identity)\\n    private val size = Array.fill(n)(1)\\n\\n    def find(x: Int): Int = {\\n      if (parent(x) != x) parent(x) = find(parent(x))\\n      parent(x)\\n    }\\n\\n    def union(x: Int, y: Int): Unit = {\\n      val (rootX, rootY) = (find(x), find(y))\\n      if (rootX != rootY) {\\n        if (size(rootX) < size(rootY)) {\\n          parent(rootX) = rootY\\n          size(rootY) += size(rootX)\\n        } else {\\n          parent(rootY) = rootX\\n          size(rootX) += size(rootY)\\n        }\\n      }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586078,
                "title": "17-lines",
                "content": "```ruby\\nrequire \\'prime\\'\\n\\n@m = {}\\n\\ndef largest_component_size a\\n    p, c = Hash.new { _1[_2] = _2 }, Hash.new(0)\\n    f = -> x { p[x] == x ? x : (p[x] = f.(p[x])) }\\n    a.each { c[_1] = 1 }\\n    a.each do | a |\\n        (@m[a] ||= a.prime_division).each do | b, _ |\\n            next if (ra = f.(a)) == (rb = f.(b))\\n            ra, rb = rb, ra if c[ra] < c[rb]\\n            p[rb] = ra; c[ra] += c[rb]\\n        end\\n    end\\n    c.each_value.max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nrequire \\'prime\\'\\n\\n@m = {}\\n\\ndef largest_component_size a\\n    p, c = Hash.new { _1[_2] = _2 }, Hash.new(0)\\n    f = -> x { p[x] == x ? x : (p[x] = f.(p[x])) }\\n    a.each { c[_1] = 1 }\\n    a.each do | a |\\n        (@m[a] ||= a.prime_division).each do | b, _ |\\n            next if (ra = f.(a)) == (rb = f.(b))\\n            ra, rb = rb, ra if c[ra] < c[rb]\\n            p[rb] = ra; c[ra] += c[rb]\\n        end\\n    end\\n    c.each_value.max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3572255,
                "title": "c-dsu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet {\\npublic:\\n    vector<int> parent, size;\\n\\n    DisjointSet(int n) {\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n   \\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int size = *max_element(nums.begin(), nums.end());\\n        DisjointSet ds(size+1);\\n\\n        for(int i=0; i<nums.size(); ++i){\\n            for(int j=2; j<=sqrt(nums[i]); ++j){\\n                if(nums[i]%j==0){\\n                    ds.unionBySize(nums[i], j);\\n                    ds.unionBySize(nums[i]/j, j);\\n                }\\n            }\\n        }\\n        \\n        map<int,int> k;\\n        int maxnodeconnected=0;\\n        for(auto it: nums){\\n            int p=ds.findUPar(it);\\n            k[p]++;\\n            maxnodeconnected=max(k[p],maxnodeconnected);\\n        }\\n        return maxnodeconnected;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> parent, size;\\n\\n    DisjointSet(int n) {\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n   \\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int size = *max_element(nums.begin(), nums.end());\\n        DisjointSet ds(size+1);\\n\\n        for(int i=0; i<nums.size(); ++i){\\n            for(int j=2; j<=sqrt(nums[i]); ++j){\\n                if(nums[i]%j==0){\\n                    ds.unionBySize(nums[i], j);\\n                    ds.unionBySize(nums[i]/j, j);\\n                }\\n            }\\n        }\\n        \\n        map<int,int> k;\\n        int maxnodeconnected=0;\\n        for(auto it: nums){\\n            int p=ds.findUPar(it);\\n            k[p]++;\\n            maxnodeconnected=max(k[p],maxnodeconnected);\\n        }\\n        return maxnodeconnected;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554094,
                "title": "ruby-union-find-solution",
                "content": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\nrequire \\'prime\\'\\n\\nclass UnionFindTree\\n  def initialize(n)\\n    @parent = (0...n).to_a\\n    @rank = [0] * n\\n  end\\n\\n  def unite(a, b)\\n    root_a, root_b = root(a), root(b)\\n    return if root_a == root_b\\n    if @rank[root_a] < @rank[root_b]\\n      @parent[root_a] = root_b\\n    else\\n      @parent[root_b] = root_a\\n      @rank[root_a] += 1 if @rank[root_a] == @rank[root_b]\\n    end\\n  end\\n\\n  def root(a)\\n    return a if @parent[a] == a\\n    @parent[a] = root(@parent[a])\\n  end\\nend\\n\\ndef largest_component_size(nums)\\n  union_find_tree = UnionFindTree.new(nums.max+1)\\n  nums.each {|num|\\n    Prime.prime_division(num).each {|prime, _|\\n      union_find_tree.unite(prime, num)\\n    }\\n  }\\n  max = 0\\n  counts = Hash.new(0)\\n  nums.each {|num|\\n    max = [max, counts[union_find_tree.root(num)] += 1].max\\n  }\\n  max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\nrequire \\'prime\\'\\n\\nclass UnionFindTree\\n  def initialize(n)\\n    @parent = (0...n).to_a\\n    @rank = [0] * n\\n  end\\n\\n  def unite(a, b)\\n    root_a, root_b = root(a), root(b)\\n    return if root_a == root_b\\n    if @rank[root_a] < @rank[root_b]\\n      @parent[root_a] = root_b\\n    else\\n      @parent[root_b] = root_a\\n      @rank[root_a] += 1 if @rank[root_a] == @rank[root_b]\\n    end\\n  end\\n\\n  def root(a)\\n    return a if @parent[a] == a\\n    @parent[a] = root(@parent[a])\\n  end\\nend\\n\\ndef largest_component_size(nums)\\n  union_find_tree = UnionFindTree.new(nums.max+1)\\n  nums.each {|num|\\n    Prime.prime_division(num).each {|prime, _|\\n      union_find_tree.unite(prime, num)\\n    }\\n  }\\n  max = 0\\n  counts = Hash.new(0)\\n  nums.each {|num|\\n    max = [max, counts[union_find_tree.root(num)] += 1].max\\n  }\\n  max\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509720,
                "title": "dsu-approch-c",
                "content": "\\n# Code\\n```\\nclass UnionFind {\\npublic:\\n    UnionFind(int sz) : root(sz+1), rank(sz+1) {\\n        for (int i = 0; i < sz+1; i++) {\\n            root[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n\\n    int find(int x) {\\n        if (x == root[x]) {\\n            return x;\\n        }\\n        return root[x] = find(root[x]);\\n    }\\n\\n    int unionSet(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if (rootX != rootY) {\\n            if (rank[rootX] > rank[rootY]) {\\n                root[rootY] = rootX;\\n            } else if (rank[rootX] < rank[rootY]) {\\n                root[rootX] = rootY;\\n            } else {\\n                root[rootY] = rootX;\\n                rank[rootX] += 1;\\n            }\\n        }\\n    return rootY;\\n    }\\n\\n    bool connected(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n\\nprivate:\\n    vector<int> root;\\n    vector<int> rank;\\n};\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n      int maxValue = *max_element(nums.begin(),nums.end());\\n      UnionFind dsu(maxValue);\\n      for (int num:nums){\\n          for(int factor=2;factor<int(sqrt(num))+1;factor++) {\\n             // cout<<factor<<\" \";\\n              if(num%factor==0){\\n                  \\n                  dsu.unionSet(num,factor);\\n                  dsu.unionSet(num,int(num/factor));\\n              }\\n          }\\n\\n      }\\n      int maxG=0;\\n      unordered_map<int,int>gc;\\n      for(auto num:nums){\\n          int gid=dsu.find(num);\\n          int count=0;\\n          if(gc.find(gid)!=gc.end())\\n             count=gc[gid];\\n          gc[gid]++;\\n          maxG=max(maxG,count+1);\\n      }\\n     return maxG;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UnionFind {\\npublic:\\n    UnionFind(int sz) : root(sz+1), rank(sz+1) {\\n        for (int i = 0; i < sz+1; i++) {\\n            root[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n\\n    int find(int x) {\\n        if (x == root[x]) {\\n            return x;\\n        }\\n        return root[x] = find(root[x]);\\n    }\\n\\n    int unionSet(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if (rootX != rootY) {\\n            if (rank[rootX] > rank[rootY]) {\\n                root[rootY] = rootX;\\n            } else if (rank[rootX] < rank[rootY]) {\\n                root[rootX] = rootY;\\n            } else {\\n                root[rootY] = rootX;\\n                rank[rootX] += 1;\\n            }\\n        }\\n    return rootY;\\n    }\\n\\n    bool connected(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n\\nprivate:\\n    vector<int> root;\\n    vector<int> rank;\\n};\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n      int maxValue = *max_element(nums.begin(),nums.end());\\n      UnionFind dsu(maxValue);\\n      for (int num:nums){\\n          for(int factor=2;factor<int(sqrt(num))+1;factor++) {\\n             // cout<<factor<<\" \";\\n              if(num%factor==0){\\n                  \\n                  dsu.unionSet(num,factor);\\n                  dsu.unionSet(num,int(num/factor));\\n              }\\n          }\\n\\n      }\\n      int maxG=0;\\n      unordered_map<int,int>gc;\\n      for(auto num:nums){\\n          int gid=dsu.find(num);\\n          int count=0;\\n          if(gc.find(gid)!=gc.end())\\n             count=gc[gid];\\n          gc[gid]++;\\n          maxG=max(maxG,count+1);\\n      }\\n     return maxG;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3477991,
                "title": "c-bfs-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a undirected graph using prime factors then count the largest connected component.\\n\\nNote: we only need to count those nodes which were there in the original list.\\n# Complexity\\n M: max digit\\n- Time complexity: O(N * sqrt(M))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N + M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> adj;\\n    void connect(int n){\\n        int val = n;\\n        bool canAdd = true;\\n        while(n % 2 == 0){\\n            if(canAdd){\\n                adj[2].push_back(val);\\n                adj[val].push_back(2);\\n                canAdd = false;\\n            }\\n            \\n            n = n / 2;\\n        }\\n        for(int i = 3; i * i <= n; i+=2){\\n            canAdd = true;\\n            while(n % i == 0){\\n                if(canAdd){\\n                    adj[i].push_back(val);\\n                    adj[val].push_back(i);\\n                    canAdd = false;\\n                }\\n                n = n / i;\\n            }\\n        }\\n        if(n > 2){\\n            adj[n].push_back(val);\\n            adj[val].push_back(n);\\n        }\\n    }\\n    int largestComponentSize(vector<int>& A) {\\n        unordered_set<int> visited, original;\\n        for(int &x: A)  connect(x), original.insert(x);\\n        int ans = 0;\\n        for(int &x: A){\\n            if(visited.count(x))    continue;\\n            int count = 0;\\n            queue<int> q;\\n            q.push(x);\\n            while(!q.empty()){\\n                int temp = q.front();\\n                q.pop();\\n                if(visited.count(temp)) continue;\\n                if(original.count(temp))    count++;\\n                visited.insert(temp);\\n                for(auto &v: adj[temp]) q.push(v);\\n            }\\n            ans = max(ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> adj;\\n    void connect(int n){\\n        int val = n;\\n        bool canAdd = true;\\n        while(n % 2 == 0){\\n            if(canAdd){\\n                adj[2].push_back(val);\\n                adj[val].push_back(2);\\n                canAdd = false;\\n            }\\n            \\n            n = n / 2;\\n        }\\n        for(int i = 3; i * i <= n; i+=2){\\n            canAdd = true;\\n            while(n % i == 0){\\n                if(canAdd){\\n                    adj[i].push_back(val);\\n                    adj[val].push_back(i);\\n                    canAdd = false;\\n                }\\n                n = n / i;\\n            }\\n        }\\n        if(n > 2){\\n            adj[n].push_back(val);\\n            adj[val].push_back(n);\\n        }\\n    }\\n    int largestComponentSize(vector<int>& A) {\\n        unordered_set<int> visited, original;\\n        for(int &x: A)  connect(x), original.insert(x);\\n        int ans = 0;\\n        for(int &x: A){\\n            if(visited.count(x))    continue;\\n            int count = 0;\\n            queue<int> q;\\n            q.push(x);\\n            while(!q.empty()){\\n                int temp = q.front();\\n                q.pop();\\n                if(visited.count(temp)) continue;\\n                if(original.count(temp))    count++;\\n                visited.insert(temp);\\n                for(auto &v: adj[temp]) q.push(v);\\n            }\\n            ans = max(ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477140,
                "title": "brute-ac-c-connect-the-factors-of-the-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n# brute force tle\\n**<!-- Describe your approach to solving the problem. -->\\n\\nclass disjointset{\\n    public:\\n    vector<int>parent,size;\\n    disjointset(int n){\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++)parent[i]=i;\\n        size.resize(n+1,1);\\n    }\\n    int findp(int u){\\n        if(parent[u]==u)return u;\\n        return parent[u]=findp(parent[u]);\\n\\n    }\\n    void unionbysize(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return ;\\n        if(size[ult_u]<=size[ult_v]){\\n            parent[ult_u]=ult_v;\\n            size[ult_v]+=size[ult_u];\\n\\n        }\\n        else{\\n            parent[ult_v]=ult_u;\\n            size[ult_u]+=size[ult_v];\\n        }\\n        \\n    }\\n};\\nclass Solution {\\npublic:\\n    int gcd(int a, int b) {\\n\\tfor(int i=min(a,b);i>1;i--){\\n        if(a%i==0&&b%i==0)\\nreturn 5;\\n    }\\n    return 0;\\n}\\n    int largestComponentSize(vector<int>& nums) {\\n        int maxi=-1e9;\\n        disjointset ds(*max_element(nums.begin(),nums.end()));\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(gcd(nums[i],nums[j])>1){\\n                    ds.unionbysize(nums[i],nums[j]);\\n                    maxi=max(maxi,ds.size[ds.findp(nums[i])]);\\n\\n                }\\n                if(maxi==nums.size())break;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n# AC \\n```\\nclass disjointset{\\n    public:\\n    vector<int>parent,size;\\n    disjointset(int n){\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++)parent[i]=i;\\n        size.resize(n+1,1);\\n    }\\n    int findp(int u){\\n        if(parent[u]==u)return u;\\n        return parent[u]=findp(parent[u]);\\n\\n    }\\n    void unionbysize(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return ;\\n        if(size[ult_u]<=size[ult_v]){\\n            parent[ult_u]=ult_v;\\n            size[ult_v]+=size[ult_u];\\n\\n        }\\n        else{\\n            parent[ult_v]=ult_u;\\n            size[ult_u]+=size[ult_v];\\n        }\\n        \\n    }\\n};\\nclass Solution {\\npublic:\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int maxi=-1e9;\\n        disjointset ds(*max_element(nums.begin(),nums.end()));\\n        for(auto i:nums){\\n            for(int j=2;j*j<=i;j++){\\n                if(i%j==0){\\n                    ds.unionbysize(i,j);\\n                    ds.unionbysize(i,i/j);\\n                }\\n            }\\n        }\\n        map<int,int>m;\\n        for(auto i:nums){\\n            maxi=max(maxi,m[ds.findp(i)]++);\\n            \\n            \\n        }\\n        return maxi+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass disjointset{\\n    public:\\n    vector<int>parent,size;\\n    disjointset(int n){\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++)parent[i]=i;\\n        size.resize(n+1,1);\\n    }\\n    int findp(int u){\\n        if(parent[u]==u)return u;\\n        return parent[u]=findp(parent[u]);\\n\\n    }\\n    void unionbysize(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return ;\\n        if(size[ult_u]<=size[ult_v]){\\n            parent[ult_u]=ult_v;\\n            size[ult_v]+=size[ult_u];\\n\\n        }\\n        else{\\n            parent[ult_v]=ult_u;\\n            size[ult_u]+=size[ult_v];\\n        }\\n        \\n    }\\n};\\nclass Solution {\\npublic:\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int maxi=-1e9;\\n        disjointset ds(*max_element(nums.begin(),nums.end()));\\n        for(auto i:nums){\\n            for(int j=2;j*j<=i;j++){\\n                if(i%j==0){\\n                    ds.unionbysize(i,j);\\n                    ds.unionbysize(i,i/j);\\n                }\\n            }\\n        }\\n        map<int,int>m;\\n        for(auto i:nums){\\n            maxi=max(maxi,m[ds.findp(i)]++);\\n            \\n            \\n        }\\n        return maxi+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351595,
                "title": "simple-c-solution-using-dfs-and-sieve",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int prime[100001];\\n    void seive(){\\n        for(int i=0;i<=1e5;i++){\\n            prime[i]=i;\\n        }\\n        for(int i=2;i<=1e5;i+=2){\\n            prime[i]=2;\\n        }\\n        for(int i=3;i*i<=1e5;i++){\\n            if(prime[i]==i){\\n                for(int j=i*i;j<=1e5;j+=i){\\n                    prime[j]=i;\\n                }\\n            }\\n        }\\n    }\\n\\n    void dfs(int node, vector<int>adj[], vector<int>&vis, int& cy){\\n        vis[node]=1;\\n        cy++;\\n        for(auto it: adj[node]){\\n            if(!vis[it]){\\n                dfs(it,adj,vis,cy);\\n            }\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n        seive();\\n        map<int,set<int>>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int x=nums[i];\\n            while(x!=1){\\n                mp[prime[x]].insert(i);\\n                x/=prime[x];\\n            }\\n        }\\n        vector<int>adj[n];\\n        for(auto i: mp){\\n            int p=0;\\n            int x;\\n            for(auto j: i.second){\\n                if(p==0){\\n                    x=j;\\n                    p=1;\\n                }\\n                else{\\n                    adj[j].push_back(x);\\n                    adj[x].push_back(j);\\n                }\\n            }\\n        }\\n        int ans=0;\\n        vector<int>vis(n,0);\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                int cy=0;\\n                dfs(i,adj,vis,cy);\\n                ans=max(cy,ans);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prime[100001];\\n    void seive(){\\n        for(int i=0;i<=1e5;i++){\\n            prime[i]=i;\\n        }\\n        for(int i=2;i<=1e5;i+=2){\\n            prime[i]=2;\\n        }\\n        for(int i=3;i*i<=1e5;i++){\\n            if(prime[i]==i){\\n                for(int j=i*i;j<=1e5;j+=i){\\n                    prime[j]=i;\\n                }\\n            }\\n        }\\n    }\\n\\n    void dfs(int node, vector<int>adj[], vector<int>&vis, int& cy){\\n        vis[node]=1;\\n        cy++;\\n        for(auto it: adj[node]){\\n            if(!vis[it]){\\n                dfs(it,adj,vis,cy);\\n            }\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n        seive();\\n        map<int,set<int>>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int x=nums[i];\\n            while(x!=1){\\n                mp[prime[x]].insert(i);\\n                x/=prime[x];\\n            }\\n        }\\n        vector<int>adj[n];\\n        for(auto i: mp){\\n            int p=0;\\n            int x;\\n            for(auto j: i.second){\\n                if(p==0){\\n                    x=j;\\n                    p=1;\\n                }\\n                else{\\n                    adj[j].push_back(x);\\n                    adj[x].push_back(j);\\n                }\\n            }\\n        }\\n        int ans=0;\\n        vector<int>vis(n,0);\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                int cy=0;\\n                dfs(i,adj,vis,cy);\\n                ans=max(cy,ans);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281410,
                "title": "easy-solution-using-prime-factor-and-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int  N=100005;\\n    bool isPrime[100005];\\n    int spf[100005];\\n    vector<int> g[500005];\\n    map<int,int>mp;\\n   // spf.resize(100005,0);\\n    void sieve() {\\n        for( int i = 2 ; i<N ; i ++ ) {\\n            isPrime[ i ] = 1 ;\\n            spf[i]=i;\\n        }\\n    \\n        spf[1]=1;\\n        for( int i = 2 ; i*i <N ; i ++ ) {\\n            if(isPrime[i]!=0) {\\n                spf[i]=i;\\n                for( int j = i * i ; j <N ; j += i ) {\\n                    isPrime[ j ] = 0 ;\\n                    if(spf[j]==j) spf[j]=i;\\n                }\\n            }\\n        }\\n        \\n    }\\n    set<int> getFactorization(int x)\\n    {\\n        set<int> ret;\\n        while (x != 1)\\n        {\\n            ret.insert(spf[x]);\\n            x = x / spf[x];\\n        }\\n        return ret;\\n    }\\n\\n    int vis[500005];\\n    int c=0;\\n    void dfs(int node) {\\n        vis[node]=1;\\n        if(mp[node]) c++;\\n        for(int child : g[node]) {\\n            if(!vis[child]) {\\n                dfs(child);\\n            }\\n        }\\n    }\\n \\n    int largestComponentSize(vector<int>& v) {\\n        sieve();\\n        for(int i=0; i<v.size(); i++) {\\n            mp[v[i]]++;\\n            set<int>s=getFactorization(v[i]);\\n            for(auto it: s) {\\n                int u=v[i],v=it+100000;\\n                g[u].push_back(v);\\n                g[v].push_back(u);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<v.size(); i++) {\\n            if(!vis[v[i]]) {\\n                c=0;\\n                dfs(v[i]);\\n                ans=max(ans,c);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int  N=100005;\\n    bool isPrime[100005];\\n    int spf[100005];\\n    vector<int> g[500005];\\n    map<int,int>mp;\\n   // spf.resize(100005,0);\\n    void sieve() {\\n        for( int i = 2 ; i<N ; i ++ ) {\\n            isPrime[ i ] = 1 ;\\n            spf[i]=i;\\n        }\\n    \\n        spf[1]=1;\\n        for( int i = 2 ; i*i <N ; i ++ ) {\\n            if(isPrime[i]!=0) {\\n                spf[i]=i;\\n                for( int j = i * i ; j <N ; j += i ) {\\n                    isPrime[ j ] = 0 ;\\n                    if(spf[j]==j) spf[j]=i;\\n                }\\n            }\\n        }\\n        \\n    }\\n    set<int> getFactorization(int x)\\n    {\\n        set<int> ret;\\n        while (x != 1)\\n        {\\n            ret.insert(spf[x]);\\n            x = x / spf[x];\\n        }\\n        return ret;\\n    }\\n\\n    int vis[500005];\\n    int c=0;\\n    void dfs(int node) {\\n        vis[node]=1;\\n        if(mp[node]) c++;\\n        for(int child : g[node]) {\\n            if(!vis[child]) {\\n                dfs(child);\\n            }\\n        }\\n    }\\n \\n    int largestComponentSize(vector<int>& v) {\\n        sieve();\\n        for(int i=0; i<v.size(); i++) {\\n            mp[v[i]]++;\\n            set<int>s=getFactorization(v[i]);\\n            for(auto it: s) {\\n                int u=v[i],v=it+100000;\\n                g[u].push_back(v);\\n                g[v].push_back(u);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<v.size(); i++) {\\n            if(!vis[v[i]]) {\\n                c=0;\\n                dfs(v[i]);\\n                ans=max(ans,c);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267970,
                "title": "fastest-python-100-tc-700ms",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(NlogN)$$\\n# Code\\n```\\nimport math as mt\\nMAXN = 10**5 + 5\\n\\nspf = [i for i in range(MAXN)]\\n\\ndef sieve():\\n\\tspf[1] = 1\\n\\n\\tfor i in range(4, MAXN, 2):\\n\\t\\tspf[i] = 2\\n\\n\\tfor i in range(3, mt.ceil(mt.sqrt(MAXN))):\\n\\t\\tif (spf[i] == i):\\n\\t\\t\\t\\n\\t\\t\\tfor j in range(i * i, MAXN, i):\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (spf[j] == j):\\n\\t\\t\\t\\t\\tspf[j] = i\\n\\ndef factors(x):\\n\\tret = set()\\n\\twhile (x != 1):\\n\\t\\tret.add(spf[x])\\n\\t\\tx = x // spf[x]\\n\\n\\treturn ret\\n\\nsieve()\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        df = dict()\\n        uf = DSU(len(nums))\\n        for i,x in enumerate(nums):\\n            for f in factors(x):\\n                if(f in df): uf.union(i,df[f])\\n                else: df[f] = i\\n                    \\n        return uf.mx;\\n            \\n\\nclass DSU:\\n    def __init__(self, N):\\n        self.par = list(range(N))\\n        self.sz = [1] * N\\n        self.mx = 1\\n    def find(self, x):\\n        if self.par[x] != x:\\n            self.par[x] = self.find(self.par[x])\\n        return self.par[x]\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        if xr == yr:\\n            return False\\n        if self.sz[xr] < self.sz[yr]:\\n            xr, yr = yr, xr\\n        self.par[yr] = xr\\n        self.sz[xr] += self.sz[yr]\\n        self.mx = max(self.mx,self.sz[xr])\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math as mt\\nMAXN = 10**5 + 5\\n\\nspf = [i for i in range(MAXN)]\\n\\ndef sieve():\\n\\tspf[1] = 1\\n\\n\\tfor i in range(4, MAXN, 2):\\n\\t\\tspf[i] = 2\\n\\n\\tfor i in range(3, mt.ceil(mt.sqrt(MAXN))):\\n\\t\\tif (spf[i] == i):\\n\\t\\t\\t\\n\\t\\t\\tfor j in range(i * i, MAXN, i):\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (spf[j] == j):\\n\\t\\t\\t\\t\\tspf[j] = i\\n\\ndef factors(x):\\n\\tret = set()\\n\\twhile (x != 1):\\n\\t\\tret.add(spf[x])\\n\\t\\tx = x // spf[x]\\n\\n\\treturn ret\\n\\nsieve()\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        df = dict()\\n        uf = DSU(len(nums))\\n        for i,x in enumerate(nums):\\n            for f in factors(x):\\n                if(f in df): uf.union(i,df[f])\\n                else: df[f] = i\\n                    \\n        return uf.mx;\\n            \\n\\nclass DSU:\\n    def __init__(self, N):\\n        self.par = list(range(N))\\n        self.sz = [1] * N\\n        self.mx = 1\\n    def find(self, x):\\n        if self.par[x] != x:\\n            self.par[x] = self.find(self.par[x])\\n        return self.par[x]\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        if xr == yr:\\n            return False\\n        if self.sz[xr] < self.sz[yr]:\\n            xr, yr = yr, xr\\n        self.par[yr] = xr\\n        self.sz[xr] += self.sz[yr]\\n        self.mx = max(self.mx,self.sz[xr])\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248877,
                "title": "c-without-dsu",
                "content": "This approach uses ONLY DFS \\nsimply search for each factor and draw an edge between them\\ncode:-\\n```\\nclass Solution {\\npublic:\\n    void solve(map<int,int> &vis ,int i , map<int,vector<int>> &mp , int &cnt , map<int,int> &inside )\\n    {\\n        vis[i] = 1;\\n        cnt+=inside[i];\\n        // if(inside[i]) cout<<i<<\" \";\\n        for(auto a : mp[i])\\n        {\\n            if(vis[a] == 0)\\n            {\\n                solve(vis , a , mp , cnt , inside);\\n            }\\n        }\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n        map<int,vector<int>> mp;\\n        map<int,int> inside;\\n        for(auto a : nums)\\n        {\\n            inside[a] = 1;\\n            for(int i = 2 ;i<=sqrt(a);i++)\\n            {\\n               if(a%i == 0)\\n               {\\n                   if(a/i == i)\\n                   {\\n                       mp[i].push_back(a);\\n                       mp[a].push_back(i);\\n                   }\\n                   else\\n                   {\\n                       mp[i].push_back(a);\\n                       mp[a].push_back(i);\\n                       mp[a/i].push_back(a);\\n                       mp[a].push_back(a/i);\\n                   }\\n               }\\n            }\\n        }\\n        map<int,int> vis;\\n        int ans = 0;\\n        \\n        for(auto a : nums)\\n        {\\n            if(vis[a] == 0)\\n            {\\n                // cout<<a<<\" \";\\n                int cnt = 0;\\n                solve(vis , a , mp , cnt , inside);\\n                ans = max(cnt , ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(map<int,int> &vis ,int i , map<int,vector<int>> &mp , int &cnt , map<int,int> &inside )\\n    {\\n        vis[i] = 1;\\n        cnt+=inside[i];\\n        // if(inside[i]) cout<<i<<\" \";\\n        for(auto a : mp[i])\\n        {\\n            if(vis[a] == 0)\\n            {\\n                solve(vis , a , mp , cnt , inside);\\n            }\\n        }\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n        map<int,vector<int>> mp;\\n        map<int,int> inside;\\n        for(auto a : nums)\\n        {\\n            inside[a] = 1;\\n            for(int i = 2 ;i<=sqrt(a);i++)\\n            {\\n               if(a%i == 0)\\n               {\\n                   if(a/i == i)\\n                   {\\n                       mp[i].push_back(a);\\n                       mp[a].push_back(i);\\n                   }\\n                   else\\n                   {\\n                       mp[i].push_back(a);\\n                       mp[a].push_back(i);\\n                       mp[a/i].push_back(a);\\n                       mp[a].push_back(a/i);\\n                   }\\n               }\\n            }\\n        }\\n        map<int,int> vis;\\n        int ans = 0;\\n        \\n        for(auto a : nums)\\n        {\\n            if(vis[a] == 0)\\n            {\\n                // cout<<a<<\" \";\\n                int cnt = 0;\\n                solve(vis , a , mp , cnt , inside);\\n                ans = max(cnt , ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3234312,
                "title": "easiest-typescript-solution-ufs",
                "content": "- Define standard UFS writing using `root`, `find` and `union`\\n- Get primes until `100000` (max) with the most optimized function for getting prime number `O(Sqrt(N))` where `N` is the given number\\n- Loop through each primes we just got. Get the `remainder` of given `nums / each prime num`\\n    - Use `Union` to group every number that was divided with the same `prime number`\\n- Loop through once again to get the maximum number of any parent and return\\n    - Minimum is `1`\\n\\n# Code (UFS)\\n```\\nfunction largestComponentSize(nums: number[]): number {\\n    const primes = getPrimesUntil(100000)\\n    const root: (undefined | number)[] = [...Array(nums.length)]\\n\\n    const find = (i: number): number => {\\n        if (root[i] === undefined || root[i] === i) return i\\n        return root[i] = find(root[i])\\n    }\\n\\n    const union = (i: number, j: number) => {\\n        const iRoot = find(i), jRoot = find(j)\\n        root[iRoot] = root[jRoot] = Math.max(iRoot, jRoot)\\n    }\\n\\n    for (const prime of primes) {\\n        const indexes = [] // indexes\\n        let max = 1\\n        for (let i = 0; i < nums.length; i++) {\\n            if (nums[i] === 1) continue\\n            if (nums[i] % prime === 0) {\\n                indexes.push(i)\\n                while (nums[i] % prime === 0) nums[i] /= prime // Optimization\\n            }\\n            max = Math.max(nums[i], max)\\n        }\\n        \\n        for (let i = 0; i < indexes.length - 1; i++) {\\n            union(indexes[i], indexes[i + 1])\\n        }\\n\\n        if (max < prime) break // Optimization\\n    }\\n\\n    const map = new Map<number, number>() // number, count\\n    let maxCnt = 1 // There should be at least one independent component\\n    for (const rootI of root) {\\n        if (rootI === undefined) continue\\n        const foundI = find(rootI)\\n\\n        const newCount = (map.get(foundI) || 0) + 1\\n        map.set(foundI, newCount)\\n        maxCnt = Math.max(maxCnt, newCount)\\n    }\\n    \\n    return maxCnt\\n};\\n\\nconst getPrimesUntil = (untilThisNumber: number) => {\\n    const primes = [2]\\n    for (let i = 3; i <= untilThisNumber; i += 2) {\\n        let isPrime = true\\n        const max = Math.sqrt(i)\\n        for (let j = 2; j <= max; j++) {\\n            if (i % j !== 0) continue\\n\\n            isPrime = false\\n            break\\n        }\\n        if (isPrime) primes.push(i)\\n    }\\n    return primes\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction largestComponentSize(nums: number[]): number {\\n    const primes = getPrimesUntil(100000)\\n    const root: (undefined | number)[] = [...Array(nums.length)]\\n\\n    const find = (i: number): number => {\\n        if (root[i] === undefined || root[i] === i) return i\\n        return root[i] = find(root[i])\\n    }\\n\\n    const union = (i: number, j: number) => {\\n        const iRoot = find(i), jRoot = find(j)\\n        root[iRoot] = root[jRoot] = Math.max(iRoot, jRoot)\\n    }\\n\\n    for (const prime of primes) {\\n        const indexes = [] // indexes\\n        let max = 1\\n        for (let i = 0; i < nums.length; i++) {\\n            if (nums[i] === 1) continue\\n            if (nums[i] % prime === 0) {\\n                indexes.push(i)\\n                while (nums[i] % prime === 0) nums[i] /= prime // Optimization\\n            }\\n            max = Math.max(nums[i], max)\\n        }\\n        \\n        for (let i = 0; i < indexes.length - 1; i++) {\\n            union(indexes[i], indexes[i + 1])\\n        }\\n\\n        if (max < prime) break // Optimization\\n    }\\n\\n    const map = new Map<number, number>() // number, count\\n    let maxCnt = 1 // There should be at least one independent component\\n    for (const rootI of root) {\\n        if (rootI === undefined) continue\\n        const foundI = find(rootI)\\n\\n        const newCount = (map.get(foundI) || 0) + 1\\n        map.set(foundI, newCount)\\n        maxCnt = Math.max(maxCnt, newCount)\\n    }\\n    \\n    return maxCnt\\n};\\n\\nconst getPrimesUntil = (untilThisNumber: number) => {\\n    const primes = [2]\\n    for (let i = 3; i <= untilThisNumber; i += 2) {\\n        let isPrime = true\\n        const max = Math.sqrt(i)\\n        for (let j = 2; j <= max; j++) {\\n            if (i % j !== 0) continue\\n\\n            isPrime = false\\n            break\\n        }\\n        if (isPrime) primes.push(i)\\n    }\\n    return primes\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3189741,
                "title": "prime-factorisation-dfs-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;        // adjacency list of indexes connected with each other\\n    vector<int> vis;\\n    map<int, int> pr_ind;           // index of a number divisible by this prime\\n    \\n    int dfs(int i, int par){\\n        int size = 1;\\n        vis[i] = 1;\\n        for(int& ch : adj[i]){\\n            if(ch != par and vis[ch] == 0){\\n                size += dfs(ch, i);\\n            }\\n        }\\n        return size;\\n    }\\n    \\n    int largestComponentSize(vector<int>& a) {\\n        int n = a.size();\\n        adj.resize(n);\\n        for(int i = 0; i < n; ++i){\\n            int num = a[i];\\n            \\n            // find the prime factorisation of a[i]\\n            // connect a[i] with all the numbers which share the same prime numbers as divisors\\n            // CATCH : We dont have to connect a[i] with all the numbers that share the same prime number\\n            // connecting with only one of those numbers will be fine as through that number we have automatically\\n            // made an indirect connection with all the other numbers ( Imagine like a Linked List )\\n            \\n            {\\n                for(long k = 2; k * k <= num; ++k){\\n                    if(num % k == 0){\\n                        // add connection\\n                        // pr_ind me agar koi index pehle se hai to usse connect krdo\\n                        // if pr_ind has some former index then connect \\'i\\' with that index\\n                        \\n                        // otherwise any number divisible by prime number K has not been \\n                        // found before hence we cannot make any connection\\n                        if(pr_ind.count(k) == 0){\\n                            pr_ind[k] = i;\\n                        } else{\\n                            adj[pr_ind[k]].push_back(i);\\n                            adj[i].push_back(pr_ind[k]);\\n                        }\\n                        \\n                        // remove all occ of this prime number\\n                        while(num % k == 0){\\n                            num /= k;\\n                        }\\n                        \\n                    }\\n                }\\n                if(num > 1){\\n                    if(pr_ind.count(num) == 0){\\n                        pr_ind[num] = i;\\n                    } else{\\n                        adj[pr_ind[num]].push_back(i);\\n                        adj[i].push_back(pr_ind[num]);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        // find the maximum component size\\n        int ans = 0;\\n        vis.resize(n);\\n        for(int i = 0; i < n; ++i){\\n            if(!vis[i]){\\n                int size = dfs(i, -1);\\n                ans = max(ans, size);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;        // adjacency list of indexes connected with each other\\n    vector<int> vis;\\n    map<int, int> pr_ind;           // index of a number divisible by this prime\\n    \\n    int dfs(int i, int par){\\n        int size = 1;\\n        vis[i] = 1;\\n        for(int& ch : adj[i]){\\n            if(ch != par and vis[ch] == 0){\\n                size += dfs(ch, i);\\n            }\\n        }\\n        return size;\\n    }\\n    \\n    int largestComponentSize(vector<int>& a) {\\n        int n = a.size();\\n        adj.resize(n);\\n        for(int i = 0; i < n; ++i){\\n            int num = a[i];\\n            \\n            // find the prime factorisation of a[i]\\n            // connect a[i] with all the numbers which share the same prime numbers as divisors\\n            // CATCH : We dont have to connect a[i] with all the numbers that share the same prime number\\n            // connecting with only one of those numbers will be fine as through that number we have automatically\\n            // made an indirect connection with all the other numbers ( Imagine like a Linked List )\\n            \\n            {\\n                for(long k = 2; k * k <= num; ++k){\\n                    if(num % k == 0){\\n                        // add connection\\n                        // pr_ind me agar koi index pehle se hai to usse connect krdo\\n                        // if pr_ind has some former index then connect \\'i\\' with that index\\n                        \\n                        // otherwise any number divisible by prime number K has not been \\n                        // found before hence we cannot make any connection\\n                        if(pr_ind.count(k) == 0){\\n                            pr_ind[k] = i;\\n                        } else{\\n                            adj[pr_ind[k]].push_back(i);\\n                            adj[i].push_back(pr_ind[k]);\\n                        }\\n                        \\n                        // remove all occ of this prime number\\n                        while(num % k == 0){\\n                            num /= k;\\n                        }\\n                        \\n                    }\\n                }\\n                if(num > 1){\\n                    if(pr_ind.count(num) == 0){\\n                        pr_ind[num] = i;\\n                    } else{\\n                        adj[pr_ind[num]].push_back(i);\\n                        adj[i].push_back(pr_ind[num]);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        // find the maximum component size\\n        int ans = 0;\\n        vis.resize(n);\\n        for(int i = 0; i < n; ++i){\\n            if(!vis[i]){\\n                int size = dfs(i, -1);\\n                ans = max(ans, size);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164139,
                "title": "c-union-find-sieve",
                "content": "# Intuition\\nConnected components => union find\\nfactor => sieve\\n\\n# Approach\\nSimply loop over the common factors and their multiples\\nand merge them\\n\\n# Complexity\\n- Time complexity:\\naround O(sieve * union) = O(mlogm * logm) where m is the maximum possible value in nums\\n\\n- Space complexity:\\nO(m) where m is the maximum possible value in nums\\n\\n# Code\\n```\\nclass Solution {\\nvector<int>rank;\\nvector<int>siz;\\nvector<int>parent;\\nint find_set(int val){\\n    if(parent[val] == val) return val;\\n    return parent[val]=find_set(parent[val]);\\n}\\nint union_set(int a, int b){\\n    int pa=find_set(a);\\n    int pb=find_set(b);\\n    \\n    if(pa==pb) return siz[pa];\\n    if(rank[pa] < rank[pb]){\\n        swap(pa,pb);\\n        swap(a,b);\\n    }\\n    parent[pb]=pa;\\n    siz[pa]+=siz[pb];\\n    if(rank[pa]==rank[pb]) rank[pa]++;\\n    return siz[pa];\\n}\\nvoid make_set(vector<int>&nums){\\n    rank.resize(100001,0);\\n    siz.resize(100001,1);\\n    parent.resize(100001,-1);\\n    for(auto num : nums){\\n        parent[num]=num;\\n    }\\n}\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        make_set(nums);\\n        int ans=1;\\n        /* Loop over all the possible common factors */\\n        for(long long i=2;i<=100000;++i){\\n            int val=-1;\\n            /* Loop over all the multiples of common factors */\\n            for(long long j=i;j<=100000;j+=i){\\n                /* If number is present in nums we keep the parent[num]=num, same way as union find \\n                data structure */\\n                if(parent[j]>0){\\n                    if(val > 0){\\n                        /* Merge the set */\\n                        ans=max(union_set(val,j),ans);\\n                    }else{\\n                        val=j;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\nvector<int>rank;\\nvector<int>siz;\\nvector<int>parent;\\nint find_set(int val){\\n    if(parent[val] == val) return val;\\n    return parent[val]=find_set(parent[val]);\\n}\\nint union_set(int a, int b){\\n    int pa=find_set(a);\\n    int pb=find_set(b);\\n    \\n    if(pa==pb) return siz[pa];\\n    if(rank[pa] < rank[pb]){\\n        swap(pa,pb);\\n        swap(a,b);\\n    }\\n    parent[pb]=pa;\\n    siz[pa]+=siz[pb];\\n    if(rank[pa]==rank[pb]) rank[pa]++;\\n    return siz[pa];\\n}\\nvoid make_set(vector<int>&nums){\\n    rank.resize(100001,0);\\n    siz.resize(100001,1);\\n    parent.resize(100001,-1);\\n    for(auto num : nums){\\n        parent[num]=num;\\n    }\\n}\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        make_set(nums);\\n        int ans=1;\\n        /* Loop over all the possible common factors */\\n        for(long long i=2;i<=100000;++i){\\n            int val=-1;\\n            /* Loop over all the multiples of common factors */\\n            for(long long j=i;j<=100000;j+=i){\\n                /* If number is present in nums we keep the parent[num]=num, same way as union find \\n                data structure */\\n                if(parent[j]>0){\\n                    if(val > 0){\\n                        /* Merge the set */\\n                        ans=max(union_set(val,j),ans);\\n                    }else{\\n                        val=j;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159831,
                "title": "shortest-simplest-solution-sieve-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        mx = max(nums)\\n        par = [i for i in range(mx + 1)]\\n        nums = set(nums)\\n\\n        def find(u):\\n            if par[u] != u:\\n                par[u] = find(par[u])\\n            return par[u]\\n    \\n        def union(u, v):\\n            if find(u) == find(v):\\n                return\\n            par[find(u)] = find(v)\\n\\n        for i in range(2, mx + 1):\\n            for j in range(i, mx + 1, i):\\n                if j in nums:\\n                    union(i, j)\\n        return max(Counter(find(num) for num in nums).values())\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        mx = max(nums)\\n        par = [i for i in range(mx + 1)]\\n        nums = set(nums)\\n\\n        def find(u):\\n            if par[u] != u:\\n                par[u] = find(par[u])\\n            return par[u]\\n    \\n        def union(u, v):\\n            if find(u) == find(v):\\n                return\\n            par[find(u)] = find(v)\\n\\n        for i in range(2, mx + 1):\\n            for j in range(i, mx + 1, i):\\n                if j in nums:\\n                    union(i, j)\\n        return max(Counter(find(num) for num in nums).values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155971,
                "title": "java-union-find",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n    public int find(int j, int[] parent) {\\n\\n        if (parent[j] == j) {\\n            return j;\\n        } else {\\n            return parent[j] = find(parent[j], parent);\\n        }\\n    }\\n\\n    public int largestComponentSize(int[] nums) {\\n\\n        int[] parent = new int[100001];\\n        for (int i = 0; i <= 100000; i++) {\\n            parent[i] = i;\\n        }\\n\\n        int[] rank = new int[100001];\\n\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n; i++) {\\n\\n            for (int j = 2; j * j <= nums[i]; j++) {\\n                if (nums[i] % j == 0) {\\n\\n                    int a = find(j, parent);\\n                    int b = find(nums[i], parent);\\n\\n                    if (rank[a] > rank[b]) {\\n                        parent[b] = a;\\n                        rank[a]++;\\n                    } else {\\n                        parent[a] = b;\\n                        rank[b]++;\\n                    }\\n                }\\n\\n                if (nums[i] % j == 0 && nums[i] % (nums[i] / j) == 0) {\\n                    int a = find(nums[i] / j, parent);\\n                    int b = find(nums[i], parent);\\n                    if (rank[a] > rank[b]) {\\n                        parent[b] = a;\\n                        rank[a]++;\\n                    } else {\\n                        parent[a] = b;\\n                        rank[b]++;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        int max = 1;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i <n; i++) {\\n            int a = find(nums[i],parent);\\n            if(map.containsKey(a)){\\n                int p = map.get(a);\\n                map.put(a,p+1);\\n                max = Math.max(p+1,max);\\n            }else{\\n                map.put(a,1);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n    public int find(int j, int[] parent) {\\n\\n        if (parent[j] == j) {\\n            return j;\\n        } else {\\n            return parent[j] = find(parent[j], parent);\\n        }\\n    }\\n\\n    public int largestComponentSize(int[] nums) {\\n\\n        int[] parent = new int[100001];\\n        for (int i = 0; i <= 100000; i++) {\\n            parent[i] = i;\\n        }\\n\\n        int[] rank = new int[100001];\\n\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n; i++) {\\n\\n            for (int j = 2; j * j <= nums[i]; j++) {\\n                if (nums[i] % j == 0) {\\n\\n                    int a = find(j, parent);\\n                    int b = find(nums[i], parent);\\n\\n                    if (rank[a] > rank[b]) {\\n                        parent[b] = a;\\n                        rank[a]++;\\n                    } else {\\n                        parent[a] = b;\\n                        rank[b]++;\\n                    }\\n                }\\n\\n                if (nums[i] % j == 0 && nums[i] % (nums[i] / j) == 0) {\\n                    int a = find(nums[i] / j, parent);\\n                    int b = find(nums[i], parent);\\n                    if (rank[a] > rank[b]) {\\n                        parent[b] = a;\\n                        rank[a]++;\\n                    } else {\\n                        parent[a] = b;\\n                        rank[b]++;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        int max = 1;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i <n; i++) {\\n            int a = find(nums[i],parent);\\n            if(map.containsKey(a)){\\n                int p = map.get(a);\\n                map.put(a,p+1);\\n                max = Math.max(p+1,max);\\n            }else{\\n                map.put(a,1);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097814,
                "title": "union-find-and-primeset-approach-follow-up-question-why-is-recursive-find-faster-than-iterative",
                "content": "Recursive find() \\n```python\\nimport math\\nfrom collections import defaultdict, Counter\\nfrom typing import List\\n\\n\\nclass UnionSet:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n\\n    def find(self, x):\\n        curr = self.parent[x]\\n        while curr != self.parent[curr]:\\n            curr, self.parent[curr] = self.parent[curr], self.parent[self.parent[curr]]\\n        return self.parent[curr]\\n\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        self.parent[xr] = yr\\n        \\n@cache\\ndef primeSet(n): # Time: O(sqrt(n)*logn), Space: O(logn), a prime set is a set of prime numbers that can express a composite number\\n    for i in range(2, int(math.sqrt(n) + 1)):\\n        if n % i == 0:\\n            return primeSet(n // i) | {i}\\n    return {n}\\n\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        unionFind = UnionSet(n)\\n        primes = defaultdict(list)\\n\\n        for i, num in enumerate(nums):  # { factor: [indexes for which has the factor] }\\n            for q in primeSet(num):\\n                primes[q].append(i)\\n\\n        for _, indexes in primes.items(): # unionFind for all indexes with a similar factor\\n            for i in range(len(indexes)-1):\\n                unionFind.union(indexes[i], indexes[i + 1])\\n                \\n        return max(Counter([unionFind.find(i) for i in range(n)]).values()) # find parent index with the largest size\\n```\\n\\nIterative find\\n```python\\nclass UnionSet:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[self.parent[x]])\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        self.parent[xr] = yr\\n        \\n@cache\\ndef primeSet(n): # Time: O(sqrt(n)*logn), Space: O(logn), a prime set is a set of prime numbers that can express a composite number\\n    for i in range(2, int(math.sqrt(n) + 1)):\\n        if n % i == 0:\\n            return primeSet(n // i) | {i}\\n    return {n}\\n\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        unionFind = UnionSet(n)\\n        primes = defaultdict(list)\\n\\n        for i, num in enumerate(nums):  # { factor: [indexes for which has the factor] }\\n            for q in primeSet(num):\\n                primes[q].append(i)\\n\\n        for _, indexes in primes.items(): # unionFind for all indexes with a similar factor\\n            for i in range(len(indexes)-1):\\n                unionFind.union(indexes[i], indexes[i + 1])\\n                \\n        return max(Counter([unionFind.find(i) for i in range(n)]).values()) # find parent index with the largest size\\n```\\n\\n\\nOddly the iterative find() implementation times out while the recursive does not. I\\'m wondering if anyone knows why\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nimport math\\nfrom collections import defaultdict, Counter\\nfrom typing import List\\n\\n\\nclass UnionSet:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n\\n    def find(self, x):\\n        curr = self.parent[x]\\n        while curr != self.parent[curr]:\\n            curr, self.parent[curr] = self.parent[curr], self.parent[self.parent[curr]]\\n        return self.parent[curr]\\n\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        self.parent[xr] = yr\\n        \\n@cache\\ndef primeSet(n): # Time: O(sqrt(n)*logn), Space: O(logn), a prime set is a set of prime numbers that can express a composite number\\n    for i in range(2, int(math.sqrt(n) + 1)):\\n        if n % i == 0:\\n            return primeSet(n // i) | {i}\\n    return {n}\\n\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        unionFind = UnionSet(n)\\n        primes = defaultdict(list)\\n\\n        for i, num in enumerate(nums):  # { factor: [indexes for which has the factor] }\\n            for q in primeSet(num):\\n                primes[q].append(i)\\n\\n        for _, indexes in primes.items(): # unionFind for all indexes with a similar factor\\n            for i in range(len(indexes)-1):\\n                unionFind.union(indexes[i], indexes[i + 1])\\n                \\n        return max(Counter([unionFind.find(i) for i in range(n)]).values()) # find parent index with the largest size\\n```\n```python\\nclass UnionSet:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[self.parent[x]])\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        self.parent[xr] = yr\\n        \\n@cache\\ndef primeSet(n): # Time: O(sqrt(n)*logn), Space: O(logn), a prime set is a set of prime numbers that can express a composite number\\n    for i in range(2, int(math.sqrt(n) + 1)):\\n        if n % i == 0:\\n            return primeSet(n // i) | {i}\\n    return {n}\\n\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        unionFind = UnionSet(n)\\n        primes = defaultdict(list)\\n\\n        for i, num in enumerate(nums):  # { factor: [indexes for which has the factor] }\\n            for q in primeSet(num):\\n                primes[q].append(i)\\n\\n        for _, indexes in primes.items(): # unionFind for all indexes with a similar factor\\n            for i in range(len(indexes)-1):\\n                unionFind.union(indexes[i], indexes[i + 1])\\n                \\n        return max(Counter([unionFind.find(i) for i in range(n)]).values()) # find parent index with the largest size\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081164,
                "title": "simple-and-clean-dsu-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvector<int>par,siz;\\nclass Disjoint{\\n    public:\\n    Disjoint(int n){\\n        par.resize(n+1);\\n        siz.resize(n+1);\\n        int i;\\n        for(i=0;i<=n;i++){\\n            par[i]=i;\\n            siz[i]=1;\\n        }\\n    }\\n    int find(int node){\\n        if(node==par[node]) return node;\\n        return par[node]=find(par[node]);\\n    }\\n    void join(int u,int v){\\n        int ultu=find(u),ultv=find(v);\\n        if(ultu!=ultv){\\n            if(siz[ultu]>=siz[ultv]){\\n                par[ultv]=ultu;\\n                siz[ultu]+=siz[ultv];\\n            }\\n            else{\\n                 par[ultu]=ultv;\\n                siz[ultv]+=siz[ultu];\\n            }\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int num=*max_element(nums.begin(),nums.end());\\n        int maxi=1,i,j;\\n        Disjoint ds(num);\\n        for(i=0;i<nums.size();i++){\\n            for(j=2;j<=sqrt(nums[i]);j++){\\n                if(nums[i]%j==0){\\n                ds.join(nums[i],j);\\n                ds.join(j,nums[i]/j);\\n                }\\n            }\\n        }\\n        unordered_map<int,int>m;\\n        for(i=0;i<nums.size();i++){\\n            int pa=ds.find(nums[i]);\\n            m[pa]++;\\n            maxi=max(maxi,m[pa]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<int>par,siz;\\nclass Disjoint{\\n    public:\\n    Disjoint(int n){\\n        par.resize(n+1);\\n        siz.resize(n+1);\\n        int i;\\n        for(i=0;i<=n;i++){\\n            par[i]=i;\\n            siz[i]=1;\\n        }\\n    }\\n    int find(int node){\\n        if(node==par[node]) return node;\\n        return par[node]=find(par[node]);\\n    }\\n    void join(int u,int v){\\n        int ultu=find(u),ultv=find(v);\\n        if(ultu!=ultv){\\n            if(siz[ultu]>=siz[ultv]){\\n                par[ultv]=ultu;\\n                siz[ultu]+=siz[ultv];\\n            }\\n            else{\\n                 par[ultu]=ultv;\\n                siz[ultv]+=siz[ultu];\\n            }\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int num=*max_element(nums.begin(),nums.end());\\n        int maxi=1,i,j;\\n        Disjoint ds(num);\\n        for(i=0;i<nums.size();i++){\\n            for(j=2;j<=sqrt(nums[i]);j++){\\n                if(nums[i]%j==0){\\n                ds.join(nums[i],j);\\n                ds.join(j,nums[i]/j);\\n                }\\n            }\\n        }\\n        unordered_map<int,int>m;\\n        for(i=0;i<nums.size();i++){\\n            int pa=ds.find(nums[i]);\\n            m[pa]++;\\n            maxi=max(maxi,m[pa]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049395,
                "title": "python-union-find-solution-prime-factor",
                "content": "```\\ndef largestComponentSize(self, nums: List[int]) -> int:\\n\\tdef prime(x):\\n\\t\\tfactors = set()\\n\\t\\tfor i in range(2, int(sqrt(x))+1):\\n\\t\\t\\twhile(x%i==0):\\n\\t\\t\\t\\tx//=i\\n\\t\\t\\t\\tfactors.add(i)\\n\\t\\treturn factors|{x} if x>1 else factors\\n\\n\\tuf, pf = list(range(len(nums))), defaultdict(list)\\n\\tfor i, x in enumerate(nums):\\n\\t\\tfor p in prime(x):\\n\\t\\t\\tpf[p].append(i)\\n\\n\\tdef find(i):\\n\\t\\tif uf[i]!=i:\\n\\t\\t\\tuf[i]=find(uf[i])\\n\\t\\treturn uf[i]\\n\\n\\tdef union(i, j):\\n\\t\\tfi, fj = find(i), find(j)\\n\\t\\tuf[fj] = fi\\n\\t\\treturn fi\\n\\n\\tfor i in pf:\\n\\t\\treduce(union, pf[i])\\n\\n\\treturn max(Counter([find(i) for i in range(len(nums))]).values())\\n```",
                "solutionTags": [],
                "code": "```\\ndef largestComponentSize(self, nums: List[int]) -> int:\\n\\tdef prime(x):\\n\\t\\tfactors = set()\\n\\t\\tfor i in range(2, int(sqrt(x))+1):\\n\\t\\t\\twhile(x%i==0):\\n\\t\\t\\t\\tx//=i\\n\\t\\t\\t\\tfactors.add(i)\\n\\t\\treturn factors|{x} if x>1 else factors\\n\\n\\tuf, pf = list(range(len(nums))), defaultdict(list)\\n\\tfor i, x in enumerate(nums):\\n\\t\\tfor p in prime(x):\\n\\t\\t\\tpf[p].append(i)\\n\\n\\tdef find(i):\\n\\t\\tif uf[i]!=i:\\n\\t\\t\\tuf[i]=find(uf[i])\\n\\t\\treturn uf[i]\\n\\n\\tdef union(i, j):\\n\\t\\tfi, fj = find(i), find(j)\\n\\t\\tuf[fj] = fi\\n\\t\\treturn fi\\n\\n\\tfor i in pf:\\n\\t\\treduce(union, pf[i])\\n\\n\\treturn max(Counter([find(i) for i in range(len(nums))]).values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3024226,
                "title": "dfs-and-map-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n* sqrt(n));\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(E) => E = edges\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool vis[100005];\\n    void dfs(int x , set<int> adj[], int &cnt, unordered_map<int,int>& m){\\n        vis[x]=1;\\n        if(m.count(x)) cnt++;\\n        for(auto it : adj[x]){\\n            if(!vis[it]){\\n                dfs(it, adj, cnt ,m);\\n            }\\n        }\\n\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n       \\n        unordered_map<int,int> m;\\n        set<int> adj[100005];\\n        for(auto x:nums) m[x]=1;\\n        for(int i =0;i<100005;i++) vis[i] = 0;\\n        int n = nums.size();\\n        for(int i =0;i<n;i++){\\n            for(int j = 2;j*j<=nums[i];j++){\\n                if(nums[i]%j==0){\\n                   adj[nums[i]].insert(j);\\n                   adj[j].insert(nums[i]);\\n                    adj[nums[i]].insert(nums[i]/j);\\n                   adj[nums[i]/j].insert(nums[i]);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i =2;i<=100000;i++){\\n            if(!vis[i]){\\n                int cnt= 0 ;\\n                dfs(i, adj,cnt,m);\\n                ans = max(ans, cnt);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool vis[100005];\\n    void dfs(int x , set<int> adj[], int &cnt, unordered_map<int,int>& m){\\n        vis[x]=1;\\n        if(m.count(x)) cnt++;\\n        for(auto it : adj[x]){\\n            if(!vis[it]){\\n                dfs(it, adj, cnt ,m);\\n            }\\n        }\\n\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n       \\n        unordered_map<int,int> m;\\n        set<int> adj[100005];\\n        for(auto x:nums) m[x]=1;\\n        for(int i =0;i<100005;i++) vis[i] = 0;\\n        int n = nums.size();\\n        for(int i =0;i<n;i++){\\n            for(int j = 2;j*j<=nums[i];j++){\\n                if(nums[i]%j==0){\\n                   adj[nums[i]].insert(j);\\n                   adj[j].insert(nums[i]);\\n                    adj[nums[i]].insert(nums[i]/j);\\n                   adj[nums[i]/j].insert(nums[i]);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i =2;i<=100000;i++){\\n            if(!vis[i]){\\n                int cnt= 0 ;\\n                dfs(i, adj,cnt,m);\\n                ans = max(ans, cnt);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981238,
                "title": "sieve-path-compression-algorithm-union-find",
                "content": "```\\nint flag=0,mx=1e5+10;\\nvector<int> spf;\\nclass Solution {\\n    vector<int> par;\\npublic:\\n    Solution(){\\n        if(!flag){\\n            flag=1;\\n            spf.resize(mx,2);\\n            for(int i=0;i<mx;i++)\\n                if(i&1)\\n                    spf[i]=i;\\n            int sq=sqrt(mx);\\n            for(int i=3;i<=sq;i+=2){\\n                if(spf[i]==i){\\n                    for(int j=i*i;j<mx;j+=i)\\n                        spf[j]=i;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int findPar(int p){\\n        if(par[p]==p)\\n            return p;\\n        return par[p]=findPar(par[p]);\\n    }\\n    \\n    int largestComponentSize(vector<int>& a) {\\n        par.resize(mx);\\n        for(int i=0;i<mx;i++)\\n            par[i]=i;\\n        \\n        sort(a.begin(),a.end());\\n        for(auto e:a){\\n            vector<int> p;\\n            int mn=e;\\n            while(e>1){\\n                int pr=spf[e];\\n                while(e%pr==0)\\n                    e/=pr;\\n                p.push_back(findPar(pr));\\n                mn=min(mn,findPar(pr));\\n            }\\n            mn=findPar(mn);\\n            for(auto e:p)\\n                par[e]=mn;\\n        }\\n        \\n        int ans=0;\\n        unordered_map<int,int> mp;\\n        for(auto e:a){\\n            mp[findPar(spf[e])]++;\\n            ans=max(ans,mp[findPar(spf[e])]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nint flag=0,mx=1e5+10;\\nvector<int> spf;\\nclass Solution {\\n    vector<int> par;\\npublic:\\n    Solution(){\\n        if(!flag){\\n            flag=1;\\n            spf.resize(mx,2);\\n            for(int i=0;i<mx;i++)\\n                if(i&1)\\n                    spf[i]=i;\\n            int sq=sqrt(mx);\\n            for(int i=3;i<=sq;i+=2){\\n                if(spf[i]==i){\\n                    for(int j=i*i;j<mx;j+=i)\\n                        spf[j]=i;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int findPar(int p){\\n        if(par[p]==p)\\n            return p;\\n        return par[p]=findPar(par[p]);\\n    }\\n    \\n    int largestComponentSize(vector<int>& a) {\\n        par.resize(mx);\\n        for(int i=0;i<mx;i++)\\n            par[i]=i;\\n        \\n        sort(a.begin(),a.end());\\n        for(auto e:a){\\n            vector<int> p;\\n            int mn=e;\\n            while(e>1){\\n                int pr=spf[e];\\n                while(e%pr==0)\\n                    e/=pr;\\n                p.push_back(findPar(pr));\\n                mn=min(mn,findPar(pr));\\n            }\\n            mn=findPar(mn);\\n            for(auto e:p)\\n                par[e]=mn;\\n        }\\n        \\n        int ans=0;\\n        unordered_map<int,int> mp;\\n        for(auto e:a){\\n            mp[findPar(spf[e])]++;\\n            ans=max(ans,mp[findPar(spf[e])]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967690,
                "title": "c-unionfind-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& A) {\\n        int root[100001]{}, res = 0;\\n        for(int i = 0; i < 100001; i++) root[i] = i;\\n\\n        auto findP = [&](int t) {\\n            while(t != root[t]) {\\n                root[t] = root[root[t]];\\n                t = root[t];\\n            }\\n            return t;\\n        };\\n\\n        for(auto e : A) {\\n            int p1 = findP(e);\\n            for(int i = 2; i <= sqrt(e); i++) {\\n                if((e%i) == 0) {\\n                    int p2 = findP(i), p3 = findP(e/i);\\n                    root[p2] = p1;\\n                    root[p3] = p1;\\n                }\\n            }\\n        }\\n\\n        unordered_map<int, int> mp;\\n        for(auto e : A) res = max(res, ++mp[findP(e)]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& A) {\\n        int root[100001]{}, res = 0;\\n        for(int i = 0; i < 100001; i++) root[i] = i;\\n\\n        auto findP = [&](int t) {\\n            while(t != root[t]) {\\n                root[t] = root[root[t]];\\n                t = root[t];\\n            }\\n            return t;\\n        };\\n\\n        for(auto e : A) {\\n            int p1 = findP(e);\\n            for(int i = 2; i <= sqrt(e); i++) {\\n                if((e%i) == 0) {\\n                    int p2 = findP(i), p3 = findP(e/i);\\n                    root[p2] = p1;\\n                    root[p3] = p1;\\n                }\\n            }\\n        }\\n\\n        unordered_map<int, int> mp;\\n        for(auto e : A) res = max(res, ++mp[findP(e)]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956437,
                "title": "python3-solution-beats-99",
                "content": "# Code\\n```\\nclass UnionFind: \\n    \\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [1]*n\\n        \\n    def find(self, p): \\n        if p != self.parent[p]: \\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, p, q): \\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False \\n        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt\\n        self.parent[prt] = qrt\\n        self.rank[qrt] += self.rank[prt]\\n        return True \\n\\n\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        m = max(A)\\n        uf = UnionFind(m+1)\\n        seen = set(A)\\n        \\n        # modified sieve of eratosthenes \\n        sieve = [1]*(m+1)\\n        sieve[0] = sieve[1] = 0 \\n        for k in range(m//2+1): \\n            if sieve[k]: \\n                prev = k if k in seen else 0\\n                for x in range(2*k, m+1, k): \\n                    sieve[x] = 0\\n                    if x in seen: \\n                        if prev: uf.union(prev, x)\\n                        else: prev = x\\n        return max(uf.rank)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind: \\n    \\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [1]*n\\n        \\n    def find(self, p): \\n        if p != self.parent[p]: \\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, p, q): \\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False \\n        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt\\n        self.parent[prt] = qrt\\n        self.rank[qrt] += self.rank[prt]\\n        return True \\n\\n\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        m = max(A)\\n        uf = UnionFind(m+1)\\n        seen = set(A)\\n        \\n        # modified sieve of eratosthenes \\n        sieve = [1]*(m+1)\\n        sieve[0] = sieve[1] = 0 \\n        for k in range(m//2+1): \\n            if sieve[k]: \\n                prev = k if k in seen else 0\\n                for x in range(2*k, m+1, k): \\n                    sieve[x] = 0\\n                    if x in seen: \\n                        if prev: uf.union(prev, x)\\n                        else: prev = x\\n        return max(uf.rank)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887937,
                "title": "code-just-ran-on-edge-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMade a map in which each divisor contained a vector of the numbers in the list. Then made a graph and solved using dfs connected components\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint cc=0;\\n    void dfs(int i,vector<int> &vis,vector<vector<int> > &g){\\n        if(vis[i]){\\n            return;\\n        }\\n        cc++;\\n        vis[i]=1;\\n\\n        for(auto it: g[i]){\\n            \\n                dfs(it,vis,g);\\n        }\\n        return;\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n\\n        map<int,unordered_set<int> > m;\\n\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=2;j<=(sqrt(nums[i]));j++){\\n                if(nums[i]%j==0){\\n                    m[j].insert(i);\\n                    m[nums[i]/j].insert(i);\\n                }\\n               \\n            }\\n             m[nums[i]].insert(i);\\n        } \\n       /* \\n    for(auto it: m){\\n        cout<<it.first<<\"\\\\n\";\\n        for(auto kp:it.second){\\n            cout<<kp<<\" \";\\n        }\\n        cout<<\"\\\\n\";\\n\\n    }*/\\n        vector<vector<int> > g(nums.size());\\n\\n        for(auto it : m){\\n            //if(it.second.size()>1){\\n                auto kp = it.second.begin();\\n                auto op = it.second.begin();\\n                op++;\\n                while(op!=it.second.end()){\\n                    g[*op].push_back(*kp);\\n                    g[*kp].push_back(*op);\\n                    ++op;\\n                    ++kp;\\n                }\\n            \\n        }/*\\n for(int i=0;i<nums.size();i++){\\n            for(auto it: g[i]){\\n                cout<<it<<\" \";\\n            }\\n            cout<<\"\\\\n\";\\n        }*/\\n        vector<int> vis(nums.size(),0);\\nint ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(vis[i]==0){\\n                dfs(i,vis,g);\\n                ans=max(ans,cc);\\n                cc=0;\\n            }\\n        }\\n        return ans;\\n        \\n       \\n        return 0;\\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint cc=0;\\n    void dfs(int i,vector<int> &vis,vector<vector<int> > &g){\\n        if(vis[i]){\\n            return;\\n        }\\n        cc++;\\n        vis[i]=1;\\n\\n        for(auto it: g[i]){\\n            \\n                dfs(it,vis,g);\\n        }\\n        return;\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n\\n        map<int,unordered_set<int> > m;\\n\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=2;j<=(sqrt(nums[i]));j++){\\n                if(nums[i]%j==0){\\n                    m[j].insert(i);\\n                    m[nums[i]/j].insert(i);\\n                }\\n               \\n            }\\n             m[nums[i]].insert(i);\\n        } \\n       /* \\n    for(auto it: m){\\n        cout<<it.first<<\"\\\\n\";\\n        for(auto kp:it.second){\\n            cout<<kp<<\" \";\\n        }\\n        cout<<\"\\\\n\";\\n\\n    }*/\\n        vector<vector<int> > g(nums.size());\\n\\n        for(auto it : m){\\n            //if(it.second.size()>1){\\n                auto kp = it.second.begin();\\n                auto op = it.second.begin();\\n                op++;\\n                while(op!=it.second.end()){\\n                    g[*op].push_back(*kp);\\n                    g[*kp].push_back(*op);\\n                    ++op;\\n                    ++kp;\\n                }\\n            \\n        }/*\\n for(int i=0;i<nums.size();i++){\\n            for(auto it: g[i]){\\n                cout<<it<<\" \";\\n            }\\n            cout<<\"\\\\n\";\\n        }*/\\n        vector<int> vis(nums.size(),0);\\nint ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(vis[i]==0){\\n                dfs(i,vis,g);\\n                ans=max(ans,cc);\\n                cc=0;\\n            }\\n        }\\n        return ans;\\n        \\n       \\n        return 0;\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2828750,
                "title": "disjoint-set-prime-factorization-in-log-n-using-sieve-c",
                "content": "\\tclass Solution \\n\\t\\t{\\n\\t\\tprivate:\\n\\t\\tint findPar(vector<int>&parent,int node)\\n\\t\\t{\\n\\t\\t\\tif(node==parent[node])return node;\\n\\t\\t\\treturn parent[node] = findPar(parent,parent[node]);\\n\\t\\t}\\n\\t\\tvoid unite(vector<int>&size,vector<int>&parent,int u,int v)\\n\\t\\t{\\n\\t\\t\\tu = findPar(parent,u);\\n\\t\\t\\tv = findPar(parent,v);\\n\\t\\t\\tif(size[u]<size[v])\\n\\t\\t\\t{\\n\\t\\t\\t\\tparent[u] = v;\\n\\t\\t\\t\\tsize[v]+=size[u];\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tparent[v] = u;\\n\\t\\t\\t\\tsize[u]+=size[v];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvoid createSieve(vector<int>&sieve)\\n\\t\\t{\\n\\t\\t\\tfor(int i=2;i*i<=100000;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(sieve[i]==-1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor(int j=i*i;j<=100000;j+=i)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tsieve[j] = i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\tpublic:\\n\\t\\tint largestComponentSize(vector<int>& nums) \\n\\t\\t{\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<int>sieve(100001,-1);\\n\\t\\t\\tcreateSieve(sieve);\\n\\t\\t\\tmap<int,set<int>>mp;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint x = nums[i];\\n\\t\\t\\t\\tint y = nums[i];\\n\\t\\t\\t\\tvector<int>temp;\\n\\t\\t\\t\\twhile(sieve[x]!=-1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.push_back(sieve[x]);\\n\\t\\t\\t\\t\\tx/=sieve[x];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp.push_back(x);\\n\\t\\t\\t\\tfor(auto j:temp)mp[j].insert(i);\\n\\t\\t\\t}\\n\\t\\t\\tint m = mp.size();\\n\\t\\t\\tvector<int>parent(n+m,0),size(n+m,1);\\n\\t\\t\\tfor(int i=0;i<n+m;i++)parent[i] = i;\\n\\t\\t\\tint i = n-1;\\n\\t\\t\\tvector<pair<int,int>>edges;\\n\\t\\t\\tfor(auto it:mp)\\n\\t\\t\\t{\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tfor(auto j:it.second)edges.push_back({i,j});\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto i:edges)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint x = findPar(parent,i.first);\\n\\t\\t\\t\\tint y = findPar(parent,i.second);\\n\\t\\t\\t\\tif(x!=y)unite(size,parent,i.second,i.first);\\n\\t\\t\\t}\\n\\t\\t\\tmap<int,int>z;\\n\\t\\t\\tfor(int i=0;i<n;i++)z[findPar(parent,parent[i])]++;\\n\\t\\t\\tint maxi = 0;\\n\\t\\t\\tfor(auto i:z)maxi = max(maxi,i.second);\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution \\n\\t\\t{\\n\\t\\tprivate:\\n\\t\\tint findPar(vector<int>&parent,int node)\\n\\t\\t{\\n\\t\\t\\tif(node==parent[node])return node;\\n\\t\\t\\treturn parent[node] = findPar(parent,parent[node]);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2821887,
                "title": "python-disjoint-set-solution-w-detailed-explanation",
                "content": "# Intuition\\nIt is clear that we need to use a disjoint set (aka union find) data structure for this problem. The first approach I tried was to iterate over each pair of elements in `nums`, check whether they share common factors, and union their set if they do. This results in O(N^2 * log(N)) time complexity and O(N) space complexity, which unfortunately raises TLE.\\nThe crux of the matter is to realize that we can group elements by their factors. This allows us to reduce for-loop iterations from O(N^2) to O(N * log(N)), as for each number we now only need to check all factors from 2 to `sqrt(x)`. \\nAs the official solution points out, we could further improve this solution by looping over prime factors only (which I did not implement).\\n\\n# Approach\\n1. For each element in `nums`, find all its factors. For each factor A, `union(x, A)` and `union(x, x // A)`.\\n2. Iterate over `nums` again to count the size of each set.\\n\\n# Complexity\\n- Time complexity:\\n    1. O(N * M * A(M)), where N is `len(nums)` and M is `max(nums)`. A() is the Ackermann function.\\n    2. O(N * A(M))\\nThus the total time complexity is O(N * M * A(M))\\n\\n- Space complexity:\\n    1. The disjoint set has size O(M)\\n    2. The counter has size O(N)\\nThus the total space complexity is O(M)\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass DisjointSet:\\n    def __init__(self, size):\\n        self.parent = list(range(size+1))\\n        self.size = [1 for _ in range(size+1)]\\n    \\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        parent_x, parent_y = self.find(x), self.find(y)\\n        if parent_x == parent_y: return \\n        if self.size[parent_x] < self.size[parent_y]:\\n            self.parent[parent_x] = parent_y \\n            self.size[parent_y] += self.size[parent_x]\\n            return parent_y \\n        else:\\n            self.parent[parent_y] = parent_x \\n            self.size[parent_x] += self.size[parent_y]\\n            return parent_x\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        ds = DisjointSet(max(nums))\\n        for x in nums:\\n            for A in range(2, int(sqrt(x)) + 1):\\n                if x % A == 0:\\n                    ds.union(x, A)\\n                    ds.union(x, x // A)\\n        # find the max size among all sets\\n        c = Counter()\\n        for n in nums:\\n            c[ds.find(n)] += 1\\n        return max(c.values())\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass DisjointSet:\\n    def __init__(self, size):\\n        self.parent = list(range(size+1))\\n        self.size = [1 for _ in range(size+1)]\\n    \\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        parent_x, parent_y = self.find(x), self.find(y)\\n        if parent_x == parent_y: return \\n        if self.size[parent_x] < self.size[parent_y]:\\n            self.parent[parent_x] = parent_y \\n            self.size[parent_y] += self.size[parent_x]\\n            return parent_y \\n        else:\\n            self.parent[parent_y] = parent_x \\n            self.size[parent_x] += self.size[parent_y]\\n            return parent_x\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        ds = DisjointSet(max(nums))\\n        for x in nums:\\n            for A in range(2, int(sqrt(x)) + 1):\\n                if x % A == 0:\\n                    ds.union(x, A)\\n                    ds.union(x, x // A)\\n        # find the max size among all sets\\n        c = Counter()\\n        for n in nums:\\n            c[ds.find(n)] += 1\\n        return max(c.values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776285,
                "title": "hashing-and-dsu",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static const int N =  1e5 +5;\\n    int n; \\n    int vis[N] = {0};\\n    int par[N];\\n    int rank[N] = {1};\\n    vector<int>prime;\\n\\n    void init(){\\n        for( int i = 0 ; i<N ; ++i ){\\n             par[i] = i;\\n            rank[i] = 1;\\n            if(vis[i]==1 || i<2 )continue;\\n            for( int j = i ; j<N ; j = 1ll*(j+i)){\\n                vis[j] = 1;\\n            }\\n            prime.emplace_back(i);\\n        }\\n    }\\n\\n\\n    int find_par( int node ){\\n        if(node == par[node])return node;\\n        return par[node] = find_par(par[node]);\\n    }\\n\\n\\n    void merge( int x , int y ){\\n        x = find_par(x);\\n        y = find_par(y);\\n\\n        if(x==y)\\n            return ;\\n            \\n        if(rank[x]==rank[y]){\\n            par[y] = x;\\n            rank[x] += 1;\\n        }\\n        else{\\n            if(rank[x] >  rank[y]){\\n                par[y] = x;\\n                rank[x] += rank[y];\\n            }\\n            else{\\n                par[x] = y;\\n                rank[y] += rank[x];\\n            }\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n        init();\\n     \\n        unordered_map<int , int >int_mp;\\n\\n        for( int i = 0 ; i<nums.size() ; ++i  ){\\n              int_mp[nums[i]] = i;\\n        }\\n\\n\\n      \\n\\n        for( int p : prime  ){\\n            vector<int>temp;\\n            for( int x = p ; x<N ; x += p ){\\n                if(int_mp.find(x) != int_mp.end())\\n                      temp.emplace_back(int_mp[x]);\\n            }\\n            \\n            for( int i = 1  ; i<temp.size() ; ++i ){\\n                merge(temp[i] , temp[i-1]);\\n            }\\n            \\n            //cout<<temp.size()<<\"\\\\n\";\\n        }\\n\\n        \\n        int cnt = 1 ;\\n        unordered_map<int , int>mp;\\n        for( int x = 0  ; x<nums.size() ; ++x ){\\n            int p  = find_par(x);\\n            mp[p] += 1;\\n            cnt = max( cnt , mp[p]);\\n        }\\n        return cnt ;\\n        \\n        //return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static const int N =  1e5 +5;\\n    int n; \\n    int vis[N] = {0};\\n    int par[N];\\n    int rank[N] = {1};\\n    vector<int>prime;\\n\\n    void init(){\\n        for( int i = 0 ; i<N ; ++i ){\\n             par[i] = i;\\n            rank[i] = 1;\\n            if(vis[i]==1 || i<2 )continue;\\n            for( int j = i ; j<N ; j = 1ll*(j+i)){\\n                vis[j] = 1;\\n            }\\n            prime.emplace_back(i);\\n        }\\n    }\\n\\n\\n    int find_par( int node ){\\n        if(node == par[node])return node;\\n        return par[node] = find_par(par[node]);\\n    }\\n\\n\\n    void merge( int x , int y ){\\n        x = find_par(x);\\n        y = find_par(y);\\n\\n        if(x==y)\\n            return ;\\n            \\n        if(rank[x]==rank[y]){\\n            par[y] = x;\\n            rank[x] += 1;\\n        }\\n        else{\\n            if(rank[x] >  rank[y]){\\n                par[y] = x;\\n                rank[x] += rank[y];\\n            }\\n            else{\\n                par[x] = y;\\n                rank[y] += rank[x];\\n            }\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n        init();\\n     \\n        unordered_map<int , int >int_mp;\\n\\n        for( int i = 0 ; i<nums.size() ; ++i  ){\\n              int_mp[nums[i]] = i;\\n        }\\n\\n\\n      \\n\\n        for( int p : prime  ){\\n            vector<int>temp;\\n            for( int x = p ; x<N ; x += p ){\\n                if(int_mp.find(x) != int_mp.end())\\n                      temp.emplace_back(int_mp[x]);\\n            }\\n            \\n            for( int i = 1  ; i<temp.size() ; ++i ){\\n                merge(temp[i] , temp[i-1]);\\n            }\\n            \\n            //cout<<temp.size()<<\"\\\\n\";\\n        }\\n\\n        \\n        int cnt = 1 ;\\n        unordered_map<int , int>mp;\\n        for( int x = 0  ; x<nums.size() ; ++x ){\\n            int p  = find_par(x);\\n            mp[p] += 1;\\n            cnt = max( cnt , mp[p]);\\n        }\\n        return cnt ;\\n        \\n        //return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2775966,
                "title": "dsu",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static const int N =  1e5 +5;\\n    int n; \\n    int vis[N] ;\\n    int par[N];\\n    int rank[N] = {1};\\n    vector<int>prime;\\n    \\n\\n    void init(){\\n        for( int i = 1 ; i< N ; ++i ){\\n            vis[i] = i;\\n            par[i] = i;\\n            rank[i] =1;\\n        }\\n        for( int i = 2 ; i*i<N ; ++i ){\\n            if(vis[i]==i){\\n                for( int j = 1ll*i*i ; j< N ;  j = j + i ){\\n                    if(vis[j]==j){\\n                        vis[j] = i;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n\\n    int find_par( int node ){\\n        if(node == par[node])return node;\\n        return par[node] = find_par(par[node]);\\n    }\\n\\n\\n    void merge( int x , int y ){\\n        x = find_par(x);\\n        y = find_par(y);\\n\\n        if(x==y)\\n            return ;\\n\\n        if(rank[x]==rank[y]){\\n            par[y] = x;\\n            rank[x] += 1;\\n        }\\n        else{\\n            if(rank[x] >  rank[y]){\\n                par[y] = x;\\n                rank[x] += rank[y];\\n            }\\n            else{\\n                par[x] = y;\\n                rank[y] += rank[x];\\n            }\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n       \\n        init();\\n        vector<int>temp;\\n        for( int x : nums  ){\\n            temp.clear();\\n            int n = x;\\n            if(n==1) continue;\\n            while(n != 1 ){\\n                int p  = vis[n];\\n                temp.emplace_back(p);\\n                while( n % p == 0 ){\\n                    n = n/p;\\n                }\\n            }\\n            for( int i = 0  ; i<temp.size()-1 ; ++i ){\\n                merge(temp[i] , temp[i+1]);\\n            }\\n            // cout<<x<<\"->\";\\n            // for(auto u :  temp ){\\n            //     cout<<u<<\" \";\\n            //   }\\n            //   printf(\"\\\\n\");\\n        }\\n\\n        int cnt = 1 ;\\n        unordered_map<int , int>mp;\\n        for( int x :  nums ){\\n            int y = -1;\\n            for( int i =  2 ; i*i <= x ; ++i  ){\\n                if(x% i  == 0 ){\\n                    y = i ;\\n                    break;\\n                }\\n            }\\n            if(y==-1){\\n                y = x;\\n            }\\n            \\n            int p  = find_par(y);\\n            mp[p] += 1;\\n            cnt = max( cnt , mp[p]);\\n        }\\n        return cnt ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static const int N =  1e5 +5;\\n    int n; \\n    int vis[N] ;\\n    int par[N];\\n    int rank[N] = {1};\\n    vector<int>prime;\\n    \\n\\n    void init(){\\n        for( int i = 1 ; i< N ; ++i ){\\n            vis[i] = i;\\n            par[i] = i;\\n            rank[i] =1;\\n        }\\n        for( int i = 2 ; i*i<N ; ++i ){\\n            if(vis[i]==i){\\n                for( int j = 1ll*i*i ; j< N ;  j = j + i ){\\n                    if(vis[j]==j){\\n                        vis[j] = i;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n\\n    int find_par( int node ){\\n        if(node == par[node])return node;\\n        return par[node] = find_par(par[node]);\\n    }\\n\\n\\n    void merge( int x , int y ){\\n        x = find_par(x);\\n        y = find_par(y);\\n\\n        if(x==y)\\n            return ;\\n\\n        if(rank[x]==rank[y]){\\n            par[y] = x;\\n            rank[x] += 1;\\n        }\\n        else{\\n            if(rank[x] >  rank[y]){\\n                par[y] = x;\\n                rank[x] += rank[y];\\n            }\\n            else{\\n                par[x] = y;\\n                rank[y] += rank[x];\\n            }\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n       \\n        init();\\n        vector<int>temp;\\n        for( int x : nums  ){\\n            temp.clear();\\n            int n = x;\\n            if(n==1) continue;\\n            while(n != 1 ){\\n                int p  = vis[n];\\n                temp.emplace_back(p);\\n                while( n % p == 0 ){\\n                    n = n/p;\\n                }\\n            }\\n            for( int i = 0  ; i<temp.size()-1 ; ++i ){\\n                merge(temp[i] , temp[i+1]);\\n            }\\n            // cout<<x<<\"->\";\\n            // for(auto u :  temp ){\\n            //     cout<<u<<\" \";\\n            //   }\\n            //   printf(\"\\\\n\");\\n        }\\n\\n        int cnt = 1 ;\\n        unordered_map<int , int>mp;\\n        for( int x :  nums ){\\n            int y = -1;\\n            for( int i =  2 ; i*i <= x ; ++i  ){\\n                if(x% i  == 0 ){\\n                    y = i ;\\n                    break;\\n                }\\n            }\\n            if(y==-1){\\n                y = x;\\n            }\\n            \\n            int p  = find_par(y);\\n            mp[p] += 1;\\n            cnt = max( cnt , mp[p]);\\n        }\\n        return cnt ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2773863,
                "title": "swift-491-ms",
                "content": "```\\nclass Solution {\\n    func largestComponentSize(_ nums: [Int]) -> Int {\\n        let n = nums.count\\n        guard n > 1 else { return n }\\n        let groups = dividersGroups(nums)\\n        var graph = Array(0 ..< n)\\n        for items in groups.values {\\n            guard items.count > 1 else { continue }\\n            var parent = -1\\n            for i in items {\\n                if parent < 0 {\\n                    parent = searchParent(i, &graph)\\n                } else {\\n                    let p2 = searchParent(i, &graph)\\n                    if parent != p2 { graph[p2] = parent }\\n                }\\n            }\\n        }\\n        var counts = Array(repeating: 0, count: n)\\n        var maxCount = 0\\n        for i in 0 ..< n {\\n            let p = searchParent(i, &graph)\\n            counts[p] += 1\\n            maxCount = max(maxCount, counts[p])\\n        }\\n        return maxCount\\n    }\\n\\n    private func searchParent(_ e: Int, _ graph: inout [Int]) -> Int {\\n        if graph[e] == e { return e }\\n        graph[e] = searchParent(graph[e], &graph)\\n        return graph[e]\\n    }\\n\\n    // Returns map simpleNum -> [indexes in nums with simpleNum factor]\\n    private func dividersGroups(_ nums: [Int]) -> [Int: [Int]] {\\n        var simpleNums = [2, 3]\\n        var simplesMap: [Int: [Int]] = [:]\\n\\n        let addDivider: (Int, Int) -> Void = { s, i in\\n            if simplesMap[s] == nil {\\n                simplesMap[s] = [i]\\n            } else {\\n                simplesMap[s]?.append(i)\\n            }\\n        }\\n\\n        for (i, n) in nums.enumerated() {\\n            let sMax = Int(sqrt(Double(n)))\\n            var j = simpleNums.last!\\n            while j <= sMax {\\n                j += 2\\n                while simpleNums.contains(where: { j % $0 == 0 }) { j += 2 }\\n                simpleNums.append(j)\\n            }\\n            var n1 = n\\n            for s in simpleNums {\\n                if s > sMax || n1 < 2 { break }\\n                if n1 % s == 0 {\\n                    addDivider(s, i)\\n                    while n1 % s == 0 { n1 /= s }\\n                }\\n            }\\n            if n1 > 1 {\\n                addDivider(n1, i)\\n            }\\n        }\\n        return simplesMap\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func largestComponentSize(_ nums: [Int]) -> Int {\\n        let n = nums.count\\n        guard n > 1 else { return n }\\n        let groups = dividersGroups(nums)\\n        var graph = Array(0 ..< n)\\n        for items in groups.values {\\n            guard items.count > 1 else { continue }\\n            var parent = -1\\n            for i in items {\\n                if parent < 0 {\\n                    parent = searchParent(i, &graph)\\n                } else {\\n                    let p2 = searchParent(i, &graph)\\n                    if parent != p2 { graph[p2] = parent }\\n                }\\n            }\\n        }\\n        var counts = Array(repeating: 0, count: n)\\n        var maxCount = 0\\n        for i in 0 ..< n {\\n            let p = searchParent(i, &graph)\\n            counts[p] += 1\\n            maxCount = max(maxCount, counts[p])\\n        }\\n        return maxCount\\n    }\\n\\n    private func searchParent(_ e: Int, _ graph: inout [Int]) -> Int {\\n        if graph[e] == e { return e }\\n        graph[e] = searchParent(graph[e], &graph)\\n        return graph[e]\\n    }\\n\\n    // Returns map simpleNum -> [indexes in nums with simpleNum factor]\\n    private func dividersGroups(_ nums: [Int]) -> [Int: [Int]] {\\n        var simpleNums = [2, 3]\\n        var simplesMap: [Int: [Int]] = [:]\\n\\n        let addDivider: (Int, Int) -> Void = { s, i in\\n            if simplesMap[s] == nil {\\n                simplesMap[s] = [i]\\n            } else {\\n                simplesMap[s]?.append(i)\\n            }\\n        }\\n\\n        for (i, n) in nums.enumerated() {\\n            let sMax = Int(sqrt(Double(n)))\\n            var j = simpleNums.last!\\n            while j <= sMax {\\n                j += 2\\n                while simpleNums.contains(where: { j % $0 == 0 }) { j += 2 }\\n                simpleNums.append(j)\\n            }\\n            var n1 = n\\n            for s in simpleNums {\\n                if s > sMax || n1 < 2 { break }\\n                if n1 % s == 0 {\\n                    addDivider(s, i)\\n                    while n1 % s == 0 { n1 /= s }\\n                }\\n            }\\n            if n1 > 1 {\\n                addDivider(n1, i)\\n            }\\n        }\\n        return simplesMap\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565219,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-component-size-by-common-factor/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Union-Find via Factors \n\n  \n**Approach 2:** Union-Find on Prime Factors\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Horopter",
                        "content": "I\\'d like to report a spurious test case : [641,645,135,108,394,652,525,532,536,28,414,543,549,926,625,540,812,181,698,572,829,318,447,962,709,199,585,459,335,594,83,468,854,761,856,478,991,993,355,359,700,747,236,624,113,596,125]"
                    },
                    {
                        "username": "selder02",
                        "content": "I just wanted to comment on the constraints, and why I think they are poorly chosen. Say there are N elements and the maximum is M, and \\u03B1 is the inverse Ackermann function.\\n\\nThere are two main ways to solve this:\\n\\n* iterate over each number and compute all its factors. The runtime is O(N sqrt(M) \\u03B1(N)) since there are up to sqrt(M) factors of each number.\\n* iterate over all pairs of numbers and compute their GCF. The runtime is O(N^2 log(M) \\u03B1(N)) since the Euclidean algorithm runs in log(M) time.\\n\\nIn each case we use a union-find data structure, hence the \\u03B1(N)\\'s.\\n\\nThe second approach times out, but the first is accepted.\\n\\nMy complaint is that the first is only pseudopolynomial (polynomial in the size of the integers themselves), i.e. exponential in the size of the problem (the number of digits or bits in the input). It would blow up for larger problems, e.g. with long long inputs.\\n\\nThe second times out even though it\\'s truly polynomial.\\n\\nMoreover, sqrt(M) is not that much smaller than N, so the runtimes are not so vastly different.\\n\\nIt\\'s annoying to build a reasonable algorithm, and then have it time out. It should be more clear from the inputs which solutions will time out and which won\\'t."
                    },
                    {
                        "username": "sakuragrass",
                        "content": "According to the defination, \\n``\\nThere is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1.\\n``\\nThe two 1s are not connected as they only have the common factor 1 which is not greater than 1. Hence they are 4 isolated nodes, the output should be 1."
                    },
                    {
                        "username": "Rounak225",
                        "content": "I tried this by making a graph and going ahead with DFS. It passed 74/108 cases, and timed out for the rest. Guess it needs a better run time than O(n^2)"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Use Algorithm to Find All the distinct sets for given input array\\n2) Using A Map To Keep Tracking The No Of Nodes For All Distinct Subsets.\\n3) Take The Maximum Value.\\n4) Return The Maximum Value.\\n\\nCode (Please try it out first on your own) :- \\n\\nhttps://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Largest%20Component%20Size%20by%20Common%20Factor%20Day30.java\\n\\nExplanation :- \\nhttps://youtu.be/hP_ZxutreCE\\n"
                    },
                    {
                        "username": "shadyysf",
                        "content": "Something weird is happening for me. I pass all the 108 test cases but I still get TLE. The test case that fails the time limit is totally empty. I think there\\'s a bug in the test code or something."
                    }
                ]
            },
            {
                "id": 1570682,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-component-size-by-common-factor/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Union-Find via Factors \n\n  \n**Approach 2:** Union-Find on Prime Factors\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Horopter",
                        "content": "I\\'d like to report a spurious test case : [641,645,135,108,394,652,525,532,536,28,414,543,549,926,625,540,812,181,698,572,829,318,447,962,709,199,585,459,335,594,83,468,854,761,856,478,991,993,355,359,700,747,236,624,113,596,125]"
                    },
                    {
                        "username": "selder02",
                        "content": "I just wanted to comment on the constraints, and why I think they are poorly chosen. Say there are N elements and the maximum is M, and \\u03B1 is the inverse Ackermann function.\\n\\nThere are two main ways to solve this:\\n\\n* iterate over each number and compute all its factors. The runtime is O(N sqrt(M) \\u03B1(N)) since there are up to sqrt(M) factors of each number.\\n* iterate over all pairs of numbers and compute their GCF. The runtime is O(N^2 log(M) \\u03B1(N)) since the Euclidean algorithm runs in log(M) time.\\n\\nIn each case we use a union-find data structure, hence the \\u03B1(N)\\'s.\\n\\nThe second approach times out, but the first is accepted.\\n\\nMy complaint is that the first is only pseudopolynomial (polynomial in the size of the integers themselves), i.e. exponential in the size of the problem (the number of digits or bits in the input). It would blow up for larger problems, e.g. with long long inputs.\\n\\nThe second times out even though it\\'s truly polynomial.\\n\\nMoreover, sqrt(M) is not that much smaller than N, so the runtimes are not so vastly different.\\n\\nIt\\'s annoying to build a reasonable algorithm, and then have it time out. It should be more clear from the inputs which solutions will time out and which won\\'t."
                    },
                    {
                        "username": "sakuragrass",
                        "content": "According to the defination, \\n``\\nThere is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1.\\n``\\nThe two 1s are not connected as they only have the common factor 1 which is not greater than 1. Hence they are 4 isolated nodes, the output should be 1."
                    },
                    {
                        "username": "Rounak225",
                        "content": "I tried this by making a graph and going ahead with DFS. It passed 74/108 cases, and timed out for the rest. Guess it needs a better run time than O(n^2)"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Use Algorithm to Find All the distinct sets for given input array\\n2) Using A Map To Keep Tracking The No Of Nodes For All Distinct Subsets.\\n3) Take The Maximum Value.\\n4) Return The Maximum Value.\\n\\nCode (Please try it out first on your own) :- \\n\\nhttps://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Largest%20Component%20Size%20by%20Common%20Factor%20Day30.java\\n\\nExplanation :- \\nhttps://youtu.be/hP_ZxutreCE\\n"
                    },
                    {
                        "username": "shadyysf",
                        "content": "Something weird is happening for me. I pass all the 108 test cases but I still get TLE. The test case that fails the time limit is totally empty. I think there\\'s a bug in the test code or something."
                    }
                ]
            },
            {
                "id": 1569460,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-component-size-by-common-factor/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Union-Find via Factors \n\n  \n**Approach 2:** Union-Find on Prime Factors\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Horopter",
                        "content": "I\\'d like to report a spurious test case : [641,645,135,108,394,652,525,532,536,28,414,543,549,926,625,540,812,181,698,572,829,318,447,962,709,199,585,459,335,594,83,468,854,761,856,478,991,993,355,359,700,747,236,624,113,596,125]"
                    },
                    {
                        "username": "selder02",
                        "content": "I just wanted to comment on the constraints, and why I think they are poorly chosen. Say there are N elements and the maximum is M, and \\u03B1 is the inverse Ackermann function.\\n\\nThere are two main ways to solve this:\\n\\n* iterate over each number and compute all its factors. The runtime is O(N sqrt(M) \\u03B1(N)) since there are up to sqrt(M) factors of each number.\\n* iterate over all pairs of numbers and compute their GCF. The runtime is O(N^2 log(M) \\u03B1(N)) since the Euclidean algorithm runs in log(M) time.\\n\\nIn each case we use a union-find data structure, hence the \\u03B1(N)\\'s.\\n\\nThe second approach times out, but the first is accepted.\\n\\nMy complaint is that the first is only pseudopolynomial (polynomial in the size of the integers themselves), i.e. exponential in the size of the problem (the number of digits or bits in the input). It would blow up for larger problems, e.g. with long long inputs.\\n\\nThe second times out even though it\\'s truly polynomial.\\n\\nMoreover, sqrt(M) is not that much smaller than N, so the runtimes are not so vastly different.\\n\\nIt\\'s annoying to build a reasonable algorithm, and then have it time out. It should be more clear from the inputs which solutions will time out and which won\\'t."
                    },
                    {
                        "username": "sakuragrass",
                        "content": "According to the defination, \\n``\\nThere is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1.\\n``\\nThe two 1s are not connected as they only have the common factor 1 which is not greater than 1. Hence they are 4 isolated nodes, the output should be 1."
                    },
                    {
                        "username": "Rounak225",
                        "content": "I tried this by making a graph and going ahead with DFS. It passed 74/108 cases, and timed out for the rest. Guess it needs a better run time than O(n^2)"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Use Algorithm to Find All the distinct sets for given input array\\n2) Using A Map To Keep Tracking The No Of Nodes For All Distinct Subsets.\\n3) Take The Maximum Value.\\n4) Return The Maximum Value.\\n\\nCode (Please try it out first on your own) :- \\n\\nhttps://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Largest%20Component%20Size%20by%20Common%20Factor%20Day30.java\\n\\nExplanation :- \\nhttps://youtu.be/hP_ZxutreCE\\n"
                    },
                    {
                        "username": "shadyysf",
                        "content": "Something weird is happening for me. I pass all the 108 test cases but I still get TLE. The test case that fails the time limit is totally empty. I think there\\'s a bug in the test code or something."
                    }
                ]
            },
            {
                "id": 1687702,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-component-size-by-common-factor/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Union-Find via Factors \n\n  \n**Approach 2:** Union-Find on Prime Factors\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Horopter",
                        "content": "I\\'d like to report a spurious test case : [641,645,135,108,394,652,525,532,536,28,414,543,549,926,625,540,812,181,698,572,829,318,447,962,709,199,585,459,335,594,83,468,854,761,856,478,991,993,355,359,700,747,236,624,113,596,125]"
                    },
                    {
                        "username": "selder02",
                        "content": "I just wanted to comment on the constraints, and why I think they are poorly chosen. Say there are N elements and the maximum is M, and \\u03B1 is the inverse Ackermann function.\\n\\nThere are two main ways to solve this:\\n\\n* iterate over each number and compute all its factors. The runtime is O(N sqrt(M) \\u03B1(N)) since there are up to sqrt(M) factors of each number.\\n* iterate over all pairs of numbers and compute their GCF. The runtime is O(N^2 log(M) \\u03B1(N)) since the Euclidean algorithm runs in log(M) time.\\n\\nIn each case we use a union-find data structure, hence the \\u03B1(N)\\'s.\\n\\nThe second approach times out, but the first is accepted.\\n\\nMy complaint is that the first is only pseudopolynomial (polynomial in the size of the integers themselves), i.e. exponential in the size of the problem (the number of digits or bits in the input). It would blow up for larger problems, e.g. with long long inputs.\\n\\nThe second times out even though it\\'s truly polynomial.\\n\\nMoreover, sqrt(M) is not that much smaller than N, so the runtimes are not so vastly different.\\n\\nIt\\'s annoying to build a reasonable algorithm, and then have it time out. It should be more clear from the inputs which solutions will time out and which won\\'t."
                    },
                    {
                        "username": "sakuragrass",
                        "content": "According to the defination, \\n``\\nThere is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1.\\n``\\nThe two 1s are not connected as they only have the common factor 1 which is not greater than 1. Hence they are 4 isolated nodes, the output should be 1."
                    },
                    {
                        "username": "Rounak225",
                        "content": "I tried this by making a graph and going ahead with DFS. It passed 74/108 cases, and timed out for the rest. Guess it needs a better run time than O(n^2)"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Use Algorithm to Find All the distinct sets for given input array\\n2) Using A Map To Keep Tracking The No Of Nodes For All Distinct Subsets.\\n3) Take The Maximum Value.\\n4) Return The Maximum Value.\\n\\nCode (Please try it out first on your own) :- \\n\\nhttps://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Largest%20Component%20Size%20by%20Common%20Factor%20Day30.java\\n\\nExplanation :- \\nhttps://youtu.be/hP_ZxutreCE\\n"
                    },
                    {
                        "username": "shadyysf",
                        "content": "Something weird is happening for me. I pass all the 108 test cases but I still get TLE. The test case that fails the time limit is totally empty. I think there\\'s a bug in the test code or something."
                    }
                ]
            },
            {
                "id": 1574300,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-component-size-by-common-factor/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Union-Find via Factors \n\n  \n**Approach 2:** Union-Find on Prime Factors\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Horopter",
                        "content": "I\\'d like to report a spurious test case : [641,645,135,108,394,652,525,532,536,28,414,543,549,926,625,540,812,181,698,572,829,318,447,962,709,199,585,459,335,594,83,468,854,761,856,478,991,993,355,359,700,747,236,624,113,596,125]"
                    },
                    {
                        "username": "selder02",
                        "content": "I just wanted to comment on the constraints, and why I think they are poorly chosen. Say there are N elements and the maximum is M, and \\u03B1 is the inverse Ackermann function.\\n\\nThere are two main ways to solve this:\\n\\n* iterate over each number and compute all its factors. The runtime is O(N sqrt(M) \\u03B1(N)) since there are up to sqrt(M) factors of each number.\\n* iterate over all pairs of numbers and compute their GCF. The runtime is O(N^2 log(M) \\u03B1(N)) since the Euclidean algorithm runs in log(M) time.\\n\\nIn each case we use a union-find data structure, hence the \\u03B1(N)\\'s.\\n\\nThe second approach times out, but the first is accepted.\\n\\nMy complaint is that the first is only pseudopolynomial (polynomial in the size of the integers themselves), i.e. exponential in the size of the problem (the number of digits or bits in the input). It would blow up for larger problems, e.g. with long long inputs.\\n\\nThe second times out even though it\\'s truly polynomial.\\n\\nMoreover, sqrt(M) is not that much smaller than N, so the runtimes are not so vastly different.\\n\\nIt\\'s annoying to build a reasonable algorithm, and then have it time out. It should be more clear from the inputs which solutions will time out and which won\\'t."
                    },
                    {
                        "username": "sakuragrass",
                        "content": "According to the defination, \\n``\\nThere is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1.\\n``\\nThe two 1s are not connected as they only have the common factor 1 which is not greater than 1. Hence they are 4 isolated nodes, the output should be 1."
                    },
                    {
                        "username": "Rounak225",
                        "content": "I tried this by making a graph and going ahead with DFS. It passed 74/108 cases, and timed out for the rest. Guess it needs a better run time than O(n^2)"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Use Algorithm to Find All the distinct sets for given input array\\n2) Using A Map To Keep Tracking The No Of Nodes For All Distinct Subsets.\\n3) Take The Maximum Value.\\n4) Return The Maximum Value.\\n\\nCode (Please try it out first on your own) :- \\n\\nhttps://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Largest%20Component%20Size%20by%20Common%20Factor%20Day30.java\\n\\nExplanation :- \\nhttps://youtu.be/hP_ZxutreCE\\n"
                    },
                    {
                        "username": "shadyysf",
                        "content": "Something weird is happening for me. I pass all the 108 test cases but I still get TLE. The test case that fails the time limit is totally empty. I think there\\'s a bug in the test code or something."
                    }
                ]
            },
            {
                "id": 1981975,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-component-size-by-common-factor/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Union-Find via Factors \n\n  \n**Approach 2:** Union-Find on Prime Factors\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Horopter",
                        "content": "I\\'d like to report a spurious test case : [641,645,135,108,394,652,525,532,536,28,414,543,549,926,625,540,812,181,698,572,829,318,447,962,709,199,585,459,335,594,83,468,854,761,856,478,991,993,355,359,700,747,236,624,113,596,125]"
                    },
                    {
                        "username": "selder02",
                        "content": "I just wanted to comment on the constraints, and why I think they are poorly chosen. Say there are N elements and the maximum is M, and \\u03B1 is the inverse Ackermann function.\\n\\nThere are two main ways to solve this:\\n\\n* iterate over each number and compute all its factors. The runtime is O(N sqrt(M) \\u03B1(N)) since there are up to sqrt(M) factors of each number.\\n* iterate over all pairs of numbers and compute their GCF. The runtime is O(N^2 log(M) \\u03B1(N)) since the Euclidean algorithm runs in log(M) time.\\n\\nIn each case we use a union-find data structure, hence the \\u03B1(N)\\'s.\\n\\nThe second approach times out, but the first is accepted.\\n\\nMy complaint is that the first is only pseudopolynomial (polynomial in the size of the integers themselves), i.e. exponential in the size of the problem (the number of digits or bits in the input). It would blow up for larger problems, e.g. with long long inputs.\\n\\nThe second times out even though it\\'s truly polynomial.\\n\\nMoreover, sqrt(M) is not that much smaller than N, so the runtimes are not so vastly different.\\n\\nIt\\'s annoying to build a reasonable algorithm, and then have it time out. It should be more clear from the inputs which solutions will time out and which won\\'t."
                    },
                    {
                        "username": "sakuragrass",
                        "content": "According to the defination, \\n``\\nThere is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1.\\n``\\nThe two 1s are not connected as they only have the common factor 1 which is not greater than 1. Hence they are 4 isolated nodes, the output should be 1."
                    },
                    {
                        "username": "Rounak225",
                        "content": "I tried this by making a graph and going ahead with DFS. It passed 74/108 cases, and timed out for the rest. Guess it needs a better run time than O(n^2)"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Use Algorithm to Find All the distinct sets for given input array\\n2) Using A Map To Keep Tracking The No Of Nodes For All Distinct Subsets.\\n3) Take The Maximum Value.\\n4) Return The Maximum Value.\\n\\nCode (Please try it out first on your own) :- \\n\\nhttps://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Largest%20Component%20Size%20by%20Common%20Factor%20Day30.java\\n\\nExplanation :- \\nhttps://youtu.be/hP_ZxutreCE\\n"
                    },
                    {
                        "username": "shadyysf",
                        "content": "Something weird is happening for me. I pass all the 108 test cases but I still get TLE. The test case that fails the time limit is totally empty. I think there\\'s a bug in the test code or something."
                    }
                ]
            }
        ]
    },
    {
        "title": "Verifying an Alien Dictionary",
        "question_content": "<p>In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different <code>order</code>. The <code>order</code> of the alphabet is some permutation of lowercase letters.</p>\n\n<p>Given a sequence of <code>words</code> written in the alien language, and the <code>order</code> of the alphabet, return <code>true</code> if and only if the given <code>words</code> are sorted lexicographically in this alien language.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;\n<strong>Output:</strong> true\n<strong>Explanation: </strong>As &#39;h&#39; comes before &#39;l&#39; in this language, then the sequence is sorted.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot;\n<strong>Output:</strong> false\n<strong>Explanation: </strong>As &#39;d&#39; comes after &#39;l&#39; in this language, then words[0] &gt; words[1], hence the sequence is unsorted.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot;\n<strong>Output:</strong> false\n<strong>Explanation: </strong>The first three characters &quot;app&quot; match, and the second string is shorter (in size.) According to lexicographical rules &quot;apple&quot; &gt; &quot;app&quot;, because &#39;l&#39; &gt; &#39;&empty;&#39;, where &#39;&empty;&#39; is defined as the blank character which is less than any other character (<a href=\"https://en.wikipedia.org/wiki/Lexicographical_order\" target=\"_blank\">More info</a>).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li><code>order.length == 26</code></li>\n\t<li>All characters in <code>words[i]</code> and <code>order</code> are English lowercase letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 203185,
                "title": "java-c-python-mapping-to-normal-order",
                "content": "## **Explanation**\\nBuild a transform mapping from `order`,\\nFind all alien words with letters in normal order.\\n\\nFor example, if we have `order = \"xyz...\"`\\nWe can map the word `\"xyz\"` to `\"abc\"` or `\"123\"`\\n\\nThen we check if all words are in sorted order.\\n\\n## **Complexity**\\nTime `O(NS)`\\nSpace `O(1)`\\n\\n**Java**\\n```java\\n    int[] mapping = new int[26];\\n    public boolean isAlienSorted(String[] words, String order) {\\n        for (int i = 0; i < order.length(); i++)\\n            mapping[order.charAt(i) - \\'a\\'] = i;\\n        for (int i = 1; i < words.length; i++)\\n            if (bigger(words[i - 1], words[i]))\\n                return false;\\n        return true;\\n    }\\n\\n    boolean bigger(String s1, String s2) {\\n        int n = s1.length(), m = s2.length();\\n        for (int i = 0; i < n && i < m; ++i)\\n            if (s1.charAt(i) != s2.charAt(i))\\n                return mapping[s1.charAt(i) - \\'a\\'] > mapping[s2.charAt(i) - \\'a\\'];\\n        return n > m;\\n    }\\n```\\n\\n**C++**:\\n```cpp\\n    bool isAlienSorted(vector<string> words, string order) {\\n        int mapping[26];\\n        for (int i = 0; i < 26; i++)\\n            mapping[order[i] - \\'a\\'] = i;\\n        for (string &w : words)\\n            for (char &c : w)\\n                c = mapping[c - \\'a\\'];\\n        return is_sorted(words.begin(), words.end());\\n    }\\n```\\n\\n**Python**\\n```py\\n    def isAlienSorted(self, words, order):\\n        m = {c: i for i, c in enumerate(order)}\\n        words = [[m[c] for c in w] for w in words]\\n        return all(w1 <= w2 for w1, w2 in zip(words, words[1:]))\\n```\\n\\n**Python 1-line**\\nSlow, just for fun\\n```py\\n    def isAlienSorted(self, words, order):\\n        return words == sorted(words, key=lambda w: map(order.index, w))\\n```",
                "solutionTags": [],
                "code": "```java\\n    int[] mapping = new int[26];\\n    public boolean isAlienSorted(String[] words, String order) {\\n        for (int i = 0; i < order.length(); i++)\\n            mapping[order.charAt(i) - \\'a\\'] = i;\\n        for (int i = 1; i < words.length; i++)\\n            if (bigger(words[i - 1], words[i]))\\n                return false;\\n        return true;\\n    }\\n\\n    boolean bigger(String s1, String s2) {\\n        int n = s1.length(), m = s2.length();\\n        for (int i = 0; i < n && i < m; ++i)\\n            if (s1.charAt(i) != s2.charAt(i))\\n                return mapping[s1.charAt(i) - \\'a\\'] > mapping[s2.charAt(i) - \\'a\\'];\\n        return n > m;\\n    }\\n```\n```cpp\\n    bool isAlienSorted(vector<string> words, string order) {\\n        int mapping[26];\\n        for (int i = 0; i < 26; i++)\\n            mapping[order[i] - \\'a\\'] = i;\\n        for (string &w : words)\\n            for (char &c : w)\\n                c = mapping[c - \\'a\\'];\\n        return is_sorted(words.begin(), words.end());\\n    }\\n```\n```py\\n    def isAlienSorted(self, words, order):\\n        m = {c: i for i, c in enumerate(order)}\\n        words = [[m[c] for c in w] for w in words]\\n        return all(w1 <= w2 for w1, w2 in zip(words, words[1:]))\\n```\n```py\\n    def isAlienSorted(self, words, order):\\n        return words == sorted(words, key=lambda w: map(order.index, w))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 203175,
                "title": "python-straightforward-solution",
                "content": "* Hash indexes of each character for better runtime\\n* Compare every adjacent word\\n* If any letter of former word is in higher order, return False\\n* If current letter of former word is in lower order, forget the rest of word \\n* If lenght of former word is longer and latter word is substring of former, return False (apple & app etc.)\\n* Return True\\n```\\nclass Solution:\\n    def isAlienSorted(self, words, order):\\n        ind = {c: i for i, c in enumerate(order)}\\n        for a, b in zip(words, words[1:]):\\n            if len(a) > len(b) and a[:len(b)] == b:\\n                return False\\n            for s1, s2 in zip(a, b):\\n                if ind[s1] < ind[s2]:\\n                    break\\n                elif ind[s1] > ind[s2]:\\n                    return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words, order):\\n        ind = {c: i for i, c in enumerate(order)}\\n        for a, b in zip(words, words[1:]):\\n            if len(a) > len(b) and a[:len(b)] == b:\\n                return False\\n            for s1, s2 in zip(a, b):\\n                if ind[s1] < ind[s2]:\\n                    break\\n                elif ind[s1] > ind[s2]:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361525,
                "title": "python-solution-with-detailed-explaination-for-beginner",
                "content": "This is an explaination for \\nhttps://leetcode.com/problems/verifying-an-alien-dictionary/discuss/203185/JavaC%2B%2BPython-Mapping-to-Normal-Order\\nThanks for this smart solution!\\nFor example, \\nwords = [\"hello\",\"leetcode\"]\\norder = \"hlabcdefgijkmnopqrstuvwxyz\"\\n1. Create a dic, key is each word in new order, value is its index, which means its new position in the new order.\\ndic = {u\\'a\\': 2, u\\'c\\': 4, u\\'b\\': 3, u\\'e\\': 6, u\\'d\\': 5, u\\'g\\': 8, u\\'f\\': 7, u\\'i\\': 9, u\\'h\\': 0, u\\'k\\': 11, u\\'j\\': 10, u\\'m\\': 12, u\\'l\\': 1, u\\'o\\': 14, u\\'n\\': 13, u\\'q\\': 16, u\\'p\\': 15, u\\'s\\': 18, u\\'r\\': 17, u\\'u\\': 20, u\\'t\\': 19, u\\'w\\': 22, u\\'v\\': 21, u\\'y\\': 24, u\\'x\\': 23, u\\'z\\': 25}\\n\\n2. Transform the list of words into its index in new order.\\nwords = [\"hello\",\"leetcode\"] -> [[0, 6, 1, 1, 14], [1, 6, 6, 19, 4, 14, 5, 6]]\\n3. zip\\nzip() will zip 2 element one by one,\\nzip(words, words[1:]) here will combine first element(words[0]) in words with\\nwords[1], so we can compare current element with next element: 0->1, 1->2\\n4. For list comparision, if we want w1 < w2, if len(w1) = len(w2), it will compare each element in w1/w2, if everyone successes, return True.\\nIf len is different. then if len(w1) > len(w2): it will return false since null is less than anything. if len(w1) < len(w2), then as long as everyone in w1 is less than its corresponding cmpoent in w2, it will return True.\\nThis is the same as lexicographicaly sort.\\nif w1 > w2: since testcase is missing duplicates in the list, so to handle duplicate, we use > instead of >=\\n\\n```\\nclass Solution(object):\\n    def isAlienSorted(self, words, order):\\n        \"\"\"\\n        :type words: List[str]\\n        :type order: str\\n        :rtype: bool\\n        \"\"\"\\n        dic = {}\\n        new_words = []\\n        for i, ch in enumerate(order):\\n            dic[ch] = i\\n        for w in words:\\n            new = []\\n            for c in w:\\n                new.append(dic[c])\\n            new_words.append(new)\\n        for w1, w2 in zip(new_words, new_words[1:]):\\n            if w1 > w2:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isAlienSorted(self, words, order):\\n        \"\"\"\\n        :type words: List[str]\\n        :type order: str\\n        :rtype: bool\\n        \"\"\"\\n        dic = {}\\n        new_words = []\\n        for i, ch in enumerate(order):\\n            dic[ch] = i\\n        for w in words:\\n            new = []\\n            for c in w:\\n                new.append(dic[c])\\n            new_words.append(new)\\n        for w1, w2 in zip(new_words, new_words[1:]):\\n            if w1 > w2:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149842,
                "title": "simple-solution-using-hashmap-w-explanation-o-n-o-1-beats-100",
                "content": "We need to create a mapping (let\\'s call it **`mp`**) of all alphabets to their index in *`order`*. This will help us determine if two words are lexicographically sorted efficiently. \\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Map Letters to Index & Check Adjacent Words)***\\n\\nIf a sequence of words is sorted, then **each adjacent word of the sequence must also be sorted**. In the given question, while comparing if two words are sorted, we just need to compare `mp[letter1]` and `mp[letter2]`  (instead of direct `letter1` and `letter2` that we would have done if it was normal english alphabetical ordering). Now, while checking if string `a`, `b` are lexicographically sorted, they are -\\n\\n&emsp;&emsp;\\uD83D\\uDC49 **Lexicographically Sorted** when -\\n&emsp;&emsp;&emsp;&emsp;\\u2726 If at first mismatch, `mp[a[i]] < mp[b[i]]`, or\\n&emsp;&emsp;&emsp;&emsp;\\u2726 If each letters of both words match and `length(a) <= length(b)`\\n\\n\\n&emsp;&emsp;\\uD83D\\uDC49 **Not Lexicographically Sorted** when -\\n&emsp;&emsp;&emsp;&emsp;\\u2726 If at first mismatch, `mp[a[i]] > mp[b[i]]`, or\\n&emsp;&emsp;&emsp;&emsp;\\u2726  If each letters of both words match and `length(a) > length(b)`.\\n\\nWith this, we can proceed to check if each adjacent words are lexicographically sorted and return true if all are found to be sorted.\\n\\n---\\n\\n**C++**\\n```\\nunordered_map<char, int> mp;\\nbool isAlienSorted(vector<string>& words, string order) {        \\n\\tfor(int i = 0; i < size(order); i++) mp[order[i]] = i;  // mapping letter to its corresponding index in order\\n\\tfor(int i = 0; i < size(words) - 1; i++)\\n\\t\\tif(!checkOrder(words[i], words[i + 1])) return false;\\n\\treturn true;        \\n}    \\n// checking if two words are lexicographically sorted\\nbool checkOrder(string& a, string& b){\\n\\tint i = -1;\\n\\twhile(++i < size(a) && i < size(b))\\n\\t\\tif(mp[a[i]] != mp[b[i]]) return mp[a[i]] < mp[b[i]];\\n\\treturn size(a) <= size(b);\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef isAlienSorted(self, words: List[str], order: str) -> bool:\\n\\tdef checkOrder(A, B):            \\n\\t\\tfor ai, bi in zip(A, B) :\\n\\t\\t\\tif mp[ai] != mp[bi] :\\n\\t\\t\\t\\treturn mp[ai] < mp[bi]\\n\\t\\treturn len(A) <= len(B)\\n\\tmp = {c : idx for idx,c in enumerate(order)}\\n\\treturn all(checkOrder(word1, word2) for word1, word2 in zip(words, words[1:]))\\n```\\n\\n---\\n\\n***Time Complexity :*** `O(N)`, where `N` is the total number of characters in `words`.\\n***Space Complexity :*** `O(1)`, we only need constant amount of space to store the mapping of letters to index which does not depend on the size of input. Hence we get constant space complexity.\\n\\n---\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Mapping Letters in Alien Order to English Order)***\\n\\nWe can also map the letters in `order` to equivalent words considering normal English ordering, transform word and then check if they are sorted as we normally would. For eg.\\n\\n```\\norder = \"hlabcdefgijkmnopqrstuvwxyz\" gets mapped to \"abcdefghijklmnopqrstuvwxyz\".\\nSo for eg, The word \"hello\" is transformed to \"agbbo\"\\n           The word \"leetcode\" is transformed to \"bggteofg\"\\n```\\n\\n\\nIn C++, there\\'s a inbuilt method `is_sorted` to check if elements in a range are sorted which I have used in the implementation below. It functions similar to the `checkOrder` function in the first solution but we can use it here since we have mapped alien language to english language -\\n\\n---\\n\\n**C++**\\n\\n\\n```\\nunordered_map<char, char> mp;\\nbool isAlienSorted(vector<string>& words, string order) {        \\n\\t// Infact, we can do without the + \\'a\\' below as well. It just won\\'t map to English but rather to characters having ascii 0,1,2...\\n\\tfor(int i = 0; i < size(order); i++) mp[order[i]] = i + \\'a\\';  \\n\\tfor(auto& word : words)\\n\\t\\tfor(auto& c : word) c = mp[c];\\n\\treturn is_sorted(begin(words), end(words));\\n} \\n```\\n\\n---\\n\\n**Python**\\n```\\ndef isAlienSorted(self, words: List[str], order: str) -> bool:\\n\\tmp = {c : i for i, c in enumerate(order)}        \\n\\twords = [[mp[c] for c in word] for word in words]\\n\\treturn all(word1 <= word2 for word1, word2 in zip(words, words[1:]))\\n```\\n\\nThe Time & Space complexity are same as in the first solution. But the runtime might be slightly worse since this solution involves extra operation of transforming words which we didn\\'t require in the first solution. Just mentioned this solution as another possible approach to solve this question.\\n\\n---\\n\\n*Best Runtime Results :*\\n\\n<span>&emsp;&emsp;&emsp;&emsp;<img src=https://assets.leetcode.com/users/images/16231ace-16e3-405c-bb23-97edbd8572f6_1617967706.3983092.png /></span>\\n\\n\\n---\\n---\\n\\n\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nunordered_map<char, int> mp;\\nbool isAlienSorted(vector<string>& words, string order) {        \\n\\tfor(int i = 0; i < size(order); i++) mp[order[i]] = i;  // mapping letter to its corresponding index in order\\n\\tfor(int i = 0; i < size(words) - 1; i++)\\n\\t\\tif(!checkOrder(words[i], words[i + 1])) return false;\\n\\treturn true;        \\n}    \\n// checking if two words are lexicographically sorted\\nbool checkOrder(string& a, string& b){\\n\\tint i = -1;\\n\\twhile(++i < size(a) && i < size(b))\\n\\t\\tif(mp[a[i]] != mp[b[i]]) return mp[a[i]] < mp[b[i]];\\n\\treturn size(a) <= size(b);\\n}\\n```\n```\\ndef isAlienSorted(self, words: List[str], order: str) -> bool:\\n\\tdef checkOrder(A, B):            \\n\\t\\tfor ai, bi in zip(A, B) :\\n\\t\\t\\tif mp[ai] != mp[bi] :\\n\\t\\t\\t\\treturn mp[ai] < mp[bi]\\n\\t\\treturn len(A) <= len(B)\\n\\tmp = {c : idx for idx,c in enumerate(order)}\\n\\treturn all(checkOrder(word1, word2) for word1, word2 in zip(words, words[1:]))\\n```\n```\\norder = \"hlabcdefgijkmnopqrstuvwxyz\" gets mapped to \"abcdefghijklmnopqrstuvwxyz\".\\nSo for eg, The word \"hello\" is transformed to \"agbbo\"\\n           The word \"leetcode\" is transformed to \"bggteofg\"\\n```\n```\\nunordered_map<char, char> mp;\\nbool isAlienSorted(vector<string>& words, string order) {        \\n\\t// Infact, we can do without the + \\'a\\' below as well. It just won\\'t map to English but rather to characters having ascii 0,1,2...\\n\\tfor(int i = 0; i < size(order); i++) mp[order[i]] = i + \\'a\\';  \\n\\tfor(auto& word : words)\\n\\t\\tfor(auto& c : word) c = mp[c];\\n\\treturn is_sorted(begin(words), end(words));\\n} \\n```\n```\\ndef isAlienSorted(self, words: List[str], order: str) -> bool:\\n\\tmp = {c : i for i, c in enumerate(order)}        \\n\\twords = [[mp[c] for c in word] for word in words]\\n\\treturn all(word1 <= word2 for word1, word2 in zip(words, words[1:]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 390005,
                "title": "java-solution-with-hashmap",
                "content": "```\\nclass Solution {\\n    Map<Character, Integer> map;\\n    public boolean isAlienSorted(String[] words, String order) {\\n        map = new HashMap<>();\\n        for (int i = 0; i < order.length(); i++) {\\n            map.put(order.charAt(i), i);\\n        }\\n        for (int i = 0; i < words.length - 1; i++) {\\n            if (!compare(words[i], words[i + 1])) return false;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean compare(String s1, String s2) {\\n        int l1 = s1.length(), l2 = s2.length();\\n        for (int i = 0, j = 0; i < l1 && j < l2; i++, j++) {\\n            if (s1.charAt(i) != s2.charAt(j)) {\\n                if (map.get(s1.charAt(i)) > map.get(s2.charAt(j))) {\\n                    return false;\\n                } else {\\n                    return true;\\n                }\\n            }\\n        }\\n        if (l1 > l2) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<Character, Integer> map;\\n    public boolean isAlienSorted(String[] words, String order) {\\n        map = new HashMap<>();\\n        for (int i = 0; i < order.length(); i++) {\\n            map.put(order.charAt(i), i);\\n        }\\n        for (int i = 0; i < words.length - 1; i++) {\\n            if (!compare(words[i], words[i + 1])) return false;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean compare(String s1, String s2) {\\n        int l1 = s1.length(), l2 = s2.length();\\n        for (int i = 0, j = 0; i < l1 && j < l2; i++, j++) {\\n            if (s1.charAt(i) != s2.charAt(j)) {\\n                if (map.get(s1.charAt(i)) > map.get(s2.charAt(j))) {\\n                    return false;\\n                } else {\\n                    return true;\\n                }\\n            }\\n        }\\n        if (l1 > l2) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129155,
                "title": "easy-solution-java-beginner-level-fully-explained",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize a HashMap \"order\" to store the order of characters in the alien language. This is done by looping through the string \"O\" and storing each character and its corresponding index in the HashMap.\\n\\nLoop through the array of words \"W\", comparing adjacent words. For each pair of words, loop through their characters.\\n\\nCompare the current characters in both words. If the order of the characters is incorrect according to the order stored in the HashMap \"order\", return false.\\n\\nIf the current characters are in the correct order, move on to the next character in both words.\\n\\nIf all characters in the first word have been compared, and the second word is not yet finished, return false as the second word is longer and therefore not sorted.\\n\\nIf the loop has gone through all words without returning false, return true, indicating that the words are sorted lexicographically in the alien language.\\n\\n**Video Explanation**\\n\\n**In English**\\n\\nhttps://youtu.be/1M51oB5G_2w\\n\\n\\n**In Hindi**\\nhttps://youtu.be/GifiTlOVeqc\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isAlienSorted(String[] W, String O) {\\n        Map<Character,Integer> order = new HashMap<>();\\n        for (int i = 0; i < O.length(); i++)\\n            order.put(O.charAt(i), i);\\n        for (int i = 1; i < W.length; i++) {\\n            String a = W[i-1];\\n            String b = W[i];\\n            for (int j = 0; j < a.length(); j++) {\\n                if (j == b.length()){\\n                    return false;\\n                }\\n                char cha = a.charAt(j);\\n                char chb = b.charAt(j);\\n                if (order.get(cha) < order.get(chb)){\\n                    break;\\n                }\\n                if (order.get(cha) > order.get(chb)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n![Screenshot 2023-01-28 at 11.15.43 AM.png](https://assets.leetcode.com/users/images/66a778cd-0b7f-4588-9507-26b160e7e340_1675297368.7771292.png)\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAlienSorted(String[] W, String O) {\\n        Map<Character,Integer> order = new HashMap<>();\\n        for (int i = 0; i < O.length(); i++)\\n            order.put(O.charAt(i), i);\\n        for (int i = 1; i < W.length; i++) {\\n            String a = W[i-1];\\n            String b = W[i];\\n            for (int j = 0; j < a.length(); j++) {\\n                if (j == b.length()){\\n                    return false;\\n                }\\n                char cha = a.charAt(j);\\n                char chb = b.charAt(j);\\n                if (order.get(cha) < order.get(chb)){\\n                    break;\\n                }\\n                if (order.get(cha) > order.get(chb)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149977,
                "title": "c-super-easy-and-short-straight-forward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool compare(string& a, string& b, string& order) {\\n        int i = 0;\\n        while (i < a.size() && a[i] == b[i]) i++;\\n        if (a.size() == i) return true;\\n        else if (b.size() == i) return false;\\n        return (order.find(a[i]) < order.find(b[i]));\\n    }\\n    \\n    bool isAlienSorted(vector<string>& words, string order) {\\n        for (int i = 0; i < words.size()-1; i++) {\\n            if (!compare(words[i], words[i+1], order)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool compare(string& a, string& b, string& order) {\\n        int i = 0;\\n        while (i < a.size() && a[i] == b[i]) i++;\\n        if (a.size() == i) return true;\\n        else if (b.size() == i) return false;\\n        return (order.find(a[i]) < order.find(b[i]));\\n    }\\n    \\n    bool isAlienSorted(vector<string>& words, string order) {\\n        for (int i = 0; i < words.size()-1; i++) {\\n            if (!compare(words[i], words[i+1], order)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203246,
                "title": "java-python-3-clean-codes-w-comment-time-o-mn-space-o-order-length",
                "content": "Compare adjacent words char by char according to the given order.\\n Loop through the `words`, if the char of previous word  `.vs.` that of current word:\\n1. less than; \\nno need to compare the following chars, continue to check next two adjacet words;\\n2. greater than; \\nreturn `false`\\n3. if current word is the prefix of and shorter than previous word; \\nreturn `false` \\n4. if never encounter `false` during loop, return `true`.\\n\\n**Analysis:**\\nOuter loop iterates `m (= words.length)` times, and inner loop runs `n (= A[0].length())` times;\\n`map` cost O(1) space.\\n\\nTherefore, **Time: O(`mn`), space: O(`order.length`).**\\n \\n```java\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int[] map = new int[26];\\n        for (int i = 0; i < 26; ++i) { // construct mapping to the given order.\\n              map[order.charAt(i) - \\'a\\'] = i; \\n        } \\n        outer:\\n        for (int i = 1; i < words.length; ++i) { // Verify the adjacent words order.\\n            for (int j = 0; j < words[i - 1].length() && j < words[i].length(); ++j) { // compare the 2 words char by char.\\n                int pre = words[i - 1].charAt(j) - \\'a\\', cur = words[i].charAt(j) - \\'a\\'; // corresponding indexes in mapping array `map`.\\n                if (map[pre] > map[cur]) { // if their relation is NOT compliant with `order`, false.\\n                    return false; \\n                }else if (map[pre] < map[cur]) { // if current char > previous char, no need to check following chars.\\n                    continue outer; \\n                } \\n            } // NOTE: only when 1 word is the prefix of the other, can the code excute the following if clause.\\n            if (words[i - 1].length() > words[i].length()) { //  current word must NOT be the prefix of and shorter than previous word.\\n                return false;\\n            } \\n        }\\n        return true;\\n    }\\n```\\n\\nThe above code can be converted to the following more readable form: decouplling the `compare` logic from the original method. Credit to @tpalmer1243.\\n\\n```\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int[] map = new int[26];\\n        for (int i = 0; i < 26; ++i) { // construct mapping to the give order.\\n            map[order.charAt(i) - \\'a\\'] = i; \\n        } \\n        for (int i = 1; i < words.length; ++i) { // Verify the ajacent words order. \\n            if (compare(words[i - 1], words[i], map) > 0) { \\n                return false; \\n            } \\n        }\\n        return true;\\n    }\\n    private int compare(String s, String t, int[] map) { // compare the 2 words char by char.\\n        int m = s.length(), n = t.length();\\n        for (int i = 0; i < m && i < n; ++i) {\\n            int cmp = map[s.charAt(i) - \\'a\\'] - map[t.charAt(i) - \\'a\\']; // compare according to the given order.\\n            if (cmp != 0) { // if not equal, return the comparison result.\\n                return cmp; \\n            } \\n        }\\n        return m - n; // when one word is the prefix of the other, compare their sizes.\\n    }\\n```\\n```python\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        \\n        def compare(u: str, v: str) -> bool:\\n            for c, d in zip(u, v):\\n                if c != d:\\n                    return dic[c] < dic[d]\\n            return len(u) <= len(v)\\n        \\n        dic = {c : i for i, c in enumerate(order)}\\n        return all(compare(u, v) for u, v in itertools.pairwise(words))\\n```",
                "solutionTags": [],
                "code": "```java\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int[] map = new int[26];\\n        for (int i = 0; i < 26; ++i) { // construct mapping to the given order.\\n              map[order.charAt(i) - \\'a\\'] = i; \\n        } \\n        outer:\\n        for (int i = 1; i < words.length; ++i) { // Verify the adjacent words order.\\n            for (int j = 0; j < words[i - 1].length() && j < words[i].length(); ++j) { // compare the 2 words char by char.\\n                int pre = words[i - 1].charAt(j) - \\'a\\', cur = words[i].charAt(j) - \\'a\\'; // corresponding indexes in mapping array `map`.\\n                if (map[pre] > map[cur]) { // if their relation is NOT compliant with `order`, false.\\n                    return false; \\n                }else if (map[pre] < map[cur]) { // if current char > previous char, no need to check following chars.\\n                    continue outer; \\n                } \\n            } // NOTE: only when 1 word is the prefix of the other, can the code excute the following if clause.\\n            if (words[i - 1].length() > words[i].length()) { //  current word must NOT be the prefix of and shorter than previous word.\\n                return false;\\n            } \\n        }\\n        return true;\\n    }\\n```\n```\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int[] map = new int[26];\\n        for (int i = 0; i < 26; ++i) { // construct mapping to the give order.\\n            map[order.charAt(i) - \\'a\\'] = i; \\n        } \\n        for (int i = 1; i < words.length; ++i) { // Verify the ajacent words order. \\n            if (compare(words[i - 1], words[i], map) > 0) { \\n                return false; \\n            } \\n        }\\n        return true;\\n    }\\n    private int compare(String s, String t, int[] map) { // compare the 2 words char by char.\\n        int m = s.length(), n = t.length();\\n        for (int i = 0; i < m && i < n; ++i) {\\n            int cmp = map[s.charAt(i) - \\'a\\'] - map[t.charAt(i) - \\'a\\']; // compare according to the given order.\\n            if (cmp != 0) { // if not equal, return the comparison result.\\n                return cmp; \\n            } \\n        }\\n        return m - n; // when one word is the prefix of the other, compare their sizes.\\n    }\\n```\n```python\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        \\n        def compare(u: str, v: str) -> bool:\\n            for c, d in zip(u, v):\\n                if c != d:\\n                    return dic[c] < dic[d]\\n            return len(u) <= len(v)\\n        \\n        dic = {c : i for i, c in enumerate(order)}\\n        return all(compare(u, v) for u, v in itertools.pairwise(words))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1149916,
                "title": "python-short-solution-explained",
                "content": "If you solved problem **Alien Dictionary** already, this one will be just copy paste. However if you not, it is still very simple. The idea is to look at pairs of adjacent words and look for first different symbol, for example `hello` and `help` means, that `o` shold go before `p`. Also we need to deal with cases like `hello` and `hell`, where the first one never can go before the second, so we return `False` in this case.\\n\\n#### Complexity\\nIt is just `O(m)`, where `m` is the total length of all words in `words`.\\n\\n#### Code\\n```\\nclass Solution:\\n    def isAlienSorted(self, words, order):\\n        ord_d = {l:i for i, l in enumerate(order)}\\n         \\n        for w1, w2 in zip(words, words[1:]):\\n            for i, j in zip(w1, w2):\\n                if i != j:\\n                    if ord_d[i] > ord_d[j]: return False\\n                    break\\n            if w1.startswith(w2) and w1 != w2: return False\\n            \\n        return True\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words, order):\\n        ord_d = {l:i for i, l in enumerate(order)}\\n         \\n        for w1, w2 in zip(words, words[1:]):\\n            for i, j in zip(w1, w2):\\n                if i != j:\\n                    if ord_d[i] > ord_d[j]: return False\\n                    break\\n            if w1.startswith(w2) and w1 != w2: return False\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860949,
                "title": "simple-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        for (int i = 0; i < words.size() - 1; i++) {\\n        string word1 = words[i];\\n        string word2 = words[i + 1];\\n        int i1 = 0, i2 = 0;\\n        while (word1[i1] == word2[i2]) {\\n            i1++, i2++;\\n        }\\n        int r = order.find(word1[i1]);   \\n        int s = order.find(word2[i2]);\\n        if (r > s) return false;\\n    }\\n    return true;\\n    }\\n};\\n```\\n\\n**Using map--**\\n```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<order.size();i++) mp[order[i]]=i;\\n        for (int i = 0; i < words.size() - 1; i++) {\\n        string word1 = words[i];\\n        string word2 = words[i + 1];\\n        int i1 = 0, i2 = 0;\\n        while (i1<word1.size()&&i2<word2.size()&&word1[i1] == word2[i2]) {\\n            i1++, i2++;\\n        }\\n        if(i2==word2.size()&&i1<word1.size()) return false;\\n        if(i1<word1.size()&&i2<word2.size())\\n        {\\n            if(mp[word1[i1]]>mp[word2[i2]]) return false;\\n        }\\n    }\\n    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        for (int i = 0; i < words.size() - 1; i++) {\\n        string word1 = words[i];\\n        string word2 = words[i + 1];\\n        int i1 = 0, i2 = 0;\\n        while (word1[i1] == word2[i2]) {\\n            i1++, i2++;\\n        }\\n        int r = order.find(word1[i1]);   \\n        int s = order.find(word2[i2]);\\n        if (r > s) return false;\\n    }\\n    return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<order.size();i++) mp[order[i]]=i;\\n        for (int i = 0; i < words.size() - 1; i++) {\\n        string word1 = words[i];\\n        string word2 = words[i + 1];\\n        int i1 = 0, i2 = 0;\\n        while (i1<word1.size()&&i2<word2.size()&&word1[i1] == word2[i2]) {\\n            i1++, i2++;\\n        }\\n        if(i2==word2.size()&&i1<word1.size()) return false;\\n        if(i1<word1.size()&&i2<word2.size())\\n        {\\n            if(mp[word1[i1]]>mp[word2[i2]]) return false;\\n        }\\n    }\\n    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801754,
                "title": "python-one-liner-just-sort-the-list-according-the-custom-alphabet",
                "content": "See the following code\\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        return words == sorted(words,key=lambda word:[order.index(c) for c in word])\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        return words == sorted(words,key=lambda word:[order.index(c) for c in word])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129154,
                "title": "c-solution-convert-word-into-normal-order",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        unordered_map<char,char> map;\\n        \\n        for(int i=0;i<26;i++){\\n            map[order[i]]= (\\'a\\'+i);\\n        }\\n        \\n        for(int i=0;i<words.size();i++){\\n            for(int j=0;j<words[i].size();j++){\\n                words[i][j]= map[words[i][j]];\\n            }\\n        }\\n        \\n        return is_sorted(words.begin(),words.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        unordered_map<char,char> map;\\n        \\n        for(int i=0;i<26;i++){\\n            map[order[i]]= (\\'a\\'+i);\\n        }\\n        \\n        for(int i=0;i<words.size();i++){\\n            for(int j=0;j<words[i].size();j++){\\n                words[i][j]= map[words[i][j]];\\n            }\\n        }\\n        \\n        return is_sorted(words.begin(),words.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149850,
                "title": "js-python-java-c-easy-map-lookup-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe naive approach here would be to iterate through pairs of consecutive words in our input array (**W**) and compare the position of each letter in the input alphabet (**O**), moving letter by letter until we find a discrepancy and can determine which word comes first lexicographically.\\n\\nAs this is an Easy question, this method works, but with a **time complexity** of **O(N * M * P)** where **N** is the length of **W**, **M** is the average length of each word in **W**, and **P** is the length of **O**.\\n\\nRather than repetitively finding the position of a character in **O**, however, we can create a lookup table of indexes from **O** (**alpha**) at a time complexity of **O(P)** and turn every position lookup into a simple **O(1)** operation. That changes the overall time complexity to **O(N * M + P)**.\\n\\nThen, as noted before, we can just iterate through word pairs (**a, b**) in **W**, then iterate through comparative characters (**achar, bchar**) in those two words and evaluate them based on their lexicographical indexes (**aix, bix**).\\n\\nIf **aix < bix** or if we reach the end of **a**, then the two words are in correct lexicographical order and we should move to the next pair of words. If **aix > bix** or if we reach the end of **b**, the two words are *not* in correct lexicographical order and we should **return false**.\\n\\nIf we reach the end without exiting, we should **return true**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences in the code for all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar isAlienSorted = function(W, O) {\\n    let alpha = new Map([[\"\",-1]])\\n    for (let i = 0; i < O.length; i++)\\n        alpha.set(O.charAt(i), i)\\n    for (let i = 1; i < W.length; i++) {\\n        let a = W[i-1], b = W[i]\\n        for (let j = 0; j < a.length; j++) {\\n            let achar = a.charAt(j), bchar = b.charAt(j),\\n                aix = alpha.get(achar), bix = alpha.get(bchar)\\n            if (aix < bix) break\\n            if (aix > bix) return false\\n        }\\n    }\\n    return true\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def isAlienSorted(self, W: List[str], O: str) -> bool:\\n        alpha = {O[i]: i for i in range(len(O))}\\n        for i in range(1,len(W)):\\n            a, b = W[i-1], W[i]\\n            for j in range(len(a)):\\n                if j == len(b): return False\\n                achar, bchar = a[j], b[j]\\n                aix, bix = alpha[achar], alpha[bchar]\\n                if aix < bix: break\\n                if aix > bix: return False\\n        return True\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public boolean isAlienSorted(String[] W, String O) {\\n        Map<Character,Integer> alpha = new HashMap<>();\\n        for (int i = 0; i < O.length(); i++)\\n            alpha.put(O.charAt(i), i);\\n        for (int i = 1; i < W.length; i++) {\\n            String a = W[i-1], b = W[i];\\n            for (int j = 0; j < a.length(); j++) {\\n                if (j == b.length()) return false;\\n                char achar = a.charAt(j), bchar = b.charAt(j);\\n                if (alpha.get(achar) < alpha.get(bchar)) break;\\n                if (alpha.get(achar) > alpha.get(bchar)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& W, string O) {\\n        unordered_map<char,int> alpha;\\n        for (int i = 0; i < O.size(); i++)\\n            alpha[O[i]] = i;\\n        for (int i = 1; i < W.size(); i++) {\\n            string a = W[i-1], b = W[i];\\n            for (int j = 0; j < a.size(); j++) {\\n                if (j == b.size()) return false;\\n                char achar = a[j], bchar = b[j];\\n                if (alpha[achar] < alpha[bchar]) break;\\n                if (alpha[achar] > alpha[bchar]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar isAlienSorted = function(W, O) {\\n    let alpha = new Map([[\"\",-1]])\\n    for (let i = 0; i < O.length; i++)\\n        alpha.set(O.charAt(i), i)\\n    for (let i = 1; i < W.length; i++) {\\n        let a = W[i-1], b = W[i]\\n        for (let j = 0; j < a.length; j++) {\\n            let achar = a.charAt(j), bchar = b.charAt(j),\\n                aix = alpha.get(achar), bix = alpha.get(bchar)\\n            if (aix < bix) break\\n            if (aix > bix) return false\\n        }\\n    }\\n    return true\\n};\\n```\n```python\\nclass Solution:\\n    def isAlienSorted(self, W: List[str], O: str) -> bool:\\n        alpha = {O[i]: i for i in range(len(O))}\\n        for i in range(1,len(W)):\\n            a, b = W[i-1], W[i]\\n            for j in range(len(a)):\\n                if j == len(b): return False\\n                achar, bchar = a[j], b[j]\\n                aix, bix = alpha[achar], alpha[bchar]\\n                if aix < bix: break\\n                if aix > bix: return False\\n        return True\\n```\n```java\\nclass Solution {\\n    public boolean isAlienSorted(String[] W, String O) {\\n        Map<Character,Integer> alpha = new HashMap<>();\\n        for (int i = 0; i < O.length(); i++)\\n            alpha.put(O.charAt(i), i);\\n        for (int i = 1; i < W.length; i++) {\\n            String a = W[i-1], b = W[i];\\n            for (int j = 0; j < a.length(); j++) {\\n                if (j == b.length()) return false;\\n                char achar = a.charAt(j), bchar = b.charAt(j);\\n                if (alpha.get(achar) < alpha.get(bchar)) break;\\n                if (alpha.get(achar) > alpha.get(bchar)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& W, string O) {\\n        unordered_map<char,int> alpha;\\n        for (int i = 0; i < O.size(); i++)\\n            alpha[O[i]] = i;\\n        for (int i = 1; i < W.size(); i++) {\\n            string a = W[i-1], b = W[i];\\n            for (int j = 0; j < a.size(); j++) {\\n                if (j == b.size()) return false;\\n                char achar = a[j], bchar = b[j];\\n                if (alpha[achar] < alpha[bchar]) break;\\n                if (alpha[achar] > alpha[bchar]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208282,
                "title": "beat-99-37-c-solution",
                "content": "```\\n    bool isAlienSorted(vector<string> &words, string order) {\\n        size_t indices[26]{};\\n        for (size_t i = 0; i < order.size(); ++i) {\\n            indices[order[i] - \\'a\\'] = i;\\n        }\\n        return is_sorted(words.begin(), words.end(), [&indices](\\n                const string &w1,\\n                const string &w2\\n        ) {\\n            auto l1 = w1.size(), l2 = w2.size();\\n            for (auto i = 0; i < min(l1, l2); ++i) {\\n                auto c1 = w1[i], c2 = w2[i];\\n                if (c1 != c2) {\\n                    return indices[c1 - \\'a\\'] < indices[c2 - \\'a\\'];\\n                }\\n            }\\n            return l1 < l2;\\n        });\\n    }",
                "solutionTags": [],
                "code": "```\\n    bool isAlienSorted(vector<string> &words, string order) {\\n        size_t indices[26]{};\\n        for (size_t i = 0; i < order.size(); ++i) {\\n            indices[order[i] - \\'a\\'] = i;\\n        }\\n        return is_sorted(words.begin(), words.end(), [&indices](\\n                const string &w1,\\n                const string &w2\\n        ) {\\n            auto l1 = w1.size(), l2 = w2.size();\\n            for (auto i = 0; i < min(l1, l2); ++i) {\\n                auto c1 = w1[i], c2 = w2[i];\\n                if (c1 != c2) {\\n                    return indices[c1 - \\'a\\'] < indices[c2 - \\'a\\'];\\n                }\\n            }\\n            return l1 < l2;\\n        });\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 456673,
                "title": "python-easy-understand-solution-beat-91-time-and-100-space",
                "content": "```\\ndef isAlienSorted(self, words: List[str], order: str) -> bool:\\n        dict = {}\\n        for i, o in enumerate(order):\\n            dict[o] = i\\n\\t\\t\\t\\n        for i in range(1,len(words)):\\n            #flag = 1 here means inner loop is break out due to pre less than cur\\n\\t\\t\\t#flag = 0 here means inner loop done iteration but two strings length are not equal\\n            pre, cur, flag = words[i-1], words[i], 0\\n            for j in range(min(len(pre),len(cur))):\\n                if dict[pre[j]] < dict[cur[j]]:\\n                    flag = 1\\n                    break\\n                elif dict[pre[j]] > dict[cur[j]]:\\n                    return False\\n            if not flag and len(pre) > len(cur): \\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isAlienSorted(self, words: List[str], order: str) -> bool:\\n        dict = {}\\n        for i, o in enumerate(order):\\n            dict[o] = i\\n\\t\\t\\t\\n        for i in range(1,len(words)):\\n            #flag = 1 here means inner loop is break out due to pre less than cur\\n\\t\\t\\t#flag = 0 here means inner loop done iteration but two strings length are not equal\\n            pre, cur, flag = words[i-1], words[i], 0\\n            for j in range(min(len(pre),len(cur))):\\n                if dict[pre[j]] < dict[cur[j]]:\\n                    flag = 1\\n                    break\\n                elif dict[pre[j]] > dict[cur[j]]:\\n                    return False\\n            if not flag and len(pre) > len(cur): \\n                return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3129584,
                "title": "clean-codes-full-explanation-hashtable-c-java-python",
                "content": "\\n# Approach :\\n- The naive approach here would be to iterate through pairs of consecutive words in our input array (W) and compare the position of each letter in the input alphabet (O), moving letter by letter until we find a discrepancy and can determine which word comes first lexicographically.\\n\\n- As this is an Easy question, this method works, but with a time complexity of O(N * M * P) where N is the length of W, M is the average length of each word in W, and P is the length of O.\\n- Rather than repetitively finding the position of a character in O, however, we can create a lookup table of indexes from O (alpha) at a time complexity of O(P) and turn every position lookup into a simple O(1) operation. That changes the overall time complexity to O(N * M + P).\\n- Then, as noted before, we can just iterate through word pairs (a, b) in W, then iterate through comparative characters (achar, bchar) in those two words and evaluate them based on their lexicographical indexes (aix, bix).\\n- If aix < bix or if we reach the end of a, then the two words are in correct lexicographical order and we should move to the next pair of words. If aix > bix or if we reach the end of b, the two words are not in correct lexicographical order and we should return false.\\n- If we reach the end without exiting, we should return true.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N * M + P).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n\\n# Codes [C++ | Java | Python] :\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& W, string O) {\\n        unordered_map<char,int> alpha;\\n        for (int i = 0; i < O.size(); i++)\\n            alpha[O[i]] = i;\\n        for (int i = 1; i < W.size(); i++) {\\n            string a = W[i-1], b = W[i];\\n            for (int j = 0; j < a.size(); j++) {\\n                if (j == b.size()) return false;\\n                char achar = a[j], bchar = b[j];\\n                if (alpha[achar] < alpha[bchar]) break;\\n                if (alpha[achar] > alpha[bchar]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isAlienSorted(String[] W, String O) {\\n        Map<Character,Integer> alpha = new HashMap<>();\\n        for (int i = 0; i < O.length(); i++)\\n            alpha.put(O.charAt(i), i);\\n        for (int i = 1; i < W.length; i++) {\\n            String a = W[i-1], b = W[i];\\n            for (int j = 0; j < a.length(); j++) {\\n                if (j == b.length()) return false;\\n                char achar = a.charAt(j), bchar = b.charAt(j);\\n                if (alpha.get(achar) < alpha.get(bchar)) break;\\n                if (alpha.get(achar) > alpha.get(bchar)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def isAlienSorted(self, W: List[str], O: str) -> bool:\\n        alpha = {O[i]: i for i in range(len(O))}\\n        for i in range(1,len(W)):\\n            a, b = W[i-1], W[i]\\n            for j in range(len(a)):\\n                if j == len(b): return False\\n                achar, bchar = a[j], b[j]\\n                aix, bix = alpha[achar], alpha[bchar]\\n                if aix < bix: break\\n                if aix > bix: return False\\n        return True\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/b6343c8c-6e49-4b0a-8622-d83febd84965_1675309626.5834215.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& W, string O) {\\n        unordered_map<char,int> alpha;\\n        for (int i = 0; i < O.size(); i++)\\n            alpha[O[i]] = i;\\n        for (int i = 1; i < W.size(); i++) {\\n            string a = W[i-1], b = W[i];\\n            for (int j = 0; j < a.size(); j++) {\\n                if (j == b.size()) return false;\\n                char achar = a[j], bchar = b[j];\\n                if (alpha[achar] < alpha[bchar]) break;\\n                if (alpha[achar] > alpha[bchar]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isAlienSorted(String[] W, String O) {\\n        Map<Character,Integer> alpha = new HashMap<>();\\n        for (int i = 0; i < O.length(); i++)\\n            alpha.put(O.charAt(i), i);\\n        for (int i = 1; i < W.length; i++) {\\n            String a = W[i-1], b = W[i];\\n            for (int j = 0; j < a.length(); j++) {\\n                if (j == b.length()) return false;\\n                char achar = a.charAt(j), bchar = b.charAt(j);\\n                if (alpha.get(achar) < alpha.get(bchar)) break;\\n                if (alpha.get(achar) > alpha.get(bchar)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def isAlienSorted(self, W: List[str], O: str) -> bool:\\n        alpha = {O[i]: i for i in range(len(O))}\\n        for i in range(1,len(W)):\\n            a, b = W[i-1], W[i]\\n            for j in range(len(a)):\\n                if j == len(b): return False\\n                achar, bchar = a[j], b[j]\\n                aix, bix = alpha[achar], alpha[bchar]\\n                if aix < bix: break\\n                if aix > bix: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149836,
                "title": "verifying-an-alien-dictionary-short-easy-w-explanation",
                "content": "We need to create a mapping (let\\'s call it **`mp`**) of all alphabets to their index in *`order`*. This will help us determine if two words are lexicographically sorted efficiently. \\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Map Letters to Index & Check Adjacent Words)***\\n\\nIf a sequence of words is sorted, then **each adjacent word of the sequence must also be sorted**. In the given question, while comparing if two words are sorted, we just need to compare `mp[letter1]` and `mp[letter2]`  (instead of direct `letter1` and `letter2` that we would have done if it was normal english alphabetical ordering). Now, while checking if string `a`, `b` are lexicographically sorted, they are -\\n\\n&emsp;&emsp;\\uD83D\\uDC49 **Lexicographically Sorted** when -\\n&emsp;&emsp;&emsp;&emsp;\\u2726 If at first mismatch, `mp[a[i]] < mp[b[i]]`, or\\n&emsp;&emsp;&emsp;&emsp;\\u2726 If each letters of both words match and `length(a) <= length(b)`\\n\\n\\n&emsp;&emsp;\\uD83D\\uDC49 **Not Lexicographically Sorted** when -\\n&emsp;&emsp;&emsp;&emsp;\\u2726 If at first mismatch, `mp[a[i]] > mp[b[i]]`, or\\n&emsp;&emsp;&emsp;&emsp;\\u2726  If each letters of both words match and `length(a) > length(b)`.\\n\\nWith this, we can proceed to check if each adjacent words are lexicographically sorted and return true if all are found to be sorted.\\n\\n---\\n\\n**C++**\\n```\\nunordered_map<char, int> mp;\\nbool isAlienSorted(vector<string>& words, string order) {        \\n\\tfor(int i = 0; i < size(order); i++) mp[order[i]] = i;  // mapping letter to its corresponding index in order\\n\\tfor(int i = 0; i < size(words) - 1; i++)\\n\\t\\tif(!checkOrder(words[i], words[i + 1])) return false;\\n\\treturn true;        \\n}    \\n// checking if two words are lexicographically sorted\\nbool checkOrder(string& a, string& b){\\n\\tint i = -1;\\n\\twhile(++i < size(a) && i < size(b))\\n\\t\\tif(mp[a[i]] != mp[b[i]]) return mp[a[i]] < mp[b[i]];\\n\\treturn size(a) <= size(b);\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef isAlienSorted(self, words: List[str], order: str) -> bool:\\n\\tdef checkOrder(A, B):            \\n\\t\\tfor ai, bi in zip(A, B) :\\n\\t\\t\\tif mp[ai] != mp[bi] :\\n\\t\\t\\t\\treturn mp[ai] < mp[bi]\\n\\t\\treturn len(A) <= len(B)\\n\\tmp = {c : idx for idx,c in enumerate(order)}\\n\\treturn all(checkOrder(word1, word2) for word1, word2 in zip(words, words[1:]))\\n```\\n\\n---\\n\\n***Time Complexity :*** `O(N)`, where `N` is the total number of characters in `words`.\\n***Space Complexity :*** `O(1)`, we only need constant amount of space to store the mapping of letters to index which does not depend on the size of input. Hence we get constant space complexity.\\n\\n---\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Mapping Letters in Alien Order to English Order)***\\n\\nWe can also map the letters in `order` to equivalent words considering normal English ordering, transform word and then check if they are sorted as we normally would. For eg.\\n\\n```\\norder = \"hlabcdefgijkmnopqrstuvwxyz\" gets mapped to \"abcdefghijklmnopqrstuvwxyz\".\\nSo for eg, The word \"hello\" is transformed to \"agbbo\"\\n           The word \"leetcode\" is transformed to \"bggteofg\"\\n```\\n\\n\\nIn C++, there\\'s a inbuilt method `is_sorted` to check if elements in a range are sorted which I have used in the implementation below. It functions similar to the `checkOrder` function in the first solution but we can use it here since we have mapped alien language to english language -\\n\\n---\\n\\n**C++**\\n\\n\\n```\\nunordered_map<char, char> mp;\\nbool isAlienSorted(vector<string>& words, string order) {        \\n\\t// Infact, we can do without the + \\'a\\' below as well. It just won\\'t map to English but rather to characters having ascii 0,1,2...\\n\\tfor(int i = 0; i < size(order); i++) mp[order[i]] = i + \\'a\\';  \\n\\tfor(auto& word : words)\\n\\t\\tfor(auto& c : word) c = mp[c];\\n\\treturn is_sorted(begin(words), end(words));\\n} \\n```\\n\\n---\\n\\n**Python**\\n```\\ndef isAlienSorted(self, words: List[str], order: str) -> bool:\\n\\tmp = {c : i for i, c in enumerate(order)}        \\n\\twords = [[mp[c] for c in word] for word in words]\\n\\treturn all(word1 <= word2 for word1, word2 in zip(words, words[1:]))\\n```\\n\\nThe Time & Space complexity are same as in the first solution. But the runtime might be slightly worse since this solution involves extra operation of transforming words which we didn\\'t require in the first solution. Just mentioned this solution as another possible approach to solve this question.\\n\\n---\\n\\n*Best Runtime Results :*\\n\\n<span>&emsp;&emsp;&emsp;&emsp;<img src=https://assets.leetcode.com/users/images/16231ace-16e3-405c-bb23-97edbd8572f6_1617967706.3983092.png /></span>\\n\\n\\n---\\n---\\n\\n\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nunordered_map<char, int> mp;\\nbool isAlienSorted(vector<string>& words, string order) {        \\n\\tfor(int i = 0; i < size(order); i++) mp[order[i]] = i;  // mapping letter to its corresponding index in order\\n\\tfor(int i = 0; i < size(words) - 1; i++)\\n\\t\\tif(!checkOrder(words[i], words[i + 1])) return false;\\n\\treturn true;        \\n}    \\n// checking if two words are lexicographically sorted\\nbool checkOrder(string& a, string& b){\\n\\tint i = -1;\\n\\twhile(++i < size(a) && i < size(b))\\n\\t\\tif(mp[a[i]] != mp[b[i]]) return mp[a[i]] < mp[b[i]];\\n\\treturn size(a) <= size(b);\\n}\\n```\n```\\ndef isAlienSorted(self, words: List[str], order: str) -> bool:\\n\\tdef checkOrder(A, B):            \\n\\t\\tfor ai, bi in zip(A, B) :\\n\\t\\t\\tif mp[ai] != mp[bi] :\\n\\t\\t\\t\\treturn mp[ai] < mp[bi]\\n\\t\\treturn len(A) <= len(B)\\n\\tmp = {c : idx for idx,c in enumerate(order)}\\n\\treturn all(checkOrder(word1, word2) for word1, word2 in zip(words, words[1:]))\\n```\n```\\norder = \"hlabcdefgijkmnopqrstuvwxyz\" gets mapped to \"abcdefghijklmnopqrstuvwxyz\".\\nSo for eg, The word \"hello\" is transformed to \"agbbo\"\\n           The word \"leetcode\" is transformed to \"bggteofg\"\\n```\n```\\nunordered_map<char, char> mp;\\nbool isAlienSorted(vector<string>& words, string order) {        \\n\\t// Infact, we can do without the + \\'a\\' below as well. It just won\\'t map to English but rather to characters having ascii 0,1,2...\\n\\tfor(int i = 0; i < size(order); i++) mp[order[i]] = i + \\'a\\';  \\n\\tfor(auto& word : words)\\n\\t\\tfor(auto& c : word) c = mp[c];\\n\\treturn is_sorted(begin(words), end(words));\\n} \\n```\n```\\ndef isAlienSorted(self, words: List[str], order: str) -> bool:\\n\\tmp = {c : i for i, c in enumerate(order)}        \\n\\twords = [[mp[c] for c in word] for word in words]\\n\\treturn all(word1 <= word2 for word1, word2 in zip(words, words[1:]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 529305,
                "title": "concise-javascript-solution",
                "content": "**Strategy:** build a map using `order` which for each letter, holds its position in the alien alphabet (for constant lookup of position). Then using two pointers `prev` and `curr`, compare to ensure the letters in `curr` hold later positions in the alien alphabet.\\n**Some Special Cases:** If `prev` and `curr`\\'s have some of the same letters + order, loop to find the first !== character and then compare. *If one string contains the other, that is, if they are the same up to a point and then one ends, return false if the one that ends first occurs later.* **Ex.** \"hell\" should occur before \"hello\"\\n```\\nconst isAlienSorted = (words, order) => {\\n    let charPosition = new Map()\\n    for(let position = 0; position < order.length; position++){\\n        let char = order[position]\\n        charPosition.set(char, position)\\n    }\\n    for(let i = 1; i < words.length; i++){\\n        let prev = words[i-1], curr = words[i]\\n        if(charPosition.get(prev[0]) > charPosition.get(curr[0]))return false\\n        else if(prev[0] === curr[0]){\\n            let pointer = 1\\n            while(prev[pointer] === curr[pointer])pointer++\\n            if(curr[pointer] === undefined)return false\\n            if(charPosition.get(prev[pointer]) > charPosition.get(curr[pointer]))return false\\n        }\\n    }\\n    return true\\n};\\n```\\n**Note:**`while(prev[pointer] === curr[pointer])pointer++` will cause an infinite loop if prev === curr. Adding `&& pointer < Math.max(curr.length, prev.length)` would solve that",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isAlienSorted = (words, order) => {\\n    let charPosition = new Map()\\n    for(let position = 0; position < order.length; position++){\\n        let char = order[position]\\n        charPosition.set(char, position)\\n    }\\n    for(let i = 1; i < words.length; i++){\\n        let prev = words[i-1], curr = words[i]\\n        if(charPosition.get(prev[0]) > charPosition.get(curr[0]))return false\\n        else if(prev[0] === curr[0]){\\n            let pointer = 1\\n            while(prev[pointer] === curr[pointer])pointer++\\n            if(curr[pointer] === undefined)return false\\n            if(charPosition.get(prev[pointer]) > charPosition.get(curr[pointer]))return false\\n        }\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3129345,
                "title": "leetcode-the-hard-way-3-lines-explained",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=OL2EJaj_mJA&list=PLBu4Bche1aEU-8z7xl3-B9lfw_DJtT_xs&index=2) if you are interested.\\n\\n```py\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        # 1. create a dictionary to map each character in `order` to its index\\n        # {\\'h\\': 0, \\'l\\': 1, \\'a\\': 2, \\'b\\': 3, \\'c\\': 4, \\'d\\': 5, \\'e\\': 6, \\'f\\': 7, \\'g\\': 8, \\'i\\': 9, \\'j\\': 10, \\n        #  \\'k\\': 11, \\'m\\': 12, \\'n\\': 13, \\'o\\': 14, \\'p\\': 15, \\'q\\': 16, \\'r\\': 17, \\'s\\': 18, \\'t\\': 19, \\'u\\': 20, \\n        #  \\'v\\': 21, \\'w\\': 22, \\'x\\': 23, \\'y\\': 24, \\'z\\': 25}\\n        m = {c: i for i, c in enumerate(order)}\\n        # 2. create a list of lists of index for each word\\n        # [[0, 6, 1, 1, 14], [1, 6, 6, 19, 4, 14, 5, 6]]\\n        l = [[m[c] for c in w] for w in words]\\n        # 3. zip `l` and `l[1:]` to check if there is `x` > `y`, if so return False\\n        # list comparsion compares lexicographically by default\\n        return not any(x > y for (x, y) in zip(l, l[1:]))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        # 1. create a dictionary to map each character in `order` to its index\\n        # {\\'h\\': 0, \\'l\\': 1, \\'a\\': 2, \\'b\\': 3, \\'c\\': 4, \\'d\\': 5, \\'e\\': 6, \\'f\\': 7, \\'g\\': 8, \\'i\\': 9, \\'j\\': 10, \\n        #  \\'k\\': 11, \\'m\\': 12, \\'n\\': 13, \\'o\\': 14, \\'p\\': 15, \\'q\\': 16, \\'r\\': 17, \\'s\\': 18, \\'t\\': 19, \\'u\\': 20, \\n        #  \\'v\\': 21, \\'w\\': 22, \\'x\\': 23, \\'y\\': 24, \\'z\\': 25}\\n        m = {c: i for i, c in enumerate(order)}\\n        # 2. create a list of lists of index for each word\\n        # [[0, 6, 1, 1, 14], [1, 6, 6, 19, 4, 14, 5, 6]]\\n        l = [[m[c] for c in w] for w in words]\\n        # 3. zip `l` and `l[1:]` to check if there is `x` > `y`, if so return False\\n        # list comparsion compares lexicographically by default\\n        return not any(x > y for (x, y) in zip(l, l[1:]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129355,
                "title": "super-easy-solution-fully-explained-c-python3",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful\\n```\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst we are mapping each word of dictionary in a map with thier position.\\nThen we are checking if any word in the vector words is valid or not as\\n1. If all every letters in a word is at a lower position than the every letter in next word then it is valid otherwise not.\\n2. If all the letters in both words are same then if check if the current word length is smaller than or equal to the next word than it is valid. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Example \\n    words = [\"hello\",\"leetcode\"]\\n    order = \"hlabcdefgijkmnopqrstuvwxyz\"\\n    Here every letter in \"hello\" is at a lower position than every   letter in \"leetcode\". So it is valid.\\n\\n    Also [\"word\",\"world\",\"row\"]\\n    Here in \"word\" \\'d\\' comes after \\'l\\' in \"world\".\\n    So it is not valid.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    // Function to compare two words word1 and word2 using the character mapping in unordered_map mp\\n    bool check(unordered_map<char, int> mp, string word1, string word2){\\n        int i=0, j=0;\\n        // Compare character by character until one of the words runs out of characters\\n        while(i < word1.size() && j < word2.size()){\\n            // If word1 has a greater character, return false\\n            if(mp[word1[i]] > mp[word2[j]]) return false;\\n            // If word2 has a greater character, return true\\n            else if(mp[word1[i]] < mp[word2[j]]) return true;\\n            i++;\\n            j++;\\n        }\\n        // If word1 has run out of characters, return true (word1 is less than or equal to word2)\\n        // If word2 has run out of characters, return false (word1 is greater than word2)\\n        return (word1.size() <= word2.size());\\n    }\\n    // Main function to check if the list of words is sorted lexicographically according to the given order of characters\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        int pos=0;\\n        unordered_map<char, int> mp;\\n        // Create a mapping of characters to their positions in the given order\\n        for(char i : order){\\n            mp[i] = pos;\\n            pos++;\\n        }\\n        // Iterate over the list of words and compare each consecutive pair using the check function\\n        for(int i=0;i<words.size()-1;i++){\\n            if(!check(mp, words[i], words[i+1])) return false;\\n        }\\n        // If all pairs are in the correct order, return true\\n        return true;\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def check(self, mp, word1, word2):\\n        i, j = 0, 0\\n        # Compare character by character until one of the words runs out of characters\\n        while i < len(word1) and j < len(word2):\\n            # If word1 has a greater character, return False\\n            if mp[word1[i]] > mp[word2[j]]:\\n                return False\\n            # If word2 has a greater character, return True\\n            elif mp[word1[i]] < mp[word2[j]]:\\n                return True\\n            i += 1\\n            j += 1\\n        # If word1 has run out of characters, return True (word1 is less than or equal to word2)\\n        # If word2 has run out of characters, return False (word1 is greater than word2)\\n        return len(word1) <= len(word2)\\n        \\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        mp = {}\\n        # Create a mapping of characters to their positions in the given order\\n        for i, c in enumerate(order):\\n            mp[c] = i\\n        # Iterate over the list of words and compare each consecutive pair using the check function\\n        for i in range(len(words) - 1):\\n            if not self.check(mp, words[i], words[i + 1]):\\n                return False\\n        # If all pairs are in the correct order, return True\\n        return True\\n```\\n```\\n                        Give a \\uD83D\\uDC4D. It motivates me alot\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    // Function to compare two words word1 and word2 using the character mapping in unordered_map mp\\n    bool check(unordered_map<char, int> mp, string word1, string word2){\\n        int i=0, j=0;\\n        // Compare character by character until one of the words runs out of characters\\n        while(i < word1.size() && j < word2.size()){\\n            // If word1 has a greater character, return false\\n            if(mp[word1[i]] > mp[word2[j]]) return false;\\n            // If word2 has a greater character, return true\\n            else if(mp[word1[i]] < mp[word2[j]]) return true;\\n            i++;\\n            j++;\\n        }\\n        // If word1 has run out of characters, return true (word1 is less than or equal to word2)\\n        // If word2 has run out of characters, return false (word1 is greater than word2)\\n        return (word1.size() <= word2.size());\\n    }\\n    // Main function to check if the list of words is sorted lexicographically according to the given order of characters\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        int pos=0;\\n        unordered_map<char, int> mp;\\n        // Create a mapping of characters to their positions in the given order\\n        for(char i : order){\\n            mp[i] = pos;\\n            pos++;\\n        }\\n        // Iterate over the list of words and compare each consecutive pair using the check function\\n        for(int i=0;i<words.size()-1;i++){\\n            if(!check(mp, words[i], words[i+1])) return false;\\n        }\\n        // If all pairs are in the correct order, return true\\n        return true;\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def check(self, mp, word1, word2):\\n        i, j = 0, 0\\n        # Compare character by character until one of the words runs out of characters\\n        while i < len(word1) and j < len(word2):\\n            # If word1 has a greater character, return False\\n            if mp[word1[i]] > mp[word2[j]]:\\n                return False\\n            # If word2 has a greater character, return True\\n            elif mp[word1[i]] < mp[word2[j]]:\\n                return True\\n            i += 1\\n            j += 1\\n        # If word1 has run out of characters, return True (word1 is less than or equal to word2)\\n        # If word2 has run out of characters, return False (word1 is greater than word2)\\n        return len(word1) <= len(word2)\\n        \\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        mp = {}\\n        # Create a mapping of characters to their positions in the given order\\n        for i, c in enumerate(order):\\n            mp[c] = i\\n        # Iterate over the list of words and compare each consecutive pair using the check function\\n        for i in range(len(words) - 1):\\n            if not self.check(mp, words[i], words[i + 1]):\\n                return False\\n        # If all pairs are in the correct order, return True\\n        return True\\n```\n```\\n                        Give a \\uD83D\\uDC4D. It motivates me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129226,
                "title": "python3-26-ms-faster-than-99-38-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/03576340-5340-45fe-9652-519481934605_1675300225.1970687.png)\\n```\\ndef isAlienSorted(self, words: List[str], order: str) -> bool:\\n        h = {ch: i for i, ch in enumerate(order)}\\n        prev = list(h[ch] for ch in words[0])\\n        for i in range(1, len(words)):\\n            cur = list(h[ch] for ch in words[i])\\n            if cur < prev:\\n                return False\\n            prev = cur\\n        return True\\n```\\nThe code implements a solution to the problem of checking if a sequence of words written in an alien language is sorted lexicographically in the alien language. The solution is implemented in the isAlienSorted method, which takes as input a list of words (words) and a string that represents the order of the alphabet in the alien language (order).\\n\\n1. A dictionary h is created that maps each character in order to its corresponding index.\\n1. The first word in words is converted into a list of indices, using the dictionary h. This list is stored in the variable prev.\\n1. A for loop is started, starting from index 1, and ending at the last index of words.\\n1. In each iteration of the for loop, the current word from words is converted into a list of indices, using the dictionary h, and stored in the variable cur.\\n1. The code checks if the current list of indices cur is lexicographically smaller than the previous list of indices prev. If this is the case, the method returns False, indicating that the words are not sorted lexicographically.\\n1. If the current list of indices cur is not lexicographically smaller than the previous list of indices prev, the value of prev is updated to be cur.\\n1. Once all iterations of the for loop have completed, the method returns True, indicating that the words are sorted lexicographically.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\ndef isAlienSorted(self, words: List[str], order: str) -> bool:\\n        h = {ch: i for i, ch in enumerate(order)}\\n        prev = list(h[ch] for ch in words[0])\\n        for i in range(1, len(words)):\\n            cur = list(h[ch] for ch in words[i])\\n            if cur < prev:\\n                return False\\n            prev = cur\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1225619,
                "title": "java-best-solution-100-faster-without-using-any-extra-space",
                "content": "here, i used string indexOf function to find index.\\nvery easy and very helpful & space = O(1)\\nboolean flag \"same\" used for ->[\"apple\" , \"app\"]   type of test case\\nwhere \"app\" should come first before \"apple\".\\n\\n        for(int i=0 ; i<words.length-1 ; i++){\\n            boolean same = true;\\n            String a = words[i], b = words[i+1];\\n            for(int k=0 ; k<Math.min(a.length(),b.length()) ; k++){\\n                if(a.charAt(k) != b.charAt(k)){\\n                    same = false;\\n                    int index_a = order.indexOf(a.charAt(k));\\n                    int index_b = order.indexOf(b.charAt(k));\\n                    if(index_b < index_a){\\n                        return false;\\n                    }\\n                    break;\\n                } \\n            }\\n            if(same && a.length() > b.length()){\\n               return false;\\n            }\\n        }\\n        return true;",
                "solutionTags": [
                    "Java"
                ],
                "code": "here, i used string indexOf function to find index.\\nvery easy and very helpful & space = O(1)\\nboolean flag \"same\" used for ->[\"apple\" , \"app\"]   type of test case\\nwhere \"app\" should come first before \"apple\".\\n\\n        for(int i=0 ; i<words.length-1 ; i++){\\n            boolean same = true;\\n            String a = words[i], b = words[i+1];\\n            for(int k=0 ; k<Math.min(a.length(),b.length()) ; k++){\\n                if(a.charAt(k) != b.charAt(k)){\\n                    same = false;\\n                    int index_a = order.indexOf(a.charAt(k));\\n                    int index_b = order.indexOf(b.charAt(k));\\n                    if(index_b < index_a){\\n                        return false;\\n                    }\\n                    break;\\n                } \\n            }\\n            if(same && a.length() > b.length()){\\n               return false;\\n            }\\n        }\\n        return true;",
                "codeTag": "Unknown"
            },
            {
                "id": 1149852,
                "title": "verifying-an-alien-dictionary-js-python-java-c-easy-map-lookup-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe naive approach here would be to iterate through pairs of consecutive words in our input array (**W**) and compare the position of each letter in the input alphabet (**O**), moving letter by letter until we find a discrepancy and can determine which word comes first lexicographically.\\n\\nAs this is an Easy question, this method works, but with a **time complexity** of **O(N * M * P)** where **N** is the length of **W**, **M** is the average length of each word in **W**, and **P** is the length of **O**.\\n\\nRather than repetitively finding the position of a character in **O**, however, we can create a lookup table of indexes from **O** (**alpha**) at a time complexity of **O(P)** and turn every position lookup into a simple **O(1)** operation. That changes the overall time complexity to **O(N * M + P)**.\\n\\nThen, as noted before, we can just iterate through word pairs (**a, b**) in **W**, then iterate through comparative characters (**achar, bchar**) in those two words and evaluate them based on their lexicographical indexes (**aix, bix**).\\n\\nIf **aix < bix** or if we reach the end of **a**, then the two words are in correct lexicographical order and we should move to the next pair of words. If **aix > bix** or if we reach the end of **b**, the two words are *not* in correct lexicographical order and we should **return false**.\\n\\nIf we reach the end without exiting, we should **return true**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences in the code for all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar isAlienSorted = function(W, O) {\\n    let alpha = new Map([[\"\",-1]])\\n    for (let i = 0; i < O.length; i++)\\n        alpha.set(O.charAt(i), i)\\n    for (let i = 1; i < W.length; i++) {\\n        let a = W[i-1], b = W[i]\\n        for (let j = 0; j < a.length; j++) {\\n            let achar = a.charAt(j), bchar = b.charAt(j),\\n                aix = alpha.get(achar), bix = alpha.get(bchar)\\n            if (aix < bix) break\\n            if (aix > bix) return false\\n        }\\n    }\\n    return true\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def isAlienSorted(self, W: List[str], O: str) -> bool:\\n        alpha = {O[i]: i for i in range(len(O))}\\n        for i in range(1,len(W)):\\n            a, b = W[i-1], W[i]\\n            for j in range(len(a)):\\n                if j == len(b): return False\\n                achar, bchar = a[j], b[j]\\n                aix, bix = alpha[achar], alpha[bchar]\\n                if aix < bix: break\\n                if aix > bix: return False\\n        return True\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public boolean isAlienSorted(String[] W, String O) {\\n        Map<Character,Integer> alpha = new HashMap<>();\\n        for (int i = 0; i < O.length(); i++)\\n            alpha.put(O.charAt(i), i);\\n        for (int i = 1; i < W.length; i++) {\\n            String a = W[i-1], b = W[i];\\n            for (int j = 0; j < a.length(); j++) {\\n                if (j == b.length()) return false;\\n                char achar = a.charAt(j), bchar = b.charAt(j);\\n                if (alpha.get(achar) < alpha.get(bchar)) break;\\n                if (alpha.get(achar) > alpha.get(bchar)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& W, string O) {\\n        unordered_map<char,int> alpha;\\n        for (int i = 0; i < O.size(); i++)\\n            alpha[O[i]] = i;\\n        for (int i = 1; i < W.size(); i++) {\\n            string a = W[i-1], b = W[i];\\n            for (int j = 0; j < a.size(); j++) {\\n                if (j == b.size()) return false;\\n                char achar = a[j], bchar = b[j];\\n                if (alpha[achar] < alpha[bchar]) break;\\n                if (alpha[achar] > alpha[bchar]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar isAlienSorted = function(W, O) {\\n    let alpha = new Map([[\"\",-1]])\\n    for (let i = 0; i < O.length; i++)\\n        alpha.set(O.charAt(i), i)\\n    for (let i = 1; i < W.length; i++) {\\n        let a = W[i-1], b = W[i]\\n        for (let j = 0; j < a.length; j++) {\\n            let achar = a.charAt(j), bchar = b.charAt(j),\\n                aix = alpha.get(achar), bix = alpha.get(bchar)\\n            if (aix < bix) break\\n            if (aix > bix) return false\\n        }\\n    }\\n    return true\\n};\\n```\n```python\\nclass Solution:\\n    def isAlienSorted(self, W: List[str], O: str) -> bool:\\n        alpha = {O[i]: i for i in range(len(O))}\\n        for i in range(1,len(W)):\\n            a, b = W[i-1], W[i]\\n            for j in range(len(a)):\\n                if j == len(b): return False\\n                achar, bchar = a[j], b[j]\\n                aix, bix = alpha[achar], alpha[bchar]\\n                if aix < bix: break\\n                if aix > bix: return False\\n        return True\\n```\n```java\\nclass Solution {\\n    public boolean isAlienSorted(String[] W, String O) {\\n        Map<Character,Integer> alpha = new HashMap<>();\\n        for (int i = 0; i < O.length(); i++)\\n            alpha.put(O.charAt(i), i);\\n        for (int i = 1; i < W.length; i++) {\\n            String a = W[i-1], b = W[i];\\n            for (int j = 0; j < a.length(); j++) {\\n                if (j == b.length()) return false;\\n                char achar = a.charAt(j), bchar = b.charAt(j);\\n                if (alpha.get(achar) < alpha.get(bchar)) break;\\n                if (alpha.get(achar) > alpha.get(bchar)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& W, string O) {\\n        unordered_map<char,int> alpha;\\n        for (int i = 0; i < O.size(); i++)\\n            alpha[O[i]] = i;\\n        for (int i = 1; i < W.size(); i++) {\\n            string a = W[i-1], b = W[i];\\n            for (int j = 0; j < a.size(); j++) {\\n                if (j == b.size()) return false;\\n                char achar = a[j], bchar = b[j];\\n                if (alpha[achar] < alpha[bchar]) break;\\n                if (alpha[achar] > alpha[bchar]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386973,
                "title": "simple-javascript-solution-map-comparator",
                "content": "For someone not familiar with the comparator function concept (like in `Array#sort()`) => if `compare(a, b)` returns:\\n- `0`: `a` is equal to `b`\\n- `-1`: `a` should be **before** `b` in the final result\\n- `1`: `a` should be **after** `b`\\n\\n```js\\nvar isAlienSorted = function(words, order) {\\n  let alphabet = new Map();\\n  let index = 0;\\n\\n  for (let letter of order) {\\n    alphabet.set(letter, index);\\n    index++;\\n  }\\n\\n  for (let i = 0; i < words.length - 1; i++) {\\n    if (compare(words[i], words[i+1], alphabet) !== 1) {\\n      continue;\\n    }\\n    \\n    return false;\\n  }\\n  \\n  return true;\\n};\\n\\nfunction compare(a, b, alphabet) {\\n  const aLength = a.length;\\n  const bLength = b.length;\\n  const minLength = Math.min(aLength, bLength);\\n  \\n  for (let i = 0; i < minLength; i++) {\\n    const aOrder = alphabet.get(a[i]);\\n    const bOrder = alphabet.get(b[i]);\\n    \\n    if (aOrder === bOrder) {\\n      continue;\\n    }\\n    \\n    if (aOrder < bOrder) {\\n      return -1;\\n    }\\n    \\n    return 1;\\n  }\\n  \\n  if (aLength === bLength) {\\n    return 0;\\n  }\\n  \\n  return aLength < bLength ? -1 : 1;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar isAlienSorted = function(words, order) {\\n  let alphabet = new Map();\\n  let index = 0;\\n\\n  for (let letter of order) {\\n    alphabet.set(letter, index);\\n    index++;\\n  }\\n\\n  for (let i = 0; i < words.length - 1; i++) {\\n    if (compare(words[i], words[i+1], alphabet) !== 1) {\\n      continue;\\n    }\\n    \\n    return false;\\n  }\\n  \\n  return true;\\n};\\n\\nfunction compare(a, b, alphabet) {\\n  const aLength = a.length;\\n  const bLength = b.length;\\n  const minLength = Math.min(aLength, bLength);\\n  \\n  for (let i = 0; i < minLength; i++) {\\n    const aOrder = alphabet.get(a[i]);\\n    const bOrder = alphabet.get(b[i]);\\n    \\n    if (aOrder === bOrder) {\\n      continue;\\n    }\\n    \\n    if (aOrder < bOrder) {\\n      return -1;\\n    }\\n    \\n    return 1;\\n  }\\n  \\n  if (aLength === bLength) {\\n    return 0;\\n  }\\n  \\n  return aLength < bLength ? -1 : 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 251208,
                "title": "python3-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        base_int = ord(\\'a\\')\\n        new_order = sorted(words, key=lambda word: [order.index(c) for c in word])\\n        return new_order == words",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        base_int = ord(\\'a\\')\\n        new_order = sorted(words, key=lambda word: [order.index(c) for c in word])\\n        return new_order == words",
                "codeTag": "Java"
            },
            {
                "id": 3130363,
                "title": "c-solution",
                "content": "# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string> words, string order) {\\n        int mapping[26];\\n        for (int i = 0; i < 26; i++)\\n            mapping[order[i] - \\'a\\'] = i;\\n        for (string &w : words)\\n            for (char &c : w)\\n                c = mapping[c - \\'a\\'];\\n        return is_sorted(words.begin(), words.end());\\n    }\\n};\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/91058aba-a0f4-42d5-b394-46155530211c_1675321750.7617948.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string> words, string order) {\\n        int mapping[26];\\n        for (int i = 0; i < 26; i++)\\n            mapping[order[i] - \\'a\\'] = i;\\n        for (string &w : words)\\n            for (char &c : w)\\n                c = mapping[c - \\'a\\'];\\n        return is_sorted(words.begin(), words.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129608,
                "title": "c-easy-intuitive-solution",
                "content": "\\n\\n \\n```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n\\n        // map which stores the order of the alien language \\n        int j=0;\\n        map<char,int> mp;\\n        for( auto &it : order ) mp[it] = j++;\\n\\n        // check for lexicographical order \\n        for( int i=1 ; i<words.size() ; i++ ){\\n\\n            bool flag = false ;\\n            string first = words[i-1];\\n            string second = words[i];\\n\\n            int minLen = min(first.size(), second.size());\\n\\n            for( int j=0 ; j<minLen ; j++ ){\\n\\n                // words = [\"hello\",\"leetcode\"]\\n                if( mp[first[j]] < mp[second[j]] ) {\\n                    flag = true ;\\n                    break;\\n                }\\n\\n                // words = [\"word\",\"world\",\"row\"]\\n                if( mp[first[j]] > mp[second[j]] ) return false ;\\n            }\\n\\n            // words = [\"apple\",\"app\"]\\n            if( !flag && first.size() > second.size() ) return false ;\\n        }\\n\\n        return true;\\n    }\\n};\\n```\\n# Please Upvote If U like the Solution!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n\\n        // map which stores the order of the alien language \\n        int j=0;\\n        map<char,int> mp;\\n        for( auto &it : order ) mp[it] = j++;\\n\\n        // check for lexicographical order \\n        for( int i=1 ; i<words.size() ; i++ ){\\n\\n            bool flag = false ;\\n            string first = words[i-1];\\n            string second = words[i];\\n\\n            int minLen = min(first.size(), second.size());\\n\\n            for( int j=0 ; j<minLen ; j++ ){\\n\\n                // words = [\"hello\",\"leetcode\"]\\n                if( mp[first[j]] < mp[second[j]] ) {\\n                    flag = true ;\\n                    break;\\n                }\\n\\n                // words = [\"word\",\"world\",\"row\"]\\n                if( mp[first[j]] > mp[second[j]] ) return false ;\\n            }\\n\\n            // words = [\"apple\",\"app\"]\\n            if( !flag && first.size() > second.size() ) return false ;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 476389,
                "title": "great-practice-of-java-comparator",
                "content": "Java comparator can be used to sort the strings, all you need to do is to rewrite the sorting logic. Please take care of cases where strings are of different lengths.\\n\\n```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        if (words == null || words.length == 0 || order == null || order.length() == 0) return false;\\n        Comparator<String> comparator = new Comparator<String>(){\\n            @Override\\n            public int compare(String str1, String str2) {\\n                for (int i = 0; i < Math.min(str1.length(), str2.length()); i++) {\\n                    char a = str1.charAt(i), b = str2.charAt(i);\\n                    if (a != b) {\\n                        if (order.indexOf(a) > order.indexOf(b)) return 1;\\n                        else return -1;\\n                    }\\n                }\\n                if (str1.length() > str2.length()) return 1;\\n                else if (str1.length() == str2.length()) return 0;\\n                else return -1;\\n            }\\n        };\\n        PriorityQueue<String> pq = new PriorityQueue<>(words.length, comparator);\\n        for (String s: words) pq.offer(s);\\n        int index = 0;\\n        while (!pq.isEmpty()) {\\n            if (!pq.poll().equals(words[index++])) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        if (words == null || words.length == 0 || order == null || order.length() == 0) return false;\\n        Comparator<String> comparator = new Comparator<String>(){\\n            @Override\\n            public int compare(String str1, String str2) {\\n                for (int i = 0; i < Math.min(str1.length(), str2.length()); i++) {\\n                    char a = str1.charAt(i), b = str2.charAt(i);\\n                    if (a != b) {\\n                        if (order.indexOf(a) > order.indexOf(b)) return 1;\\n                        else return -1;\\n                    }\\n                }\\n                if (str1.length() > str2.length()) return 1;\\n                else if (str1.length() == str2.length()) return 0;\\n                else return -1;\\n            }\\n        };\\n        PriorityQueue<String> pq = new PriorityQueue<>(words.length, comparator);\\n        for (String s: words) pq.offer(s);\\n        int index = 0;\\n        while (!pq.isEmpty()) {\\n            if (!pq.poll().equals(words[index++])) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422351,
                "title": "simplest-c-solution-4ms-97-33",
                "content": "```\\nbool isAlienSorted(vector<string>& words, string order) {\\n    for (int i = 0; i < words.size() - 1; i++) {\\n        const auto& word1 = words[i];\\n        const auto& word2 = words[i + 1];\\n\\n        int i1 = 0, i2 = 0;\\n        while (word1[i1] == word2[i2]) {\\n            i1++, i2++;\\n        }\\n\\n        i1 = order.find(word1[i1]);\\n        i2 = order.find(word2[i2]);\\n\\n        if (i1 > i2) return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isAlienSorted(vector<string>& words, string order) {\\n    for (int i = 0; i < words.size() - 1; i++) {\\n        const auto& word1 = words[i];\\n        const auto& word2 = words[i + 1];\\n\\n        int i1 = 0, i2 = 0;\\n        while (word1[i1] == word2[i2]) {\\n            i1++, i2++;\\n        }\\n\\n        i1 = order.find(word1[i1]);\\n        i2 = order.find(word2[i2]);\\n\\n        if (i1 > i2) return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3129256,
                "title": "c-easy-to-understand-simple-compare",
                "content": "```\\nclass Solution {\\npublic:\\n    //returns true if \"word1\" is smaller or equal to \"word2\"\\n    bool wordCompare(vector<int>&mp, string& word1, string& word2) \\n    {\\n        int i = 0, j = 0;\\n        while(i < word1.size() && j < word2.size())\\n        {\\n            int pos1 = mp[word1[i] - \\'a\\'];\\n            int pos2 = mp[word2[j] - \\'a\\'];\\n            if (pos1 < pos2) return true;\\n            else if (pos2 < pos1) return false;  //if pos1 == pos2, keep comparing\\n\\n            i++; \\n            j++;   \\n        }\\n        //control will come here only if the characters compared are equal\\n        //so smaller length word will be smaller in lex order\\n        return (word1.size() <= word2.size());\\n    }\\n    bool isAlienSorted(vector<string>& words, string order) \\n    {\\n        vector<int>mp(26);\\n        for (int i = 0; i < order.size(); i++) mp[order[i] - \\'a\\'] = i; \\n        //mapped characters to their pos in (new alphabet)\\n        \\n        for (int i = 0; i < words.size() - 1; i++)\\n        {\\n            if (!wordCompare(mp, words[i], words[i + 1])) \\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //returns true if \"word1\" is smaller or equal to \"word2\"\\n    bool wordCompare(vector<int>&mp, string& word1, string& word2) \\n    {\\n        int i = 0, j = 0;\\n        while(i < word1.size() && j < word2.size())\\n        {\\n            int pos1 = mp[word1[i] - \\'a\\'];\\n            int pos2 = mp[word2[j] - \\'a\\'];\\n            if (pos1 < pos2) return true;\\n            else if (pos2 < pos1) return false;  //if pos1 == pos2, keep comparing\\n\\n            i++; \\n            j++;   \\n        }\\n        //control will come here only if the characters compared are equal\\n        //so smaller length word will be smaller in lex order\\n        return (word1.size() <= word2.size());\\n    }\\n    bool isAlienSorted(vector<string>& words, string order) \\n    {\\n        vector<int>mp(26);\\n        for (int i = 0; i < order.size(); i++) mp[order[i] - \\'a\\'] = i; \\n        //mapped characters to their pos in (new alphabet)\\n        \\n        for (int i = 0; i < words.size() - 1; i++)\\n        {\\n            if (!wordCompare(mp, words[i], words[i + 1])) \\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375774,
                "title": "c-map-sorting-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) \\n    {\\n        unordered_map<char,char> m;\\n        for(int i=0;i<26;i++)\\n        {\\n            m[order[i]]=i+\\'a\\';\\n        }\\n        for(auto &w:words)\\n        {\\n            for(auto &ch:w)\\n            {\\n                ch=m[ch];\\n            }\\n        }\\n        return is_sorted(words.begin(),words.end());// check sorting \\n        \\n    }\\n};\\n//if you like the solution plz upvote;",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) \\n    {\\n        unordered_map<char,char> m;\\n        for(int i=0;i<26;i++)\\n        {\\n            m[order[i]]=i+\\'a\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 585465,
                "title": "0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Verifying an Alien Dictionary.\\nMemory Usage: 37.8 MB, less than 19.23% of Java online submissions for Verifying an Alien Dictionary.\\n\\n```\\nclass Solution {\\n    \\n    \\n    public boolean isAlienSorted(String[] words, String order) {\\n        \\n        for(int i=0; i< words.length-1; i++){\\n            String s1 = words[i];\\n            String s2 = words[i+1];\\n            if(!compare(s1, s2, order))\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean compare(String s1, String s2, String order) {\\n        if(s1.equals(s2))\\n            return true;\\n        \\n        int min = Math.min(s1.length(), s2.length());\\n        int j = 0; \\n        \\n        while(j < min && s1.charAt(j) == s2.charAt(j)){\\n           j++;\\n        }\\n        \\n        if(j==min){\\n            return (min == s1.length());\\n        }else{\\n            char c1 = s1.charAt(j);\\n            char c2 = s2.charAt(j);\\n            boolean res = (order.indexOf(c1) < order.indexOf(c2));\\n            return res;\\n        }\\n }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    \\n    public boolean isAlienSorted(String[] words, String order) {\\n        \\n        for(int i=0; i< words.length-1; i++){\\n            String s1 = words[i];\\n            String s2 = words[i+1];\\n            if(!compare(s1, s2, order))\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean compare(String s1, String s2, String order) {\\n        if(s1.equals(s2))\\n            return true;\\n        \\n        int min = Math.min(s1.length(), s2.length());\\n        int j = 0; \\n        \\n        while(j < min && s1.charAt(j) == s2.charAt(j)){\\n           j++;\\n        }\\n        \\n        if(j==min){\\n            return (min == s1.length());\\n        }else{\\n            char c1 = s1.charAt(j);\\n            char c2 = s2.charAt(j);\\n            boolean res = (order.indexOf(c1) < order.indexOf(c2));\\n            return res;\\n        }\\n }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132667,
                "title": "putta-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<order.size();i++){\\n            mp[order[i]] = i;\\n        }\\n        for(int i=0;i<words.size()-1;i++){\\n            string w1 = words[i],w2 = words[i+1];\\n            for(int j=0;j<w1.size();j++){\\n                if(j == w2.size()) return false;\\n            \\n            if(w1[j] != w2[j]) {\\n                if(mp[w1[j]] > mp[w2[j]]) return false;\\n                break;\\n            }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<order.size();i++){\\n            mp[order[i]] = i;\\n        }\\n        for(int i=0;i<words.size()-1;i++){\\n            string w1 = words[i],w2 = words[i+1];\\n            for(int j=0;j<w1.size();j++){\\n                if(j == w2.size()) return false;\\n            \\n            if(w1[j] != w2[j]) {\\n                if(mp[w1[j]] > mp[w2[j]]) return false;\\n                break;\\n            }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130033,
                "title": "java-hashmap-solution-optimized-approach-o-n",
                "content": "# Intuition\\nTo Apply HashMap \\n\\n# Approach\\nStore the order in a HashMap with key as a character and then check each words \\n\\n# Complexity\\n- Time complexity\\n- O(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private boolean check(String word1, String word2 ,Map<Character,Integer> ma){\\n        int len1= word1.length();\\n        int len2= word2.length();\\n        int min = Math.min(len1,len2);\\n        for(int i=0;i<min;i++){\\n            if(ma.get(word1.charAt(i))>ma.get(word2.charAt(i))){\\n                return false;\\n            }\\n             if(ma.get(word1.charAt(i))<ma.get(word2.charAt(i))){\\n                return true;\\n            }\\n        }\\n        if(len2 < len1){\\n            return false;\\n        }\\n        return true;   \\n    }\\n    public boolean isAlienSorted(String[] words, String order) {\\n        Map<Character,Integer> ma= new HashMap<Character,Integer>(26);\\n        for(int i=0;i<order.length();i++){\\n            ma.put(order.charAt(i),i);\\n        }\\n        for(int i=0;i<words.length-1;i++){\\n            if(!check(words[i],words[i+1],ma)){\\n                return false;\\n            }\\n        }\\n        return true; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    private boolean check(String word1, String word2 ,Map<Character,Integer> ma){\\n        int len1= word1.length();\\n        int len2= word2.length();\\n        int min = Math.min(len1,len2);\\n        for(int i=0;i<min;i++){\\n            if(ma.get(word1.charAt(i))>ma.get(word2.charAt(i))){\\n                return false;\\n            }\\n             if(ma.get(word1.charAt(i))<ma.get(word2.charAt(i))){\\n                return true;\\n            }\\n        }\\n        if(len2 < len1){\\n            return false;\\n        }\\n        return true;   \\n    }\\n    public boolean isAlienSorted(String[] words, String order) {\\n        Map<Character,Integer> ma= new HashMap<Character,Integer>(26);\\n        for(int i=0;i<order.length();i++){\\n            ma.put(order.charAt(i),i);\\n        }\\n        for(int i=0;i<words.length-1;i++){\\n            if(!check(words[i],words[i+1],ma)){\\n                return false;\\n            }\\n        }\\n        return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129641,
                "title": "c-faster-than-90-explained-very-beginner-friendly-clean-code",
                "content": "**If we try to compare the strings it will be a hefty task, so a very simple approach to do this is that, we all know the inbuilt sort can sort strings lexicographically only if the given order is the original English alphabetical order ie. \"a,b,c,d,e,f,g,h......x,y,z\" but here we are given with some other order, so in order to use the inbuilt sorting we have to make another string in the orginal english alphabetical order corresponding to the letters given and then store it in a pair with the given string and sort.....Yeahhh!!! here u go, u just need to simply compare if the strings retain their orginal positions or not as given in the question**\\n\\n**PLEASE DO UPVOTE**\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        \\n       vector<pair<string,string>>vp;\\n       unordered_map<char,char>mpp;\\n\\n       for(int i = 0 ; i < order.size(); ++i) mpp[order[i]] = char(i +\\'a\\');\\n\\n       for(int i = 0; i < words.size(); ++i)\\n       {\\n           string temp;\\n\\n           for(auto &it : words[i]) temp.push_back(mpp[it]);\\n\\n           vp.push_back({temp, words[i]});\\n       }\\n\\n       sort(vp.begin(), vp.end());\\n\\n       for(int i = 0; i < words.size(); ++i)  if(words[i] != vp[i].second) return false;\\n    \\n       return true;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        \\n       vector<pair<string,string>>vp;\\n       unordered_map<char,char>mpp;\\n\\n       for(int i = 0 ; i < order.size(); ++i) mpp[order[i]] = char(i +\\'a\\');\\n\\n       for(int i = 0; i < words.size(); ++i)\\n       {\\n           string temp;\\n\\n           for(auto &it : words[i]) temp.push_back(mpp[it]);\\n\\n           vp.push_back({temp, words[i]});\\n       }\\n\\n       sort(vp.begin(), vp.end());\\n\\n       for(int i = 0; i < words.size(); ++i)  if(words[i] != vp[i].second) return false;\\n    \\n       return true;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556633,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn is_alien_sorted(words: Vec<String>, order: String) -> bool {\\n        let pos = |c: char| -> usize { (c as u8 - b\\'a\\') as usize };\\n        let mut ord = [0; 26];\\n        order.char_indices().for_each(|(ind, c)| ord[pos(c)] = ind);\\n        words\\n            .windows(2)\\n            .map(|pair| {\\n                let (w0, w1) = (&pair[0], &pair[1]);\\n                w1.chars()\\n                    .map(|c| ord[pos(c)])\\n                    .ge(w0.chars().map(|c| ord[pos(c)]))\\n            })\\n            .all(|x| x)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Sliding Window"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_alien_sorted(words: Vec<String>, order: String) -> bool {\\n        let pos = |c: char| -> usize { (c as u8 - b\\'a\\') as usize };\\n        let mut ord = [0; 26];\\n        order.char_indices().for_each(|(ind, c)| ord[pos(c)] = ind);\\n        words\\n            .windows(2)\\n            .map(|pair| {\\n                let (w0, w1) = (&pair[0], &pair[1]);\\n                w1.chars()\\n                    .map(|c| ord[pos(c)])\\n                    .ge(w0.chars().map(|c| ord[pos(c)]))\\n            })\\n            .all(|x| x)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 717435,
                "title": "python-3-custom-sort",
                "content": "```\\nclass Solution(object):\\n    def isAlienSorted(self, words, order):\\n        \"\"\"\\n        :type words: List[str]\\n        :type order: str\\n        :rtype: bool\\n        \"\"\"\\n        out = sorted(words, key = lambda x: [order.index(c) for c in x])\\n        return out == words",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def isAlienSorted(self, words, order):\\n        \"\"\"\\n        :type words: List[str]\\n        :type order: str\\n        :rtype: bool\\n        \"\"\"\\n        out = sorted(words, key = lambda x: [order.index(c) for c in x])\\n        return out == words",
                "codeTag": "Java"
            },
            {
                "id": 704284,
                "title": "python-optimal-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n\\t\\t# create a mapping (char -> position) for O(1) lookups.\\n        char_to_idx = {c:i for i,c in enumerate(order)}\\n        \\n        prev = []        \\n        for i in range(len(words)):\\n\\t\\t\\t# Translate each character into its position in the alien alphabet.\\n            word = [char_to_idx[char] for char in words[i]]\\n\\t\\t\\t\\n\\t\\t\\t# Check if the current word translated is not less then the previous one.\\n            if word < prev:\\n                return False\\n            prev = word\\n            \\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n\\t\\t# create a mapping (char -> position) for O(1) lookups.\\n        char_to_idx = {c:i for i,c in enumerate(order)}\\n        \\n        prev = []        \\n        for i in range(len(words)):\\n\\t\\t\\t# Translate each character into its position in the alien alphabet.\\n            word = [char_to_idx[char] for char in words[i]]\\n\\t\\t\\t\\n\\t\\t\\t# Check if the current word translated is not less then the previous one.\\n            if word < prev:\\n                return False\\n            prev = word\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209550,
                "title": "java-hashmap-o-n-s-length-4ms",
                "content": "```\\nclass Solution {\\n            \\n    public boolean isAlienSorted(String[] words, String order) {\\n        int[] map = new int[26];\\n        for (int i = 0; i < order.length(); i++) {\\n            map[order.charAt(i) - \\'a\\'] = i;\\n        }\\n        for (int i = 1; i < words.length; i++) {\\n            String prev = words[i - 1];\\n            String current = words[i];\\n            if (!small(prev, current, map)) return false;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean small(String s1, String s2, int[] map) {\\n        int len = Math.min(s1.length(), s2.length());\\n        for (int i = 0; i < len; i++) {\\n            if (map[s1.charAt(i) - \\'a\\'] != map[s2.charAt(i) - \\'a\\']) {\\n                return map[s1.charAt(i) - \\'a\\'] < map[s2.charAt(i) - \\'a\\'];\\n            }\\n        }\\n        return s1.length() <= s2.length();\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n            \\n    public boolean isAlienSorted(String[] words, String order) {\\n        int[] map = new int[26];\\n        for (int i = 0; i < order.length(); i++) {\\n            map[order.charAt(i) - \\'a\\'] = i;\\n        }\\n        for (int i = 1; i < words.length; i++) {\\n            String prev = words[i - 1];\\n            String current = words[i];\\n            if (!small(prev, current, map)) return false;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean small(String s1, String s2, int[] map) {\\n        int len = Math.min(s1.length(), s2.length());\\n        for (int i = 0; i < len; i++) {\\n            if (map[s1.charAt(i) - \\'a\\'] != map[s2.charAt(i) - \\'a\\']) {\\n                return map[s1.charAt(i) - \\'a\\'] < map[s2.charAt(i) - \\'a\\'];\\n            }\\n        }\\n        return s1.length() <= s2.length();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564840,
                "title": "simple-solution-using-hashmap-with-explanation",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    We need to create a mapping (let\\'s call it mp) of all alphabets\\n    to their index in order. This will help us determine if two words\\n    are lexicographically sorted efficiently.\\n\\n\\n- **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N), where N is the total number of characters in words.\\n\\n- **Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1), we only need constant amount of space to store the mapping of \\n    letters to index which does not depend on the size of input.\\n    Hence we get constant space complexity.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<char, int> m;\\n\\n    bool isAlienSorted(vector<string>& words, string order) {        \\n\\t    for(int i=0; i<order.size(); i++){\\n            m[order[i]] = i;\\n        }\\n\\n        // for(auto i: m){\\n        //     cout << i.first << \" \" << i.second << \"\\\\n\";\\n        // }\\n\\n\\t    for(int i = 0; i < words.size() - 1; i++){\\n\\t\\t    if(checkOrder(words[i], words[i + 1]) == false){\\n                return false;\\n            }\\n        }\\n\\t    return true;        \\n    }    \\n\\n    // checking if two words are lexicographically sorted\\n    bool checkOrder(string& a, string& b){\\n        int i = 0, size = min(a.size(), b.size());\\n\\n\\t    while(i < size){\\n\\t\\t    if(m[a[i]] != m[b[i]]){\\n                return m[a[i]] < m[b[i]];\\n            }\\n            i++;\\n        }\\n\\t    return a.size() <= b.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<char, int> m;\\n\\n    bool isAlienSorted(vector<string>& words, string order) {        \\n\\t    for(int i=0; i<order.size(); i++){\\n            m[order[i]] = i;\\n        }\\n\\n        // for(auto i: m){\\n        //     cout << i.first << \" \" << i.second << \"\\\\n\";\\n        // }\\n\\n\\t    for(int i = 0; i < words.size() - 1; i++){\\n\\t\\t    if(checkOrder(words[i], words[i + 1]) == false){\\n                return false;\\n            }\\n        }\\n\\t    return true;        \\n    }    \\n\\n    // checking if two words are lexicographically sorted\\n    bool checkOrder(string& a, string& b){\\n        int i = 0, size = min(a.size(), b.size());\\n\\n\\t    while(i < size){\\n\\t\\t    if(m[a[i]] != m[b[i]]){\\n                return m[a[i]] < m[b[i]];\\n            }\\n            i++;\\n        }\\n\\t    return a.size() <= b.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3130366,
                "title": "c-very-easy-two-implementations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to just traverse and check for each word that its character is <= next word\\'s character . If any where prev character > next word\\'s character return false . And if this condition never gets true\\nthen return true at the end. And also if some where our charcter is less than next word\\'s character we should break because it means our word is less than next word so no traversal of that word after that.\\nNOTE : Also if our next word is lesser in size than curr word if any conditon doenot got satisfied we to return fasle take this case in example e.g `apple , app  or abbc, ab or aa,a`\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can do do this appraoch by checkng one by one each word and their characters.\\n Or we have also  an appraoch that is direct mapping of words using order string position to each character then  check if it is sorted or not .\\ne.g we map each charecter in words string to indices from order string   if they are in sorted order so it means lexograhically smaller . \\n# Complexity\\n- Time complexity:$$O(N*10)$$ or we can say `O(M)`\\n- where M is number of characters in words\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,int>mp;\\n        bool res=true;\\n        for(int i=0;i<order.size();i++)mp[order[i]]=i;\\n        for(int i=0;i<words.size()-1;i++){\\n            for(int j=0;j<words[i].size();j++){\\n                if (j >= words[i + 1].length()) return false;\\n                 if(mp[words[i][j]]>mp[words[i+1][j]])return false;\\n                 else if(mp[words[i][j]]<mp[words[i+1][j]]){\\n                     break;\\n                 }\\n                 \\n            }\\n            \\n        }\\n        return true;\\n    }\\n};\\n```\\n**Using STL and Direct mapping**\\n```\\nbool isAlienSorted(vector<string>& words, string order) {        \\nunordered_map<char, char> mp;\\n\\tfor(int i = 0; i < size(order); i++) mp[order[i]] = i + \\'a\\';  \\n\\tfor(auto& word : words)\\n\\t\\tfor(auto& c : word) c = mp[c];\\n\\treturn is_sorted(begin(words), end(words));\\n} \\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sorting",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,int>mp;\\n        bool res=true;\\n        for(int i=0;i<order.size();i++)mp[order[i]]=i;\\n        for(int i=0;i<words.size()-1;i++){\\n            for(int j=0;j<words[i].size();j++){\\n                if (j >= words[i + 1].length()) return false;\\n                 if(mp[words[i][j]]>mp[words[i+1][j]])return false;\\n                 else if(mp[words[i][j]]<mp[words[i+1][j]]){\\n                     break;\\n                 }\\n                 \\n            }\\n            \\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nbool isAlienSorted(vector<string>& words, string order) {        \\nunordered_map<char, char> mp;\\n\\tfor(int i = 0; i < size(order); i++) mp[order[i]] = i + \\'a\\';  \\n\\tfor(auto& word : words)\\n\\t\\tfor(auto& c : word) c = mp[c];\\n\\treturn is_sorted(begin(words), end(words));\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129295,
                "title": "python-solution-4-lines-easy-to-understand",
                "content": "class Solution(object):\\n    def isAlienSorted(self, words, order):\\n\\n        arr = []\\n        for i in words:\\n            arr.append([order.index(j) for j in i])\\n        return arr == sorted(arr)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def isAlienSorted(self, words, order):\\n\\n        arr = []\\n        for i in words:\\n            arr.append([order.index(j) for j in i])\\n        return arr == sorted(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681887,
                "title": "easy-100-faster-0ms-best-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    /* for storing the character change in alien language\\n    like according to first test case in alien lang a is h, b is l, c is a ---etc\\n    so if we change this language in our lang then we can simple find if it is sorted or not \\n    by using is_sorted built in funtion  */\\n    \\n    \\n    unordered_map<char, char> mp;\\n    \\n    bool isAlienSorted(vector<string>& words, string order) {\\n        /* in first test case h--> a, l--> b, a-->c,-------- */\\n        \\n        for(int i = 0; i < size(order); i++) mp[order[i]] = i + \\'a\\';  \\n\\t    for(auto& word : words)\\n            /* Changing alien lang into human lang like h-->a, l-->b*/\\n\\t\\t    for(auto& c : word) c = mp[c];\\n\\treturn is_sorted(begin(words), end(words));\\n        /* after changing it into human lang then we can check using is_sorted built in funtion*/\\n    } \\n};\\n\\n/* If you Like it please Do upvote \\uD83D\\uDE42\\uD83D\\uDE42*/ \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /* for storing the character change in alien language\\n    like according to first test case in alien lang a is h, b is l, c is a ---etc\\n    so if we change this language in our lang then we can simple find if it is sorted or not \\n    by using is_sorted built in funtion  */\\n    \\n    \\n    unordered_map<char, char> mp;\\n    \\n    bool isAlienSorted(vector<string>& words, string order) {\\n        /* in first test case h--> a, l--> b, a-->c,-------- */\\n        \\n        for(int i = 0; i < size(order); i++) mp[order[i]] = i + \\'a\\';  \\n\\t    for(auto& word : words)\\n            /* Changing alien lang into human lang like h-->a, l-->b*/\\n\\t\\t    for(auto& c : word) c = mp[c];\\n\\treturn is_sorted(begin(words), end(words));\\n        /* after changing it into human lang then we can check using is_sorted built in funtion*/\\n    } \\n};\\n\\n/* If you Like it please Do upvote \\uD83D\\uDE42\\uD83D\\uDE42*/ \\n```",
                "codeTag": "Java"
            },
            {
                "id": 877634,
                "title": "javascript-easy-to-understand",
                "content": "```\\nvar isAlienSorted = function(words, order) {\\n  const m = {};\\n  for (let i = 0; i < order.length; ++i) m[order[i]] = i;\\n  \\n  const isLTE = (a, b) => {\\n    for (let i = 0; i < Math.min(a.length, b.length); ++i) {\\n      if (m[a[i]] < m[b[i]]) return true;\\n      if (m[a[i]] > m[b[i]]) return false;\\n    }\\n    return a.length <= b.length;\\n  }\\n\\n  for (let i = 0; i < words.length - 1; ++i) {\\n    if (!isLTE(words[i], words[i+1])) return false;\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isAlienSorted = function(words, order) {\\n  const m = {};\\n  for (let i = 0; i < order.length; ++i) m[order[i]] = i;\\n  \\n  const isLTE = (a, b) => {\\n    for (let i = 0; i < Math.min(a.length, b.length); ++i) {\\n      if (m[a[i]] < m[b[i]]) return true;\\n      if (m[a[i]] > m[b[i]]) return false;\\n    }\\n    return a.length <= b.length;\\n  }\\n\\n  for (let i = 0; i < words.length - 1; ++i) {\\n    if (!isLTE(words[i], words[i+1])) return false;\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 727397,
                "title": "easy-python-with-comments",
                "content": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        dict = {}\\n        # map each char in the alien dictionary to its position\\n        for index, char in enumerate(order):\\n            dict[char] = index\\n        # compare adjacent words\\n        for i in range(len(words)-1):\\n            word1 = words[i]\\n            word2 = words[i+1]\\n            # words that are the same can be skipped\\n            if word1 == word2:\\n                continue\\n            # longer words, that start with the adjacent word, should not come first\\n            if len(word1) > len(word2):\\n                if word1.startswith(word2):\\n                    return False\\n            # compare each character, it must be smaller or equal to that of the adjacent word\\n            for j in range(min(len(word1), len(word2))):\\n                if dict.get(word1[j]) < dict.get(word2[j]):\\n                    break\\n                elif dict.get(word1[j]) == dict.get(word2[j]):\\n                    continue\\n                else:\\n                    return False\\n        return True\\n```\\n\\nIf you like this solution please consider giving it a star on my [github](https://github.com/bwiens/leetcode-python). Means a lot to me.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        dict = {}\\n        # map each char in the alien dictionary to its position\\n        for index, char in enumerate(order):\\n            dict[char] = index\\n        # compare adjacent words\\n        for i in range(len(words)-1):\\n            word1 = words[i]\\n            word2 = words[i+1]\\n            # words that are the same can be skipped\\n            if word1 == word2:\\n                continue\\n            # longer words, that start with the adjacent word, should not come first\\n            if len(word1) > len(word2):\\n                if word1.startswith(word2):\\n                    return False\\n            # compare each character, it must be smaller or equal to that of the adjacent word\\n            for j in range(min(len(word1), len(word2))):\\n                if dict.get(word1[j]) < dict.get(word2[j]):\\n                    break\\n                elif dict.get(word1[j]) == dict.get(word2[j]):\\n                    continue\\n                else:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 511557,
                "title": "python-solution-mapping-alien-alphabets-with-our-alphabets",
                "content": "First, I have mapped alien alphabet with our English alphabets according to the order of occurence. Then sorting the list and checking if sorted list is equal to the given list `words`. \\n\\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        alpha = \"abcdefghijklmnopqrstuvwxyz\"\\n        d = {key: val for key, val in zip(order, alpha)}\\n        return words == sorted(words, key=lambda word: \\'\\'.join(map(d.get, word)))\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        alpha = \"abcdefghijklmnopqrstuvwxyz\"\\n        d = {key: val for key, val in zip(order, alpha)}\\n        return words == sorted(words, key=lambda word: \\'\\'.join(map(d.get, word)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442685,
                "title": "simple-0ms-java-solution-for-slow-learners-like-myself",
                "content": "```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        if (words == null || words.length == 0)\\n            return true;\\n        if (order == null || order.length() != 26)\\n            return false;\\n        int[] dict = getDict(order);\\n        for (int i = 1; i < words.length; i++) {\\n            if (!isLessThanOrEqualTo(dict, words[i - 1], words[i]))\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isLessThanOrEqualTo(int[] dict, String a, String b) {\\n        for (int i = 0; i < Math.min(a.length(), b.length()); i++) {\\n            char ac = a.charAt(i), bc = b.charAt(i);\\n            if (ac != bc)\\n                return dict[ac - \\'a\\'] < dict[bc - \\'a\\'];\\n        }\\n        return a.length() <= b.length();\\n    }\\n    \\n    private int[] getDict(String order) {\\n        int[] dict = new int[26];\\n        for (int i = 0; i < order.length(); i++) {\\n            char c = order.charAt(i);\\n            dict[c - \\'a\\'] = i;\\n        }\\n        return dict;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        if (words == null || words.length == 0)\\n            return true;\\n        if (order == null || order.length() != 26)\\n            return false;\\n        int[] dict = getDict(order);\\n        for (int i = 1; i < words.length; i++) {\\n            if (!isLessThanOrEqualTo(dict, words[i - 1], words[i]))\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isLessThanOrEqualTo(int[] dict, String a, String b) {\\n        for (int i = 0; i < Math.min(a.length(), b.length()); i++) {\\n            char ac = a.charAt(i), bc = b.charAt(i);\\n            if (ac != bc)\\n                return dict[ac - \\'a\\'] < dict[bc - \\'a\\'];\\n        }\\n        return a.length() <= b.length();\\n    }\\n    \\n    private int[] getDict(String order) {\\n        int[] dict = new int[26];\\n        for (int i = 0; i < order.length(); i++) {\\n            char c = order.charAt(i);\\n            dict[c - \\'a\\'] = i;\\n        }\\n        return dict;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139857,
                "title": "day-33-c-easiest-beginner-friendly-sol-o-n-m-time-and-o-1-space",
                "content": "# Intuition of this Problem:\\n![WhatsApp Image 2023-02-04 at 2.52.00 PM.jpeg](https://assets.leetcode.com/users/images/9da1c212-610d-4fc0-8e20-110b1ca06c74_1675502542.7165763.jpeg)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Create a hash map charOrder to store the order of each letter in the given order.\\n2. Loop over the words and compare each pair of adjacent words.\\n3. For each comparison, loop through the length of the shorter word and compare each corresponding letter in the two words.\\n4. If the first different letter in two words has a larger order in charOrder, return false.\\n5. If one word is a prefix of another word, return false.\\n6. If all the comparisons pass, return true.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        unordered_map<char, int> charOrder;\\n        for (int i = 0; i < order.size(); i++) {\\n            charOrder[order[i]] = i;\\n        }\\n        for (int i = 0; i < words.size() - 1; i++) {\\n            string word1 = words[i];\\n            string word2 = words[i + 1];\\n            int len = min(word1.size(), word2.size());\\n            for (int j = 0; j < len; j++) {\\n                if (word1[j] != word2[j]) {\\n                    if (charOrder[word1[j]] > charOrder[word2[j]]) {\\n                        return false;\\n                    } else {\\n                        break;\\n                    }\\n                }\\n            }\\n            if (word1.size() > word2.size() && word1.substr(0, word2.size()) == word2)  {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```\\n```Java []\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        Map<Character, Integer> charOrder = new HashMap<>();\\n        for (int i = 0; i < order.length(); i++) {\\n            charOrder.put(order.charAt(i), i);\\n        }\\n        for (int i = 0; i < words.length - 1; i++) {\\n            String word1 = words[i];\\n            String word2 = words[i + 1];\\n            int len = Math.min(word1.length(), word2.length());\\n            for (int j = 0; j < len; j++) {\\n                if (word1.charAt(j) != word2.charAt(j)) {\\n                    if (charOrder.get(word1.charAt(j)) > charOrder.get(word2.charAt(j))) {\\n                        return false;\\n                    } else {\\n                        break;\\n                    }\\n                }\\n            }\\n            if (word1.length() > word2.length() && word1.substring(0, word2.length()).equals(word2)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        charOrder = {}\\n        for i in range(len(order)):\\n            charOrder[order[i]] = i\\n        for i in range(len(words) - 1):\\n            word1 = words[i]\\n            word2 = words[i + 1]\\n            len_ = min(len(word1), len(word2))\\n            for j in range(len_):\\n                if word1[j] != word2[j]:\\n                    if charOrder[word1[j]] > charOrder[word2[j]]:\\n                        return False\\n                    else:\\n                        break\\n            if len(word1) > len(word2) and word1[:len(word2)] == word2:\\n                return False\\n        return True\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n*m)**, where n is the number of words, and m is the average length of the words. We need to compare each pair of adjacent words, so the time complexity is O(n). In each comparison, we need to loop through the length of the shorter word, so the time complexity is O(m). Therefore, the overall time complexity is O(n * m).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(26) = O(1)**, where 26 is the number of letters in the alphabet. We only need to store the order of each letter in a hash map, which takes O(26) space. Since the number of letters is a constant, we can say the space complexity is O(1).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        unordered_map<char, int> charOrder;\\n        for (int i = 0; i < order.size(); i++) {\\n            charOrder[order[i]] = i;\\n        }\\n        for (int i = 0; i < words.size() - 1; i++) {\\n            string word1 = words[i];\\n            string word2 = words[i + 1];\\n            int len = min(word1.size(), word2.size());\\n            for (int j = 0; j < len; j++) {\\n                if (word1[j] != word2[j]) {\\n                    if (charOrder[word1[j]] > charOrder[word2[j]]) {\\n                        return false;\\n                    } else {\\n                        break;\\n                    }\\n                }\\n            }\\n            if (word1.size() > word2.size() && word1.substr(0, word2.size()) == word2)  {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```\n```Java []\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        Map<Character, Integer> charOrder = new HashMap<>();\\n        for (int i = 0; i < order.length(); i++) {\\n            charOrder.put(order.charAt(i), i);\\n        }\\n        for (int i = 0; i < words.length - 1; i++) {\\n            String word1 = words[i];\\n            String word2 = words[i + 1];\\n            int len = Math.min(word1.length(), word2.length());\\n            for (int j = 0; j < len; j++) {\\n                if (word1.charAt(j) != word2.charAt(j)) {\\n                    if (charOrder.get(word1.charAt(j)) > charOrder.get(word2.charAt(j))) {\\n                        return false;\\n                    } else {\\n                        break;\\n                    }\\n                }\\n            }\\n            if (word1.length() > word2.length() && word1.substring(0, word2.length()).equals(word2)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        charOrder = {}\\n        for i in range(len(order)):\\n            charOrder[order[i]] = i\\n        for i in range(len(words) - 1):\\n            word1 = words[i]\\n            word2 = words[i + 1]\\n            len_ = min(len(word1), len(word2))\\n            for j in range(len_):\\n                if word1[j] != word2[j]:\\n                    if charOrder[word1[j]] > charOrder[word2[j]]:\\n                        return False\\n                    else:\\n                        break\\n            if len(word1) > len(word2) and word1[:len(word2)] == word2:\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130961,
                "title": "short-and-easy-three-lines-of-linq-with-explanation",
                "content": "```csharp\\npublic class Solution\\n{\\n    public bool IsAlienSorted(string[] words, string order)\\n    {\\n        var alphabet = Enumerable.Range(0, 26).ToDictionary(i => order[i], i => (char)(\\'a\\' + i));\\n        var translated = words.Select(w => string.Concat(w.Select(c => alphabet[c])));\\n        return translated.OrderBy(x => x).SequenceEqual(translated);\\n    }\\n}\\n```\\n\\n# Explanation\\n\\n**Line 1: Create the alphabet**\\n\\nLet\\'s juxtapose the alien alphabet and ours. The first line creates a map of this kind:\\n```\\nAlien char -> Human char\\n\\'h\\'           \\'a\\'\\n\\'l\\'           \\'b\\'\\n\\'k\\'           \\'c\\'\\n\\'o\\'           \\'d\\'\\n\\'w\\'           \\'e\\'\\n...\\n```\\n\\n**Line 2: Translate the words**\\n\\nUsing the alphabet map, we then translate the alien words into our language. So, for each alien word:\\n1. Map each character of the word onto our alphabet with `Select(c => alphabet[c])`\\n2. Concatenate the characters back to a string with `string.Concat`\\n\\n> Please note that it would be better to enumerate the sequence by using `ToArray()`, otherwise it will be enumerated twice in the last step. I have omitted `ToArray()` to shorten the code.\\n\\n**Line 3: Compare**\\n\\nSort the translated words lexicographically and compare their order with the original one.\\n\\n# If you don\\'t like LINQ...\\nJust in case, here is a version with almost no LINQ:\\n\\n```csharp\\npublic class Solution\\n{\\n    public bool IsAlienSorted(string[] words, string order)\\n    {\\n        // Line 1\\n        Dictionary<char, char> alphabet = new();\\n        for (int i = 0; i < 26; i++)\\n        {\\n            alphabet.Add(order[i], (char)(\\'a\\' + i));\\n        }\\n\\n        // Line 2\\n        var translated = new string[words.Length];\\n        for (int i = 0; i < words.Length; i++)\\n        {\\n            StringBuilder translation = new();\\n            foreach (char c in words[i])\\n            {\\n                translation.Append(alphabet[c]);\\n            }\\n            translated[i] = translation.ToString();\\n        }\\n\\n        // Line 3\\n        return translated.OrderBy(x => x).SequenceEqual(translated);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public bool IsAlienSorted(string[] words, string order)\\n    {\\n        var alphabet = Enumerable.Range(0, 26).ToDictionary(i => order[i], i => (char)(\\'a\\' + i));\\n        var translated = words.Select(w => string.Concat(w.Select(c => alphabet[c])));\\n        return translated.OrderBy(x => x).SequenceEqual(translated);\\n    }\\n}\\n```\n```\\nAlien char -> Human char\\n\\'h\\'           \\'a\\'\\n\\'l\\'           \\'b\\'\\n\\'k\\'           \\'c\\'\\n\\'o\\'           \\'d\\'\\n\\'w\\'           \\'e\\'\\n...\\n```\n```csharp\\npublic class Solution\\n{\\n    public bool IsAlienSorted(string[] words, string order)\\n    {\\n        // Line 1\\n        Dictionary<char, char> alphabet = new();\\n        for (int i = 0; i < 26; i++)\\n        {\\n            alphabet.Add(order[i], (char)(\\'a\\' + i));\\n        }\\n\\n        // Line 2\\n        var translated = new string[words.Length];\\n        for (int i = 0; i < words.Length; i++)\\n        {\\n            StringBuilder translation = new();\\n            foreach (char c in words[i])\\n            {\\n                translation.Append(alphabet[c]);\\n            }\\n            translated[i] = translation.ToString();\\n        }\\n\\n        // Line 3\\n        return translated.OrderBy(x => x).SequenceEqual(translated);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129785,
                "title": "0ms-runtime-java-100-faster",
                "content": "# Code\\n``` Java []\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        for (int i = 0; i < words.length - 1; i++) {\\n            if (!isInOrder(words[i], words[i+1], order)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean isInOrder(String word1, String word2, String order) {\\n        boolean word1ShorterOrEq = word1.length() <= word2.length();\\n        int shorterWordLen = word1ShorterOrEq ? word1.length() : word2.length();\\n        for (int i = 0; i < shorterWordLen; i++) {\\n            int index1 = order.indexOf(word1.charAt(i));\\n            int index2 = order.indexOf(word2.charAt(i));\\n            if (index1 < index2) {\\n                return true;\\n            } else if (index1 > index2) {\\n                return false;\\n            }\\n        }\\n        return word1ShorterOrEq;\\n    }\\n}\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/fedf7a2e-f694-427e-a583-f1a52ad32de9_1675313909.4887128.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` Java []\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        for (int i = 0; i < words.length - 1; i++) {\\n            if (!isInOrder(words[i], words[i+1], order)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean isInOrder(String word1, String word2, String order) {\\n        boolean word1ShorterOrEq = word1.length() <= word2.length();\\n        int shorterWordLen = word1ShorterOrEq ? word1.length() : word2.length();\\n        for (int i = 0; i < shorterWordLen; i++) {\\n            int index1 = order.indexOf(word1.charAt(i));\\n            int index2 = order.indexOf(word2.charAt(i));\\n            if (index1 < index2) {\\n                return true;\\n            } else if (index1 > index2) {\\n                return false;\\n            }\\n        }\\n        return word1ShorterOrEq;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941194,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char, char> mp;\\n        char x = \\'a\\';\\n        for(auto c: order) {\\n            mp[c] = x;\\n            x++;\\n        }\\n        for(int i=0; i<words.size(); i++) {\\n            for(int j=0; j<words[i].size(); j++) {\\n               words[i][j] = mp[words[i][j]];\\n            }\\n        }\\n        return is_sorted(words.begin(), words.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char, char> mp;\\n        char x = \\'a\\';\\n        for(auto c: order) {\\n            mp[c] = x;\\n            x++;\\n        }\\n        for(int i=0; i<words.size(); i++) {\\n            for(int j=0; j<words[i].size(); j++) {\\n               words[i][j] = mp[words[i][j]];\\n            }\\n        }\\n        return is_sorted(words.begin(), words.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825379,
                "title": "well-commented-easy-c-solution-simple",
                "content": "Upvote if you liked the solution.\\n```\\nclass Solution {\\npublic:\\n    bool sorted(string s,string t,unordered_map<char,int>& mp){\\n        int s_size=s.size(),t_size=t.size();\\n        int i=0;\\n        \\n        while(i<s_size && i<t_size){     \\n           \\n            if(mp[s[i]]<mp[t[i]]){\\n                //if any letter of first string is smaller return true as \\n                // it will follow dictionary rule\\n                return true;   \\n            }\\n            else if(mp[s[i]]>mp[t[i]]){\\n                //if any letter of first string is bigger that means it \\n                // violets dictionary rules and return false\\n                return false;   \\n            }\\n            //if both are same character then move to next character\\n            i++;\\n        }\\n        //if we reach here it means all characters are same till i\\n        // and one of them is reached its size\\n        // check if first is bigger then return false else return true\\n        if(i==t_size && i!=s_size)\\n            return false;\\n        return true;\\n    }\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        \\n        int strsize=order.size();\\n        int wsize=words.size();\\n        \\n        //maping of characters and their order\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<strsize;i++)\\n            mp[order[i]]=i;\\n        \\n        //finding if each pairs who are neighbors are sorted\\n        // ex if 1st and 2nd sorted and 2nd and 3rd are sorted then all 3 are sorted\\n        // else if any of them are not sorted we can break and say whole array is unsored\\n        \\n        for(int i=0;i<wsize-1;i++){\\n            if(sorted(words[i],words[i+1],mp)==false){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool sorted(string s,string t,unordered_map<char,int>& mp){\\n        int s_size=s.size(),t_size=t.size();\\n        int i=0;\\n        \\n        while(i<s_size && i<t_size){     \\n           \\n            if(mp[s[i]]<mp[t[i]]){\\n                //if any letter of first string is smaller return true as \\n                // it will follow dictionary rule\\n                return true;   \\n            }\\n            else if(mp[s[i]]>mp[t[i]]){\\n                //if any letter of first string is bigger that means it \\n                // violets dictionary rules and return false\\n                return false;   \\n            }\\n            //if both are same character then move to next character\\n            i++;\\n        }\\n        //if we reach here it means all characters are same till i\\n        // and one of them is reached its size\\n        // check if first is bigger then return false else return true\\n        if(i==t_size && i!=s_size)\\n            return false;\\n        return true;\\n    }\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        \\n        int strsize=order.size();\\n        int wsize=words.size();\\n        \\n        //maping of characters and their order\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<strsize;i++)\\n            mp[order[i]]=i;\\n        \\n        //finding if each pairs who are neighbors are sorted\\n        // ex if 1st and 2nd sorted and 2nd and 3rd are sorted then all 3 are sorted\\n        // else if any of them are not sorted we can break and say whole array is unsored\\n        \\n        for(int i=0;i<wsize-1;i++){\\n            if(sorted(words[i],words[i+1],mp)==false){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370816,
                "title": "python3-fast-and-easy-to-understand-28-ms-faster-than-96-25",
                "content": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        hm = {ch: i for i, ch in enumerate(order)}\\n\\n        prev_repr = list(hm[ch] for ch in words[0])\\n        for i in range(1, len(words)):\\n            cur_repr = list(hm[ch] for ch in words[i])\\n\\n            if cur_repr < prev_repr:\\n                return False\\n\\n            prev_repr = cur_repr\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        hm = {ch: i for i, ch in enumerate(order)}\\n\\n        prev_repr = list(hm[ch] for ch in words[0])\\n        for i in range(1, len(words)):\\n            cur_repr = list(hm[ch] for ch in words[i])\\n\\n            if cur_repr < prev_repr:\\n                return False\\n\\n            prev_repr = cur_repr\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149930,
                "title": "python-go-o-w-by-index-mapping-w-hint",
                "content": "Python O(w) by index mapping\\n\\n---\\n\\n**Hint**:\\n\\n1. Build the **index** <-> **character** **mapping relation** based on givern **alien order**\\n\\n2. **Convert** each word to **numerical mapping** by dictionary built in step #1\\n\\n3. **Check** each numerical mapping is **sorted** in **ascending order**\\n\\n---\\n\\n**Implementation** by index mapping in Python\\n\\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        \\n\\t\\t# Step 1:\\n\\t\\t# Build the index <-> character mapping relation based on givern alien order\\n\\t\\t\\n        ## dictionary\\n        # key: alien character\\n        # value: index of alien character\\n        char_idx_dict = { char: idx for idx, char in enumerate(order) }\\n        \\n        size = len(words)\\n        \\n\\t\\t\\n\\t\\t# Step 2:\\n        # Convert words to numerical mapping by dictionary\\n\\t\\t\\n        numerical_mapping = [[char_idx_dict[char] for char in word] for word in words]\\n        \\n\\t\\t\\n\\t\\t# Step 3:\\n        # Check numerical mapping is sorted in ascending order\\n\\t\\t\\n        for i in range(0, size-1):\\n            \\n            if numerical_mapping[i] > numerical_mapping[i+1]:\\n                \\n                # Reject if we find out-of-order\\n                return False\\n        \\n        # Accept, otherwise.\\n        return True\\n```\\n\\n---\\n\\n**Implementation** by index mapping in Go\\n\\n```\\nimport (\\n    \"unicode/utf8\"\\n)\\n\\nfunc isAlienSorted(words []string, order string) bool {\\n\\n\\t// Step 1:\\n\\t// Build the index <-> character mapping relation based on givern alien order\\n    charIdxMapping := make(map[rune]int)\\n    \\n    for idx, char := range order{\\n        charIdxMapping[char] = idx\\n    }\\n    \\n    // -------------------------------------------\\n    \\n\\t// Step 2:\\n\\t// Convert each word to numerical mapping by dictionary\\n\\t\\n    var inorder func(s1, s2 string)bool\\n    \\n    inorder = func(s1, s2 string) bool{\\n        \\n        size1, size2 := len(s1), len(s2)\\n        \\n        for idx := 0 ; idx < size1 && idx < size2 ; idx++{\\n            \\n            rune1, _ := utf8.DecodeRuneInString(s1[idx:])\\n            rune2, _ := utf8.DecodeRuneInString(s2[idx:])\\n            order1, order2 := charIdxMapping[ rune1 ], charIdxMapping[ rune2 ]\\n            \\n            if  order1 > order2 {\\n                return false\\n                \\n            }else if order1 < order2 {\\n                return true\\n            }\\n\\n        }\\n        \\n        return len(s1) <= len(s2)\\n    }\\n    \\n    \\n    // -------------------------------------------\\n    \\n\\t// Step 3:\\n\\t// Check each numerical mapping is sorted in ascending order\\n\\t\\n    for i:= 0; i < len(words)-1 ; i++{\\n        if !inorder(words[i], words[i+1]){\\n            return false\\n        }  \\n    }\\n    \\n    return true\\n}\\n\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about dictioanry](https://docs.python.org/3/tutorial/datastructures.html#dictionaries)\\n\\n[2] [Golang official docs about map[]](https://blog.golang.org/maps)\\n\\n[3] [Golang official docs about DecodeRuneInString](https://golang.org/pkg/unicode/utf8/#DecodeRuneInString)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        \\n\\t\\t# Step 1:\\n\\t\\t# Build the index <-> character mapping relation based on givern alien order\\n\\t\\t\\n        ## dictionary\\n        # key: alien character\\n        # value: index of alien character\\n        char_idx_dict = { char: idx for idx, char in enumerate(order) }\\n        \\n        size = len(words)\\n        \\n\\t\\t\\n\\t\\t# Step 2:\\n        # Convert words to numerical mapping by dictionary\\n\\t\\t\\n        numerical_mapping = [[char_idx_dict[char] for char in word] for word in words]\\n        \\n\\t\\t\\n\\t\\t# Step 3:\\n        # Check numerical mapping is sorted in ascending order\\n\\t\\t\\n        for i in range(0, size-1):\\n            \\n            if numerical_mapping[i] > numerical_mapping[i+1]:\\n                \\n                # Reject if we find out-of-order\\n                return False\\n        \\n        # Accept, otherwise.\\n        return True\\n```\n```\\nimport (\\n    \"unicode/utf8\"\\n)\\n\\nfunc isAlienSorted(words []string, order string) bool {\\n\\n\\t// Step 1:\\n\\t// Build the index <-> character mapping relation based on givern alien order\\n    charIdxMapping := make(map[rune]int)\\n    \\n    for idx, char := range order{\\n        charIdxMapping[char] = idx\\n    }\\n    \\n    // -------------------------------------------\\n    \\n\\t// Step 2:\\n\\t// Convert each word to numerical mapping by dictionary\\n\\t\\n    var inorder func(s1, s2 string)bool\\n    \\n    inorder = func(s1, s2 string) bool{\\n        \\n        size1, size2 := len(s1), len(s2)\\n        \\n        for idx := 0 ; idx < size1 && idx < size2 ; idx++{\\n            \\n            rune1, _ := utf8.DecodeRuneInString(s1[idx:])\\n            rune2, _ := utf8.DecodeRuneInString(s2[idx:])\\n            order1, order2 := charIdxMapping[ rune1 ], charIdxMapping[ rune2 ]\\n            \\n            if  order1 > order2 {\\n                return false\\n                \\n            }else if order1 < order2 {\\n                return true\\n            }\\n\\n        }\\n        \\n        return len(s1) <= len(s2)\\n    }\\n    \\n    \\n    // -------------------------------------------\\n    \\n\\t// Step 3:\\n\\t// Check each numerical mapping is sorted in ascending order\\n\\t\\n    for i:= 0; i < len(words)-1 ; i++{\\n        if !inorder(words[i], words[i+1]){\\n            return false\\n        }  \\n    }\\n    \\n    return true\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 580164,
                "title": "scala-solution-relies-on-zip-function",
                "content": "```scala\\nobject Solution {\\n    // compare letters at each common index, return first difference\\n\\t// if no difference exists, return None\\n\\t// firstDiff(\"dad\", \"dab\") => Some(\\'d\\', \\'b\\')\\n\\t// fistDiff(\"hello\", \"goodbye\") => Some(\\'h\\', \\'g\\')\\n\\t// firstDiff(\"cat\", \"cat\") => None\\n\\t// firstDiff(\"check\", \"checkers\") => None\\n    def firstDiff(w1: String, w2: String): Option[(Char, Char)] = {\\n        w1.zip(w2).find {\\n            case (a, b) => a != b\\n        }\\n    }\\n    \\n    def isAlienSorted(words: Array[String], order: String): Boolean = {\\n\\t    // get mapping from alien dictionary\\n        // \"dza\" => Map(\\'d\\' -> 0, \\'z\\' -> 1, \\'a\\' -> 2)\\n        val lexOrder = Map.empty[Char, Int] ++ order.zipWithIndex\\n        \\n        // check each pair of adjcent words, verify correct order in each\\n\\t\\t// you only need to check adjacent words since order is transitive. \\n\\t\\t// If word0 < word1 and word1 < word 2, then word0 < word2.\\n        val pairs = words.zip(words.drop(1))\\n        pairs.forall(pair => {\\n            // look for first different letter between words\\n            firstDiff(pair._1, pair._2) match {\\n                // letter of lower lex order should come first\\n                case Some((l1, l2)) => lexOrder(l1) < lexOrder(l2)\\n                // if both words share same prefix, longer word should come after\\n                case None => pair._1 < pair._2\\n            }\\n        })\\n    }\\n    \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```scala\\nobject Solution {\\n    // compare letters at each common index, return first difference\\n\\t// if no difference exists, return None\\n\\t// firstDiff(\"dad\", \"dab\") => Some(\\'d\\', \\'b\\')\\n\\t// fistDiff(\"hello\", \"goodbye\") => Some(\\'h\\', \\'g\\')\\n\\t// firstDiff(\"cat\", \"cat\") => None\\n\\t// firstDiff(\"check\", \"checkers\") => None\\n    def firstDiff(w1: String, w2: String): Option[(Char, Char)] = {\\n        w1.zip(w2).find {\\n            case (a, b) => a != b\\n        }\\n    }\\n    \\n    def isAlienSorted(words: Array[String], order: String): Boolean = {\\n\\t    // get mapping from alien dictionary\\n        // \"dza\" => Map(\\'d\\' -> 0, \\'z\\' -> 1, \\'a\\' -> 2)\\n        val lexOrder = Map.empty[Char, Int] ++ order.zipWithIndex\\n        \\n        // check each pair of adjcent words, verify correct order in each\\n\\t\\t// you only need to check adjacent words since order is transitive. \\n\\t\\t// If word0 < word1 and word1 < word 2, then word0 < word2.\\n        val pairs = words.zip(words.drop(1))\\n        pairs.forall(pair => {\\n            // look for first different letter between words\\n            firstDiff(pair._1, pair._2) match {\\n                // letter of lower lex order should come first\\n                case Some((l1, l2)) => lexOrder(l1) < lexOrder(l2)\\n                // if both words share same prefix, longer word should come after\\n                case None => pair._1 < pair._2\\n            }\\n        })\\n    }\\n    \\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 206472,
                "title": "javascript-9-lines-looking-for-feedback-thanks",
                "content": "1. We compare words in pairs to evaluate whether they are in the correct order or not.\\n2. If any single word is not in the correct order we can immediately return false.\\n3. Only if we have compared all pairs (first & second, second & third, ect..) can we deem they are in order.\\nSide Note: We can let the algorithm use out of bound indexes because indexOf(undefined) will always return -1.\\n```\\nvar isAlienSorted = function(words, order) {\\n    \\n    for(let i = 0; i < words.length-1; i++) {\\n        let length = Math.max(words[i].length, words[i+1].length);\\n        \\n        for(let j = 0; j < length; j++) {\\n            let a = order.indexOf(words[i][j]);\\n            let b = order.indexOf(words[i+1][j]);\\n         \\n            if(b < a) return false;\\n            else if(b > a)\\n                break;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isAlienSorted = function(words, order) {\\n    \\n    for(let i = 0; i < words.length-1; i++) {\\n        let length = Math.max(words[i].length, words[i+1].length);\\n        \\n        for(let j = 0; j < length; j++) {\\n            let a = order.indexOf(words[i][j]);\\n            let b = order.indexOf(words[i+1][j]);\\n         \\n            if(b < a) return false;\\n            else if(b > a)\\n                break;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3133668,
                "title": "simple-solution-using-python-beats-98",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isAlienSorted(self, words, order):\\n        \"\"\"\\n        :type words: List[str]\\n        :type order: str\\n        :rtype: bool\\n        \"\"\"\\n        dic={}\\n        for i in range(26):\\n            dic[order[i]] = i\\n        \\n        def check (str1, str2, dic):\\n            mn = min(len(str1),len(str2))\\n            for i in range(mn):\\n                if str1[i] != str2[i] :\\n                   return dic[str1[i]] > dic[str2[i]]\\n    \\n            return len(str1) > len(str2)\\n        \\n\\n        for i in range(1,len(words)):\\n            if check(words[i-1],words[i],dic):\\n                return False\\n        return True\\n\\n\\n\\n       \\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isAlienSorted(self, words, order):\\n        \"\"\"\\n        :type words: List[str]\\n        :type order: str\\n        :rtype: bool\\n        \"\"\"\\n        dic={}\\n        for i in range(26):\\n            dic[order[i]] = i\\n        \\n        def check (str1, str2, dic):\\n            mn = min(len(str1),len(str2))\\n            for i in range(mn):\\n                if str1[i] != str2[i] :\\n                   return dic[str1[i]] > dic[str2[i]]\\n    \\n            return len(str1) > len(str2)\\n        \\n\\n        for i in range(1,len(words)):\\n            if check(words[i-1],words[i],dic):\\n                return False\\n        return True\\n\\n\\n\\n       \\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130561,
                "title": "c-use-hashmap-simple-approach",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) \\n    {\\n        unordered_map<char, int> mp; \\n\\n        //storing letters and their position in mp\\n        for(int i=0; i<order.size(); i++)\\n            mp[order[i]] = i;\\n\\n        //comparing two consecutive words \\n        for(int i=0; i<words.size()-1; i++)\\n        {\\n            int j=0;\\n            while(j<words[i].size() && j<words[i+1].size()) //comparing each letter of words\\n            {\\n                //If words pair are already sorted we move to next word pair\\n                if(mp[words[i][j]] < mp[words[i+1][j]]) break; \\n\\n                //If they are not sorted we return false\\n                if(mp[words[i][j]] > mp[words[i+1][j]]) return false;\\n                j++;\\n            }\\n            //for handling cases like Example 3\\n            if(j==words[i+1].size() && j<words[i].size()) return false; \\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n# Please upvote if you like this approach :)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) \\n    {\\n        unordered_map<char, int> mp; \\n\\n        //storing letters and their position in mp\\n        for(int i=0; i<order.size(); i++)\\n            mp[order[i]] = i;\\n\\n        //comparing two consecutive words \\n        for(int i=0; i<words.size()-1; i++)\\n        {\\n            int j=0;\\n            while(j<words[i].size() && j<words[i+1].size()) //comparing each letter of words\\n            {\\n                //If words pair are already sorted we move to next word pair\\n                if(mp[words[i][j]] < mp[words[i+1][j]]) break; \\n\\n                //If they are not sorted we return false\\n                if(mp[words[i][j]] > mp[words[i+1][j]]) return false;\\n                j++;\\n            }\\n            //for handling cases like Example 3\\n            if(j==words[i+1].size() && j<words[i].size()) return false; \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130085,
                "title": "easily-understandable-c-hashmap-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore the order of the indexes in the HashMap, compare the characters of the one string to another.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Declare a HashMap, which stores index of characters of the string order.\\n2.Loop1:Traverse the vector words upto last but one string\\n3.Loop2:Traverse the word upto minimum length of string[i],string[i+1]\\n4.We have to compare the HashMap values of characters.\\n5.If they are equal, we have to check the values of the next character\\n6.If it is non-increasing, then we have to return false\\n7.Else break the inner loop, and continue checking the next words\\n8.End of Loop2\\n8.Check, if we reached the end of the inner loop and (length of string[i])>length of string[i+1] return false\\n9.End of Loop1\\n10.Return true\\n\\n# Complexity\\n- Time complexity: $$O(N*M)$$ :-Total number of words * Total number of characters in individual string\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ :- Because HashMap size never exceeds 26.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        unordered_map<char,int>m;\\n        for(int i=0;i<order.size();i++){\\n            m[order[i]]=i;\\n        }\\n        bool ans=true;\\n        for(int i=0;i<words.size()-1;i++){            \\n            int j=0,len=min(words[i].size(),words[i+1].size());\\n            for(;j<len;j++){\\n                if(m[words[i][j]]==m[words[i+1][j]]){\\n                    continue;\\n                }\\n                else if(m[words[i][j]]>m[words[i+1][j]])\\n                {\\n                    ans=false;\\n                    break;\\n                }\\n                else \\n                {\\n                    break;//This is condition where they are in proper order, \\n                         //so we\\'ll break this inner loop (no need to proceed further)\\n                } \\n            }\\n            if(j==len && words[i].size()>words[i+1].size()) \\n                ans=false; //used for cases like [\"apple\",\"app\"],they are same untill now.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        unordered_map<char,int>m;\\n        for(int i=0;i<order.size();i++){\\n            m[order[i]]=i;\\n        }\\n        bool ans=true;\\n        for(int i=0;i<words.size()-1;i++){            \\n            int j=0,len=min(words[i].size(),words[i+1].size());\\n            for(;j<len;j++){\\n                if(m[words[i][j]]==m[words[i+1][j]]){\\n                    continue;\\n                }\\n                else if(m[words[i][j]]>m[words[i+1][j]])\\n                {\\n                    ans=false;\\n                    break;\\n                }\\n                else \\n                {\\n                    break;//This is condition where they are in proper order, \\n                         //so we\\'ll break this inner loop (no need to proceed further)\\n                } \\n            }\\n            if(j==len && words[i].size()>words[i+1].size()) \\n                ans=false; //used for cases like [\"apple\",\"app\"],they are same untill now.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129676,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        unordered_map<char, int> mp;\\n        for(int i=0;i<order.size();i++) mp[order[i]] = i;\\n        for(int i=1;i<words.size();i++) {\\n            string str1 = words[i-1];\\n            string str2 = words[i];\\n            int x = 0, y = 0;\\n            while(x < str1.length() && y < str2.length()) {\\n                if(str1[x] == str2[y]) {\\n                    x++; y++;\\n                }else {\\n                   if(str1[x] != str2[y] && mp[str1[x]] > mp[str2[y]]) {\\n                        return false;\\n                    }else break;\\n                }\\n            }\\n            if(x < str1.length() && y == str2.length()) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        unordered_map<char, int> mp;\\n        for(int i=0;i<order.size();i++) mp[order[i]] = i;\\n        for(int i=1;i<words.size();i++) {\\n            string str1 = words[i-1];\\n            string str2 = words[i];\\n            int x = 0, y = 0;\\n            while(x < str1.length() && y < str2.length()) {\\n                if(str1[x] == str2[y]) {\\n                    x++; y++;\\n                }else {\\n                   if(str1[x] != str2[y] && mp[str1[x]] > mp[str2[y]]) {\\n                        return false;\\n                    }else break;\\n                }\\n            }\\n            if(x < str1.length() && y == str2.length()) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836262,
                "title": "python3-beginner-solution",
                "content": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        return (words == sorted(words, key=lambda word: [order.index(letter) for letter in word]))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        return (words == sorted(words, key=lambda word: [order.index(letter) for letter in word]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206464,
                "title": "python3-simple-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        l1 = {c:i for i,c in enumerate(order)}\\n        l2 = [[l1[i] for i in word] for word in words]\\n        return l2 == sorted(l2)\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        l1 = {c:i for i,c in enumerate(order)}\\n        l2 = [[l1[i] for i in word] for word in words]\\n        return l2 == sorted(l2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151061,
                "title": "simple-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,int>mp;\\n        for(int i=0;i<26;i++)\\n            mp[order[i]]=(i+1);\\n        for (int i = 0; i < words.size() - 1; i++) \\n        {\\n            int f=0,s=0;\\n            string first=words[i];\\n            string second=words[i + 1];\\n            while (first[f]==second[s]) \\n            {\\n                f++;\\n                s++;\\n            }\\n            if (mp[first[f]]>mp[second[s]])\\n                return false;\\n    }\\n         return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,int>mp;\\n        for(int i=0;i<26;i++)\\n            mp[order[i]]=(i+1);\\n        for (int i = 0; i < words.size() - 1; i++) \\n        {\\n            int f=0,s=0;\\n            string first=words[i];\\n            string second=words[i + 1];\\n            while (first[f]==second[s]) \\n            {\\n                f++;\\n                s++;\\n            }\\n            if (mp[first[f]]>mp[second[s]])\\n                return false;\\n    }\\n         return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654235,
                "title": "swift-24ms-68-21-2mb-50-comments-and-easy-to-understand",
                "content": "```\\nclass Solution {\\n    func isAlienSorted(_ words: [String], _ order: String) -> Bool {\\n        var alphabet: [Character: Int] = [Character: Int]()\\n        \\n        // Creating a map like [[a: 1], [b: 2]] ect\\n        for (char,index) in order.enumerated() {\\n            alphabet[index] = char\\n        }\\n        \\n        for i in 0..<(words.count-1) {\\n            // Compare two words at one time, if it is valid continue, if not return false    \\n            if !isInOrder(words[i], words[i+1], alphabet) {\\n                return false\\n            }\\n        }\\n        \\n        return true\\n    }\\n    \\n    func isInOrder(_ word1: String, _ word2: String, _ alphabet: [Character: Int]) -> Bool {\\n        // Get minimum length of word\\n        let minLength: Int = min(word1.count, word2.count)\\n\\n        for i in 0..<minLength {\\n            let char1 = Array(word1)[i]\\n            let char2 = Array(word2)[i]\\n            \\n            // if two characters are same, doesnt need to look dictionary for values.\\n            guard char1 != char2 else { continue }\\n\\n            // Get value of character and compare them\\n            let value1 = alphabet[char1] ?? -1\\n            let value2 = alphabet[char2] ?? -1\\n            \\n            return value2 > value1\\n        }\\n        \\n        // If two words are like \"App\" - \"Apple\", their order should be word1, word2.\\n        return word1.count < word2.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isAlienSorted(_ words: [String], _ order: String) -> Bool {\\n        var alphabet: [Character: Int] = [Character: Int]()\\n        \\n        // Creating a map like [[a: 1], [b: 2]] ect\\n        for (char,index) in order.enumerated() {\\n            alphabet[index] = char\\n        }\\n        \\n        for i in 0..<(words.count-1) {\\n            // Compare two words at one time, if it is valid continue, if not return false    \\n            if !isInOrder(words[i], words[i+1], alphabet) {\\n                return false\\n            }\\n        }\\n        \\n        return true\\n    }\\n    \\n    func isInOrder(_ word1: String, _ word2: String, _ alphabet: [Character: Int]) -> Bool {\\n        // Get minimum length of word\\n        let minLength: Int = min(word1.count, word2.count)\\n\\n        for i in 0..<minLength {\\n            let char1 = Array(word1)[i]\\n            let char2 = Array(word2)[i]\\n            \\n            // if two characters are same, doesnt need to look dictionary for values.\\n            guard char1 != char2 else { continue }\\n\\n            // Get value of character and compare them\\n            let value1 = alphabet[char1] ?? -1\\n            let value2 = alphabet[char2] ?? -1\\n            \\n            return value2 > value1\\n        }\\n        \\n        // If two words are like \"App\" - \"Apple\", their order should be word1, word2.\\n        return word1.count < word2.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653589,
                "title": "python-python-trick-with-explanation",
                "content": "**Intuition**\\nEach char has a numeric value corresponding to its index in the order\\nOrdered chars proceed in ascending order\\nCompare each word to its neighbor and check if they are ordered\\n\\n**Python trick to simplify our code**\\nUsing the > operator python does most of the comparison work for us. > for lists works in the same way as it does for strings. It will compare the lists lexigraphically - starting from the start it checks the the first element on the left left is less than the first element on the right. Then it moves to the second element and so on. If two lists have different lengths but are the same up until the end of the shortest - the shortest list is considered less than the longer one. \\n\\n```\\n[1, 1] > [1] \\n[10, 2, 4] >[10, 2, 3, 11] \\n```\\n\\n```python\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        mapping = {char: i for i, char in enumerate(order)}\\n        alien_char_codes = [[mapping[char] for char in word] for word in words]\\n        \\n        for curr_word, next_word in zip(alien_char_codes, alien_char_codes[1:]):\\n            if curr_word > next_word:\\n                return False\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\n[1, 1] > [1] \\n[10, 2, 4] >[10, 2, 3, 11] \\n```\n```python\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        mapping = {char: i for i, char in enumerate(order)}\\n        alien_char_codes = [[mapping[char] for char in word] for word in words]\\n        \\n        for curr_word, next_word in zip(alien_char_codes, alien_char_codes[1:]):\\n            if curr_word > next_word:\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475857,
                "title": "easy-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        public bool IsAlienSorted(string[] words, string order)\\n        {\\n            IDictionary<char, int> char2Idx = new Dictionary<char, int>(26);\\n            for (int i = 0; i < 26; i++)\\n            {\\n                char2Idx.Add(order[i],i);\\n            }\\n\\n            for (int i = 0; i < words.Length - 1; i++)\\n            {\\n                int j = 0;\\n                int k = 0;\\n\\n                while (j != words[i].Length && k != words[i+1].Length)\\n                {\\n                    if (char2Idx[words[i + 1][k]] < char2Idx[words[i][j]])\\n                    {\\n                        return false;\\n                    }\\n                    \\n                    if(char2Idx[words[i + 1][k]] > char2Idx[words[i][j]])\\n                    {\\n                        break;\\n                    }\\n\\n                    j++;\\n                    k++;\\n                }\\n\\n\\n                if (k == words[i + 1].Length && j < words[i].Length)\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            return true;\\n        }\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        public bool IsAlienSorted(string[] words, string order)\\n        {\\n            IDictionary<char, int> char2Idx = new Dictionary<char, int>(26);\\n            for (int i = 0; i < 26; i++)\\n            {\\n                char2Idx.Add(order[i],i);\\n            }\\n\\n            for (int i = 0; i < words.Length - 1; i++)\\n            {\\n                int j = 0;\\n                int k = 0;\\n\\n                while (j != words[i].Length && k != words[i+1].Length)\\n                {\\n                    if (char2Idx[words[i + 1][k]] < char2Idx[words[i][j]])\\n                    {\\n                        return false;\\n                    }\\n                    \\n                    if(char2Idx[words[i + 1][k]] > char2Idx[words[i][j]])\\n                    {\\n                        break;\\n                    }\\n\\n                    j++;\\n                    k++;\\n                }\\n\\n\\n                if (k == words[i + 1].Length && j < words[i].Length)\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            return true;\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132649,
                "title": "java-easiest-solution-using-loops-beats-100-runtime-97-memory",
                "content": "# Approach\\nUsing the **indexOf** method, we get the **index** that the *letter comes in the given order* and then **comparing** both words order. If order of first word is lesser than the second word, we break out of the secondary loop, as we dont need to compare other letters (its lexographically correct), else if they are same, then comparing the next letters order and so on.\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public boolean isAlienSorted(String[] words, String order) \\n    {\\n        for(int i = 0; i < words.length - 1; i++)\\n        {\\n            String word1 = words[i];\\n            String word2 = words[i+1];\\n\\n            //finding the max len for traversing\\n            int len = Math.max(word1.length(), word2.length());\\n\\n            for(int j = 0; j < len; j++)\\n            {\\n                //as the index starts from 0\\n                int index1 = -1;\\n                int index2 = -1;\\n\\n                //getting the order\\n                if(j < word1.length())\\n                    index1 = order.indexOf(word1.charAt(j));\\n\\n                if(j < word2.length())\\n                    index2 = order.indexOf(word2.charAt(j));\\n\\n                //order of word 1 is less than word 2, then break.\\n                //as its in lexographic order\\n                if(index1 < index2)\\n                    break;\\n\\n                //if word 2\\'s order is larger than word 1 order\\n                else if(index2 < index1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Iterator"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean isAlienSorted(String[] words, String order) \\n    {\\n        for(int i = 0; i < words.length - 1; i++)\\n        {\\n            String word1 = words[i];\\n            String word2 = words[i+1];\\n\\n            //finding the max len for traversing\\n            int len = Math.max(word1.length(), word2.length());\\n\\n            for(int j = 0; j < len; j++)\\n            {\\n                //as the index starts from 0\\n                int index1 = -1;\\n                int index2 = -1;\\n\\n                //getting the order\\n                if(j < word1.length())\\n                    index1 = order.indexOf(word1.charAt(j));\\n\\n                if(j < word2.length())\\n                    index2 = order.indexOf(word2.charAt(j));\\n\\n                //order of word 1 is less than word 2, then break.\\n                //as its in lexographic order\\n                if(index1 < index2)\\n                    break;\\n\\n                //if word 2\\'s order is larger than word 1 order\\n                else if(index2 < index1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132033,
                "title": "very-easy-beginner-friendly-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        unordered_map<char,char> ans;\\n        for(int i=0;i<26;i++){\\n            ans[order[i]]= (\\'a\\'+i);\\n        }\\n        for(int i=0;i<words.size();i++){\\n            for(int j=0;j<words[i].size();j++){\\n                words[i][j]= ans[words[i][j]];\\n            }\\n        }\\n        return is_sorted(words.begin(),words.end());\\n    }\\n};\\n```\\n![leetcode upvote.jpg](https://assets.leetcode.com/users/images/4fa434c2-c48d-4e8f-9ac4-ef063b13e474_1675348677.1285906.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        unordered_map<char,char> ans;\\n        for(int i=0;i<26;i++){\\n            ans[order[i]]= (\\'a\\'+i);\\n        }\\n        for(int i=0;i<words.size();i++){\\n            for(int j=0;j<words[i].size();j++){\\n                words[i][j]= ans[words[i][j]];\\n            }\\n        }\\n        return is_sorted(words.begin(),words.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129848,
                "title": "java-c-100-solution-using-hashing-verifying-an-alien-dictionary",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ where n be the total number of characters in words\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        Map<Character,Integer> rank = new HashMap<>();\\n        for(int i=0;i<26;i++)\\n            rank.put(order.charAt(i),i);\\n\\n        for(int i=0;i<words.length-1;i++)\\n        {\\n            for(int j=0;j<words[i].length();j++)\\n            {\\n                if (j >= words[i + 1].length()) \\n                    return false;\\n                if(words[i].charAt(j)!=words[i+1].charAt(j))\\n                {\\n                    if(rank.get(words[i].charAt(j)) > rank.get(words[i+1].charAt(j)))\\n                        return false;\\n                    else\\n                        break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,int> rank;\\n        for(int i=0;i<26;i++)\\n            rank[order[i]] = i;\\n\\n        for(int i=0;i<words.size()-1;i++)\\n        {\\n            for(int j=0;j<words[i].length();j++)\\n            {\\n                if (j >= words[i + 1].length()) \\n                    return false;\\n                if(words[i][j]!=words[i+1][j])\\n                {\\n                    if(rank[words[i][j]] > rank[words[i+1][j]])\\n                        return false;\\n                    else\\n                        break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```Java []\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        Map<Character,Integer> rank = new HashMap<>();\\n        for(int i=0;i<26;i++)\\n            rank.put(order.charAt(i),i);\\n\\n        for(int i=0;i<words.length-1;i++)\\n        {\\n            for(int j=0;j<words[i].length();j++)\\n            {\\n                if (j >= words[i + 1].length()) \\n                    return false;\\n                if(words[i].charAt(j)!=words[i+1].charAt(j))\\n                {\\n                    if(rank.get(words[i].charAt(j)) > rank.get(words[i+1].charAt(j)))\\n                        return false;\\n                    else\\n                        break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,int> rank;\\n        for(int i=0;i<26;i++)\\n            rank[order[i]] = i;\\n\\n        for(int i=0;i<words.size()-1;i++)\\n        {\\n            for(int j=0;j<words[i].length();j++)\\n            {\\n                if (j >= words[i + 1].length()) \\n                    return false;\\n                if(words[i][j]!=words[i+1][j])\\n                {\\n                    if(rank[words[i][j]] > rank[words[i+1][j]])\\n                        return false;\\n                    else\\n                        break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129459,
                "title": "100-javascript-fast-very-very-easy-to-understand-solution-with-video-explanation-en-kr",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nEnglish video!\\n\\nhttps://youtu.be/NvWx62tRIAc\\n\\nKorean video!\\n\\nhttps://youtu.be/gC8W9leWuJU\\n\\n![image.png](https://assets.leetcode.com/users/images/53d9b2a5-203c-4bc5-84c2-cf50a26d27ef_1675307066.3914409.png)\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} order\\n * @return {boolean}\\n */\\nvar isAlienSorted = function(words, order) {\\n    let orderMap = {}\\n    for(let o =0; o < order.length; o++){\\n        orderMap[order[o]] = o;\\n    }\\n\\n    let isValidate = (c,p) =>{\\n        let len = c.length < p.length ? c.length : p.length;\\n        \\n        for(let i =0; i<len; i++){\\n            if(orderMap[c[i]] > orderMap[p[i]]) return true;\\n            if(orderMap[c[i]] < orderMap[p[i]]) return false;\\n        }\\n        return c.length >= p.length;\\n    }\\n    for(let i =1; i<words.length;i++){\\n        if(!isValidate(words[i],words[i-1])) return false;\\n    }\\n    return true; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} order\\n * @return {boolean}\\n */\\nvar isAlienSorted = function(words, order) {\\n    let orderMap = {}\\n    for(let o =0; o < order.length; o++){\\n        orderMap[order[o]] = o;\\n    }\\n\\n    let isValidate = (c,p) =>{\\n        let len = c.length < p.length ? c.length : p.length;\\n        \\n        for(let i =0; i<len; i++){\\n            if(orderMap[c[i]] > orderMap[p[i]]) return true;\\n            if(orderMap[c[i]] < orderMap[p[i]]) return false;\\n        }\\n        return c.length >= p.length;\\n    }\\n    for(let i =1; i<words.length;i++){\\n        if(!isValidate(words[i],words[i-1])) return false;\\n    }\\n    return true; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3129245,
                "title": "easy-explanation-playing-with-ascii-value-explanation-with-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhat changes we are having now with our English LowerCase letter? Think about it.\\nJust one change that order is different.\\nThat means ascii value of a is now not 97.\\nWhat if we update ascii value of every character then it would give us desired solution. Isn\\'t it easy?\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust do one thing use an array of 26 size to store the order of every lowercase 26 character.\\nLets say this alien dictionary order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nthen h = 0, l = 1, a =2 , b = 3 .  . .  . . . \\n\\nOnce this done just traverse over the words array and compare if any character have value less than other that means it is smaller than that other character.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n-> O(N*M)\\n-> where N = length of words , M =  max length of words[i]\\n\\n-> M is 20 in this case so, O(N) will be good to say. :)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n-> O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        // Brute Force\\n        // Assign number from 0 to 25 to the order from left to right \\n        int num[26];\\n        for (int i =0 ;i<order.length();i++){\\n            int idx = order[i] - \\'a\\'; // getting idx value for character (a = 0 , b =1, c = 2 , d = 3 .....)\\n            num[idx] = i;\\n        }\\n\\n        bool res = true; // result which will keep updating as we compare\\n\\n        for(int i = 1;i<words.size();i++){ // traversing from words[1] to words[n-1]\\n\\n            // Everytime we have to take previous and curr word to compare\\n            string first = words[i-1];  // previous word   \\n            string second = words[i];   // curr word\\n            int j =0;\\n            for(j;j<min(first.length(),second.length());j++){ // comparing word\\n                if (second[j]==first[j]) continue; // if character same means sorted but don\\'t know about next char\\n                if (num[second[j]-\\'a\\']>num[first[j]-\\'a\\']) break; // if second word\\'s character bigger, means sorted for sure so break\\n                if (num[second[j]-\\'a\\']<num[first[j]-\\'a\\']) {   // if second word\\'s smaller then means unsorted for sure so , res = false\\n                    res = false;\\n                    break;\\n                }\\n            }\\n\\n            // Let say z<first = \"reel\" , second = \"reelz\"\\n            // Then it should be false\\n            if (second.length()<first.length() && j==second.length()) res = false; // if second is smaller and all character are same then res = false\\n            \\n\\n            if(res==false) break; // no need to traverse if we found single conflict\\n        }\\n        return res; // return at the end\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        // Brute Force\\n        // Assign number from 0 to 25 to the order from left to right \\n        int num[26];\\n        for (int i =0 ;i<order.length();i++){\\n            int idx = order[i] - \\'a\\'; // getting idx value for character (a = 0 , b =1, c = 2 , d = 3 .....)\\n            num[idx] = i;\\n        }\\n\\n        bool res = true; // result which will keep updating as we compare\\n\\n        for(int i = 1;i<words.size();i++){ // traversing from words[1] to words[n-1]\\n\\n            // Everytime we have to take previous and curr word to compare\\n            string first = words[i-1];  // previous word   \\n            string second = words[i];   // curr word\\n            int j =0;\\n            for(j;j<min(first.length(),second.length());j++){ // comparing word\\n                if (second[j]==first[j]) continue; // if character same means sorted but don\\'t know about next char\\n                if (num[second[j]-\\'a\\']>num[first[j]-\\'a\\']) break; // if second word\\'s character bigger, means sorted for sure so break\\n                if (num[second[j]-\\'a\\']<num[first[j]-\\'a\\']) {   // if second word\\'s smaller then means unsorted for sure so , res = false\\n                    res = false;\\n                    break;\\n                }\\n            }\\n\\n            // Let say z<first = \"reel\" , second = \"reelz\"\\n            // Then it should be false\\n            if (second.length()<first.length() && j==second.length()) res = false; // if second is smaller and all character are same then res = false\\n            \\n\\n            if(res==false) break; // no need to traverse if we found single conflict\\n        }\\n        return res; // return at the end\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469572,
                "title": "javascript-simple-and-fast-hashmap-o-n-solution",
                "content": "```\\nfunction isAlienSorted(words, alphabet) {\\n    const map = {};\\n\\n    for (let i = 0; i < alphabet.length; i++) {\\n        map[alphabet[i]] = i + 1;\\n    }\\n\\n    for (let i = 0; i < words.length - 1; i++) {\\n        for (let j = 0; j < words[i].length; j++) {\\n            if(j >= words[i + 1].length) {\\n                return false;\\n            }\\n\\n            if(words[i][j] === words[i + 1][j]) {\\n                continue;\\n            }\\n\\n            if(map[words[i][j]] > map[words[i + 1][j]]) {\\n                return false;\\n            }\\n\\n            break;\\n        }\\n    }\\n\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction isAlienSorted(words, alphabet) {\\n    const map = {};\\n\\n    for (let i = 0; i < alphabet.length; i++) {\\n        map[alphabet[i]] = i + 1;\\n    }\\n\\n    for (let i = 0; i < words.length - 1; i++) {\\n        for (let j = 0; j < words[i].length; j++) {\\n            if(j >= words[i + 1].length) {\\n                return false;\\n            }\\n\\n            if(words[i][j] === words[i + 1][j]) {\\n                continue;\\n            }\\n\\n            if(map[words[i][j]] > map[words[i + 1][j]]) {\\n                return false;\\n            }\\n\\n            break;\\n        }\\n    }\\n\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2278541,
                "title": "c-sol-5-lines-code-better-than-96-without-using-maps-easy",
                "content": "```\\nbool isAlienSorted(vector<string>& words, string order) {\\n        int mapping[26];\\n        for (int i = 0; i < 26; i++)     mapping[order[i] - \\'a\\'] = i;\\n        for (string &w : words)\\n            for (char &c : w)      c = mapping[c - \\'a\\'];\\n        return is_sorted(words.begin(), words.end());\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool isAlienSorted(vector<string>& words, string order) {\\n        int mapping[26];\\n        for (int i = 0; i < 26; i++)     mapping[order[i] - \\'a\\'] = i;\\n        for (string &w : words)\\n            for (char &c : w)      c = mapping[c - \\'a\\'];\\n        return is_sorted(words.begin(), words.end());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1920764,
                "title": "python-1-liner",
                "content": "First sort the words based on custom comparator, which uses each letters index on the order key.\\nThen check if the sorted one is same as the given.\\n```\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        return words == sorted(words, key=lambda word:[order.index(c) for c in word])\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        return words == sorted(words, key=lambda word:[order.index(c) for c in word])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1151032,
                "title": "java-simple-and-easy-to-understand-o-n-wl-0-ms-faster-than-100-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int[] charOrder = new int[26];\\n        \\n        for(int i = 0; i < 26; i++){\\n            charOrder[order.charAt(i) - \\'a\\'] = i; \\n        }\\n        \\n        for(int i = 1; i < words.length; i++){\\n            if(!isCorrectOrder(words[i - 1], words[i], charOrder)) return false;\\n        }\\n        \\n        \\n        return true;\\n    }\\n    \\n    private boolean isCorrectOrder(String str1, String str2, int[] charOrder){\\n        //str1 - first word\\n        //str2 - 2nd word\\n        int l1 = str1.length();\\n        int l2 = str2.length();\\n        \\n        if(str2.indexOf(str1) == 0) {\\n            return l2 >= l1;\\n        }\\n        \\n        if(str1.indexOf(str2) == 0) {\\n            return l1 == l2;\\n        }\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        while(i < l1 && j < l2){\\n            char c1 = str1.charAt(i++);\\n            char c2 = str2.charAt(j++);\\n            \\n            if(c1 == c2) continue;\\n            \\n            int pos1 = charOrder[c1 - \\'a\\'];\\n            int pos2 = charOrder[c2 - \\'a\\'];\\n            \\n            return pos2 >= pos1;\\n        }\\n        \\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int[] charOrder = new int[26];\\n        \\n        for(int i = 0; i < 26; i++){\\n            charOrder[order.charAt(i) - \\'a\\'] = i; \\n        }\\n        \\n        for(int i = 1; i < words.length; i++){\\n            if(!isCorrectOrder(words[i - 1], words[i], charOrder)) return false;\\n        }\\n        \\n        \\n        return true;\\n    }\\n    \\n    private boolean isCorrectOrder(String str1, String str2, int[] charOrder){\\n        //str1 - first word\\n        //str2 - 2nd word\\n        int l1 = str1.length();\\n        int l2 = str2.length();\\n        \\n        if(str2.indexOf(str1) == 0) {\\n            return l2 >= l1;\\n        }\\n        \\n        if(str1.indexOf(str2) == 0) {\\n            return l1 == l2;\\n        }\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        while(i < l1 && j < l2){\\n            char c1 = str1.charAt(i++);\\n            char c2 = str2.charAt(j++);\\n            \\n            if(c1 == c2) continue;\\n            \\n            int pos1 = charOrder[c1 - \\'a\\'];\\n            int pos2 = charOrder[c2 - \\'a\\'];\\n            \\n            return pos2 >= pos1;\\n        }\\n        \\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149849,
                "title": "java-solution-with-simple-explanation-and-algorithm",
                "content": "*------Please **upvote** if you like this solution.  Please put your queries/doubts in the comments section below.  I will try my best to answer them.------*\\n\\n**EXPLANATION:**\\n\\n********Idea - Just do a brute force!********\\n\\n1. Create a map to store the positions of characters in the given order.\\n2. Compare 2 adjacent strings one-by-one.\\n\\nFor comparison of 2 strings, we call a **compare** method.\\n\\n1. Take **i** as the pointer to characters in the first string (**prev**) and **j** as the pointer to characters in the second string (**next**).\\n2. Iterate until **i < prev.length () and j < next.length ()**.\\n3. If position of current character of **prev** is *lesser than* the position of the current character of **next**, return **true**.\\n4. If position of current character of **prev** is *greater than* the position of the current character of **next**, return **false**.\\n5. If all characters are same, then we would ultimately reach the end of the loop.\\n6. For **prev** to be lexicographically before **next**, it must be a prefix of **next** if we have reached this stage.\\n7. So, now check if **i** has reached the end of the string **prev** and whether **i <= j**.\\n8. If yes, return **true**.\\n9. Else, return **false**.\\n\\n*------Do **upvote!** if you like the solution and explanation.------*\\n\\n```\\nclass Solution {\\n    public boolean isAlienSorted (String[] words, String order) {\\n        HashMap <Character, Integer> map = new HashMap ();\\n        for (int i = 0; i < 26; i++)\\n            map.put (order.charAt (i), i);\\n        for (int i = 0; i < words.length - 1; i++) {\\n            if (!compare (words [i], words [i+1], map))\\n                return false;\\n        }\\n        return true;\\n    }\\n    public boolean compare (String prev, String next, HashMap <Character, Integer> map) {\\n        int i = 0, j = 0;\\n        while (i < prev.length () && j < next.length ()) {\\n            char pChar = prev.charAt (i++);\\n            char nChar = next.charAt (j++);\\n            if (map.get (pChar) < map.get (nChar))\\n                return true;\\n            else if (map.get (pChar) > map.get (nChar))\\n                return false;\\n        }\\n        if (i == prev.length () && i <= j)\\n            return true;\\n        else\\n            return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isAlienSorted (String[] words, String order) {\\n        HashMap <Character, Integer> map = new HashMap ();\\n        for (int i = 0; i < 26; i++)\\n            map.put (order.charAt (i), i);\\n        for (int i = 0; i < words.length - 1; i++) {\\n            if (!compare (words [i], words [i+1], map))\\n                return false;\\n        }\\n        return true;\\n    }\\n    public boolean compare (String prev, String next, HashMap <Character, Integer> map) {\\n        int i = 0, j = 0;\\n        while (i < prev.length () && j < next.length ()) {\\n            char pChar = prev.charAt (i++);\\n            char nChar = next.charAt (j++);\\n            if (map.get (pChar) < map.get (nChar))\\n                return true;\\n            else if (map.get (pChar) > map.get (nChar))\\n                return false;\\n        }\\n        if (i == prev.length () && i <= j)\\n            return true;\\n        else\\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1093418,
                "title": "a-python-one-liner-with-o-nlgn-time-and-o-n-space-fun-to-write-but-could-be-harder-to-read",
                "content": "As human beings, my intuition when I heard the word \"Alien Dictionary\" was that I definitely need a translation service of somekind.\\n\\nTo put the translation process in code, I first translate each char of each word in the words list into an index of Alien Dicitionary (order) and use the translated index as the key in  sorted(). I then compare the original words list with the sorted words to determine whether everything is in order. Pun intended.\\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        return words == sorted(words, key=lambda w: tuple(map(order.index, w)))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        return words == sorted(words, key=lambda w: tuple(map(order.index, w)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080867,
                "title": "python-3-lines-faster-87",
                "content": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        memo = {x: i for i, x in enumerate(order)}\\n        sorted_words = sorted(words, key = lambda word: [memo[x] for x in word])\\n        return sorted_words == words\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        memo = {x: i for i, x in enumerate(order)}\\n        sorted_words = sorted(words, key = lambda word: [memo[x] for x in word])\\n        return sorted_words == words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987952,
                "title": "idiomatic-rust",
                "content": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn is_alien_sorted(words: Vec<String>, order: String) -> bool {\\n        let dict: HashMap<char, usize> = order.chars().enumerate().map(|(ix, ch)| (ch, ix)).collect();\\n\\n        \\'toploop: for word_pair in words.windows(2) {\\n            for (ch1, ch2) in word_pair[0].chars().zip(word_pair[1].chars()) {\\n                match dict[&ch1].cmp(&dict[&ch2]) {\\n                    std::cmp::Ordering::Equal => {},\\n                    std::cmp::Ordering::Greater => return false,\\n                    std::cmp::Ordering::Less => continue \\'toploop,\\n                }\\n            }\\n            if word_pair[0].len() > word_pair[1].len() {\\n                return false\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn is_alien_sorted(words: Vec<String>, order: String) -> bool {\\n        let dict: HashMap<char, usize> = order.chars().enumerate().map(|(ix, ch)| (ch, ix)).collect();\\n\\n        \\'toploop: for word_pair in words.windows(2) {\\n            for (ch1, ch2) in word_pair[0].chars().zip(word_pair[1].chars()) {\\n                match dict[&ch1].cmp(&dict[&ch2]) {\\n                    std::cmp::Ordering::Equal => {},\\n                    std::cmp::Ordering::Greater => return false,\\n                    std::cmp::Ordering::Less => continue \\'toploop,\\n                }\\n            }\\n            if word_pair[0].len() > word_pair[1].len() {\\n                return false\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 776835,
                "title": "ez-c-solution",
                "content": "```\\n     //----------------------key     index Value\\n    Dictionary<char, int> dict = new Dictionary<char, int>();\\n    \\n    public bool IsAlienSorted(string[] words, string order) {\\n        //we have to know where something occurs in order.\\n        //put this in a dictionary with index key as char and index as the value\\n        //create an list, input via sort\\n        //\\n        //check if it is equal to string[] words...\\n        \\n        \\n        \\n        //O(N) time O(N) space\\n        for(int i = 0; i < order.Length; i++){\\n            dict.Add(order[i], i);   \\n        }\\n        \\n        \\n        for(int i = 0; i < words.Length-1; i++){\\n                if(checkBoth(words[i], words[i+1])){\\n                    continue;\\n                }else{\\n                    return false;\\n                } \\n        \\n        }\\n        \\n        return true;\\n        \\n    }\\n    //reminder: check for the duplicates of same\\n    \\n    public bool checkBoth(string a, string b){\\n        \\n        //get short\\n        int yeet = Math.Min(a.Length, b.Length);\\n        \\n        for(int i = 0; i < yeet; i++){\\n            \\n            int aIndex = dict[a[i]];\\n            int bIndex = dict[b[i]];\\n            \\n            Console.WriteLine(a + \" \" + b);\\n            \\n            if(aIndex < bIndex){\\n                return true;\\n            }else if(bIndex < aIndex){\\n                return false;\\n            }else if(i == yeet - 1 && a.Length > b.Length){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n     //----------------------key     index Value\\n    Dictionary<char, int> dict = new Dictionary<char, int>();\\n    \\n    public bool IsAlienSorted(string[] words, string order) {\\n        //we have to know where something occurs in order.\\n        //put this in a dictionary with index key as char and index as the value\\n        //create an list, input via sort\\n        //\\n        //check if it is equal to string[] words...\\n        \\n        \\n        \\n        //O(N) time O(N) space\\n        for(int i = 0; i < order.Length; i++){\\n            dict.Add(order[i], i);   \\n        }\\n        \\n        \\n        for(int i = 0; i < words.Length-1; i++){\\n                if(checkBoth(words[i], words[i+1])){\\n                    continue;\\n                }else{\\n                    return false;\\n                } \\n        \\n        }\\n        \\n        return true;\\n        \\n    }\\n    //reminder: check for the duplicates of same\\n    \\n    public bool checkBoth(string a, string b){\\n        \\n        //get short\\n        int yeet = Math.Min(a.Length, b.Length);\\n        \\n        for(int i = 0; i < yeet; i++){\\n            \\n            int aIndex = dict[a[i]];\\n            int bIndex = dict[b[i]];\\n            \\n            Console.WriteLine(a + \" \" + b);\\n            \\n            if(aIndex < bIndex){\\n                return true;\\n            }else if(bIndex < aIndex){\\n                return false;\\n            }else if(i == yeet - 1 && a.Length > b.Length){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 492642,
                "title": "shortest-golang-solution",
                "content": "We just map aliens\\' alphabet to the english and replace each character in each word. The magic of the solution is to use the function [StringsAreSorted](https://golang.org/pkg/sort/#StringsAreSorted) from stdlib. Learn stdlib and have fun :) \\n```\\nfunc isAlienSorted(words []string, order string) bool {\\n    m := make(map[rune]rune)\\n    for i, b := range order {\\n        m[b] = rune(\\'a\\' + byte(i))\\n    }\\n    for i, s := range words {\\n      runes := []rune(s)\\n      for i, r := range runes {\\n        runes[i] = m[r]\\n      }\\n      words[i] = string(runes)\\n    }\\n    return sort.StringsAreSorted(words)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isAlienSorted(words []string, order string) bool {\\n    m := make(map[rune]rune)\\n    for i, b := range order {\\n        m[b] = rune(\\'a\\' + byte(i))\\n    }\\n    for i, s := range words {\\n      runes := []rune(s)\\n      for i, r := range runes {\\n        runes[i] = m[r]\\n      }\\n      words[i] = string(runes)\\n    }\\n    return sort.StringsAreSorted(words)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 472131,
                "title": "javascript-solution",
                "content": "### The idea\\n1. The character order only happens in the first pair of different characters. For example, `word` & `world`, the only character order we can make sure of is `d` is before `l`.\\n\\n### Time Complexity\\nO(N * M)\\nN: # of words, M: Avg length of words\\n``` javascript\\n/**\\n * @param {string[]} words\\n * @param {string} order\\n * @return {boolean}\\n */\\nvar isAlienSorted = function(words, order) {\\n    for (let i=0;i<words.length-1;i++) {\\n        let word1 = words[i];\\n        let word2 = words[i+1];\\n        let minLen = Math.min(word1.length, word2.length);\\n        let flag = false;\\n        for (let i=0;i<minLen;i++) {\\n            if (word1[i] != word2[i]) {\\n                if (order.indexOf(word1[i]) > order.indexOf(word2[i])) return false;\\n                flag = true;\\n                break;\\n            }\\n        }\\n        if (!flag && word1.length > word2.length) return false;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {string[]} words\\n * @param {string} order\\n * @return {boolean}\\n */\\nvar isAlienSorted = function(words, order) {\\n    for (let i=0;i<words.length-1;i++) {\\n        let word1 = words[i];\\n        let word2 = words[i+1];\\n        let minLen = Math.min(word1.length, word2.length);\\n        let flag = false;\\n        for (let i=0;i<minLen;i++) {\\n            if (word1[i] != word2[i]) {\\n                if (order.indexOf(word1[i]) > order.indexOf(word2[i])) return false;\\n                flag = true;\\n                break;\\n            }\\n        }\\n        if (!flag && word1.length > word2.length) return false;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374708,
                "title": "c-simple-inbuilt-sort",
                "content": "Runtime: 12 ms, faster than 8.13% of C++ online submissions for Verifying an Alien Dictionary.\\nMemory Usage: 12.1 MB, less than 7.69% of C++ online submissions for Verifying an Alien Dictionary.\\n\\n```\\nvector<int> mp(26,0);\\n\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        \\n        for(int i=0; i<order.size(); i++)\\n            mp[order[i] - \\'a\\'] = i;\\n        \\n        vector<string> temp = words;\\n        sort(words.begin(), words.end(), comp);\\n        \\n        return (temp == words);\\n    }\\n    \\n    static bool comp(string a, string b)\\n    {\\n        int m = min(a.length(), b.length());\\n        \\n        for(int i=0; i<m; i++)\\n            if(a[i] != b[i]) return (mp[a[i] - \\'a\\'] < mp[b[i] - \\'a\\']);\\n        \\n        return a.length() < b.length();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nvector<int> mp(26,0);\\n\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        \\n        for(int i=0; i<order.size(); i++)\\n            mp[order[i] - \\'a\\'] = i;\\n        \\n        vector<string> temp = words;\\n        sort(words.begin(), words.end(), comp);\\n        \\n        return (temp == words);\\n    }\\n    \\n    static bool comp(string a, string b)\\n    {\\n        int m = min(a.length(), b.length());\\n        \\n        for(int i=0; i<m; i++)\\n            if(a[i] != b[i]) return (mp[a[i] - \\'a\\'] < mp[b[i] - \\'a\\']);\\n        \\n        return a.length() < b.length();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 363706,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {string[]} words\\n * @param {string} order\\n * @return {boolean}\\n */\\nvar isAlienSorted = function(words, order) {\\n    return [...words]\\n        .sort((a, b) => {\\n            for (let i = 0; i < a.length; i++) {\\n                if (a[i] === b[i]) continue;\\n                if (order.indexOf(a[i]) > order.indexOf(b[i])) return 1;\\n                if (order.indexOf(a[i]) < order.indexOf(b[i])) return -1;\\n            }\\n            return a.length - b.length;\\n        }).join(\\'\\') === words.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} order\\n * @return {boolean}\\n */\\nvar isAlienSorted = function(words, order) {\\n    return [...words]\\n        .sort((a, b) => {\\n            for (let i = 0; i < a.length; i++) {\\n                if (a[i] === b[i]) continue;\\n                if (order.indexOf(a[i]) > order.indexOf(b[i])) return 1;\\n                if (order.indexOf(a[i]) < order.indexOf(b[i])) return -1;\\n            }\\n            return a.length - b.length;\\n        }).join(\\'\\') === words.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 207790,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def isAlienSorted(self, words, order):\\n        \"\"\"\\n        :type words: List[str]\\n        :type order: str\\n        :rtype: bool\\n        \"\"\"\\n        dic = {}\\n        for i, c in enumerate(order):\\n            dic[c] = i\\n        for i in range(len(words)-1):\\n            cur = words[i]\\n            nex = words[i+1]\\n            for i in range(min(len(cur), len(nex))):\\n                if cur[i] != nex[i]:\\n                    if dic[cur[i]] > dic[nex[i]]:\\n                        return False\\n                    break\\n            else:\\n                if len(cur) > len(nex):\\n                    return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words, order):\\n        \"\"\"\\n        :type words: List[str]\\n        :type order: str\\n        :rtype: bool\\n        \"\"\"\\n        dic = {}\\n        for i, c in enumerate(order):\\n            dic[c] = i\\n        for i in range(len(words)-1):\\n            cur = words[i]\\n            nex = words[i+1]\\n            for i in range(min(len(cur), len(nex))):\\n                if cur[i] != nex[i]:\\n                    if dic[cur[i]] > dic[nex[i]]:\\n                        return False\\n                    break\\n            else:\\n                if len(cur) > len(nex):\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203194,
                "title": "4-ms-java-code-with-explanation",
                "content": "Time complexity: O(mnk)\\n`m`: words.length\\n`n`: max { words[i].length() }\\n`k`: order.length (`indexOf` is used)\\n\\n```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int k = 0;\\n        while (k+1 < words.length) {\\n            \\n            // loop through words[], compare two consecutive strings at a time\\n            if (checkInOrderWithNext(order, words, k))\\n                k++;\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean checkInOrderWithNext(String order, String[] words, int k) {\\n        int wordLengthMax = Math.max(words[k].length(), words[k+1].length());\\n        int currentOrderIdx = 0;\\n        \\n        // compare the two strings one char at a time\\n        for (int i = 0; i < wordLengthMax; i++) {\\n            \\n            // if the previous one runs out first, return true\\n            if (i >= words[k].length())\\n                return true;\\n            \\n            // if the latter one runs out first, return false\\n            if (i >= words[k+1].length())\\n                return false;\\n            \\n            // if current comparing chars are strictly increasing in order, return true\\n            // if they are equal, compare next chars\\n            // if they are strictly decreasing in order, return false\\n            if (order.indexOf(words[k].charAt(i)) < order.indexOf(words[k+1].charAt(i)))\\n                return true;\\n            else if (order.indexOf(words[k].charAt(i)) == order.indexOf(words[k+1].charAt(i)))\\n                continue;\\n            else\\n                return false;\\n        }\\n        \\n        // return true if they are identical\\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int k = 0;\\n        while (k+1 < words.length) {\\n            \\n            // loop through words[], compare two consecutive strings at a time\\n            if (checkInOrderWithNext(order, words, k))\\n                k++;\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean checkInOrderWithNext(String order, String[] words, int k) {\\n        int wordLengthMax = Math.max(words[k].length(), words[k+1].length());\\n        int currentOrderIdx = 0;\\n        \\n        // compare the two strings one char at a time\\n        for (int i = 0; i < wordLengthMax; i++) {\\n            \\n            // if the previous one runs out first, return true\\n            if (i >= words[k].length())\\n                return true;\\n            \\n            // if the latter one runs out first, return false\\n            if (i >= words[k+1].length())\\n                return false;\\n            \\n            // if current comparing chars are strictly increasing in order, return true\\n            // if they are equal, compare next chars\\n            // if they are strictly decreasing in order, return false\\n            if (order.indexOf(words[k].charAt(i)) < order.indexOf(words[k+1].charAt(i)))\\n                return true;\\n            else if (order.indexOf(words[k].charAt(i)) == order.indexOf(words[k+1].charAt(i)))\\n                continue;\\n            else\\n                return false;\\n        }\\n        \\n        // return true if they are identical\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203163,
                "title": "stl-overkill",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        unordered_map<char, int> tab;\\n        for (int i = 0, n = order.size(); i < n; ++i) tab[order[i]] = i;\\n        return is_sorted(words.begin(), words.end(), [&tab](const string & a, const string & b) {\\n            return lexicographical_compare(a.begin(), a.end(), b.begin(), b.end(), [&tab](auto c1, auto c2) {\\n                return tab[c1] < tab[c2];\\n            });\\n        });\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        unordered_map<char, int> tab;\\n        for (int i = 0, n = order.size(); i < n; ++i) tab[order[i]] = i;\\n        return is_sorted(words.begin(), words.end(), [&tab](const string & a, const string & b) {\\n            return lexicographical_compare(a.begin(), a.end(), b.begin(), b.end(), [&tab](auto c1, auto c2) {\\n                return tab[c1] < tab[c2];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3133069,
                "title": "js-sol-with-68ms-runtime-and-40-mb-memory",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe approach of the function is as follows :-\\n\\n1. Create a Map object raj to store the order of characters in the alien alphabet.\\n\\n2. For each character in the order string, the code maps the character to its position in the alien alphabet using the raj map.\\n\\n3. For each pair of adjacent words in the words array, the code compares the characters of each word starting from the first character.\\n \\n4. If the characters are different, it checks if the order of the characters in the alien alphabet is correct using the raj map.\\n\\n5. If the characters are in the correct order, the code continues comparing the next characters. If the characters are in the incorrect order, the code returns false.\\n\\n6. If the code reaches the end of the pair of words, it moves on to the next pair.\\n\\n7. If the code reaches the end of the words array, it returns true, indicating that the words are sorted in the alien alphabet order.\\n\\n8. Overall, the function uses a two-pointer approach to compare each pair of words in the words array, checking the order of characters in the alien alphabet to determine if the words are sorted.\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. This is because for each pair of words, the code compares each character and could take m comparisons for each pair of words. \\n\\n2. The code performs n-1 comparisons, so the overall time complexity is $$O(n*m)$$.\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n1. This is because it only uses a constant amount of additional space, regardless of the size of the input. \\n\\n2. This is because the raj map has a constant size equal to the length of the order string, and the rest of the variables used in the code (e.g., r1, r2, i, j) are also constant.\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} order\\n * @return {boolean}\\n */\\nvar isAlienSorted = function(words, order) {\\n\\n    let raj = new Map();\\n\\n    for (let i=0; i<order.length; i++) {\\n\\n            raj[order[i]] = i;\\n        }\\n        \\n        for (let i=0; i<words.length-1; i++) {\\n\\n            let r1 = words[i];\\n\\n            let r2 = words[i+1];\\n\\n            for (let j=0; j<r1.length; j++){\\n\\n                if(j == r2.length) return false;\\n            \\n            if (r1[j] !== r2[j]) {\\n\\n                if (raj[r1[j]] > raj[r2[j]]) \\n\\n                return false;\\n\\n                break;\\n            }\\n        }\\n    }\\n\\nreturn true;\\n  \\n};\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/453634aa-bf24-4d86-a773-de0bbc70b143_1675361951.1242514.jpeg)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} order\\n * @return {boolean}\\n */\\nvar isAlienSorted = function(words, order) {\\n\\n    let raj = new Map();\\n\\n    for (let i=0; i<order.length; i++) {\\n\\n            raj[order[i]] = i;\\n        }\\n        \\n        for (let i=0; i<words.length-1; i++) {\\n\\n            let r1 = words[i];\\n\\n            let r2 = words[i+1];\\n\\n            for (let j=0; j<r1.length; j++){\\n\\n                if(j == r2.length) return false;\\n            \\n            if (r1[j] !== r2[j]) {\\n\\n                if (raj[r1[j]] > raj[r2[j]]) \\n\\n                return false;\\n\\n                break;\\n            }\\n        }\\n    }\\n\\nreturn true;\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3132721,
                "title": "verifying-an-alien-dictionary",
                "content": "# Intuition\\nThe intuition behind this problem is to understand the concept of lexicographic sorting and how it can be applied to a language where the order of the alphabet is different from the English alphabet. The goal is to determine if a given set of words are sorted in the order specified by the given order of the alphabet.\\n\\nTo solve this problem, we need to map the English letters to the corresponding positions in the given order, so that we can compare the order of two letters according to the alien language\\'s order. Then, for each pair of adjacent words, we need to compare their characters one by one until a difference is found or the end of one of the words is reached. If a difference is found, we use the index array to determine the order of the letters and return false if the first word is greater than the second word according to the alien language\\'s order. If no difference is found and the first word is longer than the second word, we return false as it is not possible for a longer word to come before a shorter word in a lexicographic sort. Finally, if all comparisons pass, we return true as the words are sorted lexicographically in the alien language.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach to solve this problem is as follows:\\n\\n1.Create an array index to store the position of each letter in the given order.\\n2.Iterate through the array of words and compare each pair of adjacent words.\\n3.For each pair of words, compare their characters one by one until a difference is found or the end of one of the words is reached.\\n4.If a difference is found, use the index array to determine the order of the letters and return false if the first word is greater than the second word according to the alien language\\'s order.\\n5.If no difference is found and the first word is longer than the second word, return false as it is not possible for a longer word to come before a shorter word in a lexicographic sort.\\n6.Repeat steps 3-5 for all pairs of words.\\n7.If all comparisons pass, return true as the words are sorted lexicographically in the alien language.\\n\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int[] index = new int[26];\\n        for (int i = 0; i < order.length(); i++) {\\n            index[order.charAt(i) - \\'a\\'] = i;\\n        }\\n        for (int i = 0; i < words.length - 1; i++) {\\n            String word1 = words[i];\\n            String word2 = words[i + 1];\\n            int len = Math.min(word1.length(), word2.length());\\n            for (int j = 0; j < len; j++) {\\n                if (word1.charAt(j) != word2.charAt(j)) {\\n                    if (index[word1.charAt(j) - \\'a\\'] > index[word2.charAt(j) - \\'a\\']) {\\n                        return false;\\n                    }\\n                    break;\\n                }\\n            }\\n            if (word1.length() > word2.length() && word1.startsWith(word2)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int[] index = new int[26];\\n        for (int i = 0; i < order.length(); i++) {\\n            index[order.charAt(i) - \\'a\\'] = i;\\n        }\\n        for (int i = 0; i < words.length - 1; i++) {\\n            String word1 = words[i];\\n            String word2 = words[i + 1];\\n            int len = Math.min(word1.length(), word2.length());\\n            for (int j = 0; j < len; j++) {\\n                if (word1.charAt(j) != word2.charAt(j)) {\\n                    if (index[word1.charAt(j) - \\'a\\'] > index[word2.charAt(j) - \\'a\\']) {\\n                        return false;\\n                    }\\n                    break;\\n                }\\n            }\\n            if (word1.length() > word2.length() && word1.startsWith(word2)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132391,
                "title": "python-solution-explained-in-detail",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- In lexicographically ordered dictionary we don\\'t have any words less in value after greater.\\n- So we don\\'t need to traverse $$words$$ array $$n^2$$ times just check it for $$n$$ times.\\n- if $$current word[i]$$ is greater in size of $$currentword[i+1]$$ and  next word is having less value according to orders then return false\\n- else check for every word pair in one iteration from i=0 to i=n-1\\n- because for $$nth$$ word we will check at $$n-1\\'th$$ tearm\\n- proceed further till we match in pair of $$words[i]$$ and $$words[i+1]$$\\n- when not matched check $$current$$ $$alphabet$$ $$order$$ in $$words[i]$$ and $$words[i+1]$$\\n- if it\\'s not according to given order then return false\\n- else at last return true\\n\\n# Code\\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        mapper = {chr(i):-1 for i in range(97,97+26)}\\n        def map_value():\\n            nonlocal order\\n            nonlocal mapper\\n            for i in range(len(order)):\\n                mapper[order[i]] = i\\n        map_value()\\n        def helper():\\n            for i in range(len(words)-1):\\n                if len(words[i+1])<len(words[i]) and mapper[words[i+1][0]] <= mapper[words[i][0]] and words[i+1] in words[i]:\\n                    return False\\n                else:\\n                    for j in range(min(len(words[i]), len(words[i+1]))):\\n                        if words[i][j] != words[i+1][j]:\\n                            if mapper[words[i+1][j]] < mapper[words[i][j]]:\\n                                return False\\n                            break\\n            return True\\n        return helper()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        mapper = {chr(i):-1 for i in range(97,97+26)}\\n        def map_value():\\n            nonlocal order\\n            nonlocal mapper\\n            for i in range(len(order)):\\n                mapper[order[i]] = i\\n        map_value()\\n        def helper():\\n            for i in range(len(words)-1):\\n                if len(words[i+1])<len(words[i]) and mapper[words[i+1][0]] <= mapper[words[i][0]] and words[i+1] in words[i]:\\n                    return False\\n                else:\\n                    for j in range(min(len(words[i]), len(words[i+1]))):\\n                        if words[i][j] != words[i+1][j]:\\n                            if mapper[words[i+1][j]] < mapper[words[i][j]]:\\n                                return False\\n                            break\\n            return True\\n        return helper()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132122,
                "title": "c-easy-solution",
                "content": "# Intuition\\nThe idea behind this code is to verify if the words in the words vector are sorted according to the given alien dictionary. To achieve this, the code first creates a mapping of each character in order to its index. Then, it sorts the words in the words vector according to the mapping and compares the sorted vector with the original vector i.e in lexicographically . If the two vectors are equal, it means that the words in words are sorted according to the alien dictionary.\\n\\n# Approach\\n- First create a map that map will store char with index according to the alien dictoniary order \\n- So we will run for loop of given order length and store the value in the map\\n- Then another for loop is used to compare adjacent words of given vector words\\n- The while loop inside for loop is used to compare each character of two adjacent word \\n- while loop will run until smallest size of both words\\n- If at same index if character is not same then we will check if they are in sorted order of not \\n- if not then we will return false else if they are sorted then we will return break and check another word\\n- one special case is added is smallest of two word is substring of largest word of two and if not sorted then we will return false\\n\\n# Complexity\\n- Time complexity:\\n- O(n)- first for loop\\n- O(n^2) - second loop inside loop\\nO(n)+O(n^2)=O(n^2)\\n\\n- Space complexity:\\nAs map is used so space complexity is - O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,int>m;\\n        int j,k,c;\\n        for(int i=0;i<order.length();i++)\\n        {\\n            m[order[i]]=i;\\n        }\\n        for(int i=1;i<words.size();i++)\\n        { j=0,k=0,c=0;\\n            while(j<words[i].size() && k<words[i-1].size())\\n            {\\n                if(words[i][j]!=words[i-1][k])\\n                { \\n                     if(m[words[i-1][k]]>m[words[i][j]])return false;\\n                     else break;\\n                }\\n                else{c++;}\\n                j++;\\n                k++;\\n            } \\n            if(c==words[i].size() && words[i-1].size()>words[i].size())return false;\\n            }\\n                      \\n return true; \\n        }\\n\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,int>m;\\n        int j,k,c;\\n        for(int i=0;i<order.length();i++)\\n        {\\n            m[order[i]]=i;\\n        }\\n        for(int i=1;i<words.size();i++)\\n        { j=0,k=0,c=0;\\n            while(j<words[i].size() && k<words[i-1].size())\\n            {\\n                if(words[i][j]!=words[i-1][k])\\n                { \\n                     if(m[words[i-1][k]]>m[words[i][j]])return false;\\n                     else break;\\n                }\\n                else{c++;}\\n                j++;\\n                k++;\\n            } \\n            if(c==words[i].size() && words[i-1].size()>words[i].size())return false;\\n            }\\n                      \\n return true; \\n        }\\n\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130448,
                "title": "java-clean-solution-explained",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\n``` java []\\nclass Solution {\\n    // create a global array (map) to store the order\\n    private int[] A = new int[26];\\n\\n    public boolean isAlienSorted(String[] words, String order) {\\n        // populate the order array\\n        for (int i = 0; i < 26; i++) {\\n            A[order.charAt(i) - \\'a\\'] = i;\\n        }\\n        // start iterating on words[]\\n        for (int i = 0; i < words.length - 1; i++) {\\n            // if current word is not smaller than next word\\n            if (!isSmaller(words[i], words[i+1])) {\\n                return false;\\n            }\\n            // otherwise check next pair\\n        }\\n\\n        // when all words are lexicographically sorted\\n        return true;   \\n    }\\n\\n    private boolean isSmaller(String s1, String s2) {\\n        int n1 = s1.length(), n2 = s2.length();\\n        int n = Math.min(n1, n2);\\n        for (int i = 0; i < n; i++) {\\n            char c1 = s1.charAt(i);   // current word\\'s i-th character\\n            char c2 = s2.charAt(i);   // next word\\'s i-th character\\n            // if c1 is less than c2, words are sorted\\n            if (A[c1 - \\'a\\'] < A[c2 - \\'a\\']) {\\n                return true;    // we don\\'t need to check further\\n            } \\n            // or else if c1 > c2, words are unsorted\\n            else if (A[c1 - \\'a\\'] > A[c2 - \\'a\\']) {\\n                return false;   \\n            }\\n\\n            // Example: \"apple\" and \"app\"\\n            // we saw that \"app\" is common in both the strings\\n            // but beyond \"app\" lies more characters which is not allowed\\n            // if it were \"apple\" AFTER \"app\" it\\'d be sorted\\n            // but \"apple\" is before \"app\" which is unsorted\\n\\n            // So we have reached the last index and so far the string was same\\n            // and we see that current word is longer than next word\\n            // which means the words are unsorted\\n            if (i == n - 1 && n1 > n2) {\\n                return false;\\n            }\\n        }\\n\\n        // when we come out of the loop means s1 is smaller than s2\\n        return true;\\n    }\\n}\\n```\\n---\\n#### Clean solution:\\n``` java []\\nclass Solution {\\n    private int[] A = new int[26];\\n    public boolean isAlienSorted(String[] words, String order) {\\n        for (int i = 0; i < 26; i++) {\\n            A[order.charAt(i) - \\'a\\'] = i;\\n        }\\n\\n        for (int i = 0; i < words.length - 1; i++) {\\n            if (!isSmaller(words[i], words[i+1])) {\\n                return false;\\n            }\\n        }\\n\\n        return true;   \\n    }\\n\\n    private boolean isSmaller(String s1, String s2) {\\n        int n1 = s1.length(), n2 = s2.length();\\n        int n = Math.min(n1, n2);\\n        for (int i = 0; i < n; i++) {\\n            char c1 = s1.charAt(i);   \\n            char c2 = s2.charAt(i);   \\n            if (A[c1 - \\'a\\'] < A[c2 - \\'a\\']) {\\n                return true;   \\n            } else if (A[c1 - \\'a\\'] > A[c2 - \\'a\\']) {\\n                return false;   \\n            }\\n            if (i == n - 1 && n1 > n2) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n---\\n### Time complexity: $$O(n * m) => O(n)$$\\nWhere $$n$$ is the length of the words array and $$m$$ is the length on which we iterate while validating two adjacent words. Considering $$m$$ is very small ($$<= 20$$), we can say our time complexity is $$O(n)$$.\\n### Space complexity: $$O(26) => O(1)$$",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "``` java []\\nclass Solution {\\n    // create a global array (map) to store the order\\n    private int[] A = new int[26];\\n\\n    public boolean isAlienSorted(String[] words, String order) {\\n        // populate the order array\\n        for (int i = 0; i < 26; i++) {\\n            A[order.charAt(i) - \\'a\\'] = i;\\n        }\\n        // start iterating on words[]\\n        for (int i = 0; i < words.length - 1; i++) {\\n            // if current word is not smaller than next word\\n            if (!isSmaller(words[i], words[i+1])) {\\n                return false;\\n            }\\n            // otherwise check next pair\\n        }\\n\\n        // when all words are lexicographically sorted\\n        return true;   \\n    }\\n\\n    private boolean isSmaller(String s1, String s2) {\\n        int n1 = s1.length(), n2 = s2.length();\\n        int n = Math.min(n1, n2);\\n        for (int i = 0; i < n; i++) {\\n            char c1 = s1.charAt(i);   // current word\\'s i-th character\\n            char c2 = s2.charAt(i);   // next word\\'s i-th character\\n            // if c1 is less than c2, words are sorted\\n            if (A[c1 - \\'a\\'] < A[c2 - \\'a\\']) {\\n                return true;    // we don\\'t need to check further\\n            } \\n            // or else if c1 > c2, words are unsorted\\n            else if (A[c1 - \\'a\\'] > A[c2 - \\'a\\']) {\\n                return false;   \\n            }\\n\\n            // Example: \"apple\" and \"app\"\\n            // we saw that \"app\" is common in both the strings\\n            // but beyond \"app\" lies more characters which is not allowed\\n            // if it were \"apple\" AFTER \"app\" it\\'d be sorted\\n            // but \"apple\" is before \"app\" which is unsorted\\n\\n            // So we have reached the last index and so far the string was same\\n            // and we see that current word is longer than next word\\n            // which means the words are unsorted\\n            if (i == n - 1 && n1 > n2) {\\n                return false;\\n            }\\n        }\\n\\n        // when we come out of the loop means s1 is smaller than s2\\n        return true;\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    private int[] A = new int[26];\\n    public boolean isAlienSorted(String[] words, String order) {\\n        for (int i = 0; i < 26; i++) {\\n            A[order.charAt(i) - \\'a\\'] = i;\\n        }\\n\\n        for (int i = 0; i < words.length - 1; i++) {\\n            if (!isSmaller(words[i], words[i+1])) {\\n                return false;\\n            }\\n        }\\n\\n        return true;   \\n    }\\n\\n    private boolean isSmaller(String s1, String s2) {\\n        int n1 = s1.length(), n2 = s2.length();\\n        int n = Math.min(n1, n2);\\n        for (int i = 0; i < n; i++) {\\n            char c1 = s1.charAt(i);   \\n            char c2 = s2.charAt(i);   \\n            if (A[c1 - \\'a\\'] < A[c2 - \\'a\\']) {\\n                return true;   \\n            } else if (A[c1 - \\'a\\'] > A[c2 - \\'a\\']) {\\n                return false;   \\n            }\\n            if (i == n - 1 && n1 > n2) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129849,
                "title": "python-solution-with-detailed-explanation-fastest-99-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\nFor Detailed Explaination Read this Blog:\\nhttps://www.python-techs.com/2023/02/Alien-Language.html\\n\\n**Solution:**\\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        # Map each character to its index in the order\\n        order_index = {c: i for i, c in enumerate(order)}\\n\\n        # Check each pair of adjacent words\\n        for i in range(len(words) - 1):\\n            word1 = words[i]\\n            word2 = words[i + 1]\\n\\n            # Compare characters\\n            for j in range(min(len(word1), len(word2))):\\n                if word1[j] != word2[j]:\\n                    # If order is not sorted, return False\\n                    if order_index[word1[j]] > order_index[word2[j]]:\\n                        return False\\n                    break\\n            else:\\n                # If end of shorter word reached and length of first word is greater, return False\\n                if len(word1) > len(word2):\\n                    return False\\n\\n        # If all pairs are sorted, return True\\n        return True\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        # Map each character to its index in the order\\n        order_index = {c: i for i, c in enumerate(order)}\\n\\n        # Check each pair of adjacent words\\n        for i in range(len(words) - 1):\\n            word1 = words[i]\\n            word2 = words[i + 1]\\n\\n            # Compare characters\\n            for j in range(min(len(word1), len(word2))):\\n                if word1[j] != word2[j]:\\n                    # If order is not sorted, return False\\n                    if order_index[word1[j]] > order_index[word2[j]]:\\n                        return False\\n                    break\\n            else:\\n                # If end of shorter word reached and length of first word is greater, return False\\n                if len(word1) > len(word2):\\n                    return False\\n\\n        # If all pairs are sorted, return True\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129845,
                "title": "easy-solution-by-using-dictionarys-and-traversal-python3-java-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust create a order of characters that they appear in the order word and then check the words accordingly....\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code implements a solution to the problem of checking if a sequence of words written in an alien language is sorted lexicographically in the alien language. The solution is implemented in the isAlienSorted method, which takes as input a list of words (words) and a string that represents the order of the alphabet in the alien language (order).\\n\\n-->A dictionary h is created that maps each character in order to its corresponding index.\\n-->The first word in words is converted into a list of indices, using the dictionary h. This list is stored in the variable prev.\\n-->A for loop is started, starting from index 1, and ending at the last index of words.\\n-->In each iteration of the for loop, the current word from words is converted into a list of indices, using the dictionary h, and stored in the variable cur.\\n-->The code checks if the current list of indices cur is lexicographically smaller than the previous list of indices prev. If this is the case, the method returns False, indicating that the words are not sorted lexicographically.\\nIf the current list of indices cur is not lexicographically smaller than the previous list of indices prev, the value of prev is updated to be cur.\\n-->Once all iterations of the for loop have completed, the method returns True, indicating that the words are sorted lexicographically.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        dic={c:i for i,c in enumerate(order)}\\n        prev=list(dic[char] for char in words[0])\\n        for i in range(1,len(words)):\\n            cur=list(dic[ch] for ch in words[i])\\n            if cur<prev:\\n                return False\\n            prev=cur\\n        return True\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        dic={c:i for i,c in enumerate(order)}\\n        prev=list(dic[char] for char in words[0])\\n        for i in range(1,len(words)):\\n            cur=list(dic[ch] for ch in words[i])\\n            if cur<prev:\\n                return False\\n            prev=cur\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129712,
                "title": "ruby-1-liner",
                "content": "```\\ndef is_alien_sorted(words, order) =\\n\\n  words==words.sort_by{_1.tr order, \\'a-z\\'}\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef is_alien_sorted(words, order) =\\n\\n  words==words.sort_by{_1.tr order, \\'a-z\\'}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3129661,
                "title": "beats-100-fully-explained-java",
                "content": "# Intuition\\n- Lexicographically means in dictionary order,i.e.if two strings are compared based on dictionary position the string which comes afterwards is said to be Lexicographically greater.\\n- String A can be called as lexicographically bigger than String B if it satisfies the following conditions:-\\n1. If one of the character atleast one of character of the String A is greater than the character at the same index of the String B, For Example let say String A=\"abce\" and String B=\"abcd\",so in this example you can see that all of the character of both the Strings are same expect the last one. \"e\" comes after than \"d\" i.e why A is lexicographically bigger than B.\\n2. Let String A=\"abcd\" and String B=\"abc\" ,so in example you can see that all the characters of both the strings are same but the String B does not contains the last character i.e \"d\" because of which the String A became bigger than B.But But But guys it doesn\\'t mean that String \"abce\" is greater than String \"abd\" because the String \"abd\" have atleast one character which is lexicographically bigger than the character \"c\" of String \"abce\".\\n\\n- And we always compare two characters that are at same index only. \\n- I hope you understand the intuition my whole program depend upon it please dry run it by your own thank you ;)\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    boolean check(String one,String two,String order){\\n\\n    for(int i=0;i<one.length()&&i<two.length();i++){\\n        \\n    if(order.indexOf(one.charAt(i))<order.indexOf(two.charAt(i))){\\n        \\n    return true;\\n    \\n    }\\n    if(order.indexOf(one.charAt(i))>order.indexOf(two.charAt(i))){\\n\\n    System.out.println(one.charAt(i));\\n    \\n    System.out.println(two.charAt(i));\\n\\n    return false;\\n\\n    }\\n\\n    }\\n\\n    if(one.length()>two.length())return false;\\n\\n    return true;\\n\\n    }\\n\\n    public boolean isAlienSorted(String[] words, String order) {\\n\\n    for(int i=0;i<words.length-1;i++){\\n\\n    for(int j=i+1;j<words.length;j++){\\n\\n    if(!check(words[i],words[j],order)){\\n        return false;\\n    }\\n\\n    }\\n\\n    }\\n\\n    return true;\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n\\n    boolean check(String one,String two,String order){\\n\\n    for(int i=0;i<one.length()&&i<two.length();i++){\\n        \\n    if(order.indexOf(one.charAt(i))<order.indexOf(two.charAt(i))){\\n        \\n    return true;\\n    \\n    }\\n    if(order.indexOf(one.charAt(i))>order.indexOf(two.charAt(i))){\\n\\n    System.out.println(one.charAt(i));\\n    \\n    System.out.println(two.charAt(i));\\n\\n    return false;\\n\\n    }\\n\\n    }\\n\\n    if(one.length()>two.length())return false;\\n\\n    return true;\\n\\n    }\\n\\n    public boolean isAlienSorted(String[] words, String order) {\\n\\n    for(int i=0;i<words.length-1;i++){\\n\\n    for(int j=i+1;j<words.length;j++){\\n\\n    if(!check(words[i],words[j],order)){\\n        return false;\\n    }\\n\\n    }\\n\\n    }\\n\\n    return true;\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129563,
                "title": "easiest-commented-code-without-map-o-1-space-optimization",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n      for (int i = 0; i < words.size() - 1; i++) {\\n        string curr = words[i];\\n        string next = words[i + 1];\\n        int x = 0, y = 0;\\n        while (curr[x] == next[y]) { // till both char are same in both the strings, skip them\\n            x++, y++;\\n        }\\n        // now these are the two indexes where characters doesn\\'t matches\\n        int ind1 = order.find(curr[x]);   \\n        int ind2 = order.find(next[y]);\\n        // now if they are in sorted order, this means char of current string should appear in the order string before the char of next string\\n        if (ind1 > ind2) return false;\\n    }\\n    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n      for (int i = 0; i < words.size() - 1; i++) {\\n        string curr = words[i];\\n        string next = words[i + 1];\\n        int x = 0, y = 0;\\n        while (curr[x] == next[y]) { // till both char are same in both the strings, skip them\\n            x++, y++;\\n        }\\n        // now these are the two indexes where characters doesn\\'t matches\\n        int ind1 = order.find(curr[x]);   \\n        int ind2 = order.find(next[y]);\\n        // now if they are in sorted order, this means char of current string should appear in the order string before the char of next string\\n        if (ind1 > ind2) return false;\\n    }\\n    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129439,
                "title": "understandable-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        // creating a unordered_map to store the character of order and their indexed\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<order.length();i++) mp[order[i]]=i;// storing order\\n        int n=words.size();\\n        // iterating in words\\n        for(int i=0;i<n-1;i++)\\n        {\\n            string first=words[i];\\n            string second=words[i+1];\\n            int j=0;\\n            bool flag=false;// this flag will denote that the first string is considered as bigger or not\\n            for( j=0;j<min(first.length(),second.length());j++)\\n            {\\n                if(mp[first[j]]< mp[second[j]])//if char of first string occur first in order than \\n                // second string simply break and turn on flag\\n                {  \\n                     flag=true;\\n                    break;\\n                }\\n                else if(mp[first[j]]==mp[second[j]]) continue;// if equal than  continue;\\n                else return false;// if mp[first[i]]> mp[second[i]] return false;\\n            }\\n            if(first.length()>second.length() && !flag) // if not considered greater and first length is greater than second length return false. for ex- ab always comes before abc\\n            {\\n                return false;\\n            }\\n\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        // creating a unordered_map to store the character of order and their indexed\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<order.length();i++) mp[order[i]]=i;// storing order\\n        int n=words.size();\\n        // iterating in words\\n        for(int i=0;i<n-1;i++)\\n        {\\n            string first=words[i];\\n            string second=words[i+1];\\n            int j=0;\\n            bool flag=false;// this flag will denote that the first string is considered as bigger or not\\n            for( j=0;j<min(first.length(),second.length());j++)\\n            {\\n                if(mp[first[j]]< mp[second[j]])//if char of first string occur first in order than \\n                // second string simply break and turn on flag\\n                {  \\n                     flag=true;\\n                    break;\\n                }\\n                else if(mp[first[j]]==mp[second[j]]) continue;// if equal than  continue;\\n                else return false;// if mp[first[i]]> mp[second[i]] return false;\\n            }\\n            if(first.length()>second.length() && !flag) // if not considered greater and first length is greater than second length return false. for ex- ab always comes before abc\\n            {\\n                return false;\\n            }\\n\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945652,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(26)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,int> m;\\n        for(int i=0; i<order.size(); i++){\\n            m[order[i]]=i;\\n        }\\n        for(int i=1; i<words.size(); i++){\\n            string w1=words[i-1]; \\n            string w2=words[i];\\n            for(int i=0; i<w1.size(); i++){\\n                if(m[w1[i]]<m[w2[i]]){break;}\\n                if(i>=w2.size()){return false;}\\n                if(m[w1[i]]>m[w2[i]]){return false;}\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,int> m;\\n        for(int i=0; i<order.size(); i++){\\n            m[order[i]]=i;\\n        }\\n        for(int i=1; i<words.size(); i++){\\n            string w1=words[i-1]; \\n            string w2=words[i];\\n            for(int i=0; i<w1.size(); i++){\\n                if(m[w1[i]]<m[w2[i]]){break;}\\n                if(i>=w2.size()){return false;}\\n                if(m[w1[i]]>m[w2[i]]){return false;}\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168022,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        orderIndex={c : i for i,c in enumerate(order)} #c =key, i=value (orderIndex = h:1, l:2,a:3..etc)\\n        for i in range(len(words)-1):\\n            w1,w2=words[i], words[i+1]\\n            for j in range(len(w1)):\\n                if j==len(w2):\\n                    return False\\n                if w1[j]!=w2[j]:\\n                    if orderIndex[w2[j]]<orderIndex[w1[j]]:\\n                        return False\\n                    break\\n        return True          \\n        \\n```\\n**Please UpVote if it was Helpful :)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        orderIndex={c : i for i,c in enumerate(order)} #c =key, i=value (orderIndex = h:1, l:2,a:3..etc)\\n        for i in range(len(words)-1):\\n            w1,w2=words[i], words[i+1]\\n            for j in range(len(w1)):\\n                if j==len(w2):\\n                    return False\\n                if w1[j]!=w2[j]:\\n                    if orderIndex[w2[j]]<orderIndex[w1[j]]:\\n                        return False\\n                    break\\n        return True          \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335798,
                "title": "python-made-code-easy-easiest-python-solution-easy-to-understand",
                "content": "```\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        ourlang = \"abcdefghijklmnopqrstuvwxyz\"\\n        alienlang = \"\".maketrans(order, ourlang)\\n        for i in range(len(words)):\\n            words[i] = words[i].translate(alienlang)\\n        return words == sorted(words)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        ourlang = \"abcdefghijklmnopqrstuvwxyz\"\\n        alienlang = \"\".maketrans(order, ourlang)\\n        for i in range(len(words)):\\n            words[i] = words[i].translate(alienlang)\\n        return words == sorted(words)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1324773,
                "title": "easy-javascript-solution",
                "content": "```javascript\\nvar isAlienSorted = function(words, order) {\\n  let dict = {};\\n  for (let i = 0; i < order.length; i++) dict[order[i]] = i;\\n  \\n  for (let i = 0; i < words.length - 1; i++) {\\n    const a = words[i], b = words[i+1];\\n    \\n    for (let j = 0; j < a.length; j++) {\\n      const aIdx = dict[a[j]], bIdx = dict[b[j]];\\n      if (aIdx > bIdx || !b[j]) return false;\\n      if (aIdx < bIdx) break;\\n    }\\n  }\\n\\n  return true;\\n};\\n```\\n\\n**Time Complexity**: O(M) --- M be the total number of characters in words.\\n**Space Complexity**: O(1) --- the length of order = 26\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar isAlienSorted = function(words, order) {\\n  let dict = {};\\n  for (let i = 0; i < order.length; i++) dict[order[i]] = i;\\n  \\n  for (let i = 0; i < words.length - 1; i++) {\\n    const a = words[i], b = words[i+1];\\n    \\n    for (let j = 0; j < a.length; j++) {\\n      const aIdx = dict[a[j]], bIdx = dict[b[j]];\\n      if (aIdx > bIdx || !b[j]) return false;\\n      if (aIdx < bIdx) break;\\n    }\\n  }\\n\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1149796,
                "title": "python-solution",
                "content": "My code:\\n\\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        alphabet = {}\\n        for i in range(26):\\n            alphabet[order[i]] = i\\n        n = len(words)\\n        for i in range(n-1):\\n            len1 = len(words[i])\\n            len2 = len(words[i+1])\\n            min_len = min(len1, len2)\\n            good = False\\n            for j in range(min_len):\\n                if alphabet[words[i][j]] > alphabet[words[i+1][j]]:\\n                    return False\\n                elif alphabet[words[i][j]] < alphabet[words[i+1][j]]:\\n                    good = True\\n                    break\\n            if not good and len1 > len2:\\n                return False\\n        return True        \\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        alphabet = {}\\n        for i in range(26):\\n            alphabet[order[i]] = i\\n        n = len(words)\\n        for i in range(n-1):\\n            len1 = len(words[i])\\n            len2 = len(words[i+1])\\n            min_len = min(len1, len2)\\n            good = False\\n            for j in range(min_len):\\n                if alphabet[words[i][j]] > alphabet[words[i+1][j]]:\\n                    return False\\n                elif alphabet[words[i][j]] < alphabet[words[i+1][j]]:\\n                    good = True\\n                    break\\n            if not good and len1 > len2:\\n                return False\\n        return True        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072072,
                "title": "python-implementation-of-solution-with-clearer-explanation",
                "content": "```\\ndef isAlienSorted(self, words: List[str], order: str) -> bool:\\n    # create order_dict for easy reference later on\\n    order_dict = {l: i for i,l in enumerate(order)}\\n    \\n    # iterate through list of words leaving out last since it will be compared with second to last\\n    for i in range(len(words)-1):\\n        # set current word and next word\\n        current_word = words[i]\\n        next_word = words[i + 1]\\n\\n        # find the shortest of the two words\\n        shortest = min(len(current_word), len(next_word))\\n        \\n        # iterate on the length of the shortest word because we can only match letters up until that point\\n        for j in range(shortest):\\n            # if letter at position j of current and next don\\'t match - we need to evaluate\\n            if current_word[j] != next_word[j]: \\n                # if the value (position) of current word\\'s letter in the order_dict \\n                #   > value of next word\\'s letter in order_dict, we know the order is not sorted - return false\\n                if order_dict[current_word[j]] > order_dict[next_word[j]]:\\n                    return False\\n                # otherwise break (order is good)\\n                break\\n        # else (this is the \\'else\\' of little known \\'for/else\\' statement);\\n        # this means the break wasn\\'t hit because each letter for the shortest length matched, eg (\"app\", \"apple\");\\n        # so...\\n        else:\\n            # if length of current word > length of next word\\n            if len(current_word) > len(next_word):\\n                return False\\n            \\n    # return true (means we got through whole iteration without hitting a false condition)\\n    return True\\n```",
                "solutionTags": [],
                "code": "```\\ndef isAlienSorted(self, words: List[str], order: str) -> bool:\\n    # create order_dict for easy reference later on\\n    order_dict = {l: i for i,l in enumerate(order)}\\n    \\n    # iterate through list of words leaving out last since it will be compared with second to last\\n    for i in range(len(words)-1):\\n        # set current word and next word\\n        current_word = words[i]\\n        next_word = words[i + 1]\\n\\n        # find the shortest of the two words\\n        shortest = min(len(current_word), len(next_word))\\n        \\n        # iterate on the length of the shortest word because we can only match letters up until that point\\n        for j in range(shortest):\\n            # if letter at position j of current and next don\\'t match - we need to evaluate\\n            if current_word[j] != next_word[j]: \\n                # if the value (position) of current word\\'s letter in the order_dict \\n                #   > value of next word\\'s letter in order_dict, we know the order is not sorted - return false\\n                if order_dict[current_word[j]] > order_dict[next_word[j]]:\\n                    return False\\n                # otherwise break (order is good)\\n                break\\n        # else (this is the \\'else\\' of little known \\'for/else\\' statement);\\n        # this means the break wasn\\'t hit because each letter for the shortest length matched, eg (\"app\", \"apple\");\\n        # so...\\n        else:\\n            # if length of current word > length of next word\\n            if len(current_word) > len(next_word):\\n                return False\\n            \\n    # return true (means we got through whole iteration without hitting a false condition)\\n    return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 914094,
                "title": "0ms-super-simple-java-solution-beats-100-w-explanation",
                "content": "```\\npublic boolean isAlienSorted(String[] words, String order) {\\n    \\n        for(int i=0; i<words.length-1; i++){ // traverse the words\\n            \\n                int j = i+1; // pick the next word\\n\\n                int min = Math.min(words[i].length(),words[j].length()); // calculate the min length\\n            \\n                for(int k=0; k<min; k++){\\n                    \\n                    //check each characters of first two words\\n                    \\n                    char iChar = words[i].charAt(k); //picks characters of first word\\n                    char jChar = words[j].charAt(k); // picks characters of second word\\n                    \\n                    \\n                    // if order is correct, then the words are in correct order, don\\'t do anything and break\\n                    if(order.indexOf(iChar)<order.indexOf(jChar)){ \\n                       \\n                        break;\\n                   \\n                        //else if character in second word comes before character in first word, \\n                        //then order is wrong\\n                    } else if(order.indexOf(jChar)<order.indexOf(iChar)){\\n                       \\n                        return false;\\n                    \\n                        //also, if we reach at the last character and length of first word is greater than\\n                        //length of second word, then also return false.\\n                    } else if(k == min-1 && words[i].length()>words[j].length()){\\n                        \\n\\t\\t\\t\\t\\t\\treturn false;\\n                    \\n\\t\\t\\t\\t\\t}   \\n                }\\n        }\\n        //if nothing of the above happens, then words are sorted, return true;\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean isAlienSorted(String[] words, String order) {\\n    \\n        for(int i=0; i<words.length-1; i++){ // traverse the words\\n            \\n                int j = i+1; // pick the next word\\n\\n                int min = Math.min(words[i].length(),words[j].length()); // calculate the min length\\n            \\n                for(int k=0; k<min; k++){\\n                    \\n                    //check each characters of first two words\\n                    \\n                    char iChar = words[i].charAt(k); //picks characters of first word\\n                    char jChar = words[j].charAt(k); // picks characters of second word\\n                    \\n                    \\n                    // if order is correct, then the words are in correct order, don\\'t do anything and break\\n                    if(order.indexOf(iChar)<order.indexOf(jChar)){ \\n                       \\n                        break;\\n                   \\n                        //else if character in second word comes before character in first word, \\n                        //then order is wrong\\n                    } else if(order.indexOf(jChar)<order.indexOf(iChar)){\\n                       \\n                        return false;\\n                    \\n                        //also, if we reach at the last character and length of first word is greater than\\n                        //length of second word, then also return false.\\n                    } else if(k == min-1 && words[i].length()>words[j].length()){\\n                        \\n\\t\\t\\t\\t\\t\\treturn false;\\n                    \\n\\t\\t\\t\\t\\t}   \\n                }\\n        }\\n        //if nothing of the above happens, then words are sorted, return true;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 696977,
                "title": "rust-5-lines-0ms-hashmap",
                "content": "```Rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn is_alien_sorted(words: Vec<String>, order: String) -> bool {\\n        let dict: HashMap<_, _> = order.chars().zip(\"abcdefghijklmnopqrstuvwxyz\".chars()).collect();\\n        let human_words: Vec<String> = words.iter().map(|w| w.chars().map(|c| dict[&c]).collect()).collect();\\n        let mut sorted = human_words.clone();\\n        sorted.sort_unstable();\\n        sorted == human_words\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn is_alien_sorted(words: Vec<String>, order: String) -> bool {\\n        let dict: HashMap<_, _> = order.chars().zip(\"abcdefghijklmnopqrstuvwxyz\".chars()).collect();\\n        let human_words: Vec<String> = words.iter().map(|w| w.chars().map(|c| dict[&c]).collect()).collect();\\n        let mut sorted = human_words.clone();\\n        sorted.sort_unstable();\\n        sorted == human_words\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686805,
                "title": "python-simple-and-efficient-bfs-solution-detailed-explanation",
                "content": "1. If the length of words is < 2, return true as there are not enough words to establish a sequence.\\n2. If the words were arranged lexographically then we must assume the starting list is already sorted. We will parse the list completely to make sure everything is lexographically arranged. If we find nothing to contradict the assumption, then we return True\\n3. If while parsing we find that first letter of current word is in lexographical misalignment with first letter of the next word, we return false.\\n4. If while parsing we find that first letter of current word is same as first letter of the next word, then we do BFS with the rest of the word.\\n5. If while parsing we find that current word and a next word are a lexographical match till ith position, where i is length of next word, but current word\\'s length is greater than i, then return false. (apple, app) should return False, (app, apple) should return True\\n6. If everything is parsed and no sequence is broken, return True\\n7. Time Complexity = O(n*m), where n is len of list and m is length of longest word (worst case)\\n8. Space Complexity = O(m), where m is length of longest word (worst case)\\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n            n = len(words)\\n\\t\\t\\t#If the length of words is < 2, return true as there are not enough words to establish a sequence.\\n            if n < 2:\\n                return True\\n            def BFS(words_2):\\n\\t\\t\\t#go through all the words once. As we are comparing with (i+1)th word, we should stop loop at len(list)-1 to avoid index out of bounds exception\\n                for i in range(len(words_2)-1):\\n\\t\\t\\t\\t#If while parsing we find that first letter of current word is in lexographical misalignment with first letter of the next word, we return false.\\n                    if order.find(words_2[i][0])>order.find(words_2[i+1][0]):\\n                        return False\\n\\t\\t\\t\\t\\t\\t#If while parsing we find that first letter of current word is same as first letter of the next word, then we do BFS with the rest of the word.\\n                    elif order.find(words_2[i][0])==order.find(words_2[i+1][0]):\\n                        if len(words_2[i])>1 and len(words_2[i+1])>1:\\n\\t\\t\\t\\t\\t\\t#BFS would be done only when words match, on the rest of the chracters in the word\\n                            if not BFS([words_2[i][1:],words_2[i+1][1:]]):\\n                                return False\\n\\t\\t\\t\\t\\t\\t#If while parsing we find that current word and a next word are a lexographical match till ith position, where i is length of next word, but current word\\'s length is greater than i, then return false. (apple, app) should return False, (app, apple) should return True\\n                        elif len(words_2[i])>len(words_2[i+1]):\\n                            return False\\n                return True\\n    return BFS(words)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n            n = len(words)\\n\\t\\t\\t#If the length of words is < 2, return true as there are not enough words to establish a sequence.\\n            if n < 2:\\n                return True\\n            def BFS(words_2):\\n\\t\\t\\t#go through all the words once. As we are comparing with (i+1)th word, we should stop loop at len(list)-1 to avoid index out of bounds exception\\n                for i in range(len(words_2)-1):\\n\\t\\t\\t\\t#If while parsing we find that first letter of current word is in lexographical misalignment with first letter of the next word, we return false.\\n                    if order.find(words_2[i][0])>order.find(words_2[i+1][0]):\\n                        return False\\n\\t\\t\\t\\t\\t\\t#If while parsing we find that first letter of current word is same as first letter of the next word, then we do BFS with the rest of the word.\\n                    elif order.find(words_2[i][0])==order.find(words_2[i+1][0]):\\n                        if len(words_2[i])>1 and len(words_2[i+1])>1:\\n\\t\\t\\t\\t\\t\\t#BFS would be done only when words match, on the rest of the chracters in the word\\n                            if not BFS([words_2[i][1:],words_2[i+1][1:]]):\\n                                return False\\n\\t\\t\\t\\t\\t\\t#If while parsing we find that current word and a next word are a lexographical match till ith position, where i is length of next word, but current word\\'s length is greater than i, then return false. (apple, app) should return False, (app, apple) should return True\\n                        elif len(words_2[i])>len(words_2[i+1]):\\n                            return False\\n                return True\\n    return BFS(words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632468,
                "title": "modern-c-20-solution-no-raw-loops-zero-heap-allocations-only-8-lines",
                "content": "Here\\'s a solution that uses modern C++ idioms; Excluding comments and blank lines, its 8 lines really\\n\\n```c++\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        //Populate rank\\n        std::array<std::uint8_t, 26> rank;\\n        std::for_each(order.begin(), order.end(), [&rank, i=0](auto c) mutable { rank[c - \\'a\\'] = i++; });\\n        \\n        //Create sorter\\n        auto is_less_than = [&rank](const auto a, const auto b) {\\n            return std::lexicographical_compare(a.begin(), a.end(), b.begin(), b.end(), [&rank](auto ac, auto bc){\\n                return rank[ac - \\'a\\'] < rank[bc - \\'a\\'];\\n            });\\n        };\\n        return std::is_sorted(words.begin(), words.end(), is_less_than);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        //Populate rank\\n        std::array<std::uint8_t, 26> rank;\\n        std::for_each(order.begin(), order.end(), [&rank, i=0](auto c) mutable { rank[c - \\'a\\'] = i++; });\\n        \\n        //Create sorter\\n        auto is_less_than = [&rank](const auto a, const auto b) {\\n            return std::lexicographical_compare(a.begin(), a.end(), b.begin(), b.end(), [&rank](auto ac, auto bc){\\n                return rank[ac - \\'a\\'] < rank[bc - \\'a\\'];\\n            });\\n        };\\n        return std::is_sorted(words.begin(), words.end(), is_less_than);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 591391,
                "title": "python-using-built-in-sorted-with-a-custom-key-very-clear-with-a-detailed-explanation",
                "content": "It\\'s possible to substitute an alien word with a list of positions of its letters in the alien alphabet.\\nFor example, for the alphabet \"h*labcdefgijkmnopqrstuvwxyz*\"  \"*leetcode*\" becomes *[1, 6, 6, 19, 4, 14, 5, 6]*\\nand \"*hello*\" becomes *[0, 6, 1, 1, 14]*. Instead of sorting [\"leetcode\", \"hello\"] to check if they are actually sorted, we can sort\\n[[1, 6, 6, 19, 4, 14, 5, 6], [0, 6, 1, 1, 14]] which is trivial using built in functions.\\n\\nThe built-in **sorted()** has a *key=* parameter where we can specify a function to be called on each element of the list we want to sort.\\n\\nIn our case:\\n```sorted(words, key=self.alien_sort)``` really means: instead of sorting the words itself, pass each word through the self.alien_sort function, and then sort words in an order you would sort list of \"whatever self.alien_sort function returns\" which in our case is [1, 6, 6, 19, 4, 14, 5, 6] and [0, 6, 1, 1, 14]\\n Since the proper order is [0, 6, 1, 1, 14], [1, 6, 6, 19, 4, 14, 5, 6] then the proper \"alien\" order is \"hello\", \"leetcode\"\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.alphabet = None\\n\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        self.alphabet = order\\n        if words == sorted(words, key=self.alien_sort):\\n            return True\\n        else:\\n            return False\\n\\n    def alien_sort(self, word):\\n        result = []\\n        for letter in word:\\n            result.append(self.alphabet.index(letter))\\n        return result\\n\\t\\t```",
                "solutionTags": [],
                "code": "```sorted(words, key=self.alien_sort)```\n```\\nclass Solution:\\n    def __init__(self):\\n        self.alphabet = None\\n\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        self.alphabet = order\\n        if words == sorted(words, key=self.alien_sort):\\n            return True\\n        else:\\n            return False\\n\\n    def alien_sort(self, word):\\n        result = []\\n        for letter in word:\\n            result.append(self.alphabet.index(letter))\\n        return result\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 552703,
                "title": "javascript-simpler-solution",
                "content": "```\\nlet isAlienSorted = (words, order) => {\\n  // loop over words and compare each word with next...\\n  for (let i = 0, len = words.length - 1; i < len; i++) {\\n    let word = words[i];\\n    let next = words[i + 1];\\n    let pointer = 0;\\n    // advance the pointer while characters are same...\\n    while (word[pointer] === next[pointer]) pointer++;\\n    if (\\n      typeof next[pointer] === \\'undefined\\' || // check for empty character\\n      order.indexOf(word[pointer]) > order.indexOf(next[pointer]) // compare indexes\\n    ) {\\n      return false;\\n    }\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet isAlienSorted = (words, order) => {\\n  // loop over words and compare each word with next...\\n  for (let i = 0, len = words.length - 1; i < len; i++) {\\n    let word = words[i];\\n    let next = words[i + 1];\\n    let pointer = 0;\\n    // advance the pointer while characters are same...\\n    while (word[pointer] === next[pointer]) pointer++;\\n    if (\\n      typeof next[pointer] === \\'undefined\\' || // check for empty character\\n      order.indexOf(word[pointer]) > order.indexOf(next[pointer]) // compare indexes\\n    ) {\\n      return false;\\n    }\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 507535,
                "title": "0ms-100-faster-w-r-t-c-solutions",
                "content": "Just map the order string w.r.t actual alphabetical order (a, b, c, d, ...)\\n```\\nchar m[26];\\nclass Solution {\\n\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        char x = \\'a\\';\\n        for(int i=0;i<order.size();i++){\\n            m[order[i]-\\'a\\']=x;\\n            x++;\\n        }\\n        \\n        for(int i=0;i<words.size();i++){\\n            for(int j=0;j<words[i].size();j++){\\n               words[i][j]=m[words[i][j]-\\'a\\'];\\n            }\\n        }\\n        return is_sorted(words.begin(), words.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nchar m[26];\\nclass Solution {\\n\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        char x = \\'a\\';\\n        for(int i=0;i<order.size();i++){\\n            m[order[i]-\\'a\\']=x;\\n            x++;\\n        }\\n        \\n        for(int i=0;i<words.size();i++){\\n            for(int j=0;j<words[i].size();j++){\\n               words[i][j]=m[words[i][j]-\\'a\\'];\\n            }\\n        }\\n        return is_sorted(words.begin(), words.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505516,
                "title": "short-and-fast-py3-solution",
                "content": "This exploits the fact that python has built-in lexicographic list comparison. The runtime is O(n * m) where n is the number of words and m is their average length, or equivalently, O(l) where l is the total number of letters in every word.\\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        if len(words) <= 1:\\n            return True\\n        \\n        ordict = {c: i for i, c in enumerate(order)}\\n\\t\\t\\n        def key(w):\\n            return [ordict[c] for c in w]\\n\\t\\t\\t\\n        for i in range(len(words) - 1):\\n            if key(words[i]) > key(words[i+1]):\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        if len(words) <= 1:\\n            return True\\n        \\n        ordict = {c: i for i, c in enumerate(order)}\\n\\t\\t\\n        def key(w):\\n            return [ordict[c] for c in w]\\n\\t\\t\\t\\n        for i in range(len(words) - 1):\\n            if key(words[i]) > key(words[i+1]):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442016,
                "title": "clean-go-solution",
                "content": "```go\\nvar pos = make([]int, \\'z\\'-\\'a\\'+1)\\n\\nfunc orderedWords(w1, w2 string) bool {\\n\\tfor i := 0; i < len(w1) && i < len(w2); i++ {\\n\\t\\tif w1[i] != w2[i] {\\n\\t\\t\\tif pos[w1[i]-\\'a\\'] > pos[w2[i]-\\'a\\'] {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn len(w1) <= len(w2)\\n}\\n\\nfunc isAlienSorted(words []string, order string) bool {\\n\\tfor i := range order {\\n\\t\\tpos[order[i]-\\'a\\'] = i\\n\\t}\\n\\n\\tfor i := 1; i < len(words); i++ {\\n\\t\\tif !orderedWords(words[i-1], words[i]) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nvar pos = make([]int, \\'z\\'-\\'a\\'+1)\\n\\nfunc orderedWords(w1, w2 string) bool {\\n\\tfor i := 0; i < len(w1) && i < len(w2); i++ {\\n\\t\\tif w1[i] != w2[i] {\\n\\t\\t\\tif pos[w1[i]-\\'a\\'] > pos[w2[i]-\\'a\\'] {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn len(w1) <= len(w2)\\n}\\n\\nfunc isAlienSorted(words []string, order string) bool {\\n\\tfor i := range order {\\n\\t\\tpos[order[i]-\\'a\\'] = i\\n\\t}\\n\\n\\tfor i := 1; i < len(words); i++ {\\n\\t\\tif !orderedWords(words[i-1], words[i]) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 387887,
                "title": "golang-ac-solution-using-a-custom-sorting-function",
                "content": "Time Complexity: `O(mnlog(n))` , m is the longest string\\'s length in `words`.\\nReference: https://stackoverflow.com/a/33453710/3970355\\n\\n```\\nfunc isAlienSorted(words []string, order string) bool {\\n\\t// save order into a map\\n\\tmp := map[byte]int{}\\n\\tfor i := 0; i < len(order); i++ {\\n\\t\\tmp[order[i]] = i\\n\\t}\\n\\t// keep the original words\\n\\torig := make([]string, len(words))\\n\\tcopy(orig, words)\\n\\t// use a custom sort here\\n\\tsort.Slice(words, func(i, j int) bool {\\n\\t\\ts1, s2 := words[i], words[j]\\n\\t\\tcomp := 0\\n\\t\\tfor i, j := 0, 0; i < len(s1) && j < len(s2) && comp == 0; i, j = i+1, j+1 {\\n\\t\\t\\tcomp = mp[s1[i]] - mp[s2[i]]\\n\\t\\t}\\n\\t\\t// all compared words are equal, we should check if the shorter one is before the longer one\\n\\t\\tif comp == 0 {\\n\\t\\t\\treturn len(s1) < len(s2)\\n\\t\\t}\\n\\t\\t// check the order is in asc\\n\\t\\treturn comp < 0\\n\\t})\\n\\t// compare the original one with the sorted one\\n\\treturn reflect.DeepEqual(orig, words)\\n}\\n```\\n\\n# Update at 2020/4/23\\nAs I did this problem again, I came up with a solution below. I belive it is cleaner than the version I\\'ve done last year. As I took advantage of `SliceIsSorted` in Golang\\'s `sort` package, deep copy was no more used. \\n```\\nfunc isAlienSorted(words []string, order string) bool {\\n\\tordMp := map[byte]int{}\\n\\tfor i := 0; i < len(order); i++ {\\n\\t\\tordMp[order[i]] = i\\n\\t}\\n\\treturn sort.SliceIsSorted(words, func(i, j int) bool {\\n\\t\\tx, y := words[i], words[j]\\n\\t\\tl := int(math.Min(float64(len(x)), float64(len(y))))\\n\\t\\tfor z := 0; z < l; z++ {\\n\\t\\t\\tif x[z] != y[z] {\\n\\t\\t\\t\\treturn ordMp[x[z]] < ordMp[y[z]]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn len(x) <= len(y)\\n\\t})\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sorting"
                ],
                "code": "```\\nfunc isAlienSorted(words []string, order string) bool {\\n\\t// save order into a map\\n\\tmp := map[byte]int{}\\n\\tfor i := 0; i < len(order); i++ {\\n\\t\\tmp[order[i]] = i\\n\\t}\\n\\t// keep the original words\\n\\torig := make([]string, len(words))\\n\\tcopy(orig, words)\\n\\t// use a custom sort here\\n\\tsort.Slice(words, func(i, j int) bool {\\n\\t\\ts1, s2 := words[i], words[j]\\n\\t\\tcomp := 0\\n\\t\\tfor i, j := 0, 0; i < len(s1) && j < len(s2) && comp == 0; i, j = i+1, j+1 {\\n\\t\\t\\tcomp = mp[s1[i]] - mp[s2[i]]\\n\\t\\t}\\n\\t\\t// all compared words are equal, we should check if the shorter one is before the longer one\\n\\t\\tif comp == 0 {\\n\\t\\t\\treturn len(s1) < len(s2)\\n\\t\\t}\\n\\t\\t// check the order is in asc\\n\\t\\treturn comp < 0\\n\\t})\\n\\t// compare the original one with the sorted one\\n\\treturn reflect.DeepEqual(orig, words)\\n}\\n```\n```\\nfunc isAlienSorted(words []string, order string) bool {\\n\\tordMp := map[byte]int{}\\n\\tfor i := 0; i < len(order); i++ {\\n\\t\\tordMp[order[i]] = i\\n\\t}\\n\\treturn sort.SliceIsSorted(words, func(i, j int) bool {\\n\\t\\tx, y := words[i], words[j]\\n\\t\\tl := int(math.Min(float64(len(x)), float64(len(y))))\\n\\t\\tfor z := 0; z < l; z++ {\\n\\t\\t\\tif x[z] != y[z] {\\n\\t\\t\\t\\treturn ordMp[x[z]] < ordMp[y[z]]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn len(x) <= len(y)\\n\\t})\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 307193,
                "title": "simple-python-beats-97",
                "content": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n    \\n        dictmap = {}\\n        for i, j in zip(order, range(97, 97 + 26)):\\n            dictmap[ord(i)] = chr(j)\\n    \\n        for i in range(len(words)-1):\\n            if words[i].translate(dictmap) > words[i+1].translate(dictmap):\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n    \\n        dictmap = {}\\n        for i, j in zip(order, range(97, 97 + 26)):\\n            dictmap[ord(i)] = chr(j)\\n    \\n        for i in range(len(words)-1):\\n            if words[i].translate(dictmap) > words[i+1].translate(dictmap):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847037,
                "title": "java-easy-solution-with-lambda-sort-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we can sort the array of string and then compare with the provided array it will certainly give the result. Main challenge is to sort the current array. If we apply sort method, it will sort according to our dictionary, so we need a custom sort function that will take the order from provided \"order\" string. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Take \"words\" array into a temporary array.\\n2. Sort \"words\" array with a custom sort function running on \"order\".\\n3. Check if resulting array is equal to that temporary array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        String[] temp = words.clone();\\n        Arrays.sort(words, (String a, String b) ->{\\n            int i = 0;\\n            while(a.charAt(i) == b.charAt(i)){\\n                if(i+1>a.length()-1) return -1;\\n                else if(i+1>b.length()-1) return 1;\\n                else i++;\\n            }\\n            if(order.indexOf(a.charAt(i)) < order.indexOf(b.charAt(i))) return -1;\\n            else return 1;\\n        });\\n        for (int i = 0; i < words.length; i++){\\n            if (!temp[i].equals(words[i])) \\n                return false;\\n        } \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        String[] temp = words.clone();\\n        Arrays.sort(words, (String a, String b) ->{\\n            int i = 0;\\n            while(a.charAt(i) == b.charAt(i)){\\n                if(i+1>a.length()-1) return -1;\\n                else if(i+1>b.length()-1) return 1;\\n                else i++;\\n            }\\n            if(order.indexOf(a.charAt(i)) < order.indexOf(b.charAt(i))) return -1;\\n            else return 1;\\n        });\\n        for (int i = 0; i < words.length; i++){\\n            if (!temp[i].equals(words[i])) \\n                return false;\\n        } \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734719,
                "title": "i-think-this-also-a-good-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing HashMap\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n * m)$$\\n\\n- Space complexity:\\n $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        //Approach: Using HashMap\\n        //Idea: First differing characters\\n        //      if word A is prefix of word B, word B must be After word A\\n        HashMap<Character, Integer> orderIdx = new HashMap<>();\\n        int idx = 0;\\n        for(char c:order.toCharArray()){\\n            orderIdx.put(c, idx++);\\n        }\\n\\n        //traverse through the words\\n        //words.length-1 because we will check the pairs\\n        for(int i=0;i<words.length-1;i++){\\n            String w1 = words[i], w2 = words[i+1];\\n\\n            //again traverse through the word w1\\n            for(int j=0;j<w1.length();j++){\\n                //base case\\n                if(j==w2.length()){\\n                    return false;\\n                }\\n                else if(w1.charAt(j)!=w2.charAt(j)){\\n                    if(orderIdx.get(w2.charAt(j))<orderIdx.get(w1.charAt(j))){\\n                        return false;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        //Approach: Using HashMap\\n        //Idea: First differing characters\\n        //      if word A is prefix of word B, word B must be After word A\\n        HashMap<Character, Integer> orderIdx = new HashMap<>();\\n        int idx = 0;\\n        for(char c:order.toCharArray()){\\n            orderIdx.put(c, idx++);\\n        }\\n\\n        //traverse through the words\\n        //words.length-1 because we will check the pairs\\n        for(int i=0;i<words.length-1;i++){\\n            String w1 = words[i], w2 = words[i+1];\\n\\n            //again traverse through the word w1\\n            for(int j=0;j<w1.length();j++){\\n                //base case\\n                if(j==w2.length()){\\n                    return false;\\n                }\\n                else if(w1.charAt(j)!=w2.charAt(j)){\\n                    if(orderIdx.get(w2.charAt(j))<orderIdx.get(w1.charAt(j))){\\n                        return false;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529308,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        int map[26];\\n        int alphabetOrder = 1;\\n        for(auto character : order)\\n        {\\n            map[character-\\'a\\'] = alphabetOrder;\\n            alphabetOrder++;\\n        }\\n        for(int i = 0; i < words.size() - 1; i++)\\n        {\\n            string first = words[i];\\n            string second = words[i+1];\\n            for(int j = 0; j < first.size(); j++)\\n            {\\n                if(j == second.size())\\n                    return false;\\n                if(map[first[j] - \\'a\\'] < map[second[j] - \\'a\\'])\\n                {\\n                    break;\\n                }\\n                if(map[first[j] - \\'a\\'] > map[second[j] - \\'a\\'])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        ans = {}\\n        for index, val in enumerate(order):\\n            ans[val] = index\\n\\n        for i in range(len(words) - 1):\\n            for j in range(len(words[i])):\\n\\n                if j >= len(words[i + 1]): \\n                    return False\\n\\n                if words[i][j] != words[i + 1][j]:\\n                    if ans[words[i][j]] > ans[words[i + 1][j]]: return False\\n                   \\n                    break\\n\\n        return True\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int[] pos = new int[order.length()];\\n        for (int i=0; i<order.length(); i++)\\n            pos[order.charAt(i)-\\'a\\'] = i;\\n        for (int i=1; i<words.length; i++) {\\n            String prev = words[i - 1], curr = words[i];\\n            int len = Math.min(prev.length(),curr.length());\\n            int countEqual = 0;\\n            for (int j=0; j<len; j++) {\\n                char p = prev.charAt(j), c = curr.charAt(j);\\n                if (pos[p-\\'a\\'] > pos[c-\\'a\\']) return false;\\n                else if (pos[p-\\'a\\'] == pos[c-\\'a\\']) countEqual++;\\n                else break;\\n            }\\n            if (countEqual == len && prev.length() > curr.length()) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        int map[26];\\n        int alphabetOrder = 1;\\n        for(auto character : order)\\n        {\\n            map[character-\\'a\\'] = alphabetOrder;\\n            alphabetOrder++;\\n        }\\n        for(int i = 0; i < words.size() - 1; i++)\\n        {\\n            string first = words[i];\\n            string second = words[i+1];\\n            for(int j = 0; j < first.size(); j++)\\n            {\\n                if(j == second.size())\\n                    return false;\\n                if(map[first[j] - \\'a\\'] < map[second[j] - \\'a\\'])\\n                {\\n                    break;\\n                }\\n                if(map[first[j] - \\'a\\'] > map[second[j] - \\'a\\'])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        ans = {}\\n        for index, val in enumerate(order):\\n            ans[val] = index\\n\\n        for i in range(len(words) - 1):\\n            for j in range(len(words[i])):\\n\\n                if j >= len(words[i + 1]): \\n                    return False\\n\\n                if words[i][j] != words[i + 1][j]:\\n                    if ans[words[i][j]] > ans[words[i + 1][j]]: return False\\n                   \\n                    break\\n\\n        return True\\n```\n```Java []\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int[] pos = new int[order.length()];\\n        for (int i=0; i<order.length(); i++)\\n            pos[order.charAt(i)-\\'a\\'] = i;\\n        for (int i=1; i<words.length; i++) {\\n            String prev = words[i - 1], curr = words[i];\\n            int len = Math.min(prev.length(),curr.length());\\n            int countEqual = 0;\\n            for (int j=0; j<len; j++) {\\n                char p = prev.charAt(j), c = curr.charAt(j);\\n                if (pos[p-\\'a\\'] > pos[c-\\'a\\']) return false;\\n                else if (pos[p-\\'a\\'] == pos[c-\\'a\\']) countEqual++;\\n                else break;\\n            }\\n            if (countEqual == len && prev.length() > curr.length()) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135184,
                "title": "usinga-hashmap-java-solution",
                "content": "# Intuition\\r\\n<!-- easy solution -->\\r\\n\\r\\n# Approach\\r\\n<!-- brute force approach using hashmap   -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- o(n^2)-->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    public boolean isAlienSorted(String[] words, String order) {\\r\\n        HashMap<Character,Integer> map = new HashMap<>();\\r\\n        String str=\"\";\\r\\n        String str1 = \"\";\\r\\n        for(int i=0;i<order.length();i++)\\r\\n        {\\r\\n            map.put(order.charAt(i),i);\\r\\n        }\\r\\n\\r\\n        for(int i=0;i<words.length-1;i++)\\r\\n        {\\r\\n            int n=Math.min(words[i].length(),words[i+1].length());\\r\\n             str=str+words[i];\\r\\n                 str1=str1+words[i+1];\\r\\n       boolean  flag = false;\\r\\n                 \\r\\n            for(int j=0;j<n;j++)\\r\\n            {  \\r\\n                if(map.get(words[i].charAt(j))<map.get(words[i+1].charAt(j)))\\r\\n                {\\r\\n                     flag=true;\\r\\n                     break;\\r\\n                    \\r\\n                }\\r\\n                else if(map.get(words[i].charAt(j))>map.get(words[i+1].charAt(j)))\\r\\n                {\\r\\n                    return false;\\r\\n                }\\r\\n                else \\r\\n                {   \\r\\n                    continue;\\r\\n                }\\r\\n              // return false;\\r\\n            }\\r\\n            if(!flag&&str.length()>str1.length()) return false;\\r\\n           \\r\\n        }\\r\\n        \\r\\n         return true;\\r\\n         \\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    public boolean isAlienSorted(String[] words, String order) {\\r\\n        HashMap<Character,Integer> map = new HashMap<>();\\r\\n        String str=\"\";\\r\\n        String str1 = \"\";\\r\\n        for(int i=0;i<order.length();i++)\\r\\n        {\\r\\n            map.put(order.charAt(i),i);\\r\\n        }\\r\\n\\r\\n        for(int i=0;i<words.length-1;i++)\\r\\n        {\\r\\n            int n=Math.min(words[i].length(),words[i+1].length());\\r\\n             str=str+words[i];\\r\\n                 str1=str1+words[i+1];\\r\\n       boolean  flag = false;\\r\\n                 \\r\\n            for(int j=0;j<n;j++)\\r\\n            {  \\r\\n                if(map.get(words[i].charAt(j))<map.get(words[i+1].charAt(j)))\\r\\n                {\\r\\n                     flag=true;\\r\\n                     break;\\r\\n                    \\r\\n                }\\r\\n                else if(map.get(words[i].charAt(j))>map.get(words[i+1].charAt(j)))\\r\\n                {\\r\\n                    return false;\\r\\n                }\\r\\n                else \\r\\n                {   \\r\\n                    continue;\\r\\n                }\\r\\n              // return false;\\r\\n            }\\r\\n            if(!flag&&str.length()>str1.length()) return false;\\r\\n           \\r\\n        }\\r\\n        \\r\\n         return true;\\r\\n         \\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134218,
                "title": "python-faster-than-100-easy-understanding-clean-concise-code",
                "content": "![image.png](https://assets.leetcode.com/users/images/1bfb0b03-f3bc-4356-aac9-0c9f866da59d_1675394528.1767328.png)\\n\\n# Complexity\\n- Time complexity:O(n)\\n- Space complexity: O(1)\\n# Code\\n```\\n# /953. Verifying an Alien Dictionary\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        orderIdx = {ch:i for i,ch in enumerate(order)}\\n        for i in range(len(words)-1):\\n            w1, w2 = words[i], words[i+1]\\n            for j in range(len(w1)):\\n                if j == len(w2):\\n                    return False\\n                if w1[j] != w2[j]:\\n                    if orderIdx[w2[j]] < orderIdx[w1[j]]:\\n                        return False\\n                    break\\n        return True\\n```\\nYou Can also Look At My SDE Prep Repo [\\uD83E\\uDDE2 GitHub](https://github.com/Ayon-SSP/The-SDE-Prep)\\n> Give It a \\uD83C\\uDF1F",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# /953. Verifying an Alien Dictionary\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        orderIdx = {ch:i for i,ch in enumerate(order)}\\n        for i in range(len(words)-1):\\n            w1, w2 = words[i], words[i+1]\\n            for j in range(len(w1)):\\n                if j == len(w2):\\n                    return False\\n                if w1[j] != w2[j]:\\n                    if orderIdx[w2[j]] < orderIdx[w1[j]]:\\n                        return False\\n                    break\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132723,
                "title": "easy-solution-using-maps-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        int n=words.size();\\n        map<char,int> mp;\\n        for(int i=0;i<order.size();i++)\\n        {\\n            mp[order[i]]=i;\\n        }\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int x=words[i].size();\\n            int y=words[i+1].size();\\n            string p=words[i].substr(0,min(x,y));\\n            string q=words[i+1].substr(0,min(x,y));\\n            if(p==q)\\n            {\\n                if(x==max(x,y) && x!=y)\\n                {\\n                    <!-- cout<<\"Yeah\"<<\" \"<<i<<endl; -->\\n                    return false;\\n                }\\n            }\\n            string s1=words[i];\\n            string s2=words[i+1];\\n            for(int j=0;j<min(x,y);j++)\\n            {\\n                if(mp[s1[j]]>mp[s2[j]])\\n                {\\n                    <!-- cout<<\"oh\"<<\" \"<<j<<endl; -->\\n                    return false;\\n                }\\n                else if(mp[s1[j]]<mp[s2[j]])\\n                    break;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        int n=words.size();\\n        map<char,int> mp;\\n        for(int i=0;i<order.size();i++)\\n        {\\n            mp[order[i]]=i;\\n        }\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int x=words[i].size();\\n            int y=words[i+1].size();\\n            string p=words[i].substr(0,min(x,y));\\n            string q=words[i+1].substr(0,min(x,y));\\n            if(p==q)\\n            {\\n                if(x==max(x,y) && x!=y)\\n                {\\n                    <!-- cout<<\"Yeah\"<<\" \"<<i<<endl; -->\\n                    return false;\\n                }\\n            }\\n            string s1=words[i];\\n            string s2=words[i+1];\\n            for(int j=0;j<min(x,y);j++)\\n            {\\n                if(mp[s1[j]]>mp[s2[j]])\\n                {\\n                    <!-- cout<<\"oh\"<<\" \"<<j<<endl; -->\\n                    return false;\\n                }\\n                else if(mp[s1[j]]<mp[s2[j]])\\n                    break;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3132501,
                "title": "full-python-explanation-for-beginners",
                "content": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        # First we make a dictionary where the keys are characters \\n        # and the  values are their index in the string \"order\"\\n        d = {char:i for i,char in enumerate(order)}\\n\\n        # This helper method will return whether a word \"w1\"\\n        # is lexicographically smaller than a word in \"w2\"\\n        def comp(w1, w2):\\n            # Go through the two words character by character\\n            for c1, c2 in zip(w1, w2):\\n                # If the character in word1 comes earlier in \"d\" \\n                # than the character in word 2, it is smaller!\\n                if d[c1] < d[c2]:\\n                    return True\\n                elif d[c2] < d[c1]:\\n                    # Otherwise, it is bigger so return False\\n                    return False\\n            # If the two words had the same character all throughout,\\n            # then we check if the first word is smaller or equal in length\\n            return len(w1) <= len(w2)\\n        \\n        # Return true if all the pairs of 2 words are properly in order!\\n        return all(comp(words[i],words[i+1]) for i in range(len(words)-1))\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        # First we make a dictionary where the keys are characters \\n        # and the  values are their index in the string \"order\"\\n        d = {char:i for i,char in enumerate(order)}\\n\\n        # This helper method will return whether a word \"w1\"\\n        # is lexicographically smaller than a word in \"w2\"\\n        def comp(w1, w2):\\n            # Go through the two words character by character\\n            for c1, c2 in zip(w1, w2):\\n                # If the character in word1 comes earlier in \"d\" \\n                # than the character in word 2, it is smaller!\\n                if d[c1] < d[c2]:\\n                    return True\\n                elif d[c2] < d[c1]:\\n                    # Otherwise, it is bigger so return False\\n                    return False\\n            # If the two words had the same character all throughout,\\n            # then we check if the first word is smaller or equal in length\\n            return len(w1) <= len(w2)\\n        \\n        # Return true if all the pairs of 2 words are properly in order!\\n        return all(comp(words[i],words[i+1]) for i in range(len(words)-1))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132425,
                "title": "video-explanation-solution-using-hashmap-beats-99-65",
                "content": "# Approach\\nhttps://youtu.be/hR5oGnTQ9hU\\n\\n# Code\\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        order_counter = {value: index for index, value in enumerate(order)}\\n\\n        for i in range(len(words)-1):\\n            word1, word2 = words[i], words[i+1]\\n\\n            for j in range(len(word1)):\\n                if j == len(word2):\\n                    return False\\n\\n                if word1[j] != word2[j]:\\n                    if order_counter[word2[j]] < order_counter[word1[j]]:\\n                        return False\\n\\n                    break\\n\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        order_counter = {value: index for index, value in enumerate(order)}\\n\\n        for i in range(len(words)-1):\\n            word1, word2 = words[i], words[i+1]\\n\\n            for j in range(len(word1)):\\n                if j == len(word2):\\n                    return False\\n\\n                if word1[j] != word2[j]:\\n                    if order_counter[word2[j]] < order_counter[word1[j]]:\\n                        return False\\n\\n                    break\\n\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132298,
                "title": "naive-approach-with-easy-explanation",
                "content": "# Intuition\\nLet the index be the comparison factor .The greater the index the later that character occurs in order string.\\n\\n# Approach\\nWe will compare two words at a time at position i and i+1.\\nIf order.indexOf(words[i].charAt(0))>order.indexOf(words[i+1].charAt(0))\\nwe return false\\nIf the first characcter is equal we go on to the next character of the same set of words.\\n\\n# Complexity\\nO(nk)\\nwhere, n=total number of words in array words\\nk=length of word\\n\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int n;\\n        n=words.length;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            //we will compare two words at a time at position i and i+1\\n            int k=0;\\n            char ch1,ch2;\\n            ch1=words[i].charAt(k);\\n            ch2=words[i+1].charAt(k);\\n            //let the index be the comparison factor .The greater the index the later that character occurs in order string.\\n            if(order.indexOf(ch1)>order.indexOf(ch2))\\n                return false;\\n            //If the first chracater is equal we go on to the next character of the same words\\n            if(order.indexOf(ch1)==order.indexOf(ch2))\\n            {\\n                while(k<words[i].length()-1 && k<words[i+1].length()-1)\\n                {\\n                    k++;\\n                    ch1=words[i].charAt(k);\\n                    ch2=words[i+1].charAt(k);\\n                    if(order.indexOf(ch1)>order.indexOf(ch2))\\n                        return false;\\n                }\\n\\n                if(words[i].length()>words[i+1].length() && words[i].substring(0,k+1).equals(words[i+1]) )\\n                    return false;\\n            }\\n            continue;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int n;\\n        n=words.length;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            //we will compare two words at a time at position i and i+1\\n            int k=0;\\n            char ch1,ch2;\\n            ch1=words[i].charAt(k);\\n            ch2=words[i+1].charAt(k);\\n            //let the index be the comparison factor .The greater the index the later that character occurs in order string.\\n            if(order.indexOf(ch1)>order.indexOf(ch2))\\n                return false;\\n            //If the first chracater is equal we go on to the next character of the same words\\n            if(order.indexOf(ch1)==order.indexOf(ch2))\\n            {\\n                while(k<words[i].length()-1 && k<words[i+1].length()-1)\\n                {\\n                    k++;\\n                    ch1=words[i].charAt(k);\\n                    ch2=words[i+1].charAt(k);\\n                    if(order.indexOf(ch1)>order.indexOf(ch2))\\n                        return false;\\n                }\\n\\n                if(words[i].length()>words[i+1].length() && words[i].substring(0,k+1).equals(words[i+1]) )\\n                    return false;\\n            }\\n            continue;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132003,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        char_to_inx = dict()\\n        for inx, c in enumerate(order):\\n            char_to_inx[c] = inx\\n        for j in range(1, len(words)):\\n            cur_len = len(words[j])\\n            prev_len = len(words[j-1])\\n            p, q = 0, 0\\n            while p < cur_len and q < prev_len:\\n                if char_to_inx[words[j][p]] < char_to_inx[words[j-1][q]]:\\n                    return False\\n                if char_to_inx[words[j][p]] > char_to_inx[words[j-1][q]]:\\n                    break\\n                p+=1\\n                q+=1\\n            if p == cur_len and q < prev_len:\\n                return False        \\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        char_to_inx = dict()\\n        for inx, c in enumerate(order):\\n            char_to_inx[c] = inx\\n        for j in range(1, len(words)):\\n            cur_len = len(words[j])\\n            prev_len = len(words[j-1])\\n            p, q = 0, 0\\n            while p < cur_len and q < prev_len:\\n                if char_to_inx[words[j][p]] < char_to_inx[words[j-1][q]]:\\n                    return False\\n                if char_to_inx[words[j][p]] > char_to_inx[words[j-1][q]]:\\n                    break\\n                p+=1\\n                q+=1\\n            if p == cur_len and q < prev_len:\\n                return False        \\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131923,
                "title": "java-hashmap-simple-and-easy",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        //Mapping alphabets\\n        Map<Character,Integer> map = new HashMap<>();\\n        int index=1;\\n        for(int i=0;i<order.length();i++)\\n            map.put(order.charAt(i),index++);\\n        for(int i=1;i<words.length;i++){\\n            int j=0;         \\n            while(j < words[i].length() || j < words[i-1].length()){\\n                if(j >= words[i-1].length()){\\n                    break;\\n                }\\n                if(j >= words[i].length()){\\n                    return false;\\n                }\\n                char a = words[i-1].charAt(j);\\n                char b = words[i].charAt(j);\\n                if(map.get(a) > map.get(b)) return false;\\n                else if(map.get(a) < map.get(b)) break;\\n                j++;\\n            }\\n        } \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        //Mapping alphabets\\n        Map<Character,Integer> map = new HashMap<>();\\n        int index=1;\\n        for(int i=0;i<order.length();i++)\\n            map.put(order.charAt(i),index++);\\n        for(int i=1;i<words.length;i++){\\n            int j=0;         \\n            while(j < words[i].length() || j < words[i-1].length()){\\n                if(j >= words[i-1].length()){\\n                    break;\\n                }\\n                if(j >= words[i].length()){\\n                    return false;\\n                }\\n                char a = words[i-1].charAt(j);\\n                char b = words[i].charAt(j);\\n                if(map.get(a) > map.get(b)) return false;\\n                else if(map.get(a) < map.get(b)) break;\\n                j++;\\n            }\\n        } \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131800,
                "title": "python-solution-using-a-hash-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Compare adjacent words: ```words[i]``` and ```words[i-1]``` based on the ```order```\\n- Return False if we find two words that are not sorted. Otherwise returne True.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Use a dictionary to store the mapping between the character and its position in the new ```order```\\n- When comparing two adjecent words\\n    - We can use the characters in each word to access the dictionary value\\n    - We also need a ```is_prefix``` flag to keep track of whether one word is a prefix of the other\\n        - The prefix should be placed on the left side (i.e., ```word[i-1]```)\\n            - We can compare the length of the word to find out\\n# Complexity\\n- Time complexity: $O(n)$, where n is the number of characters (not words) in ```words```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$, there are only 26 characters\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        d = collections.defaultdict(int)\\n        for i in range(len(order)):\\n            d[order[i]] = i\\n        n = len(words)\\n        if n == 1:\\n            return True\\n        for i in range(1, n):\\n            j = 0\\n            is_prefix = True\\n            for j in range(min(len(words[i]), len(words[i-1]))):\\n                if d[words[i][j]] < d[words[i-1][j]]:\\n                    return False\\n                elif d[words[i][j]] > d[words[i-1][j]]:\\n                    is_prefix = False\\n                    break\\n            if is_prefix:\\n                if len(words[i]) < len(words[i-1]):\\n                    return False\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```words[i]```\n```words[i-1]```\n```order```\n```order```\n```is_prefix```\n```word[i-1]```\n```words```\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        d = collections.defaultdict(int)\\n        for i in range(len(order)):\\n            d[order[i]] = i\\n        n = len(words)\\n        if n == 1:\\n            return True\\n        for i in range(1, n):\\n            j = 0\\n            is_prefix = True\\n            for j in range(min(len(words[i]), len(words[i-1]))):\\n                if d[words[i][j]] < d[words[i-1][j]]:\\n                    return False\\n                elif d[words[i][j]] > d[words[i-1][j]]:\\n                    is_prefix = False\\n                    break\\n            if is_prefix:\\n                if len(words[i]) < len(words[i-1]):\\n                    return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131482,
                "title": "0ms-100-fast-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        for(int i=0;i<words.length-1;i++){\\n            if(order.indexOf(words[i].charAt(0))>order.indexOf(words[i+1].charAt(0))){\\n                return false;\\n            }\\n            if(words[i].charAt(0)==words[i+1].charAt(0)){\\n                int n=words[i].length()<=words[i+1].length()  ? words[i].length():words[i+1].length();\\n                int f=0;\\n                for(int j=1;j<n;j++){\\n                    if(order.indexOf(words[i].charAt(j))>order.indexOf(words[i+1].charAt(j))){\\n                        return false;\\n                    }\\n                    else if(order.indexOf(words[i].charAt(j))<order.indexOf(words[i+1].charAt(j))){                     f=1;\\n                        break;\\n                    }\\n                }\\n                if(f==0&&(words[i].length()>words[i+1].length())){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        for(int i=0;i<words.length-1;i++){\\n            if(order.indexOf(words[i].charAt(0))>order.indexOf(words[i+1].charAt(0))){\\n                return false;\\n            }\\n            if(words[i].charAt(0)==words[i+1].charAt(0)){\\n                int n=words[i].length()<=words[i+1].length()  ? words[i].length():words[i+1].length();\\n                int f=0;\\n                for(int j=1;j<n;j++){\\n                    if(order.indexOf(words[i].charAt(j))>order.indexOf(words[i+1].charAt(j))){\\n                        return false;\\n                    }\\n                    else if(order.indexOf(words[i].charAt(j))<order.indexOf(words[i+1].charAt(j))){                     f=1;\\n                        break;\\n                    }\\n                }\\n                if(f==0&&(words[i].length()>words[i+1].length())){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131112,
                "title": "python-beginner-friendly-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n\\n        alp = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        d = {}\\n        for i in range(26):\\n            d[order[i]] = alp[i]\\n\\n        def f(st: str) -> str:\\n            normal = \\'\\'\\n            for i in st:\\n                normal += d[i]\\n            return normal\\n\\n        for i in range(len(words)-1):\\n            if f(words[i]) > f(words[i+1]):\\n                return False\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n\\n        alp = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        d = {}\\n        for i in range(26):\\n            d[order[i]] = alp[i]\\n\\n        def f(st: str) -> str:\\n            normal = \\'\\'\\n            for i in st:\\n                normal += d[i]\\n            return normal\\n\\n        for i in range(len(words)-1):\\n            if f(words[i]) > f(words[i+1]):\\n                return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131024,
                "title": "simple-java-c-easy-few-lines-code-100-working-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int [] orderMap = new int[26];\\n        for (int i = 0; i < order.length(); i++){\\n            orderMap[order.charAt(i) - \\'a\\'] = i;\\n        }\\n        \\n        for(int i =1;i< words.length;i++){\\n            if(!compare(orderMap, words[i],words[i-1]))return false;\\n        }\\n        return true;\\n        \\n    }\\n    \\n    public boolean compare(int [] orderMap, String s1, String s2){\\n            \\n            int j = 0;\\n            while(j<s1.length() && j<s2.length()){\\n                if(s1.charAt(j) == s2.charAt(j)) j++;\\n                else if(orderMap[s1.charAt(j)-\\'a\\']>orderMap[s2.charAt(j)-\\'a\\']) return true;\\n                else return false;\\n            }\\n            if(s1.length()<s2.length())return false;\\n            return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int [] orderMap = new int[26];\\n        for (int i = 0; i < order.length(); i++){\\n            orderMap[order.charAt(i) - \\'a\\'] = i;\\n        }\\n        \\n        for(int i =1;i< words.length;i++){\\n            if(!compare(orderMap, words[i],words[i-1]))return false;\\n        }\\n        return true;\\n        \\n    }\\n    \\n    public boolean compare(int [] orderMap, String s1, String s2){\\n            \\n            int j = 0;\\n            while(j<s1.length() && j<s2.length()){\\n                if(s1.charAt(j) == s2.charAt(j)) j++;\\n                else if(orderMap[s1.charAt(j)-\\'a\\']>orderMap[s2.charAt(j)-\\'a\\']) return true;\\n                else return false;\\n            }\\n            if(s1.length()<s2.length())return false;\\n            return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130950,
                "title": "simple-approach-explained",
                "content": "# Intuition\\nThe first step is to create an array of characters that we then would map each word in the alphabet with its new order in the alien dictionary\\n\\n**Example : Alien dictionary is \"hlabcdefgijkmnopqrstuvwxyz\" our array would be \\n[c, d, e, f, g, h, i, a, j, k, l, b, m, n, o, p, q, r, s, t, u, v, w, x, y, z]**\\n\\nnotice since h is the first character in the alien dictionary its position in the array (8) is a, since z comes last its position doesn\\'t change\\n\\nThen we loop through every word in the words array and replace the occurance of each character with its new order\\n\\nLastly we compare each new ordered string with the one before it\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean isAlienSorted(String[] words, String order) {\\n\\n        char[] dictionary = new char[26];\\n\\n        for (int i = 0; i < order.length(); i++) {\\n            char c= (char) (\\'a\\'+i);\\n            dictionary[order.charAt(i)-\\'a\\']=c;\\n        }\\n\\n        boolean firstWord = true;\\n        String previous = \"\";\\n        StringBuilder current = new StringBuilder(\"\");\\n\\n        for (String word: words) {\\n            for (int i = 0; i < word.length(); i++) {\\n                char currentChar = dictionary[word.charAt(i) - \\'a\\'];\\n                current.append(currentChar);\\n            }\\n\\n            if(firstWord){\\n                firstWord=false;\\n                previous=current.toString();\\n                current.setLength(0);\\n                continue;\\n            }\\n\\n            if(previous.compareTo(current.toString()) >0){\\n                return false;\\n            }\\n\\n            previous=current.toString();\\n            current.setLength(0);\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean isAlienSorted(String[] words, String order) {\\n\\n        char[] dictionary = new char[26];\\n\\n        for (int i = 0; i < order.length(); i++) {\\n            char c= (char) (\\'a\\'+i);\\n            dictionary[order.charAt(i)-\\'a\\']=c;\\n        }\\n\\n        boolean firstWord = true;\\n        String previous = \"\";\\n        StringBuilder current = new StringBuilder(\"\");\\n\\n        for (String word: words) {\\n            for (int i = 0; i < word.length(); i++) {\\n                char currentChar = dictionary[word.charAt(i) - \\'a\\'];\\n                current.append(currentChar);\\n            }\\n\\n            if(firstWord){\\n                firstWord=false;\\n                previous=current.toString();\\n                current.setLength(0);\\n                continue;\\n            }\\n\\n            if(previous.compareTo(current.toString()) >0){\\n                return false;\\n            }\\n\\n            previous=current.toString();\\n            current.setLength(0);\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130926,
                "title": "easy-c-intuitive-solution-tc-o-n-sc-o-1-well-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConvert the alien\\'s dictionary into normal one, then convert the words by it. Finally compare every word in word list from start to end, if any of them are not sorted lexicographically, return false, otherwise return true.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a vector<int> to save the order, the vector\\'s index means the alien\\'s order, value means normal order.\\nFor example, input order is \"hla\"... , then we will save as V[\\'h\\'-\\'a\\'] = 0 , V[\\'l\\'-\\'a\\'] = 1 , \\nV[\\'a\\'-\\'a\\'] = 2 , that is, their \\'h\\', \\'l\\', \\'a\\' equal our \\'a\\', \\'b\\', \\'c\\' respectively.\\n\\nBy this vector, we can convert every word in word list into our language.\\n\\nFinally, in lexicographical order, \"a\" must be the smallest word, so we initialize the cur string to \"a\".\\nThen compare word throughout the list, if any of them are smaller than cur, which means some words are not sorted lexicographically, return false. \\nOtherwise, let cur equal to current word and keep comparing until the end, then return true.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1. convert words : O(n)\\n2. comapre words : O(n)\\n- Space complexity: O(1)\\nOnly use the constant vector and a string\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        vector<int> V(26);\\n        for (int i = 0; i < order.size(); i++) {\\n            V[order[i]-\\'a\\'] = i;\\n        }\\n\\n        for (string &word : words) {\\n            for (char &c : word) {\\n                c = V[c-\\'a\\'] + \\'a\\';\\n            }\\n        }\\n        string cur = \"a\";\\n        for (string word : words) {\\n            if (word >= cur) {\\n                cur = word;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        vector<int> V(26);\\n        for (int i = 0; i < order.size(); i++) {\\n            V[order[i]-\\'a\\'] = i;\\n        }\\n\\n        for (string &word : words) {\\n            for (char &c : word) {\\n                c = V[c-\\'a\\'] + \\'a\\';\\n            }\\n        }\\n        string cur = \"a\";\\n        for (string word : words) {\\n            if (word >= cur) {\\n                cur = word;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130875,
                "title": "you-will-not-find-more-simpller-approach-than-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(M+N) but N is fixed so O(M)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)// because we are using hashmap to store fixed chars\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        \\n        HashMap<Character,Integer> map = new HashMap<>();\\n\\n        int k = 1;\\n\\n        //adding to character to dictionary\\n\\n        for(int i =0; i < order.length(); i++){\\n\\n            if(map.containsKey(order.charAt(i))){\\n                continue;\\n            }\\n            else{\\n                map.put(order.charAt(i),k++);\\n            }\\n        }\\n\\n        //traverse in the words array\\n\\n        boolean check = true;\\n\\n        for(int i = 0; i < words.length-1; i++){\\n\\n            String first = words[i];\\n            String second = words[i+1];\\n\\n            // find minimum length of first and second\\n\\n                int len  = Math.min(first.length(),second.length());\\n\\n                for(int j = 0; j < len;j++){\\n\\n                    //if the charAt(j) in first is less than charAt(j) in second\\n\\n                    if(map.get(first.charAt(j)) < map.get(second.charAt(j))){\\n                        check = false;\\n                        break;\\n                        //return true;\\n                    }\\n\\n                    //if the charAt(j) in first is equal greater to charAt(j) in second means they are unorderd\\n\\n                     else if(map.get(first.charAt(j)) > map.get(second.charAt(j))){\\n                        return false;\\n                    }\\n\\n                    //if the charAt(j) in first is equal to charAt(j) in second then move forward\\n                    \\n                    else{\\n                        continue;\\n                    }\\n                }\\n\\n                //check will remain true only if for loop has compleated without any break and return statement\\n                //If the loop has completed and check is true and first length is greater than second length\\n\\n                if(check && first.length() > second.length()){\\n                    return false;\\n                }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        \\n        HashMap<Character,Integer> map = new HashMap<>();\\n\\n        int k = 1;\\n\\n        //adding to character to dictionary\\n\\n        for(int i =0; i < order.length(); i++){\\n\\n            if(map.containsKey(order.charAt(i))){\\n                continue;\\n            }\\n            else{\\n                map.put(order.charAt(i),k++);\\n            }\\n        }\\n\\n        //traverse in the words array\\n\\n        boolean check = true;\\n\\n        for(int i = 0; i < words.length-1; i++){\\n\\n            String first = words[i];\\n            String second = words[i+1];\\n\\n            // find minimum length of first and second\\n\\n                int len  = Math.min(first.length(),second.length());\\n\\n                for(int j = 0; j < len;j++){\\n\\n                    //if the charAt(j) in first is less than charAt(j) in second\\n\\n                    if(map.get(first.charAt(j)) < map.get(second.charAt(j))){\\n                        check = false;\\n                        break;\\n                        //return true;\\n                    }\\n\\n                    //if the charAt(j) in first is equal greater to charAt(j) in second means they are unorderd\\n\\n                     else if(map.get(first.charAt(j)) > map.get(second.charAt(j))){\\n                        return false;\\n                    }\\n\\n                    //if the charAt(j) in first is equal to charAt(j) in second then move forward\\n                    \\n                    else{\\n                        continue;\\n                    }\\n                }\\n\\n                //check will remain true only if for loop has compleated without any break and return statement\\n                //If the loop has completed and check is true and first length is greater than second length\\n\\n                if(check && first.length() > second.length()){\\n                    return false;\\n                }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130710,
                "title": "linear-scan-order",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char, int> val;\\n        for(int i = 0; i < 26; i++)\\n            val[order[i]] = i;\\n        int n = words.size();\\n        for(int i = 1; i < n; i++) {\\n            int c, l0 = words[i - 1].length(), l1 = words[i].length();\\n            for(c = 0; c < l0 && c < l1; c++) {\\n                if(val[words[i - 1][c]] > val[words[i][c]])\\n                    return false;\\n                if(val[words[i - 1][c]] < val[words[i][c]])\\n                    break;\\n            }\\n            if(c == l1 && c < l0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char, int> val;\\n        for(int i = 0; i < 26; i++)\\n            val[order[i]] = i;\\n        int n = words.size();\\n        for(int i = 1; i < n; i++) {\\n            int c, l0 = words[i - 1].length(), l1 = words[i].length();\\n            for(c = 0; c < l0 && c < l1; c++) {\\n                if(val[words[i - 1][c]] > val[words[i][c]])\\n                    return false;\\n                if(val[words[i - 1][c]] < val[words[i][c]])\\n                    break;\\n            }\\n            if(c == l1 && c < l0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130584,
                "title": "c-easiest-solution-with-explanation-hashing",
                "content": "# Intuition\\nFirstly , Just To Be Clear , The Question says we need to check weather words are sorted or not . \\nSome of you might have understood it as to chechk if each word is sorted or not .\\n\\nThe idea is we will compare first letter of curr word with letter of  previous word . There will be three cases .\\n1. If  first letter of curr word i.e. word[i][0] is less than first letter of previous word i.e. word[i-1][0] (in String Order) . we simply return false.\\n2. If both are equal we move to next index of both words i.e. index 1;\\n3. If above two cases are false . we increment i and move ahead.\\n\\n\\nNow to check ordereing we will make an array converter of size 26 to \\nwhere each block represents letters\\nconverter[0] = a;\\nconverter[1] = b;\\nconverter[2] = c and so on\\n\\nand the letter which has come first will be given 0 and next letter will be set with 1 and so on.\\nex : Order = \"mnabcdefghijklopqrstuvwxyz\"\\nconverter[\\'m\\'-\\'a\\'] = 0;\\nconverter[\\'n\\'-\\'a\\'] = 1;\\nconverter[\\'a\\'-\\'a\\'] = 2;\\nconverter[\\'b\\'-\\'a\\'] = 3;\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    bool isAlienSorted(vector<string>& word, string order) {\\n \\n       vector<int> converter(26, 0);\\n        for(int k = 0 ; k<26 ; k++)\\n        converter[order[k]-\\'a\\'] = k;\\n\\n        int i = 1;\\n\\n        while(i<word.size())\\n        {\\n           // Case 1\\n           if(converter[word[i][0]-\\'a\\']<converter[word[i-1][0]-\\'a\\'])\\n           return false;\\n           // Case 2\\n           else if(converter[word[i][0]-\\'a\\'] == converter[word[i-1][0]-\\'a\\'])\\n           {\\n               int j = 1;\\n\\n               while(j<word[i].size() && j<word[i-1].size())\\n               {\\n                   if(converter[word[i][j]-\\'a\\'] == converter[word[i-1][j]-\\'a\\'])\\n                   j++;\\n                   else\\n                   break;\\n               }\\n\\n               if(j == word[i].size() && j != word[i-1].size())\\n               return false;\\n               else if(j<word[i].size() && j<word[i-1].size()) \\n               {\\n                   if(converter[word[i][j]-\\'a\\'] < converter[word[i-1][j]-\\'a\\'])\\n                   return false;\\n               }\\n           }\\n\\n           // Case 3\\n           i++;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    bool isAlienSorted(vector<string>& word, string order) {\\n \\n       vector<int> converter(26, 0);\\n        for(int k = 0 ; k<26 ; k++)\\n        converter[order[k]-\\'a\\'] = k;\\n\\n        int i = 1;\\n\\n        while(i<word.size())\\n        {\\n           // Case 1\\n           if(converter[word[i][0]-\\'a\\']<converter[word[i-1][0]-\\'a\\'])\\n           return false;\\n           // Case 2\\n           else if(converter[word[i][0]-\\'a\\'] == converter[word[i-1][0]-\\'a\\'])\\n           {\\n               int j = 1;\\n\\n               while(j<word[i].size() && j<word[i-1].size())\\n               {\\n                   if(converter[word[i][j]-\\'a\\'] == converter[word[i-1][j]-\\'a\\'])\\n                   j++;\\n                   else\\n                   break;\\n               }\\n\\n               if(j == word[i].size() && j != word[i-1].size())\\n               return false;\\n               else if(j<word[i].size() && j<word[i-1].size()) \\n               {\\n                   if(converter[word[i][j]-\\'a\\'] < converter[word[i-1][j]-\\'a\\'])\\n                   return false;\\n               }\\n           }\\n\\n           // Case 3\\n           i++;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130500,
                "title": "python-java-easy-solutions-beats-100",
                "content": "# ONE LIKE = BOOST \\u26A1\\uD83D\\uDE80\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhere we are first trying to convert our string into a dictionary form or in a map, where we will store indexes of the alphabet form orders.\\n\\n- which can then be used to compare elements later on.\\n\\n1. Now we are using 2 for loops first to iterate words[]\\n2. Second is to iterate over the character of individual elments.\\n3. now for the cases like ```[\\'apple\\',\\'app\\'] ``` we are checking so that our jth value means apple lenght doesnt exceed the lenght of next element if does then we will return false.\\n4. now we are storing the vlaue of ```ith words\\'s jth character``` in current and ```i+1th words\\'s jth character``` in next.\\n5. Once we are done we will check if they are not equal if they did then j\\'s value will increase.\\n6. If not we will be compairing current character index from dictionary .\\n7. if current index is greater which doesn\\'t follow sorted list so we will return False\\n8. and then break or once iterated from every case passing all we will return True.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M)    M = length of words[]\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n# JAVA\\n```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int[] dic = new int[26];\\n        for (int i = 0; i <order.length(); i++){\\n            dic[order.charAt(i)-\\'a\\'] = i;\\n        }\\n        for (int i=0 ; i <words.length-1 ;i++){\\n            for (int j =0; j < words[i].length(); j++ ){\\n                if (j>= words[i+1].length())\\n                return false;\\n                int curr = words[i].charAt(j)-\\'a\\'; \\n                int next = words[i+1].charAt(j)-\\'a\\'; \\n                if (curr != next){\\n                    if(dic[curr] > dic[next]){\\n                        return false;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n# PYTHON\\n```\\nclass Solution(object):\\n    def isAlienSorted(self, words, order):\\n        \"\"\"\\n        :type words: List[str]\\n        :type order: str\\n        :rtype: bool\\n        \"\"\"\\n\\n        dic = {}\\n        for i in range (len(order)):\\n            dic[order[i]] = i\\n        for i in range(len(words)-1):\\n            for j in range(len(words[i])):\\n                if j>= len(words[i]) or j>= len(words[i+1]):\\n                    return False\\n                one = words[i][j]\\n                two = words[i+1][j]\\n                if (one!= two):\\n                    if dic[one] > dic[two]:\\n                        return False\\n                    break\\n\\n        return True\\n        \\n\\nif __name__ == \"__main__\":\\n    words = [\"kuvp\",\"q\"]    \\n    order = \"ngxlkthsjuoqcpavbfdermiywz\"\\n    print(Solution().isAlienSorted(words, order))\\n```",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```[\\'apple\\',\\'app\\'] ```\n```ith words\\'s jth character```\n```i+1th words\\'s jth character```\n```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int[] dic = new int[26];\\n        for (int i = 0; i <order.length(); i++){\\n            dic[order.charAt(i)-\\'a\\'] = i;\\n        }\\n        for (int i=0 ; i <words.length-1 ;i++){\\n            for (int j =0; j < words[i].length(); j++ ){\\n                if (j>= words[i+1].length())\\n                return false;\\n                int curr = words[i].charAt(j)-\\'a\\'; \\n                int next = words[i+1].charAt(j)-\\'a\\'; \\n                if (curr != next){\\n                    if(dic[curr] > dic[next]){\\n                        return false;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def isAlienSorted(self, words, order):\\n        \"\"\"\\n        :type words: List[str]\\n        :type order: str\\n        :rtype: bool\\n        \"\"\"\\n\\n        dic = {}\\n        for i in range (len(order)):\\n            dic[order[i]] = i\\n        for i in range(len(words)-1):\\n            for j in range(len(words[i])):\\n                if j>= len(words[i]) or j>= len(words[i+1]):\\n                    return False\\n                one = words[i][j]\\n                two = words[i+1][j]\\n                if (one!= two):\\n                    if dic[one] > dic[two]:\\n                        return False\\n                    break\\n\\n        return True\\n        \\n\\nif __name__ == \"__main__\":\\n    words = [\"kuvp\",\"q\"]    \\n    order = \"ngxlkthsjuoqcpavbfdermiywz\"\\n    print(Solution().isAlienSorted(words, order))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130453,
                "title": "simple-solution-explanation-hashing",
                "content": "# Intuition\\nFrom the `words []`array take two words at a time, and compare whether the first one is Lexicographically smaller than the second one, by comparing them letter by letter as per the given **Lexicographic order specific to the Alien Dictionary**\\n\\n- Eg: In **our human dictionary** Lexicographic order is $$A$$ *to* $$Z$$\\n- But for the **Alien dictionary** the specific **`order`** is as given in each test case.\\n- We need to check whether the given `words []` follow the $$Lexicographic$$ **`order` of the Aliens**.\\n\\n# Approach\\n- A HashMap is required to store the letters and their respective order in the **Alien Dictionary** i.e. letter-order relations\\n- Iterate over the words[] taking two at a time and compare the two words letter by letter.\\n- Possibilities while comparing the first letter of two words:\\n\\n    - First letter of word1 > first letter of word2 : `return false`\\n    - First letter of word1 < word2 : `continue` with the next set of two words\\n    - First letter of word1 == word2\\n```\\n    1.  if(hm.get(words[i].charAt(0)) > hm.get(words[i+1].charAt(0)))\\n            return false;\\n    2.  if(hm.get(words[i].charAt(0)) < hm.get(words[i+1].charAt(0)))\\n            continue;\\n    3.  if(hm.get(words[i].charAt(0)) == hm.get(words[i+1].charAt(0)))\\n            // Begin comparing subsequent letters\\n```\\n- If the first Letter of Two consecutive words match we start comparing the subsequent letters. \\n    -  We use an inner loop for this with loop variable `j`. \\n    - The loop continues until end of one of the words is reached. \\n    - Possibilities while comparing the subsequent letters are letter of two words are:\\n>\\n    1.  if(hm.get(words[i].charAt(j)) > hm.get(words[i+1].charAt(j)))  return false;\\n    2.  if(hm.get(words[i].charAt(j)) < hm.get(words[i+1].charAt(j)))\\n            continue;\\n    3.  if(hm.get(words[i].charAt(j)) == hm.get(words[i+1].charAt(j)))\\n            // Keep count of same letters for comparison\\n\\n\\n\\n# Complexity\\nLet $$N$$ be the length of order, and $$M$$ be the total number of characters in words.\\n\\n- Time complexity:$$O(M)$$ \\n\\n- Space complexity: $$O(1)$$\\n > The only extra data structure used is the hashmap for storing the letter-order relations for each word in order. Since the length of order is fixed as $$26$$, this approach achieves constant space complexity\\n \\n\\n##### Explanation has been included in the comments\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public boolean isAlienSorted(String[] words, String order) \\n    {\\n        // A HashMap is required to store the letters and their \\n        // respective order in the Alien Dictionary.\\n\\n        char[] orderAr = order.toCharArray();\\n        HashMap<Character, Integer> hm= new HashMap<>();\\n        for(int i=0; i<orderAr.length; i++)\\n        {\\n            hm.put(orderAr[i], i);\\n        }\\n\\n        // Iterate over the words[] taking two at a time nd compare\\n        // the two words letter by letter.\\n\\n        // Outer loop : to select two words at a time from words[]\\n        for(int i=0; i+1<words.length ;i++)        \\n        {\\n            if(hm.get(words[i].charAt(0)) < hm.get(words[i+1].charAt(0)))\\n                continue;\\n            else if(hm.get(words[i].charAt(0)) > hm.get(words[i+1].charAt(0)))\\n                return false;\\n            // If the first letter of the two words is same\\n            else if(hm.get(words[i].charAt(0)) == hm.get(words[i+1].charAt(0)))\\n            {\\n                int l1 = words[i].length(), ctr=0;\\n                int l2 = words[i+1].length();\\n\\n                // Inner loop : to compare letters of two adjacent words from words[]\\n                for(int j=1; j<l1 && j<l2; j++)\\n                {\\n                    if(hm.get(words[i].charAt(j)) < hm.get(words[i+1].charAt(j)))\\n                        continue;\\n                    else if(hm.get(words[i].charAt(j)) > hm.get(words[i+1].charAt(j)))\\n                        return false;\\n                    else if(hm.get(words[i].charAt(j)) == hm.get(words[i+1].charAt(j)))\\n                        ctr++;  \\n                    // ctr maintains the count of number of common letters in the same order\\n                    //Debug : System.out.println(words[i].charAt(j)+\" \"+words[i+1].charAt(j));\\n                }\\n                // To handle the corner cases\\n                if(l2<l1 && ctr+1==l2)   // Eg: Test Case 3\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/233ac516-90a9-47bf-a33d-9cccf3158bc7_1675355065.7826693.png)\\n\\n**Hope it helps \\u2764\\uFE0F\\u2764\\uFE0F**\\n*Please do **Upvote** if you find it useful.*\\n*Also if you have any suggestion or query do comment.*\\n***Thank you.***\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\n    1.  if(hm.get(words[i].charAt(0)) > hm.get(words[i+1].charAt(0)))\\n            return false;\\n    2.  if(hm.get(words[i].charAt(0)) < hm.get(words[i+1].charAt(0)))\\n            continue;\\n    3.  if(hm.get(words[i].charAt(0)) == hm.get(words[i+1].charAt(0)))\\n            // Begin comparing subsequent letters\\n```\n```\\nclass Solution \\n{\\n    public boolean isAlienSorted(String[] words, String order) \\n    {\\n        // A HashMap is required to store the letters and their \\n        // respective order in the Alien Dictionary.\\n\\n        char[] orderAr = order.toCharArray();\\n        HashMap<Character, Integer> hm= new HashMap<>();\\n        for(int i=0; i<orderAr.length; i++)\\n        {\\n            hm.put(orderAr[i], i);\\n        }\\n\\n        // Iterate over the words[] taking two at a time nd compare\\n        // the two words letter by letter.\\n\\n        // Outer loop : to select two words at a time from words[]\\n        for(int i=0; i+1<words.length ;i++)        \\n        {\\n            if(hm.get(words[i].charAt(0)) < hm.get(words[i+1].charAt(0)))\\n                continue;\\n            else if(hm.get(words[i].charAt(0)) > hm.get(words[i+1].charAt(0)))\\n                return false;\\n            // If the first letter of the two words is same\\n            else if(hm.get(words[i].charAt(0)) == hm.get(words[i+1].charAt(0)))\\n            {\\n                int l1 = words[i].length(), ctr=0;\\n                int l2 = words[i+1].length();\\n\\n                // Inner loop : to compare letters of two adjacent words from words[]\\n                for(int j=1; j<l1 && j<l2; j++)\\n                {\\n                    if(hm.get(words[i].charAt(j)) < hm.get(words[i+1].charAt(j)))\\n                        continue;\\n                    else if(hm.get(words[i].charAt(j)) > hm.get(words[i+1].charAt(j)))\\n                        return false;\\n                    else if(hm.get(words[i].charAt(j)) == hm.get(words[i+1].charAt(j)))\\n                        ctr++;  \\n                    // ctr maintains the count of number of common letters in the same order\\n                    //Debug : System.out.println(words[i].charAt(j)+\" \"+words[i+1].charAt(j));\\n                }\\n                // To handle the corner cases\\n                if(l2<l1 && ctr+1==l2)   // Eg: Test Case 3\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130421,
                "title": "easy-beginner-friendly-approach-using-map-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s map the order given of the string to our actual alphabets.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter mapping order to original alphabets, we will change every character of every word in words. \\nThen we will make a copy of words and sort that. After sorting if copy == words, return true, else false;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n- Space complexity:\\nO(N)\\n- <!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,char> mp;\\n        char start = \\'a\\';\\n        for(char i = 0; i < 26; i++){\\n            mp[order[i]] = start++;\\n        }\\n        for(int i = 0; i < words.size(); i++){\\n            for(int j = 0; j < words[i].size(); j++){\\n                words[i][j] = mp[words[i][j]];\\n            }\\n        }\\n        vector<string> flag;\\n        flag = words;\\n        sort(flag.begin(), flag.end());\\n        return words == flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,char> mp;\\n        char start = \\'a\\';\\n        for(char i = 0; i < 26; i++){\\n            mp[order[i]] = start++;\\n        }\\n        for(int i = 0; i < words.size(); i++){\\n            for(int j = 0; j < words[i].size(); j++){\\n                words[i][j] = mp[words[i][j]];\\n            }\\n        }\\n        vector<string> flag;\\n        flag = words;\\n        sort(flag.begin(), flag.end());\\n        return words == flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130237,
                "title": "c-begineer-friendly-easy-understanding-hash-table-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=agfs69pIWHA/\\n\\n\\n# Complexity\\n- Time complexity:\\n  O(nk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n // to store the order of\\n        unordered_map<char,int>mp;\\n    bool correctOrder(string a,string b){\\n        int n=min(a.size(),b.size());\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[a[i]]<mp[b[i]]) return true;\\n            else if(mp[a[i]]>mp[b[i]]) {\\n                    return false;\\n            }\\n        }\\n        // if they are lexicographically.check if b is substring of a\\n        if(a.size()>b.size() &&(a.find(b)!= string::npos)){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    bool isAlienSorted(vector<string>& words, string order) {\\n\\n        for(int i=0;i<order.size();i++){\\n            mp[order[i]] = i;\\n        }\\n\\n       \\n\\n        for(int i=0;i<words.size()-1;i++){\\n            if(!correctOrder(words[i],words[i+1])){return false;}\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n // to store the order of\\n        unordered_map<char,int>mp;\\n    bool correctOrder(string a,string b){\\n        int n=min(a.size(),b.size());\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[a[i]]<mp[b[i]]) return true;\\n            else if(mp[a[i]]>mp[b[i]]) {\\n                    return false;\\n            }\\n        }\\n        // if they are lexicographically.check if b is substring of a\\n        if(a.size()>b.size() &&(a.find(b)!= string::npos)){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    bool isAlienSorted(vector<string>& words, string order) {\\n\\n        for(int i=0;i<order.size();i++){\\n            mp[order[i]] = i;\\n        }\\n\\n       \\n\\n        for(int i=0;i<words.size()-1;i++){\\n            if(!correctOrder(words[i],words[i+1])){return false;}\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130073,
                "title": "direct-comparison-solution-with-dictionary",
                "content": "## Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Like the built-in function `ord` in Python, I ranked the alphabets with given variable `order` by function `enumerate`, and save them into the dictionary (hashmap) by dictionary comprehension.\\n\\n2. I noticed that strings of char or lists of integers could be compared with **lexicographical order directly** by built-in **comparison operators**.\\n\\nFor examples,\\n```\\n>>> \\'word\\' > \\'world\\'\\nFalse\\n>>> [22, 14, 17, 5] > [22, 14, 17, 1, 5]\\nTrue\\n>>> [22, 14, 17, 5] > []\\nTrue\\n```\\nYap, the null list could be also compared.\\n\\n3. In lexicographical order, the next word should be larger than the previous word after converting into the list of orders. I create the null list `[]` as initial one to compare for the first word, and check if `words` satisfied the condition iteratively!\\n\\n## Code\\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        alphabet_order = {alphabet: order for order, alphabet in enumerate(order)}\\n        \\n        curr_word_order = list()\\n        for word in words:\\n            word_order = [alphabet_order[alphabet] for alphabet in word]\\n            if word_order >= curr_word_order:\\n                curr_word_order = word_order\\n            else:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\n>>> \\'word\\' > \\'world\\'\\nFalse\\n>>> [22, 14, 17, 5] > [22, 14, 17, 1, 5]\\nTrue\\n>>> [22, 14, 17, 5] > []\\nTrue\\n```\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        alphabet_order = {alphabet: order for order, alphabet in enumerate(order)}\\n        \\n        curr_word_order = list()\\n        for word in words:\\n            word_order = [alphabet_order[alphabet] for alphabet in word]\\n            if word_order >= curr_word_order:\\n                curr_word_order = word_order\\n            else:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130047,
                "title": "java-100-faster-solution",
                "content": "# Intuition\\nIn first loop I bind a letter with actual position from \"order\".\\nThen according to this binding array I start looping over two consecutive words:\\n- If a letter of prev word comes after a letter in next word, then return false.\\n- If two letters equal then increment count.\\n- If a letter of prev word comes before a letter in next word, then break.\\n\\nAfter inner loop I check whether an edge case, given in the description, occurs.\\nThat\\'s it.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int[] pos = new int[order.length()];\\n        for (int i = 0; i < order.length(); i++)\\n            pos[order.charAt(i) - \\'a\\'] = i;\\n        for (int i = 1; i < words.length; i++) {\\n            String prev = words[i - 1], curr = words[i];\\n            int len = Math.min(prev.length(), curr.length());\\n            int countEqual = 0;\\n            for (int j = 0; j < len; j++) {\\n                char p = prev.charAt(j), c = curr.charAt(j);\\n                if (pos[p - \\'a\\'] > pos[c - \\'a\\']) return false;\\n                else if (pos[p - \\'a\\'] == pos[c - \\'a\\']) countEqual++;\\n                else break;\\n            }\\n            if (countEqual == len && prev.length() > curr.length()) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int[] pos = new int[order.length()];\\n        for (int i = 0; i < order.length(); i++)\\n            pos[order.charAt(i) - \\'a\\'] = i;\\n        for (int i = 1; i < words.length; i++) {\\n            String prev = words[i - 1], curr = words[i];\\n            int len = Math.min(prev.length(), curr.length());\\n            int countEqual = 0;\\n            for (int j = 0; j < len; j++) {\\n                char p = prev.charAt(j), c = curr.charAt(j);\\n                if (pos[p - \\'a\\'] > pos[c - \\'a\\']) return false;\\n                else if (pos[p - \\'a\\'] == pos[c - \\'a\\']) countEqual++;\\n                else break;\\n            }\\n            if (countEqual == len && prev.length() > curr.length()) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130027,
                "title": "beginner-friendly-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool comparison(string &a, string &b, string &order)\\n{\\n    int i  = 0;\\n    while(i<a.size() && a[i]==b[i])\\n    i++;\\n    if(i==a.size())\\n    return true;\\n    else if(b.size()==i)\\n    return false;\\n    return (order.find(a[i])<order.find(b[i]));\\n}\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        for(int i = 0; i<words.size()-1; i++)\\n        {\\n            if(!comparison(words[i],words[i+1],order))\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool comparison(string &a, string &b, string &order)\\n{\\n    int i  = 0;\\n    while(i<a.size() && a[i]==b[i])\\n    i++;\\n    if(i==a.size())\\n    return true;\\n    else if(b.size()==i)\\n    return false;\\n    return (order.find(a[i])<order.find(b[i]));\\n}\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        for(int i = 0; i<words.size()-1; i++)\\n        {\\n            if(!comparison(words[i],words[i+1],order))\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129989,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- firstly make array of order using using orders array.\\n- now loop through every string of words array and check that previous char @ i of prev string (in for loop) is greater than char @ i in next string ( Basically Checking Array is sorted or not ).\\n- if the array is sorted the break the loop.\\n\\n- at last check the condition if length is next length and cur starts with next then return false : to satisfy the third test case.\\n# Complexity\\n- Time complexity: O(m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int[] map = new int[26];\\n        int seq = 0;\\n        for(char ch : order.toCharArray()){\\n            map[ch - \\'a\\'] = seq++;\\n        }\\n\\n        for(int i = 0 ; i < words.length - 1; i++){\\n            String cur = words[i];\\n            String nxt = words[i+1];\\n\\n            int len = Math.min(cur.length(), nxt.length());\\n\\n            if(len != cur.length() && len == nxt.length() &&cur.startsWith(nxt))\\n                return false;\\n            for(int l = 0; l < len; l++){\\n                if(map[cur.charAt(l) - \\'a\\'] > map[nxt.charAt(l) - \\'a\\'])\\n                    return false;\\n                if(map[cur.charAt(l) - \\'a\\'] < map[nxt.charAt(l) - \\'a\\'])\\n                    break;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int[] map = new int[26];\\n        int seq = 0;\\n        for(char ch : order.toCharArray()){\\n            map[ch - \\'a\\'] = seq++;\\n        }\\n\\n        for(int i = 0 ; i < words.length - 1; i++){\\n            String cur = words[i];\\n            String nxt = words[i+1];\\n\\n            int len = Math.min(cur.length(), nxt.length());\\n\\n            if(len != cur.length() && len == nxt.length() &&cur.startsWith(nxt))\\n                return false;\\n            for(int l = 0; l < len; l++){\\n                if(map[cur.charAt(l) - \\'a\\'] > map[nxt.charAt(l) - \\'a\\'])\\n                    return false;\\n                if(map[cur.charAt(l) - \\'a\\'] < map[nxt.charAt(l) - \\'a\\'])\\n                    break;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129910,
                "title": "easy-brute-force-with-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] char_map;\\n    public boolean isAlienSorted(String[] words, String order) {\\n        char_map = new int[26];\\n        for(int i=0; i<order.length(); i++){\\n            char_map[order.charAt(i)-\\'a\\'] = i;\\n        }\\n\\n        for(int i=1; i<words.length; i++ ){\\n            if(compare(words[i-1], words[i])>0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int compare(String word1, String word2){\\n        int i=0; \\n        int j=0;\\n        int char_compare_val=0;\\n        while(i<word1.length() && j<word2.length() && char_compare_val==0){\\n            char_compare_val = char_map[word1.charAt(i)-\\'a\\']-char_map[word2.charAt(j)-\\'a\\'];\\n            i++;\\n            j++;\\n        }\\n        if(char_compare_val==0){\\n            return word1.length() - word2.length();\\n        }\\n        else{\\n            return char_compare_val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int[] char_map;\\n    public boolean isAlienSorted(String[] words, String order) {\\n        char_map = new int[26];\\n        for(int i=0; i<order.length(); i++){\\n            char_map[order.charAt(i)-\\'a\\'] = i;\\n        }\\n\\n        for(int i=1; i<words.length; i++ ){\\n            if(compare(words[i-1], words[i])>0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int compare(String word1, String word2){\\n        int i=0; \\n        int j=0;\\n        int char_compare_val=0;\\n        while(i<word1.length() && j<word2.length() && char_compare_val==0){\\n            char_compare_val = char_map[word1.charAt(i)-\\'a\\']-char_map[word2.charAt(j)-\\'a\\'];\\n            i++;\\n            j++;\\n        }\\n        if(char_compare_val==0){\\n            return word1.length() - word2.length();\\n        }\\n        else{\\n            return char_compare_val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129873,
                "title": "c-simple-approach-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        unordered_map<char,char> mp;  // storing the character which are change due to Aliens dict h --> a here h in alien and a in our dict\\n        for(char c = \\'a\\'; c<= \\'z\\';c++){\\n            mp[order[c-\\'a\\']] = c;\\n        }\\n        \\n        for(int i = 0;i<words.size();i++){  // changing the characters of aliens words in our words with there order\\n            for(auto &c : words[i]) c = mp[c];\\n        }\\n        for(int i = 1;i<words.size();i++){  // comparing simply becase it is in our language now and comparing function internaly compares the strings in according to our dict\\n            if(words[i] < words[i-1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        unordered_map<char,char> mp;  // storing the character which are change due to Aliens dict h --> a here h in alien and a in our dict\\n        for(char c = \\'a\\'; c<= \\'z\\';c++){\\n            mp[order[c-\\'a\\']] = c;\\n        }\\n        \\n        for(int i = 0;i<words.size();i++){  // changing the characters of aliens words in our words with there order\\n            for(auto &c : words[i]) c = mp[c];\\n        }\\n        for(int i = 1;i<words.size();i++){  // comparing simply becase it is in our language now and comparing function internaly compares the strings in according to our dict\\n            if(words[i] < words[i-1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129857,
                "title": "java-o-n-time-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean isAlienSorted(String[] words, String order) {\\n    var map = new int[26];\\n\\n    for (var i=0; i<26; i++)\\n      map[order.charAt(i) - \\'a\\'] = i;\\n\\n    for (var i=0; i < words.length - 1; i++) {\\n      boolean good = false;\\n\\n      for (var j=0; !good && j < words[i].length() && j < words[i+1].length(); j++) {\\n        if (map[words[i].charAt(j) - \\'a\\'] < map[words[i+1].charAt(j) - \\'a\\']) {\\n          good = true;\\n          continue;\\n        }\\n        if (map[words[i].charAt(j) - \\'a\\'] > map[words[i+1].charAt(j) - \\'a\\'])\\n          return false;\\n      }\\n      if (good) continue;\\n      if (words[i].length() > words[i+1].length())\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n  public boolean isAlienSorted(String[] words, String order) {\\n    var map = new int[26];\\n\\n    for (var i=0; i<26; i++)\\n      map[order.charAt(i) - \\'a\\'] = i;\\n\\n    for (var i=0; i < words.length - 1; i++) {\\n      boolean good = false;\\n\\n      for (var j=0; !good && j < words[i].length() && j < words[i+1].length(); j++) {\\n        if (map[words[i].charAt(j) - \\'a\\'] < map[words[i+1].charAt(j) - \\'a\\']) {\\n          good = true;\\n          continue;\\n        }\\n        if (map[words[i].charAt(j) - \\'a\\'] > map[words[i+1].charAt(j) - \\'a\\'])\\n          return false;\\n      }\\n      if (good) continue;\\n      if (words[i].length() > words[i+1].length())\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129748,
                "title": "",
                "content": "# Intuition\\n\\n# Approach[]()\\n## *Brute Force*\\n\\n# Complexity\\n- Time complexity:o(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        boolean flag=true;\\n        for(int i=0;i<words.length-1;i++){\\n            boolean temp=true;\\n            char a=\\'0\\',b=\\'0\\';\\n            for(int j=0;j<words[i].length()&&j<words[i+1].length();j++){\\n                if(order.indexOf(words[i].charAt(0))<order.indexOf(words[i+1].charAt(0))){\\n                    temp=false;\\n                    break;\\n                }\\n                else if(order.indexOf(words[i].charAt(j))>order.indexOf(words[i+1].charAt(j))){\\n                    return false;\\n                }\\n                a=words[i].charAt(j);\\n                b=words[i+1].charAt(j);\\n            }\\n            if(words[i].length()>words[i+1].length()&&temp){\\n                if(a<b){\\n                    continue;\\n                }\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        boolean flag=true;\\n        for(int i=0;i<words.length-1;i++){\\n            boolean temp=true;\\n            char a=\\'0\\',b=\\'0\\';\\n            for(int j=0;j<words[i].length()&&j<words[i+1].length();j++){\\n                if(order.indexOf(words[i].charAt(0))<order.indexOf(words[i+1].charAt(0))){\\n                    temp=false;\\n                    break;\\n                }\\n                else if(order.indexOf(words[i].charAt(j))>order.indexOf(words[i+1].charAt(j))){\\n                    return false;\\n                }\\n                a=words[i].charAt(j);\\n                b=words[i+1].charAt(j);\\n            }\\n            if(words[i].length()>words[i+1].length()&&temp){\\n                if(a<b){\\n                    continue;\\n                }\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129621,
                "title": "java-strings-beats-100-intuitive-solution-easy-understand",
                "content": "***please give an upvote if you like the solution***\\n\\n![image.png](https://assets.leetcode.com/users/images/0f1b9718-fc98-4108-82d4-f6506f76c162_1675310083.5279634.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*m) -> in worst case (m -> minOf(sizeOf(string1), sizeOf(string2))   OR   m == n (if n >= m))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public static boolean isGreaterThan(String s1, String s2, String order){\\n        int i = 0;\\n        int n = s1.length() < s2.length() ? s1.length() : s2.length();\\n        while(i < n && s1.charAt(i) == s2.charAt(i)) i++;\\n        if(s2.length() == i) return true;\\n        if(s1.length() == i) return false;\\n        return order.indexOf(s1.charAt(i)) >= order.indexOf(s2.charAt(i));\\n    }\\n\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int n = words.length;\\n        for(int i = 1; i < n ;i++){\\n            if(!(isGreaterThan(words[i], words[i -1], order))){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static boolean isGreaterThan(String s1, String s2, String order){\\n        int i = 0;\\n        int n = s1.length() < s2.length() ? s1.length() : s2.length();\\n        while(i < n && s1.charAt(i) == s2.charAt(i)) i++;\\n        if(s2.length() == i) return true;\\n        if(s1.length() == i) return false;\\n        return order.indexOf(s1.charAt(i)) >= order.indexOf(s2.charAt(i));\\n    }\\n\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int n = words.length;\\n        for(int i = 1; i < n ;i++){\\n            if(!(isGreaterThan(words[i], words[i -1], order))){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129567,
                "title": "python-ugly-but-runnable-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        dic = {}\\n        for i,a in enumerate(order):\\n            dic[a] = i\\n        for i in range(len(words)-1):\\n            if dic[words[i][0]]>dic[words[i+1][0]]:\\n                return False\\n            elif dic[words[i][0]]==dic[words[i+1][0]]:\\n                flag = 0\\n                for j in range(1,min(len(words[i]), len(words[i+1]))):\\n                    if dic[words[i][j]]>dic[words[i+1][j]]:\\n                        return False\\n                    elif dic[words[i][j]]!=dic[words[i+1][j]]:\\n                        flag = 1\\n                if flag == 0 and len(words[i])>len(words[i+1]):\\n                    return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        dic = {}\\n        for i,a in enumerate(order):\\n            dic[a] = i\\n        for i in range(len(words)-1):\\n            if dic[words[i][0]]>dic[words[i+1][0]]:\\n                return False\\n            elif dic[words[i][0]]==dic[words[i+1][0]]:\\n                flag = 0\\n                for j in range(1,min(len(words[i]), len(words[i+1]))):\\n                    if dic[words[i][j]]>dic[words[i+1][j]]:\\n                        return False\\n                    elif dic[words[i][j]]!=dic[words[i+1][j]]:\\n                        flag = 1\\n                if flag == 0 and len(words[i])>len(words[i+1]):\\n                    return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129500,
                "title": "dp-100-0-ms-algorithm-full-explained-animation",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/5d05ace4-36a5-4dc9-80e4-597e9e4e8dab_1675307860.4760368.png)\\n\\n\\n# Approach: Compare adjacent words\\n![image.png](https://assets.leetcode.com/users/images/755f41a4-1c15-4074-83d4-04b0d91aad6d_1675310837.2828078.png)\\n\\n# Intuition\\n\\nWe want to compare each pair of adjacent words to see if they are sorted lexicographically. This can be achieved by a naive for-loop iterating over the input array. We can store the letter-order relation of each letter with its ranking in order, so that we can easily access the order of letters when we compare them.\\n\\nThe remaining piece of the puzzle is how to compare two words lexicographically. This is not difficult, but there are a few edge cases that we must consider. To compare two adjacent words words[i] and words[i+1], we want to find the first letter that is different: if words[i] has the lexicographically smaller letter, then we can exit from the iteration because we know words[i] and words[i+1] are in the right order; however, if words[i] has the lexicographically larger letter, then we immediately return false, because we found one pair of words that are in the wrong order.\\n\\nWe also need to consider the boundaries. While we loop from the beginning to the end of one word, we need to check if the other word has ended. Take the words apple and app as an example, we cannot iterate over all of the letters in apple because the word app is shorter. In this case, we reach the end of one word before finding the first different letter. When this happens, we must examine the length of each word: if the words are the same length or the former word is shorter, then words is sorted. However, if the latter word is shorter, then words is not sorted.\\n\\n# Algorithm\\n\\nInitialize a hashmap/array to record the relations between each letter and its ranking in order.\\nIterate over words and compare each pair of adjacent words.\\nIterate over each letter to find the first different letter between words[i] and words[i + 1].\\nIf words[i + 1] ends before words[i] and no different letters are found, then we need to return false because words[i + 1] should come before words[i] (for example, apple and app).\\nIf we find the first different letter and the two words are in the correct order, then we can exit from the current iteration and proceed to the next pair of words.\\nIf we find the first different letter and the two words are in the wrong order, then we can safely return false.\\nIf we reach this point, it means that we have examined all pairs of adjacent words and that they are all sorted. Therefore we can return true.\\n\\n# Complexity analysis\\n\\nLet N be the length of order, and M be the total number of characters in words.\\n\\n# Time complexity : O(M).\\n\\nStoring the letter-order relation of each letter takes O(N) time. For the nested for-loops, we examine each pair of words in the outer-loop and for the inner loop, we check each letter in the current word. Therefore, we will iterate over all of letters in words.\\n\\nTaking both into consideration, the time complexity is O(M+N). However, we know that N is fixed as 262626. Therefore, the time complexity is O(M).\\n\\n# Space complexity : O(1). \\nThe only extra data structure we use is the hashmap/array that serves to store the letter-order relations for each word in order. Because the length of order is fixed as 262626, this approach achieves constant space complexity.\\n\\n# Code\\n```\\npublic boolean isAlienSorted(String[] W, String O) {\\n        int A[] = new int[26];\\n        for (int i = 0; i < O.length(); i++) A[O.charAt(i) - \\'a\\'] = i;\\n        outer: for (int i = 0; i < W.length - 1; i++)\\n            for (int j = 0; j < W[i].length(); j++) {\\n                if (j >= W[i + 1].length()) return false;\\n                int cur = W[i].charAt(j) - \\'a\\', pre = W[i + 1].charAt(j) - \\'a\\';\\n                if (cur != pre) {\\n                    if (A[cur] > A[pre]) return false;\\n                    else continue outer;\\n                }\\n            } return true;\\n}\\n```\\n```\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        order_map = {}\\n        for index, val in enumerate(order):\\n            order_map[val] = index\\n        for i in range(len(words) - 1):\\n            for j in range(len(words[i])):\\n                # If we do not find a mismatch letter between words[i] and words[i + 1],\\n                # we need to examine the case when words are like (\"apple\", \"app\").\\n                if j >= len(words[i + 1]): return False\\n                if words[i][j] != words[i + 1][j]:\\n                    if order_map[words[i][j]] > order_map[words[i + 1][j]]: return False\\n                    # if we find the first different character and they are sorted,\\n                    # then there\\'s no need to check remaining letters\\n                    break\\n        return True\\n```\\n\\n![mem2.png](https://assets.leetcode.com/users/images/a9bfdb67-0e71-41e7-ad94-8895b53c8f8d_1675308426.6564279.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic boolean isAlienSorted(String[] W, String O) {\\n        int A[] = new int[26];\\n        for (int i = 0; i < O.length(); i++) A[O.charAt(i) - \\'a\\'] = i;\\n        outer: for (int i = 0; i < W.length - 1; i++)\\n            for (int j = 0; j < W[i].length(); j++) {\\n                if (j >= W[i + 1].length()) return false;\\n                int cur = W[i].charAt(j) - \\'a\\', pre = W[i + 1].charAt(j) - \\'a\\';\\n                if (cur != pre) {\\n                    if (A[cur] > A[pre]) return false;\\n                    else continue outer;\\n                }\\n            } return true;\\n}\\n```\n```\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        order_map = {}\\n        for index, val in enumerate(order):\\n            order_map[val] = index\\n        for i in range(len(words) - 1):\\n            for j in range(len(words[i])):\\n                # If we do not find a mismatch letter between words[i] and words[i + 1],\\n                # we need to examine the case when words are like (\"apple\", \"app\").\\n                if j >= len(words[i + 1]): return False\\n                if words[i][j] != words[i + 1][j]:\\n                    if order_map[words[i][j]] > order_map[words[i + 1][j]]: return False\\n                    # if we find the first different character and they are sorted,\\n                    # then there\\'s no need to check remaining letters\\n                    break\\n        return True\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1566979,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me :/"
                    },
                    {
                        "username": "urodoloh",
                        "content": "[@kseniiaprytkova](/kseniiaprytkova) oh god, i understood the problem only thanks to you. thanks"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Only aliens can understand it! ;)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# To clear up the confusion\\n\\nLexographic order = alphabetical order. Think about it like this: if you were to build a dictionary, which word would you put first?\\n\\nThis is why some apparently weird test cases like `[[\"kuvp\",\"q\"], \"ngxlkthsjuoqcpavbfdermiywz\"]` return true"
                    },
                    {
                        "username": "kseniiaprytkova",
                        "content": "Imagine a regular paper dictionary of your language. Where words are presented and their definitions. The words there are in alphabetical order. If the first letters of 2 words are the same, then we look at the second letters of 2 words (and so on) to decide which word will be first."
                    },
                    {
                        "username": "dapilk101",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) Good explanation. That is how I interpreted this problem too."
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova)  Basically , the words list is a dictionary (ex - oxford dictionary) and the order is provided (ranking of alphabets) , we need to check whether the dictionary is correct i.e. the words need to be in order provided."
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "This is how I understand this task:\\n\\nIf the first word in the given array \"words\" is longer then second --- result will be false \\nThan we take letters of this words and find them in the given \"order\", if the index of the letter from the  first word is bigger than the letter index of the second word --- result will be false \\n(for example, we have the first letters from the first and the second word, we find index of this letters in the given \"order\" and compare this indexes, the index of the first word must be lower that index of the second, otherwise it will be false)\\n\\nYou can correct me if I\\'m wrong or add explanations to my answer. This task is really unclear, lol"
                    },
                    {
                        "username": "shubham_kamdi",
                        "content": "please move this to medium "
                    },
                    {
                        "username": "dieg0maci3l",
                        "content": "I don't think this is a medium problem, they just need to add a short list of \"lexicographical rules\" to make the statement more clear. They explain how the lexicographical rules work in the examples, but the statement can be improved for sure. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I would say this is an easy problem with a few edge cases where we need to be more careful"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Medium problems often take me over an hour, or I require hints, this took me 6 minuets and 44 seconds. Not sure why this would be medium?"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "[@aanand07](/aanand07) thanks i think this might be cause\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Let me check with the Men in Black."
                    },
                    {
                        "username": "aanand07",
                        "content": "IMO, in some cases input constraints determine the level of a problem.\\nOver here, words and words[i] max length is less, so it should be in easy category."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Took about 5 minutes to solve I don\\'t know what you\\'re talking about lol"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Definitely not an easy lol. Also they should say `alphabetical order` somewhere in the question because `lexicographic order` is just a weird term that causes confusion"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Somewhere Aliens are laughing..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Hard to be an alien nowadays :)"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "is my skill going down or the easy questions are getting difficult ?"
                    },
                    {
                        "username": "mohak0",
                        "content": "I believe that the question description should\\'ve explained the problem better. The current description is so vague that we\\'re expected to decipher the test cases and figure out what\\'s being asked.\\nMaybe a good problem for interviews where you can ask questions and clarify different test cases with the interviewer "
                    },
                    {
                        "username": "coolgal",
                        "content": "Why is following testcase returning true ?\\n\\n[\"kuvp\",\"q\"]\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\nIn example 3, it says if second string length is less then first string than return false?\\n\\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nOutput: false\\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because \\'l\\' > \\'\\u2205\\', where \\'\\u2205\\' is defined as the blank character which is less than any other character (More info)."
                    },
                    {
                        "username": "hridoy100",
                        "content": "condition should be: if word2 has more length and it is also a minimum length substring of word1."
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"abcdefghijklmnopqrstuvwxyz\"\norder.index(\"k\") \n=> 10\norder.index(\"q\") \n=> 16\nso \"k\" before \"q\" then ignore other later \nThe first letter has the highest importance"
                    },
                    {
                        "username": "arshde3p",
                        "content": "Hint: compare characters from left-to-right. See here q > k, so it will come after in the lexicographic order. In the apple-app example you\\'ll start from left \\n\\'a\\' == \\'a\\'\\n\\'p\\' == \\'p\\'\\n.\\n\\'l\\' > null\\nso \"apple\" is greater than \"app\" here hence result is false for that case.\\n\\nHere,\\n\\'k\\' < \\'q\\'\\nso break here itself rest characters doesn\\'t matter"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "[@srivastavashubham7984](/srivastavashubham7984)  I don\\'t think it is invalid. We compare \"kuvp\" to \"q\", which is equal to \"kuvp\" to \"q000\" where 0 is phi. since \"k\" < \"q\", this should return True. Its similar to \"ant\" < \"z\" in our modern lexicography. "
                    },
                    {
                        "username": "shantanu1405",
                        "content": "if you have seen a dictionary, there words are arranged lexicographical , there, ambulance comes before zebra, so we move from the first letter and check, if at any point, the letter of preceding word is alphabetically greater than the  letter of next word, then it is wrong.\\nin your case, k comes before q, so no need to check the next letters as the sequence is correct\\n\\n"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "\"apple\" > \"app\" is sorted by the length only because they both start with \"app\".\\nin the case with [\"kuvp\",\"q\"] \"k\" shows up sooner in the alphabet than \"q\" does, so even though \"kuvp\" is longer it is alphabetically first,\\njust like how \"apple\" comes alphabetically first before \"car\" in regular english  "
                    },
                    {
                        "username": "srivastavashubham7984",
                        "content": "[@ujjwal1234](/ujjwal1234)  Yes, this seems to be invalid test case. As per the example, output should be false."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "I am also facing the same problem\\n"
                    },
                    {
                        "username": "mhhs",
                        "content": "I think this one is a medium problem. It\\'s take a long time for me to grasp the concept clearly"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Hint: check next character only if current character is equal.\\n\\nThey should\\'ve mentioned it, i\\'m not sure how it is obvious"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "The second test case in the examples states in its explanation, \\'As \\'d\\' comes after \\'l\\' in this language\\' it should be obvious."
                    },
                    {
                        "username": "ayush_cmd",
                        "content": "it is obvio because this is how the real dictionary works"
                    },
                    {
                        "username": "aanand07",
                        "content": "Thanks for this tip!! \\uD83D\\uDD25 "
                    },
                    {
                        "username": "rohit__27",
                        "content": "it is .."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "![image](https://assets.leetcode.com/users/bluecode2017/image_1561259655.png)\\n"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@TornikePy](/TornikePy) \\nSo how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "TuringJest",
                        "content": "A simple way to understand this, is to picture a string\\'s lexicographic value as a float - where the first char is the integer part and the rest is the fractional part.\\n\\nh   l   a  b  c  d  e   f  g   i    j    k   m    n   o   p   q    r    s    t...\\n0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19...\\n\\nhello -> 0 6 1 1 14  -> 0 . 6 1 1 14\\nleetcode -> 1 6 6 19 4 14 5 6 -> 1 . 6 6 19 4 14 5 6\\n(let\\'s imagine the float it in base26, so that a letter can\\'t take up more than \"one decimal place\" or correct in base26 - a hexavigesimal place.)\\n\\nIt\\'s immediately clear that 1.6... > 0.6....\\n\\nPs. Don\\'t get confused about base26, it\\'s just there to make the float analogy mathematically correct. It\\'s not needed for the mental model or the code.\\n\\n"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\\norder.index(\"h\")\\n=> 0\\norder.index(\"l\")\\n=>  1\\nso \"h\" before \"l\" then ignore other later\\nThe first letter has the highest importance\\nis sored "
                    },
                    {
                        "username": "GKushi",
                        "content": "[@TornikePy](/TornikePy)  Thanks"
                    },
                    {
                        "username": "TornikePy",
                        "content": "we do not need to check more than first character, as H and L are different and L comes after H, so second word will come after first."
                    },
                    {
                        "username": "pradeep11",
                        "content": "Example 1:\\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nOutput: true\\n\\nthe 4th index position - char \\'o\\' comes after 4th index position of second word \\'c\\' . How it is sorted? It should return false?"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@Vaibhav_69](/Vaibhav_69) So how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "We are only checking the first character of the words in the string array, hence it is true as H<L in alien dictionary"
                    },
                    {
                        "username": "JohnCanessa",
                        "content": "Hello,\\nThe first test case uses the words \\'hello\\' and \\'leetcode\\' and the dictionary \\'hlabcdefgijkmnopqrstuvwxyz\\'.\\n\\'hello\\' = [0, 6, 1, 1, 14]\\n\\'leetcode\\' = [1, 6, 6, 19, 4, 14, 5, 6]\\n0 <= 1, 6 <= 6, 1 <= 6, 1 <= 19, 14 > 4\\n\\'hello\\' seems to be > \\'leetcode\\'.\\nThat seems to indicate that the result for the test case should be false.\\nCould someone set me straight?\\nThanks\\nJohn\\n\\n"
                    },
                    {
                        "username": "leddie24",
                        "content": "We\\'re not comparing the total \"value\" of each word. We stop as soon as we get to a comparison that isn\\'t equal.  For a non-alien dictionary (e.g: English) if we compare \"Apple\" to \"America\", \"America\" is sorted before apple, because we stop comparing after the second letter.  In the example, since \"h\" !== \"l\", we can stop the comparison after those letters. H has a lower index in the alien alphabet, so we consider \"hello\" < \"leetcode\"."
                    }
                ]
            },
            {
                "id": 1730803,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me :/"
                    },
                    {
                        "username": "urodoloh",
                        "content": "[@kseniiaprytkova](/kseniiaprytkova) oh god, i understood the problem only thanks to you. thanks"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Only aliens can understand it! ;)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# To clear up the confusion\\n\\nLexographic order = alphabetical order. Think about it like this: if you were to build a dictionary, which word would you put first?\\n\\nThis is why some apparently weird test cases like `[[\"kuvp\",\"q\"], \"ngxlkthsjuoqcpavbfdermiywz\"]` return true"
                    },
                    {
                        "username": "kseniiaprytkova",
                        "content": "Imagine a regular paper dictionary of your language. Where words are presented and their definitions. The words there are in alphabetical order. If the first letters of 2 words are the same, then we look at the second letters of 2 words (and so on) to decide which word will be first."
                    },
                    {
                        "username": "dapilk101",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) Good explanation. That is how I interpreted this problem too."
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova)  Basically , the words list is a dictionary (ex - oxford dictionary) and the order is provided (ranking of alphabets) , we need to check whether the dictionary is correct i.e. the words need to be in order provided."
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "This is how I understand this task:\\n\\nIf the first word in the given array \"words\" is longer then second --- result will be false \\nThan we take letters of this words and find them in the given \"order\", if the index of the letter from the  first word is bigger than the letter index of the second word --- result will be false \\n(for example, we have the first letters from the first and the second word, we find index of this letters in the given \"order\" and compare this indexes, the index of the first word must be lower that index of the second, otherwise it will be false)\\n\\nYou can correct me if I\\'m wrong or add explanations to my answer. This task is really unclear, lol"
                    },
                    {
                        "username": "shubham_kamdi",
                        "content": "please move this to medium "
                    },
                    {
                        "username": "dieg0maci3l",
                        "content": "I don't think this is a medium problem, they just need to add a short list of \"lexicographical rules\" to make the statement more clear. They explain how the lexicographical rules work in the examples, but the statement can be improved for sure. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I would say this is an easy problem with a few edge cases where we need to be more careful"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Medium problems often take me over an hour, or I require hints, this took me 6 minuets and 44 seconds. Not sure why this would be medium?"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "[@aanand07](/aanand07) thanks i think this might be cause\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Let me check with the Men in Black."
                    },
                    {
                        "username": "aanand07",
                        "content": "IMO, in some cases input constraints determine the level of a problem.\\nOver here, words and words[i] max length is less, so it should be in easy category."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Took about 5 minutes to solve I don\\'t know what you\\'re talking about lol"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Definitely not an easy lol. Also they should say `alphabetical order` somewhere in the question because `lexicographic order` is just a weird term that causes confusion"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Somewhere Aliens are laughing..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Hard to be an alien nowadays :)"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "is my skill going down or the easy questions are getting difficult ?"
                    },
                    {
                        "username": "mohak0",
                        "content": "I believe that the question description should\\'ve explained the problem better. The current description is so vague that we\\'re expected to decipher the test cases and figure out what\\'s being asked.\\nMaybe a good problem for interviews where you can ask questions and clarify different test cases with the interviewer "
                    },
                    {
                        "username": "coolgal",
                        "content": "Why is following testcase returning true ?\\n\\n[\"kuvp\",\"q\"]\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\nIn example 3, it says if second string length is less then first string than return false?\\n\\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nOutput: false\\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because \\'l\\' > \\'\\u2205\\', where \\'\\u2205\\' is defined as the blank character which is less than any other character (More info)."
                    },
                    {
                        "username": "hridoy100",
                        "content": "condition should be: if word2 has more length and it is also a minimum length substring of word1."
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"abcdefghijklmnopqrstuvwxyz\"\norder.index(\"k\") \n=> 10\norder.index(\"q\") \n=> 16\nso \"k\" before \"q\" then ignore other later \nThe first letter has the highest importance"
                    },
                    {
                        "username": "arshde3p",
                        "content": "Hint: compare characters from left-to-right. See here q > k, so it will come after in the lexicographic order. In the apple-app example you\\'ll start from left \\n\\'a\\' == \\'a\\'\\n\\'p\\' == \\'p\\'\\n.\\n\\'l\\' > null\\nso \"apple\" is greater than \"app\" here hence result is false for that case.\\n\\nHere,\\n\\'k\\' < \\'q\\'\\nso break here itself rest characters doesn\\'t matter"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "[@srivastavashubham7984](/srivastavashubham7984)  I don\\'t think it is invalid. We compare \"kuvp\" to \"q\", which is equal to \"kuvp\" to \"q000\" where 0 is phi. since \"k\" < \"q\", this should return True. Its similar to \"ant\" < \"z\" in our modern lexicography. "
                    },
                    {
                        "username": "shantanu1405",
                        "content": "if you have seen a dictionary, there words are arranged lexicographical , there, ambulance comes before zebra, so we move from the first letter and check, if at any point, the letter of preceding word is alphabetically greater than the  letter of next word, then it is wrong.\\nin your case, k comes before q, so no need to check the next letters as the sequence is correct\\n\\n"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "\"apple\" > \"app\" is sorted by the length only because they both start with \"app\".\\nin the case with [\"kuvp\",\"q\"] \"k\" shows up sooner in the alphabet than \"q\" does, so even though \"kuvp\" is longer it is alphabetically first,\\njust like how \"apple\" comes alphabetically first before \"car\" in regular english  "
                    },
                    {
                        "username": "srivastavashubham7984",
                        "content": "[@ujjwal1234](/ujjwal1234)  Yes, this seems to be invalid test case. As per the example, output should be false."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "I am also facing the same problem\\n"
                    },
                    {
                        "username": "mhhs",
                        "content": "I think this one is a medium problem. It\\'s take a long time for me to grasp the concept clearly"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Hint: check next character only if current character is equal.\\n\\nThey should\\'ve mentioned it, i\\'m not sure how it is obvious"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "The second test case in the examples states in its explanation, \\'As \\'d\\' comes after \\'l\\' in this language\\' it should be obvious."
                    },
                    {
                        "username": "ayush_cmd",
                        "content": "it is obvio because this is how the real dictionary works"
                    },
                    {
                        "username": "aanand07",
                        "content": "Thanks for this tip!! \\uD83D\\uDD25 "
                    },
                    {
                        "username": "rohit__27",
                        "content": "it is .."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "![image](https://assets.leetcode.com/users/bluecode2017/image_1561259655.png)\\n"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@TornikePy](/TornikePy) \\nSo how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "TuringJest",
                        "content": "A simple way to understand this, is to picture a string\\'s lexicographic value as a float - where the first char is the integer part and the rest is the fractional part.\\n\\nh   l   a  b  c  d  e   f  g   i    j    k   m    n   o   p   q    r    s    t...\\n0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19...\\n\\nhello -> 0 6 1 1 14  -> 0 . 6 1 1 14\\nleetcode -> 1 6 6 19 4 14 5 6 -> 1 . 6 6 19 4 14 5 6\\n(let\\'s imagine the float it in base26, so that a letter can\\'t take up more than \"one decimal place\" or correct in base26 - a hexavigesimal place.)\\n\\nIt\\'s immediately clear that 1.6... > 0.6....\\n\\nPs. Don\\'t get confused about base26, it\\'s just there to make the float analogy mathematically correct. It\\'s not needed for the mental model or the code.\\n\\n"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\\norder.index(\"h\")\\n=> 0\\norder.index(\"l\")\\n=>  1\\nso \"h\" before \"l\" then ignore other later\\nThe first letter has the highest importance\\nis sored "
                    },
                    {
                        "username": "GKushi",
                        "content": "[@TornikePy](/TornikePy)  Thanks"
                    },
                    {
                        "username": "TornikePy",
                        "content": "we do not need to check more than first character, as H and L are different and L comes after H, so second word will come after first."
                    },
                    {
                        "username": "pradeep11",
                        "content": "Example 1:\\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nOutput: true\\n\\nthe 4th index position - char \\'o\\' comes after 4th index position of second word \\'c\\' . How it is sorted? It should return false?"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@Vaibhav_69](/Vaibhav_69) So how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "We are only checking the first character of the words in the string array, hence it is true as H<L in alien dictionary"
                    },
                    {
                        "username": "JohnCanessa",
                        "content": "Hello,\\nThe first test case uses the words \\'hello\\' and \\'leetcode\\' and the dictionary \\'hlabcdefgijkmnopqrstuvwxyz\\'.\\n\\'hello\\' = [0, 6, 1, 1, 14]\\n\\'leetcode\\' = [1, 6, 6, 19, 4, 14, 5, 6]\\n0 <= 1, 6 <= 6, 1 <= 6, 1 <= 19, 14 > 4\\n\\'hello\\' seems to be > \\'leetcode\\'.\\nThat seems to indicate that the result for the test case should be false.\\nCould someone set me straight?\\nThanks\\nJohn\\n\\n"
                    },
                    {
                        "username": "leddie24",
                        "content": "We\\'re not comparing the total \"value\" of each word. We stop as soon as we get to a comparison that isn\\'t equal.  For a non-alien dictionary (e.g: English) if we compare \"Apple\" to \"America\", \"America\" is sorted before apple, because we stop comparing after the second letter.  In the example, since \"h\" !== \"l\", we can stop the comparison after those letters. H has a lower index in the alien alphabet, so we consider \"hello\" < \"leetcode\"."
                    }
                ]
            },
            {
                "id": 1784438,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me :/"
                    },
                    {
                        "username": "urodoloh",
                        "content": "[@kseniiaprytkova](/kseniiaprytkova) oh god, i understood the problem only thanks to you. thanks"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Only aliens can understand it! ;)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# To clear up the confusion\\n\\nLexographic order = alphabetical order. Think about it like this: if you were to build a dictionary, which word would you put first?\\n\\nThis is why some apparently weird test cases like `[[\"kuvp\",\"q\"], \"ngxlkthsjuoqcpavbfdermiywz\"]` return true"
                    },
                    {
                        "username": "kseniiaprytkova",
                        "content": "Imagine a regular paper dictionary of your language. Where words are presented and their definitions. The words there are in alphabetical order. If the first letters of 2 words are the same, then we look at the second letters of 2 words (and so on) to decide which word will be first."
                    },
                    {
                        "username": "dapilk101",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) Good explanation. That is how I interpreted this problem too."
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova)  Basically , the words list is a dictionary (ex - oxford dictionary) and the order is provided (ranking of alphabets) , we need to check whether the dictionary is correct i.e. the words need to be in order provided."
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "This is how I understand this task:\\n\\nIf the first word in the given array \"words\" is longer then second --- result will be false \\nThan we take letters of this words and find them in the given \"order\", if the index of the letter from the  first word is bigger than the letter index of the second word --- result will be false \\n(for example, we have the first letters from the first and the second word, we find index of this letters in the given \"order\" and compare this indexes, the index of the first word must be lower that index of the second, otherwise it will be false)\\n\\nYou can correct me if I\\'m wrong or add explanations to my answer. This task is really unclear, lol"
                    },
                    {
                        "username": "shubham_kamdi",
                        "content": "please move this to medium "
                    },
                    {
                        "username": "dieg0maci3l",
                        "content": "I don't think this is a medium problem, they just need to add a short list of \"lexicographical rules\" to make the statement more clear. They explain how the lexicographical rules work in the examples, but the statement can be improved for sure. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I would say this is an easy problem with a few edge cases where we need to be more careful"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Medium problems often take me over an hour, or I require hints, this took me 6 minuets and 44 seconds. Not sure why this would be medium?"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "[@aanand07](/aanand07) thanks i think this might be cause\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Let me check with the Men in Black."
                    },
                    {
                        "username": "aanand07",
                        "content": "IMO, in some cases input constraints determine the level of a problem.\\nOver here, words and words[i] max length is less, so it should be in easy category."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Took about 5 minutes to solve I don\\'t know what you\\'re talking about lol"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Definitely not an easy lol. Also they should say `alphabetical order` somewhere in the question because `lexicographic order` is just a weird term that causes confusion"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Somewhere Aliens are laughing..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Hard to be an alien nowadays :)"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "is my skill going down or the easy questions are getting difficult ?"
                    },
                    {
                        "username": "mohak0",
                        "content": "I believe that the question description should\\'ve explained the problem better. The current description is so vague that we\\'re expected to decipher the test cases and figure out what\\'s being asked.\\nMaybe a good problem for interviews where you can ask questions and clarify different test cases with the interviewer "
                    },
                    {
                        "username": "coolgal",
                        "content": "Why is following testcase returning true ?\\n\\n[\"kuvp\",\"q\"]\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\nIn example 3, it says if second string length is less then first string than return false?\\n\\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nOutput: false\\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because \\'l\\' > \\'\\u2205\\', where \\'\\u2205\\' is defined as the blank character which is less than any other character (More info)."
                    },
                    {
                        "username": "hridoy100",
                        "content": "condition should be: if word2 has more length and it is also a minimum length substring of word1."
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"abcdefghijklmnopqrstuvwxyz\"\norder.index(\"k\") \n=> 10\norder.index(\"q\") \n=> 16\nso \"k\" before \"q\" then ignore other later \nThe first letter has the highest importance"
                    },
                    {
                        "username": "arshde3p",
                        "content": "Hint: compare characters from left-to-right. See here q > k, so it will come after in the lexicographic order. In the apple-app example you\\'ll start from left \\n\\'a\\' == \\'a\\'\\n\\'p\\' == \\'p\\'\\n.\\n\\'l\\' > null\\nso \"apple\" is greater than \"app\" here hence result is false for that case.\\n\\nHere,\\n\\'k\\' < \\'q\\'\\nso break here itself rest characters doesn\\'t matter"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "[@srivastavashubham7984](/srivastavashubham7984)  I don\\'t think it is invalid. We compare \"kuvp\" to \"q\", which is equal to \"kuvp\" to \"q000\" where 0 is phi. since \"k\" < \"q\", this should return True. Its similar to \"ant\" < \"z\" in our modern lexicography. "
                    },
                    {
                        "username": "shantanu1405",
                        "content": "if you have seen a dictionary, there words are arranged lexicographical , there, ambulance comes before zebra, so we move from the first letter and check, if at any point, the letter of preceding word is alphabetically greater than the  letter of next word, then it is wrong.\\nin your case, k comes before q, so no need to check the next letters as the sequence is correct\\n\\n"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "\"apple\" > \"app\" is sorted by the length only because they both start with \"app\".\\nin the case with [\"kuvp\",\"q\"] \"k\" shows up sooner in the alphabet than \"q\" does, so even though \"kuvp\" is longer it is alphabetically first,\\njust like how \"apple\" comes alphabetically first before \"car\" in regular english  "
                    },
                    {
                        "username": "srivastavashubham7984",
                        "content": "[@ujjwal1234](/ujjwal1234)  Yes, this seems to be invalid test case. As per the example, output should be false."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "I am also facing the same problem\\n"
                    },
                    {
                        "username": "mhhs",
                        "content": "I think this one is a medium problem. It\\'s take a long time for me to grasp the concept clearly"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Hint: check next character only if current character is equal.\\n\\nThey should\\'ve mentioned it, i\\'m not sure how it is obvious"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "The second test case in the examples states in its explanation, \\'As \\'d\\' comes after \\'l\\' in this language\\' it should be obvious."
                    },
                    {
                        "username": "ayush_cmd",
                        "content": "it is obvio because this is how the real dictionary works"
                    },
                    {
                        "username": "aanand07",
                        "content": "Thanks for this tip!! \\uD83D\\uDD25 "
                    },
                    {
                        "username": "rohit__27",
                        "content": "it is .."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "![image](https://assets.leetcode.com/users/bluecode2017/image_1561259655.png)\\n"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@TornikePy](/TornikePy) \\nSo how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "TuringJest",
                        "content": "A simple way to understand this, is to picture a string\\'s lexicographic value as a float - where the first char is the integer part and the rest is the fractional part.\\n\\nh   l   a  b  c  d  e   f  g   i    j    k   m    n   o   p   q    r    s    t...\\n0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19...\\n\\nhello -> 0 6 1 1 14  -> 0 . 6 1 1 14\\nleetcode -> 1 6 6 19 4 14 5 6 -> 1 . 6 6 19 4 14 5 6\\n(let\\'s imagine the float it in base26, so that a letter can\\'t take up more than \"one decimal place\" or correct in base26 - a hexavigesimal place.)\\n\\nIt\\'s immediately clear that 1.6... > 0.6....\\n\\nPs. Don\\'t get confused about base26, it\\'s just there to make the float analogy mathematically correct. It\\'s not needed for the mental model or the code.\\n\\n"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\\norder.index(\"h\")\\n=> 0\\norder.index(\"l\")\\n=>  1\\nso \"h\" before \"l\" then ignore other later\\nThe first letter has the highest importance\\nis sored "
                    },
                    {
                        "username": "GKushi",
                        "content": "[@TornikePy](/TornikePy)  Thanks"
                    },
                    {
                        "username": "TornikePy",
                        "content": "we do not need to check more than first character, as H and L are different and L comes after H, so second word will come after first."
                    },
                    {
                        "username": "pradeep11",
                        "content": "Example 1:\\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nOutput: true\\n\\nthe 4th index position - char \\'o\\' comes after 4th index position of second word \\'c\\' . How it is sorted? It should return false?"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@Vaibhav_69](/Vaibhav_69) So how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "We are only checking the first character of the words in the string array, hence it is true as H<L in alien dictionary"
                    },
                    {
                        "username": "JohnCanessa",
                        "content": "Hello,\\nThe first test case uses the words \\'hello\\' and \\'leetcode\\' and the dictionary \\'hlabcdefgijkmnopqrstuvwxyz\\'.\\n\\'hello\\' = [0, 6, 1, 1, 14]\\n\\'leetcode\\' = [1, 6, 6, 19, 4, 14, 5, 6]\\n0 <= 1, 6 <= 6, 1 <= 6, 1 <= 19, 14 > 4\\n\\'hello\\' seems to be > \\'leetcode\\'.\\nThat seems to indicate that the result for the test case should be false.\\nCould someone set me straight?\\nThanks\\nJohn\\n\\n"
                    },
                    {
                        "username": "leddie24",
                        "content": "We\\'re not comparing the total \"value\" of each word. We stop as soon as we get to a comparison that isn\\'t equal.  For a non-alien dictionary (e.g: English) if we compare \"Apple\" to \"America\", \"America\" is sorted before apple, because we stop comparing after the second letter.  In the example, since \"h\" !== \"l\", we can stop the comparison after those letters. H has a lower index in the alien alphabet, so we consider \"hello\" < \"leetcode\"."
                    }
                ]
            },
            {
                "id": 1784797,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me :/"
                    },
                    {
                        "username": "urodoloh",
                        "content": "[@kseniiaprytkova](/kseniiaprytkova) oh god, i understood the problem only thanks to you. thanks"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Only aliens can understand it! ;)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# To clear up the confusion\\n\\nLexographic order = alphabetical order. Think about it like this: if you were to build a dictionary, which word would you put first?\\n\\nThis is why some apparently weird test cases like `[[\"kuvp\",\"q\"], \"ngxlkthsjuoqcpavbfdermiywz\"]` return true"
                    },
                    {
                        "username": "kseniiaprytkova",
                        "content": "Imagine a regular paper dictionary of your language. Where words are presented and their definitions. The words there are in alphabetical order. If the first letters of 2 words are the same, then we look at the second letters of 2 words (and so on) to decide which word will be first."
                    },
                    {
                        "username": "dapilk101",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) Good explanation. That is how I interpreted this problem too."
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova)  Basically , the words list is a dictionary (ex - oxford dictionary) and the order is provided (ranking of alphabets) , we need to check whether the dictionary is correct i.e. the words need to be in order provided."
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "This is how I understand this task:\\n\\nIf the first word in the given array \"words\" is longer then second --- result will be false \\nThan we take letters of this words and find them in the given \"order\", if the index of the letter from the  first word is bigger than the letter index of the second word --- result will be false \\n(for example, we have the first letters from the first and the second word, we find index of this letters in the given \"order\" and compare this indexes, the index of the first word must be lower that index of the second, otherwise it will be false)\\n\\nYou can correct me if I\\'m wrong or add explanations to my answer. This task is really unclear, lol"
                    },
                    {
                        "username": "shubham_kamdi",
                        "content": "please move this to medium "
                    },
                    {
                        "username": "dieg0maci3l",
                        "content": "I don't think this is a medium problem, they just need to add a short list of \"lexicographical rules\" to make the statement more clear. They explain how the lexicographical rules work in the examples, but the statement can be improved for sure. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I would say this is an easy problem with a few edge cases where we need to be more careful"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Medium problems often take me over an hour, or I require hints, this took me 6 minuets and 44 seconds. Not sure why this would be medium?"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "[@aanand07](/aanand07) thanks i think this might be cause\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Let me check with the Men in Black."
                    },
                    {
                        "username": "aanand07",
                        "content": "IMO, in some cases input constraints determine the level of a problem.\\nOver here, words and words[i] max length is less, so it should be in easy category."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Took about 5 minutes to solve I don\\'t know what you\\'re talking about lol"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Definitely not an easy lol. Also they should say `alphabetical order` somewhere in the question because `lexicographic order` is just a weird term that causes confusion"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Somewhere Aliens are laughing..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Hard to be an alien nowadays :)"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "is my skill going down or the easy questions are getting difficult ?"
                    },
                    {
                        "username": "mohak0",
                        "content": "I believe that the question description should\\'ve explained the problem better. The current description is so vague that we\\'re expected to decipher the test cases and figure out what\\'s being asked.\\nMaybe a good problem for interviews where you can ask questions and clarify different test cases with the interviewer "
                    },
                    {
                        "username": "coolgal",
                        "content": "Why is following testcase returning true ?\\n\\n[\"kuvp\",\"q\"]\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\nIn example 3, it says if second string length is less then first string than return false?\\n\\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nOutput: false\\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because \\'l\\' > \\'\\u2205\\', where \\'\\u2205\\' is defined as the blank character which is less than any other character (More info)."
                    },
                    {
                        "username": "hridoy100",
                        "content": "condition should be: if word2 has more length and it is also a minimum length substring of word1."
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"abcdefghijklmnopqrstuvwxyz\"\norder.index(\"k\") \n=> 10\norder.index(\"q\") \n=> 16\nso \"k\" before \"q\" then ignore other later \nThe first letter has the highest importance"
                    },
                    {
                        "username": "arshde3p",
                        "content": "Hint: compare characters from left-to-right. See here q > k, so it will come after in the lexicographic order. In the apple-app example you\\'ll start from left \\n\\'a\\' == \\'a\\'\\n\\'p\\' == \\'p\\'\\n.\\n\\'l\\' > null\\nso \"apple\" is greater than \"app\" here hence result is false for that case.\\n\\nHere,\\n\\'k\\' < \\'q\\'\\nso break here itself rest characters doesn\\'t matter"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "[@srivastavashubham7984](/srivastavashubham7984)  I don\\'t think it is invalid. We compare \"kuvp\" to \"q\", which is equal to \"kuvp\" to \"q000\" where 0 is phi. since \"k\" < \"q\", this should return True. Its similar to \"ant\" < \"z\" in our modern lexicography. "
                    },
                    {
                        "username": "shantanu1405",
                        "content": "if you have seen a dictionary, there words are arranged lexicographical , there, ambulance comes before zebra, so we move from the first letter and check, if at any point, the letter of preceding word is alphabetically greater than the  letter of next word, then it is wrong.\\nin your case, k comes before q, so no need to check the next letters as the sequence is correct\\n\\n"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "\"apple\" > \"app\" is sorted by the length only because they both start with \"app\".\\nin the case with [\"kuvp\",\"q\"] \"k\" shows up sooner in the alphabet than \"q\" does, so even though \"kuvp\" is longer it is alphabetically first,\\njust like how \"apple\" comes alphabetically first before \"car\" in regular english  "
                    },
                    {
                        "username": "srivastavashubham7984",
                        "content": "[@ujjwal1234](/ujjwal1234)  Yes, this seems to be invalid test case. As per the example, output should be false."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "I am also facing the same problem\\n"
                    },
                    {
                        "username": "mhhs",
                        "content": "I think this one is a medium problem. It\\'s take a long time for me to grasp the concept clearly"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Hint: check next character only if current character is equal.\\n\\nThey should\\'ve mentioned it, i\\'m not sure how it is obvious"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "The second test case in the examples states in its explanation, \\'As \\'d\\' comes after \\'l\\' in this language\\' it should be obvious."
                    },
                    {
                        "username": "ayush_cmd",
                        "content": "it is obvio because this is how the real dictionary works"
                    },
                    {
                        "username": "aanand07",
                        "content": "Thanks for this tip!! \\uD83D\\uDD25 "
                    },
                    {
                        "username": "rohit__27",
                        "content": "it is .."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "![image](https://assets.leetcode.com/users/bluecode2017/image_1561259655.png)\\n"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@TornikePy](/TornikePy) \\nSo how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "TuringJest",
                        "content": "A simple way to understand this, is to picture a string\\'s lexicographic value as a float - where the first char is the integer part and the rest is the fractional part.\\n\\nh   l   a  b  c  d  e   f  g   i    j    k   m    n   o   p   q    r    s    t...\\n0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19...\\n\\nhello -> 0 6 1 1 14  -> 0 . 6 1 1 14\\nleetcode -> 1 6 6 19 4 14 5 6 -> 1 . 6 6 19 4 14 5 6\\n(let\\'s imagine the float it in base26, so that a letter can\\'t take up more than \"one decimal place\" or correct in base26 - a hexavigesimal place.)\\n\\nIt\\'s immediately clear that 1.6... > 0.6....\\n\\nPs. Don\\'t get confused about base26, it\\'s just there to make the float analogy mathematically correct. It\\'s not needed for the mental model or the code.\\n\\n"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\\norder.index(\"h\")\\n=> 0\\norder.index(\"l\")\\n=>  1\\nso \"h\" before \"l\" then ignore other later\\nThe first letter has the highest importance\\nis sored "
                    },
                    {
                        "username": "GKushi",
                        "content": "[@TornikePy](/TornikePy)  Thanks"
                    },
                    {
                        "username": "TornikePy",
                        "content": "we do not need to check more than first character, as H and L are different and L comes after H, so second word will come after first."
                    },
                    {
                        "username": "pradeep11",
                        "content": "Example 1:\\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nOutput: true\\n\\nthe 4th index position - char \\'o\\' comes after 4th index position of second word \\'c\\' . How it is sorted? It should return false?"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@Vaibhav_69](/Vaibhav_69) So how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "We are only checking the first character of the words in the string array, hence it is true as H<L in alien dictionary"
                    },
                    {
                        "username": "JohnCanessa",
                        "content": "Hello,\\nThe first test case uses the words \\'hello\\' and \\'leetcode\\' and the dictionary \\'hlabcdefgijkmnopqrstuvwxyz\\'.\\n\\'hello\\' = [0, 6, 1, 1, 14]\\n\\'leetcode\\' = [1, 6, 6, 19, 4, 14, 5, 6]\\n0 <= 1, 6 <= 6, 1 <= 6, 1 <= 19, 14 > 4\\n\\'hello\\' seems to be > \\'leetcode\\'.\\nThat seems to indicate that the result for the test case should be false.\\nCould someone set me straight?\\nThanks\\nJohn\\n\\n"
                    },
                    {
                        "username": "leddie24",
                        "content": "We\\'re not comparing the total \"value\" of each word. We stop as soon as we get to a comparison that isn\\'t equal.  For a non-alien dictionary (e.g: English) if we compare \"Apple\" to \"America\", \"America\" is sorted before apple, because we stop comparing after the second letter.  In the example, since \"h\" !== \"l\", we can stop the comparison after those letters. H has a lower index in the alien alphabet, so we consider \"hello\" < \"leetcode\"."
                    }
                ]
            },
            {
                "id": 1569578,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me :/"
                    },
                    {
                        "username": "urodoloh",
                        "content": "[@kseniiaprytkova](/kseniiaprytkova) oh god, i understood the problem only thanks to you. thanks"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Only aliens can understand it! ;)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# To clear up the confusion\\n\\nLexographic order = alphabetical order. Think about it like this: if you were to build a dictionary, which word would you put first?\\n\\nThis is why some apparently weird test cases like `[[\"kuvp\",\"q\"], \"ngxlkthsjuoqcpavbfdermiywz\"]` return true"
                    },
                    {
                        "username": "kseniiaprytkova",
                        "content": "Imagine a regular paper dictionary of your language. Where words are presented and their definitions. The words there are in alphabetical order. If the first letters of 2 words are the same, then we look at the second letters of 2 words (and so on) to decide which word will be first."
                    },
                    {
                        "username": "dapilk101",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) Good explanation. That is how I interpreted this problem too."
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova)  Basically , the words list is a dictionary (ex - oxford dictionary) and the order is provided (ranking of alphabets) , we need to check whether the dictionary is correct i.e. the words need to be in order provided."
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "This is how I understand this task:\\n\\nIf the first word in the given array \"words\" is longer then second --- result will be false \\nThan we take letters of this words and find them in the given \"order\", if the index of the letter from the  first word is bigger than the letter index of the second word --- result will be false \\n(for example, we have the first letters from the first and the second word, we find index of this letters in the given \"order\" and compare this indexes, the index of the first word must be lower that index of the second, otherwise it will be false)\\n\\nYou can correct me if I\\'m wrong or add explanations to my answer. This task is really unclear, lol"
                    },
                    {
                        "username": "shubham_kamdi",
                        "content": "please move this to medium "
                    },
                    {
                        "username": "dieg0maci3l",
                        "content": "I don't think this is a medium problem, they just need to add a short list of \"lexicographical rules\" to make the statement more clear. They explain how the lexicographical rules work in the examples, but the statement can be improved for sure. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I would say this is an easy problem with a few edge cases where we need to be more careful"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Medium problems often take me over an hour, or I require hints, this took me 6 minuets and 44 seconds. Not sure why this would be medium?"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "[@aanand07](/aanand07) thanks i think this might be cause\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Let me check with the Men in Black."
                    },
                    {
                        "username": "aanand07",
                        "content": "IMO, in some cases input constraints determine the level of a problem.\\nOver here, words and words[i] max length is less, so it should be in easy category."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Took about 5 minutes to solve I don\\'t know what you\\'re talking about lol"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Definitely not an easy lol. Also they should say `alphabetical order` somewhere in the question because `lexicographic order` is just a weird term that causes confusion"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Somewhere Aliens are laughing..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Hard to be an alien nowadays :)"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "is my skill going down or the easy questions are getting difficult ?"
                    },
                    {
                        "username": "mohak0",
                        "content": "I believe that the question description should\\'ve explained the problem better. The current description is so vague that we\\'re expected to decipher the test cases and figure out what\\'s being asked.\\nMaybe a good problem for interviews where you can ask questions and clarify different test cases with the interviewer "
                    },
                    {
                        "username": "coolgal",
                        "content": "Why is following testcase returning true ?\\n\\n[\"kuvp\",\"q\"]\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\nIn example 3, it says if second string length is less then first string than return false?\\n\\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nOutput: false\\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because \\'l\\' > \\'\\u2205\\', where \\'\\u2205\\' is defined as the blank character which is less than any other character (More info)."
                    },
                    {
                        "username": "hridoy100",
                        "content": "condition should be: if word2 has more length and it is also a minimum length substring of word1."
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"abcdefghijklmnopqrstuvwxyz\"\norder.index(\"k\") \n=> 10\norder.index(\"q\") \n=> 16\nso \"k\" before \"q\" then ignore other later \nThe first letter has the highest importance"
                    },
                    {
                        "username": "arshde3p",
                        "content": "Hint: compare characters from left-to-right. See here q > k, so it will come after in the lexicographic order. In the apple-app example you\\'ll start from left \\n\\'a\\' == \\'a\\'\\n\\'p\\' == \\'p\\'\\n.\\n\\'l\\' > null\\nso \"apple\" is greater than \"app\" here hence result is false for that case.\\n\\nHere,\\n\\'k\\' < \\'q\\'\\nso break here itself rest characters doesn\\'t matter"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "[@srivastavashubham7984](/srivastavashubham7984)  I don\\'t think it is invalid. We compare \"kuvp\" to \"q\", which is equal to \"kuvp\" to \"q000\" where 0 is phi. since \"k\" < \"q\", this should return True. Its similar to \"ant\" < \"z\" in our modern lexicography. "
                    },
                    {
                        "username": "shantanu1405",
                        "content": "if you have seen a dictionary, there words are arranged lexicographical , there, ambulance comes before zebra, so we move from the first letter and check, if at any point, the letter of preceding word is alphabetically greater than the  letter of next word, then it is wrong.\\nin your case, k comes before q, so no need to check the next letters as the sequence is correct\\n\\n"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "\"apple\" > \"app\" is sorted by the length only because they both start with \"app\".\\nin the case with [\"kuvp\",\"q\"] \"k\" shows up sooner in the alphabet than \"q\" does, so even though \"kuvp\" is longer it is alphabetically first,\\njust like how \"apple\" comes alphabetically first before \"car\" in regular english  "
                    },
                    {
                        "username": "srivastavashubham7984",
                        "content": "[@ujjwal1234](/ujjwal1234)  Yes, this seems to be invalid test case. As per the example, output should be false."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "I am also facing the same problem\\n"
                    },
                    {
                        "username": "mhhs",
                        "content": "I think this one is a medium problem. It\\'s take a long time for me to grasp the concept clearly"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Hint: check next character only if current character is equal.\\n\\nThey should\\'ve mentioned it, i\\'m not sure how it is obvious"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "The second test case in the examples states in its explanation, \\'As \\'d\\' comes after \\'l\\' in this language\\' it should be obvious."
                    },
                    {
                        "username": "ayush_cmd",
                        "content": "it is obvio because this is how the real dictionary works"
                    },
                    {
                        "username": "aanand07",
                        "content": "Thanks for this tip!! \\uD83D\\uDD25 "
                    },
                    {
                        "username": "rohit__27",
                        "content": "it is .."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "![image](https://assets.leetcode.com/users/bluecode2017/image_1561259655.png)\\n"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@TornikePy](/TornikePy) \\nSo how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "TuringJest",
                        "content": "A simple way to understand this, is to picture a string\\'s lexicographic value as a float - where the first char is the integer part and the rest is the fractional part.\\n\\nh   l   a  b  c  d  e   f  g   i    j    k   m    n   o   p   q    r    s    t...\\n0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19...\\n\\nhello -> 0 6 1 1 14  -> 0 . 6 1 1 14\\nleetcode -> 1 6 6 19 4 14 5 6 -> 1 . 6 6 19 4 14 5 6\\n(let\\'s imagine the float it in base26, so that a letter can\\'t take up more than \"one decimal place\" or correct in base26 - a hexavigesimal place.)\\n\\nIt\\'s immediately clear that 1.6... > 0.6....\\n\\nPs. Don\\'t get confused about base26, it\\'s just there to make the float analogy mathematically correct. It\\'s not needed for the mental model or the code.\\n\\n"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\\norder.index(\"h\")\\n=> 0\\norder.index(\"l\")\\n=>  1\\nso \"h\" before \"l\" then ignore other later\\nThe first letter has the highest importance\\nis sored "
                    },
                    {
                        "username": "GKushi",
                        "content": "[@TornikePy](/TornikePy)  Thanks"
                    },
                    {
                        "username": "TornikePy",
                        "content": "we do not need to check more than first character, as H and L are different and L comes after H, so second word will come after first."
                    },
                    {
                        "username": "pradeep11",
                        "content": "Example 1:\\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nOutput: true\\n\\nthe 4th index position - char \\'o\\' comes after 4th index position of second word \\'c\\' . How it is sorted? It should return false?"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@Vaibhav_69](/Vaibhav_69) So how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "We are only checking the first character of the words in the string array, hence it is true as H<L in alien dictionary"
                    },
                    {
                        "username": "JohnCanessa",
                        "content": "Hello,\\nThe first test case uses the words \\'hello\\' and \\'leetcode\\' and the dictionary \\'hlabcdefgijkmnopqrstuvwxyz\\'.\\n\\'hello\\' = [0, 6, 1, 1, 14]\\n\\'leetcode\\' = [1, 6, 6, 19, 4, 14, 5, 6]\\n0 <= 1, 6 <= 6, 1 <= 6, 1 <= 19, 14 > 4\\n\\'hello\\' seems to be > \\'leetcode\\'.\\nThat seems to indicate that the result for the test case should be false.\\nCould someone set me straight?\\nThanks\\nJohn\\n\\n"
                    },
                    {
                        "username": "leddie24",
                        "content": "We\\'re not comparing the total \"value\" of each word. We stop as soon as we get to a comparison that isn\\'t equal.  For a non-alien dictionary (e.g: English) if we compare \"Apple\" to \"America\", \"America\" is sorted before apple, because we stop comparing after the second letter.  In the example, since \"h\" !== \"l\", we can stop the comparison after those letters. H has a lower index in the alien alphabet, so we consider \"hello\" < \"leetcode\"."
                    }
                ]
            },
            {
                "id": 1734339,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me :/"
                    },
                    {
                        "username": "urodoloh",
                        "content": "[@kseniiaprytkova](/kseniiaprytkova) oh god, i understood the problem only thanks to you. thanks"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Only aliens can understand it! ;)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# To clear up the confusion\\n\\nLexographic order = alphabetical order. Think about it like this: if you were to build a dictionary, which word would you put first?\\n\\nThis is why some apparently weird test cases like `[[\"kuvp\",\"q\"], \"ngxlkthsjuoqcpavbfdermiywz\"]` return true"
                    },
                    {
                        "username": "kseniiaprytkova",
                        "content": "Imagine a regular paper dictionary of your language. Where words are presented and their definitions. The words there are in alphabetical order. If the first letters of 2 words are the same, then we look at the second letters of 2 words (and so on) to decide which word will be first."
                    },
                    {
                        "username": "dapilk101",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) Good explanation. That is how I interpreted this problem too."
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova)  Basically , the words list is a dictionary (ex - oxford dictionary) and the order is provided (ranking of alphabets) , we need to check whether the dictionary is correct i.e. the words need to be in order provided."
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "This is how I understand this task:\\n\\nIf the first word in the given array \"words\" is longer then second --- result will be false \\nThan we take letters of this words and find them in the given \"order\", if the index of the letter from the  first word is bigger than the letter index of the second word --- result will be false \\n(for example, we have the first letters from the first and the second word, we find index of this letters in the given \"order\" and compare this indexes, the index of the first word must be lower that index of the second, otherwise it will be false)\\n\\nYou can correct me if I\\'m wrong or add explanations to my answer. This task is really unclear, lol"
                    },
                    {
                        "username": "shubham_kamdi",
                        "content": "please move this to medium "
                    },
                    {
                        "username": "dieg0maci3l",
                        "content": "I don't think this is a medium problem, they just need to add a short list of \"lexicographical rules\" to make the statement more clear. They explain how the lexicographical rules work in the examples, but the statement can be improved for sure. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I would say this is an easy problem with a few edge cases where we need to be more careful"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Medium problems often take me over an hour, or I require hints, this took me 6 minuets and 44 seconds. Not sure why this would be medium?"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "[@aanand07](/aanand07) thanks i think this might be cause\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Let me check with the Men in Black."
                    },
                    {
                        "username": "aanand07",
                        "content": "IMO, in some cases input constraints determine the level of a problem.\\nOver here, words and words[i] max length is less, so it should be in easy category."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Took about 5 minutes to solve I don\\'t know what you\\'re talking about lol"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Definitely not an easy lol. Also they should say `alphabetical order` somewhere in the question because `lexicographic order` is just a weird term that causes confusion"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Somewhere Aliens are laughing..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Hard to be an alien nowadays :)"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "is my skill going down or the easy questions are getting difficult ?"
                    },
                    {
                        "username": "mohak0",
                        "content": "I believe that the question description should\\'ve explained the problem better. The current description is so vague that we\\'re expected to decipher the test cases and figure out what\\'s being asked.\\nMaybe a good problem for interviews where you can ask questions and clarify different test cases with the interviewer "
                    },
                    {
                        "username": "coolgal",
                        "content": "Why is following testcase returning true ?\\n\\n[\"kuvp\",\"q\"]\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\nIn example 3, it says if second string length is less then first string than return false?\\n\\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nOutput: false\\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because \\'l\\' > \\'\\u2205\\', where \\'\\u2205\\' is defined as the blank character which is less than any other character (More info)."
                    },
                    {
                        "username": "hridoy100",
                        "content": "condition should be: if word2 has more length and it is also a minimum length substring of word1."
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"abcdefghijklmnopqrstuvwxyz\"\norder.index(\"k\") \n=> 10\norder.index(\"q\") \n=> 16\nso \"k\" before \"q\" then ignore other later \nThe first letter has the highest importance"
                    },
                    {
                        "username": "arshde3p",
                        "content": "Hint: compare characters from left-to-right. See here q > k, so it will come after in the lexicographic order. In the apple-app example you\\'ll start from left \\n\\'a\\' == \\'a\\'\\n\\'p\\' == \\'p\\'\\n.\\n\\'l\\' > null\\nso \"apple\" is greater than \"app\" here hence result is false for that case.\\n\\nHere,\\n\\'k\\' < \\'q\\'\\nso break here itself rest characters doesn\\'t matter"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "[@srivastavashubham7984](/srivastavashubham7984)  I don\\'t think it is invalid. We compare \"kuvp\" to \"q\", which is equal to \"kuvp\" to \"q000\" where 0 is phi. since \"k\" < \"q\", this should return True. Its similar to \"ant\" < \"z\" in our modern lexicography. "
                    },
                    {
                        "username": "shantanu1405",
                        "content": "if you have seen a dictionary, there words are arranged lexicographical , there, ambulance comes before zebra, so we move from the first letter and check, if at any point, the letter of preceding word is alphabetically greater than the  letter of next word, then it is wrong.\\nin your case, k comes before q, so no need to check the next letters as the sequence is correct\\n\\n"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "\"apple\" > \"app\" is sorted by the length only because they both start with \"app\".\\nin the case with [\"kuvp\",\"q\"] \"k\" shows up sooner in the alphabet than \"q\" does, so even though \"kuvp\" is longer it is alphabetically first,\\njust like how \"apple\" comes alphabetically first before \"car\" in regular english  "
                    },
                    {
                        "username": "srivastavashubham7984",
                        "content": "[@ujjwal1234](/ujjwal1234)  Yes, this seems to be invalid test case. As per the example, output should be false."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "I am also facing the same problem\\n"
                    },
                    {
                        "username": "mhhs",
                        "content": "I think this one is a medium problem. It\\'s take a long time for me to grasp the concept clearly"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Hint: check next character only if current character is equal.\\n\\nThey should\\'ve mentioned it, i\\'m not sure how it is obvious"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "The second test case in the examples states in its explanation, \\'As \\'d\\' comes after \\'l\\' in this language\\' it should be obvious."
                    },
                    {
                        "username": "ayush_cmd",
                        "content": "it is obvio because this is how the real dictionary works"
                    },
                    {
                        "username": "aanand07",
                        "content": "Thanks for this tip!! \\uD83D\\uDD25 "
                    },
                    {
                        "username": "rohit__27",
                        "content": "it is .."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "![image](https://assets.leetcode.com/users/bluecode2017/image_1561259655.png)\\n"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@TornikePy](/TornikePy) \\nSo how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "TuringJest",
                        "content": "A simple way to understand this, is to picture a string\\'s lexicographic value as a float - where the first char is the integer part and the rest is the fractional part.\\n\\nh   l   a  b  c  d  e   f  g   i    j    k   m    n   o   p   q    r    s    t...\\n0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19...\\n\\nhello -> 0 6 1 1 14  -> 0 . 6 1 1 14\\nleetcode -> 1 6 6 19 4 14 5 6 -> 1 . 6 6 19 4 14 5 6\\n(let\\'s imagine the float it in base26, so that a letter can\\'t take up more than \"one decimal place\" or correct in base26 - a hexavigesimal place.)\\n\\nIt\\'s immediately clear that 1.6... > 0.6....\\n\\nPs. Don\\'t get confused about base26, it\\'s just there to make the float analogy mathematically correct. It\\'s not needed for the mental model or the code.\\n\\n"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\\norder.index(\"h\")\\n=> 0\\norder.index(\"l\")\\n=>  1\\nso \"h\" before \"l\" then ignore other later\\nThe first letter has the highest importance\\nis sored "
                    },
                    {
                        "username": "GKushi",
                        "content": "[@TornikePy](/TornikePy)  Thanks"
                    },
                    {
                        "username": "TornikePy",
                        "content": "we do not need to check more than first character, as H and L are different and L comes after H, so second word will come after first."
                    },
                    {
                        "username": "pradeep11",
                        "content": "Example 1:\\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nOutput: true\\n\\nthe 4th index position - char \\'o\\' comes after 4th index position of second word \\'c\\' . How it is sorted? It should return false?"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@Vaibhav_69](/Vaibhav_69) So how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "We are only checking the first character of the words in the string array, hence it is true as H<L in alien dictionary"
                    },
                    {
                        "username": "JohnCanessa",
                        "content": "Hello,\\nThe first test case uses the words \\'hello\\' and \\'leetcode\\' and the dictionary \\'hlabcdefgijkmnopqrstuvwxyz\\'.\\n\\'hello\\' = [0, 6, 1, 1, 14]\\n\\'leetcode\\' = [1, 6, 6, 19, 4, 14, 5, 6]\\n0 <= 1, 6 <= 6, 1 <= 6, 1 <= 19, 14 > 4\\n\\'hello\\' seems to be > \\'leetcode\\'.\\nThat seems to indicate that the result for the test case should be false.\\nCould someone set me straight?\\nThanks\\nJohn\\n\\n"
                    },
                    {
                        "username": "leddie24",
                        "content": "We\\'re not comparing the total \"value\" of each word. We stop as soon as we get to a comparison that isn\\'t equal.  For a non-alien dictionary (e.g: English) if we compare \"Apple\" to \"America\", \"America\" is sorted before apple, because we stop comparing after the second letter.  In the example, since \"h\" !== \"l\", we can stop the comparison after those letters. H has a lower index in the alien alphabet, so we consider \"hello\" < \"leetcode\"."
                    }
                ]
            },
            {
                "id": 1784027,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me :/"
                    },
                    {
                        "username": "urodoloh",
                        "content": "[@kseniiaprytkova](/kseniiaprytkova) oh god, i understood the problem only thanks to you. thanks"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Only aliens can understand it! ;)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# To clear up the confusion\\n\\nLexographic order = alphabetical order. Think about it like this: if you were to build a dictionary, which word would you put first?\\n\\nThis is why some apparently weird test cases like `[[\"kuvp\",\"q\"], \"ngxlkthsjuoqcpavbfdermiywz\"]` return true"
                    },
                    {
                        "username": "kseniiaprytkova",
                        "content": "Imagine a regular paper dictionary of your language. Where words are presented and their definitions. The words there are in alphabetical order. If the first letters of 2 words are the same, then we look at the second letters of 2 words (and so on) to decide which word will be first."
                    },
                    {
                        "username": "dapilk101",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) Good explanation. That is how I interpreted this problem too."
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova)  Basically , the words list is a dictionary (ex - oxford dictionary) and the order is provided (ranking of alphabets) , we need to check whether the dictionary is correct i.e. the words need to be in order provided."
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "This is how I understand this task:\\n\\nIf the first word in the given array \"words\" is longer then second --- result will be false \\nThan we take letters of this words and find them in the given \"order\", if the index of the letter from the  first word is bigger than the letter index of the second word --- result will be false \\n(for example, we have the first letters from the first and the second word, we find index of this letters in the given \"order\" and compare this indexes, the index of the first word must be lower that index of the second, otherwise it will be false)\\n\\nYou can correct me if I\\'m wrong or add explanations to my answer. This task is really unclear, lol"
                    },
                    {
                        "username": "shubham_kamdi",
                        "content": "please move this to medium "
                    },
                    {
                        "username": "dieg0maci3l",
                        "content": "I don't think this is a medium problem, they just need to add a short list of \"lexicographical rules\" to make the statement more clear. They explain how the lexicographical rules work in the examples, but the statement can be improved for sure. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I would say this is an easy problem with a few edge cases where we need to be more careful"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Medium problems often take me over an hour, or I require hints, this took me 6 minuets and 44 seconds. Not sure why this would be medium?"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "[@aanand07](/aanand07) thanks i think this might be cause\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Let me check with the Men in Black."
                    },
                    {
                        "username": "aanand07",
                        "content": "IMO, in some cases input constraints determine the level of a problem.\\nOver here, words and words[i] max length is less, so it should be in easy category."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Took about 5 minutes to solve I don\\'t know what you\\'re talking about lol"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Definitely not an easy lol. Also they should say `alphabetical order` somewhere in the question because `lexicographic order` is just a weird term that causes confusion"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Somewhere Aliens are laughing..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Hard to be an alien nowadays :)"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "is my skill going down or the easy questions are getting difficult ?"
                    },
                    {
                        "username": "mohak0",
                        "content": "I believe that the question description should\\'ve explained the problem better. The current description is so vague that we\\'re expected to decipher the test cases and figure out what\\'s being asked.\\nMaybe a good problem for interviews where you can ask questions and clarify different test cases with the interviewer "
                    },
                    {
                        "username": "coolgal",
                        "content": "Why is following testcase returning true ?\\n\\n[\"kuvp\",\"q\"]\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\nIn example 3, it says if second string length is less then first string than return false?\\n\\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nOutput: false\\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because \\'l\\' > \\'\\u2205\\', where \\'\\u2205\\' is defined as the blank character which is less than any other character (More info)."
                    },
                    {
                        "username": "hridoy100",
                        "content": "condition should be: if word2 has more length and it is also a minimum length substring of word1."
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"abcdefghijklmnopqrstuvwxyz\"\norder.index(\"k\") \n=> 10\norder.index(\"q\") \n=> 16\nso \"k\" before \"q\" then ignore other later \nThe first letter has the highest importance"
                    },
                    {
                        "username": "arshde3p",
                        "content": "Hint: compare characters from left-to-right. See here q > k, so it will come after in the lexicographic order. In the apple-app example you\\'ll start from left \\n\\'a\\' == \\'a\\'\\n\\'p\\' == \\'p\\'\\n.\\n\\'l\\' > null\\nso \"apple\" is greater than \"app\" here hence result is false for that case.\\n\\nHere,\\n\\'k\\' < \\'q\\'\\nso break here itself rest characters doesn\\'t matter"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "[@srivastavashubham7984](/srivastavashubham7984)  I don\\'t think it is invalid. We compare \"kuvp\" to \"q\", which is equal to \"kuvp\" to \"q000\" where 0 is phi. since \"k\" < \"q\", this should return True. Its similar to \"ant\" < \"z\" in our modern lexicography. "
                    },
                    {
                        "username": "shantanu1405",
                        "content": "if you have seen a dictionary, there words are arranged lexicographical , there, ambulance comes before zebra, so we move from the first letter and check, if at any point, the letter of preceding word is alphabetically greater than the  letter of next word, then it is wrong.\\nin your case, k comes before q, so no need to check the next letters as the sequence is correct\\n\\n"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "\"apple\" > \"app\" is sorted by the length only because they both start with \"app\".\\nin the case with [\"kuvp\",\"q\"] \"k\" shows up sooner in the alphabet than \"q\" does, so even though \"kuvp\" is longer it is alphabetically first,\\njust like how \"apple\" comes alphabetically first before \"car\" in regular english  "
                    },
                    {
                        "username": "srivastavashubham7984",
                        "content": "[@ujjwal1234](/ujjwal1234)  Yes, this seems to be invalid test case. As per the example, output should be false."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "I am also facing the same problem\\n"
                    },
                    {
                        "username": "mhhs",
                        "content": "I think this one is a medium problem. It\\'s take a long time for me to grasp the concept clearly"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Hint: check next character only if current character is equal.\\n\\nThey should\\'ve mentioned it, i\\'m not sure how it is obvious"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "The second test case in the examples states in its explanation, \\'As \\'d\\' comes after \\'l\\' in this language\\' it should be obvious."
                    },
                    {
                        "username": "ayush_cmd",
                        "content": "it is obvio because this is how the real dictionary works"
                    },
                    {
                        "username": "aanand07",
                        "content": "Thanks for this tip!! \\uD83D\\uDD25 "
                    },
                    {
                        "username": "rohit__27",
                        "content": "it is .."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "![image](https://assets.leetcode.com/users/bluecode2017/image_1561259655.png)\\n"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@TornikePy](/TornikePy) \\nSo how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "TuringJest",
                        "content": "A simple way to understand this, is to picture a string\\'s lexicographic value as a float - where the first char is the integer part and the rest is the fractional part.\\n\\nh   l   a  b  c  d  e   f  g   i    j    k   m    n   o   p   q    r    s    t...\\n0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19...\\n\\nhello -> 0 6 1 1 14  -> 0 . 6 1 1 14\\nleetcode -> 1 6 6 19 4 14 5 6 -> 1 . 6 6 19 4 14 5 6\\n(let\\'s imagine the float it in base26, so that a letter can\\'t take up more than \"one decimal place\" or correct in base26 - a hexavigesimal place.)\\n\\nIt\\'s immediately clear that 1.6... > 0.6....\\n\\nPs. Don\\'t get confused about base26, it\\'s just there to make the float analogy mathematically correct. It\\'s not needed for the mental model or the code.\\n\\n"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\\norder.index(\"h\")\\n=> 0\\norder.index(\"l\")\\n=>  1\\nso \"h\" before \"l\" then ignore other later\\nThe first letter has the highest importance\\nis sored "
                    },
                    {
                        "username": "GKushi",
                        "content": "[@TornikePy](/TornikePy)  Thanks"
                    },
                    {
                        "username": "TornikePy",
                        "content": "we do not need to check more than first character, as H and L are different and L comes after H, so second word will come after first."
                    },
                    {
                        "username": "pradeep11",
                        "content": "Example 1:\\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nOutput: true\\n\\nthe 4th index position - char \\'o\\' comes after 4th index position of second word \\'c\\' . How it is sorted? It should return false?"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@Vaibhav_69](/Vaibhav_69) So how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "We are only checking the first character of the words in the string array, hence it is true as H<L in alien dictionary"
                    },
                    {
                        "username": "JohnCanessa",
                        "content": "Hello,\\nThe first test case uses the words \\'hello\\' and \\'leetcode\\' and the dictionary \\'hlabcdefgijkmnopqrstuvwxyz\\'.\\n\\'hello\\' = [0, 6, 1, 1, 14]\\n\\'leetcode\\' = [1, 6, 6, 19, 4, 14, 5, 6]\\n0 <= 1, 6 <= 6, 1 <= 6, 1 <= 19, 14 > 4\\n\\'hello\\' seems to be > \\'leetcode\\'.\\nThat seems to indicate that the result for the test case should be false.\\nCould someone set me straight?\\nThanks\\nJohn\\n\\n"
                    },
                    {
                        "username": "leddie24",
                        "content": "We\\'re not comparing the total \"value\" of each word. We stop as soon as we get to a comparison that isn\\'t equal.  For a non-alien dictionary (e.g: English) if we compare \"Apple\" to \"America\", \"America\" is sorted before apple, because we stop comparing after the second letter.  In the example, since \"h\" !== \"l\", we can stop the comparison after those letters. H has a lower index in the alien alphabet, so we consider \"hello\" < \"leetcode\"."
                    }
                ]
            },
            {
                "id": 1564833,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me :/"
                    },
                    {
                        "username": "urodoloh",
                        "content": "[@kseniiaprytkova](/kseniiaprytkova) oh god, i understood the problem only thanks to you. thanks"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Only aliens can understand it! ;)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# To clear up the confusion\\n\\nLexographic order = alphabetical order. Think about it like this: if you were to build a dictionary, which word would you put first?\\n\\nThis is why some apparently weird test cases like `[[\"kuvp\",\"q\"], \"ngxlkthsjuoqcpavbfdermiywz\"]` return true"
                    },
                    {
                        "username": "kseniiaprytkova",
                        "content": "Imagine a regular paper dictionary of your language. Where words are presented and their definitions. The words there are in alphabetical order. If the first letters of 2 words are the same, then we look at the second letters of 2 words (and so on) to decide which word will be first."
                    },
                    {
                        "username": "dapilk101",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) Good explanation. That is how I interpreted this problem too."
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova)  Basically , the words list is a dictionary (ex - oxford dictionary) and the order is provided (ranking of alphabets) , we need to check whether the dictionary is correct i.e. the words need to be in order provided."
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "This is how I understand this task:\\n\\nIf the first word in the given array \"words\" is longer then second --- result will be false \\nThan we take letters of this words and find them in the given \"order\", if the index of the letter from the  first word is bigger than the letter index of the second word --- result will be false \\n(for example, we have the first letters from the first and the second word, we find index of this letters in the given \"order\" and compare this indexes, the index of the first word must be lower that index of the second, otherwise it will be false)\\n\\nYou can correct me if I\\'m wrong or add explanations to my answer. This task is really unclear, lol"
                    },
                    {
                        "username": "shubham_kamdi",
                        "content": "please move this to medium "
                    },
                    {
                        "username": "dieg0maci3l",
                        "content": "I don't think this is a medium problem, they just need to add a short list of \"lexicographical rules\" to make the statement more clear. They explain how the lexicographical rules work in the examples, but the statement can be improved for sure. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I would say this is an easy problem with a few edge cases where we need to be more careful"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Medium problems often take me over an hour, or I require hints, this took me 6 minuets and 44 seconds. Not sure why this would be medium?"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "[@aanand07](/aanand07) thanks i think this might be cause\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Let me check with the Men in Black."
                    },
                    {
                        "username": "aanand07",
                        "content": "IMO, in some cases input constraints determine the level of a problem.\\nOver here, words and words[i] max length is less, so it should be in easy category."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Took about 5 minutes to solve I don\\'t know what you\\'re talking about lol"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Definitely not an easy lol. Also they should say `alphabetical order` somewhere in the question because `lexicographic order` is just a weird term that causes confusion"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Somewhere Aliens are laughing..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Hard to be an alien nowadays :)"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "is my skill going down or the easy questions are getting difficult ?"
                    },
                    {
                        "username": "mohak0",
                        "content": "I believe that the question description should\\'ve explained the problem better. The current description is so vague that we\\'re expected to decipher the test cases and figure out what\\'s being asked.\\nMaybe a good problem for interviews where you can ask questions and clarify different test cases with the interviewer "
                    },
                    {
                        "username": "coolgal",
                        "content": "Why is following testcase returning true ?\\n\\n[\"kuvp\",\"q\"]\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\nIn example 3, it says if second string length is less then first string than return false?\\n\\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nOutput: false\\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because \\'l\\' > \\'\\u2205\\', where \\'\\u2205\\' is defined as the blank character which is less than any other character (More info)."
                    },
                    {
                        "username": "hridoy100",
                        "content": "condition should be: if word2 has more length and it is also a minimum length substring of word1."
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"abcdefghijklmnopqrstuvwxyz\"\norder.index(\"k\") \n=> 10\norder.index(\"q\") \n=> 16\nso \"k\" before \"q\" then ignore other later \nThe first letter has the highest importance"
                    },
                    {
                        "username": "arshde3p",
                        "content": "Hint: compare characters from left-to-right. See here q > k, so it will come after in the lexicographic order. In the apple-app example you\\'ll start from left \\n\\'a\\' == \\'a\\'\\n\\'p\\' == \\'p\\'\\n.\\n\\'l\\' > null\\nso \"apple\" is greater than \"app\" here hence result is false for that case.\\n\\nHere,\\n\\'k\\' < \\'q\\'\\nso break here itself rest characters doesn\\'t matter"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "[@srivastavashubham7984](/srivastavashubham7984)  I don\\'t think it is invalid. We compare \"kuvp\" to \"q\", which is equal to \"kuvp\" to \"q000\" where 0 is phi. since \"k\" < \"q\", this should return True. Its similar to \"ant\" < \"z\" in our modern lexicography. "
                    },
                    {
                        "username": "shantanu1405",
                        "content": "if you have seen a dictionary, there words are arranged lexicographical , there, ambulance comes before zebra, so we move from the first letter and check, if at any point, the letter of preceding word is alphabetically greater than the  letter of next word, then it is wrong.\\nin your case, k comes before q, so no need to check the next letters as the sequence is correct\\n\\n"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "\"apple\" > \"app\" is sorted by the length only because they both start with \"app\".\\nin the case with [\"kuvp\",\"q\"] \"k\" shows up sooner in the alphabet than \"q\" does, so even though \"kuvp\" is longer it is alphabetically first,\\njust like how \"apple\" comes alphabetically first before \"car\" in regular english  "
                    },
                    {
                        "username": "srivastavashubham7984",
                        "content": "[@ujjwal1234](/ujjwal1234)  Yes, this seems to be invalid test case. As per the example, output should be false."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "I am also facing the same problem\\n"
                    },
                    {
                        "username": "mhhs",
                        "content": "I think this one is a medium problem. It\\'s take a long time for me to grasp the concept clearly"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Hint: check next character only if current character is equal.\\n\\nThey should\\'ve mentioned it, i\\'m not sure how it is obvious"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "The second test case in the examples states in its explanation, \\'As \\'d\\' comes after \\'l\\' in this language\\' it should be obvious."
                    },
                    {
                        "username": "ayush_cmd",
                        "content": "it is obvio because this is how the real dictionary works"
                    },
                    {
                        "username": "aanand07",
                        "content": "Thanks for this tip!! \\uD83D\\uDD25 "
                    },
                    {
                        "username": "rohit__27",
                        "content": "it is .."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "![image](https://assets.leetcode.com/users/bluecode2017/image_1561259655.png)\\n"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@TornikePy](/TornikePy) \\nSo how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "TuringJest",
                        "content": "A simple way to understand this, is to picture a string\\'s lexicographic value as a float - where the first char is the integer part and the rest is the fractional part.\\n\\nh   l   a  b  c  d  e   f  g   i    j    k   m    n   o   p   q    r    s    t...\\n0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19...\\n\\nhello -> 0 6 1 1 14  -> 0 . 6 1 1 14\\nleetcode -> 1 6 6 19 4 14 5 6 -> 1 . 6 6 19 4 14 5 6\\n(let\\'s imagine the float it in base26, so that a letter can\\'t take up more than \"one decimal place\" or correct in base26 - a hexavigesimal place.)\\n\\nIt\\'s immediately clear that 1.6... > 0.6....\\n\\nPs. Don\\'t get confused about base26, it\\'s just there to make the float analogy mathematically correct. It\\'s not needed for the mental model or the code.\\n\\n"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\\norder.index(\"h\")\\n=> 0\\norder.index(\"l\")\\n=>  1\\nso \"h\" before \"l\" then ignore other later\\nThe first letter has the highest importance\\nis sored "
                    },
                    {
                        "username": "GKushi",
                        "content": "[@TornikePy](/TornikePy)  Thanks"
                    },
                    {
                        "username": "TornikePy",
                        "content": "we do not need to check more than first character, as H and L are different and L comes after H, so second word will come after first."
                    },
                    {
                        "username": "pradeep11",
                        "content": "Example 1:\\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nOutput: true\\n\\nthe 4th index position - char \\'o\\' comes after 4th index position of second word \\'c\\' . How it is sorted? It should return false?"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@Vaibhav_69](/Vaibhav_69) So how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "We are only checking the first character of the words in the string array, hence it is true as H<L in alien dictionary"
                    },
                    {
                        "username": "JohnCanessa",
                        "content": "Hello,\\nThe first test case uses the words \\'hello\\' and \\'leetcode\\' and the dictionary \\'hlabcdefgijkmnopqrstuvwxyz\\'.\\n\\'hello\\' = [0, 6, 1, 1, 14]\\n\\'leetcode\\' = [1, 6, 6, 19, 4, 14, 5, 6]\\n0 <= 1, 6 <= 6, 1 <= 6, 1 <= 19, 14 > 4\\n\\'hello\\' seems to be > \\'leetcode\\'.\\nThat seems to indicate that the result for the test case should be false.\\nCould someone set me straight?\\nThanks\\nJohn\\n\\n"
                    },
                    {
                        "username": "leddie24",
                        "content": "We\\'re not comparing the total \"value\" of each word. We stop as soon as we get to a comparison that isn\\'t equal.  For a non-alien dictionary (e.g: English) if we compare \"Apple\" to \"America\", \"America\" is sorted before apple, because we stop comparing after the second letter.  In the example, since \"h\" !== \"l\", we can stop the comparison after those letters. H has a lower index in the alien alphabet, so we consider \"hello\" < \"leetcode\"."
                    }
                ]
            },
            {
                "id": 1568080,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me :/"
                    },
                    {
                        "username": "urodoloh",
                        "content": "[@kseniiaprytkova](/kseniiaprytkova) oh god, i understood the problem only thanks to you. thanks"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Only aliens can understand it! ;)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# To clear up the confusion\\n\\nLexographic order = alphabetical order. Think about it like this: if you were to build a dictionary, which word would you put first?\\n\\nThis is why some apparently weird test cases like `[[\"kuvp\",\"q\"], \"ngxlkthsjuoqcpavbfdermiywz\"]` return true"
                    },
                    {
                        "username": "kseniiaprytkova",
                        "content": "Imagine a regular paper dictionary of your language. Where words are presented and their definitions. The words there are in alphabetical order. If the first letters of 2 words are the same, then we look at the second letters of 2 words (and so on) to decide which word will be first."
                    },
                    {
                        "username": "dapilk101",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) Good explanation. That is how I interpreted this problem too."
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova)  Basically , the words list is a dictionary (ex - oxford dictionary) and the order is provided (ranking of alphabets) , we need to check whether the dictionary is correct i.e. the words need to be in order provided."
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "This is how I understand this task:\\n\\nIf the first word in the given array \"words\" is longer then second --- result will be false \\nThan we take letters of this words and find them in the given \"order\", if the index of the letter from the  first word is bigger than the letter index of the second word --- result will be false \\n(for example, we have the first letters from the first and the second word, we find index of this letters in the given \"order\" and compare this indexes, the index of the first word must be lower that index of the second, otherwise it will be false)\\n\\nYou can correct me if I\\'m wrong or add explanations to my answer. This task is really unclear, lol"
                    },
                    {
                        "username": "shubham_kamdi",
                        "content": "please move this to medium "
                    },
                    {
                        "username": "dieg0maci3l",
                        "content": "I don't think this is a medium problem, they just need to add a short list of \"lexicographical rules\" to make the statement more clear. They explain how the lexicographical rules work in the examples, but the statement can be improved for sure. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I would say this is an easy problem with a few edge cases where we need to be more careful"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Medium problems often take me over an hour, or I require hints, this took me 6 minuets and 44 seconds. Not sure why this would be medium?"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "[@aanand07](/aanand07) thanks i think this might be cause\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Let me check with the Men in Black."
                    },
                    {
                        "username": "aanand07",
                        "content": "IMO, in some cases input constraints determine the level of a problem.\\nOver here, words and words[i] max length is less, so it should be in easy category."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Took about 5 minutes to solve I don\\'t know what you\\'re talking about lol"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Definitely not an easy lol. Also they should say `alphabetical order` somewhere in the question because `lexicographic order` is just a weird term that causes confusion"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Somewhere Aliens are laughing..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Hard to be an alien nowadays :)"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "is my skill going down or the easy questions are getting difficult ?"
                    },
                    {
                        "username": "mohak0",
                        "content": "I believe that the question description should\\'ve explained the problem better. The current description is so vague that we\\'re expected to decipher the test cases and figure out what\\'s being asked.\\nMaybe a good problem for interviews where you can ask questions and clarify different test cases with the interviewer "
                    },
                    {
                        "username": "coolgal",
                        "content": "Why is following testcase returning true ?\\n\\n[\"kuvp\",\"q\"]\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\nIn example 3, it says if second string length is less then first string than return false?\\n\\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nOutput: false\\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because \\'l\\' > \\'\\u2205\\', where \\'\\u2205\\' is defined as the blank character which is less than any other character (More info)."
                    },
                    {
                        "username": "hridoy100",
                        "content": "condition should be: if word2 has more length and it is also a minimum length substring of word1."
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"abcdefghijklmnopqrstuvwxyz\"\norder.index(\"k\") \n=> 10\norder.index(\"q\") \n=> 16\nso \"k\" before \"q\" then ignore other later \nThe first letter has the highest importance"
                    },
                    {
                        "username": "arshde3p",
                        "content": "Hint: compare characters from left-to-right. See here q > k, so it will come after in the lexicographic order. In the apple-app example you\\'ll start from left \\n\\'a\\' == \\'a\\'\\n\\'p\\' == \\'p\\'\\n.\\n\\'l\\' > null\\nso \"apple\" is greater than \"app\" here hence result is false for that case.\\n\\nHere,\\n\\'k\\' < \\'q\\'\\nso break here itself rest characters doesn\\'t matter"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "[@srivastavashubham7984](/srivastavashubham7984)  I don\\'t think it is invalid. We compare \"kuvp\" to \"q\", which is equal to \"kuvp\" to \"q000\" where 0 is phi. since \"k\" < \"q\", this should return True. Its similar to \"ant\" < \"z\" in our modern lexicography. "
                    },
                    {
                        "username": "shantanu1405",
                        "content": "if you have seen a dictionary, there words are arranged lexicographical , there, ambulance comes before zebra, so we move from the first letter and check, if at any point, the letter of preceding word is alphabetically greater than the  letter of next word, then it is wrong.\\nin your case, k comes before q, so no need to check the next letters as the sequence is correct\\n\\n"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "\"apple\" > \"app\" is sorted by the length only because they both start with \"app\".\\nin the case with [\"kuvp\",\"q\"] \"k\" shows up sooner in the alphabet than \"q\" does, so even though \"kuvp\" is longer it is alphabetically first,\\njust like how \"apple\" comes alphabetically first before \"car\" in regular english  "
                    },
                    {
                        "username": "srivastavashubham7984",
                        "content": "[@ujjwal1234](/ujjwal1234)  Yes, this seems to be invalid test case. As per the example, output should be false."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "I am also facing the same problem\\n"
                    },
                    {
                        "username": "mhhs",
                        "content": "I think this one is a medium problem. It\\'s take a long time for me to grasp the concept clearly"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Hint: check next character only if current character is equal.\\n\\nThey should\\'ve mentioned it, i\\'m not sure how it is obvious"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "The second test case in the examples states in its explanation, \\'As \\'d\\' comes after \\'l\\' in this language\\' it should be obvious."
                    },
                    {
                        "username": "ayush_cmd",
                        "content": "it is obvio because this is how the real dictionary works"
                    },
                    {
                        "username": "aanand07",
                        "content": "Thanks for this tip!! \\uD83D\\uDD25 "
                    },
                    {
                        "username": "rohit__27",
                        "content": "it is .."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "![image](https://assets.leetcode.com/users/bluecode2017/image_1561259655.png)\\n"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@TornikePy](/TornikePy) \\nSo how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "TuringJest",
                        "content": "A simple way to understand this, is to picture a string\\'s lexicographic value as a float - where the first char is the integer part and the rest is the fractional part.\\n\\nh   l   a  b  c  d  e   f  g   i    j    k   m    n   o   p   q    r    s    t...\\n0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19...\\n\\nhello -> 0 6 1 1 14  -> 0 . 6 1 1 14\\nleetcode -> 1 6 6 19 4 14 5 6 -> 1 . 6 6 19 4 14 5 6\\n(let\\'s imagine the float it in base26, so that a letter can\\'t take up more than \"one decimal place\" or correct in base26 - a hexavigesimal place.)\\n\\nIt\\'s immediately clear that 1.6... > 0.6....\\n\\nPs. Don\\'t get confused about base26, it\\'s just there to make the float analogy mathematically correct. It\\'s not needed for the mental model or the code.\\n\\n"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\\norder.index(\"h\")\\n=> 0\\norder.index(\"l\")\\n=>  1\\nso \"h\" before \"l\" then ignore other later\\nThe first letter has the highest importance\\nis sored "
                    },
                    {
                        "username": "GKushi",
                        "content": "[@TornikePy](/TornikePy)  Thanks"
                    },
                    {
                        "username": "TornikePy",
                        "content": "we do not need to check more than first character, as H and L are different and L comes after H, so second word will come after first."
                    },
                    {
                        "username": "pradeep11",
                        "content": "Example 1:\\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nOutput: true\\n\\nthe 4th index position - char \\'o\\' comes after 4th index position of second word \\'c\\' . How it is sorted? It should return false?"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@Vaibhav_69](/Vaibhav_69) So how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "We are only checking the first character of the words in the string array, hence it is true as H<L in alien dictionary"
                    },
                    {
                        "username": "JohnCanessa",
                        "content": "Hello,\\nThe first test case uses the words \\'hello\\' and \\'leetcode\\' and the dictionary \\'hlabcdefgijkmnopqrstuvwxyz\\'.\\n\\'hello\\' = [0, 6, 1, 1, 14]\\n\\'leetcode\\' = [1, 6, 6, 19, 4, 14, 5, 6]\\n0 <= 1, 6 <= 6, 1 <= 6, 1 <= 19, 14 > 4\\n\\'hello\\' seems to be > \\'leetcode\\'.\\nThat seems to indicate that the result for the test case should be false.\\nCould someone set me straight?\\nThanks\\nJohn\\n\\n"
                    },
                    {
                        "username": "leddie24",
                        "content": "We\\'re not comparing the total \"value\" of each word. We stop as soon as we get to a comparison that isn\\'t equal.  For a non-alien dictionary (e.g: English) if we compare \"Apple\" to \"America\", \"America\" is sorted before apple, because we stop comparing after the second letter.  In the example, since \"h\" !== \"l\", we can stop the comparison after those letters. H has a lower index in the alien alphabet, so we consider \"hello\" < \"leetcode\"."
                    }
                ]
            },
            {
                "id": 1574869,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me :/"
                    },
                    {
                        "username": "urodoloh",
                        "content": "[@kseniiaprytkova](/kseniiaprytkova) oh god, i understood the problem only thanks to you. thanks"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Only aliens can understand it! ;)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# To clear up the confusion\\n\\nLexographic order = alphabetical order. Think about it like this: if you were to build a dictionary, which word would you put first?\\n\\nThis is why some apparently weird test cases like `[[\"kuvp\",\"q\"], \"ngxlkthsjuoqcpavbfdermiywz\"]` return true"
                    },
                    {
                        "username": "kseniiaprytkova",
                        "content": "Imagine a regular paper dictionary of your language. Where words are presented and their definitions. The words there are in alphabetical order. If the first letters of 2 words are the same, then we look at the second letters of 2 words (and so on) to decide which word will be first."
                    },
                    {
                        "username": "dapilk101",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) Good explanation. That is how I interpreted this problem too."
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova)  Basically , the words list is a dictionary (ex - oxford dictionary) and the order is provided (ranking of alphabets) , we need to check whether the dictionary is correct i.e. the words need to be in order provided."
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "This is how I understand this task:\\n\\nIf the first word in the given array \"words\" is longer then second --- result will be false \\nThan we take letters of this words and find them in the given \"order\", if the index of the letter from the  first word is bigger than the letter index of the second word --- result will be false \\n(for example, we have the first letters from the first and the second word, we find index of this letters in the given \"order\" and compare this indexes, the index of the first word must be lower that index of the second, otherwise it will be false)\\n\\nYou can correct me if I\\'m wrong or add explanations to my answer. This task is really unclear, lol"
                    },
                    {
                        "username": "shubham_kamdi",
                        "content": "please move this to medium "
                    },
                    {
                        "username": "dieg0maci3l",
                        "content": "I don't think this is a medium problem, they just need to add a short list of \"lexicographical rules\" to make the statement more clear. They explain how the lexicographical rules work in the examples, but the statement can be improved for sure. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I would say this is an easy problem with a few edge cases where we need to be more careful"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Medium problems often take me over an hour, or I require hints, this took me 6 minuets and 44 seconds. Not sure why this would be medium?"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "[@aanand07](/aanand07) thanks i think this might be cause\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Let me check with the Men in Black."
                    },
                    {
                        "username": "aanand07",
                        "content": "IMO, in some cases input constraints determine the level of a problem.\\nOver here, words and words[i] max length is less, so it should be in easy category."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Took about 5 minutes to solve I don\\'t know what you\\'re talking about lol"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Definitely not an easy lol. Also they should say `alphabetical order` somewhere in the question because `lexicographic order` is just a weird term that causes confusion"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Somewhere Aliens are laughing..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Hard to be an alien nowadays :)"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "is my skill going down or the easy questions are getting difficult ?"
                    },
                    {
                        "username": "mohak0",
                        "content": "I believe that the question description should\\'ve explained the problem better. The current description is so vague that we\\'re expected to decipher the test cases and figure out what\\'s being asked.\\nMaybe a good problem for interviews where you can ask questions and clarify different test cases with the interviewer "
                    },
                    {
                        "username": "coolgal",
                        "content": "Why is following testcase returning true ?\\n\\n[\"kuvp\",\"q\"]\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\nIn example 3, it says if second string length is less then first string than return false?\\n\\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nOutput: false\\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because \\'l\\' > \\'\\u2205\\', where \\'\\u2205\\' is defined as the blank character which is less than any other character (More info)."
                    },
                    {
                        "username": "hridoy100",
                        "content": "condition should be: if word2 has more length and it is also a minimum length substring of word1."
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"abcdefghijklmnopqrstuvwxyz\"\norder.index(\"k\") \n=> 10\norder.index(\"q\") \n=> 16\nso \"k\" before \"q\" then ignore other later \nThe first letter has the highest importance"
                    },
                    {
                        "username": "arshde3p",
                        "content": "Hint: compare characters from left-to-right. See here q > k, so it will come after in the lexicographic order. In the apple-app example you\\'ll start from left \\n\\'a\\' == \\'a\\'\\n\\'p\\' == \\'p\\'\\n.\\n\\'l\\' > null\\nso \"apple\" is greater than \"app\" here hence result is false for that case.\\n\\nHere,\\n\\'k\\' < \\'q\\'\\nso break here itself rest characters doesn\\'t matter"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "[@srivastavashubham7984](/srivastavashubham7984)  I don\\'t think it is invalid. We compare \"kuvp\" to \"q\", which is equal to \"kuvp\" to \"q000\" where 0 is phi. since \"k\" < \"q\", this should return True. Its similar to \"ant\" < \"z\" in our modern lexicography. "
                    },
                    {
                        "username": "shantanu1405",
                        "content": "if you have seen a dictionary, there words are arranged lexicographical , there, ambulance comes before zebra, so we move from the first letter and check, if at any point, the letter of preceding word is alphabetically greater than the  letter of next word, then it is wrong.\\nin your case, k comes before q, so no need to check the next letters as the sequence is correct\\n\\n"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "\"apple\" > \"app\" is sorted by the length only because they both start with \"app\".\\nin the case with [\"kuvp\",\"q\"] \"k\" shows up sooner in the alphabet than \"q\" does, so even though \"kuvp\" is longer it is alphabetically first,\\njust like how \"apple\" comes alphabetically first before \"car\" in regular english  "
                    },
                    {
                        "username": "srivastavashubham7984",
                        "content": "[@ujjwal1234](/ujjwal1234)  Yes, this seems to be invalid test case. As per the example, output should be false."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "I am also facing the same problem\\n"
                    },
                    {
                        "username": "mhhs",
                        "content": "I think this one is a medium problem. It\\'s take a long time for me to grasp the concept clearly"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Hint: check next character only if current character is equal.\\n\\nThey should\\'ve mentioned it, i\\'m not sure how it is obvious"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "The second test case in the examples states in its explanation, \\'As \\'d\\' comes after \\'l\\' in this language\\' it should be obvious."
                    },
                    {
                        "username": "ayush_cmd",
                        "content": "it is obvio because this is how the real dictionary works"
                    },
                    {
                        "username": "aanand07",
                        "content": "Thanks for this tip!! \\uD83D\\uDD25 "
                    },
                    {
                        "username": "rohit__27",
                        "content": "it is .."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "![image](https://assets.leetcode.com/users/bluecode2017/image_1561259655.png)\\n"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@TornikePy](/TornikePy) \\nSo how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "TuringJest",
                        "content": "A simple way to understand this, is to picture a string\\'s lexicographic value as a float - where the first char is the integer part and the rest is the fractional part.\\n\\nh   l   a  b  c  d  e   f  g   i    j    k   m    n   o   p   q    r    s    t...\\n0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19...\\n\\nhello -> 0 6 1 1 14  -> 0 . 6 1 1 14\\nleetcode -> 1 6 6 19 4 14 5 6 -> 1 . 6 6 19 4 14 5 6\\n(let\\'s imagine the float it in base26, so that a letter can\\'t take up more than \"one decimal place\" or correct in base26 - a hexavigesimal place.)\\n\\nIt\\'s immediately clear that 1.6... > 0.6....\\n\\nPs. Don\\'t get confused about base26, it\\'s just there to make the float analogy mathematically correct. It\\'s not needed for the mental model or the code.\\n\\n"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\\norder.index(\"h\")\\n=> 0\\norder.index(\"l\")\\n=>  1\\nso \"h\" before \"l\" then ignore other later\\nThe first letter has the highest importance\\nis sored "
                    },
                    {
                        "username": "GKushi",
                        "content": "[@TornikePy](/TornikePy)  Thanks"
                    },
                    {
                        "username": "TornikePy",
                        "content": "we do not need to check more than first character, as H and L are different and L comes after H, so second word will come after first."
                    },
                    {
                        "username": "pradeep11",
                        "content": "Example 1:\\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nOutput: true\\n\\nthe 4th index position - char \\'o\\' comes after 4th index position of second word \\'c\\' . How it is sorted? It should return false?"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@Vaibhav_69](/Vaibhav_69) So how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "We are only checking the first character of the words in the string array, hence it is true as H<L in alien dictionary"
                    },
                    {
                        "username": "JohnCanessa",
                        "content": "Hello,\\nThe first test case uses the words \\'hello\\' and \\'leetcode\\' and the dictionary \\'hlabcdefgijkmnopqrstuvwxyz\\'.\\n\\'hello\\' = [0, 6, 1, 1, 14]\\n\\'leetcode\\' = [1, 6, 6, 19, 4, 14, 5, 6]\\n0 <= 1, 6 <= 6, 1 <= 6, 1 <= 19, 14 > 4\\n\\'hello\\' seems to be > \\'leetcode\\'.\\nThat seems to indicate that the result for the test case should be false.\\nCould someone set me straight?\\nThanks\\nJohn\\n\\n"
                    },
                    {
                        "username": "leddie24",
                        "content": "We\\'re not comparing the total \"value\" of each word. We stop as soon as we get to a comparison that isn\\'t equal.  For a non-alien dictionary (e.g: English) if we compare \"Apple\" to \"America\", \"America\" is sorted before apple, because we stop comparing after the second letter.  In the example, since \"h\" !== \"l\", we can stop the comparison after those letters. H has a lower index in the alien alphabet, so we consider \"hello\" < \"leetcode\"."
                    }
                ]
            },
            {
                "id": 1566979,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me :/"
                    },
                    {
                        "username": "urodoloh",
                        "content": "[@kseniiaprytkova](/kseniiaprytkova) oh god, i understood the problem only thanks to you. thanks"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Only aliens can understand it! ;)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# To clear up the confusion\\n\\nLexographic order = alphabetical order. Think about it like this: if you were to build a dictionary, which word would you put first?\\n\\nThis is why some apparently weird test cases like `[[\"kuvp\",\"q\"], \"ngxlkthsjuoqcpavbfdermiywz\"]` return true"
                    },
                    {
                        "username": "kseniiaprytkova",
                        "content": "Imagine a regular paper dictionary of your language. Where words are presented and their definitions. The words there are in alphabetical order. If the first letters of 2 words are the same, then we look at the second letters of 2 words (and so on) to decide which word will be first."
                    },
                    {
                        "username": "dapilk101",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) Good explanation. That is how I interpreted this problem too."
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova)  Basically , the words list is a dictionary (ex - oxford dictionary) and the order is provided (ranking of alphabets) , we need to check whether the dictionary is correct i.e. the words need to be in order provided."
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "This is how I understand this task:\\n\\nIf the first word in the given array \"words\" is longer then second --- result will be false \\nThan we take letters of this words and find them in the given \"order\", if the index of the letter from the  first word is bigger than the letter index of the second word --- result will be false \\n(for example, we have the first letters from the first and the second word, we find index of this letters in the given \"order\" and compare this indexes, the index of the first word must be lower that index of the second, otherwise it will be false)\\n\\nYou can correct me if I\\'m wrong or add explanations to my answer. This task is really unclear, lol"
                    },
                    {
                        "username": "shubham_kamdi",
                        "content": "please move this to medium "
                    },
                    {
                        "username": "dieg0maci3l",
                        "content": "I don't think this is a medium problem, they just need to add a short list of \"lexicographical rules\" to make the statement more clear. They explain how the lexicographical rules work in the examples, but the statement can be improved for sure. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I would say this is an easy problem with a few edge cases where we need to be more careful"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Medium problems often take me over an hour, or I require hints, this took me 6 minuets and 44 seconds. Not sure why this would be medium?"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "[@aanand07](/aanand07) thanks i think this might be cause\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Let me check with the Men in Black."
                    },
                    {
                        "username": "aanand07",
                        "content": "IMO, in some cases input constraints determine the level of a problem.\\nOver here, words and words[i] max length is less, so it should be in easy category."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Took about 5 minutes to solve I don\\'t know what you\\'re talking about lol"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Definitely not an easy lol. Also they should say `alphabetical order` somewhere in the question because `lexicographic order` is just a weird term that causes confusion"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Somewhere Aliens are laughing..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Hard to be an alien nowadays :)"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "is my skill going down or the easy questions are getting difficult ?"
                    },
                    {
                        "username": "mohak0",
                        "content": "I believe that the question description should\\'ve explained the problem better. The current description is so vague that we\\'re expected to decipher the test cases and figure out what\\'s being asked.\\nMaybe a good problem for interviews where you can ask questions and clarify different test cases with the interviewer "
                    },
                    {
                        "username": "coolgal",
                        "content": "Why is following testcase returning true ?\\n\\n[\"kuvp\",\"q\"]\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\nIn example 3, it says if second string length is less then first string than return false?\\n\\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nOutput: false\\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because \\'l\\' > \\'\\u2205\\', where \\'\\u2205\\' is defined as the blank character which is less than any other character (More info)."
                    },
                    {
                        "username": "hridoy100",
                        "content": "condition should be: if word2 has more length and it is also a minimum length substring of word1."
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"abcdefghijklmnopqrstuvwxyz\"\norder.index(\"k\") \n=> 10\norder.index(\"q\") \n=> 16\nso \"k\" before \"q\" then ignore other later \nThe first letter has the highest importance"
                    },
                    {
                        "username": "arshde3p",
                        "content": "Hint: compare characters from left-to-right. See here q > k, so it will come after in the lexicographic order. In the apple-app example you\\'ll start from left \\n\\'a\\' == \\'a\\'\\n\\'p\\' == \\'p\\'\\n.\\n\\'l\\' > null\\nso \"apple\" is greater than \"app\" here hence result is false for that case.\\n\\nHere,\\n\\'k\\' < \\'q\\'\\nso break here itself rest characters doesn\\'t matter"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "[@srivastavashubham7984](/srivastavashubham7984)  I don\\'t think it is invalid. We compare \"kuvp\" to \"q\", which is equal to \"kuvp\" to \"q000\" where 0 is phi. since \"k\" < \"q\", this should return True. Its similar to \"ant\" < \"z\" in our modern lexicography. "
                    },
                    {
                        "username": "shantanu1405",
                        "content": "if you have seen a dictionary, there words are arranged lexicographical , there, ambulance comes before zebra, so we move from the first letter and check, if at any point, the letter of preceding word is alphabetically greater than the  letter of next word, then it is wrong.\\nin your case, k comes before q, so no need to check the next letters as the sequence is correct\\n\\n"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "\"apple\" > \"app\" is sorted by the length only because they both start with \"app\".\\nin the case with [\"kuvp\",\"q\"] \"k\" shows up sooner in the alphabet than \"q\" does, so even though \"kuvp\" is longer it is alphabetically first,\\njust like how \"apple\" comes alphabetically first before \"car\" in regular english  "
                    },
                    {
                        "username": "srivastavashubham7984",
                        "content": "[@ujjwal1234](/ujjwal1234)  Yes, this seems to be invalid test case. As per the example, output should be false."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "I am also facing the same problem\\n"
                    },
                    {
                        "username": "mhhs",
                        "content": "I think this one is a medium problem. It\\'s take a long time for me to grasp the concept clearly"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Hint: check next character only if current character is equal.\\n\\nThey should\\'ve mentioned it, i\\'m not sure how it is obvious"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "The second test case in the examples states in its explanation, \\'As \\'d\\' comes after \\'l\\' in this language\\' it should be obvious."
                    },
                    {
                        "username": "ayush_cmd",
                        "content": "it is obvio because this is how the real dictionary works"
                    },
                    {
                        "username": "aanand07",
                        "content": "Thanks for this tip!! \\uD83D\\uDD25 "
                    },
                    {
                        "username": "rohit__27",
                        "content": "it is .."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "![image](https://assets.leetcode.com/users/bluecode2017/image_1561259655.png)\\n"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@TornikePy](/TornikePy) \\nSo how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "TuringJest",
                        "content": "A simple way to understand this, is to picture a string\\'s lexicographic value as a float - where the first char is the integer part and the rest is the fractional part.\\n\\nh   l   a  b  c  d  e   f  g   i    j    k   m    n   o   p   q    r    s    t...\\n0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19...\\n\\nhello -> 0 6 1 1 14  -> 0 . 6 1 1 14\\nleetcode -> 1 6 6 19 4 14 5 6 -> 1 . 6 6 19 4 14 5 6\\n(let\\'s imagine the float it in base26, so that a letter can\\'t take up more than \"one decimal place\" or correct in base26 - a hexavigesimal place.)\\n\\nIt\\'s immediately clear that 1.6... > 0.6....\\n\\nPs. Don\\'t get confused about base26, it\\'s just there to make the float analogy mathematically correct. It\\'s not needed for the mental model or the code.\\n\\n"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\\norder.index(\"h\")\\n=> 0\\norder.index(\"l\")\\n=>  1\\nso \"h\" before \"l\" then ignore other later\\nThe first letter has the highest importance\\nis sored "
                    },
                    {
                        "username": "GKushi",
                        "content": "[@TornikePy](/TornikePy)  Thanks"
                    },
                    {
                        "username": "TornikePy",
                        "content": "we do not need to check more than first character, as H and L are different and L comes after H, so second word will come after first."
                    },
                    {
                        "username": "pradeep11",
                        "content": "Example 1:\\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nOutput: true\\n\\nthe 4th index position - char \\'o\\' comes after 4th index position of second word \\'c\\' . How it is sorted? It should return false?"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@Vaibhav_69](/Vaibhav_69) So how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "We are only checking the first character of the words in the string array, hence it is true as H<L in alien dictionary"
                    },
                    {
                        "username": "JohnCanessa",
                        "content": "Hello,\\nThe first test case uses the words \\'hello\\' and \\'leetcode\\' and the dictionary \\'hlabcdefgijkmnopqrstuvwxyz\\'.\\n\\'hello\\' = [0, 6, 1, 1, 14]\\n\\'leetcode\\' = [1, 6, 6, 19, 4, 14, 5, 6]\\n0 <= 1, 6 <= 6, 1 <= 6, 1 <= 19, 14 > 4\\n\\'hello\\' seems to be > \\'leetcode\\'.\\nThat seems to indicate that the result for the test case should be false.\\nCould someone set me straight?\\nThanks\\nJohn\\n\\n"
                    },
                    {
                        "username": "leddie24",
                        "content": "We\\'re not comparing the total \"value\" of each word. We stop as soon as we get to a comparison that isn\\'t equal.  For a non-alien dictionary (e.g: English) if we compare \"Apple\" to \"America\", \"America\" is sorted before apple, because we stop comparing after the second letter.  In the example, since \"h\" !== \"l\", we can stop the comparison after those letters. H has a lower index in the alien alphabet, so we consider \"hello\" < \"leetcode\"."
                    }
                ]
            },
            {
                "id": 1730803,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me :/"
                    },
                    {
                        "username": "urodoloh",
                        "content": "[@kseniiaprytkova](/kseniiaprytkova) oh god, i understood the problem only thanks to you. thanks"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Only aliens can understand it! ;)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# To clear up the confusion\\n\\nLexographic order = alphabetical order. Think about it like this: if you were to build a dictionary, which word would you put first?\\n\\nThis is why some apparently weird test cases like `[[\"kuvp\",\"q\"], \"ngxlkthsjuoqcpavbfdermiywz\"]` return true"
                    },
                    {
                        "username": "kseniiaprytkova",
                        "content": "Imagine a regular paper dictionary of your language. Where words are presented and their definitions. The words there are in alphabetical order. If the first letters of 2 words are the same, then we look at the second letters of 2 words (and so on) to decide which word will be first."
                    },
                    {
                        "username": "dapilk101",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) Good explanation. That is how I interpreted this problem too."
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova)  Basically , the words list is a dictionary (ex - oxford dictionary) and the order is provided (ranking of alphabets) , we need to check whether the dictionary is correct i.e. the words need to be in order provided."
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "This is how I understand this task:\\n\\nIf the first word in the given array \"words\" is longer then second --- result will be false \\nThan we take letters of this words and find them in the given \"order\", if the index of the letter from the  first word is bigger than the letter index of the second word --- result will be false \\n(for example, we have the first letters from the first and the second word, we find index of this letters in the given \"order\" and compare this indexes, the index of the first word must be lower that index of the second, otherwise it will be false)\\n\\nYou can correct me if I\\'m wrong or add explanations to my answer. This task is really unclear, lol"
                    },
                    {
                        "username": "shubham_kamdi",
                        "content": "please move this to medium "
                    },
                    {
                        "username": "dieg0maci3l",
                        "content": "I don't think this is a medium problem, they just need to add a short list of \"lexicographical rules\" to make the statement more clear. They explain how the lexicographical rules work in the examples, but the statement can be improved for sure. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I would say this is an easy problem with a few edge cases where we need to be more careful"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Medium problems often take me over an hour, or I require hints, this took me 6 minuets and 44 seconds. Not sure why this would be medium?"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "[@aanand07](/aanand07) thanks i think this might be cause\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Let me check with the Men in Black."
                    },
                    {
                        "username": "aanand07",
                        "content": "IMO, in some cases input constraints determine the level of a problem.\\nOver here, words and words[i] max length is less, so it should be in easy category."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Took about 5 minutes to solve I don\\'t know what you\\'re talking about lol"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Definitely not an easy lol. Also they should say `alphabetical order` somewhere in the question because `lexicographic order` is just a weird term that causes confusion"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Somewhere Aliens are laughing..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Hard to be an alien nowadays :)"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "is my skill going down or the easy questions are getting difficult ?"
                    },
                    {
                        "username": "mohak0",
                        "content": "I believe that the question description should\\'ve explained the problem better. The current description is so vague that we\\'re expected to decipher the test cases and figure out what\\'s being asked.\\nMaybe a good problem for interviews where you can ask questions and clarify different test cases with the interviewer "
                    },
                    {
                        "username": "coolgal",
                        "content": "Why is following testcase returning true ?\\n\\n[\"kuvp\",\"q\"]\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\nIn example 3, it says if second string length is less then first string than return false?\\n\\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nOutput: false\\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because \\'l\\' > \\'\\u2205\\', where \\'\\u2205\\' is defined as the blank character which is less than any other character (More info)."
                    },
                    {
                        "username": "hridoy100",
                        "content": "condition should be: if word2 has more length and it is also a minimum length substring of word1."
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"abcdefghijklmnopqrstuvwxyz\"\norder.index(\"k\") \n=> 10\norder.index(\"q\") \n=> 16\nso \"k\" before \"q\" then ignore other later \nThe first letter has the highest importance"
                    },
                    {
                        "username": "arshde3p",
                        "content": "Hint: compare characters from left-to-right. See here q > k, so it will come after in the lexicographic order. In the apple-app example you\\'ll start from left \\n\\'a\\' == \\'a\\'\\n\\'p\\' == \\'p\\'\\n.\\n\\'l\\' > null\\nso \"apple\" is greater than \"app\" here hence result is false for that case.\\n\\nHere,\\n\\'k\\' < \\'q\\'\\nso break here itself rest characters doesn\\'t matter"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "[@srivastavashubham7984](/srivastavashubham7984)  I don\\'t think it is invalid. We compare \"kuvp\" to \"q\", which is equal to \"kuvp\" to \"q000\" where 0 is phi. since \"k\" < \"q\", this should return True. Its similar to \"ant\" < \"z\" in our modern lexicography. "
                    },
                    {
                        "username": "shantanu1405",
                        "content": "if you have seen a dictionary, there words are arranged lexicographical , there, ambulance comes before zebra, so we move from the first letter and check, if at any point, the letter of preceding word is alphabetically greater than the  letter of next word, then it is wrong.\\nin your case, k comes before q, so no need to check the next letters as the sequence is correct\\n\\n"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "\"apple\" > \"app\" is sorted by the length only because they both start with \"app\".\\nin the case with [\"kuvp\",\"q\"] \"k\" shows up sooner in the alphabet than \"q\" does, so even though \"kuvp\" is longer it is alphabetically first,\\njust like how \"apple\" comes alphabetically first before \"car\" in regular english  "
                    },
                    {
                        "username": "srivastavashubham7984",
                        "content": "[@ujjwal1234](/ujjwal1234)  Yes, this seems to be invalid test case. As per the example, output should be false."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "I am also facing the same problem\\n"
                    },
                    {
                        "username": "mhhs",
                        "content": "I think this one is a medium problem. It\\'s take a long time for me to grasp the concept clearly"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Hint: check next character only if current character is equal.\\n\\nThey should\\'ve mentioned it, i\\'m not sure how it is obvious"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "The second test case in the examples states in its explanation, \\'As \\'d\\' comes after \\'l\\' in this language\\' it should be obvious."
                    },
                    {
                        "username": "ayush_cmd",
                        "content": "it is obvio because this is how the real dictionary works"
                    },
                    {
                        "username": "aanand07",
                        "content": "Thanks for this tip!! \\uD83D\\uDD25 "
                    },
                    {
                        "username": "rohit__27",
                        "content": "it is .."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "![image](https://assets.leetcode.com/users/bluecode2017/image_1561259655.png)\\n"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@TornikePy](/TornikePy) \\nSo how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "TuringJest",
                        "content": "A simple way to understand this, is to picture a string\\'s lexicographic value as a float - where the first char is the integer part and the rest is the fractional part.\\n\\nh   l   a  b  c  d  e   f  g   i    j    k   m    n   o   p   q    r    s    t...\\n0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19...\\n\\nhello -> 0 6 1 1 14  -> 0 . 6 1 1 14\\nleetcode -> 1 6 6 19 4 14 5 6 -> 1 . 6 6 19 4 14 5 6\\n(let\\'s imagine the float it in base26, so that a letter can\\'t take up more than \"one decimal place\" or correct in base26 - a hexavigesimal place.)\\n\\nIt\\'s immediately clear that 1.6... > 0.6....\\n\\nPs. Don\\'t get confused about base26, it\\'s just there to make the float analogy mathematically correct. It\\'s not needed for the mental model or the code.\\n\\n"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\\norder.index(\"h\")\\n=> 0\\norder.index(\"l\")\\n=>  1\\nso \"h\" before \"l\" then ignore other later\\nThe first letter has the highest importance\\nis sored "
                    },
                    {
                        "username": "GKushi",
                        "content": "[@TornikePy](/TornikePy)  Thanks"
                    },
                    {
                        "username": "TornikePy",
                        "content": "we do not need to check more than first character, as H and L are different and L comes after H, so second word will come after first."
                    },
                    {
                        "username": "pradeep11",
                        "content": "Example 1:\\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nOutput: true\\n\\nthe 4th index position - char \\'o\\' comes after 4th index position of second word \\'c\\' . How it is sorted? It should return false?"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@Vaibhav_69](/Vaibhav_69) So how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "We are only checking the first character of the words in the string array, hence it is true as H<L in alien dictionary"
                    },
                    {
                        "username": "JohnCanessa",
                        "content": "Hello,\\nThe first test case uses the words \\'hello\\' and \\'leetcode\\' and the dictionary \\'hlabcdefgijkmnopqrstuvwxyz\\'.\\n\\'hello\\' = [0, 6, 1, 1, 14]\\n\\'leetcode\\' = [1, 6, 6, 19, 4, 14, 5, 6]\\n0 <= 1, 6 <= 6, 1 <= 6, 1 <= 19, 14 > 4\\n\\'hello\\' seems to be > \\'leetcode\\'.\\nThat seems to indicate that the result for the test case should be false.\\nCould someone set me straight?\\nThanks\\nJohn\\n\\n"
                    },
                    {
                        "username": "leddie24",
                        "content": "We\\'re not comparing the total \"value\" of each word. We stop as soon as we get to a comparison that isn\\'t equal.  For a non-alien dictionary (e.g: English) if we compare \"Apple\" to \"America\", \"America\" is sorted before apple, because we stop comparing after the second letter.  In the example, since \"h\" !== \"l\", we can stop the comparison after those letters. H has a lower index in the alien alphabet, so we consider \"hello\" < \"leetcode\"."
                    }
                ]
            },
            {
                "id": 1784438,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me :/"
                    },
                    {
                        "username": "urodoloh",
                        "content": "[@kseniiaprytkova](/kseniiaprytkova) oh god, i understood the problem only thanks to you. thanks"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Only aliens can understand it! ;)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# To clear up the confusion\\n\\nLexographic order = alphabetical order. Think about it like this: if you were to build a dictionary, which word would you put first?\\n\\nThis is why some apparently weird test cases like `[[\"kuvp\",\"q\"], \"ngxlkthsjuoqcpavbfdermiywz\"]` return true"
                    },
                    {
                        "username": "kseniiaprytkova",
                        "content": "Imagine a regular paper dictionary of your language. Where words are presented and their definitions. The words there are in alphabetical order. If the first letters of 2 words are the same, then we look at the second letters of 2 words (and so on) to decide which word will be first."
                    },
                    {
                        "username": "dapilk101",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) Good explanation. That is how I interpreted this problem too."
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova)  Basically , the words list is a dictionary (ex - oxford dictionary) and the order is provided (ranking of alphabets) , we need to check whether the dictionary is correct i.e. the words need to be in order provided."
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "This is how I understand this task:\\n\\nIf the first word in the given array \"words\" is longer then second --- result will be false \\nThan we take letters of this words and find them in the given \"order\", if the index of the letter from the  first word is bigger than the letter index of the second word --- result will be false \\n(for example, we have the first letters from the first and the second word, we find index of this letters in the given \"order\" and compare this indexes, the index of the first word must be lower that index of the second, otherwise it will be false)\\n\\nYou can correct me if I\\'m wrong or add explanations to my answer. This task is really unclear, lol"
                    },
                    {
                        "username": "shubham_kamdi",
                        "content": "please move this to medium "
                    },
                    {
                        "username": "dieg0maci3l",
                        "content": "I don't think this is a medium problem, they just need to add a short list of \"lexicographical rules\" to make the statement more clear. They explain how the lexicographical rules work in the examples, but the statement can be improved for sure. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I would say this is an easy problem with a few edge cases where we need to be more careful"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Medium problems often take me over an hour, or I require hints, this took me 6 minuets and 44 seconds. Not sure why this would be medium?"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "[@aanand07](/aanand07) thanks i think this might be cause\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Let me check with the Men in Black."
                    },
                    {
                        "username": "aanand07",
                        "content": "IMO, in some cases input constraints determine the level of a problem.\\nOver here, words and words[i] max length is less, so it should be in easy category."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Took about 5 minutes to solve I don\\'t know what you\\'re talking about lol"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Definitely not an easy lol. Also they should say `alphabetical order` somewhere in the question because `lexicographic order` is just a weird term that causes confusion"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Somewhere Aliens are laughing..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Hard to be an alien nowadays :)"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "is my skill going down or the easy questions are getting difficult ?"
                    },
                    {
                        "username": "mohak0",
                        "content": "I believe that the question description should\\'ve explained the problem better. The current description is so vague that we\\'re expected to decipher the test cases and figure out what\\'s being asked.\\nMaybe a good problem for interviews where you can ask questions and clarify different test cases with the interviewer "
                    },
                    {
                        "username": "coolgal",
                        "content": "Why is following testcase returning true ?\\n\\n[\"kuvp\",\"q\"]\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\nIn example 3, it says if second string length is less then first string than return false?\\n\\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nOutput: false\\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because \\'l\\' > \\'\\u2205\\', where \\'\\u2205\\' is defined as the blank character which is less than any other character (More info)."
                    },
                    {
                        "username": "hridoy100",
                        "content": "condition should be: if word2 has more length and it is also a minimum length substring of word1."
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"abcdefghijklmnopqrstuvwxyz\"\norder.index(\"k\") \n=> 10\norder.index(\"q\") \n=> 16\nso \"k\" before \"q\" then ignore other later \nThe first letter has the highest importance"
                    },
                    {
                        "username": "arshde3p",
                        "content": "Hint: compare characters from left-to-right. See here q > k, so it will come after in the lexicographic order. In the apple-app example you\\'ll start from left \\n\\'a\\' == \\'a\\'\\n\\'p\\' == \\'p\\'\\n.\\n\\'l\\' > null\\nso \"apple\" is greater than \"app\" here hence result is false for that case.\\n\\nHere,\\n\\'k\\' < \\'q\\'\\nso break here itself rest characters doesn\\'t matter"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "[@srivastavashubham7984](/srivastavashubham7984)  I don\\'t think it is invalid. We compare \"kuvp\" to \"q\", which is equal to \"kuvp\" to \"q000\" where 0 is phi. since \"k\" < \"q\", this should return True. Its similar to \"ant\" < \"z\" in our modern lexicography. "
                    },
                    {
                        "username": "shantanu1405",
                        "content": "if you have seen a dictionary, there words are arranged lexicographical , there, ambulance comes before zebra, so we move from the first letter and check, if at any point, the letter of preceding word is alphabetically greater than the  letter of next word, then it is wrong.\\nin your case, k comes before q, so no need to check the next letters as the sequence is correct\\n\\n"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "\"apple\" > \"app\" is sorted by the length only because they both start with \"app\".\\nin the case with [\"kuvp\",\"q\"] \"k\" shows up sooner in the alphabet than \"q\" does, so even though \"kuvp\" is longer it is alphabetically first,\\njust like how \"apple\" comes alphabetically first before \"car\" in regular english  "
                    },
                    {
                        "username": "srivastavashubham7984",
                        "content": "[@ujjwal1234](/ujjwal1234)  Yes, this seems to be invalid test case. As per the example, output should be false."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "I am also facing the same problem\\n"
                    },
                    {
                        "username": "mhhs",
                        "content": "I think this one is a medium problem. It\\'s take a long time for me to grasp the concept clearly"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Hint: check next character only if current character is equal.\\n\\nThey should\\'ve mentioned it, i\\'m not sure how it is obvious"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "The second test case in the examples states in its explanation, \\'As \\'d\\' comes after \\'l\\' in this language\\' it should be obvious."
                    },
                    {
                        "username": "ayush_cmd",
                        "content": "it is obvio because this is how the real dictionary works"
                    },
                    {
                        "username": "aanand07",
                        "content": "Thanks for this tip!! \\uD83D\\uDD25 "
                    },
                    {
                        "username": "rohit__27",
                        "content": "it is .."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "![image](https://assets.leetcode.com/users/bluecode2017/image_1561259655.png)\\n"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@TornikePy](/TornikePy) \\nSo how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "TuringJest",
                        "content": "A simple way to understand this, is to picture a string\\'s lexicographic value as a float - where the first char is the integer part and the rest is the fractional part.\\n\\nh   l   a  b  c  d  e   f  g   i    j    k   m    n   o   p   q    r    s    t...\\n0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19...\\n\\nhello -> 0 6 1 1 14  -> 0 . 6 1 1 14\\nleetcode -> 1 6 6 19 4 14 5 6 -> 1 . 6 6 19 4 14 5 6\\n(let\\'s imagine the float it in base26, so that a letter can\\'t take up more than \"one decimal place\" or correct in base26 - a hexavigesimal place.)\\n\\nIt\\'s immediately clear that 1.6... > 0.6....\\n\\nPs. Don\\'t get confused about base26, it\\'s just there to make the float analogy mathematically correct. It\\'s not needed for the mental model or the code.\\n\\n"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\\norder.index(\"h\")\\n=> 0\\norder.index(\"l\")\\n=>  1\\nso \"h\" before \"l\" then ignore other later\\nThe first letter has the highest importance\\nis sored "
                    },
                    {
                        "username": "GKushi",
                        "content": "[@TornikePy](/TornikePy)  Thanks"
                    },
                    {
                        "username": "TornikePy",
                        "content": "we do not need to check more than first character, as H and L are different and L comes after H, so second word will come after first."
                    },
                    {
                        "username": "pradeep11",
                        "content": "Example 1:\\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nOutput: true\\n\\nthe 4th index position - char \\'o\\' comes after 4th index position of second word \\'c\\' . How it is sorted? It should return false?"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@Vaibhav_69](/Vaibhav_69) So how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "We are only checking the first character of the words in the string array, hence it is true as H<L in alien dictionary"
                    },
                    {
                        "username": "JohnCanessa",
                        "content": "Hello,\\nThe first test case uses the words \\'hello\\' and \\'leetcode\\' and the dictionary \\'hlabcdefgijkmnopqrstuvwxyz\\'.\\n\\'hello\\' = [0, 6, 1, 1, 14]\\n\\'leetcode\\' = [1, 6, 6, 19, 4, 14, 5, 6]\\n0 <= 1, 6 <= 6, 1 <= 6, 1 <= 19, 14 > 4\\n\\'hello\\' seems to be > \\'leetcode\\'.\\nThat seems to indicate that the result for the test case should be false.\\nCould someone set me straight?\\nThanks\\nJohn\\n\\n"
                    },
                    {
                        "username": "leddie24",
                        "content": "We\\'re not comparing the total \"value\" of each word. We stop as soon as we get to a comparison that isn\\'t equal.  For a non-alien dictionary (e.g: English) if we compare \"Apple\" to \"America\", \"America\" is sorted before apple, because we stop comparing after the second letter.  In the example, since \"h\" !== \"l\", we can stop the comparison after those letters. H has a lower index in the alien alphabet, so we consider \"hello\" < \"leetcode\"."
                    }
                ]
            },
            {
                "id": 1784797,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me :/"
                    },
                    {
                        "username": "urodoloh",
                        "content": "[@kseniiaprytkova](/kseniiaprytkova) oh god, i understood the problem only thanks to you. thanks"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Only aliens can understand it! ;)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# To clear up the confusion\\n\\nLexographic order = alphabetical order. Think about it like this: if you were to build a dictionary, which word would you put first?\\n\\nThis is why some apparently weird test cases like `[[\"kuvp\",\"q\"], \"ngxlkthsjuoqcpavbfdermiywz\"]` return true"
                    },
                    {
                        "username": "kseniiaprytkova",
                        "content": "Imagine a regular paper dictionary of your language. Where words are presented and their definitions. The words there are in alphabetical order. If the first letters of 2 words are the same, then we look at the second letters of 2 words (and so on) to decide which word will be first."
                    },
                    {
                        "username": "dapilk101",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) Good explanation. That is how I interpreted this problem too."
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova)  Basically , the words list is a dictionary (ex - oxford dictionary) and the order is provided (ranking of alphabets) , we need to check whether the dictionary is correct i.e. the words need to be in order provided."
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "This is how I understand this task:\\n\\nIf the first word in the given array \"words\" is longer then second --- result will be false \\nThan we take letters of this words and find them in the given \"order\", if the index of the letter from the  first word is bigger than the letter index of the second word --- result will be false \\n(for example, we have the first letters from the first and the second word, we find index of this letters in the given \"order\" and compare this indexes, the index of the first word must be lower that index of the second, otherwise it will be false)\\n\\nYou can correct me if I\\'m wrong or add explanations to my answer. This task is really unclear, lol"
                    },
                    {
                        "username": "shubham_kamdi",
                        "content": "please move this to medium "
                    },
                    {
                        "username": "dieg0maci3l",
                        "content": "I don't think this is a medium problem, they just need to add a short list of \"lexicographical rules\" to make the statement more clear. They explain how the lexicographical rules work in the examples, but the statement can be improved for sure. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I would say this is an easy problem with a few edge cases where we need to be more careful"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Medium problems often take me over an hour, or I require hints, this took me 6 minuets and 44 seconds. Not sure why this would be medium?"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "[@aanand07](/aanand07) thanks i think this might be cause\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Let me check with the Men in Black."
                    },
                    {
                        "username": "aanand07",
                        "content": "IMO, in some cases input constraints determine the level of a problem.\\nOver here, words and words[i] max length is less, so it should be in easy category."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Took about 5 minutes to solve I don\\'t know what you\\'re talking about lol"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Definitely not an easy lol. Also they should say `alphabetical order` somewhere in the question because `lexicographic order` is just a weird term that causes confusion"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Somewhere Aliens are laughing..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Hard to be an alien nowadays :)"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "is my skill going down or the easy questions are getting difficult ?"
                    },
                    {
                        "username": "mohak0",
                        "content": "I believe that the question description should\\'ve explained the problem better. The current description is so vague that we\\'re expected to decipher the test cases and figure out what\\'s being asked.\\nMaybe a good problem for interviews where you can ask questions and clarify different test cases with the interviewer "
                    },
                    {
                        "username": "coolgal",
                        "content": "Why is following testcase returning true ?\\n\\n[\"kuvp\",\"q\"]\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\nIn example 3, it says if second string length is less then first string than return false?\\n\\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nOutput: false\\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because \\'l\\' > \\'\\u2205\\', where \\'\\u2205\\' is defined as the blank character which is less than any other character (More info)."
                    },
                    {
                        "username": "hridoy100",
                        "content": "condition should be: if word2 has more length and it is also a minimum length substring of word1."
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"abcdefghijklmnopqrstuvwxyz\"\norder.index(\"k\") \n=> 10\norder.index(\"q\") \n=> 16\nso \"k\" before \"q\" then ignore other later \nThe first letter has the highest importance"
                    },
                    {
                        "username": "arshde3p",
                        "content": "Hint: compare characters from left-to-right. See here q > k, so it will come after in the lexicographic order. In the apple-app example you\\'ll start from left \\n\\'a\\' == \\'a\\'\\n\\'p\\' == \\'p\\'\\n.\\n\\'l\\' > null\\nso \"apple\" is greater than \"app\" here hence result is false for that case.\\n\\nHere,\\n\\'k\\' < \\'q\\'\\nso break here itself rest characters doesn\\'t matter"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "[@srivastavashubham7984](/srivastavashubham7984)  I don\\'t think it is invalid. We compare \"kuvp\" to \"q\", which is equal to \"kuvp\" to \"q000\" where 0 is phi. since \"k\" < \"q\", this should return True. Its similar to \"ant\" < \"z\" in our modern lexicography. "
                    },
                    {
                        "username": "shantanu1405",
                        "content": "if you have seen a dictionary, there words are arranged lexicographical , there, ambulance comes before zebra, so we move from the first letter and check, if at any point, the letter of preceding word is alphabetically greater than the  letter of next word, then it is wrong.\\nin your case, k comes before q, so no need to check the next letters as the sequence is correct\\n\\n"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "\"apple\" > \"app\" is sorted by the length only because they both start with \"app\".\\nin the case with [\"kuvp\",\"q\"] \"k\" shows up sooner in the alphabet than \"q\" does, so even though \"kuvp\" is longer it is alphabetically first,\\njust like how \"apple\" comes alphabetically first before \"car\" in regular english  "
                    },
                    {
                        "username": "srivastavashubham7984",
                        "content": "[@ujjwal1234](/ujjwal1234)  Yes, this seems to be invalid test case. As per the example, output should be false."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "I am also facing the same problem\\n"
                    },
                    {
                        "username": "mhhs",
                        "content": "I think this one is a medium problem. It\\'s take a long time for me to grasp the concept clearly"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Hint: check next character only if current character is equal.\\n\\nThey should\\'ve mentioned it, i\\'m not sure how it is obvious"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "The second test case in the examples states in its explanation, \\'As \\'d\\' comes after \\'l\\' in this language\\' it should be obvious."
                    },
                    {
                        "username": "ayush_cmd",
                        "content": "it is obvio because this is how the real dictionary works"
                    },
                    {
                        "username": "aanand07",
                        "content": "Thanks for this tip!! \\uD83D\\uDD25 "
                    },
                    {
                        "username": "rohit__27",
                        "content": "it is .."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "![image](https://assets.leetcode.com/users/bluecode2017/image_1561259655.png)\\n"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@TornikePy](/TornikePy) \\nSo how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "TuringJest",
                        "content": "A simple way to understand this, is to picture a string\\'s lexicographic value as a float - where the first char is the integer part and the rest is the fractional part.\\n\\nh   l   a  b  c  d  e   f  g   i    j    k   m    n   o   p   q    r    s    t...\\n0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19...\\n\\nhello -> 0 6 1 1 14  -> 0 . 6 1 1 14\\nleetcode -> 1 6 6 19 4 14 5 6 -> 1 . 6 6 19 4 14 5 6\\n(let\\'s imagine the float it in base26, so that a letter can\\'t take up more than \"one decimal place\" or correct in base26 - a hexavigesimal place.)\\n\\nIt\\'s immediately clear that 1.6... > 0.6....\\n\\nPs. Don\\'t get confused about base26, it\\'s just there to make the float analogy mathematically correct. It\\'s not needed for the mental model or the code.\\n\\n"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\\norder.index(\"h\")\\n=> 0\\norder.index(\"l\")\\n=>  1\\nso \"h\" before \"l\" then ignore other later\\nThe first letter has the highest importance\\nis sored "
                    },
                    {
                        "username": "GKushi",
                        "content": "[@TornikePy](/TornikePy)  Thanks"
                    },
                    {
                        "username": "TornikePy",
                        "content": "we do not need to check more than first character, as H and L are different and L comes after H, so second word will come after first."
                    },
                    {
                        "username": "pradeep11",
                        "content": "Example 1:\\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nOutput: true\\n\\nthe 4th index position - char \\'o\\' comes after 4th index position of second word \\'c\\' . How it is sorted? It should return false?"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@Vaibhav_69](/Vaibhav_69) So how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "We are only checking the first character of the words in the string array, hence it is true as H<L in alien dictionary"
                    },
                    {
                        "username": "JohnCanessa",
                        "content": "Hello,\\nThe first test case uses the words \\'hello\\' and \\'leetcode\\' and the dictionary \\'hlabcdefgijkmnopqrstuvwxyz\\'.\\n\\'hello\\' = [0, 6, 1, 1, 14]\\n\\'leetcode\\' = [1, 6, 6, 19, 4, 14, 5, 6]\\n0 <= 1, 6 <= 6, 1 <= 6, 1 <= 19, 14 > 4\\n\\'hello\\' seems to be > \\'leetcode\\'.\\nThat seems to indicate that the result for the test case should be false.\\nCould someone set me straight?\\nThanks\\nJohn\\n\\n"
                    },
                    {
                        "username": "leddie24",
                        "content": "We\\'re not comparing the total \"value\" of each word. We stop as soon as we get to a comparison that isn\\'t equal.  For a non-alien dictionary (e.g: English) if we compare \"Apple\" to \"America\", \"America\" is sorted before apple, because we stop comparing after the second letter.  In the example, since \"h\" !== \"l\", we can stop the comparison after those letters. H has a lower index in the alien alphabet, so we consider \"hello\" < \"leetcode\"."
                    }
                ]
            },
            {
                "id": 1569578,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me :/"
                    },
                    {
                        "username": "urodoloh",
                        "content": "[@kseniiaprytkova](/kseniiaprytkova) oh god, i understood the problem only thanks to you. thanks"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Only aliens can understand it! ;)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# To clear up the confusion\\n\\nLexographic order = alphabetical order. Think about it like this: if you were to build a dictionary, which word would you put first?\\n\\nThis is why some apparently weird test cases like `[[\"kuvp\",\"q\"], \"ngxlkthsjuoqcpavbfdermiywz\"]` return true"
                    },
                    {
                        "username": "kseniiaprytkova",
                        "content": "Imagine a regular paper dictionary of your language. Where words are presented and their definitions. The words there are in alphabetical order. If the first letters of 2 words are the same, then we look at the second letters of 2 words (and so on) to decide which word will be first."
                    },
                    {
                        "username": "dapilk101",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) Good explanation. That is how I interpreted this problem too."
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova)  Basically , the words list is a dictionary (ex - oxford dictionary) and the order is provided (ranking of alphabets) , we need to check whether the dictionary is correct i.e. the words need to be in order provided."
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "This is how I understand this task:\\n\\nIf the first word in the given array \"words\" is longer then second --- result will be false \\nThan we take letters of this words and find them in the given \"order\", if the index of the letter from the  first word is bigger than the letter index of the second word --- result will be false \\n(for example, we have the first letters from the first and the second word, we find index of this letters in the given \"order\" and compare this indexes, the index of the first word must be lower that index of the second, otherwise it will be false)\\n\\nYou can correct me if I\\'m wrong or add explanations to my answer. This task is really unclear, lol"
                    },
                    {
                        "username": "shubham_kamdi",
                        "content": "please move this to medium "
                    },
                    {
                        "username": "dieg0maci3l",
                        "content": "I don't think this is a medium problem, they just need to add a short list of \"lexicographical rules\" to make the statement more clear. They explain how the lexicographical rules work in the examples, but the statement can be improved for sure. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I would say this is an easy problem with a few edge cases where we need to be more careful"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Medium problems often take me over an hour, or I require hints, this took me 6 minuets and 44 seconds. Not sure why this would be medium?"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "[@aanand07](/aanand07) thanks i think this might be cause\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Let me check with the Men in Black."
                    },
                    {
                        "username": "aanand07",
                        "content": "IMO, in some cases input constraints determine the level of a problem.\\nOver here, words and words[i] max length is less, so it should be in easy category."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Took about 5 minutes to solve I don\\'t know what you\\'re talking about lol"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Definitely not an easy lol. Also they should say `alphabetical order` somewhere in the question because `lexicographic order` is just a weird term that causes confusion"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Somewhere Aliens are laughing..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Hard to be an alien nowadays :)"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "is my skill going down or the easy questions are getting difficult ?"
                    },
                    {
                        "username": "mohak0",
                        "content": "I believe that the question description should\\'ve explained the problem better. The current description is so vague that we\\'re expected to decipher the test cases and figure out what\\'s being asked.\\nMaybe a good problem for interviews where you can ask questions and clarify different test cases with the interviewer "
                    },
                    {
                        "username": "coolgal",
                        "content": "Why is following testcase returning true ?\\n\\n[\"kuvp\",\"q\"]\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\nIn example 3, it says if second string length is less then first string than return false?\\n\\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nOutput: false\\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because \\'l\\' > \\'\\u2205\\', where \\'\\u2205\\' is defined as the blank character which is less than any other character (More info)."
                    },
                    {
                        "username": "hridoy100",
                        "content": "condition should be: if word2 has more length and it is also a minimum length substring of word1."
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"abcdefghijklmnopqrstuvwxyz\"\norder.index(\"k\") \n=> 10\norder.index(\"q\") \n=> 16\nso \"k\" before \"q\" then ignore other later \nThe first letter has the highest importance"
                    },
                    {
                        "username": "arshde3p",
                        "content": "Hint: compare characters from left-to-right. See here q > k, so it will come after in the lexicographic order. In the apple-app example you\\'ll start from left \\n\\'a\\' == \\'a\\'\\n\\'p\\' == \\'p\\'\\n.\\n\\'l\\' > null\\nso \"apple\" is greater than \"app\" here hence result is false for that case.\\n\\nHere,\\n\\'k\\' < \\'q\\'\\nso break here itself rest characters doesn\\'t matter"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "[@srivastavashubham7984](/srivastavashubham7984)  I don\\'t think it is invalid. We compare \"kuvp\" to \"q\", which is equal to \"kuvp\" to \"q000\" where 0 is phi. since \"k\" < \"q\", this should return True. Its similar to \"ant\" < \"z\" in our modern lexicography. "
                    },
                    {
                        "username": "shantanu1405",
                        "content": "if you have seen a dictionary, there words are arranged lexicographical , there, ambulance comes before zebra, so we move from the first letter and check, if at any point, the letter of preceding word is alphabetically greater than the  letter of next word, then it is wrong.\\nin your case, k comes before q, so no need to check the next letters as the sequence is correct\\n\\n"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "\"apple\" > \"app\" is sorted by the length only because they both start with \"app\".\\nin the case with [\"kuvp\",\"q\"] \"k\" shows up sooner in the alphabet than \"q\" does, so even though \"kuvp\" is longer it is alphabetically first,\\njust like how \"apple\" comes alphabetically first before \"car\" in regular english  "
                    },
                    {
                        "username": "srivastavashubham7984",
                        "content": "[@ujjwal1234](/ujjwal1234)  Yes, this seems to be invalid test case. As per the example, output should be false."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "I am also facing the same problem\\n"
                    },
                    {
                        "username": "mhhs",
                        "content": "I think this one is a medium problem. It\\'s take a long time for me to grasp the concept clearly"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Hint: check next character only if current character is equal.\\n\\nThey should\\'ve mentioned it, i\\'m not sure how it is obvious"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "The second test case in the examples states in its explanation, \\'As \\'d\\' comes after \\'l\\' in this language\\' it should be obvious."
                    },
                    {
                        "username": "ayush_cmd",
                        "content": "it is obvio because this is how the real dictionary works"
                    },
                    {
                        "username": "aanand07",
                        "content": "Thanks for this tip!! \\uD83D\\uDD25 "
                    },
                    {
                        "username": "rohit__27",
                        "content": "it is .."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "![image](https://assets.leetcode.com/users/bluecode2017/image_1561259655.png)\\n"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@TornikePy](/TornikePy) \\nSo how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "TuringJest",
                        "content": "A simple way to understand this, is to picture a string\\'s lexicographic value as a float - where the first char is the integer part and the rest is the fractional part.\\n\\nh   l   a  b  c  d  e   f  g   i    j    k   m    n   o   p   q    r    s    t...\\n0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19...\\n\\nhello -> 0 6 1 1 14  -> 0 . 6 1 1 14\\nleetcode -> 1 6 6 19 4 14 5 6 -> 1 . 6 6 19 4 14 5 6\\n(let\\'s imagine the float it in base26, so that a letter can\\'t take up more than \"one decimal place\" or correct in base26 - a hexavigesimal place.)\\n\\nIt\\'s immediately clear that 1.6... > 0.6....\\n\\nPs. Don\\'t get confused about base26, it\\'s just there to make the float analogy mathematically correct. It\\'s not needed for the mental model or the code.\\n\\n"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\\norder.index(\"h\")\\n=> 0\\norder.index(\"l\")\\n=>  1\\nso \"h\" before \"l\" then ignore other later\\nThe first letter has the highest importance\\nis sored "
                    },
                    {
                        "username": "GKushi",
                        "content": "[@TornikePy](/TornikePy)  Thanks"
                    },
                    {
                        "username": "TornikePy",
                        "content": "we do not need to check more than first character, as H and L are different and L comes after H, so second word will come after first."
                    },
                    {
                        "username": "pradeep11",
                        "content": "Example 1:\\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nOutput: true\\n\\nthe 4th index position - char \\'o\\' comes after 4th index position of second word \\'c\\' . How it is sorted? It should return false?"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@Vaibhav_69](/Vaibhav_69) So how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "We are only checking the first character of the words in the string array, hence it is true as H<L in alien dictionary"
                    },
                    {
                        "username": "JohnCanessa",
                        "content": "Hello,\\nThe first test case uses the words \\'hello\\' and \\'leetcode\\' and the dictionary \\'hlabcdefgijkmnopqrstuvwxyz\\'.\\n\\'hello\\' = [0, 6, 1, 1, 14]\\n\\'leetcode\\' = [1, 6, 6, 19, 4, 14, 5, 6]\\n0 <= 1, 6 <= 6, 1 <= 6, 1 <= 19, 14 > 4\\n\\'hello\\' seems to be > \\'leetcode\\'.\\nThat seems to indicate that the result for the test case should be false.\\nCould someone set me straight?\\nThanks\\nJohn\\n\\n"
                    },
                    {
                        "username": "leddie24",
                        "content": "We\\'re not comparing the total \"value\" of each word. We stop as soon as we get to a comparison that isn\\'t equal.  For a non-alien dictionary (e.g: English) if we compare \"Apple\" to \"America\", \"America\" is sorted before apple, because we stop comparing after the second letter.  In the example, since \"h\" !== \"l\", we can stop the comparison after those letters. H has a lower index in the alien alphabet, so we consider \"hello\" < \"leetcode\"."
                    }
                ]
            },
            {
                "id": 1734339,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me :/"
                    },
                    {
                        "username": "urodoloh",
                        "content": "[@kseniiaprytkova](/kseniiaprytkova) oh god, i understood the problem only thanks to you. thanks"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Only aliens can understand it! ;)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# To clear up the confusion\\n\\nLexographic order = alphabetical order. Think about it like this: if you were to build a dictionary, which word would you put first?\\n\\nThis is why some apparently weird test cases like `[[\"kuvp\",\"q\"], \"ngxlkthsjuoqcpavbfdermiywz\"]` return true"
                    },
                    {
                        "username": "kseniiaprytkova",
                        "content": "Imagine a regular paper dictionary of your language. Where words are presented and their definitions. The words there are in alphabetical order. If the first letters of 2 words are the same, then we look at the second letters of 2 words (and so on) to decide which word will be first."
                    },
                    {
                        "username": "dapilk101",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) Good explanation. That is how I interpreted this problem too."
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova)  Basically , the words list is a dictionary (ex - oxford dictionary) and the order is provided (ranking of alphabets) , we need to check whether the dictionary is correct i.e. the words need to be in order provided."
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "This is how I understand this task:\\n\\nIf the first word in the given array \"words\" is longer then second --- result will be false \\nThan we take letters of this words and find them in the given \"order\", if the index of the letter from the  first word is bigger than the letter index of the second word --- result will be false \\n(for example, we have the first letters from the first and the second word, we find index of this letters in the given \"order\" and compare this indexes, the index of the first word must be lower that index of the second, otherwise it will be false)\\n\\nYou can correct me if I\\'m wrong or add explanations to my answer. This task is really unclear, lol"
                    },
                    {
                        "username": "shubham_kamdi",
                        "content": "please move this to medium "
                    },
                    {
                        "username": "dieg0maci3l",
                        "content": "I don't think this is a medium problem, they just need to add a short list of \"lexicographical rules\" to make the statement more clear. They explain how the lexicographical rules work in the examples, but the statement can be improved for sure. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I would say this is an easy problem with a few edge cases where we need to be more careful"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Medium problems often take me over an hour, or I require hints, this took me 6 minuets and 44 seconds. Not sure why this would be medium?"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "[@aanand07](/aanand07) thanks i think this might be cause\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Let me check with the Men in Black."
                    },
                    {
                        "username": "aanand07",
                        "content": "IMO, in some cases input constraints determine the level of a problem.\\nOver here, words and words[i] max length is less, so it should be in easy category."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Took about 5 minutes to solve I don\\'t know what you\\'re talking about lol"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Definitely not an easy lol. Also they should say `alphabetical order` somewhere in the question because `lexicographic order` is just a weird term that causes confusion"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Somewhere Aliens are laughing..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Hard to be an alien nowadays :)"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "is my skill going down or the easy questions are getting difficult ?"
                    },
                    {
                        "username": "mohak0",
                        "content": "I believe that the question description should\\'ve explained the problem better. The current description is so vague that we\\'re expected to decipher the test cases and figure out what\\'s being asked.\\nMaybe a good problem for interviews where you can ask questions and clarify different test cases with the interviewer "
                    },
                    {
                        "username": "coolgal",
                        "content": "Why is following testcase returning true ?\\n\\n[\"kuvp\",\"q\"]\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\nIn example 3, it says if second string length is less then first string than return false?\\n\\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nOutput: false\\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because \\'l\\' > \\'\\u2205\\', where \\'\\u2205\\' is defined as the blank character which is less than any other character (More info)."
                    },
                    {
                        "username": "hridoy100",
                        "content": "condition should be: if word2 has more length and it is also a minimum length substring of word1."
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"abcdefghijklmnopqrstuvwxyz\"\norder.index(\"k\") \n=> 10\norder.index(\"q\") \n=> 16\nso \"k\" before \"q\" then ignore other later \nThe first letter has the highest importance"
                    },
                    {
                        "username": "arshde3p",
                        "content": "Hint: compare characters from left-to-right. See here q > k, so it will come after in the lexicographic order. In the apple-app example you\\'ll start from left \\n\\'a\\' == \\'a\\'\\n\\'p\\' == \\'p\\'\\n.\\n\\'l\\' > null\\nso \"apple\" is greater than \"app\" here hence result is false for that case.\\n\\nHere,\\n\\'k\\' < \\'q\\'\\nso break here itself rest characters doesn\\'t matter"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "[@srivastavashubham7984](/srivastavashubham7984)  I don\\'t think it is invalid. We compare \"kuvp\" to \"q\", which is equal to \"kuvp\" to \"q000\" where 0 is phi. since \"k\" < \"q\", this should return True. Its similar to \"ant\" < \"z\" in our modern lexicography. "
                    },
                    {
                        "username": "shantanu1405",
                        "content": "if you have seen a dictionary, there words are arranged lexicographical , there, ambulance comes before zebra, so we move from the first letter and check, if at any point, the letter of preceding word is alphabetically greater than the  letter of next word, then it is wrong.\\nin your case, k comes before q, so no need to check the next letters as the sequence is correct\\n\\n"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "\"apple\" > \"app\" is sorted by the length only because they both start with \"app\".\\nin the case with [\"kuvp\",\"q\"] \"k\" shows up sooner in the alphabet than \"q\" does, so even though \"kuvp\" is longer it is alphabetically first,\\njust like how \"apple\" comes alphabetically first before \"car\" in regular english  "
                    },
                    {
                        "username": "srivastavashubham7984",
                        "content": "[@ujjwal1234](/ujjwal1234)  Yes, this seems to be invalid test case. As per the example, output should be false."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "I am also facing the same problem\\n"
                    },
                    {
                        "username": "mhhs",
                        "content": "I think this one is a medium problem. It\\'s take a long time for me to grasp the concept clearly"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Hint: check next character only if current character is equal.\\n\\nThey should\\'ve mentioned it, i\\'m not sure how it is obvious"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "The second test case in the examples states in its explanation, \\'As \\'d\\' comes after \\'l\\' in this language\\' it should be obvious."
                    },
                    {
                        "username": "ayush_cmd",
                        "content": "it is obvio because this is how the real dictionary works"
                    },
                    {
                        "username": "aanand07",
                        "content": "Thanks for this tip!! \\uD83D\\uDD25 "
                    },
                    {
                        "username": "rohit__27",
                        "content": "it is .."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "![image](https://assets.leetcode.com/users/bluecode2017/image_1561259655.png)\\n"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@TornikePy](/TornikePy) \\nSo how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "TuringJest",
                        "content": "A simple way to understand this, is to picture a string\\'s lexicographic value as a float - where the first char is the integer part and the rest is the fractional part.\\n\\nh   l   a  b  c  d  e   f  g   i    j    k   m    n   o   p   q    r    s    t...\\n0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19...\\n\\nhello -> 0 6 1 1 14  -> 0 . 6 1 1 14\\nleetcode -> 1 6 6 19 4 14 5 6 -> 1 . 6 6 19 4 14 5 6\\n(let\\'s imagine the float it in base26, so that a letter can\\'t take up more than \"one decimal place\" or correct in base26 - a hexavigesimal place.)\\n\\nIt\\'s immediately clear that 1.6... > 0.6....\\n\\nPs. Don\\'t get confused about base26, it\\'s just there to make the float analogy mathematically correct. It\\'s not needed for the mental model or the code.\\n\\n"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\\norder.index(\"h\")\\n=> 0\\norder.index(\"l\")\\n=>  1\\nso \"h\" before \"l\" then ignore other later\\nThe first letter has the highest importance\\nis sored "
                    },
                    {
                        "username": "GKushi",
                        "content": "[@TornikePy](/TornikePy)  Thanks"
                    },
                    {
                        "username": "TornikePy",
                        "content": "we do not need to check more than first character, as H and L are different and L comes after H, so second word will come after first."
                    },
                    {
                        "username": "pradeep11",
                        "content": "Example 1:\\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nOutput: true\\n\\nthe 4th index position - char \\'o\\' comes after 4th index position of second word \\'c\\' . How it is sorted? It should return false?"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@Vaibhav_69](/Vaibhav_69) So how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "We are only checking the first character of the words in the string array, hence it is true as H<L in alien dictionary"
                    },
                    {
                        "username": "JohnCanessa",
                        "content": "Hello,\\nThe first test case uses the words \\'hello\\' and \\'leetcode\\' and the dictionary \\'hlabcdefgijkmnopqrstuvwxyz\\'.\\n\\'hello\\' = [0, 6, 1, 1, 14]\\n\\'leetcode\\' = [1, 6, 6, 19, 4, 14, 5, 6]\\n0 <= 1, 6 <= 6, 1 <= 6, 1 <= 19, 14 > 4\\n\\'hello\\' seems to be > \\'leetcode\\'.\\nThat seems to indicate that the result for the test case should be false.\\nCould someone set me straight?\\nThanks\\nJohn\\n\\n"
                    },
                    {
                        "username": "leddie24",
                        "content": "We\\'re not comparing the total \"value\" of each word. We stop as soon as we get to a comparison that isn\\'t equal.  For a non-alien dictionary (e.g: English) if we compare \"Apple\" to \"America\", \"America\" is sorted before apple, because we stop comparing after the second letter.  In the example, since \"h\" !== \"l\", we can stop the comparison after those letters. H has a lower index in the alien alphabet, so we consider \"hello\" < \"leetcode\"."
                    }
                ]
            },
            {
                "id": 1784027,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me :/"
                    },
                    {
                        "username": "urodoloh",
                        "content": "[@kseniiaprytkova](/kseniiaprytkova) oh god, i understood the problem only thanks to you. thanks"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Only aliens can understand it! ;)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# To clear up the confusion\\n\\nLexographic order = alphabetical order. Think about it like this: if you were to build a dictionary, which word would you put first?\\n\\nThis is why some apparently weird test cases like `[[\"kuvp\",\"q\"], \"ngxlkthsjuoqcpavbfdermiywz\"]` return true"
                    },
                    {
                        "username": "kseniiaprytkova",
                        "content": "Imagine a regular paper dictionary of your language. Where words are presented and their definitions. The words there are in alphabetical order. If the first letters of 2 words are the same, then we look at the second letters of 2 words (and so on) to decide which word will be first."
                    },
                    {
                        "username": "dapilk101",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) Good explanation. That is how I interpreted this problem too."
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova)  Basically , the words list is a dictionary (ex - oxford dictionary) and the order is provided (ranking of alphabets) , we need to check whether the dictionary is correct i.e. the words need to be in order provided."
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "This is how I understand this task:\\n\\nIf the first word in the given array \"words\" is longer then second --- result will be false \\nThan we take letters of this words and find them in the given \"order\", if the index of the letter from the  first word is bigger than the letter index of the second word --- result will be false \\n(for example, we have the first letters from the first and the second word, we find index of this letters in the given \"order\" and compare this indexes, the index of the first word must be lower that index of the second, otherwise it will be false)\\n\\nYou can correct me if I\\'m wrong or add explanations to my answer. This task is really unclear, lol"
                    },
                    {
                        "username": "shubham_kamdi",
                        "content": "please move this to medium "
                    },
                    {
                        "username": "dieg0maci3l",
                        "content": "I don't think this is a medium problem, they just need to add a short list of \"lexicographical rules\" to make the statement more clear. They explain how the lexicographical rules work in the examples, but the statement can be improved for sure. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I would say this is an easy problem with a few edge cases where we need to be more careful"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Medium problems often take me over an hour, or I require hints, this took me 6 minuets and 44 seconds. Not sure why this would be medium?"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "[@aanand07](/aanand07) thanks i think this might be cause\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Let me check with the Men in Black."
                    },
                    {
                        "username": "aanand07",
                        "content": "IMO, in some cases input constraints determine the level of a problem.\\nOver here, words and words[i] max length is less, so it should be in easy category."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Took about 5 minutes to solve I don\\'t know what you\\'re talking about lol"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Definitely not an easy lol. Also they should say `alphabetical order` somewhere in the question because `lexicographic order` is just a weird term that causes confusion"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Somewhere Aliens are laughing..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Hard to be an alien nowadays :)"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "is my skill going down or the easy questions are getting difficult ?"
                    },
                    {
                        "username": "mohak0",
                        "content": "I believe that the question description should\\'ve explained the problem better. The current description is so vague that we\\'re expected to decipher the test cases and figure out what\\'s being asked.\\nMaybe a good problem for interviews where you can ask questions and clarify different test cases with the interviewer "
                    },
                    {
                        "username": "coolgal",
                        "content": "Why is following testcase returning true ?\\n\\n[\"kuvp\",\"q\"]\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\nIn example 3, it says if second string length is less then first string than return false?\\n\\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nOutput: false\\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because \\'l\\' > \\'\\u2205\\', where \\'\\u2205\\' is defined as the blank character which is less than any other character (More info)."
                    },
                    {
                        "username": "hridoy100",
                        "content": "condition should be: if word2 has more length and it is also a minimum length substring of word1."
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"abcdefghijklmnopqrstuvwxyz\"\norder.index(\"k\") \n=> 10\norder.index(\"q\") \n=> 16\nso \"k\" before \"q\" then ignore other later \nThe first letter has the highest importance"
                    },
                    {
                        "username": "arshde3p",
                        "content": "Hint: compare characters from left-to-right. See here q > k, so it will come after in the lexicographic order. In the apple-app example you\\'ll start from left \\n\\'a\\' == \\'a\\'\\n\\'p\\' == \\'p\\'\\n.\\n\\'l\\' > null\\nso \"apple\" is greater than \"app\" here hence result is false for that case.\\n\\nHere,\\n\\'k\\' < \\'q\\'\\nso break here itself rest characters doesn\\'t matter"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "[@srivastavashubham7984](/srivastavashubham7984)  I don\\'t think it is invalid. We compare \"kuvp\" to \"q\", which is equal to \"kuvp\" to \"q000\" where 0 is phi. since \"k\" < \"q\", this should return True. Its similar to \"ant\" < \"z\" in our modern lexicography. "
                    },
                    {
                        "username": "shantanu1405",
                        "content": "if you have seen a dictionary, there words are arranged lexicographical , there, ambulance comes before zebra, so we move from the first letter and check, if at any point, the letter of preceding word is alphabetically greater than the  letter of next word, then it is wrong.\\nin your case, k comes before q, so no need to check the next letters as the sequence is correct\\n\\n"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "\"apple\" > \"app\" is sorted by the length only because they both start with \"app\".\\nin the case with [\"kuvp\",\"q\"] \"k\" shows up sooner in the alphabet than \"q\" does, so even though \"kuvp\" is longer it is alphabetically first,\\njust like how \"apple\" comes alphabetically first before \"car\" in regular english  "
                    },
                    {
                        "username": "srivastavashubham7984",
                        "content": "[@ujjwal1234](/ujjwal1234)  Yes, this seems to be invalid test case. As per the example, output should be false."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "I am also facing the same problem\\n"
                    },
                    {
                        "username": "mhhs",
                        "content": "I think this one is a medium problem. It\\'s take a long time for me to grasp the concept clearly"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Hint: check next character only if current character is equal.\\n\\nThey should\\'ve mentioned it, i\\'m not sure how it is obvious"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "The second test case in the examples states in its explanation, \\'As \\'d\\' comes after \\'l\\' in this language\\' it should be obvious."
                    },
                    {
                        "username": "ayush_cmd",
                        "content": "it is obvio because this is how the real dictionary works"
                    },
                    {
                        "username": "aanand07",
                        "content": "Thanks for this tip!! \\uD83D\\uDD25 "
                    },
                    {
                        "username": "rohit__27",
                        "content": "it is .."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "![image](https://assets.leetcode.com/users/bluecode2017/image_1561259655.png)\\n"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@TornikePy](/TornikePy) \\nSo how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "TuringJest",
                        "content": "A simple way to understand this, is to picture a string\\'s lexicographic value as a float - where the first char is the integer part and the rest is the fractional part.\\n\\nh   l   a  b  c  d  e   f  g   i    j    k   m    n   o   p   q    r    s    t...\\n0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19...\\n\\nhello -> 0 6 1 1 14  -> 0 . 6 1 1 14\\nleetcode -> 1 6 6 19 4 14 5 6 -> 1 . 6 6 19 4 14 5 6\\n(let\\'s imagine the float it in base26, so that a letter can\\'t take up more than \"one decimal place\" or correct in base26 - a hexavigesimal place.)\\n\\nIt\\'s immediately clear that 1.6... > 0.6....\\n\\nPs. Don\\'t get confused about base26, it\\'s just there to make the float analogy mathematically correct. It\\'s not needed for the mental model or the code.\\n\\n"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\\norder.index(\"h\")\\n=> 0\\norder.index(\"l\")\\n=>  1\\nso \"h\" before \"l\" then ignore other later\\nThe first letter has the highest importance\\nis sored "
                    },
                    {
                        "username": "GKushi",
                        "content": "[@TornikePy](/TornikePy)  Thanks"
                    },
                    {
                        "username": "TornikePy",
                        "content": "we do not need to check more than first character, as H and L are different and L comes after H, so second word will come after first."
                    },
                    {
                        "username": "pradeep11",
                        "content": "Example 1:\\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nOutput: true\\n\\nthe 4th index position - char \\'o\\' comes after 4th index position of second word \\'c\\' . How it is sorted? It should return false?"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@Vaibhav_69](/Vaibhav_69) So how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "We are only checking the first character of the words in the string array, hence it is true as H<L in alien dictionary"
                    },
                    {
                        "username": "JohnCanessa",
                        "content": "Hello,\\nThe first test case uses the words \\'hello\\' and \\'leetcode\\' and the dictionary \\'hlabcdefgijkmnopqrstuvwxyz\\'.\\n\\'hello\\' = [0, 6, 1, 1, 14]\\n\\'leetcode\\' = [1, 6, 6, 19, 4, 14, 5, 6]\\n0 <= 1, 6 <= 6, 1 <= 6, 1 <= 19, 14 > 4\\n\\'hello\\' seems to be > \\'leetcode\\'.\\nThat seems to indicate that the result for the test case should be false.\\nCould someone set me straight?\\nThanks\\nJohn\\n\\n"
                    },
                    {
                        "username": "leddie24",
                        "content": "We\\'re not comparing the total \"value\" of each word. We stop as soon as we get to a comparison that isn\\'t equal.  For a non-alien dictionary (e.g: English) if we compare \"Apple\" to \"America\", \"America\" is sorted before apple, because we stop comparing after the second letter.  In the example, since \"h\" !== \"l\", we can stop the comparison after those letters. H has a lower index in the alien alphabet, so we consider \"hello\" < \"leetcode\"."
                    }
                ]
            },
            {
                "id": 1564833,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me :/"
                    },
                    {
                        "username": "urodoloh",
                        "content": "[@kseniiaprytkova](/kseniiaprytkova) oh god, i understood the problem only thanks to you. thanks"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Only aliens can understand it! ;)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# To clear up the confusion\\n\\nLexographic order = alphabetical order. Think about it like this: if you were to build a dictionary, which word would you put first?\\n\\nThis is why some apparently weird test cases like `[[\"kuvp\",\"q\"], \"ngxlkthsjuoqcpavbfdermiywz\"]` return true"
                    },
                    {
                        "username": "kseniiaprytkova",
                        "content": "Imagine a regular paper dictionary of your language. Where words are presented and their definitions. The words there are in alphabetical order. If the first letters of 2 words are the same, then we look at the second letters of 2 words (and so on) to decide which word will be first."
                    },
                    {
                        "username": "dapilk101",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) Good explanation. That is how I interpreted this problem too."
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova)  Basically , the words list is a dictionary (ex - oxford dictionary) and the order is provided (ranking of alphabets) , we need to check whether the dictionary is correct i.e. the words need to be in order provided."
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "This is how I understand this task:\\n\\nIf the first word in the given array \"words\" is longer then second --- result will be false \\nThan we take letters of this words and find them in the given \"order\", if the index of the letter from the  first word is bigger than the letter index of the second word --- result will be false \\n(for example, we have the first letters from the first and the second word, we find index of this letters in the given \"order\" and compare this indexes, the index of the first word must be lower that index of the second, otherwise it will be false)\\n\\nYou can correct me if I\\'m wrong or add explanations to my answer. This task is really unclear, lol"
                    },
                    {
                        "username": "shubham_kamdi",
                        "content": "please move this to medium "
                    },
                    {
                        "username": "dieg0maci3l",
                        "content": "I don't think this is a medium problem, they just need to add a short list of \"lexicographical rules\" to make the statement more clear. They explain how the lexicographical rules work in the examples, but the statement can be improved for sure. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I would say this is an easy problem with a few edge cases where we need to be more careful"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Medium problems often take me over an hour, or I require hints, this took me 6 minuets and 44 seconds. Not sure why this would be medium?"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "[@aanand07](/aanand07) thanks i think this might be cause\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Let me check with the Men in Black."
                    },
                    {
                        "username": "aanand07",
                        "content": "IMO, in some cases input constraints determine the level of a problem.\\nOver here, words and words[i] max length is less, so it should be in easy category."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Took about 5 minutes to solve I don\\'t know what you\\'re talking about lol"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Definitely not an easy lol. Also they should say `alphabetical order` somewhere in the question because `lexicographic order` is just a weird term that causes confusion"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Somewhere Aliens are laughing..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Hard to be an alien nowadays :)"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "is my skill going down or the easy questions are getting difficult ?"
                    },
                    {
                        "username": "mohak0",
                        "content": "I believe that the question description should\\'ve explained the problem better. The current description is so vague that we\\'re expected to decipher the test cases and figure out what\\'s being asked.\\nMaybe a good problem for interviews where you can ask questions and clarify different test cases with the interviewer "
                    },
                    {
                        "username": "coolgal",
                        "content": "Why is following testcase returning true ?\\n\\n[\"kuvp\",\"q\"]\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\nIn example 3, it says if second string length is less then first string than return false?\\n\\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nOutput: false\\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because \\'l\\' > \\'\\u2205\\', where \\'\\u2205\\' is defined as the blank character which is less than any other character (More info)."
                    },
                    {
                        "username": "hridoy100",
                        "content": "condition should be: if word2 has more length and it is also a minimum length substring of word1."
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"abcdefghijklmnopqrstuvwxyz\"\norder.index(\"k\") \n=> 10\norder.index(\"q\") \n=> 16\nso \"k\" before \"q\" then ignore other later \nThe first letter has the highest importance"
                    },
                    {
                        "username": "arshde3p",
                        "content": "Hint: compare characters from left-to-right. See here q > k, so it will come after in the lexicographic order. In the apple-app example you\\'ll start from left \\n\\'a\\' == \\'a\\'\\n\\'p\\' == \\'p\\'\\n.\\n\\'l\\' > null\\nso \"apple\" is greater than \"app\" here hence result is false for that case.\\n\\nHere,\\n\\'k\\' < \\'q\\'\\nso break here itself rest characters doesn\\'t matter"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "[@srivastavashubham7984](/srivastavashubham7984)  I don\\'t think it is invalid. We compare \"kuvp\" to \"q\", which is equal to \"kuvp\" to \"q000\" where 0 is phi. since \"k\" < \"q\", this should return True. Its similar to \"ant\" < \"z\" in our modern lexicography. "
                    },
                    {
                        "username": "shantanu1405",
                        "content": "if you have seen a dictionary, there words are arranged lexicographical , there, ambulance comes before zebra, so we move from the first letter and check, if at any point, the letter of preceding word is alphabetically greater than the  letter of next word, then it is wrong.\\nin your case, k comes before q, so no need to check the next letters as the sequence is correct\\n\\n"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "\"apple\" > \"app\" is sorted by the length only because they both start with \"app\".\\nin the case with [\"kuvp\",\"q\"] \"k\" shows up sooner in the alphabet than \"q\" does, so even though \"kuvp\" is longer it is alphabetically first,\\njust like how \"apple\" comes alphabetically first before \"car\" in regular english  "
                    },
                    {
                        "username": "srivastavashubham7984",
                        "content": "[@ujjwal1234](/ujjwal1234)  Yes, this seems to be invalid test case. As per the example, output should be false."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "I am also facing the same problem\\n"
                    },
                    {
                        "username": "mhhs",
                        "content": "I think this one is a medium problem. It\\'s take a long time for me to grasp the concept clearly"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Hint: check next character only if current character is equal.\\n\\nThey should\\'ve mentioned it, i\\'m not sure how it is obvious"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "The second test case in the examples states in its explanation, \\'As \\'d\\' comes after \\'l\\' in this language\\' it should be obvious."
                    },
                    {
                        "username": "ayush_cmd",
                        "content": "it is obvio because this is how the real dictionary works"
                    },
                    {
                        "username": "aanand07",
                        "content": "Thanks for this tip!! \\uD83D\\uDD25 "
                    },
                    {
                        "username": "rohit__27",
                        "content": "it is .."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "![image](https://assets.leetcode.com/users/bluecode2017/image_1561259655.png)\\n"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@TornikePy](/TornikePy) \\nSo how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "TuringJest",
                        "content": "A simple way to understand this, is to picture a string\\'s lexicographic value as a float - where the first char is the integer part and the rest is the fractional part.\\n\\nh   l   a  b  c  d  e   f  g   i    j    k   m    n   o   p   q    r    s    t...\\n0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19...\\n\\nhello -> 0 6 1 1 14  -> 0 . 6 1 1 14\\nleetcode -> 1 6 6 19 4 14 5 6 -> 1 . 6 6 19 4 14 5 6\\n(let\\'s imagine the float it in base26, so that a letter can\\'t take up more than \"one decimal place\" or correct in base26 - a hexavigesimal place.)\\n\\nIt\\'s immediately clear that 1.6... > 0.6....\\n\\nPs. Don\\'t get confused about base26, it\\'s just there to make the float analogy mathematically correct. It\\'s not needed for the mental model or the code.\\n\\n"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\\norder.index(\"h\")\\n=> 0\\norder.index(\"l\")\\n=>  1\\nso \"h\" before \"l\" then ignore other later\\nThe first letter has the highest importance\\nis sored "
                    },
                    {
                        "username": "GKushi",
                        "content": "[@TornikePy](/TornikePy)  Thanks"
                    },
                    {
                        "username": "TornikePy",
                        "content": "we do not need to check more than first character, as H and L are different and L comes after H, so second word will come after first."
                    },
                    {
                        "username": "pradeep11",
                        "content": "Example 1:\\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nOutput: true\\n\\nthe 4th index position - char \\'o\\' comes after 4th index position of second word \\'c\\' . How it is sorted? It should return false?"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@Vaibhav_69](/Vaibhav_69) So how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "We are only checking the first character of the words in the string array, hence it is true as H<L in alien dictionary"
                    },
                    {
                        "username": "JohnCanessa",
                        "content": "Hello,\\nThe first test case uses the words \\'hello\\' and \\'leetcode\\' and the dictionary \\'hlabcdefgijkmnopqrstuvwxyz\\'.\\n\\'hello\\' = [0, 6, 1, 1, 14]\\n\\'leetcode\\' = [1, 6, 6, 19, 4, 14, 5, 6]\\n0 <= 1, 6 <= 6, 1 <= 6, 1 <= 19, 14 > 4\\n\\'hello\\' seems to be > \\'leetcode\\'.\\nThat seems to indicate that the result for the test case should be false.\\nCould someone set me straight?\\nThanks\\nJohn\\n\\n"
                    },
                    {
                        "username": "leddie24",
                        "content": "We\\'re not comparing the total \"value\" of each word. We stop as soon as we get to a comparison that isn\\'t equal.  For a non-alien dictionary (e.g: English) if we compare \"Apple\" to \"America\", \"America\" is sorted before apple, because we stop comparing after the second letter.  In the example, since \"h\" !== \"l\", we can stop the comparison after those letters. H has a lower index in the alien alphabet, so we consider \"hello\" < \"leetcode\"."
                    }
                ]
            },
            {
                "id": 1568080,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me :/"
                    },
                    {
                        "username": "urodoloh",
                        "content": "[@kseniiaprytkova](/kseniiaprytkova) oh god, i understood the problem only thanks to you. thanks"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Only aliens can understand it! ;)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# To clear up the confusion\\n\\nLexographic order = alphabetical order. Think about it like this: if you were to build a dictionary, which word would you put first?\\n\\nThis is why some apparently weird test cases like `[[\"kuvp\",\"q\"], \"ngxlkthsjuoqcpavbfdermiywz\"]` return true"
                    },
                    {
                        "username": "kseniiaprytkova",
                        "content": "Imagine a regular paper dictionary of your language. Where words are presented and their definitions. The words there are in alphabetical order. If the first letters of 2 words are the same, then we look at the second letters of 2 words (and so on) to decide which word will be first."
                    },
                    {
                        "username": "dapilk101",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) Good explanation. That is how I interpreted this problem too."
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova)  Basically , the words list is a dictionary (ex - oxford dictionary) and the order is provided (ranking of alphabets) , we need to check whether the dictionary is correct i.e. the words need to be in order provided."
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "This is how I understand this task:\\n\\nIf the first word in the given array \"words\" is longer then second --- result will be false \\nThan we take letters of this words and find them in the given \"order\", if the index of the letter from the  first word is bigger than the letter index of the second word --- result will be false \\n(for example, we have the first letters from the first and the second word, we find index of this letters in the given \"order\" and compare this indexes, the index of the first word must be lower that index of the second, otherwise it will be false)\\n\\nYou can correct me if I\\'m wrong or add explanations to my answer. This task is really unclear, lol"
                    },
                    {
                        "username": "shubham_kamdi",
                        "content": "please move this to medium "
                    },
                    {
                        "username": "dieg0maci3l",
                        "content": "I don't think this is a medium problem, they just need to add a short list of \"lexicographical rules\" to make the statement more clear. They explain how the lexicographical rules work in the examples, but the statement can be improved for sure. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I would say this is an easy problem with a few edge cases where we need to be more careful"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Medium problems often take me over an hour, or I require hints, this took me 6 minuets and 44 seconds. Not sure why this would be medium?"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "[@aanand07](/aanand07) thanks i think this might be cause\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Let me check with the Men in Black."
                    },
                    {
                        "username": "aanand07",
                        "content": "IMO, in some cases input constraints determine the level of a problem.\\nOver here, words and words[i] max length is less, so it should be in easy category."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Took about 5 minutes to solve I don\\'t know what you\\'re talking about lol"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Definitely not an easy lol. Also they should say `alphabetical order` somewhere in the question because `lexicographic order` is just a weird term that causes confusion"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Somewhere Aliens are laughing..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Hard to be an alien nowadays :)"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "is my skill going down or the easy questions are getting difficult ?"
                    },
                    {
                        "username": "mohak0",
                        "content": "I believe that the question description should\\'ve explained the problem better. The current description is so vague that we\\'re expected to decipher the test cases and figure out what\\'s being asked.\\nMaybe a good problem for interviews where you can ask questions and clarify different test cases with the interviewer "
                    },
                    {
                        "username": "coolgal",
                        "content": "Why is following testcase returning true ?\\n\\n[\"kuvp\",\"q\"]\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\nIn example 3, it says if second string length is less then first string than return false?\\n\\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nOutput: false\\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because \\'l\\' > \\'\\u2205\\', where \\'\\u2205\\' is defined as the blank character which is less than any other character (More info)."
                    },
                    {
                        "username": "hridoy100",
                        "content": "condition should be: if word2 has more length and it is also a minimum length substring of word1."
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"abcdefghijklmnopqrstuvwxyz\"\norder.index(\"k\") \n=> 10\norder.index(\"q\") \n=> 16\nso \"k\" before \"q\" then ignore other later \nThe first letter has the highest importance"
                    },
                    {
                        "username": "arshde3p",
                        "content": "Hint: compare characters from left-to-right. See here q > k, so it will come after in the lexicographic order. In the apple-app example you\\'ll start from left \\n\\'a\\' == \\'a\\'\\n\\'p\\' == \\'p\\'\\n.\\n\\'l\\' > null\\nso \"apple\" is greater than \"app\" here hence result is false for that case.\\n\\nHere,\\n\\'k\\' < \\'q\\'\\nso break here itself rest characters doesn\\'t matter"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "[@srivastavashubham7984](/srivastavashubham7984)  I don\\'t think it is invalid. We compare \"kuvp\" to \"q\", which is equal to \"kuvp\" to \"q000\" where 0 is phi. since \"k\" < \"q\", this should return True. Its similar to \"ant\" < \"z\" in our modern lexicography. "
                    },
                    {
                        "username": "shantanu1405",
                        "content": "if you have seen a dictionary, there words are arranged lexicographical , there, ambulance comes before zebra, so we move from the first letter and check, if at any point, the letter of preceding word is alphabetically greater than the  letter of next word, then it is wrong.\\nin your case, k comes before q, so no need to check the next letters as the sequence is correct\\n\\n"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "\"apple\" > \"app\" is sorted by the length only because they both start with \"app\".\\nin the case with [\"kuvp\",\"q\"] \"k\" shows up sooner in the alphabet than \"q\" does, so even though \"kuvp\" is longer it is alphabetically first,\\njust like how \"apple\" comes alphabetically first before \"car\" in regular english  "
                    },
                    {
                        "username": "srivastavashubham7984",
                        "content": "[@ujjwal1234](/ujjwal1234)  Yes, this seems to be invalid test case. As per the example, output should be false."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "I am also facing the same problem\\n"
                    },
                    {
                        "username": "mhhs",
                        "content": "I think this one is a medium problem. It\\'s take a long time for me to grasp the concept clearly"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Hint: check next character only if current character is equal.\\n\\nThey should\\'ve mentioned it, i\\'m not sure how it is obvious"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "The second test case in the examples states in its explanation, \\'As \\'d\\' comes after \\'l\\' in this language\\' it should be obvious."
                    },
                    {
                        "username": "ayush_cmd",
                        "content": "it is obvio because this is how the real dictionary works"
                    },
                    {
                        "username": "aanand07",
                        "content": "Thanks for this tip!! \\uD83D\\uDD25 "
                    },
                    {
                        "username": "rohit__27",
                        "content": "it is .."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "![image](https://assets.leetcode.com/users/bluecode2017/image_1561259655.png)\\n"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@TornikePy](/TornikePy) \\nSo how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "TuringJest",
                        "content": "A simple way to understand this, is to picture a string\\'s lexicographic value as a float - where the first char is the integer part and the rest is the fractional part.\\n\\nh   l   a  b  c  d  e   f  g   i    j    k   m    n   o   p   q    r    s    t...\\n0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19...\\n\\nhello -> 0 6 1 1 14  -> 0 . 6 1 1 14\\nleetcode -> 1 6 6 19 4 14 5 6 -> 1 . 6 6 19 4 14 5 6\\n(let\\'s imagine the float it in base26, so that a letter can\\'t take up more than \"one decimal place\" or correct in base26 - a hexavigesimal place.)\\n\\nIt\\'s immediately clear that 1.6... > 0.6....\\n\\nPs. Don\\'t get confused about base26, it\\'s just there to make the float analogy mathematically correct. It\\'s not needed for the mental model or the code.\\n\\n"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\\norder.index(\"h\")\\n=> 0\\norder.index(\"l\")\\n=>  1\\nso \"h\" before \"l\" then ignore other later\\nThe first letter has the highest importance\\nis sored "
                    },
                    {
                        "username": "GKushi",
                        "content": "[@TornikePy](/TornikePy)  Thanks"
                    },
                    {
                        "username": "TornikePy",
                        "content": "we do not need to check more than first character, as H and L are different and L comes after H, so second word will come after first."
                    },
                    {
                        "username": "pradeep11",
                        "content": "Example 1:\\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nOutput: true\\n\\nthe 4th index position - char \\'o\\' comes after 4th index position of second word \\'c\\' . How it is sorted? It should return false?"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@Vaibhav_69](/Vaibhav_69) So how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "We are only checking the first character of the words in the string array, hence it is true as H<L in alien dictionary"
                    },
                    {
                        "username": "JohnCanessa",
                        "content": "Hello,\\nThe first test case uses the words \\'hello\\' and \\'leetcode\\' and the dictionary \\'hlabcdefgijkmnopqrstuvwxyz\\'.\\n\\'hello\\' = [0, 6, 1, 1, 14]\\n\\'leetcode\\' = [1, 6, 6, 19, 4, 14, 5, 6]\\n0 <= 1, 6 <= 6, 1 <= 6, 1 <= 19, 14 > 4\\n\\'hello\\' seems to be > \\'leetcode\\'.\\nThat seems to indicate that the result for the test case should be false.\\nCould someone set me straight?\\nThanks\\nJohn\\n\\n"
                    },
                    {
                        "username": "leddie24",
                        "content": "We\\'re not comparing the total \"value\" of each word. We stop as soon as we get to a comparison that isn\\'t equal.  For a non-alien dictionary (e.g: English) if we compare \"Apple\" to \"America\", \"America\" is sorted before apple, because we stop comparing after the second letter.  In the example, since \"h\" !== \"l\", we can stop the comparison after those letters. H has a lower index in the alien alphabet, so we consider \"hello\" < \"leetcode\"."
                    }
                ]
            },
            {
                "id": 1574869,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me :/"
                    },
                    {
                        "username": "urodoloh",
                        "content": "[@kseniiaprytkova](/kseniiaprytkova) oh god, i understood the problem only thanks to you. thanks"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Only aliens can understand it! ;)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# To clear up the confusion\\n\\nLexographic order = alphabetical order. Think about it like this: if you were to build a dictionary, which word would you put first?\\n\\nThis is why some apparently weird test cases like `[[\"kuvp\",\"q\"], \"ngxlkthsjuoqcpavbfdermiywz\"]` return true"
                    },
                    {
                        "username": "kseniiaprytkova",
                        "content": "Imagine a regular paper dictionary of your language. Where words are presented and their definitions. The words there are in alphabetical order. If the first letters of 2 words are the same, then we look at the second letters of 2 words (and so on) to decide which word will be first."
                    },
                    {
                        "username": "dapilk101",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) Good explanation. That is how I interpreted this problem too."
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova)  Basically , the words list is a dictionary (ex - oxford dictionary) and the order is provided (ranking of alphabets) , we need to check whether the dictionary is correct i.e. the words need to be in order provided."
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "This is how I understand this task:\\n\\nIf the first word in the given array \"words\" is longer then second --- result will be false \\nThan we take letters of this words and find them in the given \"order\", if the index of the letter from the  first word is bigger than the letter index of the second word --- result will be false \\n(for example, we have the first letters from the first and the second word, we find index of this letters in the given \"order\" and compare this indexes, the index of the first word must be lower that index of the second, otherwise it will be false)\\n\\nYou can correct me if I\\'m wrong or add explanations to my answer. This task is really unclear, lol"
                    },
                    {
                        "username": "shubham_kamdi",
                        "content": "please move this to medium "
                    },
                    {
                        "username": "dieg0maci3l",
                        "content": "I don't think this is a medium problem, they just need to add a short list of \"lexicographical rules\" to make the statement more clear. They explain how the lexicographical rules work in the examples, but the statement can be improved for sure. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I would say this is an easy problem with a few edge cases where we need to be more careful"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Medium problems often take me over an hour, or I require hints, this took me 6 minuets and 44 seconds. Not sure why this would be medium?"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "[@aanand07](/aanand07) thanks i think this might be cause\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Let me check with the Men in Black."
                    },
                    {
                        "username": "aanand07",
                        "content": "IMO, in some cases input constraints determine the level of a problem.\\nOver here, words and words[i] max length is less, so it should be in easy category."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Took about 5 minutes to solve I don\\'t know what you\\'re talking about lol"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Definitely not an easy lol. Also they should say `alphabetical order` somewhere in the question because `lexicographic order` is just a weird term that causes confusion"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Somewhere Aliens are laughing..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Hard to be an alien nowadays :)"
                    },
                    {
                        "username": "ersarthaksethi",
                        "content": "is my skill going down or the easy questions are getting difficult ?"
                    },
                    {
                        "username": "mohak0",
                        "content": "I believe that the question description should\\'ve explained the problem better. The current description is so vague that we\\'re expected to decipher the test cases and figure out what\\'s being asked.\\nMaybe a good problem for interviews where you can ask questions and clarify different test cases with the interviewer "
                    },
                    {
                        "username": "coolgal",
                        "content": "Why is following testcase returning true ?\\n\\n[\"kuvp\",\"q\"]\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\nIn example 3, it says if second string length is less then first string than return false?\\n\\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nOutput: false\\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because \\'l\\' > \\'\\u2205\\', where \\'\\u2205\\' is defined as the blank character which is less than any other character (More info)."
                    },
                    {
                        "username": "hridoy100",
                        "content": "condition should be: if word2 has more length and it is also a minimum length substring of word1."
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"abcdefghijklmnopqrstuvwxyz\"\norder.index(\"k\") \n=> 10\norder.index(\"q\") \n=> 16\nso \"k\" before \"q\" then ignore other later \nThe first letter has the highest importance"
                    },
                    {
                        "username": "arshde3p",
                        "content": "Hint: compare characters from left-to-right. See here q > k, so it will come after in the lexicographic order. In the apple-app example you\\'ll start from left \\n\\'a\\' == \\'a\\'\\n\\'p\\' == \\'p\\'\\n.\\n\\'l\\' > null\\nso \"apple\" is greater than \"app\" here hence result is false for that case.\\n\\nHere,\\n\\'k\\' < \\'q\\'\\nso break here itself rest characters doesn\\'t matter"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "[@srivastavashubham7984](/srivastavashubham7984)  I don\\'t think it is invalid. We compare \"kuvp\" to \"q\", which is equal to \"kuvp\" to \"q000\" where 0 is phi. since \"k\" < \"q\", this should return True. Its similar to \"ant\" < \"z\" in our modern lexicography. "
                    },
                    {
                        "username": "shantanu1405",
                        "content": "if you have seen a dictionary, there words are arranged lexicographical , there, ambulance comes before zebra, so we move from the first letter and check, if at any point, the letter of preceding word is alphabetically greater than the  letter of next word, then it is wrong.\\nin your case, k comes before q, so no need to check the next letters as the sequence is correct\\n\\n"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "\"apple\" > \"app\" is sorted by the length only because they both start with \"app\".\\nin the case with [\"kuvp\",\"q\"] \"k\" shows up sooner in the alphabet than \"q\" does, so even though \"kuvp\" is longer it is alphabetically first,\\njust like how \"apple\" comes alphabetically first before \"car\" in regular english  "
                    },
                    {
                        "username": "srivastavashubham7984",
                        "content": "[@ujjwal1234](/ujjwal1234)  Yes, this seems to be invalid test case. As per the example, output should be false."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "I am also facing the same problem\\n"
                    },
                    {
                        "username": "mhhs",
                        "content": "I think this one is a medium problem. It\\'s take a long time for me to grasp the concept clearly"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Hint: check next character only if current character is equal.\\n\\nThey should\\'ve mentioned it, i\\'m not sure how it is obvious"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "The second test case in the examples states in its explanation, \\'As \\'d\\' comes after \\'l\\' in this language\\' it should be obvious."
                    },
                    {
                        "username": "ayush_cmd",
                        "content": "it is obvio because this is how the real dictionary works"
                    },
                    {
                        "username": "aanand07",
                        "content": "Thanks for this tip!! \\uD83D\\uDD25 "
                    },
                    {
                        "username": "rohit__27",
                        "content": "it is .."
                    },
                    {
                        "username": "bluecode2017",
                        "content": "![image](https://assets.leetcode.com/users/bluecode2017/image_1561259655.png)\\n"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@TornikePy](/TornikePy) \\nSo how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "TuringJest",
                        "content": "A simple way to understand this, is to picture a string\\'s lexicographic value as a float - where the first char is the integer part and the rest is the fractional part.\\n\\nh   l   a  b  c  d  e   f  g   i    j    k   m    n   o   p   q    r    s    t...\\n0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19...\\n\\nhello -> 0 6 1 1 14  -> 0 . 6 1 1 14\\nleetcode -> 1 6 6 19 4 14 5 6 -> 1 . 6 6 19 4 14 5 6\\n(let\\'s imagine the float it in base26, so that a letter can\\'t take up more than \"one decimal place\" or correct in base26 - a hexavigesimal place.)\\n\\nIt\\'s immediately clear that 1.6... > 0.6....\\n\\nPs. Don\\'t get confused about base26, it\\'s just there to make the float analogy mathematically correct. It\\'s not needed for the mental model or the code.\\n\\n"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\\norder.index(\"h\")\\n=> 0\\norder.index(\"l\")\\n=>  1\\nso \"h\" before \"l\" then ignore other later\\nThe first letter has the highest importance\\nis sored "
                    },
                    {
                        "username": "GKushi",
                        "content": "[@TornikePy](/TornikePy)  Thanks"
                    },
                    {
                        "username": "TornikePy",
                        "content": "we do not need to check more than first character, as H and L are different and L comes after H, so second word will come after first."
                    },
                    {
                        "username": "pradeep11",
                        "content": "Example 1:\\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\\nOutput: true\\n\\nthe 4th index position - char \\'o\\' comes after 4th index position of second word \\'c\\' . How it is sorted? It should return false?"
                    },
                    {
                        "username": "gulu375",
                        "content": "[@Vaibhav_69](/Vaibhav_69) So how this examples can be explained. Why they are comparing \\'d\\' and \\'l\\'\\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\\nOutput: false\\nExplanation: As \\'d\\' comes after \\'l\\' in this language, then words[0] > words[1], hence the sequence is unsorted."
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "We are only checking the first character of the words in the string array, hence it is true as H<L in alien dictionary"
                    },
                    {
                        "username": "JohnCanessa",
                        "content": "Hello,\\nThe first test case uses the words \\'hello\\' and \\'leetcode\\' and the dictionary \\'hlabcdefgijkmnopqrstuvwxyz\\'.\\n\\'hello\\' = [0, 6, 1, 1, 14]\\n\\'leetcode\\' = [1, 6, 6, 19, 4, 14, 5, 6]\\n0 <= 1, 6 <= 6, 1 <= 6, 1 <= 19, 14 > 4\\n\\'hello\\' seems to be > \\'leetcode\\'.\\nThat seems to indicate that the result for the test case should be false.\\nCould someone set me straight?\\nThanks\\nJohn\\n\\n"
                    },
                    {
                        "username": "leddie24",
                        "content": "We\\'re not comparing the total \"value\" of each word. We stop as soon as we get to a comparison that isn\\'t equal.  For a non-alien dictionary (e.g: English) if we compare \"Apple\" to \"America\", \"America\" is sorted before apple, because we stop comparing after the second letter.  In the example, since \"h\" !== \"l\", we can stop the comparison after those letters. H has a lower index in the alien alphabet, so we consider \"hello\" < \"leetcode\"."
                    }
                ]
            },
            {
                "id": 1784416,
                "content": [
                    {
                        "username": "sanjay_soni",
                        "content": "The ques is very simple.\\n\\nwe have given string order in which all 26 letters of English are not in correct order because its a Alien\\'s dictionary.\\n\\nwe have to check our words are in correct order or not according to this new dictionary.\\n\\nso first ,  map order with their index by using map<char,int> map.\\nthen pick first to words and compare their letter one by one.\\n\\nif it is in correct order then return true otherwise false.\\n\\ncheckout my solution from my profile"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "definitely not an easy problem ;3"
                    },
                    {
                        "username": "marcozylol",
                        "content": "I think what makes this problem \"easy\" is the constraints. Because of that you can make an algorithm that would normally be considered non-optimal. The words array is very small and the words aren't too large. Order can only be 26 characters, so any traversal of that can be thought of as constant time. However, its description is very wordy and not clear unless you read it many times. In a real interview I think it would be much easier to figure out what the problem is asking because you have someone to get clarifications from + walk through more test cases. Also, my solution took a lot of code for an easy but I'm sure there's Python solutions that only take one line."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "i\\'m not an alien and i can\\'t understand this \\uD83D\\uDE2D"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Greetings, fellow not an alien! I too cannot understand this. The letters of the problem are all mixed up in an order I do not understand."
                    },
                    {
                        "username": "dongliang14",
                        "content": "normally our dictionary is organzied/ordered by alphabetical order (\"abcdefghijklmnopqrstuvwxyz\"), but now they have new order"
                    },
                    {
                        "username": "zhakupov",
                        "content": "I am just trying to understand the problem. The first example is kind of weird to me.\\n`Input is : words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"`\\nand `output is true`. But if we check lexicographicaly the last letter of `\"hello\"` located in position `5` is \"o\" and `5th` letter of `\"leetcode\"` is `\"c\"`. Now if you check the given order letter `\"c\"` comes before the letter `\"o\"`. Then howcome the outcome can be true. Can anybody explain me what\\'s wrong with my thinking process and point out the misconception I am having?\\nGreatly appreciate your help!\\n\\nThanks"
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "I guess it is too late, but as in the real world dictionary words starting with \"A\" come before words starting with \"B\".  Similarly, the words need to be in the order provided, \"h\" preceeds \"l\" in the order so we need not to check other indexes. "
                    },
                    {
                        "username": "TuringJest",
                        "content": "<div><div class=\"text-brand-orange text-dark-brand-orange\">A simple way to understand this better, is to picture a string's lexicographic value as a float - with the first char as the integer part and the rest as the fractional part.\n<br><br><div class=\"text-lg\">Example:</div>\nhlabcdefgijkmnopqrst...\n<br>01234567891011 12 13 14 15 16 17 18 19...\n<br>\n<br><b>hello</b> -> 0 6 1 1 14 ->  <b>0 . 6 1 1 14</b>\n<br><b>leetcode</b> -> 1 6 6 19 4 14 5 6 -><b>1 . 6 6 19 4 14 5 6 </b>\n<br>(be aware of '14' and '19'. Let's imagine the float in <b>base26</b>, so any letter only takes up \"one decimal place\" - or correct in base26, a <b>hexavigesimal place</b>.)\n<br><br>Comparing both values it's easy to see that <b>1.6... > 0.6...</b>. \n<br><br>Ps. Don't get confused about base26, it's just there to make the float analogy mathematically correct. It's not needed for the mental model or the code.<div></div>"
                    },
                    {
                        "username": "sachindramishra204",
                        "content": "I would definitely recommend to move this problem to medium. The approach is not very intuitive!\n\nFOR YOUR HELP!\n-> If the first characters of two words are same, then only compare the adjacent characters. \n"
                    },
                    {
                        "username": "S_Basu",
                        "content": "#### ALIEN LEXICOGRAPHY\n*At first glance it seems difficult to understand what the question is trying to say or what exactly are we required to do?* The examples also seem confusing at first. \n- The most important terms that we need to focus on is \n> **\"lexicographically in this alien language\"**\n\nWe need to check if the given `words []` are **lexicographically arranged as per the Alien Dictionary**.\n- Eg: In **our human dictionary** Lexicographic order is $$A$$ *to* $$Z$$\n- But for the **Alien dictionary** the specific **`order`** is as given in each test case.\n- We need to check whether the given `words []` follow the $$Lexicographic$$ **`order` of the Aliens**."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[Link to Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Length check is a pain in ass. They haven\\'t even explained when testcase\\'s are passing and failing.\\nHow come this testcase is true.\\n```\\n[\"apap\",\"app\"]\\n\"abcdefghijklmnopqrstuvwxyz\"\\n```"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "you need to continue checking until both character are different here in this case ap == ap in both cases but next element is diff \\none has a other one has a p\\naccording to order a holds more values"
                    },
                    {
                        "username": "anjaliu949",
                        "content": "As the first two characters of both string \"apap\" and \"app\" are equal , so we have to check for the third one which is  'a' and 'p' and according to the order given 'a' should come before 'p' which is true. Hence, it is returning true.\nNOTE: We need not check for the rest of the characters as soon as we encounter first different characters from both the string."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "\"apap\" would go before \"app\" if the 2 words are put inside a physical human dictionary. (ie. lexicographically)"
                    },
                    {
                        "username": "drewbie",
                        "content": "A good test case to run\\n\\n`[\"a\", \"app\", \"apple\", \"appl\"]`"
                    }
                ]
            },
            {
                "id": 1784263,
                "content": [
                    {
                        "username": "sanjay_soni",
                        "content": "The ques is very simple.\\n\\nwe have given string order in which all 26 letters of English are not in correct order because its a Alien\\'s dictionary.\\n\\nwe have to check our words are in correct order or not according to this new dictionary.\\n\\nso first ,  map order with their index by using map<char,int> map.\\nthen pick first to words and compare their letter one by one.\\n\\nif it is in correct order then return true otherwise false.\\n\\ncheckout my solution from my profile"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "definitely not an easy problem ;3"
                    },
                    {
                        "username": "marcozylol",
                        "content": "I think what makes this problem \"easy\" is the constraints. Because of that you can make an algorithm that would normally be considered non-optimal. The words array is very small and the words aren't too large. Order can only be 26 characters, so any traversal of that can be thought of as constant time. However, its description is very wordy and not clear unless you read it many times. In a real interview I think it would be much easier to figure out what the problem is asking because you have someone to get clarifications from + walk through more test cases. Also, my solution took a lot of code for an easy but I'm sure there's Python solutions that only take one line."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "i\\'m not an alien and i can\\'t understand this \\uD83D\\uDE2D"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Greetings, fellow not an alien! I too cannot understand this. The letters of the problem are all mixed up in an order I do not understand."
                    },
                    {
                        "username": "dongliang14",
                        "content": "normally our dictionary is organzied/ordered by alphabetical order (\"abcdefghijklmnopqrstuvwxyz\"), but now they have new order"
                    },
                    {
                        "username": "zhakupov",
                        "content": "I am just trying to understand the problem. The first example is kind of weird to me.\\n`Input is : words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"`\\nand `output is true`. But if we check lexicographicaly the last letter of `\"hello\"` located in position `5` is \"o\" and `5th` letter of `\"leetcode\"` is `\"c\"`. Now if you check the given order letter `\"c\"` comes before the letter `\"o\"`. Then howcome the outcome can be true. Can anybody explain me what\\'s wrong with my thinking process and point out the misconception I am having?\\nGreatly appreciate your help!\\n\\nThanks"
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "I guess it is too late, but as in the real world dictionary words starting with \"A\" come before words starting with \"B\".  Similarly, the words need to be in the order provided, \"h\" preceeds \"l\" in the order so we need not to check other indexes. "
                    },
                    {
                        "username": "TuringJest",
                        "content": "<div><div class=\"text-brand-orange text-dark-brand-orange\">A simple way to understand this better, is to picture a string's lexicographic value as a float - with the first char as the integer part and the rest as the fractional part.\n<br><br><div class=\"text-lg\">Example:</div>\nhlabcdefgijkmnopqrst...\n<br>01234567891011 12 13 14 15 16 17 18 19...\n<br>\n<br><b>hello</b> -> 0 6 1 1 14 ->  <b>0 . 6 1 1 14</b>\n<br><b>leetcode</b> -> 1 6 6 19 4 14 5 6 -><b>1 . 6 6 19 4 14 5 6 </b>\n<br>(be aware of '14' and '19'. Let's imagine the float in <b>base26</b>, so any letter only takes up \"one decimal place\" - or correct in base26, a <b>hexavigesimal place</b>.)\n<br><br>Comparing both values it's easy to see that <b>1.6... > 0.6...</b>. \n<br><br>Ps. Don't get confused about base26, it's just there to make the float analogy mathematically correct. It's not needed for the mental model or the code.<div></div>"
                    },
                    {
                        "username": "sachindramishra204",
                        "content": "I would definitely recommend to move this problem to medium. The approach is not very intuitive!\n\nFOR YOUR HELP!\n-> If the first characters of two words are same, then only compare the adjacent characters. \n"
                    },
                    {
                        "username": "S_Basu",
                        "content": "#### ALIEN LEXICOGRAPHY\n*At first glance it seems difficult to understand what the question is trying to say or what exactly are we required to do?* The examples also seem confusing at first. \n- The most important terms that we need to focus on is \n> **\"lexicographically in this alien language\"**\n\nWe need to check if the given `words []` are **lexicographically arranged as per the Alien Dictionary**.\n- Eg: In **our human dictionary** Lexicographic order is $$A$$ *to* $$Z$$\n- But for the **Alien dictionary** the specific **`order`** is as given in each test case.\n- We need to check whether the given `words []` follow the $$Lexicographic$$ **`order` of the Aliens**."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[Link to Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Length check is a pain in ass. They haven\\'t even explained when testcase\\'s are passing and failing.\\nHow come this testcase is true.\\n```\\n[\"apap\",\"app\"]\\n\"abcdefghijklmnopqrstuvwxyz\"\\n```"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "you need to continue checking until both character are different here in this case ap == ap in both cases but next element is diff \\none has a other one has a p\\naccording to order a holds more values"
                    },
                    {
                        "username": "anjaliu949",
                        "content": "As the first two characters of both string \"apap\" and \"app\" are equal , so we have to check for the third one which is  'a' and 'p' and according to the order given 'a' should come before 'p' which is true. Hence, it is returning true.\nNOTE: We need not check for the rest of the characters as soon as we encounter first different characters from both the string."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "\"apap\" would go before \"app\" if the 2 words are put inside a physical human dictionary. (ie. lexicographically)"
                    },
                    {
                        "username": "drewbie",
                        "content": "A good test case to run\\n\\n`[\"a\", \"app\", \"apple\", \"appl\"]`"
                    }
                ]
            },
            {
                "id": 1784100,
                "content": [
                    {
                        "username": "sanjay_soni",
                        "content": "The ques is very simple.\\n\\nwe have given string order in which all 26 letters of English are not in correct order because its a Alien\\'s dictionary.\\n\\nwe have to check our words are in correct order or not according to this new dictionary.\\n\\nso first ,  map order with their index by using map<char,int> map.\\nthen pick first to words and compare their letter one by one.\\n\\nif it is in correct order then return true otherwise false.\\n\\ncheckout my solution from my profile"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "definitely not an easy problem ;3"
                    },
                    {
                        "username": "marcozylol",
                        "content": "I think what makes this problem \"easy\" is the constraints. Because of that you can make an algorithm that would normally be considered non-optimal. The words array is very small and the words aren't too large. Order can only be 26 characters, so any traversal of that can be thought of as constant time. However, its description is very wordy and not clear unless you read it many times. In a real interview I think it would be much easier to figure out what the problem is asking because you have someone to get clarifications from + walk through more test cases. Also, my solution took a lot of code for an easy but I'm sure there's Python solutions that only take one line."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "i\\'m not an alien and i can\\'t understand this \\uD83D\\uDE2D"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Greetings, fellow not an alien! I too cannot understand this. The letters of the problem are all mixed up in an order I do not understand."
                    },
                    {
                        "username": "dongliang14",
                        "content": "normally our dictionary is organzied/ordered by alphabetical order (\"abcdefghijklmnopqrstuvwxyz\"), but now they have new order"
                    },
                    {
                        "username": "zhakupov",
                        "content": "I am just trying to understand the problem. The first example is kind of weird to me.\\n`Input is : words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"`\\nand `output is true`. But if we check lexicographicaly the last letter of `\"hello\"` located in position `5` is \"o\" and `5th` letter of `\"leetcode\"` is `\"c\"`. Now if you check the given order letter `\"c\"` comes before the letter `\"o\"`. Then howcome the outcome can be true. Can anybody explain me what\\'s wrong with my thinking process and point out the misconception I am having?\\nGreatly appreciate your help!\\n\\nThanks"
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "I guess it is too late, but as in the real world dictionary words starting with \"A\" come before words starting with \"B\".  Similarly, the words need to be in the order provided, \"h\" preceeds \"l\" in the order so we need not to check other indexes. "
                    },
                    {
                        "username": "TuringJest",
                        "content": "<div><div class=\"text-brand-orange text-dark-brand-orange\">A simple way to understand this better, is to picture a string's lexicographic value as a float - with the first char as the integer part and the rest as the fractional part.\n<br><br><div class=\"text-lg\">Example:</div>\nhlabcdefgijkmnopqrst...\n<br>01234567891011 12 13 14 15 16 17 18 19...\n<br>\n<br><b>hello</b> -> 0 6 1 1 14 ->  <b>0 . 6 1 1 14</b>\n<br><b>leetcode</b> -> 1 6 6 19 4 14 5 6 -><b>1 . 6 6 19 4 14 5 6 </b>\n<br>(be aware of '14' and '19'. Let's imagine the float in <b>base26</b>, so any letter only takes up \"one decimal place\" - or correct in base26, a <b>hexavigesimal place</b>.)\n<br><br>Comparing both values it's easy to see that <b>1.6... > 0.6...</b>. \n<br><br>Ps. Don't get confused about base26, it's just there to make the float analogy mathematically correct. It's not needed for the mental model or the code.<div></div>"
                    },
                    {
                        "username": "sachindramishra204",
                        "content": "I would definitely recommend to move this problem to medium. The approach is not very intuitive!\n\nFOR YOUR HELP!\n-> If the first characters of two words are same, then only compare the adjacent characters. \n"
                    },
                    {
                        "username": "S_Basu",
                        "content": "#### ALIEN LEXICOGRAPHY\n*At first glance it seems difficult to understand what the question is trying to say or what exactly are we required to do?* The examples also seem confusing at first. \n- The most important terms that we need to focus on is \n> **\"lexicographically in this alien language\"**\n\nWe need to check if the given `words []` are **lexicographically arranged as per the Alien Dictionary**.\n- Eg: In **our human dictionary** Lexicographic order is $$A$$ *to* $$Z$$\n- But for the **Alien dictionary** the specific **`order`** is as given in each test case.\n- We need to check whether the given `words []` follow the $$Lexicographic$$ **`order` of the Aliens**."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[Link to Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Length check is a pain in ass. They haven\\'t even explained when testcase\\'s are passing and failing.\\nHow come this testcase is true.\\n```\\n[\"apap\",\"app\"]\\n\"abcdefghijklmnopqrstuvwxyz\"\\n```"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "you need to continue checking until both character are different here in this case ap == ap in both cases but next element is diff \\none has a other one has a p\\naccording to order a holds more values"
                    },
                    {
                        "username": "anjaliu949",
                        "content": "As the first two characters of both string \"apap\" and \"app\" are equal , so we have to check for the third one which is  'a' and 'p' and according to the order given 'a' should come before 'p' which is true. Hence, it is returning true.\nNOTE: We need not check for the rest of the characters as soon as we encounter first different characters from both the string."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "\"apap\" would go before \"app\" if the 2 words are put inside a physical human dictionary. (ie. lexicographically)"
                    },
                    {
                        "username": "drewbie",
                        "content": "A good test case to run\\n\\n`[\"a\", \"app\", \"apple\", \"appl\"]`"
                    }
                ]
            },
            {
                "id": 1784048,
                "content": [
                    {
                        "username": "sanjay_soni",
                        "content": "The ques is very simple.\\n\\nwe have given string order in which all 26 letters of English are not in correct order because its a Alien\\'s dictionary.\\n\\nwe have to check our words are in correct order or not according to this new dictionary.\\n\\nso first ,  map order with their index by using map<char,int> map.\\nthen pick first to words and compare their letter one by one.\\n\\nif it is in correct order then return true otherwise false.\\n\\ncheckout my solution from my profile"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "definitely not an easy problem ;3"
                    },
                    {
                        "username": "marcozylol",
                        "content": "I think what makes this problem \"easy\" is the constraints. Because of that you can make an algorithm that would normally be considered non-optimal. The words array is very small and the words aren't too large. Order can only be 26 characters, so any traversal of that can be thought of as constant time. However, its description is very wordy and not clear unless you read it many times. In a real interview I think it would be much easier to figure out what the problem is asking because you have someone to get clarifications from + walk through more test cases. Also, my solution took a lot of code for an easy but I'm sure there's Python solutions that only take one line."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "i\\'m not an alien and i can\\'t understand this \\uD83D\\uDE2D"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Greetings, fellow not an alien! I too cannot understand this. The letters of the problem are all mixed up in an order I do not understand."
                    },
                    {
                        "username": "dongliang14",
                        "content": "normally our dictionary is organzied/ordered by alphabetical order (\"abcdefghijklmnopqrstuvwxyz\"), but now they have new order"
                    },
                    {
                        "username": "zhakupov",
                        "content": "I am just trying to understand the problem. The first example is kind of weird to me.\\n`Input is : words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"`\\nand `output is true`. But if we check lexicographicaly the last letter of `\"hello\"` located in position `5` is \"o\" and `5th` letter of `\"leetcode\"` is `\"c\"`. Now if you check the given order letter `\"c\"` comes before the letter `\"o\"`. Then howcome the outcome can be true. Can anybody explain me what\\'s wrong with my thinking process and point out the misconception I am having?\\nGreatly appreciate your help!\\n\\nThanks"
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "I guess it is too late, but as in the real world dictionary words starting with \"A\" come before words starting with \"B\".  Similarly, the words need to be in the order provided, \"h\" preceeds \"l\" in the order so we need not to check other indexes. "
                    },
                    {
                        "username": "TuringJest",
                        "content": "<div><div class=\"text-brand-orange text-dark-brand-orange\">A simple way to understand this better, is to picture a string's lexicographic value as a float - with the first char as the integer part and the rest as the fractional part.\n<br><br><div class=\"text-lg\">Example:</div>\nhlabcdefgijkmnopqrst...\n<br>01234567891011 12 13 14 15 16 17 18 19...\n<br>\n<br><b>hello</b> -> 0 6 1 1 14 ->  <b>0 . 6 1 1 14</b>\n<br><b>leetcode</b> -> 1 6 6 19 4 14 5 6 -><b>1 . 6 6 19 4 14 5 6 </b>\n<br>(be aware of '14' and '19'. Let's imagine the float in <b>base26</b>, so any letter only takes up \"one decimal place\" - or correct in base26, a <b>hexavigesimal place</b>.)\n<br><br>Comparing both values it's easy to see that <b>1.6... > 0.6...</b>. \n<br><br>Ps. Don't get confused about base26, it's just there to make the float analogy mathematically correct. It's not needed for the mental model or the code.<div></div>"
                    },
                    {
                        "username": "sachindramishra204",
                        "content": "I would definitely recommend to move this problem to medium. The approach is not very intuitive!\n\nFOR YOUR HELP!\n-> If the first characters of two words are same, then only compare the adjacent characters. \n"
                    },
                    {
                        "username": "S_Basu",
                        "content": "#### ALIEN LEXICOGRAPHY\n*At first glance it seems difficult to understand what the question is trying to say or what exactly are we required to do?* The examples also seem confusing at first. \n- The most important terms that we need to focus on is \n> **\"lexicographically in this alien language\"**\n\nWe need to check if the given `words []` are **lexicographically arranged as per the Alien Dictionary**.\n- Eg: In **our human dictionary** Lexicographic order is $$A$$ *to* $$Z$$\n- But for the **Alien dictionary** the specific **`order`** is as given in each test case.\n- We need to check whether the given `words []` follow the $$Lexicographic$$ **`order` of the Aliens**."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[Link to Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Length check is a pain in ass. They haven\\'t even explained when testcase\\'s are passing and failing.\\nHow come this testcase is true.\\n```\\n[\"apap\",\"app\"]\\n\"abcdefghijklmnopqrstuvwxyz\"\\n```"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "you need to continue checking until both character are different here in this case ap == ap in both cases but next element is diff \\none has a other one has a p\\naccording to order a holds more values"
                    },
                    {
                        "username": "anjaliu949",
                        "content": "As the first two characters of both string \"apap\" and \"app\" are equal , so we have to check for the third one which is  'a' and 'p' and according to the order given 'a' should come before 'p' which is true. Hence, it is returning true.\nNOTE: We need not check for the rest of the characters as soon as we encounter first different characters from both the string."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "\"apap\" would go before \"app\" if the 2 words are put inside a physical human dictionary. (ie. lexicographically)"
                    },
                    {
                        "username": "drewbie",
                        "content": "A good test case to run\\n\\n`[\"a\", \"app\", \"apple\", \"appl\"]`"
                    }
                ]
            },
            {
                "id": 1573510,
                "content": [
                    {
                        "username": "sanjay_soni",
                        "content": "The ques is very simple.\\n\\nwe have given string order in which all 26 letters of English are not in correct order because its a Alien\\'s dictionary.\\n\\nwe have to check our words are in correct order or not according to this new dictionary.\\n\\nso first ,  map order with their index by using map<char,int> map.\\nthen pick first to words and compare their letter one by one.\\n\\nif it is in correct order then return true otherwise false.\\n\\ncheckout my solution from my profile"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "definitely not an easy problem ;3"
                    },
                    {
                        "username": "marcozylol",
                        "content": "I think what makes this problem \"easy\" is the constraints. Because of that you can make an algorithm that would normally be considered non-optimal. The words array is very small and the words aren't too large. Order can only be 26 characters, so any traversal of that can be thought of as constant time. However, its description is very wordy and not clear unless you read it many times. In a real interview I think it would be much easier to figure out what the problem is asking because you have someone to get clarifications from + walk through more test cases. Also, my solution took a lot of code for an easy but I'm sure there's Python solutions that only take one line."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "i\\'m not an alien and i can\\'t understand this \\uD83D\\uDE2D"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Greetings, fellow not an alien! I too cannot understand this. The letters of the problem are all mixed up in an order I do not understand."
                    },
                    {
                        "username": "dongliang14",
                        "content": "normally our dictionary is organzied/ordered by alphabetical order (\"abcdefghijklmnopqrstuvwxyz\"), but now they have new order"
                    },
                    {
                        "username": "zhakupov",
                        "content": "I am just trying to understand the problem. The first example is kind of weird to me.\\n`Input is : words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"`\\nand `output is true`. But if we check lexicographicaly the last letter of `\"hello\"` located in position `5` is \"o\" and `5th` letter of `\"leetcode\"` is `\"c\"`. Now if you check the given order letter `\"c\"` comes before the letter `\"o\"`. Then howcome the outcome can be true. Can anybody explain me what\\'s wrong with my thinking process and point out the misconception I am having?\\nGreatly appreciate your help!\\n\\nThanks"
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "I guess it is too late, but as in the real world dictionary words starting with \"A\" come before words starting with \"B\".  Similarly, the words need to be in the order provided, \"h\" preceeds \"l\" in the order so we need not to check other indexes. "
                    },
                    {
                        "username": "TuringJest",
                        "content": "<div><div class=\"text-brand-orange text-dark-brand-orange\">A simple way to understand this better, is to picture a string's lexicographic value as a float - with the first char as the integer part and the rest as the fractional part.\n<br><br><div class=\"text-lg\">Example:</div>\nhlabcdefgijkmnopqrst...\n<br>01234567891011 12 13 14 15 16 17 18 19...\n<br>\n<br><b>hello</b> -> 0 6 1 1 14 ->  <b>0 . 6 1 1 14</b>\n<br><b>leetcode</b> -> 1 6 6 19 4 14 5 6 -><b>1 . 6 6 19 4 14 5 6 </b>\n<br>(be aware of '14' and '19'. Let's imagine the float in <b>base26</b>, so any letter only takes up \"one decimal place\" - or correct in base26, a <b>hexavigesimal place</b>.)\n<br><br>Comparing both values it's easy to see that <b>1.6... > 0.6...</b>. \n<br><br>Ps. Don't get confused about base26, it's just there to make the float analogy mathematically correct. It's not needed for the mental model or the code.<div></div>"
                    },
                    {
                        "username": "sachindramishra204",
                        "content": "I would definitely recommend to move this problem to medium. The approach is not very intuitive!\n\nFOR YOUR HELP!\n-> If the first characters of two words are same, then only compare the adjacent characters. \n"
                    },
                    {
                        "username": "S_Basu",
                        "content": "#### ALIEN LEXICOGRAPHY\n*At first glance it seems difficult to understand what the question is trying to say or what exactly are we required to do?* The examples also seem confusing at first. \n- The most important terms that we need to focus on is \n> **\"lexicographically in this alien language\"**\n\nWe need to check if the given `words []` are **lexicographically arranged as per the Alien Dictionary**.\n- Eg: In **our human dictionary** Lexicographic order is $$A$$ *to* $$Z$$\n- But for the **Alien dictionary** the specific **`order`** is as given in each test case.\n- We need to check whether the given `words []` follow the $$Lexicographic$$ **`order` of the Aliens**."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[Link to Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Length check is a pain in ass. They haven\\'t even explained when testcase\\'s are passing and failing.\\nHow come this testcase is true.\\n```\\n[\"apap\",\"app\"]\\n\"abcdefghijklmnopqrstuvwxyz\"\\n```"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "you need to continue checking until both character are different here in this case ap == ap in both cases but next element is diff \\none has a other one has a p\\naccording to order a holds more values"
                    },
                    {
                        "username": "anjaliu949",
                        "content": "As the first two characters of both string \"apap\" and \"app\" are equal , so we have to check for the third one which is  'a' and 'p' and according to the order given 'a' should come before 'p' which is true. Hence, it is returning true.\nNOTE: We need not check for the rest of the characters as soon as we encounter first different characters from both the string."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "\"apap\" would go before \"app\" if the 2 words are put inside a physical human dictionary. (ie. lexicographically)"
                    },
                    {
                        "username": "drewbie",
                        "content": "A good test case to run\\n\\n`[\"a\", \"app\", \"apple\", \"appl\"]`"
                    }
                ]
            },
            {
                "id": 1785336,
                "content": [
                    {
                        "username": "sanjay_soni",
                        "content": "The ques is very simple.\\n\\nwe have given string order in which all 26 letters of English are not in correct order because its a Alien\\'s dictionary.\\n\\nwe have to check our words are in correct order or not according to this new dictionary.\\n\\nso first ,  map order with their index by using map<char,int> map.\\nthen pick first to words and compare their letter one by one.\\n\\nif it is in correct order then return true otherwise false.\\n\\ncheckout my solution from my profile"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "definitely not an easy problem ;3"
                    },
                    {
                        "username": "marcozylol",
                        "content": "I think what makes this problem \"easy\" is the constraints. Because of that you can make an algorithm that would normally be considered non-optimal. The words array is very small and the words aren't too large. Order can only be 26 characters, so any traversal of that can be thought of as constant time. However, its description is very wordy and not clear unless you read it many times. In a real interview I think it would be much easier to figure out what the problem is asking because you have someone to get clarifications from + walk through more test cases. Also, my solution took a lot of code for an easy but I'm sure there's Python solutions that only take one line."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "i\\'m not an alien and i can\\'t understand this \\uD83D\\uDE2D"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Greetings, fellow not an alien! I too cannot understand this. The letters of the problem are all mixed up in an order I do not understand."
                    },
                    {
                        "username": "dongliang14",
                        "content": "normally our dictionary is organzied/ordered by alphabetical order (\"abcdefghijklmnopqrstuvwxyz\"), but now they have new order"
                    },
                    {
                        "username": "zhakupov",
                        "content": "I am just trying to understand the problem. The first example is kind of weird to me.\\n`Input is : words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"`\\nand `output is true`. But if we check lexicographicaly the last letter of `\"hello\"` located in position `5` is \"o\" and `5th` letter of `\"leetcode\"` is `\"c\"`. Now if you check the given order letter `\"c\"` comes before the letter `\"o\"`. Then howcome the outcome can be true. Can anybody explain me what\\'s wrong with my thinking process and point out the misconception I am having?\\nGreatly appreciate your help!\\n\\nThanks"
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "I guess it is too late, but as in the real world dictionary words starting with \"A\" come before words starting with \"B\".  Similarly, the words need to be in the order provided, \"h\" preceeds \"l\" in the order so we need not to check other indexes. "
                    },
                    {
                        "username": "TuringJest",
                        "content": "<div><div class=\"text-brand-orange text-dark-brand-orange\">A simple way to understand this better, is to picture a string's lexicographic value as a float - with the first char as the integer part and the rest as the fractional part.\n<br><br><div class=\"text-lg\">Example:</div>\nhlabcdefgijkmnopqrst...\n<br>01234567891011 12 13 14 15 16 17 18 19...\n<br>\n<br><b>hello</b> -> 0 6 1 1 14 ->  <b>0 . 6 1 1 14</b>\n<br><b>leetcode</b> -> 1 6 6 19 4 14 5 6 -><b>1 . 6 6 19 4 14 5 6 </b>\n<br>(be aware of '14' and '19'. Let's imagine the float in <b>base26</b>, so any letter only takes up \"one decimal place\" - or correct in base26, a <b>hexavigesimal place</b>.)\n<br><br>Comparing both values it's easy to see that <b>1.6... > 0.6...</b>. \n<br><br>Ps. Don't get confused about base26, it's just there to make the float analogy mathematically correct. It's not needed for the mental model or the code.<div></div>"
                    },
                    {
                        "username": "sachindramishra204",
                        "content": "I would definitely recommend to move this problem to medium. The approach is not very intuitive!\n\nFOR YOUR HELP!\n-> If the first characters of two words are same, then only compare the adjacent characters. \n"
                    },
                    {
                        "username": "S_Basu",
                        "content": "#### ALIEN LEXICOGRAPHY\n*At first glance it seems difficult to understand what the question is trying to say or what exactly are we required to do?* The examples also seem confusing at first. \n- The most important terms that we need to focus on is \n> **\"lexicographically in this alien language\"**\n\nWe need to check if the given `words []` are **lexicographically arranged as per the Alien Dictionary**.\n- Eg: In **our human dictionary** Lexicographic order is $$A$$ *to* $$Z$$\n- But for the **Alien dictionary** the specific **`order`** is as given in each test case.\n- We need to check whether the given `words []` follow the $$Lexicographic$$ **`order` of the Aliens**."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[Link to Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Length check is a pain in ass. They haven\\'t even explained when testcase\\'s are passing and failing.\\nHow come this testcase is true.\\n```\\n[\"apap\",\"app\"]\\n\"abcdefghijklmnopqrstuvwxyz\"\\n```"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "you need to continue checking until both character are different here in this case ap == ap in both cases but next element is diff \\none has a other one has a p\\naccording to order a holds more values"
                    },
                    {
                        "username": "anjaliu949",
                        "content": "As the first two characters of both string \"apap\" and \"app\" are equal , so we have to check for the third one which is  'a' and 'p' and according to the order given 'a' should come before 'p' which is true. Hence, it is returning true.\nNOTE: We need not check for the rest of the characters as soon as we encounter first different characters from both the string."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "\"apap\" would go before \"app\" if the 2 words are put inside a physical human dictionary. (ie. lexicographically)"
                    },
                    {
                        "username": "drewbie",
                        "content": "A good test case to run\\n\\n`[\"a\", \"app\", \"apple\", \"appl\"]`"
                    }
                ]
            },
            {
                "id": 1785080,
                "content": [
                    {
                        "username": "sanjay_soni",
                        "content": "The ques is very simple.\\n\\nwe have given string order in which all 26 letters of English are not in correct order because its a Alien\\'s dictionary.\\n\\nwe have to check our words are in correct order or not according to this new dictionary.\\n\\nso first ,  map order with their index by using map<char,int> map.\\nthen pick first to words and compare their letter one by one.\\n\\nif it is in correct order then return true otherwise false.\\n\\ncheckout my solution from my profile"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "definitely not an easy problem ;3"
                    },
                    {
                        "username": "marcozylol",
                        "content": "I think what makes this problem \"easy\" is the constraints. Because of that you can make an algorithm that would normally be considered non-optimal. The words array is very small and the words aren't too large. Order can only be 26 characters, so any traversal of that can be thought of as constant time. However, its description is very wordy and not clear unless you read it many times. In a real interview I think it would be much easier to figure out what the problem is asking because you have someone to get clarifications from + walk through more test cases. Also, my solution took a lot of code for an easy but I'm sure there's Python solutions that only take one line."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "i\\'m not an alien and i can\\'t understand this \\uD83D\\uDE2D"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Greetings, fellow not an alien! I too cannot understand this. The letters of the problem are all mixed up in an order I do not understand."
                    },
                    {
                        "username": "dongliang14",
                        "content": "normally our dictionary is organzied/ordered by alphabetical order (\"abcdefghijklmnopqrstuvwxyz\"), but now they have new order"
                    },
                    {
                        "username": "zhakupov",
                        "content": "I am just trying to understand the problem. The first example is kind of weird to me.\\n`Input is : words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"`\\nand `output is true`. But if we check lexicographicaly the last letter of `\"hello\"` located in position `5` is \"o\" and `5th` letter of `\"leetcode\"` is `\"c\"`. Now if you check the given order letter `\"c\"` comes before the letter `\"o\"`. Then howcome the outcome can be true. Can anybody explain me what\\'s wrong with my thinking process and point out the misconception I am having?\\nGreatly appreciate your help!\\n\\nThanks"
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "I guess it is too late, but as in the real world dictionary words starting with \"A\" come before words starting with \"B\".  Similarly, the words need to be in the order provided, \"h\" preceeds \"l\" in the order so we need not to check other indexes. "
                    },
                    {
                        "username": "TuringJest",
                        "content": "<div><div class=\"text-brand-orange text-dark-brand-orange\">A simple way to understand this better, is to picture a string's lexicographic value as a float - with the first char as the integer part and the rest as the fractional part.\n<br><br><div class=\"text-lg\">Example:</div>\nhlabcdefgijkmnopqrst...\n<br>01234567891011 12 13 14 15 16 17 18 19...\n<br>\n<br><b>hello</b> -> 0 6 1 1 14 ->  <b>0 . 6 1 1 14</b>\n<br><b>leetcode</b> -> 1 6 6 19 4 14 5 6 -><b>1 . 6 6 19 4 14 5 6 </b>\n<br>(be aware of '14' and '19'. Let's imagine the float in <b>base26</b>, so any letter only takes up \"one decimal place\" - or correct in base26, a <b>hexavigesimal place</b>.)\n<br><br>Comparing both values it's easy to see that <b>1.6... > 0.6...</b>. \n<br><br>Ps. Don't get confused about base26, it's just there to make the float analogy mathematically correct. It's not needed for the mental model or the code.<div></div>"
                    },
                    {
                        "username": "sachindramishra204",
                        "content": "I would definitely recommend to move this problem to medium. The approach is not very intuitive!\n\nFOR YOUR HELP!\n-> If the first characters of two words are same, then only compare the adjacent characters. \n"
                    },
                    {
                        "username": "S_Basu",
                        "content": "#### ALIEN LEXICOGRAPHY\n*At first glance it seems difficult to understand what the question is trying to say or what exactly are we required to do?* The examples also seem confusing at first. \n- The most important terms that we need to focus on is \n> **\"lexicographically in this alien language\"**\n\nWe need to check if the given `words []` are **lexicographically arranged as per the Alien Dictionary**.\n- Eg: In **our human dictionary** Lexicographic order is $$A$$ *to* $$Z$$\n- But for the **Alien dictionary** the specific **`order`** is as given in each test case.\n- We need to check whether the given `words []` follow the $$Lexicographic$$ **`order` of the Aliens**."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[Link to Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Length check is a pain in ass. They haven\\'t even explained when testcase\\'s are passing and failing.\\nHow come this testcase is true.\\n```\\n[\"apap\",\"app\"]\\n\"abcdefghijklmnopqrstuvwxyz\"\\n```"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "you need to continue checking until both character are different here in this case ap == ap in both cases but next element is diff \\none has a other one has a p\\naccording to order a holds more values"
                    },
                    {
                        "username": "anjaliu949",
                        "content": "As the first two characters of both string \"apap\" and \"app\" are equal , so we have to check for the third one which is  'a' and 'p' and according to the order given 'a' should come before 'p' which is true. Hence, it is returning true.\nNOTE: We need not check for the rest of the characters as soon as we encounter first different characters from both the string."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "\"apap\" would go before \"app\" if the 2 words are put inside a physical human dictionary. (ie. lexicographically)"
                    },
                    {
                        "username": "drewbie",
                        "content": "A good test case to run\\n\\n`[\"a\", \"app\", \"apple\", \"appl\"]`"
                    }
                ]
            },
            {
                "id": 1784307,
                "content": [
                    {
                        "username": "sanjay_soni",
                        "content": "The ques is very simple.\\n\\nwe have given string order in which all 26 letters of English are not in correct order because its a Alien\\'s dictionary.\\n\\nwe have to check our words are in correct order or not according to this new dictionary.\\n\\nso first ,  map order with their index by using map<char,int> map.\\nthen pick first to words and compare their letter one by one.\\n\\nif it is in correct order then return true otherwise false.\\n\\ncheckout my solution from my profile"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "definitely not an easy problem ;3"
                    },
                    {
                        "username": "marcozylol",
                        "content": "I think what makes this problem \"easy\" is the constraints. Because of that you can make an algorithm that would normally be considered non-optimal. The words array is very small and the words aren't too large. Order can only be 26 characters, so any traversal of that can be thought of as constant time. However, its description is very wordy and not clear unless you read it many times. In a real interview I think it would be much easier to figure out what the problem is asking because you have someone to get clarifications from + walk through more test cases. Also, my solution took a lot of code for an easy but I'm sure there's Python solutions that only take one line."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "i\\'m not an alien and i can\\'t understand this \\uD83D\\uDE2D"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Greetings, fellow not an alien! I too cannot understand this. The letters of the problem are all mixed up in an order I do not understand."
                    },
                    {
                        "username": "dongliang14",
                        "content": "normally our dictionary is organzied/ordered by alphabetical order (\"abcdefghijklmnopqrstuvwxyz\"), but now they have new order"
                    },
                    {
                        "username": "zhakupov",
                        "content": "I am just trying to understand the problem. The first example is kind of weird to me.\\n`Input is : words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"`\\nand `output is true`. But if we check lexicographicaly the last letter of `\"hello\"` located in position `5` is \"o\" and `5th` letter of `\"leetcode\"` is `\"c\"`. Now if you check the given order letter `\"c\"` comes before the letter `\"o\"`. Then howcome the outcome can be true. Can anybody explain me what\\'s wrong with my thinking process and point out the misconception I am having?\\nGreatly appreciate your help!\\n\\nThanks"
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "I guess it is too late, but as in the real world dictionary words starting with \"A\" come before words starting with \"B\".  Similarly, the words need to be in the order provided, \"h\" preceeds \"l\" in the order so we need not to check other indexes. "
                    },
                    {
                        "username": "TuringJest",
                        "content": "<div><div class=\"text-brand-orange text-dark-brand-orange\">A simple way to understand this better, is to picture a string's lexicographic value as a float - with the first char as the integer part and the rest as the fractional part.\n<br><br><div class=\"text-lg\">Example:</div>\nhlabcdefgijkmnopqrst...\n<br>01234567891011 12 13 14 15 16 17 18 19...\n<br>\n<br><b>hello</b> -> 0 6 1 1 14 ->  <b>0 . 6 1 1 14</b>\n<br><b>leetcode</b> -> 1 6 6 19 4 14 5 6 -><b>1 . 6 6 19 4 14 5 6 </b>\n<br>(be aware of '14' and '19'. Let's imagine the float in <b>base26</b>, so any letter only takes up \"one decimal place\" - or correct in base26, a <b>hexavigesimal place</b>.)\n<br><br>Comparing both values it's easy to see that <b>1.6... > 0.6...</b>. \n<br><br>Ps. Don't get confused about base26, it's just there to make the float analogy mathematically correct. It's not needed for the mental model or the code.<div></div>"
                    },
                    {
                        "username": "sachindramishra204",
                        "content": "I would definitely recommend to move this problem to medium. The approach is not very intuitive!\n\nFOR YOUR HELP!\n-> If the first characters of two words are same, then only compare the adjacent characters. \n"
                    },
                    {
                        "username": "S_Basu",
                        "content": "#### ALIEN LEXICOGRAPHY\n*At first glance it seems difficult to understand what the question is trying to say or what exactly are we required to do?* The examples also seem confusing at first. \n- The most important terms that we need to focus on is \n> **\"lexicographically in this alien language\"**\n\nWe need to check if the given `words []` are **lexicographically arranged as per the Alien Dictionary**.\n- Eg: In **our human dictionary** Lexicographic order is $$A$$ *to* $$Z$$\n- But for the **Alien dictionary** the specific **`order`** is as given in each test case.\n- We need to check whether the given `words []` follow the $$Lexicographic$$ **`order` of the Aliens**."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[Link to Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Length check is a pain in ass. They haven\\'t even explained when testcase\\'s are passing and failing.\\nHow come this testcase is true.\\n```\\n[\"apap\",\"app\"]\\n\"abcdefghijklmnopqrstuvwxyz\"\\n```"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "you need to continue checking until both character are different here in this case ap == ap in both cases but next element is diff \\none has a other one has a p\\naccording to order a holds more values"
                    },
                    {
                        "username": "anjaliu949",
                        "content": "As the first two characters of both string \"apap\" and \"app\" are equal , so we have to check for the third one which is  'a' and 'p' and according to the order given 'a' should come before 'p' which is true. Hence, it is returning true.\nNOTE: We need not check for the rest of the characters as soon as we encounter first different characters from both the string."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "\"apap\" would go before \"app\" if the 2 words are put inside a physical human dictionary. (ie. lexicographically)"
                    },
                    {
                        "username": "drewbie",
                        "content": "A good test case to run\\n\\n`[\"a\", \"app\", \"apple\", \"appl\"]`"
                    }
                ]
            },
            {
                "id": 1784109,
                "content": [
                    {
                        "username": "sanjay_soni",
                        "content": "The ques is very simple.\\n\\nwe have given string order in which all 26 letters of English are not in correct order because its a Alien\\'s dictionary.\\n\\nwe have to check our words are in correct order or not according to this new dictionary.\\n\\nso first ,  map order with their index by using map<char,int> map.\\nthen pick first to words and compare their letter one by one.\\n\\nif it is in correct order then return true otherwise false.\\n\\ncheckout my solution from my profile"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "definitely not an easy problem ;3"
                    },
                    {
                        "username": "marcozylol",
                        "content": "I think what makes this problem \"easy\" is the constraints. Because of that you can make an algorithm that would normally be considered non-optimal. The words array is very small and the words aren't too large. Order can only be 26 characters, so any traversal of that can be thought of as constant time. However, its description is very wordy and not clear unless you read it many times. In a real interview I think it would be much easier to figure out what the problem is asking because you have someone to get clarifications from + walk through more test cases. Also, my solution took a lot of code for an easy but I'm sure there's Python solutions that only take one line."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "i\\'m not an alien and i can\\'t understand this \\uD83D\\uDE2D"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Greetings, fellow not an alien! I too cannot understand this. The letters of the problem are all mixed up in an order I do not understand."
                    },
                    {
                        "username": "dongliang14",
                        "content": "normally our dictionary is organzied/ordered by alphabetical order (\"abcdefghijklmnopqrstuvwxyz\"), but now they have new order"
                    },
                    {
                        "username": "zhakupov",
                        "content": "I am just trying to understand the problem. The first example is kind of weird to me.\\n`Input is : words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"`\\nand `output is true`. But if we check lexicographicaly the last letter of `\"hello\"` located in position `5` is \"o\" and `5th` letter of `\"leetcode\"` is `\"c\"`. Now if you check the given order letter `\"c\"` comes before the letter `\"o\"`. Then howcome the outcome can be true. Can anybody explain me what\\'s wrong with my thinking process and point out the misconception I am having?\\nGreatly appreciate your help!\\n\\nThanks"
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "I guess it is too late, but as in the real world dictionary words starting with \"A\" come before words starting with \"B\".  Similarly, the words need to be in the order provided, \"h\" preceeds \"l\" in the order so we need not to check other indexes. "
                    },
                    {
                        "username": "TuringJest",
                        "content": "<div><div class=\"text-brand-orange text-dark-brand-orange\">A simple way to understand this better, is to picture a string's lexicographic value as a float - with the first char as the integer part and the rest as the fractional part.\n<br><br><div class=\"text-lg\">Example:</div>\nhlabcdefgijkmnopqrst...\n<br>01234567891011 12 13 14 15 16 17 18 19...\n<br>\n<br><b>hello</b> -> 0 6 1 1 14 ->  <b>0 . 6 1 1 14</b>\n<br><b>leetcode</b> -> 1 6 6 19 4 14 5 6 -><b>1 . 6 6 19 4 14 5 6 </b>\n<br>(be aware of '14' and '19'. Let's imagine the float in <b>base26</b>, so any letter only takes up \"one decimal place\" - or correct in base26, a <b>hexavigesimal place</b>.)\n<br><br>Comparing both values it's easy to see that <b>1.6... > 0.6...</b>. \n<br><br>Ps. Don't get confused about base26, it's just there to make the float analogy mathematically correct. It's not needed for the mental model or the code.<div></div>"
                    },
                    {
                        "username": "sachindramishra204",
                        "content": "I would definitely recommend to move this problem to medium. The approach is not very intuitive!\n\nFOR YOUR HELP!\n-> If the first characters of two words are same, then only compare the adjacent characters. \n"
                    },
                    {
                        "username": "S_Basu",
                        "content": "#### ALIEN LEXICOGRAPHY\n*At first glance it seems difficult to understand what the question is trying to say or what exactly are we required to do?* The examples also seem confusing at first. \n- The most important terms that we need to focus on is \n> **\"lexicographically in this alien language\"**\n\nWe need to check if the given `words []` are **lexicographically arranged as per the Alien Dictionary**.\n- Eg: In **our human dictionary** Lexicographic order is $$A$$ *to* $$Z$$\n- But for the **Alien dictionary** the specific **`order`** is as given in each test case.\n- We need to check whether the given `words []` follow the $$Lexicographic$$ **`order` of the Aliens**."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[Link to Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Length check is a pain in ass. They haven\\'t even explained when testcase\\'s are passing and failing.\\nHow come this testcase is true.\\n```\\n[\"apap\",\"app\"]\\n\"abcdefghijklmnopqrstuvwxyz\"\\n```"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "you need to continue checking until both character are different here in this case ap == ap in both cases but next element is diff \\none has a other one has a p\\naccording to order a holds more values"
                    },
                    {
                        "username": "anjaliu949",
                        "content": "As the first two characters of both string \"apap\" and \"app\" are equal , so we have to check for the third one which is  'a' and 'p' and according to the order given 'a' should come before 'p' which is true. Hence, it is returning true.\nNOTE: We need not check for the rest of the characters as soon as we encounter first different characters from both the string."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "\"apap\" would go before \"app\" if the 2 words are put inside a physical human dictionary. (ie. lexicographically)"
                    },
                    {
                        "username": "drewbie",
                        "content": "A good test case to run\\n\\n`[\"a\", \"app\", \"apple\", \"appl\"]`"
                    }
                ]
            },
            {
                "id": 1783973,
                "content": [
                    {
                        "username": "sanjay_soni",
                        "content": "The ques is very simple.\\n\\nwe have given string order in which all 26 letters of English are not in correct order because its a Alien\\'s dictionary.\\n\\nwe have to check our words are in correct order or not according to this new dictionary.\\n\\nso first ,  map order with their index by using map<char,int> map.\\nthen pick first to words and compare their letter one by one.\\n\\nif it is in correct order then return true otherwise false.\\n\\ncheckout my solution from my profile"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "definitely not an easy problem ;3"
                    },
                    {
                        "username": "marcozylol",
                        "content": "I think what makes this problem \"easy\" is the constraints. Because of that you can make an algorithm that would normally be considered non-optimal. The words array is very small and the words aren't too large. Order can only be 26 characters, so any traversal of that can be thought of as constant time. However, its description is very wordy and not clear unless you read it many times. In a real interview I think it would be much easier to figure out what the problem is asking because you have someone to get clarifications from + walk through more test cases. Also, my solution took a lot of code for an easy but I'm sure there's Python solutions that only take one line."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "i\\'m not an alien and i can\\'t understand this \\uD83D\\uDE2D"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Greetings, fellow not an alien! I too cannot understand this. The letters of the problem are all mixed up in an order I do not understand."
                    },
                    {
                        "username": "dongliang14",
                        "content": "normally our dictionary is organzied/ordered by alphabetical order (\"abcdefghijklmnopqrstuvwxyz\"), but now they have new order"
                    },
                    {
                        "username": "zhakupov",
                        "content": "I am just trying to understand the problem. The first example is kind of weird to me.\\n`Input is : words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"`\\nand `output is true`. But if we check lexicographicaly the last letter of `\"hello\"` located in position `5` is \"o\" and `5th` letter of `\"leetcode\"` is `\"c\"`. Now if you check the given order letter `\"c\"` comes before the letter `\"o\"`. Then howcome the outcome can be true. Can anybody explain me what\\'s wrong with my thinking process and point out the misconception I am having?\\nGreatly appreciate your help!\\n\\nThanks"
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "I guess it is too late, but as in the real world dictionary words starting with \"A\" come before words starting with \"B\".  Similarly, the words need to be in the order provided, \"h\" preceeds \"l\" in the order so we need not to check other indexes. "
                    },
                    {
                        "username": "TuringJest",
                        "content": "<div><div class=\"text-brand-orange text-dark-brand-orange\">A simple way to understand this better, is to picture a string's lexicographic value as a float - with the first char as the integer part and the rest as the fractional part.\n<br><br><div class=\"text-lg\">Example:</div>\nhlabcdefgijkmnopqrst...\n<br>01234567891011 12 13 14 15 16 17 18 19...\n<br>\n<br><b>hello</b> -> 0 6 1 1 14 ->  <b>0 . 6 1 1 14</b>\n<br><b>leetcode</b> -> 1 6 6 19 4 14 5 6 -><b>1 . 6 6 19 4 14 5 6 </b>\n<br>(be aware of '14' and '19'. Let's imagine the float in <b>base26</b>, so any letter only takes up \"one decimal place\" - or correct in base26, a <b>hexavigesimal place</b>.)\n<br><br>Comparing both values it's easy to see that <b>1.6... > 0.6...</b>. \n<br><br>Ps. Don't get confused about base26, it's just there to make the float analogy mathematically correct. It's not needed for the mental model or the code.<div></div>"
                    },
                    {
                        "username": "sachindramishra204",
                        "content": "I would definitely recommend to move this problem to medium. The approach is not very intuitive!\n\nFOR YOUR HELP!\n-> If the first characters of two words are same, then only compare the adjacent characters. \n"
                    },
                    {
                        "username": "S_Basu",
                        "content": "#### ALIEN LEXICOGRAPHY\n*At first glance it seems difficult to understand what the question is trying to say or what exactly are we required to do?* The examples also seem confusing at first. \n- The most important terms that we need to focus on is \n> **\"lexicographically in this alien language\"**\n\nWe need to check if the given `words []` are **lexicographically arranged as per the Alien Dictionary**.\n- Eg: In **our human dictionary** Lexicographic order is $$A$$ *to* $$Z$$\n- But for the **Alien dictionary** the specific **`order`** is as given in each test case.\n- We need to check whether the given `words []` follow the $$Lexicographic$$ **`order` of the Aliens**."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[Link to Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Length check is a pain in ass. They haven\\'t even explained when testcase\\'s are passing and failing.\\nHow come this testcase is true.\\n```\\n[\"apap\",\"app\"]\\n\"abcdefghijklmnopqrstuvwxyz\"\\n```"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "you need to continue checking until both character are different here in this case ap == ap in both cases but next element is diff \\none has a other one has a p\\naccording to order a holds more values"
                    },
                    {
                        "username": "anjaliu949",
                        "content": "As the first two characters of both string \"apap\" and \"app\" are equal , so we have to check for the third one which is  'a' and 'p' and according to the order given 'a' should come before 'p' which is true. Hence, it is returning true.\nNOTE: We need not check for the rest of the characters as soon as we encounter first different characters from both the string."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "\"apap\" would go before \"app\" if the 2 words are put inside a physical human dictionary. (ie. lexicographically)"
                    },
                    {
                        "username": "drewbie",
                        "content": "A good test case to run\\n\\n`[\"a\", \"app\", \"apple\", \"appl\"]`"
                    }
                ]
            },
            {
                "id": 1576375,
                "content": [
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/808686db-23a8-4a48-8b30-0431c2de7f35_1644678606.8533213.jpeg)\\n"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Fuck this question i m copy pasting. Fuck off"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "its not that difficult tho but i do agree with u its annoying"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol, calm down man :))))))"
                    },
                    {
                        "username": "RedoUser",
                        "content": "The constraints make this an 'Easy' problem. Because of the the array size, you can get away with some pretty inefficient and smelly solutions (just look at mine..). If the array size was larger, this would be a much harder problem. \n\nIt is one of those problems that once you identify the trick, coming up with a solution is trivial. As usual, all the heavy lifting is done before a single key stroke."
                    },
                    {
                        "username": "user0582FY",
                        "content": "Please check your explanation, this is stroke inducing"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "an easy medium level question IMO"
                    },
                    {
                        "username": "SG-C",
                        "content": " It\\'s a question for aliens, I have no knowledge of this language."
                    },
                    {
                        "username": "18013e",
                        "content": "seems like you are using the \"alien word\" to describe this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Folks need to remember that questions can be intentionally vague. In the real world, you will not always be given clear problem definitions nor will you always have someone to ask for help. \n\nFor those struggling to understand the problem, how would you approach this if you were asked to check if an array of strings written in lowercase English is properly sorted? \n\nRealize that the second arg, order, is essentially a dictionary, or reference guide, to help you check whether or not the first arg, words, is sorted correctly according to the second arg."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**Focus On Edge Cases**"
                    },
                    {
                        "username": "Novice69",
                        "content": "its not easy"
                    }
                ]
            },
            {
                "id": 1784111,
                "content": [
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/808686db-23a8-4a48-8b30-0431c2de7f35_1644678606.8533213.jpeg)\\n"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Fuck this question i m copy pasting. Fuck off"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "its not that difficult tho but i do agree with u its annoying"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol, calm down man :))))))"
                    },
                    {
                        "username": "RedoUser",
                        "content": "The constraints make this an 'Easy' problem. Because of the the array size, you can get away with some pretty inefficient and smelly solutions (just look at mine..). If the array size was larger, this would be a much harder problem. \n\nIt is one of those problems that once you identify the trick, coming up with a solution is trivial. As usual, all the heavy lifting is done before a single key stroke."
                    },
                    {
                        "username": "user0582FY",
                        "content": "Please check your explanation, this is stroke inducing"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "an easy medium level question IMO"
                    },
                    {
                        "username": "SG-C",
                        "content": " It\\'s a question for aliens, I have no knowledge of this language."
                    },
                    {
                        "username": "18013e",
                        "content": "seems like you are using the \"alien word\" to describe this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Folks need to remember that questions can be intentionally vague. In the real world, you will not always be given clear problem definitions nor will you always have someone to ask for help. \n\nFor those struggling to understand the problem, how would you approach this if you were asked to check if an array of strings written in lowercase English is properly sorted? \n\nRealize that the second arg, order, is essentially a dictionary, or reference guide, to help you check whether or not the first arg, words, is sorted correctly according to the second arg."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**Focus On Edge Cases**"
                    },
                    {
                        "username": "Novice69",
                        "content": "its not easy"
                    }
                ]
            },
            {
                "id": 2038513,
                "content": [
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/808686db-23a8-4a48-8b30-0431c2de7f35_1644678606.8533213.jpeg)\\n"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Fuck this question i m copy pasting. Fuck off"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "its not that difficult tho but i do agree with u its annoying"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol, calm down man :))))))"
                    },
                    {
                        "username": "RedoUser",
                        "content": "The constraints make this an 'Easy' problem. Because of the the array size, you can get away with some pretty inefficient and smelly solutions (just look at mine..). If the array size was larger, this would be a much harder problem. \n\nIt is one of those problems that once you identify the trick, coming up with a solution is trivial. As usual, all the heavy lifting is done before a single key stroke."
                    },
                    {
                        "username": "user0582FY",
                        "content": "Please check your explanation, this is stroke inducing"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "an easy medium level question IMO"
                    },
                    {
                        "username": "SG-C",
                        "content": " It\\'s a question for aliens, I have no knowledge of this language."
                    },
                    {
                        "username": "18013e",
                        "content": "seems like you are using the \"alien word\" to describe this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Folks need to remember that questions can be intentionally vague. In the real world, you will not always be given clear problem definitions nor will you always have someone to ask for help. \n\nFor those struggling to understand the problem, how would you approach this if you were asked to check if an array of strings written in lowercase English is properly sorted? \n\nRealize that the second arg, order, is essentially a dictionary, or reference guide, to help you check whether or not the first arg, words, is sorted correctly according to the second arg."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**Focus On Edge Cases**"
                    },
                    {
                        "username": "Novice69",
                        "content": "its not easy"
                    }
                ]
            },
            {
                "id": 1997239,
                "content": [
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/808686db-23a8-4a48-8b30-0431c2de7f35_1644678606.8533213.jpeg)\\n"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Fuck this question i m copy pasting. Fuck off"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "its not that difficult tho but i do agree with u its annoying"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol, calm down man :))))))"
                    },
                    {
                        "username": "RedoUser",
                        "content": "The constraints make this an 'Easy' problem. Because of the the array size, you can get away with some pretty inefficient and smelly solutions (just look at mine..). If the array size was larger, this would be a much harder problem. \n\nIt is one of those problems that once you identify the trick, coming up with a solution is trivial. As usual, all the heavy lifting is done before a single key stroke."
                    },
                    {
                        "username": "user0582FY",
                        "content": "Please check your explanation, this is stroke inducing"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "an easy medium level question IMO"
                    },
                    {
                        "username": "SG-C",
                        "content": " It\\'s a question for aliens, I have no knowledge of this language."
                    },
                    {
                        "username": "18013e",
                        "content": "seems like you are using the \"alien word\" to describe this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Folks need to remember that questions can be intentionally vague. In the real world, you will not always be given clear problem definitions nor will you always have someone to ask for help. \n\nFor those struggling to understand the problem, how would you approach this if you were asked to check if an array of strings written in lowercase English is properly sorted? \n\nRealize that the second arg, order, is essentially a dictionary, or reference guide, to help you check whether or not the first arg, words, is sorted correctly according to the second arg."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**Focus On Edge Cases**"
                    },
                    {
                        "username": "Novice69",
                        "content": "its not easy"
                    }
                ]
            },
            {
                "id": 1967628,
                "content": [
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/808686db-23a8-4a48-8b30-0431c2de7f35_1644678606.8533213.jpeg)\\n"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Fuck this question i m copy pasting. Fuck off"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "its not that difficult tho but i do agree with u its annoying"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol, calm down man :))))))"
                    },
                    {
                        "username": "RedoUser",
                        "content": "The constraints make this an 'Easy' problem. Because of the the array size, you can get away with some pretty inefficient and smelly solutions (just look at mine..). If the array size was larger, this would be a much harder problem. \n\nIt is one of those problems that once you identify the trick, coming up with a solution is trivial. As usual, all the heavy lifting is done before a single key stroke."
                    },
                    {
                        "username": "user0582FY",
                        "content": "Please check your explanation, this is stroke inducing"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "an easy medium level question IMO"
                    },
                    {
                        "username": "SG-C",
                        "content": " It\\'s a question for aliens, I have no knowledge of this language."
                    },
                    {
                        "username": "18013e",
                        "content": "seems like you are using the \"alien word\" to describe this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Folks need to remember that questions can be intentionally vague. In the real world, you will not always be given clear problem definitions nor will you always have someone to ask for help. \n\nFor those struggling to understand the problem, how would you approach this if you were asked to check if an array of strings written in lowercase English is properly sorted? \n\nRealize that the second arg, order, is essentially a dictionary, or reference guide, to help you check whether or not the first arg, words, is sorted correctly according to the second arg."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**Focus On Edge Cases**"
                    },
                    {
                        "username": "Novice69",
                        "content": "its not easy"
                    }
                ]
            },
            {
                "id": 1964139,
                "content": [
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/808686db-23a8-4a48-8b30-0431c2de7f35_1644678606.8533213.jpeg)\\n"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Fuck this question i m copy pasting. Fuck off"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "its not that difficult tho but i do agree with u its annoying"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol, calm down man :))))))"
                    },
                    {
                        "username": "RedoUser",
                        "content": "The constraints make this an 'Easy' problem. Because of the the array size, you can get away with some pretty inefficient and smelly solutions (just look at mine..). If the array size was larger, this would be a much harder problem. \n\nIt is one of those problems that once you identify the trick, coming up with a solution is trivial. As usual, all the heavy lifting is done before a single key stroke."
                    },
                    {
                        "username": "user0582FY",
                        "content": "Please check your explanation, this is stroke inducing"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "an easy medium level question IMO"
                    },
                    {
                        "username": "SG-C",
                        "content": " It\\'s a question for aliens, I have no knowledge of this language."
                    },
                    {
                        "username": "18013e",
                        "content": "seems like you are using the \"alien word\" to describe this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Folks need to remember that questions can be intentionally vague. In the real world, you will not always be given clear problem definitions nor will you always have someone to ask for help. \n\nFor those struggling to understand the problem, how would you approach this if you were asked to check if an array of strings written in lowercase English is properly sorted? \n\nRealize that the second arg, order, is essentially a dictionary, or reference guide, to help you check whether or not the first arg, words, is sorted correctly according to the second arg."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**Focus On Edge Cases**"
                    },
                    {
                        "username": "Novice69",
                        "content": "its not easy"
                    }
                ]
            },
            {
                "id": 1941776,
                "content": [
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/808686db-23a8-4a48-8b30-0431c2de7f35_1644678606.8533213.jpeg)\\n"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Fuck this question i m copy pasting. Fuck off"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "its not that difficult tho but i do agree with u its annoying"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol, calm down man :))))))"
                    },
                    {
                        "username": "RedoUser",
                        "content": "The constraints make this an 'Easy' problem. Because of the the array size, you can get away with some pretty inefficient and smelly solutions (just look at mine..). If the array size was larger, this would be a much harder problem. \n\nIt is one of those problems that once you identify the trick, coming up with a solution is trivial. As usual, all the heavy lifting is done before a single key stroke."
                    },
                    {
                        "username": "user0582FY",
                        "content": "Please check your explanation, this is stroke inducing"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "an easy medium level question IMO"
                    },
                    {
                        "username": "SG-C",
                        "content": " It\\'s a question for aliens, I have no knowledge of this language."
                    },
                    {
                        "username": "18013e",
                        "content": "seems like you are using the \"alien word\" to describe this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Folks need to remember that questions can be intentionally vague. In the real world, you will not always be given clear problem definitions nor will you always have someone to ask for help. \n\nFor those struggling to understand the problem, how would you approach this if you were asked to check if an array of strings written in lowercase English is properly sorted? \n\nRealize that the second arg, order, is essentially a dictionary, or reference guide, to help you check whether or not the first arg, words, is sorted correctly according to the second arg."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**Focus On Edge Cases**"
                    },
                    {
                        "username": "Novice69",
                        "content": "its not easy"
                    }
                ]
            },
            {
                "id": 1936284,
                "content": [
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/808686db-23a8-4a48-8b30-0431c2de7f35_1644678606.8533213.jpeg)\\n"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Fuck this question i m copy pasting. Fuck off"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "its not that difficult tho but i do agree with u its annoying"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol, calm down man :))))))"
                    },
                    {
                        "username": "RedoUser",
                        "content": "The constraints make this an 'Easy' problem. Because of the the array size, you can get away with some pretty inefficient and smelly solutions (just look at mine..). If the array size was larger, this would be a much harder problem. \n\nIt is one of those problems that once you identify the trick, coming up with a solution is trivial. As usual, all the heavy lifting is done before a single key stroke."
                    },
                    {
                        "username": "user0582FY",
                        "content": "Please check your explanation, this is stroke inducing"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "an easy medium level question IMO"
                    },
                    {
                        "username": "SG-C",
                        "content": " It\\'s a question for aliens, I have no knowledge of this language."
                    },
                    {
                        "username": "18013e",
                        "content": "seems like you are using the \"alien word\" to describe this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Folks need to remember that questions can be intentionally vague. In the real world, you will not always be given clear problem definitions nor will you always have someone to ask for help. \n\nFor those struggling to understand the problem, how would you approach this if you were asked to check if an array of strings written in lowercase English is properly sorted? \n\nRealize that the second arg, order, is essentially a dictionary, or reference guide, to help you check whether or not the first arg, words, is sorted correctly according to the second arg."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**Focus On Edge Cases**"
                    },
                    {
                        "username": "Novice69",
                        "content": "its not easy"
                    }
                ]
            },
            {
                "id": 1933018,
                "content": [
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/808686db-23a8-4a48-8b30-0431c2de7f35_1644678606.8533213.jpeg)\\n"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Fuck this question i m copy pasting. Fuck off"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "its not that difficult tho but i do agree with u its annoying"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol, calm down man :))))))"
                    },
                    {
                        "username": "RedoUser",
                        "content": "The constraints make this an 'Easy' problem. Because of the the array size, you can get away with some pretty inefficient and smelly solutions (just look at mine..). If the array size was larger, this would be a much harder problem. \n\nIt is one of those problems that once you identify the trick, coming up with a solution is trivial. As usual, all the heavy lifting is done before a single key stroke."
                    },
                    {
                        "username": "user0582FY",
                        "content": "Please check your explanation, this is stroke inducing"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "an easy medium level question IMO"
                    },
                    {
                        "username": "SG-C",
                        "content": " It\\'s a question for aliens, I have no knowledge of this language."
                    },
                    {
                        "username": "18013e",
                        "content": "seems like you are using the \"alien word\" to describe this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Folks need to remember that questions can be intentionally vague. In the real world, you will not always be given clear problem definitions nor will you always have someone to ask for help. \n\nFor those struggling to understand the problem, how would you approach this if you were asked to check if an array of strings written in lowercase English is properly sorted? \n\nRealize that the second arg, order, is essentially a dictionary, or reference guide, to help you check whether or not the first arg, words, is sorted correctly according to the second arg."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**Focus On Edge Cases**"
                    },
                    {
                        "username": "Novice69",
                        "content": "its not easy"
                    }
                ]
            },
            {
                "id": 1919569,
                "content": [
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/808686db-23a8-4a48-8b30-0431c2de7f35_1644678606.8533213.jpeg)\\n"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Fuck this question i m copy pasting. Fuck off"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "its not that difficult tho but i do agree with u its annoying"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol, calm down man :))))))"
                    },
                    {
                        "username": "RedoUser",
                        "content": "The constraints make this an 'Easy' problem. Because of the the array size, you can get away with some pretty inefficient and smelly solutions (just look at mine..). If the array size was larger, this would be a much harder problem. \n\nIt is one of those problems that once you identify the trick, coming up with a solution is trivial. As usual, all the heavy lifting is done before a single key stroke."
                    },
                    {
                        "username": "user0582FY",
                        "content": "Please check your explanation, this is stroke inducing"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "an easy medium level question IMO"
                    },
                    {
                        "username": "SG-C",
                        "content": " It\\'s a question for aliens, I have no knowledge of this language."
                    },
                    {
                        "username": "18013e",
                        "content": "seems like you are using the \"alien word\" to describe this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Folks need to remember that questions can be intentionally vague. In the real world, you will not always be given clear problem definitions nor will you always have someone to ask for help. \n\nFor those struggling to understand the problem, how would you approach this if you were asked to check if an array of strings written in lowercase English is properly sorted? \n\nRealize that the second arg, order, is essentially a dictionary, or reference guide, to help you check whether or not the first arg, words, is sorted correctly according to the second arg."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**Focus On Edge Cases**"
                    },
                    {
                        "username": "Novice69",
                        "content": "its not easy"
                    }
                ]
            },
            {
                "id": 1862077,
                "content": [
                    {
                        "username": "Linkon-sid",
                        "content": "Confusing question. Description is not clear"
                    },
                    {
                        "username": "aman_kumar_20051949",
                        "content": "why i am getting two test cases not run\\nclass Solution {\\npublic:\\n  \\n    bool isAlienSorted(vector<string>& words, string order) {\\n       \\n    int row = words.size();\\n        int col = words[0].size();\\n        int order_size = order.size();\\n   \\n        for(int i = 0; i < row-1; i++){  //the row-1 were taken because  we are on n-2 and comparinbg with the n-1\\n            int j = 0;\\n            while(j < col && j < words[i+1].size()){ //HERE WE ARE COMPARING THE TWO STRINGS AND THEREFORE WE HAVE TO GIVE J IN BOTH CASE \\n                if(words[i][j] == words[i+1][j]){\\n                    j++;\\n                }\\n                else{\\n                    int  n = order.find(words[i][j]);\\n                    int m = order.find(words[i+1][j]);\\n                    if(n > m){\\n                        return false;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            \\n            \\n            if(j == words[i+1].size() && words[i].size() > words[i+1].size()){  //the word of the before must be grater than the word next than the next string therefor it will return ex-HELLOWORLD and HELLO \\n                return false;\\n            }\\n            \\n\\n        }  \\n    }\\n        return true;   \\n    }\\n};\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Understanding the question is more difficult than solving the actual problem  :/"
                    },
                    {
                        "username": "withrvr",
                        "content": "- Question is *HARD* to understand at *FIRST*\\n- many lines to code .... to write\\n- BUT:\\n  - its  Logic / Solution is\\n  - *** *VERY EASY*\\n"
                    },
                    {
                        "username": "longdogialong123",
                        "content": "finally, I solved this problem. Easy to get solution but pretty hard to understand exactly the question means."
                    },
                    {
                        "username": "aumo",
                        "content": "\"In an alien language, surprisingly, they also use English lowercase letters\"\\n\\ngotta love lc humor"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Here if we don\\'t use &w and &c then answer won\\'t come correct .. why??? and my cout<<e<<endl; is not printing anything\\n\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string> words, string order) {\\n        int mapping[26];\\n        for (int i = 0; i < 26; i++)\\n            mapping[order[i] - \\'a\\'] = i;  //alphabets are numbered from 1 to 25.\\n\\n        // for(auto e: mapping) cout<<e<<endl;\\n        for (string &w : words)\\n            for (char &c : w)\\n                c = mapping[c - \\'a\\'];\\n\\n        for(auto e:words) cout<<e<<endl;\\n        return is_sorted(words.begin(), words.end());\\n    }\\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This is a good problem that appears to be a bit more difficult than a medium but is simple once you break it down"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I usually go to the discussion section to find funny comments, and nothing found for today."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Should we not be using string operations? All the solutions I\\'ve seen are more complicated than what I did."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "[@BristolJ](/BristolJ) I did it in C++, and used a for loop that would go from i = 0 to the length of the words list - 1. I then check the words in the ith and ith - 1 position, go through each character, find the position of the character in the order string using .find(), compare the two values I find through .find(), then either break the while loop, return false, or increment the index that we check for each case."
                    },
                    {
                        "username": "BristolJ",
                        "content": "I think the fastest way to complete these is to use and int array since we are checking characters which java also treats as numbers.\\nI am curious about what you did to solve this though. What percent did you get for your time complexity?"
                    }
                ]
            },
            {
                "id": 1816508,
                "content": [
                    {
                        "username": "Linkon-sid",
                        "content": "Confusing question. Description is not clear"
                    },
                    {
                        "username": "aman_kumar_20051949",
                        "content": "why i am getting two test cases not run\\nclass Solution {\\npublic:\\n  \\n    bool isAlienSorted(vector<string>& words, string order) {\\n       \\n    int row = words.size();\\n        int col = words[0].size();\\n        int order_size = order.size();\\n   \\n        for(int i = 0; i < row-1; i++){  //the row-1 were taken because  we are on n-2 and comparinbg with the n-1\\n            int j = 0;\\n            while(j < col && j < words[i+1].size()){ //HERE WE ARE COMPARING THE TWO STRINGS AND THEREFORE WE HAVE TO GIVE J IN BOTH CASE \\n                if(words[i][j] == words[i+1][j]){\\n                    j++;\\n                }\\n                else{\\n                    int  n = order.find(words[i][j]);\\n                    int m = order.find(words[i+1][j]);\\n                    if(n > m){\\n                        return false;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            \\n            \\n            if(j == words[i+1].size() && words[i].size() > words[i+1].size()){  //the word of the before must be grater than the word next than the next string therefor it will return ex-HELLOWORLD and HELLO \\n                return false;\\n            }\\n            \\n\\n        }  \\n    }\\n        return true;   \\n    }\\n};\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Understanding the question is more difficult than solving the actual problem  :/"
                    },
                    {
                        "username": "withrvr",
                        "content": "- Question is *HARD* to understand at *FIRST*\\n- many lines to code .... to write\\n- BUT:\\n  - its  Logic / Solution is\\n  - *** *VERY EASY*\\n"
                    },
                    {
                        "username": "longdogialong123",
                        "content": "finally, I solved this problem. Easy to get solution but pretty hard to understand exactly the question means."
                    },
                    {
                        "username": "aumo",
                        "content": "\"In an alien language, surprisingly, they also use English lowercase letters\"\\n\\ngotta love lc humor"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Here if we don\\'t use &w and &c then answer won\\'t come correct .. why??? and my cout<<e<<endl; is not printing anything\\n\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string> words, string order) {\\n        int mapping[26];\\n        for (int i = 0; i < 26; i++)\\n            mapping[order[i] - \\'a\\'] = i;  //alphabets are numbered from 1 to 25.\\n\\n        // for(auto e: mapping) cout<<e<<endl;\\n        for (string &w : words)\\n            for (char &c : w)\\n                c = mapping[c - \\'a\\'];\\n\\n        for(auto e:words) cout<<e<<endl;\\n        return is_sorted(words.begin(), words.end());\\n    }\\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This is a good problem that appears to be a bit more difficult than a medium but is simple once you break it down"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I usually go to the discussion section to find funny comments, and nothing found for today."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Should we not be using string operations? All the solutions I\\'ve seen are more complicated than what I did."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "[@BristolJ](/BristolJ) I did it in C++, and used a for loop that would go from i = 0 to the length of the words list - 1. I then check the words in the ith and ith - 1 position, go through each character, find the position of the character in the order string using .find(), compare the two values I find through .find(), then either break the while loop, return false, or increment the index that we check for each case."
                    },
                    {
                        "username": "BristolJ",
                        "content": "I think the fastest way to complete these is to use and int array since we are checking characters which java also treats as numbers.\\nI am curious about what you did to solve this though. What percent did you get for your time complexity?"
                    }
                ]
            },
            {
                "id": 1795767,
                "content": [
                    {
                        "username": "Linkon-sid",
                        "content": "Confusing question. Description is not clear"
                    },
                    {
                        "username": "aman_kumar_20051949",
                        "content": "why i am getting two test cases not run\\nclass Solution {\\npublic:\\n  \\n    bool isAlienSorted(vector<string>& words, string order) {\\n       \\n    int row = words.size();\\n        int col = words[0].size();\\n        int order_size = order.size();\\n   \\n        for(int i = 0; i < row-1; i++){  //the row-1 were taken because  we are on n-2 and comparinbg with the n-1\\n            int j = 0;\\n            while(j < col && j < words[i+1].size()){ //HERE WE ARE COMPARING THE TWO STRINGS AND THEREFORE WE HAVE TO GIVE J IN BOTH CASE \\n                if(words[i][j] == words[i+1][j]){\\n                    j++;\\n                }\\n                else{\\n                    int  n = order.find(words[i][j]);\\n                    int m = order.find(words[i+1][j]);\\n                    if(n > m){\\n                        return false;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            \\n            \\n            if(j == words[i+1].size() && words[i].size() > words[i+1].size()){  //the word of the before must be grater than the word next than the next string therefor it will return ex-HELLOWORLD and HELLO \\n                return false;\\n            }\\n            \\n\\n        }  \\n    }\\n        return true;   \\n    }\\n};\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Understanding the question is more difficult than solving the actual problem  :/"
                    },
                    {
                        "username": "withrvr",
                        "content": "- Question is *HARD* to understand at *FIRST*\\n- many lines to code .... to write\\n- BUT:\\n  - its  Logic / Solution is\\n  - *** *VERY EASY*\\n"
                    },
                    {
                        "username": "longdogialong123",
                        "content": "finally, I solved this problem. Easy to get solution but pretty hard to understand exactly the question means."
                    },
                    {
                        "username": "aumo",
                        "content": "\"In an alien language, surprisingly, they also use English lowercase letters\"\\n\\ngotta love lc humor"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Here if we don\\'t use &w and &c then answer won\\'t come correct .. why??? and my cout<<e<<endl; is not printing anything\\n\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string> words, string order) {\\n        int mapping[26];\\n        for (int i = 0; i < 26; i++)\\n            mapping[order[i] - \\'a\\'] = i;  //alphabets are numbered from 1 to 25.\\n\\n        // for(auto e: mapping) cout<<e<<endl;\\n        for (string &w : words)\\n            for (char &c : w)\\n                c = mapping[c - \\'a\\'];\\n\\n        for(auto e:words) cout<<e<<endl;\\n        return is_sorted(words.begin(), words.end());\\n    }\\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This is a good problem that appears to be a bit more difficult than a medium but is simple once you break it down"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I usually go to the discussion section to find funny comments, and nothing found for today."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Should we not be using string operations? All the solutions I\\'ve seen are more complicated than what I did."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "[@BristolJ](/BristolJ) I did it in C++, and used a for loop that would go from i = 0 to the length of the words list - 1. I then check the words in the ith and ith - 1 position, go through each character, find the position of the character in the order string using .find(), compare the two values I find through .find(), then either break the while loop, return false, or increment the index that we check for each case."
                    },
                    {
                        "username": "BristolJ",
                        "content": "I think the fastest way to complete these is to use and int array since we are checking characters which java also treats as numbers.\\nI am curious about what you did to solve this though. What percent did you get for your time complexity?"
                    }
                ]
            },
            {
                "id": 1794575,
                "content": [
                    {
                        "username": "Linkon-sid",
                        "content": "Confusing question. Description is not clear"
                    },
                    {
                        "username": "aman_kumar_20051949",
                        "content": "why i am getting two test cases not run\\nclass Solution {\\npublic:\\n  \\n    bool isAlienSorted(vector<string>& words, string order) {\\n       \\n    int row = words.size();\\n        int col = words[0].size();\\n        int order_size = order.size();\\n   \\n        for(int i = 0; i < row-1; i++){  //the row-1 were taken because  we are on n-2 and comparinbg with the n-1\\n            int j = 0;\\n            while(j < col && j < words[i+1].size()){ //HERE WE ARE COMPARING THE TWO STRINGS AND THEREFORE WE HAVE TO GIVE J IN BOTH CASE \\n                if(words[i][j] == words[i+1][j]){\\n                    j++;\\n                }\\n                else{\\n                    int  n = order.find(words[i][j]);\\n                    int m = order.find(words[i+1][j]);\\n                    if(n > m){\\n                        return false;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            \\n            \\n            if(j == words[i+1].size() && words[i].size() > words[i+1].size()){  //the word of the before must be grater than the word next than the next string therefor it will return ex-HELLOWORLD and HELLO \\n                return false;\\n            }\\n            \\n\\n        }  \\n    }\\n        return true;   \\n    }\\n};\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Understanding the question is more difficult than solving the actual problem  :/"
                    },
                    {
                        "username": "withrvr",
                        "content": "- Question is *HARD* to understand at *FIRST*\\n- many lines to code .... to write\\n- BUT:\\n  - its  Logic / Solution is\\n  - *** *VERY EASY*\\n"
                    },
                    {
                        "username": "longdogialong123",
                        "content": "finally, I solved this problem. Easy to get solution but pretty hard to understand exactly the question means."
                    },
                    {
                        "username": "aumo",
                        "content": "\"In an alien language, surprisingly, they also use English lowercase letters\"\\n\\ngotta love lc humor"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Here if we don\\'t use &w and &c then answer won\\'t come correct .. why??? and my cout<<e<<endl; is not printing anything\\n\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string> words, string order) {\\n        int mapping[26];\\n        for (int i = 0; i < 26; i++)\\n            mapping[order[i] - \\'a\\'] = i;  //alphabets are numbered from 1 to 25.\\n\\n        // for(auto e: mapping) cout<<e<<endl;\\n        for (string &w : words)\\n            for (char &c : w)\\n                c = mapping[c - \\'a\\'];\\n\\n        for(auto e:words) cout<<e<<endl;\\n        return is_sorted(words.begin(), words.end());\\n    }\\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This is a good problem that appears to be a bit more difficult than a medium but is simple once you break it down"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I usually go to the discussion section to find funny comments, and nothing found for today."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Should we not be using string operations? All the solutions I\\'ve seen are more complicated than what I did."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "[@BristolJ](/BristolJ) I did it in C++, and used a for loop that would go from i = 0 to the length of the words list - 1. I then check the words in the ith and ith - 1 position, go through each character, find the position of the character in the order string using .find(), compare the two values I find through .find(), then either break the while loop, return false, or increment the index that we check for each case."
                    },
                    {
                        "username": "BristolJ",
                        "content": "I think the fastest way to complete these is to use and int array since we are checking characters which java also treats as numbers.\\nI am curious about what you did to solve this though. What percent did you get for your time complexity?"
                    }
                ]
            },
            {
                "id": 1785395,
                "content": [
                    {
                        "username": "Linkon-sid",
                        "content": "Confusing question. Description is not clear"
                    },
                    {
                        "username": "aman_kumar_20051949",
                        "content": "why i am getting two test cases not run\\nclass Solution {\\npublic:\\n  \\n    bool isAlienSorted(vector<string>& words, string order) {\\n       \\n    int row = words.size();\\n        int col = words[0].size();\\n        int order_size = order.size();\\n   \\n        for(int i = 0; i < row-1; i++){  //the row-1 were taken because  we are on n-2 and comparinbg with the n-1\\n            int j = 0;\\n            while(j < col && j < words[i+1].size()){ //HERE WE ARE COMPARING THE TWO STRINGS AND THEREFORE WE HAVE TO GIVE J IN BOTH CASE \\n                if(words[i][j] == words[i+1][j]){\\n                    j++;\\n                }\\n                else{\\n                    int  n = order.find(words[i][j]);\\n                    int m = order.find(words[i+1][j]);\\n                    if(n > m){\\n                        return false;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            \\n            \\n            if(j == words[i+1].size() && words[i].size() > words[i+1].size()){  //the word of the before must be grater than the word next than the next string therefor it will return ex-HELLOWORLD and HELLO \\n                return false;\\n            }\\n            \\n\\n        }  \\n    }\\n        return true;   \\n    }\\n};\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Understanding the question is more difficult than solving the actual problem  :/"
                    },
                    {
                        "username": "withrvr",
                        "content": "- Question is *HARD* to understand at *FIRST*\\n- many lines to code .... to write\\n- BUT:\\n  - its  Logic / Solution is\\n  - *** *VERY EASY*\\n"
                    },
                    {
                        "username": "longdogialong123",
                        "content": "finally, I solved this problem. Easy to get solution but pretty hard to understand exactly the question means."
                    },
                    {
                        "username": "aumo",
                        "content": "\"In an alien language, surprisingly, they also use English lowercase letters\"\\n\\ngotta love lc humor"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Here if we don\\'t use &w and &c then answer won\\'t come correct .. why??? and my cout<<e<<endl; is not printing anything\\n\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string> words, string order) {\\n        int mapping[26];\\n        for (int i = 0; i < 26; i++)\\n            mapping[order[i] - \\'a\\'] = i;  //alphabets are numbered from 1 to 25.\\n\\n        // for(auto e: mapping) cout<<e<<endl;\\n        for (string &w : words)\\n            for (char &c : w)\\n                c = mapping[c - \\'a\\'];\\n\\n        for(auto e:words) cout<<e<<endl;\\n        return is_sorted(words.begin(), words.end());\\n    }\\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This is a good problem that appears to be a bit more difficult than a medium but is simple once you break it down"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I usually go to the discussion section to find funny comments, and nothing found for today."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Should we not be using string operations? All the solutions I\\'ve seen are more complicated than what I did."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "[@BristolJ](/BristolJ) I did it in C++, and used a for loop that would go from i = 0 to the length of the words list - 1. I then check the words in the ith and ith - 1 position, go through each character, find the position of the character in the order string using .find(), compare the two values I find through .find(), then either break the while loop, return false, or increment the index that we check for each case."
                    },
                    {
                        "username": "BristolJ",
                        "content": "I think the fastest way to complete these is to use and int array since we are checking characters which java also treats as numbers.\\nI am curious about what you did to solve this though. What percent did you get for your time complexity?"
                    }
                ]
            },
            {
                "id": 1785349,
                "content": [
                    {
                        "username": "Linkon-sid",
                        "content": "Confusing question. Description is not clear"
                    },
                    {
                        "username": "aman_kumar_20051949",
                        "content": "why i am getting two test cases not run\\nclass Solution {\\npublic:\\n  \\n    bool isAlienSorted(vector<string>& words, string order) {\\n       \\n    int row = words.size();\\n        int col = words[0].size();\\n        int order_size = order.size();\\n   \\n        for(int i = 0; i < row-1; i++){  //the row-1 were taken because  we are on n-2 and comparinbg with the n-1\\n            int j = 0;\\n            while(j < col && j < words[i+1].size()){ //HERE WE ARE COMPARING THE TWO STRINGS AND THEREFORE WE HAVE TO GIVE J IN BOTH CASE \\n                if(words[i][j] == words[i+1][j]){\\n                    j++;\\n                }\\n                else{\\n                    int  n = order.find(words[i][j]);\\n                    int m = order.find(words[i+1][j]);\\n                    if(n > m){\\n                        return false;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            \\n            \\n            if(j == words[i+1].size() && words[i].size() > words[i+1].size()){  //the word of the before must be grater than the word next than the next string therefor it will return ex-HELLOWORLD and HELLO \\n                return false;\\n            }\\n            \\n\\n        }  \\n    }\\n        return true;   \\n    }\\n};\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Understanding the question is more difficult than solving the actual problem  :/"
                    },
                    {
                        "username": "withrvr",
                        "content": "- Question is *HARD* to understand at *FIRST*\\n- many lines to code .... to write\\n- BUT:\\n  - its  Logic / Solution is\\n  - *** *VERY EASY*\\n"
                    },
                    {
                        "username": "longdogialong123",
                        "content": "finally, I solved this problem. Easy to get solution but pretty hard to understand exactly the question means."
                    },
                    {
                        "username": "aumo",
                        "content": "\"In an alien language, surprisingly, they also use English lowercase letters\"\\n\\ngotta love lc humor"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Here if we don\\'t use &w and &c then answer won\\'t come correct .. why??? and my cout<<e<<endl; is not printing anything\\n\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string> words, string order) {\\n        int mapping[26];\\n        for (int i = 0; i < 26; i++)\\n            mapping[order[i] - \\'a\\'] = i;  //alphabets are numbered from 1 to 25.\\n\\n        // for(auto e: mapping) cout<<e<<endl;\\n        for (string &w : words)\\n            for (char &c : w)\\n                c = mapping[c - \\'a\\'];\\n\\n        for(auto e:words) cout<<e<<endl;\\n        return is_sorted(words.begin(), words.end());\\n    }\\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This is a good problem that appears to be a bit more difficult than a medium but is simple once you break it down"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I usually go to the discussion section to find funny comments, and nothing found for today."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Should we not be using string operations? All the solutions I\\'ve seen are more complicated than what I did."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "[@BristolJ](/BristolJ) I did it in C++, and used a for loop that would go from i = 0 to the length of the words list - 1. I then check the words in the ith and ith - 1 position, go through each character, find the position of the character in the order string using .find(), compare the two values I find through .find(), then either break the while loop, return false, or increment the index that we check for each case."
                    },
                    {
                        "username": "BristolJ",
                        "content": "I think the fastest way to complete these is to use and int array since we are checking characters which java also treats as numbers.\\nI am curious about what you did to solve this though. What percent did you get for your time complexity?"
                    }
                ]
            },
            {
                "id": 1785269,
                "content": [
                    {
                        "username": "Linkon-sid",
                        "content": "Confusing question. Description is not clear"
                    },
                    {
                        "username": "aman_kumar_20051949",
                        "content": "why i am getting two test cases not run\\nclass Solution {\\npublic:\\n  \\n    bool isAlienSorted(vector<string>& words, string order) {\\n       \\n    int row = words.size();\\n        int col = words[0].size();\\n        int order_size = order.size();\\n   \\n        for(int i = 0; i < row-1; i++){  //the row-1 were taken because  we are on n-2 and comparinbg with the n-1\\n            int j = 0;\\n            while(j < col && j < words[i+1].size()){ //HERE WE ARE COMPARING THE TWO STRINGS AND THEREFORE WE HAVE TO GIVE J IN BOTH CASE \\n                if(words[i][j] == words[i+1][j]){\\n                    j++;\\n                }\\n                else{\\n                    int  n = order.find(words[i][j]);\\n                    int m = order.find(words[i+1][j]);\\n                    if(n > m){\\n                        return false;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            \\n            \\n            if(j == words[i+1].size() && words[i].size() > words[i+1].size()){  //the word of the before must be grater than the word next than the next string therefor it will return ex-HELLOWORLD and HELLO \\n                return false;\\n            }\\n            \\n\\n        }  \\n    }\\n        return true;   \\n    }\\n};\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Understanding the question is more difficult than solving the actual problem  :/"
                    },
                    {
                        "username": "withrvr",
                        "content": "- Question is *HARD* to understand at *FIRST*\\n- many lines to code .... to write\\n- BUT:\\n  - its  Logic / Solution is\\n  - *** *VERY EASY*\\n"
                    },
                    {
                        "username": "longdogialong123",
                        "content": "finally, I solved this problem. Easy to get solution but pretty hard to understand exactly the question means."
                    },
                    {
                        "username": "aumo",
                        "content": "\"In an alien language, surprisingly, they also use English lowercase letters\"\\n\\ngotta love lc humor"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Here if we don\\'t use &w and &c then answer won\\'t come correct .. why??? and my cout<<e<<endl; is not printing anything\\n\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string> words, string order) {\\n        int mapping[26];\\n        for (int i = 0; i < 26; i++)\\n            mapping[order[i] - \\'a\\'] = i;  //alphabets are numbered from 1 to 25.\\n\\n        // for(auto e: mapping) cout<<e<<endl;\\n        for (string &w : words)\\n            for (char &c : w)\\n                c = mapping[c - \\'a\\'];\\n\\n        for(auto e:words) cout<<e<<endl;\\n        return is_sorted(words.begin(), words.end());\\n    }\\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This is a good problem that appears to be a bit more difficult than a medium but is simple once you break it down"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I usually go to the discussion section to find funny comments, and nothing found for today."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Should we not be using string operations? All the solutions I\\'ve seen are more complicated than what I did."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "[@BristolJ](/BristolJ) I did it in C++, and used a for loop that would go from i = 0 to the length of the words list - 1. I then check the words in the ith and ith - 1 position, go through each character, find the position of the character in the order string using .find(), compare the two values I find through .find(), then either break the while loop, return false, or increment the index that we check for each case."
                    },
                    {
                        "username": "BristolJ",
                        "content": "I think the fastest way to complete these is to use and int array since we are checking characters which java also treats as numbers.\\nI am curious about what you did to solve this though. What percent did you get for your time complexity?"
                    }
                ]
            },
            {
                "id": 1785265,
                "content": [
                    {
                        "username": "Linkon-sid",
                        "content": "Confusing question. Description is not clear"
                    },
                    {
                        "username": "aman_kumar_20051949",
                        "content": "why i am getting two test cases not run\\nclass Solution {\\npublic:\\n  \\n    bool isAlienSorted(vector<string>& words, string order) {\\n       \\n    int row = words.size();\\n        int col = words[0].size();\\n        int order_size = order.size();\\n   \\n        for(int i = 0; i < row-1; i++){  //the row-1 were taken because  we are on n-2 and comparinbg with the n-1\\n            int j = 0;\\n            while(j < col && j < words[i+1].size()){ //HERE WE ARE COMPARING THE TWO STRINGS AND THEREFORE WE HAVE TO GIVE J IN BOTH CASE \\n                if(words[i][j] == words[i+1][j]){\\n                    j++;\\n                }\\n                else{\\n                    int  n = order.find(words[i][j]);\\n                    int m = order.find(words[i+1][j]);\\n                    if(n > m){\\n                        return false;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            \\n            \\n            if(j == words[i+1].size() && words[i].size() > words[i+1].size()){  //the word of the before must be grater than the word next than the next string therefor it will return ex-HELLOWORLD and HELLO \\n                return false;\\n            }\\n            \\n\\n        }  \\n    }\\n        return true;   \\n    }\\n};\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Understanding the question is more difficult than solving the actual problem  :/"
                    },
                    {
                        "username": "withrvr",
                        "content": "- Question is *HARD* to understand at *FIRST*\\n- many lines to code .... to write\\n- BUT:\\n  - its  Logic / Solution is\\n  - *** *VERY EASY*\\n"
                    },
                    {
                        "username": "longdogialong123",
                        "content": "finally, I solved this problem. Easy to get solution but pretty hard to understand exactly the question means."
                    },
                    {
                        "username": "aumo",
                        "content": "\"In an alien language, surprisingly, they also use English lowercase letters\"\\n\\ngotta love lc humor"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Here if we don\\'t use &w and &c then answer won\\'t come correct .. why??? and my cout<<e<<endl; is not printing anything\\n\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string> words, string order) {\\n        int mapping[26];\\n        for (int i = 0; i < 26; i++)\\n            mapping[order[i] - \\'a\\'] = i;  //alphabets are numbered from 1 to 25.\\n\\n        // for(auto e: mapping) cout<<e<<endl;\\n        for (string &w : words)\\n            for (char &c : w)\\n                c = mapping[c - \\'a\\'];\\n\\n        for(auto e:words) cout<<e<<endl;\\n        return is_sorted(words.begin(), words.end());\\n    }\\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This is a good problem that appears to be a bit more difficult than a medium but is simple once you break it down"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I usually go to the discussion section to find funny comments, and nothing found for today."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Should we not be using string operations? All the solutions I\\'ve seen are more complicated than what I did."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "[@BristolJ](/BristolJ) I did it in C++, and used a for loop that would go from i = 0 to the length of the words list - 1. I then check the words in the ith and ith - 1 position, go through each character, find the position of the character in the order string using .find(), compare the two values I find through .find(), then either break the while loop, return false, or increment the index that we check for each case."
                    },
                    {
                        "username": "BristolJ",
                        "content": "I think the fastest way to complete these is to use and int array since we are checking characters which java also treats as numbers.\\nI am curious about what you did to solve this though. What percent did you get for your time complexity?"
                    }
                ]
            },
            {
                "id": 1785261,
                "content": [
                    {
                        "username": "Linkon-sid",
                        "content": "Confusing question. Description is not clear"
                    },
                    {
                        "username": "aman_kumar_20051949",
                        "content": "why i am getting two test cases not run\\nclass Solution {\\npublic:\\n  \\n    bool isAlienSorted(vector<string>& words, string order) {\\n       \\n    int row = words.size();\\n        int col = words[0].size();\\n        int order_size = order.size();\\n   \\n        for(int i = 0; i < row-1; i++){  //the row-1 were taken because  we are on n-2 and comparinbg with the n-1\\n            int j = 0;\\n            while(j < col && j < words[i+1].size()){ //HERE WE ARE COMPARING THE TWO STRINGS AND THEREFORE WE HAVE TO GIVE J IN BOTH CASE \\n                if(words[i][j] == words[i+1][j]){\\n                    j++;\\n                }\\n                else{\\n                    int  n = order.find(words[i][j]);\\n                    int m = order.find(words[i+1][j]);\\n                    if(n > m){\\n                        return false;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            \\n            \\n            if(j == words[i+1].size() && words[i].size() > words[i+1].size()){  //the word of the before must be grater than the word next than the next string therefor it will return ex-HELLOWORLD and HELLO \\n                return false;\\n            }\\n            \\n\\n        }  \\n    }\\n        return true;   \\n    }\\n};\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Understanding the question is more difficult than solving the actual problem  :/"
                    },
                    {
                        "username": "withrvr",
                        "content": "- Question is *HARD* to understand at *FIRST*\\n- many lines to code .... to write\\n- BUT:\\n  - its  Logic / Solution is\\n  - *** *VERY EASY*\\n"
                    },
                    {
                        "username": "longdogialong123",
                        "content": "finally, I solved this problem. Easy to get solution but pretty hard to understand exactly the question means."
                    },
                    {
                        "username": "aumo",
                        "content": "\"In an alien language, surprisingly, they also use English lowercase letters\"\\n\\ngotta love lc humor"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Here if we don\\'t use &w and &c then answer won\\'t come correct .. why??? and my cout<<e<<endl; is not printing anything\\n\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string> words, string order) {\\n        int mapping[26];\\n        for (int i = 0; i < 26; i++)\\n            mapping[order[i] - \\'a\\'] = i;  //alphabets are numbered from 1 to 25.\\n\\n        // for(auto e: mapping) cout<<e<<endl;\\n        for (string &w : words)\\n            for (char &c : w)\\n                c = mapping[c - \\'a\\'];\\n\\n        for(auto e:words) cout<<e<<endl;\\n        return is_sorted(words.begin(), words.end());\\n    }\\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This is a good problem that appears to be a bit more difficult than a medium but is simple once you break it down"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I usually go to the discussion section to find funny comments, and nothing found for today."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Should we not be using string operations? All the solutions I\\'ve seen are more complicated than what I did."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "[@BristolJ](/BristolJ) I did it in C++, and used a for loop that would go from i = 0 to the length of the words list - 1. I then check the words in the ith and ith - 1 position, go through each character, find the position of the character in the order string using .find(), compare the two values I find through .find(), then either break the while loop, return false, or increment the index that we check for each case."
                    },
                    {
                        "username": "BristolJ",
                        "content": "I think the fastest way to complete these is to use and int array since we are checking characters which java also treats as numbers.\\nI am curious about what you did to solve this though. What percent did you get for your time complexity?"
                    }
                ]
            },
            {
                "id": 1785258,
                "content": [
                    {
                        "username": "Linkon-sid",
                        "content": "Confusing question. Description is not clear"
                    },
                    {
                        "username": "aman_kumar_20051949",
                        "content": "why i am getting two test cases not run\\nclass Solution {\\npublic:\\n  \\n    bool isAlienSorted(vector<string>& words, string order) {\\n       \\n    int row = words.size();\\n        int col = words[0].size();\\n        int order_size = order.size();\\n   \\n        for(int i = 0; i < row-1; i++){  //the row-1 were taken because  we are on n-2 and comparinbg with the n-1\\n            int j = 0;\\n            while(j < col && j < words[i+1].size()){ //HERE WE ARE COMPARING THE TWO STRINGS AND THEREFORE WE HAVE TO GIVE J IN BOTH CASE \\n                if(words[i][j] == words[i+1][j]){\\n                    j++;\\n                }\\n                else{\\n                    int  n = order.find(words[i][j]);\\n                    int m = order.find(words[i+1][j]);\\n                    if(n > m){\\n                        return false;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            \\n            \\n            if(j == words[i+1].size() && words[i].size() > words[i+1].size()){  //the word of the before must be grater than the word next than the next string therefor it will return ex-HELLOWORLD and HELLO \\n                return false;\\n            }\\n            \\n\\n        }  \\n    }\\n        return true;   \\n    }\\n};\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Understanding the question is more difficult than solving the actual problem  :/"
                    },
                    {
                        "username": "withrvr",
                        "content": "- Question is *HARD* to understand at *FIRST*\\n- many lines to code .... to write\\n- BUT:\\n  - its  Logic / Solution is\\n  - *** *VERY EASY*\\n"
                    },
                    {
                        "username": "longdogialong123",
                        "content": "finally, I solved this problem. Easy to get solution but pretty hard to understand exactly the question means."
                    },
                    {
                        "username": "aumo",
                        "content": "\"In an alien language, surprisingly, they also use English lowercase letters\"\\n\\ngotta love lc humor"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Here if we don\\'t use &w and &c then answer won\\'t come correct .. why??? and my cout<<e<<endl; is not printing anything\\n\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string> words, string order) {\\n        int mapping[26];\\n        for (int i = 0; i < 26; i++)\\n            mapping[order[i] - \\'a\\'] = i;  //alphabets are numbered from 1 to 25.\\n\\n        // for(auto e: mapping) cout<<e<<endl;\\n        for (string &w : words)\\n            for (char &c : w)\\n                c = mapping[c - \\'a\\'];\\n\\n        for(auto e:words) cout<<e<<endl;\\n        return is_sorted(words.begin(), words.end());\\n    }\\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This is a good problem that appears to be a bit more difficult than a medium but is simple once you break it down"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I usually go to the discussion section to find funny comments, and nothing found for today."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Should we not be using string operations? All the solutions I\\'ve seen are more complicated than what I did."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "[@BristolJ](/BristolJ) I did it in C++, and used a for loop that would go from i = 0 to the length of the words list - 1. I then check the words in the ith and ith - 1 position, go through each character, find the position of the character in the order string using .find(), compare the two values I find through .find(), then either break the while loop, return false, or increment the index that we check for each case."
                    },
                    {
                        "username": "BristolJ",
                        "content": "I think the fastest way to complete these is to use and int array since we are checking characters which java also treats as numbers.\\nI am curious about what you did to solve this though. What percent did you get for your time complexity?"
                    }
                ]
            },
            {
                "id": 1785164,
                "content": [
                    {
                        "username": "Asadbek525",
                        "content": "I think this is medium problem."
                    },
                    {
                        "username": "t_Mz",
                        "content": "This question can be categorize into medium level ques and ques can be explained in better way... Discussion section really helps me in such situation, after giving thought and reading comments, finally able to solve it.\\n\\nkey point: \\n>Check whole word only when first letter of adjacent word is equal else you move ahead if it is in sorted manner and if not then return false.\\n\\n>Also check for edge cases like 3rd example of ques."
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string>& words, string order) {\\n      int arr[26];\\n      for(int i=0;i<26;i++){\\n          arr[order[i]-\\'a\\']=i;\\n}\\nfor(int i=1;i<words.size();i++){\\n    int n = min(words[i].size(),words[i-1].size());\\n    for(int j=0;j<n;j++){\\n        if(words[i][j] != words[i-1][j]){\\n        if(arr[words[i][j]-\\'a\\'] < arr[words[i-1][j]-\\'a\\'] ){\\n            return false;\\n        }\\n        break;\\n        }\\n    }\\n    if(words[i-1].length()>words[i].length() && words[i-1].substr(0,words[i].length()) == words[i] )\\n    return false;\\n} return true; \\n    }\\n};"
                    },
                    {
                        "username": "20k32",
                        "content": "words \\n\"mtkwpj\", \"wlaees\"\\norder\\n\"evhadxsqukcogztlnfjpiymbwr\"\\nOutput - false\\nExpected - true\\n\\nm < w = true\\nt < l = true\\nk < a = false, its not sorted, why expected - true?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "yes its sorting problem m<w is sufficient for example in dictionary apple<book because a<b"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "`m < w` is enough to validate this test case, you don\\'t need further verifications. "
                    },
                    {
                        "username": "S_Basu",
                        "content": "[Link to Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Dealing with aliens is not \\'EASY\\'...it should be atleast medium"
                    },
                    {
                        "username": "heygauri",
                        "content": "I am still not getting the question. Feeling like an alien"
                    },
                    {
                        "username": "S_Basu",
                        "content": "- [Small Hint](https://leetcode.com/problems/verifying-an-alien-dictionary/discussion/comments/1784307)\n- [Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)\n*Hope it helps*"
                    },
                    {
                        "username": "space_invader",
                        "content": "Do not forget to strike off properly ordered words (looking backwards)."
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "Aliens plz take back your dictionary  T_T"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "The description of the question feels more alien."
                    }
                ]
            },
            {
                "id": 1785117,
                "content": [
                    {
                        "username": "Asadbek525",
                        "content": "I think this is medium problem."
                    },
                    {
                        "username": "t_Mz",
                        "content": "This question can be categorize into medium level ques and ques can be explained in better way... Discussion section really helps me in such situation, after giving thought and reading comments, finally able to solve it.\\n\\nkey point: \\n>Check whole word only when first letter of adjacent word is equal else you move ahead if it is in sorted manner and if not then return false.\\n\\n>Also check for edge cases like 3rd example of ques."
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string>& words, string order) {\\n      int arr[26];\\n      for(int i=0;i<26;i++){\\n          arr[order[i]-\\'a\\']=i;\\n}\\nfor(int i=1;i<words.size();i++){\\n    int n = min(words[i].size(),words[i-1].size());\\n    for(int j=0;j<n;j++){\\n        if(words[i][j] != words[i-1][j]){\\n        if(arr[words[i][j]-\\'a\\'] < arr[words[i-1][j]-\\'a\\'] ){\\n            return false;\\n        }\\n        break;\\n        }\\n    }\\n    if(words[i-1].length()>words[i].length() && words[i-1].substr(0,words[i].length()) == words[i] )\\n    return false;\\n} return true; \\n    }\\n};"
                    },
                    {
                        "username": "20k32",
                        "content": "words \\n\"mtkwpj\", \"wlaees\"\\norder\\n\"evhadxsqukcogztlnfjpiymbwr\"\\nOutput - false\\nExpected - true\\n\\nm < w = true\\nt < l = true\\nk < a = false, its not sorted, why expected - true?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "yes its sorting problem m<w is sufficient for example in dictionary apple<book because a<b"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "`m < w` is enough to validate this test case, you don\\'t need further verifications. "
                    },
                    {
                        "username": "S_Basu",
                        "content": "[Link to Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Dealing with aliens is not \\'EASY\\'...it should be atleast medium"
                    },
                    {
                        "username": "heygauri",
                        "content": "I am still not getting the question. Feeling like an alien"
                    },
                    {
                        "username": "S_Basu",
                        "content": "- [Small Hint](https://leetcode.com/problems/verifying-an-alien-dictionary/discussion/comments/1784307)\n- [Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)\n*Hope it helps*"
                    },
                    {
                        "username": "space_invader",
                        "content": "Do not forget to strike off properly ordered words (looking backwards)."
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "Aliens plz take back your dictionary  T_T"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "The description of the question feels more alien."
                    }
                ]
            },
            {
                "id": 1785104,
                "content": [
                    {
                        "username": "Asadbek525",
                        "content": "I think this is medium problem."
                    },
                    {
                        "username": "t_Mz",
                        "content": "This question can be categorize into medium level ques and ques can be explained in better way... Discussion section really helps me in such situation, after giving thought and reading comments, finally able to solve it.\\n\\nkey point: \\n>Check whole word only when first letter of adjacent word is equal else you move ahead if it is in sorted manner and if not then return false.\\n\\n>Also check for edge cases like 3rd example of ques."
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string>& words, string order) {\\n      int arr[26];\\n      for(int i=0;i<26;i++){\\n          arr[order[i]-\\'a\\']=i;\\n}\\nfor(int i=1;i<words.size();i++){\\n    int n = min(words[i].size(),words[i-1].size());\\n    for(int j=0;j<n;j++){\\n        if(words[i][j] != words[i-1][j]){\\n        if(arr[words[i][j]-\\'a\\'] < arr[words[i-1][j]-\\'a\\'] ){\\n            return false;\\n        }\\n        break;\\n        }\\n    }\\n    if(words[i-1].length()>words[i].length() && words[i-1].substr(0,words[i].length()) == words[i] )\\n    return false;\\n} return true; \\n    }\\n};"
                    },
                    {
                        "username": "20k32",
                        "content": "words \\n\"mtkwpj\", \"wlaees\"\\norder\\n\"evhadxsqukcogztlnfjpiymbwr\"\\nOutput - false\\nExpected - true\\n\\nm < w = true\\nt < l = true\\nk < a = false, its not sorted, why expected - true?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "yes its sorting problem m<w is sufficient for example in dictionary apple<book because a<b"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "`m < w` is enough to validate this test case, you don\\'t need further verifications. "
                    },
                    {
                        "username": "S_Basu",
                        "content": "[Link to Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Dealing with aliens is not \\'EASY\\'...it should be atleast medium"
                    },
                    {
                        "username": "heygauri",
                        "content": "I am still not getting the question. Feeling like an alien"
                    },
                    {
                        "username": "S_Basu",
                        "content": "- [Small Hint](https://leetcode.com/problems/verifying-an-alien-dictionary/discussion/comments/1784307)\n- [Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)\n*Hope it helps*"
                    },
                    {
                        "username": "space_invader",
                        "content": "Do not forget to strike off properly ordered words (looking backwards)."
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "Aliens plz take back your dictionary  T_T"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "The description of the question feels more alien."
                    }
                ]
            },
            {
                "id": 1785101,
                "content": [
                    {
                        "username": "Asadbek525",
                        "content": "I think this is medium problem."
                    },
                    {
                        "username": "t_Mz",
                        "content": "This question can be categorize into medium level ques and ques can be explained in better way... Discussion section really helps me in such situation, after giving thought and reading comments, finally able to solve it.\\n\\nkey point: \\n>Check whole word only when first letter of adjacent word is equal else you move ahead if it is in sorted manner and if not then return false.\\n\\n>Also check for edge cases like 3rd example of ques."
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string>& words, string order) {\\n      int arr[26];\\n      for(int i=0;i<26;i++){\\n          arr[order[i]-\\'a\\']=i;\\n}\\nfor(int i=1;i<words.size();i++){\\n    int n = min(words[i].size(),words[i-1].size());\\n    for(int j=0;j<n;j++){\\n        if(words[i][j] != words[i-1][j]){\\n        if(arr[words[i][j]-\\'a\\'] < arr[words[i-1][j]-\\'a\\'] ){\\n            return false;\\n        }\\n        break;\\n        }\\n    }\\n    if(words[i-1].length()>words[i].length() && words[i-1].substr(0,words[i].length()) == words[i] )\\n    return false;\\n} return true; \\n    }\\n};"
                    },
                    {
                        "username": "20k32",
                        "content": "words \\n\"mtkwpj\", \"wlaees\"\\norder\\n\"evhadxsqukcogztlnfjpiymbwr\"\\nOutput - false\\nExpected - true\\n\\nm < w = true\\nt < l = true\\nk < a = false, its not sorted, why expected - true?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "yes its sorting problem m<w is sufficient for example in dictionary apple<book because a<b"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "`m < w` is enough to validate this test case, you don\\'t need further verifications. "
                    },
                    {
                        "username": "S_Basu",
                        "content": "[Link to Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Dealing with aliens is not \\'EASY\\'...it should be atleast medium"
                    },
                    {
                        "username": "heygauri",
                        "content": "I am still not getting the question. Feeling like an alien"
                    },
                    {
                        "username": "S_Basu",
                        "content": "- [Small Hint](https://leetcode.com/problems/verifying-an-alien-dictionary/discussion/comments/1784307)\n- [Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)\n*Hope it helps*"
                    },
                    {
                        "username": "space_invader",
                        "content": "Do not forget to strike off properly ordered words (looking backwards)."
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "Aliens plz take back your dictionary  T_T"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "The description of the question feels more alien."
                    }
                ]
            },
            {
                "id": 1785029,
                "content": [
                    {
                        "username": "Asadbek525",
                        "content": "I think this is medium problem."
                    },
                    {
                        "username": "t_Mz",
                        "content": "This question can be categorize into medium level ques and ques can be explained in better way... Discussion section really helps me in such situation, after giving thought and reading comments, finally able to solve it.\\n\\nkey point: \\n>Check whole word only when first letter of adjacent word is equal else you move ahead if it is in sorted manner and if not then return false.\\n\\n>Also check for edge cases like 3rd example of ques."
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string>& words, string order) {\\n      int arr[26];\\n      for(int i=0;i<26;i++){\\n          arr[order[i]-\\'a\\']=i;\\n}\\nfor(int i=1;i<words.size();i++){\\n    int n = min(words[i].size(),words[i-1].size());\\n    for(int j=0;j<n;j++){\\n        if(words[i][j] != words[i-1][j]){\\n        if(arr[words[i][j]-\\'a\\'] < arr[words[i-1][j]-\\'a\\'] ){\\n            return false;\\n        }\\n        break;\\n        }\\n    }\\n    if(words[i-1].length()>words[i].length() && words[i-1].substr(0,words[i].length()) == words[i] )\\n    return false;\\n} return true; \\n    }\\n};"
                    },
                    {
                        "username": "20k32",
                        "content": "words \\n\"mtkwpj\", \"wlaees\"\\norder\\n\"evhadxsqukcogztlnfjpiymbwr\"\\nOutput - false\\nExpected - true\\n\\nm < w = true\\nt < l = true\\nk < a = false, its not sorted, why expected - true?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "yes its sorting problem m<w is sufficient for example in dictionary apple<book because a<b"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "`m < w` is enough to validate this test case, you don\\'t need further verifications. "
                    },
                    {
                        "username": "S_Basu",
                        "content": "[Link to Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Dealing with aliens is not \\'EASY\\'...it should be atleast medium"
                    },
                    {
                        "username": "heygauri",
                        "content": "I am still not getting the question. Feeling like an alien"
                    },
                    {
                        "username": "S_Basu",
                        "content": "- [Small Hint](https://leetcode.com/problems/verifying-an-alien-dictionary/discussion/comments/1784307)\n- [Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)\n*Hope it helps*"
                    },
                    {
                        "username": "space_invader",
                        "content": "Do not forget to strike off properly ordered words (looking backwards)."
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "Aliens plz take back your dictionary  T_T"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "The description of the question feels more alien."
                    }
                ]
            },
            {
                "id": 1784995,
                "content": [
                    {
                        "username": "Asadbek525",
                        "content": "I think this is medium problem."
                    },
                    {
                        "username": "t_Mz",
                        "content": "This question can be categorize into medium level ques and ques can be explained in better way... Discussion section really helps me in such situation, after giving thought and reading comments, finally able to solve it.\\n\\nkey point: \\n>Check whole word only when first letter of adjacent word is equal else you move ahead if it is in sorted manner and if not then return false.\\n\\n>Also check for edge cases like 3rd example of ques."
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string>& words, string order) {\\n      int arr[26];\\n      for(int i=0;i<26;i++){\\n          arr[order[i]-\\'a\\']=i;\\n}\\nfor(int i=1;i<words.size();i++){\\n    int n = min(words[i].size(),words[i-1].size());\\n    for(int j=0;j<n;j++){\\n        if(words[i][j] != words[i-1][j]){\\n        if(arr[words[i][j]-\\'a\\'] < arr[words[i-1][j]-\\'a\\'] ){\\n            return false;\\n        }\\n        break;\\n        }\\n    }\\n    if(words[i-1].length()>words[i].length() && words[i-1].substr(0,words[i].length()) == words[i] )\\n    return false;\\n} return true; \\n    }\\n};"
                    },
                    {
                        "username": "20k32",
                        "content": "words \\n\"mtkwpj\", \"wlaees\"\\norder\\n\"evhadxsqukcogztlnfjpiymbwr\"\\nOutput - false\\nExpected - true\\n\\nm < w = true\\nt < l = true\\nk < a = false, its not sorted, why expected - true?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "yes its sorting problem m<w is sufficient for example in dictionary apple<book because a<b"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "`m < w` is enough to validate this test case, you don\\'t need further verifications. "
                    },
                    {
                        "username": "S_Basu",
                        "content": "[Link to Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Dealing with aliens is not \\'EASY\\'...it should be atleast medium"
                    },
                    {
                        "username": "heygauri",
                        "content": "I am still not getting the question. Feeling like an alien"
                    },
                    {
                        "username": "S_Basu",
                        "content": "- [Small Hint](https://leetcode.com/problems/verifying-an-alien-dictionary/discussion/comments/1784307)\n- [Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)\n*Hope it helps*"
                    },
                    {
                        "username": "space_invader",
                        "content": "Do not forget to strike off properly ordered words (looking backwards)."
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "Aliens plz take back your dictionary  T_T"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "The description of the question feels more alien."
                    }
                ]
            },
            {
                "id": 1784953,
                "content": [
                    {
                        "username": "Asadbek525",
                        "content": "I think this is medium problem."
                    },
                    {
                        "username": "t_Mz",
                        "content": "This question can be categorize into medium level ques and ques can be explained in better way... Discussion section really helps me in such situation, after giving thought and reading comments, finally able to solve it.\\n\\nkey point: \\n>Check whole word only when first letter of adjacent word is equal else you move ahead if it is in sorted manner and if not then return false.\\n\\n>Also check for edge cases like 3rd example of ques."
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string>& words, string order) {\\n      int arr[26];\\n      for(int i=0;i<26;i++){\\n          arr[order[i]-\\'a\\']=i;\\n}\\nfor(int i=1;i<words.size();i++){\\n    int n = min(words[i].size(),words[i-1].size());\\n    for(int j=0;j<n;j++){\\n        if(words[i][j] != words[i-1][j]){\\n        if(arr[words[i][j]-\\'a\\'] < arr[words[i-1][j]-\\'a\\'] ){\\n            return false;\\n        }\\n        break;\\n        }\\n    }\\n    if(words[i-1].length()>words[i].length() && words[i-1].substr(0,words[i].length()) == words[i] )\\n    return false;\\n} return true; \\n    }\\n};"
                    },
                    {
                        "username": "20k32",
                        "content": "words \\n\"mtkwpj\", \"wlaees\"\\norder\\n\"evhadxsqukcogztlnfjpiymbwr\"\\nOutput - false\\nExpected - true\\n\\nm < w = true\\nt < l = true\\nk < a = false, its not sorted, why expected - true?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "yes its sorting problem m<w is sufficient for example in dictionary apple<book because a<b"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "`m < w` is enough to validate this test case, you don\\'t need further verifications. "
                    },
                    {
                        "username": "S_Basu",
                        "content": "[Link to Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Dealing with aliens is not \\'EASY\\'...it should be atleast medium"
                    },
                    {
                        "username": "heygauri",
                        "content": "I am still not getting the question. Feeling like an alien"
                    },
                    {
                        "username": "S_Basu",
                        "content": "- [Small Hint](https://leetcode.com/problems/verifying-an-alien-dictionary/discussion/comments/1784307)\n- [Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)\n*Hope it helps*"
                    },
                    {
                        "username": "space_invader",
                        "content": "Do not forget to strike off properly ordered words (looking backwards)."
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "Aliens plz take back your dictionary  T_T"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "The description of the question feels more alien."
                    }
                ]
            },
            {
                "id": 1784946,
                "content": [
                    {
                        "username": "Asadbek525",
                        "content": "I think this is medium problem."
                    },
                    {
                        "username": "t_Mz",
                        "content": "This question can be categorize into medium level ques and ques can be explained in better way... Discussion section really helps me in such situation, after giving thought and reading comments, finally able to solve it.\\n\\nkey point: \\n>Check whole word only when first letter of adjacent word is equal else you move ahead if it is in sorted manner and if not then return false.\\n\\n>Also check for edge cases like 3rd example of ques."
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string>& words, string order) {\\n      int arr[26];\\n      for(int i=0;i<26;i++){\\n          arr[order[i]-\\'a\\']=i;\\n}\\nfor(int i=1;i<words.size();i++){\\n    int n = min(words[i].size(),words[i-1].size());\\n    for(int j=0;j<n;j++){\\n        if(words[i][j] != words[i-1][j]){\\n        if(arr[words[i][j]-\\'a\\'] < arr[words[i-1][j]-\\'a\\'] ){\\n            return false;\\n        }\\n        break;\\n        }\\n    }\\n    if(words[i-1].length()>words[i].length() && words[i-1].substr(0,words[i].length()) == words[i] )\\n    return false;\\n} return true; \\n    }\\n};"
                    },
                    {
                        "username": "20k32",
                        "content": "words \\n\"mtkwpj\", \"wlaees\"\\norder\\n\"evhadxsqukcogztlnfjpiymbwr\"\\nOutput - false\\nExpected - true\\n\\nm < w = true\\nt < l = true\\nk < a = false, its not sorted, why expected - true?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "yes its sorting problem m<w is sufficient for example in dictionary apple<book because a<b"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "`m < w` is enough to validate this test case, you don\\'t need further verifications. "
                    },
                    {
                        "username": "S_Basu",
                        "content": "[Link to Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Dealing with aliens is not \\'EASY\\'...it should be atleast medium"
                    },
                    {
                        "username": "heygauri",
                        "content": "I am still not getting the question. Feeling like an alien"
                    },
                    {
                        "username": "S_Basu",
                        "content": "- [Small Hint](https://leetcode.com/problems/verifying-an-alien-dictionary/discussion/comments/1784307)\n- [Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)\n*Hope it helps*"
                    },
                    {
                        "username": "space_invader",
                        "content": "Do not forget to strike off properly ordered words (looking backwards)."
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "Aliens plz take back your dictionary  T_T"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "The description of the question feels more alien."
                    }
                ]
            },
            {
                "id": 1784945,
                "content": [
                    {
                        "username": "Asadbek525",
                        "content": "I think this is medium problem."
                    },
                    {
                        "username": "t_Mz",
                        "content": "This question can be categorize into medium level ques and ques can be explained in better way... Discussion section really helps me in such situation, after giving thought and reading comments, finally able to solve it.\\n\\nkey point: \\n>Check whole word only when first letter of adjacent word is equal else you move ahead if it is in sorted manner and if not then return false.\\n\\n>Also check for edge cases like 3rd example of ques."
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string>& words, string order) {\\n      int arr[26];\\n      for(int i=0;i<26;i++){\\n          arr[order[i]-\\'a\\']=i;\\n}\\nfor(int i=1;i<words.size();i++){\\n    int n = min(words[i].size(),words[i-1].size());\\n    for(int j=0;j<n;j++){\\n        if(words[i][j] != words[i-1][j]){\\n        if(arr[words[i][j]-\\'a\\'] < arr[words[i-1][j]-\\'a\\'] ){\\n            return false;\\n        }\\n        break;\\n        }\\n    }\\n    if(words[i-1].length()>words[i].length() && words[i-1].substr(0,words[i].length()) == words[i] )\\n    return false;\\n} return true; \\n    }\\n};"
                    },
                    {
                        "username": "20k32",
                        "content": "words \\n\"mtkwpj\", \"wlaees\"\\norder\\n\"evhadxsqukcogztlnfjpiymbwr\"\\nOutput - false\\nExpected - true\\n\\nm < w = true\\nt < l = true\\nk < a = false, its not sorted, why expected - true?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "yes its sorting problem m<w is sufficient for example in dictionary apple<book because a<b"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "`m < w` is enough to validate this test case, you don\\'t need further verifications. "
                    },
                    {
                        "username": "S_Basu",
                        "content": "[Link to Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Dealing with aliens is not \\'EASY\\'...it should be atleast medium"
                    },
                    {
                        "username": "heygauri",
                        "content": "I am still not getting the question. Feeling like an alien"
                    },
                    {
                        "username": "S_Basu",
                        "content": "- [Small Hint](https://leetcode.com/problems/verifying-an-alien-dictionary/discussion/comments/1784307)\n- [Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)\n*Hope it helps*"
                    },
                    {
                        "username": "space_invader",
                        "content": "Do not forget to strike off properly ordered words (looking backwards)."
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "Aliens plz take back your dictionary  T_T"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "The description of the question feels more alien."
                    }
                ]
            },
            {
                "id": 1784943,
                "content": [
                    {
                        "username": "Asadbek525",
                        "content": "I think this is medium problem."
                    },
                    {
                        "username": "t_Mz",
                        "content": "This question can be categorize into medium level ques and ques can be explained in better way... Discussion section really helps me in such situation, after giving thought and reading comments, finally able to solve it.\\n\\nkey point: \\n>Check whole word only when first letter of adjacent word is equal else you move ahead if it is in sorted manner and if not then return false.\\n\\n>Also check for edge cases like 3rd example of ques."
                    },
                    {
                        "username": "LEOFRAGGER",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n\\n    bool isAlienSorted(vector<string>& words, string order) {\\n      int arr[26];\\n      for(int i=0;i<26;i++){\\n          arr[order[i]-\\'a\\']=i;\\n}\\nfor(int i=1;i<words.size();i++){\\n    int n = min(words[i].size(),words[i-1].size());\\n    for(int j=0;j<n;j++){\\n        if(words[i][j] != words[i-1][j]){\\n        if(arr[words[i][j]-\\'a\\'] < arr[words[i-1][j]-\\'a\\'] ){\\n            return false;\\n        }\\n        break;\\n        }\\n    }\\n    if(words[i-1].length()>words[i].length() && words[i-1].substr(0,words[i].length()) == words[i] )\\n    return false;\\n} return true; \\n    }\\n};"
                    },
                    {
                        "username": "20k32",
                        "content": "words \\n\"mtkwpj\", \"wlaees\"\\norder\\n\"evhadxsqukcogztlnfjpiymbwr\"\\nOutput - false\\nExpected - true\\n\\nm < w = true\\nt < l = true\\nk < a = false, its not sorted, why expected - true?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "yes its sorting problem m<w is sufficient for example in dictionary apple<book because a<b"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "`m < w` is enough to validate this test case, you don\\'t need further verifications. "
                    },
                    {
                        "username": "S_Basu",
                        "content": "[Link to Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Dealing with aliens is not \\'EASY\\'...it should be atleast medium"
                    },
                    {
                        "username": "heygauri",
                        "content": "I am still not getting the question. Feeling like an alien"
                    },
                    {
                        "username": "S_Basu",
                        "content": "- [Small Hint](https://leetcode.com/problems/verifying-an-alien-dictionary/discussion/comments/1784307)\n- [Solution + Explanation](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130453/simple-solution-explanation-hashing/)\n*Hope it helps*"
                    },
                    {
                        "username": "space_invader",
                        "content": "Do not forget to strike off properly ordered words (looking backwards)."
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "Aliens plz take back your dictionary  T_T"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "The description of the question feels more alien."
                    }
                ]
            },
            {
                "id": 1784932,
                "content": [
                    {
                        "username": "jobless_lm10",
                        "content": "Seems like aliens do not pose much of a threat, if they have not yet discovered the Capitals."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Solution is easy. Implementation is medium."
                    },
                    {
                        "username": "bablushaw23",
                        "content": "Don\\'t know is it really Easy. Took 1/2 day and lots of confidence but when worked, beat 100%. Confidence recharged. "
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Another case of reading the question until you fully understand the problem. Good exercise for my brain cause I\\'m pretty sure I have only 2 cells left. "
                    },
                    {
                        "username": "reassurance",
                        "content": "Can anyone explain this question to me atleast in English ? :/\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "Think of the order as the alien versions of the ABCs.\\n\\nWe are trying to test whether the words are in alphabetical order according to this version of the ABCs. The question does not explain it in the clearest terms. "
                    },
                    {
                        "username": "Kashi_27",
                        "content": "// java hashing solution\\n\\nclass Solution {\\n     HashMap<Character,Integer> map = new HashMap<>();\\n     public boolean fun(String str1,String str2)\\n     {\\n         if(str1.length()<str2.length())\\n         {\\n             if(str2.startsWith(str1))\\n             return true;\\n         }\\n         if(str1.length()>str2.length())\\n         {\\n             if(str1.startsWith(str2))\\n             return false;\\n         }\\n        \\n         for(int i=0;i<str1.length();i++)\\n         {\\n             char c1=str1.charAt(i);\\n             char c2=str2.charAt(i);\\n             if(c1==c2)\\n             {\\n                continue; \\n             }\\n             else\\n             {\\n                 if(map.get(c1)<map.get(c2))\\n                 return true;\\n                 else\\n                 return false;\\n             }\\n         }\\n       return true;\\n     }\\n    public boolean isAlienSorted(String[] words, String order) {\\n       \\n        for(int i=0;i<order.length();i++)\\n        {\\n            char c=order.charAt(i);\\n            map.put(c,i);\\n        }\\n        for(int i=0;i<words.length-1;i++)\\n        {\\n        if(!fun(words[i],words[i+1]))\\n        {\\n           return false;\\n        }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "c# Question \n\nPlease help Me why my solution is failing in 111 test case\n```\n[\"kuvp\",\"q\"]\n\"ngxlkthsjuoqcpavbfdermiywz\"\n```\n\n```\nusing System.Text.RegularExpressions;\npublic class Solution \n{\n    public bool IsAlienSorted(string[] words, string order ) \n    {\n        var result = words.OrderBy(x => Regex.Replace(x, \"[a-z]\", match => order.IndexOf(match.Value).ToString())).ToList();\n\n        for (int i = 0; i < words.Length; i++) \n            if (result[i] != words[i]) return false; \n        return true;\n    }\n}\n```\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You are sorting the strings with format like \"1138216\". Strings are sorted lexicographically, eg. \"1\" < \"14\" < \"2\" < \"21\" < \"3\".\n\nI think you can try .ToCharArray() then .Select()"
                    },
                    {
                        "username": "Harryd0311",
                        "content": "words =\\n[\"kuvp\",\"q\"]\\norder =\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\n\"kuvp\" maps to \"ormv\"\\n\"q\" maps to \"b\"\\nand \"b\" comes before \"ormv\"\\nhow is the test case expecting answer as true?\\ncan anyone explain"
                    },
                    {
                        "username": "ajesk",
                        "content": "k comes before q in the order. Think of the `order` as the alien ABCs. "
                    },
                    {
                        "username": "Balram600",
                        "content": "This week is for String...."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "At first, i thought it must be medium but then i read question again and again and got the clue. it\\'s easy to solve."
                    }
                ]
            },
            {
                "id": 1784820,
                "content": [
                    {
                        "username": "jobless_lm10",
                        "content": "Seems like aliens do not pose much of a threat, if they have not yet discovered the Capitals."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Solution is easy. Implementation is medium."
                    },
                    {
                        "username": "bablushaw23",
                        "content": "Don\\'t know is it really Easy. Took 1/2 day and lots of confidence but when worked, beat 100%. Confidence recharged. "
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Another case of reading the question until you fully understand the problem. Good exercise for my brain cause I\\'m pretty sure I have only 2 cells left. "
                    },
                    {
                        "username": "reassurance",
                        "content": "Can anyone explain this question to me atleast in English ? :/\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "Think of the order as the alien versions of the ABCs.\\n\\nWe are trying to test whether the words are in alphabetical order according to this version of the ABCs. The question does not explain it in the clearest terms. "
                    },
                    {
                        "username": "Kashi_27",
                        "content": "// java hashing solution\\n\\nclass Solution {\\n     HashMap<Character,Integer> map = new HashMap<>();\\n     public boolean fun(String str1,String str2)\\n     {\\n         if(str1.length()<str2.length())\\n         {\\n             if(str2.startsWith(str1))\\n             return true;\\n         }\\n         if(str1.length()>str2.length())\\n         {\\n             if(str1.startsWith(str2))\\n             return false;\\n         }\\n        \\n         for(int i=0;i<str1.length();i++)\\n         {\\n             char c1=str1.charAt(i);\\n             char c2=str2.charAt(i);\\n             if(c1==c2)\\n             {\\n                continue; \\n             }\\n             else\\n             {\\n                 if(map.get(c1)<map.get(c2))\\n                 return true;\\n                 else\\n                 return false;\\n             }\\n         }\\n       return true;\\n     }\\n    public boolean isAlienSorted(String[] words, String order) {\\n       \\n        for(int i=0;i<order.length();i++)\\n        {\\n            char c=order.charAt(i);\\n            map.put(c,i);\\n        }\\n        for(int i=0;i<words.length-1;i++)\\n        {\\n        if(!fun(words[i],words[i+1]))\\n        {\\n           return false;\\n        }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "c# Question \n\nPlease help Me why my solution is failing in 111 test case\n```\n[\"kuvp\",\"q\"]\n\"ngxlkthsjuoqcpavbfdermiywz\"\n```\n\n```\nusing System.Text.RegularExpressions;\npublic class Solution \n{\n    public bool IsAlienSorted(string[] words, string order ) \n    {\n        var result = words.OrderBy(x => Regex.Replace(x, \"[a-z]\", match => order.IndexOf(match.Value).ToString())).ToList();\n\n        for (int i = 0; i < words.Length; i++) \n            if (result[i] != words[i]) return false; \n        return true;\n    }\n}\n```\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You are sorting the strings with format like \"1138216\". Strings are sorted lexicographically, eg. \"1\" < \"14\" < \"2\" < \"21\" < \"3\".\n\nI think you can try .ToCharArray() then .Select()"
                    },
                    {
                        "username": "Harryd0311",
                        "content": "words =\\n[\"kuvp\",\"q\"]\\norder =\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\n\"kuvp\" maps to \"ormv\"\\n\"q\" maps to \"b\"\\nand \"b\" comes before \"ormv\"\\nhow is the test case expecting answer as true?\\ncan anyone explain"
                    },
                    {
                        "username": "ajesk",
                        "content": "k comes before q in the order. Think of the `order` as the alien ABCs. "
                    },
                    {
                        "username": "Balram600",
                        "content": "This week is for String...."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "At first, i thought it must be medium but then i read question again and again and got the clue. it\\'s easy to solve."
                    }
                ]
            },
            {
                "id": 1784811,
                "content": [
                    {
                        "username": "jobless_lm10",
                        "content": "Seems like aliens do not pose much of a threat, if they have not yet discovered the Capitals."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Solution is easy. Implementation is medium."
                    },
                    {
                        "username": "bablushaw23",
                        "content": "Don\\'t know is it really Easy. Took 1/2 day and lots of confidence but when worked, beat 100%. Confidence recharged. "
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Another case of reading the question until you fully understand the problem. Good exercise for my brain cause I\\'m pretty sure I have only 2 cells left. "
                    },
                    {
                        "username": "reassurance",
                        "content": "Can anyone explain this question to me atleast in English ? :/\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "Think of the order as the alien versions of the ABCs.\\n\\nWe are trying to test whether the words are in alphabetical order according to this version of the ABCs. The question does not explain it in the clearest terms. "
                    },
                    {
                        "username": "Kashi_27",
                        "content": "// java hashing solution\\n\\nclass Solution {\\n     HashMap<Character,Integer> map = new HashMap<>();\\n     public boolean fun(String str1,String str2)\\n     {\\n         if(str1.length()<str2.length())\\n         {\\n             if(str2.startsWith(str1))\\n             return true;\\n         }\\n         if(str1.length()>str2.length())\\n         {\\n             if(str1.startsWith(str2))\\n             return false;\\n         }\\n        \\n         for(int i=0;i<str1.length();i++)\\n         {\\n             char c1=str1.charAt(i);\\n             char c2=str2.charAt(i);\\n             if(c1==c2)\\n             {\\n                continue; \\n             }\\n             else\\n             {\\n                 if(map.get(c1)<map.get(c2))\\n                 return true;\\n                 else\\n                 return false;\\n             }\\n         }\\n       return true;\\n     }\\n    public boolean isAlienSorted(String[] words, String order) {\\n       \\n        for(int i=0;i<order.length();i++)\\n        {\\n            char c=order.charAt(i);\\n            map.put(c,i);\\n        }\\n        for(int i=0;i<words.length-1;i++)\\n        {\\n        if(!fun(words[i],words[i+1]))\\n        {\\n           return false;\\n        }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "c# Question \n\nPlease help Me why my solution is failing in 111 test case\n```\n[\"kuvp\",\"q\"]\n\"ngxlkthsjuoqcpavbfdermiywz\"\n```\n\n```\nusing System.Text.RegularExpressions;\npublic class Solution \n{\n    public bool IsAlienSorted(string[] words, string order ) \n    {\n        var result = words.OrderBy(x => Regex.Replace(x, \"[a-z]\", match => order.IndexOf(match.Value).ToString())).ToList();\n\n        for (int i = 0; i < words.Length; i++) \n            if (result[i] != words[i]) return false; \n        return true;\n    }\n}\n```\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You are sorting the strings with format like \"1138216\". Strings are sorted lexicographically, eg. \"1\" < \"14\" < \"2\" < \"21\" < \"3\".\n\nI think you can try .ToCharArray() then .Select()"
                    },
                    {
                        "username": "Harryd0311",
                        "content": "words =\\n[\"kuvp\",\"q\"]\\norder =\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\n\"kuvp\" maps to \"ormv\"\\n\"q\" maps to \"b\"\\nand \"b\" comes before \"ormv\"\\nhow is the test case expecting answer as true?\\ncan anyone explain"
                    },
                    {
                        "username": "ajesk",
                        "content": "k comes before q in the order. Think of the `order` as the alien ABCs. "
                    },
                    {
                        "username": "Balram600",
                        "content": "This week is for String...."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "At first, i thought it must be medium but then i read question again and again and got the clue. it\\'s easy to solve."
                    }
                ]
            },
            {
                "id": 1784786,
                "content": [
                    {
                        "username": "jobless_lm10",
                        "content": "Seems like aliens do not pose much of a threat, if they have not yet discovered the Capitals."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Solution is easy. Implementation is medium."
                    },
                    {
                        "username": "bablushaw23",
                        "content": "Don\\'t know is it really Easy. Took 1/2 day and lots of confidence but when worked, beat 100%. Confidence recharged. "
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Another case of reading the question until you fully understand the problem. Good exercise for my brain cause I\\'m pretty sure I have only 2 cells left. "
                    },
                    {
                        "username": "reassurance",
                        "content": "Can anyone explain this question to me atleast in English ? :/\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "Think of the order as the alien versions of the ABCs.\\n\\nWe are trying to test whether the words are in alphabetical order according to this version of the ABCs. The question does not explain it in the clearest terms. "
                    },
                    {
                        "username": "Kashi_27",
                        "content": "// java hashing solution\\n\\nclass Solution {\\n     HashMap<Character,Integer> map = new HashMap<>();\\n     public boolean fun(String str1,String str2)\\n     {\\n         if(str1.length()<str2.length())\\n         {\\n             if(str2.startsWith(str1))\\n             return true;\\n         }\\n         if(str1.length()>str2.length())\\n         {\\n             if(str1.startsWith(str2))\\n             return false;\\n         }\\n        \\n         for(int i=0;i<str1.length();i++)\\n         {\\n             char c1=str1.charAt(i);\\n             char c2=str2.charAt(i);\\n             if(c1==c2)\\n             {\\n                continue; \\n             }\\n             else\\n             {\\n                 if(map.get(c1)<map.get(c2))\\n                 return true;\\n                 else\\n                 return false;\\n             }\\n         }\\n       return true;\\n     }\\n    public boolean isAlienSorted(String[] words, String order) {\\n       \\n        for(int i=0;i<order.length();i++)\\n        {\\n            char c=order.charAt(i);\\n            map.put(c,i);\\n        }\\n        for(int i=0;i<words.length-1;i++)\\n        {\\n        if(!fun(words[i],words[i+1]))\\n        {\\n           return false;\\n        }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "c# Question \n\nPlease help Me why my solution is failing in 111 test case\n```\n[\"kuvp\",\"q\"]\n\"ngxlkthsjuoqcpavbfdermiywz\"\n```\n\n```\nusing System.Text.RegularExpressions;\npublic class Solution \n{\n    public bool IsAlienSorted(string[] words, string order ) \n    {\n        var result = words.OrderBy(x => Regex.Replace(x, \"[a-z]\", match => order.IndexOf(match.Value).ToString())).ToList();\n\n        for (int i = 0; i < words.Length; i++) \n            if (result[i] != words[i]) return false; \n        return true;\n    }\n}\n```\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You are sorting the strings with format like \"1138216\". Strings are sorted lexicographically, eg. \"1\" < \"14\" < \"2\" < \"21\" < \"3\".\n\nI think you can try .ToCharArray() then .Select()"
                    },
                    {
                        "username": "Harryd0311",
                        "content": "words =\\n[\"kuvp\",\"q\"]\\norder =\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\n\"kuvp\" maps to \"ormv\"\\n\"q\" maps to \"b\"\\nand \"b\" comes before \"ormv\"\\nhow is the test case expecting answer as true?\\ncan anyone explain"
                    },
                    {
                        "username": "ajesk",
                        "content": "k comes before q in the order. Think of the `order` as the alien ABCs. "
                    },
                    {
                        "username": "Balram600",
                        "content": "This week is for String...."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "At first, i thought it must be medium but then i read question again and again and got the clue. it\\'s easy to solve."
                    }
                ]
            },
            {
                "id": 1784732,
                "content": [
                    {
                        "username": "jobless_lm10",
                        "content": "Seems like aliens do not pose much of a threat, if they have not yet discovered the Capitals."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Solution is easy. Implementation is medium."
                    },
                    {
                        "username": "bablushaw23",
                        "content": "Don\\'t know is it really Easy. Took 1/2 day and lots of confidence but when worked, beat 100%. Confidence recharged. "
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Another case of reading the question until you fully understand the problem. Good exercise for my brain cause I\\'m pretty sure I have only 2 cells left. "
                    },
                    {
                        "username": "reassurance",
                        "content": "Can anyone explain this question to me atleast in English ? :/\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "Think of the order as the alien versions of the ABCs.\\n\\nWe are trying to test whether the words are in alphabetical order according to this version of the ABCs. The question does not explain it in the clearest terms. "
                    },
                    {
                        "username": "Kashi_27",
                        "content": "// java hashing solution\\n\\nclass Solution {\\n     HashMap<Character,Integer> map = new HashMap<>();\\n     public boolean fun(String str1,String str2)\\n     {\\n         if(str1.length()<str2.length())\\n         {\\n             if(str2.startsWith(str1))\\n             return true;\\n         }\\n         if(str1.length()>str2.length())\\n         {\\n             if(str1.startsWith(str2))\\n             return false;\\n         }\\n        \\n         for(int i=0;i<str1.length();i++)\\n         {\\n             char c1=str1.charAt(i);\\n             char c2=str2.charAt(i);\\n             if(c1==c2)\\n             {\\n                continue; \\n             }\\n             else\\n             {\\n                 if(map.get(c1)<map.get(c2))\\n                 return true;\\n                 else\\n                 return false;\\n             }\\n         }\\n       return true;\\n     }\\n    public boolean isAlienSorted(String[] words, String order) {\\n       \\n        for(int i=0;i<order.length();i++)\\n        {\\n            char c=order.charAt(i);\\n            map.put(c,i);\\n        }\\n        for(int i=0;i<words.length-1;i++)\\n        {\\n        if(!fun(words[i],words[i+1]))\\n        {\\n           return false;\\n        }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "c# Question \n\nPlease help Me why my solution is failing in 111 test case\n```\n[\"kuvp\",\"q\"]\n\"ngxlkthsjuoqcpavbfdermiywz\"\n```\n\n```\nusing System.Text.RegularExpressions;\npublic class Solution \n{\n    public bool IsAlienSorted(string[] words, string order ) \n    {\n        var result = words.OrderBy(x => Regex.Replace(x, \"[a-z]\", match => order.IndexOf(match.Value).ToString())).ToList();\n\n        for (int i = 0; i < words.Length; i++) \n            if (result[i] != words[i]) return false; \n        return true;\n    }\n}\n```\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You are sorting the strings with format like \"1138216\". Strings are sorted lexicographically, eg. \"1\" < \"14\" < \"2\" < \"21\" < \"3\".\n\nI think you can try .ToCharArray() then .Select()"
                    },
                    {
                        "username": "Harryd0311",
                        "content": "words =\\n[\"kuvp\",\"q\"]\\norder =\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\n\"kuvp\" maps to \"ormv\"\\n\"q\" maps to \"b\"\\nand \"b\" comes before \"ormv\"\\nhow is the test case expecting answer as true?\\ncan anyone explain"
                    },
                    {
                        "username": "ajesk",
                        "content": "k comes before q in the order. Think of the `order` as the alien ABCs. "
                    },
                    {
                        "username": "Balram600",
                        "content": "This week is for String...."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "At first, i thought it must be medium but then i read question again and again and got the clue. it\\'s easy to solve."
                    }
                ]
            },
            {
                "id": 1784724,
                "content": [
                    {
                        "username": "jobless_lm10",
                        "content": "Seems like aliens do not pose much of a threat, if they have not yet discovered the Capitals."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Solution is easy. Implementation is medium."
                    },
                    {
                        "username": "bablushaw23",
                        "content": "Don\\'t know is it really Easy. Took 1/2 day and lots of confidence but when worked, beat 100%. Confidence recharged. "
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Another case of reading the question until you fully understand the problem. Good exercise for my brain cause I\\'m pretty sure I have only 2 cells left. "
                    },
                    {
                        "username": "reassurance",
                        "content": "Can anyone explain this question to me atleast in English ? :/\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "Think of the order as the alien versions of the ABCs.\\n\\nWe are trying to test whether the words are in alphabetical order according to this version of the ABCs. The question does not explain it in the clearest terms. "
                    },
                    {
                        "username": "Kashi_27",
                        "content": "// java hashing solution\\n\\nclass Solution {\\n     HashMap<Character,Integer> map = new HashMap<>();\\n     public boolean fun(String str1,String str2)\\n     {\\n         if(str1.length()<str2.length())\\n         {\\n             if(str2.startsWith(str1))\\n             return true;\\n         }\\n         if(str1.length()>str2.length())\\n         {\\n             if(str1.startsWith(str2))\\n             return false;\\n         }\\n        \\n         for(int i=0;i<str1.length();i++)\\n         {\\n             char c1=str1.charAt(i);\\n             char c2=str2.charAt(i);\\n             if(c1==c2)\\n             {\\n                continue; \\n             }\\n             else\\n             {\\n                 if(map.get(c1)<map.get(c2))\\n                 return true;\\n                 else\\n                 return false;\\n             }\\n         }\\n       return true;\\n     }\\n    public boolean isAlienSorted(String[] words, String order) {\\n       \\n        for(int i=0;i<order.length();i++)\\n        {\\n            char c=order.charAt(i);\\n            map.put(c,i);\\n        }\\n        for(int i=0;i<words.length-1;i++)\\n        {\\n        if(!fun(words[i],words[i+1]))\\n        {\\n           return false;\\n        }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "c# Question \n\nPlease help Me why my solution is failing in 111 test case\n```\n[\"kuvp\",\"q\"]\n\"ngxlkthsjuoqcpavbfdermiywz\"\n```\n\n```\nusing System.Text.RegularExpressions;\npublic class Solution \n{\n    public bool IsAlienSorted(string[] words, string order ) \n    {\n        var result = words.OrderBy(x => Regex.Replace(x, \"[a-z]\", match => order.IndexOf(match.Value).ToString())).ToList();\n\n        for (int i = 0; i < words.Length; i++) \n            if (result[i] != words[i]) return false; \n        return true;\n    }\n}\n```\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You are sorting the strings with format like \"1138216\". Strings are sorted lexicographically, eg. \"1\" < \"14\" < \"2\" < \"21\" < \"3\".\n\nI think you can try .ToCharArray() then .Select()"
                    },
                    {
                        "username": "Harryd0311",
                        "content": "words =\\n[\"kuvp\",\"q\"]\\norder =\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\n\"kuvp\" maps to \"ormv\"\\n\"q\" maps to \"b\"\\nand \"b\" comes before \"ormv\"\\nhow is the test case expecting answer as true?\\ncan anyone explain"
                    },
                    {
                        "username": "ajesk",
                        "content": "k comes before q in the order. Think of the `order` as the alien ABCs. "
                    },
                    {
                        "username": "Balram600",
                        "content": "This week is for String...."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "At first, i thought it must be medium but then i read question again and again and got the clue. it\\'s easy to solve."
                    }
                ]
            },
            {
                "id": 1784684,
                "content": [
                    {
                        "username": "jobless_lm10",
                        "content": "Seems like aliens do not pose much of a threat, if they have not yet discovered the Capitals."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Solution is easy. Implementation is medium."
                    },
                    {
                        "username": "bablushaw23",
                        "content": "Don\\'t know is it really Easy. Took 1/2 day and lots of confidence but when worked, beat 100%. Confidence recharged. "
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Another case of reading the question until you fully understand the problem. Good exercise for my brain cause I\\'m pretty sure I have only 2 cells left. "
                    },
                    {
                        "username": "reassurance",
                        "content": "Can anyone explain this question to me atleast in English ? :/\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "Think of the order as the alien versions of the ABCs.\\n\\nWe are trying to test whether the words are in alphabetical order according to this version of the ABCs. The question does not explain it in the clearest terms. "
                    },
                    {
                        "username": "Kashi_27",
                        "content": "// java hashing solution\\n\\nclass Solution {\\n     HashMap<Character,Integer> map = new HashMap<>();\\n     public boolean fun(String str1,String str2)\\n     {\\n         if(str1.length()<str2.length())\\n         {\\n             if(str2.startsWith(str1))\\n             return true;\\n         }\\n         if(str1.length()>str2.length())\\n         {\\n             if(str1.startsWith(str2))\\n             return false;\\n         }\\n        \\n         for(int i=0;i<str1.length();i++)\\n         {\\n             char c1=str1.charAt(i);\\n             char c2=str2.charAt(i);\\n             if(c1==c2)\\n             {\\n                continue; \\n             }\\n             else\\n             {\\n                 if(map.get(c1)<map.get(c2))\\n                 return true;\\n                 else\\n                 return false;\\n             }\\n         }\\n       return true;\\n     }\\n    public boolean isAlienSorted(String[] words, String order) {\\n       \\n        for(int i=0;i<order.length();i++)\\n        {\\n            char c=order.charAt(i);\\n            map.put(c,i);\\n        }\\n        for(int i=0;i<words.length-1;i++)\\n        {\\n        if(!fun(words[i],words[i+1]))\\n        {\\n           return false;\\n        }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "c# Question \n\nPlease help Me why my solution is failing in 111 test case\n```\n[\"kuvp\",\"q\"]\n\"ngxlkthsjuoqcpavbfdermiywz\"\n```\n\n```\nusing System.Text.RegularExpressions;\npublic class Solution \n{\n    public bool IsAlienSorted(string[] words, string order ) \n    {\n        var result = words.OrderBy(x => Regex.Replace(x, \"[a-z]\", match => order.IndexOf(match.Value).ToString())).ToList();\n\n        for (int i = 0; i < words.Length; i++) \n            if (result[i] != words[i]) return false; \n        return true;\n    }\n}\n```\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You are sorting the strings with format like \"1138216\". Strings are sorted lexicographically, eg. \"1\" < \"14\" < \"2\" < \"21\" < \"3\".\n\nI think you can try .ToCharArray() then .Select()"
                    },
                    {
                        "username": "Harryd0311",
                        "content": "words =\\n[\"kuvp\",\"q\"]\\norder =\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\n\"kuvp\" maps to \"ormv\"\\n\"q\" maps to \"b\"\\nand \"b\" comes before \"ormv\"\\nhow is the test case expecting answer as true?\\ncan anyone explain"
                    },
                    {
                        "username": "ajesk",
                        "content": "k comes before q in the order. Think of the `order` as the alien ABCs. "
                    },
                    {
                        "username": "Balram600",
                        "content": "This week is for String...."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "At first, i thought it must be medium but then i read question again and again and got the clue. it\\'s easy to solve."
                    }
                ]
            },
            {
                "id": 1784670,
                "content": [
                    {
                        "username": "jobless_lm10",
                        "content": "Seems like aliens do not pose much of a threat, if they have not yet discovered the Capitals."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Solution is easy. Implementation is medium."
                    },
                    {
                        "username": "bablushaw23",
                        "content": "Don\\'t know is it really Easy. Took 1/2 day and lots of confidence but when worked, beat 100%. Confidence recharged. "
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Another case of reading the question until you fully understand the problem. Good exercise for my brain cause I\\'m pretty sure I have only 2 cells left. "
                    },
                    {
                        "username": "reassurance",
                        "content": "Can anyone explain this question to me atleast in English ? :/\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "Think of the order as the alien versions of the ABCs.\\n\\nWe are trying to test whether the words are in alphabetical order according to this version of the ABCs. The question does not explain it in the clearest terms. "
                    },
                    {
                        "username": "Kashi_27",
                        "content": "// java hashing solution\\n\\nclass Solution {\\n     HashMap<Character,Integer> map = new HashMap<>();\\n     public boolean fun(String str1,String str2)\\n     {\\n         if(str1.length()<str2.length())\\n         {\\n             if(str2.startsWith(str1))\\n             return true;\\n         }\\n         if(str1.length()>str2.length())\\n         {\\n             if(str1.startsWith(str2))\\n             return false;\\n         }\\n        \\n         for(int i=0;i<str1.length();i++)\\n         {\\n             char c1=str1.charAt(i);\\n             char c2=str2.charAt(i);\\n             if(c1==c2)\\n             {\\n                continue; \\n             }\\n             else\\n             {\\n                 if(map.get(c1)<map.get(c2))\\n                 return true;\\n                 else\\n                 return false;\\n             }\\n         }\\n       return true;\\n     }\\n    public boolean isAlienSorted(String[] words, String order) {\\n       \\n        for(int i=0;i<order.length();i++)\\n        {\\n            char c=order.charAt(i);\\n            map.put(c,i);\\n        }\\n        for(int i=0;i<words.length-1;i++)\\n        {\\n        if(!fun(words[i],words[i+1]))\\n        {\\n           return false;\\n        }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "c# Question \n\nPlease help Me why my solution is failing in 111 test case\n```\n[\"kuvp\",\"q\"]\n\"ngxlkthsjuoqcpavbfdermiywz\"\n```\n\n```\nusing System.Text.RegularExpressions;\npublic class Solution \n{\n    public bool IsAlienSorted(string[] words, string order ) \n    {\n        var result = words.OrderBy(x => Regex.Replace(x, \"[a-z]\", match => order.IndexOf(match.Value).ToString())).ToList();\n\n        for (int i = 0; i < words.Length; i++) \n            if (result[i] != words[i]) return false; \n        return true;\n    }\n}\n```\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You are sorting the strings with format like \"1138216\". Strings are sorted lexicographically, eg. \"1\" < \"14\" < \"2\" < \"21\" < \"3\".\n\nI think you can try .ToCharArray() then .Select()"
                    },
                    {
                        "username": "Harryd0311",
                        "content": "words =\\n[\"kuvp\",\"q\"]\\norder =\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\n\"kuvp\" maps to \"ormv\"\\n\"q\" maps to \"b\"\\nand \"b\" comes before \"ormv\"\\nhow is the test case expecting answer as true?\\ncan anyone explain"
                    },
                    {
                        "username": "ajesk",
                        "content": "k comes before q in the order. Think of the `order` as the alien ABCs. "
                    },
                    {
                        "username": "Balram600",
                        "content": "This week is for String...."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "At first, i thought it must be medium but then i read question again and again and got the clue. it\\'s easy to solve."
                    }
                ]
            },
            {
                "id": 1784669,
                "content": [
                    {
                        "username": "jobless_lm10",
                        "content": "Seems like aliens do not pose much of a threat, if they have not yet discovered the Capitals."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Solution is easy. Implementation is medium."
                    },
                    {
                        "username": "bablushaw23",
                        "content": "Don\\'t know is it really Easy. Took 1/2 day and lots of confidence but when worked, beat 100%. Confidence recharged. "
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Another case of reading the question until you fully understand the problem. Good exercise for my brain cause I\\'m pretty sure I have only 2 cells left. "
                    },
                    {
                        "username": "reassurance",
                        "content": "Can anyone explain this question to me atleast in English ? :/\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "Think of the order as the alien versions of the ABCs.\\n\\nWe are trying to test whether the words are in alphabetical order according to this version of the ABCs. The question does not explain it in the clearest terms. "
                    },
                    {
                        "username": "Kashi_27",
                        "content": "// java hashing solution\\n\\nclass Solution {\\n     HashMap<Character,Integer> map = new HashMap<>();\\n     public boolean fun(String str1,String str2)\\n     {\\n         if(str1.length()<str2.length())\\n         {\\n             if(str2.startsWith(str1))\\n             return true;\\n         }\\n         if(str1.length()>str2.length())\\n         {\\n             if(str1.startsWith(str2))\\n             return false;\\n         }\\n        \\n         for(int i=0;i<str1.length();i++)\\n         {\\n             char c1=str1.charAt(i);\\n             char c2=str2.charAt(i);\\n             if(c1==c2)\\n             {\\n                continue; \\n             }\\n             else\\n             {\\n                 if(map.get(c1)<map.get(c2))\\n                 return true;\\n                 else\\n                 return false;\\n             }\\n         }\\n       return true;\\n     }\\n    public boolean isAlienSorted(String[] words, String order) {\\n       \\n        for(int i=0;i<order.length();i++)\\n        {\\n            char c=order.charAt(i);\\n            map.put(c,i);\\n        }\\n        for(int i=0;i<words.length-1;i++)\\n        {\\n        if(!fun(words[i],words[i+1]))\\n        {\\n           return false;\\n        }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "c# Question \n\nPlease help Me why my solution is failing in 111 test case\n```\n[\"kuvp\",\"q\"]\n\"ngxlkthsjuoqcpavbfdermiywz\"\n```\n\n```\nusing System.Text.RegularExpressions;\npublic class Solution \n{\n    public bool IsAlienSorted(string[] words, string order ) \n    {\n        var result = words.OrderBy(x => Regex.Replace(x, \"[a-z]\", match => order.IndexOf(match.Value).ToString())).ToList();\n\n        for (int i = 0; i < words.Length; i++) \n            if (result[i] != words[i]) return false; \n        return true;\n    }\n}\n```\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You are sorting the strings with format like \"1138216\". Strings are sorted lexicographically, eg. \"1\" < \"14\" < \"2\" < \"21\" < \"3\".\n\nI think you can try .ToCharArray() then .Select()"
                    },
                    {
                        "username": "Harryd0311",
                        "content": "words =\\n[\"kuvp\",\"q\"]\\norder =\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\n\"kuvp\" maps to \"ormv\"\\n\"q\" maps to \"b\"\\nand \"b\" comes before \"ormv\"\\nhow is the test case expecting answer as true?\\ncan anyone explain"
                    },
                    {
                        "username": "ajesk",
                        "content": "k comes before q in the order. Think of the `order` as the alien ABCs. "
                    },
                    {
                        "username": "Balram600",
                        "content": "This week is for String...."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "At first, i thought it must be medium but then i read question again and again and got the clue. it\\'s easy to solve."
                    }
                ]
            },
            {
                "id": 1784663,
                "content": [
                    {
                        "username": "jobless_lm10",
                        "content": "Seems like aliens do not pose much of a threat, if they have not yet discovered the Capitals."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Solution is easy. Implementation is medium."
                    },
                    {
                        "username": "bablushaw23",
                        "content": "Don\\'t know is it really Easy. Took 1/2 day and lots of confidence but when worked, beat 100%. Confidence recharged. "
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Another case of reading the question until you fully understand the problem. Good exercise for my brain cause I\\'m pretty sure I have only 2 cells left. "
                    },
                    {
                        "username": "reassurance",
                        "content": "Can anyone explain this question to me atleast in English ? :/\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "Think of the order as the alien versions of the ABCs.\\n\\nWe are trying to test whether the words are in alphabetical order according to this version of the ABCs. The question does not explain it in the clearest terms. "
                    },
                    {
                        "username": "Kashi_27",
                        "content": "// java hashing solution\\n\\nclass Solution {\\n     HashMap<Character,Integer> map = new HashMap<>();\\n     public boolean fun(String str1,String str2)\\n     {\\n         if(str1.length()<str2.length())\\n         {\\n             if(str2.startsWith(str1))\\n             return true;\\n         }\\n         if(str1.length()>str2.length())\\n         {\\n             if(str1.startsWith(str2))\\n             return false;\\n         }\\n        \\n         for(int i=0;i<str1.length();i++)\\n         {\\n             char c1=str1.charAt(i);\\n             char c2=str2.charAt(i);\\n             if(c1==c2)\\n             {\\n                continue; \\n             }\\n             else\\n             {\\n                 if(map.get(c1)<map.get(c2))\\n                 return true;\\n                 else\\n                 return false;\\n             }\\n         }\\n       return true;\\n     }\\n    public boolean isAlienSorted(String[] words, String order) {\\n       \\n        for(int i=0;i<order.length();i++)\\n        {\\n            char c=order.charAt(i);\\n            map.put(c,i);\\n        }\\n        for(int i=0;i<words.length-1;i++)\\n        {\\n        if(!fun(words[i],words[i+1]))\\n        {\\n           return false;\\n        }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "c# Question \n\nPlease help Me why my solution is failing in 111 test case\n```\n[\"kuvp\",\"q\"]\n\"ngxlkthsjuoqcpavbfdermiywz\"\n```\n\n```\nusing System.Text.RegularExpressions;\npublic class Solution \n{\n    public bool IsAlienSorted(string[] words, string order ) \n    {\n        var result = words.OrderBy(x => Regex.Replace(x, \"[a-z]\", match => order.IndexOf(match.Value).ToString())).ToList();\n\n        for (int i = 0; i < words.Length; i++) \n            if (result[i] != words[i]) return false; \n        return true;\n    }\n}\n```\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You are sorting the strings with format like \"1138216\". Strings are sorted lexicographically, eg. \"1\" < \"14\" < \"2\" < \"21\" < \"3\".\n\nI think you can try .ToCharArray() then .Select()"
                    },
                    {
                        "username": "Harryd0311",
                        "content": "words =\\n[\"kuvp\",\"q\"]\\norder =\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\n\"kuvp\" maps to \"ormv\"\\n\"q\" maps to \"b\"\\nand \"b\" comes before \"ormv\"\\nhow is the test case expecting answer as true?\\ncan anyone explain"
                    },
                    {
                        "username": "ajesk",
                        "content": "k comes before q in the order. Think of the `order` as the alien ABCs. "
                    },
                    {
                        "username": "Balram600",
                        "content": "This week is for String...."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "At first, i thought it must be medium but then i read question again and again and got the clue. it\\'s easy to solve."
                    }
                ]
            },
            {
                "id": 1784643,
                "content": [
                    {
                        "username": "coder42032",
                        "content": "After 4 wrong submission Now I can understand why people dislike this Question. But testcases are very well designed by leetcode."
                    },
                    {
                        "username": "racemus",
                        "content": "It\\'s a oneliner with sort and lambda :)"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "after the struggle of 38 minutes, i finally solved it...\nquestion says that, in simple,\nthere is a guy and that guy has dictionary and that dictionary contains `english letters` but the order is not like `a-to-z` it is different than `a-to-z` and which is given to us, i.e. order string\nand we've given the `list of words` which contains some words and you've to check that the, words are given to us are lexographically arranged or not, based on the order string\n\nhere \n```\nwords = [\"hello\",\"leetcode\"], \norder = \"hlabcdefgijkmnopqrstuvwxyz\"\nin dictionary \nh----\nhe---\nhello\n...\n....\nleetcode \n```\nif you check the order we can see that h comes before l in order string so they are directly, arranged [lexographically]\n\nex. 2\n```\nwords = [\"apple\",\"app\"], \norder = \"abcdefghijklmnopqrstuvwxyz\"\n\na-----\nap---\napple\napp\n```\nas you can see the app comes before the apple but\napple then app comes so, they are not arranged in lexographically\n\n```https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130966/my-brute-force-solution-easy/```"
                    },
                    {
                        "username": "Harryd0311",
                        "content": "words =\\n[\"kuvp\",\"q\"]\\norder =\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\n\"kuvp\" maps to \"ormv\"\\n\"q\" maps to \"b\"\\nand \"b\" comes before \"ormv\"\\nhow is the test case expecting answer as true?\\ncan anyone explain"
                    },
                    {
                        "username": "Fz_coder",
                        "content": "1. to Check isSorted or not then check only there adjacent element instead compare with all element\\n2. if first charter is same then check for next character and same in recersive manner\\n"
                    },
                    {
                        "username": "Madhav-2003",
                        "content": "can anyone explain the question in a simple way ?"
                    },
                    {
                        "username": "peterjohncoles",
                        "content": "You are trying to check whether the words in the array are in the correct dictionary order according to the order of the letters given. For the first example \"hello\", \"leetcode\" it returns true because h comes before l in the order. Just like aardvark comes before apple in an English dictionary. "
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "Help needed!!\\nThis problem took me 15 minutes to understand.\\nMy approach:\\n1) Find the string of max size in words vector (for iteration on alphabets).\\n2) Run a loop over words vector and a nested loop for the alphabets.\\n3) Then find the position of alphabet in order string, if it\\'s not found then return 0.\\n4) compare the position index obtained from previous step.\\n\\nI\\'m failing on the 119 test case :\\n[\"aa\",\"a\"]\\n\"abqwertyuioplkjhgfdszxcvnm\"\\n\\n ` bool isAlienSorted(vector<string>& words, string order) {\\n        int mx  = 0;\\n        for(int i=0; i<words.size(); i++){\\n           int s = words[i].size();\\n           mx = max(mx, s);\\n        }\\n        for(int i=1; i<words.size(); i++){\\n            for(int j=0; j<mx; j++){\\n               int s1 =  order.find(words[i][j]) != -1 ? order.find(words[i][j]) : 0;\\n               int s2 =  order.find(words[i-1][j]) != -1 ? order.find(words[i-1][j]) : 0;\\n               if( s1 < s2) {\\n                    return false;\\n               } \\n               else if(s1 > s2){\\n                   break;\\n               }           \\n            }\\n        }\\n        return true;\\n    }`"
                    },
                    {
                        "username": "aswanthkumar96",
                        "content": "Easy way to do it is to convert into a normal simple problem & solve it. [solution](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130526/c-convert-to-a-normal-simple-problem/)"
                    },
                    {
                        "username": "sanjay_soni",
                        "content": "Very easy ques , Read full to understand completely.\\n\\nwe have given an order of 26 English letters which are not in correct order because it is for an alien dictionary.\\n\\nwe have to check our words are in correct order or not according to this new order.\\n\\nfirst of all map all letter of order using a map<char,int>map;\\n\\nthen pick first two words and check if they are in correct order or not. \\ndo it for all.\\nreturn true if correct order otherwise false.\\n\\ncheckout my code from my profile \\nthank you.\\n"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "\\nMy Java Solution using Array (0ms)\\n\\n`class Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int i=1;\\n        int[] lex = new int[26];\\n        for (i = 0; i < order.length(); i++) \\n            lex[order.charAt(i) - \\'a\\'] = i;\\n        \\n        for(i=0;i<words.length-1;i++){\\n            if(!check(words[i] , words[i+1] , lex))\\n                return false;\\n        }\\n        return true;\\n    }\\n    public boolean check(String s1,String s2 , int[] arr){\\n        int i=0;\\n        while(i<s1.length() && i< s2.length()){\\n            if(arr[s1.charAt(i)-\\'a\\'] < arr[s2.charAt(i)-\\'a\\'])\\n                return true;\\n            \\n            else if(arr[s1.charAt(i)-\\'a\\'] > arr[s2.charAt(i)-\\'a\\'])\\n                return false;\\n            i++;\\n        }\\n        if(i==s1.length())\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "first approch is comming into my mind is too loop through all word and index of each word and check if first index is smaller or not"
                    }
                ]
            },
            {
                "id": 1784629,
                "content": [
                    {
                        "username": "coder42032",
                        "content": "After 4 wrong submission Now I can understand why people dislike this Question. But testcases are very well designed by leetcode."
                    },
                    {
                        "username": "racemus",
                        "content": "It\\'s a oneliner with sort and lambda :)"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "after the struggle of 38 minutes, i finally solved it...\nquestion says that, in simple,\nthere is a guy and that guy has dictionary and that dictionary contains `english letters` but the order is not like `a-to-z` it is different than `a-to-z` and which is given to us, i.e. order string\nand we've given the `list of words` which contains some words and you've to check that the, words are given to us are lexographically arranged or not, based on the order string\n\nhere \n```\nwords = [\"hello\",\"leetcode\"], \norder = \"hlabcdefgijkmnopqrstuvwxyz\"\nin dictionary \nh----\nhe---\nhello\n...\n....\nleetcode \n```\nif you check the order we can see that h comes before l in order string so they are directly, arranged [lexographically]\n\nex. 2\n```\nwords = [\"apple\",\"app\"], \norder = \"abcdefghijklmnopqrstuvwxyz\"\n\na-----\nap---\napple\napp\n```\nas you can see the app comes before the apple but\napple then app comes so, they are not arranged in lexographically\n\n```https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130966/my-brute-force-solution-easy/```"
                    },
                    {
                        "username": "Harryd0311",
                        "content": "words =\\n[\"kuvp\",\"q\"]\\norder =\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\n\"kuvp\" maps to \"ormv\"\\n\"q\" maps to \"b\"\\nand \"b\" comes before \"ormv\"\\nhow is the test case expecting answer as true?\\ncan anyone explain"
                    },
                    {
                        "username": "Fz_coder",
                        "content": "1. to Check isSorted or not then check only there adjacent element instead compare with all element\\n2. if first charter is same then check for next character and same in recersive manner\\n"
                    },
                    {
                        "username": "Madhav-2003",
                        "content": "can anyone explain the question in a simple way ?"
                    },
                    {
                        "username": "peterjohncoles",
                        "content": "You are trying to check whether the words in the array are in the correct dictionary order according to the order of the letters given. For the first example \"hello\", \"leetcode\" it returns true because h comes before l in the order. Just like aardvark comes before apple in an English dictionary. "
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "Help needed!!\\nThis problem took me 15 minutes to understand.\\nMy approach:\\n1) Find the string of max size in words vector (for iteration on alphabets).\\n2) Run a loop over words vector and a nested loop for the alphabets.\\n3) Then find the position of alphabet in order string, if it\\'s not found then return 0.\\n4) compare the position index obtained from previous step.\\n\\nI\\'m failing on the 119 test case :\\n[\"aa\",\"a\"]\\n\"abqwertyuioplkjhgfdszxcvnm\"\\n\\n ` bool isAlienSorted(vector<string>& words, string order) {\\n        int mx  = 0;\\n        for(int i=0; i<words.size(); i++){\\n           int s = words[i].size();\\n           mx = max(mx, s);\\n        }\\n        for(int i=1; i<words.size(); i++){\\n            for(int j=0; j<mx; j++){\\n               int s1 =  order.find(words[i][j]) != -1 ? order.find(words[i][j]) : 0;\\n               int s2 =  order.find(words[i-1][j]) != -1 ? order.find(words[i-1][j]) : 0;\\n               if( s1 < s2) {\\n                    return false;\\n               } \\n               else if(s1 > s2){\\n                   break;\\n               }           \\n            }\\n        }\\n        return true;\\n    }`"
                    },
                    {
                        "username": "aswanthkumar96",
                        "content": "Easy way to do it is to convert into a normal simple problem & solve it. [solution](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130526/c-convert-to-a-normal-simple-problem/)"
                    },
                    {
                        "username": "sanjay_soni",
                        "content": "Very easy ques , Read full to understand completely.\\n\\nwe have given an order of 26 English letters which are not in correct order because it is for an alien dictionary.\\n\\nwe have to check our words are in correct order or not according to this new order.\\n\\nfirst of all map all letter of order using a map<char,int>map;\\n\\nthen pick first two words and check if they are in correct order or not. \\ndo it for all.\\nreturn true if correct order otherwise false.\\n\\ncheckout my code from my profile \\nthank you.\\n"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "\\nMy Java Solution using Array (0ms)\\n\\n`class Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int i=1;\\n        int[] lex = new int[26];\\n        for (i = 0; i < order.length(); i++) \\n            lex[order.charAt(i) - \\'a\\'] = i;\\n        \\n        for(i=0;i<words.length-1;i++){\\n            if(!check(words[i] , words[i+1] , lex))\\n                return false;\\n        }\\n        return true;\\n    }\\n    public boolean check(String s1,String s2 , int[] arr){\\n        int i=0;\\n        while(i<s1.length() && i< s2.length()){\\n            if(arr[s1.charAt(i)-\\'a\\'] < arr[s2.charAt(i)-\\'a\\'])\\n                return true;\\n            \\n            else if(arr[s1.charAt(i)-\\'a\\'] > arr[s2.charAt(i)-\\'a\\'])\\n                return false;\\n            i++;\\n        }\\n        if(i==s1.length())\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "first approch is comming into my mind is too loop through all word and index of each word and check if first index is smaller or not"
                    }
                ]
            },
            {
                "id": 1784570,
                "content": [
                    {
                        "username": "coder42032",
                        "content": "After 4 wrong submission Now I can understand why people dislike this Question. But testcases are very well designed by leetcode."
                    },
                    {
                        "username": "racemus",
                        "content": "It\\'s a oneliner with sort and lambda :)"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "after the struggle of 38 minutes, i finally solved it...\nquestion says that, in simple,\nthere is a guy and that guy has dictionary and that dictionary contains `english letters` but the order is not like `a-to-z` it is different than `a-to-z` and which is given to us, i.e. order string\nand we've given the `list of words` which contains some words and you've to check that the, words are given to us are lexographically arranged or not, based on the order string\n\nhere \n```\nwords = [\"hello\",\"leetcode\"], \norder = \"hlabcdefgijkmnopqrstuvwxyz\"\nin dictionary \nh----\nhe---\nhello\n...\n....\nleetcode \n```\nif you check the order we can see that h comes before l in order string so they are directly, arranged [lexographically]\n\nex. 2\n```\nwords = [\"apple\",\"app\"], \norder = \"abcdefghijklmnopqrstuvwxyz\"\n\na-----\nap---\napple\napp\n```\nas you can see the app comes before the apple but\napple then app comes so, they are not arranged in lexographically\n\n```https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130966/my-brute-force-solution-easy/```"
                    },
                    {
                        "username": "Harryd0311",
                        "content": "words =\\n[\"kuvp\",\"q\"]\\norder =\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\n\"kuvp\" maps to \"ormv\"\\n\"q\" maps to \"b\"\\nand \"b\" comes before \"ormv\"\\nhow is the test case expecting answer as true?\\ncan anyone explain"
                    },
                    {
                        "username": "Fz_coder",
                        "content": "1. to Check isSorted or not then check only there adjacent element instead compare with all element\\n2. if first charter is same then check for next character and same in recersive manner\\n"
                    },
                    {
                        "username": "Madhav-2003",
                        "content": "can anyone explain the question in a simple way ?"
                    },
                    {
                        "username": "peterjohncoles",
                        "content": "You are trying to check whether the words in the array are in the correct dictionary order according to the order of the letters given. For the first example \"hello\", \"leetcode\" it returns true because h comes before l in the order. Just like aardvark comes before apple in an English dictionary. "
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "Help needed!!\\nThis problem took me 15 minutes to understand.\\nMy approach:\\n1) Find the string of max size in words vector (for iteration on alphabets).\\n2) Run a loop over words vector and a nested loop for the alphabets.\\n3) Then find the position of alphabet in order string, if it\\'s not found then return 0.\\n4) compare the position index obtained from previous step.\\n\\nI\\'m failing on the 119 test case :\\n[\"aa\",\"a\"]\\n\"abqwertyuioplkjhgfdszxcvnm\"\\n\\n ` bool isAlienSorted(vector<string>& words, string order) {\\n        int mx  = 0;\\n        for(int i=0; i<words.size(); i++){\\n           int s = words[i].size();\\n           mx = max(mx, s);\\n        }\\n        for(int i=1; i<words.size(); i++){\\n            for(int j=0; j<mx; j++){\\n               int s1 =  order.find(words[i][j]) != -1 ? order.find(words[i][j]) : 0;\\n               int s2 =  order.find(words[i-1][j]) != -1 ? order.find(words[i-1][j]) : 0;\\n               if( s1 < s2) {\\n                    return false;\\n               } \\n               else if(s1 > s2){\\n                   break;\\n               }           \\n            }\\n        }\\n        return true;\\n    }`"
                    },
                    {
                        "username": "aswanthkumar96",
                        "content": "Easy way to do it is to convert into a normal simple problem & solve it. [solution](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130526/c-convert-to-a-normal-simple-problem/)"
                    },
                    {
                        "username": "sanjay_soni",
                        "content": "Very easy ques , Read full to understand completely.\\n\\nwe have given an order of 26 English letters which are not in correct order because it is for an alien dictionary.\\n\\nwe have to check our words are in correct order or not according to this new order.\\n\\nfirst of all map all letter of order using a map<char,int>map;\\n\\nthen pick first two words and check if they are in correct order or not. \\ndo it for all.\\nreturn true if correct order otherwise false.\\n\\ncheckout my code from my profile \\nthank you.\\n"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "\\nMy Java Solution using Array (0ms)\\n\\n`class Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int i=1;\\n        int[] lex = new int[26];\\n        for (i = 0; i < order.length(); i++) \\n            lex[order.charAt(i) - \\'a\\'] = i;\\n        \\n        for(i=0;i<words.length-1;i++){\\n            if(!check(words[i] , words[i+1] , lex))\\n                return false;\\n        }\\n        return true;\\n    }\\n    public boolean check(String s1,String s2 , int[] arr){\\n        int i=0;\\n        while(i<s1.length() && i< s2.length()){\\n            if(arr[s1.charAt(i)-\\'a\\'] < arr[s2.charAt(i)-\\'a\\'])\\n                return true;\\n            \\n            else if(arr[s1.charAt(i)-\\'a\\'] > arr[s2.charAt(i)-\\'a\\'])\\n                return false;\\n            i++;\\n        }\\n        if(i==s1.length())\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "first approch is comming into my mind is too loop through all word and index of each word and check if first index is smaller or not"
                    }
                ]
            },
            {
                "id": 1784529,
                "content": [
                    {
                        "username": "coder42032",
                        "content": "After 4 wrong submission Now I can understand why people dislike this Question. But testcases are very well designed by leetcode."
                    },
                    {
                        "username": "racemus",
                        "content": "It\\'s a oneliner with sort and lambda :)"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "after the struggle of 38 minutes, i finally solved it...\nquestion says that, in simple,\nthere is a guy and that guy has dictionary and that dictionary contains `english letters` but the order is not like `a-to-z` it is different than `a-to-z` and which is given to us, i.e. order string\nand we've given the `list of words` which contains some words and you've to check that the, words are given to us are lexographically arranged or not, based on the order string\n\nhere \n```\nwords = [\"hello\",\"leetcode\"], \norder = \"hlabcdefgijkmnopqrstuvwxyz\"\nin dictionary \nh----\nhe---\nhello\n...\n....\nleetcode \n```\nif you check the order we can see that h comes before l in order string so they are directly, arranged [lexographically]\n\nex. 2\n```\nwords = [\"apple\",\"app\"], \norder = \"abcdefghijklmnopqrstuvwxyz\"\n\na-----\nap---\napple\napp\n```\nas you can see the app comes before the apple but\napple then app comes so, they are not arranged in lexographically\n\n```https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130966/my-brute-force-solution-easy/```"
                    },
                    {
                        "username": "Harryd0311",
                        "content": "words =\\n[\"kuvp\",\"q\"]\\norder =\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\n\"kuvp\" maps to \"ormv\"\\n\"q\" maps to \"b\"\\nand \"b\" comes before \"ormv\"\\nhow is the test case expecting answer as true?\\ncan anyone explain"
                    },
                    {
                        "username": "Fz_coder",
                        "content": "1. to Check isSorted or not then check only there adjacent element instead compare with all element\\n2. if first charter is same then check for next character and same in recersive manner\\n"
                    },
                    {
                        "username": "Madhav-2003",
                        "content": "can anyone explain the question in a simple way ?"
                    },
                    {
                        "username": "peterjohncoles",
                        "content": "You are trying to check whether the words in the array are in the correct dictionary order according to the order of the letters given. For the first example \"hello\", \"leetcode\" it returns true because h comes before l in the order. Just like aardvark comes before apple in an English dictionary. "
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "Help needed!!\\nThis problem took me 15 minutes to understand.\\nMy approach:\\n1) Find the string of max size in words vector (for iteration on alphabets).\\n2) Run a loop over words vector and a nested loop for the alphabets.\\n3) Then find the position of alphabet in order string, if it\\'s not found then return 0.\\n4) compare the position index obtained from previous step.\\n\\nI\\'m failing on the 119 test case :\\n[\"aa\",\"a\"]\\n\"abqwertyuioplkjhgfdszxcvnm\"\\n\\n ` bool isAlienSorted(vector<string>& words, string order) {\\n        int mx  = 0;\\n        for(int i=0; i<words.size(); i++){\\n           int s = words[i].size();\\n           mx = max(mx, s);\\n        }\\n        for(int i=1; i<words.size(); i++){\\n            for(int j=0; j<mx; j++){\\n               int s1 =  order.find(words[i][j]) != -1 ? order.find(words[i][j]) : 0;\\n               int s2 =  order.find(words[i-1][j]) != -1 ? order.find(words[i-1][j]) : 0;\\n               if( s1 < s2) {\\n                    return false;\\n               } \\n               else if(s1 > s2){\\n                   break;\\n               }           \\n            }\\n        }\\n        return true;\\n    }`"
                    },
                    {
                        "username": "aswanthkumar96",
                        "content": "Easy way to do it is to convert into a normal simple problem & solve it. [solution](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130526/c-convert-to-a-normal-simple-problem/)"
                    },
                    {
                        "username": "sanjay_soni",
                        "content": "Very easy ques , Read full to understand completely.\\n\\nwe have given an order of 26 English letters which are not in correct order because it is for an alien dictionary.\\n\\nwe have to check our words are in correct order or not according to this new order.\\n\\nfirst of all map all letter of order using a map<char,int>map;\\n\\nthen pick first two words and check if they are in correct order or not. \\ndo it for all.\\nreturn true if correct order otherwise false.\\n\\ncheckout my code from my profile \\nthank you.\\n"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "\\nMy Java Solution using Array (0ms)\\n\\n`class Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int i=1;\\n        int[] lex = new int[26];\\n        for (i = 0; i < order.length(); i++) \\n            lex[order.charAt(i) - \\'a\\'] = i;\\n        \\n        for(i=0;i<words.length-1;i++){\\n            if(!check(words[i] , words[i+1] , lex))\\n                return false;\\n        }\\n        return true;\\n    }\\n    public boolean check(String s1,String s2 , int[] arr){\\n        int i=0;\\n        while(i<s1.length() && i< s2.length()){\\n            if(arr[s1.charAt(i)-\\'a\\'] < arr[s2.charAt(i)-\\'a\\'])\\n                return true;\\n            \\n            else if(arr[s1.charAt(i)-\\'a\\'] > arr[s2.charAt(i)-\\'a\\'])\\n                return false;\\n            i++;\\n        }\\n        if(i==s1.length())\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "first approch is comming into my mind is too loop through all word and index of each word and check if first index is smaller or not"
                    }
                ]
            },
            {
                "id": 1784524,
                "content": [
                    {
                        "username": "coder42032",
                        "content": "After 4 wrong submission Now I can understand why people dislike this Question. But testcases are very well designed by leetcode."
                    },
                    {
                        "username": "racemus",
                        "content": "It\\'s a oneliner with sort and lambda :)"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "after the struggle of 38 minutes, i finally solved it...\nquestion says that, in simple,\nthere is a guy and that guy has dictionary and that dictionary contains `english letters` but the order is not like `a-to-z` it is different than `a-to-z` and which is given to us, i.e. order string\nand we've given the `list of words` which contains some words and you've to check that the, words are given to us are lexographically arranged or not, based on the order string\n\nhere \n```\nwords = [\"hello\",\"leetcode\"], \norder = \"hlabcdefgijkmnopqrstuvwxyz\"\nin dictionary \nh----\nhe---\nhello\n...\n....\nleetcode \n```\nif you check the order we can see that h comes before l in order string so they are directly, arranged [lexographically]\n\nex. 2\n```\nwords = [\"apple\",\"app\"], \norder = \"abcdefghijklmnopqrstuvwxyz\"\n\na-----\nap---\napple\napp\n```\nas you can see the app comes before the apple but\napple then app comes so, they are not arranged in lexographically\n\n```https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130966/my-brute-force-solution-easy/```"
                    },
                    {
                        "username": "Harryd0311",
                        "content": "words =\\n[\"kuvp\",\"q\"]\\norder =\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\n\"kuvp\" maps to \"ormv\"\\n\"q\" maps to \"b\"\\nand \"b\" comes before \"ormv\"\\nhow is the test case expecting answer as true?\\ncan anyone explain"
                    },
                    {
                        "username": "Fz_coder",
                        "content": "1. to Check isSorted or not then check only there adjacent element instead compare with all element\\n2. if first charter is same then check for next character and same in recersive manner\\n"
                    },
                    {
                        "username": "Madhav-2003",
                        "content": "can anyone explain the question in a simple way ?"
                    },
                    {
                        "username": "peterjohncoles",
                        "content": "You are trying to check whether the words in the array are in the correct dictionary order according to the order of the letters given. For the first example \"hello\", \"leetcode\" it returns true because h comes before l in the order. Just like aardvark comes before apple in an English dictionary. "
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "Help needed!!\\nThis problem took me 15 minutes to understand.\\nMy approach:\\n1) Find the string of max size in words vector (for iteration on alphabets).\\n2) Run a loop over words vector and a nested loop for the alphabets.\\n3) Then find the position of alphabet in order string, if it\\'s not found then return 0.\\n4) compare the position index obtained from previous step.\\n\\nI\\'m failing on the 119 test case :\\n[\"aa\",\"a\"]\\n\"abqwertyuioplkjhgfdszxcvnm\"\\n\\n ` bool isAlienSorted(vector<string>& words, string order) {\\n        int mx  = 0;\\n        for(int i=0; i<words.size(); i++){\\n           int s = words[i].size();\\n           mx = max(mx, s);\\n        }\\n        for(int i=1; i<words.size(); i++){\\n            for(int j=0; j<mx; j++){\\n               int s1 =  order.find(words[i][j]) != -1 ? order.find(words[i][j]) : 0;\\n               int s2 =  order.find(words[i-1][j]) != -1 ? order.find(words[i-1][j]) : 0;\\n               if( s1 < s2) {\\n                    return false;\\n               } \\n               else if(s1 > s2){\\n                   break;\\n               }           \\n            }\\n        }\\n        return true;\\n    }`"
                    },
                    {
                        "username": "aswanthkumar96",
                        "content": "Easy way to do it is to convert into a normal simple problem & solve it. [solution](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130526/c-convert-to-a-normal-simple-problem/)"
                    },
                    {
                        "username": "sanjay_soni",
                        "content": "Very easy ques , Read full to understand completely.\\n\\nwe have given an order of 26 English letters which are not in correct order because it is for an alien dictionary.\\n\\nwe have to check our words are in correct order or not according to this new order.\\n\\nfirst of all map all letter of order using a map<char,int>map;\\n\\nthen pick first two words and check if they are in correct order or not. \\ndo it for all.\\nreturn true if correct order otherwise false.\\n\\ncheckout my code from my profile \\nthank you.\\n"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "\\nMy Java Solution using Array (0ms)\\n\\n`class Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int i=1;\\n        int[] lex = new int[26];\\n        for (i = 0; i < order.length(); i++) \\n            lex[order.charAt(i) - \\'a\\'] = i;\\n        \\n        for(i=0;i<words.length-1;i++){\\n            if(!check(words[i] , words[i+1] , lex))\\n                return false;\\n        }\\n        return true;\\n    }\\n    public boolean check(String s1,String s2 , int[] arr){\\n        int i=0;\\n        while(i<s1.length() && i< s2.length()){\\n            if(arr[s1.charAt(i)-\\'a\\'] < arr[s2.charAt(i)-\\'a\\'])\\n                return true;\\n            \\n            else if(arr[s1.charAt(i)-\\'a\\'] > arr[s2.charAt(i)-\\'a\\'])\\n                return false;\\n            i++;\\n        }\\n        if(i==s1.length())\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "first approch is comming into my mind is too loop through all word and index of each word and check if first index is smaller or not"
                    }
                ]
            },
            {
                "id": 1784488,
                "content": [
                    {
                        "username": "coder42032",
                        "content": "After 4 wrong submission Now I can understand why people dislike this Question. But testcases are very well designed by leetcode."
                    },
                    {
                        "username": "racemus",
                        "content": "It\\'s a oneliner with sort and lambda :)"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "after the struggle of 38 minutes, i finally solved it...\nquestion says that, in simple,\nthere is a guy and that guy has dictionary and that dictionary contains `english letters` but the order is not like `a-to-z` it is different than `a-to-z` and which is given to us, i.e. order string\nand we've given the `list of words` which contains some words and you've to check that the, words are given to us are lexographically arranged or not, based on the order string\n\nhere \n```\nwords = [\"hello\",\"leetcode\"], \norder = \"hlabcdefgijkmnopqrstuvwxyz\"\nin dictionary \nh----\nhe---\nhello\n...\n....\nleetcode \n```\nif you check the order we can see that h comes before l in order string so they are directly, arranged [lexographically]\n\nex. 2\n```\nwords = [\"apple\",\"app\"], \norder = \"abcdefghijklmnopqrstuvwxyz\"\n\na-----\nap---\napple\napp\n```\nas you can see the app comes before the apple but\napple then app comes so, they are not arranged in lexographically\n\n```https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130966/my-brute-force-solution-easy/```"
                    },
                    {
                        "username": "Harryd0311",
                        "content": "words =\\n[\"kuvp\",\"q\"]\\norder =\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\n\"kuvp\" maps to \"ormv\"\\n\"q\" maps to \"b\"\\nand \"b\" comes before \"ormv\"\\nhow is the test case expecting answer as true?\\ncan anyone explain"
                    },
                    {
                        "username": "Fz_coder",
                        "content": "1. to Check isSorted or not then check only there adjacent element instead compare with all element\\n2. if first charter is same then check for next character and same in recersive manner\\n"
                    },
                    {
                        "username": "Madhav-2003",
                        "content": "can anyone explain the question in a simple way ?"
                    },
                    {
                        "username": "peterjohncoles",
                        "content": "You are trying to check whether the words in the array are in the correct dictionary order according to the order of the letters given. For the first example \"hello\", \"leetcode\" it returns true because h comes before l in the order. Just like aardvark comes before apple in an English dictionary. "
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "Help needed!!\\nThis problem took me 15 minutes to understand.\\nMy approach:\\n1) Find the string of max size in words vector (for iteration on alphabets).\\n2) Run a loop over words vector and a nested loop for the alphabets.\\n3) Then find the position of alphabet in order string, if it\\'s not found then return 0.\\n4) compare the position index obtained from previous step.\\n\\nI\\'m failing on the 119 test case :\\n[\"aa\",\"a\"]\\n\"abqwertyuioplkjhgfdszxcvnm\"\\n\\n ` bool isAlienSorted(vector<string>& words, string order) {\\n        int mx  = 0;\\n        for(int i=0; i<words.size(); i++){\\n           int s = words[i].size();\\n           mx = max(mx, s);\\n        }\\n        for(int i=1; i<words.size(); i++){\\n            for(int j=0; j<mx; j++){\\n               int s1 =  order.find(words[i][j]) != -1 ? order.find(words[i][j]) : 0;\\n               int s2 =  order.find(words[i-1][j]) != -1 ? order.find(words[i-1][j]) : 0;\\n               if( s1 < s2) {\\n                    return false;\\n               } \\n               else if(s1 > s2){\\n                   break;\\n               }           \\n            }\\n        }\\n        return true;\\n    }`"
                    },
                    {
                        "username": "aswanthkumar96",
                        "content": "Easy way to do it is to convert into a normal simple problem & solve it. [solution](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130526/c-convert-to-a-normal-simple-problem/)"
                    },
                    {
                        "username": "sanjay_soni",
                        "content": "Very easy ques , Read full to understand completely.\\n\\nwe have given an order of 26 English letters which are not in correct order because it is for an alien dictionary.\\n\\nwe have to check our words are in correct order or not according to this new order.\\n\\nfirst of all map all letter of order using a map<char,int>map;\\n\\nthen pick first two words and check if they are in correct order or not. \\ndo it for all.\\nreturn true if correct order otherwise false.\\n\\ncheckout my code from my profile \\nthank you.\\n"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "\\nMy Java Solution using Array (0ms)\\n\\n`class Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int i=1;\\n        int[] lex = new int[26];\\n        for (i = 0; i < order.length(); i++) \\n            lex[order.charAt(i) - \\'a\\'] = i;\\n        \\n        for(i=0;i<words.length-1;i++){\\n            if(!check(words[i] , words[i+1] , lex))\\n                return false;\\n        }\\n        return true;\\n    }\\n    public boolean check(String s1,String s2 , int[] arr){\\n        int i=0;\\n        while(i<s1.length() && i< s2.length()){\\n            if(arr[s1.charAt(i)-\\'a\\'] < arr[s2.charAt(i)-\\'a\\'])\\n                return true;\\n            \\n            else if(arr[s1.charAt(i)-\\'a\\'] > arr[s2.charAt(i)-\\'a\\'])\\n                return false;\\n            i++;\\n        }\\n        if(i==s1.length())\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "first approch is comming into my mind is too loop through all word and index of each word and check if first index is smaller or not"
                    }
                ]
            },
            {
                "id": 1784448,
                "content": [
                    {
                        "username": "coder42032",
                        "content": "After 4 wrong submission Now I can understand why people dislike this Question. But testcases are very well designed by leetcode."
                    },
                    {
                        "username": "racemus",
                        "content": "It\\'s a oneliner with sort and lambda :)"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "after the struggle of 38 minutes, i finally solved it...\nquestion says that, in simple,\nthere is a guy and that guy has dictionary and that dictionary contains `english letters` but the order is not like `a-to-z` it is different than `a-to-z` and which is given to us, i.e. order string\nand we've given the `list of words` which contains some words and you've to check that the, words are given to us are lexographically arranged or not, based on the order string\n\nhere \n```\nwords = [\"hello\",\"leetcode\"], \norder = \"hlabcdefgijkmnopqrstuvwxyz\"\nin dictionary \nh----\nhe---\nhello\n...\n....\nleetcode \n```\nif you check the order we can see that h comes before l in order string so they are directly, arranged [lexographically]\n\nex. 2\n```\nwords = [\"apple\",\"app\"], \norder = \"abcdefghijklmnopqrstuvwxyz\"\n\na-----\nap---\napple\napp\n```\nas you can see the app comes before the apple but\napple then app comes so, they are not arranged in lexographically\n\n```https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130966/my-brute-force-solution-easy/```"
                    },
                    {
                        "username": "Harryd0311",
                        "content": "words =\\n[\"kuvp\",\"q\"]\\norder =\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\n\"kuvp\" maps to \"ormv\"\\n\"q\" maps to \"b\"\\nand \"b\" comes before \"ormv\"\\nhow is the test case expecting answer as true?\\ncan anyone explain"
                    },
                    {
                        "username": "Fz_coder",
                        "content": "1. to Check isSorted or not then check only there adjacent element instead compare with all element\\n2. if first charter is same then check for next character and same in recersive manner\\n"
                    },
                    {
                        "username": "Madhav-2003",
                        "content": "can anyone explain the question in a simple way ?"
                    },
                    {
                        "username": "peterjohncoles",
                        "content": "You are trying to check whether the words in the array are in the correct dictionary order according to the order of the letters given. For the first example \"hello\", \"leetcode\" it returns true because h comes before l in the order. Just like aardvark comes before apple in an English dictionary. "
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "Help needed!!\\nThis problem took me 15 minutes to understand.\\nMy approach:\\n1) Find the string of max size in words vector (for iteration on alphabets).\\n2) Run a loop over words vector and a nested loop for the alphabets.\\n3) Then find the position of alphabet in order string, if it\\'s not found then return 0.\\n4) compare the position index obtained from previous step.\\n\\nI\\'m failing on the 119 test case :\\n[\"aa\",\"a\"]\\n\"abqwertyuioplkjhgfdszxcvnm\"\\n\\n ` bool isAlienSorted(vector<string>& words, string order) {\\n        int mx  = 0;\\n        for(int i=0; i<words.size(); i++){\\n           int s = words[i].size();\\n           mx = max(mx, s);\\n        }\\n        for(int i=1; i<words.size(); i++){\\n            for(int j=0; j<mx; j++){\\n               int s1 =  order.find(words[i][j]) != -1 ? order.find(words[i][j]) : 0;\\n               int s2 =  order.find(words[i-1][j]) != -1 ? order.find(words[i-1][j]) : 0;\\n               if( s1 < s2) {\\n                    return false;\\n               } \\n               else if(s1 > s2){\\n                   break;\\n               }           \\n            }\\n        }\\n        return true;\\n    }`"
                    },
                    {
                        "username": "aswanthkumar96",
                        "content": "Easy way to do it is to convert into a normal simple problem & solve it. [solution](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130526/c-convert-to-a-normal-simple-problem/)"
                    },
                    {
                        "username": "sanjay_soni",
                        "content": "Very easy ques , Read full to understand completely.\\n\\nwe have given an order of 26 English letters which are not in correct order because it is for an alien dictionary.\\n\\nwe have to check our words are in correct order or not according to this new order.\\n\\nfirst of all map all letter of order using a map<char,int>map;\\n\\nthen pick first two words and check if they are in correct order or not. \\ndo it for all.\\nreturn true if correct order otherwise false.\\n\\ncheckout my code from my profile \\nthank you.\\n"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "\\nMy Java Solution using Array (0ms)\\n\\n`class Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int i=1;\\n        int[] lex = new int[26];\\n        for (i = 0; i < order.length(); i++) \\n            lex[order.charAt(i) - \\'a\\'] = i;\\n        \\n        for(i=0;i<words.length-1;i++){\\n            if(!check(words[i] , words[i+1] , lex))\\n                return false;\\n        }\\n        return true;\\n    }\\n    public boolean check(String s1,String s2 , int[] arr){\\n        int i=0;\\n        while(i<s1.length() && i< s2.length()){\\n            if(arr[s1.charAt(i)-\\'a\\'] < arr[s2.charAt(i)-\\'a\\'])\\n                return true;\\n            \\n            else if(arr[s1.charAt(i)-\\'a\\'] > arr[s2.charAt(i)-\\'a\\'])\\n                return false;\\n            i++;\\n        }\\n        if(i==s1.length())\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "first approch is comming into my mind is too loop through all word and index of each word and check if first index is smaller or not"
                    }
                ]
            },
            {
                "id": 1784429,
                "content": [
                    {
                        "username": "coder42032",
                        "content": "After 4 wrong submission Now I can understand why people dislike this Question. But testcases are very well designed by leetcode."
                    },
                    {
                        "username": "racemus",
                        "content": "It\\'s a oneliner with sort and lambda :)"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "after the struggle of 38 minutes, i finally solved it...\nquestion says that, in simple,\nthere is a guy and that guy has dictionary and that dictionary contains `english letters` but the order is not like `a-to-z` it is different than `a-to-z` and which is given to us, i.e. order string\nand we've given the `list of words` which contains some words and you've to check that the, words are given to us are lexographically arranged or not, based on the order string\n\nhere \n```\nwords = [\"hello\",\"leetcode\"], \norder = \"hlabcdefgijkmnopqrstuvwxyz\"\nin dictionary \nh----\nhe---\nhello\n...\n....\nleetcode \n```\nif you check the order we can see that h comes before l in order string so they are directly, arranged [lexographically]\n\nex. 2\n```\nwords = [\"apple\",\"app\"], \norder = \"abcdefghijklmnopqrstuvwxyz\"\n\na-----\nap---\napple\napp\n```\nas you can see the app comes before the apple but\napple then app comes so, they are not arranged in lexographically\n\n```https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130966/my-brute-force-solution-easy/```"
                    },
                    {
                        "username": "Harryd0311",
                        "content": "words =\\n[\"kuvp\",\"q\"]\\norder =\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\n\"kuvp\" maps to \"ormv\"\\n\"q\" maps to \"b\"\\nand \"b\" comes before \"ormv\"\\nhow is the test case expecting answer as true?\\ncan anyone explain"
                    },
                    {
                        "username": "Fz_coder",
                        "content": "1. to Check isSorted or not then check only there adjacent element instead compare with all element\\n2. if first charter is same then check for next character and same in recersive manner\\n"
                    },
                    {
                        "username": "Madhav-2003",
                        "content": "can anyone explain the question in a simple way ?"
                    },
                    {
                        "username": "peterjohncoles",
                        "content": "You are trying to check whether the words in the array are in the correct dictionary order according to the order of the letters given. For the first example \"hello\", \"leetcode\" it returns true because h comes before l in the order. Just like aardvark comes before apple in an English dictionary. "
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "Help needed!!\\nThis problem took me 15 minutes to understand.\\nMy approach:\\n1) Find the string of max size in words vector (for iteration on alphabets).\\n2) Run a loop over words vector and a nested loop for the alphabets.\\n3) Then find the position of alphabet in order string, if it\\'s not found then return 0.\\n4) compare the position index obtained from previous step.\\n\\nI\\'m failing on the 119 test case :\\n[\"aa\",\"a\"]\\n\"abqwertyuioplkjhgfdszxcvnm\"\\n\\n ` bool isAlienSorted(vector<string>& words, string order) {\\n        int mx  = 0;\\n        for(int i=0; i<words.size(); i++){\\n           int s = words[i].size();\\n           mx = max(mx, s);\\n        }\\n        for(int i=1; i<words.size(); i++){\\n            for(int j=0; j<mx; j++){\\n               int s1 =  order.find(words[i][j]) != -1 ? order.find(words[i][j]) : 0;\\n               int s2 =  order.find(words[i-1][j]) != -1 ? order.find(words[i-1][j]) : 0;\\n               if( s1 < s2) {\\n                    return false;\\n               } \\n               else if(s1 > s2){\\n                   break;\\n               }           \\n            }\\n        }\\n        return true;\\n    }`"
                    },
                    {
                        "username": "aswanthkumar96",
                        "content": "Easy way to do it is to convert into a normal simple problem & solve it. [solution](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130526/c-convert-to-a-normal-simple-problem/)"
                    },
                    {
                        "username": "sanjay_soni",
                        "content": "Very easy ques , Read full to understand completely.\\n\\nwe have given an order of 26 English letters which are not in correct order because it is for an alien dictionary.\\n\\nwe have to check our words are in correct order or not according to this new order.\\n\\nfirst of all map all letter of order using a map<char,int>map;\\n\\nthen pick first two words and check if they are in correct order or not. \\ndo it for all.\\nreturn true if correct order otherwise false.\\n\\ncheckout my code from my profile \\nthank you.\\n"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "\\nMy Java Solution using Array (0ms)\\n\\n`class Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int i=1;\\n        int[] lex = new int[26];\\n        for (i = 0; i < order.length(); i++) \\n            lex[order.charAt(i) - \\'a\\'] = i;\\n        \\n        for(i=0;i<words.length-1;i++){\\n            if(!check(words[i] , words[i+1] , lex))\\n                return false;\\n        }\\n        return true;\\n    }\\n    public boolean check(String s1,String s2 , int[] arr){\\n        int i=0;\\n        while(i<s1.length() && i< s2.length()){\\n            if(arr[s1.charAt(i)-\\'a\\'] < arr[s2.charAt(i)-\\'a\\'])\\n                return true;\\n            \\n            else if(arr[s1.charAt(i)-\\'a\\'] > arr[s2.charAt(i)-\\'a\\'])\\n                return false;\\n            i++;\\n        }\\n        if(i==s1.length())\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "first approch is comming into my mind is too loop through all word and index of each word and check if first index is smaller or not"
                    }
                ]
            },
            {
                "id": 1784420,
                "content": [
                    {
                        "username": "coder42032",
                        "content": "After 4 wrong submission Now I can understand why people dislike this Question. But testcases are very well designed by leetcode."
                    },
                    {
                        "username": "racemus",
                        "content": "It\\'s a oneliner with sort and lambda :)"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "after the struggle of 38 minutes, i finally solved it...\nquestion says that, in simple,\nthere is a guy and that guy has dictionary and that dictionary contains `english letters` but the order is not like `a-to-z` it is different than `a-to-z` and which is given to us, i.e. order string\nand we've given the `list of words` which contains some words and you've to check that the, words are given to us are lexographically arranged or not, based on the order string\n\nhere \n```\nwords = [\"hello\",\"leetcode\"], \norder = \"hlabcdefgijkmnopqrstuvwxyz\"\nin dictionary \nh----\nhe---\nhello\n...\n....\nleetcode \n```\nif you check the order we can see that h comes before l in order string so they are directly, arranged [lexographically]\n\nex. 2\n```\nwords = [\"apple\",\"app\"], \norder = \"abcdefghijklmnopqrstuvwxyz\"\n\na-----\nap---\napple\napp\n```\nas you can see the app comes before the apple but\napple then app comes so, they are not arranged in lexographically\n\n```https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130966/my-brute-force-solution-easy/```"
                    },
                    {
                        "username": "Harryd0311",
                        "content": "words =\\n[\"kuvp\",\"q\"]\\norder =\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\n\"kuvp\" maps to \"ormv\"\\n\"q\" maps to \"b\"\\nand \"b\" comes before \"ormv\"\\nhow is the test case expecting answer as true?\\ncan anyone explain"
                    },
                    {
                        "username": "Fz_coder",
                        "content": "1. to Check isSorted or not then check only there adjacent element instead compare with all element\\n2. if first charter is same then check for next character and same in recersive manner\\n"
                    },
                    {
                        "username": "Madhav-2003",
                        "content": "can anyone explain the question in a simple way ?"
                    },
                    {
                        "username": "peterjohncoles",
                        "content": "You are trying to check whether the words in the array are in the correct dictionary order according to the order of the letters given. For the first example \"hello\", \"leetcode\" it returns true because h comes before l in the order. Just like aardvark comes before apple in an English dictionary. "
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "Help needed!!\\nThis problem took me 15 minutes to understand.\\nMy approach:\\n1) Find the string of max size in words vector (for iteration on alphabets).\\n2) Run a loop over words vector and a nested loop for the alphabets.\\n3) Then find the position of alphabet in order string, if it\\'s not found then return 0.\\n4) compare the position index obtained from previous step.\\n\\nI\\'m failing on the 119 test case :\\n[\"aa\",\"a\"]\\n\"abqwertyuioplkjhgfdszxcvnm\"\\n\\n ` bool isAlienSorted(vector<string>& words, string order) {\\n        int mx  = 0;\\n        for(int i=0; i<words.size(); i++){\\n           int s = words[i].size();\\n           mx = max(mx, s);\\n        }\\n        for(int i=1; i<words.size(); i++){\\n            for(int j=0; j<mx; j++){\\n               int s1 =  order.find(words[i][j]) != -1 ? order.find(words[i][j]) : 0;\\n               int s2 =  order.find(words[i-1][j]) != -1 ? order.find(words[i-1][j]) : 0;\\n               if( s1 < s2) {\\n                    return false;\\n               } \\n               else if(s1 > s2){\\n                   break;\\n               }           \\n            }\\n        }\\n        return true;\\n    }`"
                    },
                    {
                        "username": "aswanthkumar96",
                        "content": "Easy way to do it is to convert into a normal simple problem & solve it. [solution](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130526/c-convert-to-a-normal-simple-problem/)"
                    },
                    {
                        "username": "sanjay_soni",
                        "content": "Very easy ques , Read full to understand completely.\\n\\nwe have given an order of 26 English letters which are not in correct order because it is for an alien dictionary.\\n\\nwe have to check our words are in correct order or not according to this new order.\\n\\nfirst of all map all letter of order using a map<char,int>map;\\n\\nthen pick first two words and check if they are in correct order or not. \\ndo it for all.\\nreturn true if correct order otherwise false.\\n\\ncheckout my code from my profile \\nthank you.\\n"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "\\nMy Java Solution using Array (0ms)\\n\\n`class Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int i=1;\\n        int[] lex = new int[26];\\n        for (i = 0; i < order.length(); i++) \\n            lex[order.charAt(i) - \\'a\\'] = i;\\n        \\n        for(i=0;i<words.length-1;i++){\\n            if(!check(words[i] , words[i+1] , lex))\\n                return false;\\n        }\\n        return true;\\n    }\\n    public boolean check(String s1,String s2 , int[] arr){\\n        int i=0;\\n        while(i<s1.length() && i< s2.length()){\\n            if(arr[s1.charAt(i)-\\'a\\'] < arr[s2.charAt(i)-\\'a\\'])\\n                return true;\\n            \\n            else if(arr[s1.charAt(i)-\\'a\\'] > arr[s2.charAt(i)-\\'a\\'])\\n                return false;\\n            i++;\\n        }\\n        if(i==s1.length())\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "first approch is comming into my mind is too loop through all word and index of each word and check if first index is smaller or not"
                    }
                ]
            },
            {
                "id": 1784418,
                "content": [
                    {
                        "username": "coder42032",
                        "content": "After 4 wrong submission Now I can understand why people dislike this Question. But testcases are very well designed by leetcode."
                    },
                    {
                        "username": "racemus",
                        "content": "It\\'s a oneliner with sort and lambda :)"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "after the struggle of 38 minutes, i finally solved it...\nquestion says that, in simple,\nthere is a guy and that guy has dictionary and that dictionary contains `english letters` but the order is not like `a-to-z` it is different than `a-to-z` and which is given to us, i.e. order string\nand we've given the `list of words` which contains some words and you've to check that the, words are given to us are lexographically arranged or not, based on the order string\n\nhere \n```\nwords = [\"hello\",\"leetcode\"], \norder = \"hlabcdefgijkmnopqrstuvwxyz\"\nin dictionary \nh----\nhe---\nhello\n...\n....\nleetcode \n```\nif you check the order we can see that h comes before l in order string so they are directly, arranged [lexographically]\n\nex. 2\n```\nwords = [\"apple\",\"app\"], \norder = \"abcdefghijklmnopqrstuvwxyz\"\n\na-----\nap---\napple\napp\n```\nas you can see the app comes before the apple but\napple then app comes so, they are not arranged in lexographically\n\n```https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130966/my-brute-force-solution-easy/```"
                    },
                    {
                        "username": "Harryd0311",
                        "content": "words =\\n[\"kuvp\",\"q\"]\\norder =\\n\"ngxlkthsjuoqcpavbfdermiywz\"\\n\\n\"kuvp\" maps to \"ormv\"\\n\"q\" maps to \"b\"\\nand \"b\" comes before \"ormv\"\\nhow is the test case expecting answer as true?\\ncan anyone explain"
                    },
                    {
                        "username": "Fz_coder",
                        "content": "1. to Check isSorted or not then check only there adjacent element instead compare with all element\\n2. if first charter is same then check for next character and same in recersive manner\\n"
                    },
                    {
                        "username": "Madhav-2003",
                        "content": "can anyone explain the question in a simple way ?"
                    },
                    {
                        "username": "peterjohncoles",
                        "content": "You are trying to check whether the words in the array are in the correct dictionary order according to the order of the letters given. For the first example \"hello\", \"leetcode\" it returns true because h comes before l in the order. Just like aardvark comes before apple in an English dictionary. "
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "Help needed!!\\nThis problem took me 15 minutes to understand.\\nMy approach:\\n1) Find the string of max size in words vector (for iteration on alphabets).\\n2) Run a loop over words vector and a nested loop for the alphabets.\\n3) Then find the position of alphabet in order string, if it\\'s not found then return 0.\\n4) compare the position index obtained from previous step.\\n\\nI\\'m failing on the 119 test case :\\n[\"aa\",\"a\"]\\n\"abqwertyuioplkjhgfdszxcvnm\"\\n\\n ` bool isAlienSorted(vector<string>& words, string order) {\\n        int mx  = 0;\\n        for(int i=0; i<words.size(); i++){\\n           int s = words[i].size();\\n           mx = max(mx, s);\\n        }\\n        for(int i=1; i<words.size(); i++){\\n            for(int j=0; j<mx; j++){\\n               int s1 =  order.find(words[i][j]) != -1 ? order.find(words[i][j]) : 0;\\n               int s2 =  order.find(words[i-1][j]) != -1 ? order.find(words[i-1][j]) : 0;\\n               if( s1 < s2) {\\n                    return false;\\n               } \\n               else if(s1 > s2){\\n                   break;\\n               }           \\n            }\\n        }\\n        return true;\\n    }`"
                    },
                    {
                        "username": "aswanthkumar96",
                        "content": "Easy way to do it is to convert into a normal simple problem & solve it. [solution](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130526/c-convert-to-a-normal-simple-problem/)"
                    },
                    {
                        "username": "sanjay_soni",
                        "content": "Very easy ques , Read full to understand completely.\\n\\nwe have given an order of 26 English letters which are not in correct order because it is for an alien dictionary.\\n\\nwe have to check our words are in correct order or not according to this new order.\\n\\nfirst of all map all letter of order using a map<char,int>map;\\n\\nthen pick first two words and check if they are in correct order or not. \\ndo it for all.\\nreturn true if correct order otherwise false.\\n\\ncheckout my code from my profile \\nthank you.\\n"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "\\nMy Java Solution using Array (0ms)\\n\\n`class Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int i=1;\\n        int[] lex = new int[26];\\n        for (i = 0; i < order.length(); i++) \\n            lex[order.charAt(i) - \\'a\\'] = i;\\n        \\n        for(i=0;i<words.length-1;i++){\\n            if(!check(words[i] , words[i+1] , lex))\\n                return false;\\n        }\\n        return true;\\n    }\\n    public boolean check(String s1,String s2 , int[] arr){\\n        int i=0;\\n        while(i<s1.length() && i< s2.length()){\\n            if(arr[s1.charAt(i)-\\'a\\'] < arr[s2.charAt(i)-\\'a\\'])\\n                return true;\\n            \\n            else if(arr[s1.charAt(i)-\\'a\\'] > arr[s2.charAt(i)-\\'a\\'])\\n                return false;\\n            i++;\\n        }\\n        if(i==s1.length())\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "first approch is comming into my mind is too loop through all word and index of each word and check if first index is smaller or not"
                    }
                ]
            },
            {
                "id": 1784405,
                "content": [
                    {
                        "username": "ayushluthra62",
                        "content": "Level : East to Medium But It is Easy as you can easily understand the logic part if you read it\\'s description carefully .<br>\\nHint : use Map <br>\\nMy solution Link : -> https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130389/c-easy-and-simple-solution-using-hashmap/"
                    },
                    {
                        "username": "Vinit171",
                        "content": "words =\n[\"mtkwpj\",\"wlaees\"]\norder =\n\"evhadxsqukcogztlnfjpiymbwr\"\n\nCan somebody explain, why it is giving \"True\" as an output."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Because m is occurring before w so returning true Check my solution  and don\\'t forgot to up vote it .\\n\\n\\nhttps://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130389/c-easy-and-simple-solution-using-hashmap/ "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just looking in the comments to see if someone wrote it should be medium or not :)"
                    },
                    {
                        "username": "_aakash027",
                        "content": "How come this is false\\nwords = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nand this is true\\nwords=[\"apap\",\"app\"], order=\"\"abcdefghijklmnopqrstuvwxyz\"\\n\\nthey both should be false "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@_aakash027](/_aakash027) the problem's description kinda tricky to understand, instead of check every characters you should just check until 2 of them are not equal or 1 of them is blank \n\nThe result is based on that position alone not the whole word\n\n`apap` and `app` -> first 2 chars are the same on both words so we skip\n3rd char is `a` < `p` because `a` comes before `b` in `order` string -> **we stop here** and conclude that word1 < word2 -> return `true`\n"
                    },
                    {
                        "username": "sumad200",
                        "content": "Its similar to how you look for a word in a dictionary (normal alphabetical order for the test cases mentioned above), \"apa..\" comes before \"apb..\",\"apc..\"........\"apo\" and so on till \"app\""
                    },
                    {
                        "username": "kaps146singh",
                        "content": "can some one help me with the problem in my code??\\nclass Solution {\\npublic:\\n    bool check(string one , string two,map<char,int>&seq){\\n        bool ans = true;\\n        int ind = 0;\\n        while(true){\\n            // auto k1 = one[ind];\\n            // auto k2 = two[ind];\\n            if(seq.at(one[ind]) > seq.at(two[ind])){\\n                ans = false;\\n                break;\\n            }\\n            if(ind<one.size() && ind>= two.size()) return false;\\n            else if(ind == one.size() && ind < two.size()) return true;\\n            ind++;\\n        }\\n        return ans;\\n    }\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,int>seq;\\n        int ind = 0;\\n        for(auto it : order)seq[it] = ind++;\\n        int n=words.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                string one = words[i];\\n                string two = words[j];\\n                if(check(one , two,seq) == false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\nthe error that i get is :\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  map::at"
                    },
                    {
                        "username": "tbekpro",
                        "content": "Try thinking of making an alphabet array and using it in some way.\\n\\nor check this 100% Faster Solution\\n[Java 100% Faster Alphabet Array](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130047/java-100-faster-solution/)\\n\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The brute force solution with O(n^3) time complexity gives 100% beats lol"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Check the constraint bro it\\'s quite small so the time is definitely not much"
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "can anyone plz tell me why this code failed\n\nTestcase\n words = [\"kuvp\",\"q\"] , order =\"ngxlkthsjuoqcpavbfdermiywz\"\n\nclass Solution {\nprivate:\n  unordered_map<char,int> m;\npublic:\n\n    bool acc_to_dic(string first , string second){\n        int mini=min(first.length(),second.length());\n        for(int i=0;i<mini;i++){\n            if(m[first[i]] != m[second[i]]) return m[first[i]] < m[second[i]] ;\n        }\n\n        return first.length() <= second.length() ;\n    }\n    bool isAlienSorted(vector<string>& words, string order) {\n\n        unordered_map<char,int> m;\n\n        int seq=0;\n        \n        for(auto i : order){\n            m[i]=seq++;\n        }\n\n        for(int i=0;i<words.size()-1;i++){\n            if(acc_to_dic(words[i],words[i+1])) continue;\n            else return false;\n        }\n        return true;\n    }\n};  "
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "[@ohYouCan](/ohYouCan) Thank\\'s it get accepted .Really want to appreciate you for helping as i was not able to find where i got my logic wrong "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "You have re-declared you map , and you acc_to_order method is using global one. which is basically empty."
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "[@KingCoderHK](/KingCoderHK)  it is like if they match according to dictionary then continue else return false if all words matched then at last we return true"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "if acc_to_dic(words[i],words[i+1]) is True, do you want to continue or return True? "
                    },
                    {
                        "username": "chezzyfries",
                        "content": "nice question. I underestimated it at first and came up with a wrong solution"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "To anyone getting error in this testcase [\"kuvp\",\"q\"] think a simple dictionary where if first character is small the obviously that word will come before the other word."
                    }
                ]
            },
            {
                "id": 1784398,
                "content": [
                    {
                        "username": "ayushluthra62",
                        "content": "Level : East to Medium But It is Easy as you can easily understand the logic part if you read it\\'s description carefully .<br>\\nHint : use Map <br>\\nMy solution Link : -> https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130389/c-easy-and-simple-solution-using-hashmap/"
                    },
                    {
                        "username": "Vinit171",
                        "content": "words =\n[\"mtkwpj\",\"wlaees\"]\norder =\n\"evhadxsqukcogztlnfjpiymbwr\"\n\nCan somebody explain, why it is giving \"True\" as an output."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Because m is occurring before w so returning true Check my solution  and don\\'t forgot to up vote it .\\n\\n\\nhttps://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130389/c-easy-and-simple-solution-using-hashmap/ "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just looking in the comments to see if someone wrote it should be medium or not :)"
                    },
                    {
                        "username": "_aakash027",
                        "content": "How come this is false\\nwords = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nand this is true\\nwords=[\"apap\",\"app\"], order=\"\"abcdefghijklmnopqrstuvwxyz\"\\n\\nthey both should be false "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@_aakash027](/_aakash027) the problem's description kinda tricky to understand, instead of check every characters you should just check until 2 of them are not equal or 1 of them is blank \n\nThe result is based on that position alone not the whole word\n\n`apap` and `app` -> first 2 chars are the same on both words so we skip\n3rd char is `a` < `p` because `a` comes before `b` in `order` string -> **we stop here** and conclude that word1 < word2 -> return `true`\n"
                    },
                    {
                        "username": "sumad200",
                        "content": "Its similar to how you look for a word in a dictionary (normal alphabetical order for the test cases mentioned above), \"apa..\" comes before \"apb..\",\"apc..\"........\"apo\" and so on till \"app\""
                    },
                    {
                        "username": "kaps146singh",
                        "content": "can some one help me with the problem in my code??\\nclass Solution {\\npublic:\\n    bool check(string one , string two,map<char,int>&seq){\\n        bool ans = true;\\n        int ind = 0;\\n        while(true){\\n            // auto k1 = one[ind];\\n            // auto k2 = two[ind];\\n            if(seq.at(one[ind]) > seq.at(two[ind])){\\n                ans = false;\\n                break;\\n            }\\n            if(ind<one.size() && ind>= two.size()) return false;\\n            else if(ind == one.size() && ind < two.size()) return true;\\n            ind++;\\n        }\\n        return ans;\\n    }\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,int>seq;\\n        int ind = 0;\\n        for(auto it : order)seq[it] = ind++;\\n        int n=words.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                string one = words[i];\\n                string two = words[j];\\n                if(check(one , two,seq) == false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\nthe error that i get is :\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  map::at"
                    },
                    {
                        "username": "tbekpro",
                        "content": "Try thinking of making an alphabet array and using it in some way.\\n\\nor check this 100% Faster Solution\\n[Java 100% Faster Alphabet Array](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130047/java-100-faster-solution/)\\n\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The brute force solution with O(n^3) time complexity gives 100% beats lol"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Check the constraint bro it\\'s quite small so the time is definitely not much"
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "can anyone plz tell me why this code failed\n\nTestcase\n words = [\"kuvp\",\"q\"] , order =\"ngxlkthsjuoqcpavbfdermiywz\"\n\nclass Solution {\nprivate:\n  unordered_map<char,int> m;\npublic:\n\n    bool acc_to_dic(string first , string second){\n        int mini=min(first.length(),second.length());\n        for(int i=0;i<mini;i++){\n            if(m[first[i]] != m[second[i]]) return m[first[i]] < m[second[i]] ;\n        }\n\n        return first.length() <= second.length() ;\n    }\n    bool isAlienSorted(vector<string>& words, string order) {\n\n        unordered_map<char,int> m;\n\n        int seq=0;\n        \n        for(auto i : order){\n            m[i]=seq++;\n        }\n\n        for(int i=0;i<words.size()-1;i++){\n            if(acc_to_dic(words[i],words[i+1])) continue;\n            else return false;\n        }\n        return true;\n    }\n};  "
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "[@ohYouCan](/ohYouCan) Thank\\'s it get accepted .Really want to appreciate you for helping as i was not able to find where i got my logic wrong "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "You have re-declared you map , and you acc_to_order method is using global one. which is basically empty."
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "[@KingCoderHK](/KingCoderHK)  it is like if they match according to dictionary then continue else return false if all words matched then at last we return true"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "if acc_to_dic(words[i],words[i+1]) is True, do you want to continue or return True? "
                    },
                    {
                        "username": "chezzyfries",
                        "content": "nice question. I underestimated it at first and came up with a wrong solution"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "To anyone getting error in this testcase [\"kuvp\",\"q\"] think a simple dictionary where if first character is small the obviously that word will come before the other word."
                    }
                ]
            },
            {
                "id": 1784384,
                "content": [
                    {
                        "username": "ayushluthra62",
                        "content": "Level : East to Medium But It is Easy as you can easily understand the logic part if you read it\\'s description carefully .<br>\\nHint : use Map <br>\\nMy solution Link : -> https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130389/c-easy-and-simple-solution-using-hashmap/"
                    },
                    {
                        "username": "Vinit171",
                        "content": "words =\n[\"mtkwpj\",\"wlaees\"]\norder =\n\"evhadxsqukcogztlnfjpiymbwr\"\n\nCan somebody explain, why it is giving \"True\" as an output."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Because m is occurring before w so returning true Check my solution  and don\\'t forgot to up vote it .\\n\\n\\nhttps://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130389/c-easy-and-simple-solution-using-hashmap/ "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just looking in the comments to see if someone wrote it should be medium or not :)"
                    },
                    {
                        "username": "_aakash027",
                        "content": "How come this is false\\nwords = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nand this is true\\nwords=[\"apap\",\"app\"], order=\"\"abcdefghijklmnopqrstuvwxyz\"\\n\\nthey both should be false "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@_aakash027](/_aakash027) the problem's description kinda tricky to understand, instead of check every characters you should just check until 2 of them are not equal or 1 of them is blank \n\nThe result is based on that position alone not the whole word\n\n`apap` and `app` -> first 2 chars are the same on both words so we skip\n3rd char is `a` < `p` because `a` comes before `b` in `order` string -> **we stop here** and conclude that word1 < word2 -> return `true`\n"
                    },
                    {
                        "username": "sumad200",
                        "content": "Its similar to how you look for a word in a dictionary (normal alphabetical order for the test cases mentioned above), \"apa..\" comes before \"apb..\",\"apc..\"........\"apo\" and so on till \"app\""
                    },
                    {
                        "username": "kaps146singh",
                        "content": "can some one help me with the problem in my code??\\nclass Solution {\\npublic:\\n    bool check(string one , string two,map<char,int>&seq){\\n        bool ans = true;\\n        int ind = 0;\\n        while(true){\\n            // auto k1 = one[ind];\\n            // auto k2 = two[ind];\\n            if(seq.at(one[ind]) > seq.at(two[ind])){\\n                ans = false;\\n                break;\\n            }\\n            if(ind<one.size() && ind>= two.size()) return false;\\n            else if(ind == one.size() && ind < two.size()) return true;\\n            ind++;\\n        }\\n        return ans;\\n    }\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,int>seq;\\n        int ind = 0;\\n        for(auto it : order)seq[it] = ind++;\\n        int n=words.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                string one = words[i];\\n                string two = words[j];\\n                if(check(one , two,seq) == false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\nthe error that i get is :\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  map::at"
                    },
                    {
                        "username": "tbekpro",
                        "content": "Try thinking of making an alphabet array and using it in some way.\\n\\nor check this 100% Faster Solution\\n[Java 100% Faster Alphabet Array](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130047/java-100-faster-solution/)\\n\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The brute force solution with O(n^3) time complexity gives 100% beats lol"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Check the constraint bro it\\'s quite small so the time is definitely not much"
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "can anyone plz tell me why this code failed\n\nTestcase\n words = [\"kuvp\",\"q\"] , order =\"ngxlkthsjuoqcpavbfdermiywz\"\n\nclass Solution {\nprivate:\n  unordered_map<char,int> m;\npublic:\n\n    bool acc_to_dic(string first , string second){\n        int mini=min(first.length(),second.length());\n        for(int i=0;i<mini;i++){\n            if(m[first[i]] != m[second[i]]) return m[first[i]] < m[second[i]] ;\n        }\n\n        return first.length() <= second.length() ;\n    }\n    bool isAlienSorted(vector<string>& words, string order) {\n\n        unordered_map<char,int> m;\n\n        int seq=0;\n        \n        for(auto i : order){\n            m[i]=seq++;\n        }\n\n        for(int i=0;i<words.size()-1;i++){\n            if(acc_to_dic(words[i],words[i+1])) continue;\n            else return false;\n        }\n        return true;\n    }\n};  "
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "[@ohYouCan](/ohYouCan) Thank\\'s it get accepted .Really want to appreciate you for helping as i was not able to find where i got my logic wrong "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "You have re-declared you map , and you acc_to_order method is using global one. which is basically empty."
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "[@KingCoderHK](/KingCoderHK)  it is like if they match according to dictionary then continue else return false if all words matched then at last we return true"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "if acc_to_dic(words[i],words[i+1]) is True, do you want to continue or return True? "
                    },
                    {
                        "username": "chezzyfries",
                        "content": "nice question. I underestimated it at first and came up with a wrong solution"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "To anyone getting error in this testcase [\"kuvp\",\"q\"] think a simple dictionary where if first character is small the obviously that word will come before the other word."
                    }
                ]
            },
            {
                "id": 1784369,
                "content": [
                    {
                        "username": "ayushluthra62",
                        "content": "Level : East to Medium But It is Easy as you can easily understand the logic part if you read it\\'s description carefully .<br>\\nHint : use Map <br>\\nMy solution Link : -> https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130389/c-easy-and-simple-solution-using-hashmap/"
                    },
                    {
                        "username": "Vinit171",
                        "content": "words =\n[\"mtkwpj\",\"wlaees\"]\norder =\n\"evhadxsqukcogztlnfjpiymbwr\"\n\nCan somebody explain, why it is giving \"True\" as an output."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Because m is occurring before w so returning true Check my solution  and don\\'t forgot to up vote it .\\n\\n\\nhttps://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130389/c-easy-and-simple-solution-using-hashmap/ "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just looking in the comments to see if someone wrote it should be medium or not :)"
                    },
                    {
                        "username": "_aakash027",
                        "content": "How come this is false\\nwords = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nand this is true\\nwords=[\"apap\",\"app\"], order=\"\"abcdefghijklmnopqrstuvwxyz\"\\n\\nthey both should be false "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@_aakash027](/_aakash027) the problem's description kinda tricky to understand, instead of check every characters you should just check until 2 of them are not equal or 1 of them is blank \n\nThe result is based on that position alone not the whole word\n\n`apap` and `app` -> first 2 chars are the same on both words so we skip\n3rd char is `a` < `p` because `a` comes before `b` in `order` string -> **we stop here** and conclude that word1 < word2 -> return `true`\n"
                    },
                    {
                        "username": "sumad200",
                        "content": "Its similar to how you look for a word in a dictionary (normal alphabetical order for the test cases mentioned above), \"apa..\" comes before \"apb..\",\"apc..\"........\"apo\" and so on till \"app\""
                    },
                    {
                        "username": "kaps146singh",
                        "content": "can some one help me with the problem in my code??\\nclass Solution {\\npublic:\\n    bool check(string one , string two,map<char,int>&seq){\\n        bool ans = true;\\n        int ind = 0;\\n        while(true){\\n            // auto k1 = one[ind];\\n            // auto k2 = two[ind];\\n            if(seq.at(one[ind]) > seq.at(two[ind])){\\n                ans = false;\\n                break;\\n            }\\n            if(ind<one.size() && ind>= two.size()) return false;\\n            else if(ind == one.size() && ind < two.size()) return true;\\n            ind++;\\n        }\\n        return ans;\\n    }\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,int>seq;\\n        int ind = 0;\\n        for(auto it : order)seq[it] = ind++;\\n        int n=words.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                string one = words[i];\\n                string two = words[j];\\n                if(check(one , two,seq) == false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\nthe error that i get is :\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  map::at"
                    },
                    {
                        "username": "tbekpro",
                        "content": "Try thinking of making an alphabet array and using it in some way.\\n\\nor check this 100% Faster Solution\\n[Java 100% Faster Alphabet Array](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130047/java-100-faster-solution/)\\n\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The brute force solution with O(n^3) time complexity gives 100% beats lol"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Check the constraint bro it\\'s quite small so the time is definitely not much"
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "can anyone plz tell me why this code failed\n\nTestcase\n words = [\"kuvp\",\"q\"] , order =\"ngxlkthsjuoqcpavbfdermiywz\"\n\nclass Solution {\nprivate:\n  unordered_map<char,int> m;\npublic:\n\n    bool acc_to_dic(string first , string second){\n        int mini=min(first.length(),second.length());\n        for(int i=0;i<mini;i++){\n            if(m[first[i]] != m[second[i]]) return m[first[i]] < m[second[i]] ;\n        }\n\n        return first.length() <= second.length() ;\n    }\n    bool isAlienSorted(vector<string>& words, string order) {\n\n        unordered_map<char,int> m;\n\n        int seq=0;\n        \n        for(auto i : order){\n            m[i]=seq++;\n        }\n\n        for(int i=0;i<words.size()-1;i++){\n            if(acc_to_dic(words[i],words[i+1])) continue;\n            else return false;\n        }\n        return true;\n    }\n};  "
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "[@ohYouCan](/ohYouCan) Thank\\'s it get accepted .Really want to appreciate you for helping as i was not able to find where i got my logic wrong "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "You have re-declared you map , and you acc_to_order method is using global one. which is basically empty."
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "[@KingCoderHK](/KingCoderHK)  it is like if they match according to dictionary then continue else return false if all words matched then at last we return true"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "if acc_to_dic(words[i],words[i+1]) is True, do you want to continue or return True? "
                    },
                    {
                        "username": "chezzyfries",
                        "content": "nice question. I underestimated it at first and came up with a wrong solution"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "To anyone getting error in this testcase [\"kuvp\",\"q\"] think a simple dictionary where if first character is small the obviously that word will come before the other word."
                    }
                ]
            },
            {
                "id": 1784334,
                "content": [
                    {
                        "username": "ayushluthra62",
                        "content": "Level : East to Medium But It is Easy as you can easily understand the logic part if you read it\\'s description carefully .<br>\\nHint : use Map <br>\\nMy solution Link : -> https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130389/c-easy-and-simple-solution-using-hashmap/"
                    },
                    {
                        "username": "Vinit171",
                        "content": "words =\n[\"mtkwpj\",\"wlaees\"]\norder =\n\"evhadxsqukcogztlnfjpiymbwr\"\n\nCan somebody explain, why it is giving \"True\" as an output."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Because m is occurring before w so returning true Check my solution  and don\\'t forgot to up vote it .\\n\\n\\nhttps://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130389/c-easy-and-simple-solution-using-hashmap/ "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just looking in the comments to see if someone wrote it should be medium or not :)"
                    },
                    {
                        "username": "_aakash027",
                        "content": "How come this is false\\nwords = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nand this is true\\nwords=[\"apap\",\"app\"], order=\"\"abcdefghijklmnopqrstuvwxyz\"\\n\\nthey both should be false "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@_aakash027](/_aakash027) the problem's description kinda tricky to understand, instead of check every characters you should just check until 2 of them are not equal or 1 of them is blank \n\nThe result is based on that position alone not the whole word\n\n`apap` and `app` -> first 2 chars are the same on both words so we skip\n3rd char is `a` < `p` because `a` comes before `b` in `order` string -> **we stop here** and conclude that word1 < word2 -> return `true`\n"
                    },
                    {
                        "username": "sumad200",
                        "content": "Its similar to how you look for a word in a dictionary (normal alphabetical order for the test cases mentioned above), \"apa..\" comes before \"apb..\",\"apc..\"........\"apo\" and so on till \"app\""
                    },
                    {
                        "username": "kaps146singh",
                        "content": "can some one help me with the problem in my code??\\nclass Solution {\\npublic:\\n    bool check(string one , string two,map<char,int>&seq){\\n        bool ans = true;\\n        int ind = 0;\\n        while(true){\\n            // auto k1 = one[ind];\\n            // auto k2 = two[ind];\\n            if(seq.at(one[ind]) > seq.at(two[ind])){\\n                ans = false;\\n                break;\\n            }\\n            if(ind<one.size() && ind>= two.size()) return false;\\n            else if(ind == one.size() && ind < two.size()) return true;\\n            ind++;\\n        }\\n        return ans;\\n    }\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,int>seq;\\n        int ind = 0;\\n        for(auto it : order)seq[it] = ind++;\\n        int n=words.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                string one = words[i];\\n                string two = words[j];\\n                if(check(one , two,seq) == false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\nthe error that i get is :\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  map::at"
                    },
                    {
                        "username": "tbekpro",
                        "content": "Try thinking of making an alphabet array and using it in some way.\\n\\nor check this 100% Faster Solution\\n[Java 100% Faster Alphabet Array](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130047/java-100-faster-solution/)\\n\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The brute force solution with O(n^3) time complexity gives 100% beats lol"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Check the constraint bro it\\'s quite small so the time is definitely not much"
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "can anyone plz tell me why this code failed\n\nTestcase\n words = [\"kuvp\",\"q\"] , order =\"ngxlkthsjuoqcpavbfdermiywz\"\n\nclass Solution {\nprivate:\n  unordered_map<char,int> m;\npublic:\n\n    bool acc_to_dic(string first , string second){\n        int mini=min(first.length(),second.length());\n        for(int i=0;i<mini;i++){\n            if(m[first[i]] != m[second[i]]) return m[first[i]] < m[second[i]] ;\n        }\n\n        return first.length() <= second.length() ;\n    }\n    bool isAlienSorted(vector<string>& words, string order) {\n\n        unordered_map<char,int> m;\n\n        int seq=0;\n        \n        for(auto i : order){\n            m[i]=seq++;\n        }\n\n        for(int i=0;i<words.size()-1;i++){\n            if(acc_to_dic(words[i],words[i+1])) continue;\n            else return false;\n        }\n        return true;\n    }\n};  "
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "[@ohYouCan](/ohYouCan) Thank\\'s it get accepted .Really want to appreciate you for helping as i was not able to find where i got my logic wrong "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "You have re-declared you map , and you acc_to_order method is using global one. which is basically empty."
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "[@KingCoderHK](/KingCoderHK)  it is like if they match according to dictionary then continue else return false if all words matched then at last we return true"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "if acc_to_dic(words[i],words[i+1]) is True, do you want to continue or return True? "
                    },
                    {
                        "username": "chezzyfries",
                        "content": "nice question. I underestimated it at first and came up with a wrong solution"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "To anyone getting error in this testcase [\"kuvp\",\"q\"] think a simple dictionary where if first character is small the obviously that word will come before the other word."
                    }
                ]
            },
            {
                "id": 1784313,
                "content": [
                    {
                        "username": "ayushluthra62",
                        "content": "Level : East to Medium But It is Easy as you can easily understand the logic part if you read it\\'s description carefully .<br>\\nHint : use Map <br>\\nMy solution Link : -> https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130389/c-easy-and-simple-solution-using-hashmap/"
                    },
                    {
                        "username": "Vinit171",
                        "content": "words =\n[\"mtkwpj\",\"wlaees\"]\norder =\n\"evhadxsqukcogztlnfjpiymbwr\"\n\nCan somebody explain, why it is giving \"True\" as an output."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Because m is occurring before w so returning true Check my solution  and don\\'t forgot to up vote it .\\n\\n\\nhttps://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130389/c-easy-and-simple-solution-using-hashmap/ "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just looking in the comments to see if someone wrote it should be medium or not :)"
                    },
                    {
                        "username": "_aakash027",
                        "content": "How come this is false\\nwords = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nand this is true\\nwords=[\"apap\",\"app\"], order=\"\"abcdefghijklmnopqrstuvwxyz\"\\n\\nthey both should be false "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@_aakash027](/_aakash027) the problem's description kinda tricky to understand, instead of check every characters you should just check until 2 of them are not equal or 1 of them is blank \n\nThe result is based on that position alone not the whole word\n\n`apap` and `app` -> first 2 chars are the same on both words so we skip\n3rd char is `a` < `p` because `a` comes before `b` in `order` string -> **we stop here** and conclude that word1 < word2 -> return `true`\n"
                    },
                    {
                        "username": "sumad200",
                        "content": "Its similar to how you look for a word in a dictionary (normal alphabetical order for the test cases mentioned above), \"apa..\" comes before \"apb..\",\"apc..\"........\"apo\" and so on till \"app\""
                    },
                    {
                        "username": "kaps146singh",
                        "content": "can some one help me with the problem in my code??\\nclass Solution {\\npublic:\\n    bool check(string one , string two,map<char,int>&seq){\\n        bool ans = true;\\n        int ind = 0;\\n        while(true){\\n            // auto k1 = one[ind];\\n            // auto k2 = two[ind];\\n            if(seq.at(one[ind]) > seq.at(two[ind])){\\n                ans = false;\\n                break;\\n            }\\n            if(ind<one.size() && ind>= two.size()) return false;\\n            else if(ind == one.size() && ind < two.size()) return true;\\n            ind++;\\n        }\\n        return ans;\\n    }\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,int>seq;\\n        int ind = 0;\\n        for(auto it : order)seq[it] = ind++;\\n        int n=words.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                string one = words[i];\\n                string two = words[j];\\n                if(check(one , two,seq) == false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\nthe error that i get is :\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  map::at"
                    },
                    {
                        "username": "tbekpro",
                        "content": "Try thinking of making an alphabet array and using it in some way.\\n\\nor check this 100% Faster Solution\\n[Java 100% Faster Alphabet Array](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130047/java-100-faster-solution/)\\n\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The brute force solution with O(n^3) time complexity gives 100% beats lol"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Check the constraint bro it\\'s quite small so the time is definitely not much"
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "can anyone plz tell me why this code failed\n\nTestcase\n words = [\"kuvp\",\"q\"] , order =\"ngxlkthsjuoqcpavbfdermiywz\"\n\nclass Solution {\nprivate:\n  unordered_map<char,int> m;\npublic:\n\n    bool acc_to_dic(string first , string second){\n        int mini=min(first.length(),second.length());\n        for(int i=0;i<mini;i++){\n            if(m[first[i]] != m[second[i]]) return m[first[i]] < m[second[i]] ;\n        }\n\n        return first.length() <= second.length() ;\n    }\n    bool isAlienSorted(vector<string>& words, string order) {\n\n        unordered_map<char,int> m;\n\n        int seq=0;\n        \n        for(auto i : order){\n            m[i]=seq++;\n        }\n\n        for(int i=0;i<words.size()-1;i++){\n            if(acc_to_dic(words[i],words[i+1])) continue;\n            else return false;\n        }\n        return true;\n    }\n};  "
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "[@ohYouCan](/ohYouCan) Thank\\'s it get accepted .Really want to appreciate you for helping as i was not able to find where i got my logic wrong "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "You have re-declared you map , and you acc_to_order method is using global one. which is basically empty."
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "[@KingCoderHK](/KingCoderHK)  it is like if they match according to dictionary then continue else return false if all words matched then at last we return true"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "if acc_to_dic(words[i],words[i+1]) is True, do you want to continue or return True? "
                    },
                    {
                        "username": "chezzyfries",
                        "content": "nice question. I underestimated it at first and came up with a wrong solution"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "To anyone getting error in this testcase [\"kuvp\",\"q\"] think a simple dictionary where if first character is small the obviously that word will come before the other word."
                    }
                ]
            },
            {
                "id": 1784297,
                "content": [
                    {
                        "username": "ayushluthra62",
                        "content": "Level : East to Medium But It is Easy as you can easily understand the logic part if you read it\\'s description carefully .<br>\\nHint : use Map <br>\\nMy solution Link : -> https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130389/c-easy-and-simple-solution-using-hashmap/"
                    },
                    {
                        "username": "Vinit171",
                        "content": "words =\n[\"mtkwpj\",\"wlaees\"]\norder =\n\"evhadxsqukcogztlnfjpiymbwr\"\n\nCan somebody explain, why it is giving \"True\" as an output."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Because m is occurring before w so returning true Check my solution  and don\\'t forgot to up vote it .\\n\\n\\nhttps://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130389/c-easy-and-simple-solution-using-hashmap/ "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just looking in the comments to see if someone wrote it should be medium or not :)"
                    },
                    {
                        "username": "_aakash027",
                        "content": "How come this is false\\nwords = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nand this is true\\nwords=[\"apap\",\"app\"], order=\"\"abcdefghijklmnopqrstuvwxyz\"\\n\\nthey both should be false "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@_aakash027](/_aakash027) the problem's description kinda tricky to understand, instead of check every characters you should just check until 2 of them are not equal or 1 of them is blank \n\nThe result is based on that position alone not the whole word\n\n`apap` and `app` -> first 2 chars are the same on both words so we skip\n3rd char is `a` < `p` because `a` comes before `b` in `order` string -> **we stop here** and conclude that word1 < word2 -> return `true`\n"
                    },
                    {
                        "username": "sumad200",
                        "content": "Its similar to how you look for a word in a dictionary (normal alphabetical order for the test cases mentioned above), \"apa..\" comes before \"apb..\",\"apc..\"........\"apo\" and so on till \"app\""
                    },
                    {
                        "username": "kaps146singh",
                        "content": "can some one help me with the problem in my code??\\nclass Solution {\\npublic:\\n    bool check(string one , string two,map<char,int>&seq){\\n        bool ans = true;\\n        int ind = 0;\\n        while(true){\\n            // auto k1 = one[ind];\\n            // auto k2 = two[ind];\\n            if(seq.at(one[ind]) > seq.at(two[ind])){\\n                ans = false;\\n                break;\\n            }\\n            if(ind<one.size() && ind>= two.size()) return false;\\n            else if(ind == one.size() && ind < two.size()) return true;\\n            ind++;\\n        }\\n        return ans;\\n    }\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,int>seq;\\n        int ind = 0;\\n        for(auto it : order)seq[it] = ind++;\\n        int n=words.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                string one = words[i];\\n                string two = words[j];\\n                if(check(one , two,seq) == false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\nthe error that i get is :\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  map::at"
                    },
                    {
                        "username": "tbekpro",
                        "content": "Try thinking of making an alphabet array and using it in some way.\\n\\nor check this 100% Faster Solution\\n[Java 100% Faster Alphabet Array](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130047/java-100-faster-solution/)\\n\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The brute force solution with O(n^3) time complexity gives 100% beats lol"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Check the constraint bro it\\'s quite small so the time is definitely not much"
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "can anyone plz tell me why this code failed\n\nTestcase\n words = [\"kuvp\",\"q\"] , order =\"ngxlkthsjuoqcpavbfdermiywz\"\n\nclass Solution {\nprivate:\n  unordered_map<char,int> m;\npublic:\n\n    bool acc_to_dic(string first , string second){\n        int mini=min(first.length(),second.length());\n        for(int i=0;i<mini;i++){\n            if(m[first[i]] != m[second[i]]) return m[first[i]] < m[second[i]] ;\n        }\n\n        return first.length() <= second.length() ;\n    }\n    bool isAlienSorted(vector<string>& words, string order) {\n\n        unordered_map<char,int> m;\n\n        int seq=0;\n        \n        for(auto i : order){\n            m[i]=seq++;\n        }\n\n        for(int i=0;i<words.size()-1;i++){\n            if(acc_to_dic(words[i],words[i+1])) continue;\n            else return false;\n        }\n        return true;\n    }\n};  "
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "[@ohYouCan](/ohYouCan) Thank\\'s it get accepted .Really want to appreciate you for helping as i was not able to find where i got my logic wrong "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "You have re-declared you map , and you acc_to_order method is using global one. which is basically empty."
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "[@KingCoderHK](/KingCoderHK)  it is like if they match according to dictionary then continue else return false if all words matched then at last we return true"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "if acc_to_dic(words[i],words[i+1]) is True, do you want to continue or return True? "
                    },
                    {
                        "username": "chezzyfries",
                        "content": "nice question. I underestimated it at first and came up with a wrong solution"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "To anyone getting error in this testcase [\"kuvp\",\"q\"] think a simple dictionary where if first character is small the obviously that word will come before the other word."
                    }
                ]
            },
            {
                "id": 1784258,
                "content": [
                    {
                        "username": "ayushluthra62",
                        "content": "Level : East to Medium But It is Easy as you can easily understand the logic part if you read it\\'s description carefully .<br>\\nHint : use Map <br>\\nMy solution Link : -> https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130389/c-easy-and-simple-solution-using-hashmap/"
                    },
                    {
                        "username": "Vinit171",
                        "content": "words =\n[\"mtkwpj\",\"wlaees\"]\norder =\n\"evhadxsqukcogztlnfjpiymbwr\"\n\nCan somebody explain, why it is giving \"True\" as an output."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Because m is occurring before w so returning true Check my solution  and don\\'t forgot to up vote it .\\n\\n\\nhttps://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130389/c-easy-and-simple-solution-using-hashmap/ "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just looking in the comments to see if someone wrote it should be medium or not :)"
                    },
                    {
                        "username": "_aakash027",
                        "content": "How come this is false\\nwords = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nand this is true\\nwords=[\"apap\",\"app\"], order=\"\"abcdefghijklmnopqrstuvwxyz\"\\n\\nthey both should be false "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@_aakash027](/_aakash027) the problem's description kinda tricky to understand, instead of check every characters you should just check until 2 of them are not equal or 1 of them is blank \n\nThe result is based on that position alone not the whole word\n\n`apap` and `app` -> first 2 chars are the same on both words so we skip\n3rd char is `a` < `p` because `a` comes before `b` in `order` string -> **we stop here** and conclude that word1 < word2 -> return `true`\n"
                    },
                    {
                        "username": "sumad200",
                        "content": "Its similar to how you look for a word in a dictionary (normal alphabetical order for the test cases mentioned above), \"apa..\" comes before \"apb..\",\"apc..\"........\"apo\" and so on till \"app\""
                    },
                    {
                        "username": "kaps146singh",
                        "content": "can some one help me with the problem in my code??\\nclass Solution {\\npublic:\\n    bool check(string one , string two,map<char,int>&seq){\\n        bool ans = true;\\n        int ind = 0;\\n        while(true){\\n            // auto k1 = one[ind];\\n            // auto k2 = two[ind];\\n            if(seq.at(one[ind]) > seq.at(two[ind])){\\n                ans = false;\\n                break;\\n            }\\n            if(ind<one.size() && ind>= two.size()) return false;\\n            else if(ind == one.size() && ind < two.size()) return true;\\n            ind++;\\n        }\\n        return ans;\\n    }\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,int>seq;\\n        int ind = 0;\\n        for(auto it : order)seq[it] = ind++;\\n        int n=words.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                string one = words[i];\\n                string two = words[j];\\n                if(check(one , two,seq) == false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\nthe error that i get is :\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  map::at"
                    },
                    {
                        "username": "tbekpro",
                        "content": "Try thinking of making an alphabet array and using it in some way.\\n\\nor check this 100% Faster Solution\\n[Java 100% Faster Alphabet Array](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130047/java-100-faster-solution/)\\n\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The brute force solution with O(n^3) time complexity gives 100% beats lol"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Check the constraint bro it\\'s quite small so the time is definitely not much"
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "can anyone plz tell me why this code failed\n\nTestcase\n words = [\"kuvp\",\"q\"] , order =\"ngxlkthsjuoqcpavbfdermiywz\"\n\nclass Solution {\nprivate:\n  unordered_map<char,int> m;\npublic:\n\n    bool acc_to_dic(string first , string second){\n        int mini=min(first.length(),second.length());\n        for(int i=0;i<mini;i++){\n            if(m[first[i]] != m[second[i]]) return m[first[i]] < m[second[i]] ;\n        }\n\n        return first.length() <= second.length() ;\n    }\n    bool isAlienSorted(vector<string>& words, string order) {\n\n        unordered_map<char,int> m;\n\n        int seq=0;\n        \n        for(auto i : order){\n            m[i]=seq++;\n        }\n\n        for(int i=0;i<words.size()-1;i++){\n            if(acc_to_dic(words[i],words[i+1])) continue;\n            else return false;\n        }\n        return true;\n    }\n};  "
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "[@ohYouCan](/ohYouCan) Thank\\'s it get accepted .Really want to appreciate you for helping as i was not able to find where i got my logic wrong "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "You have re-declared you map , and you acc_to_order method is using global one. which is basically empty."
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "[@KingCoderHK](/KingCoderHK)  it is like if they match according to dictionary then continue else return false if all words matched then at last we return true"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "if acc_to_dic(words[i],words[i+1]) is True, do you want to continue or return True? "
                    },
                    {
                        "username": "chezzyfries",
                        "content": "nice question. I underestimated it at first and came up with a wrong solution"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "To anyone getting error in this testcase [\"kuvp\",\"q\"] think a simple dictionary where if first character is small the obviously that word will come before the other word."
                    }
                ]
            },
            {
                "id": 1784239,
                "content": [
                    {
                        "username": "ayushluthra62",
                        "content": "Level : East to Medium But It is Easy as you can easily understand the logic part if you read it\\'s description carefully .<br>\\nHint : use Map <br>\\nMy solution Link : -> https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130389/c-easy-and-simple-solution-using-hashmap/"
                    },
                    {
                        "username": "Vinit171",
                        "content": "words =\n[\"mtkwpj\",\"wlaees\"]\norder =\n\"evhadxsqukcogztlnfjpiymbwr\"\n\nCan somebody explain, why it is giving \"True\" as an output."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Because m is occurring before w so returning true Check my solution  and don\\'t forgot to up vote it .\\n\\n\\nhttps://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130389/c-easy-and-simple-solution-using-hashmap/ "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just looking in the comments to see if someone wrote it should be medium or not :)"
                    },
                    {
                        "username": "_aakash027",
                        "content": "How come this is false\\nwords = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nand this is true\\nwords=[\"apap\",\"app\"], order=\"\"abcdefghijklmnopqrstuvwxyz\"\\n\\nthey both should be false "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@_aakash027](/_aakash027) the problem's description kinda tricky to understand, instead of check every characters you should just check until 2 of them are not equal or 1 of them is blank \n\nThe result is based on that position alone not the whole word\n\n`apap` and `app` -> first 2 chars are the same on both words so we skip\n3rd char is `a` < `p` because `a` comes before `b` in `order` string -> **we stop here** and conclude that word1 < word2 -> return `true`\n"
                    },
                    {
                        "username": "sumad200",
                        "content": "Its similar to how you look for a word in a dictionary (normal alphabetical order for the test cases mentioned above), \"apa..\" comes before \"apb..\",\"apc..\"........\"apo\" and so on till \"app\""
                    },
                    {
                        "username": "kaps146singh",
                        "content": "can some one help me with the problem in my code??\\nclass Solution {\\npublic:\\n    bool check(string one , string two,map<char,int>&seq){\\n        bool ans = true;\\n        int ind = 0;\\n        while(true){\\n            // auto k1 = one[ind];\\n            // auto k2 = two[ind];\\n            if(seq.at(one[ind]) > seq.at(two[ind])){\\n                ans = false;\\n                break;\\n            }\\n            if(ind<one.size() && ind>= two.size()) return false;\\n            else if(ind == one.size() && ind < two.size()) return true;\\n            ind++;\\n        }\\n        return ans;\\n    }\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,int>seq;\\n        int ind = 0;\\n        for(auto it : order)seq[it] = ind++;\\n        int n=words.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                string one = words[i];\\n                string two = words[j];\\n                if(check(one , two,seq) == false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\nthe error that i get is :\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  map::at"
                    },
                    {
                        "username": "tbekpro",
                        "content": "Try thinking of making an alphabet array and using it in some way.\\n\\nor check this 100% Faster Solution\\n[Java 100% Faster Alphabet Array](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130047/java-100-faster-solution/)\\n\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The brute force solution with O(n^3) time complexity gives 100% beats lol"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Check the constraint bro it\\'s quite small so the time is definitely not much"
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "can anyone plz tell me why this code failed\n\nTestcase\n words = [\"kuvp\",\"q\"] , order =\"ngxlkthsjuoqcpavbfdermiywz\"\n\nclass Solution {\nprivate:\n  unordered_map<char,int> m;\npublic:\n\n    bool acc_to_dic(string first , string second){\n        int mini=min(first.length(),second.length());\n        for(int i=0;i<mini;i++){\n            if(m[first[i]] != m[second[i]]) return m[first[i]] < m[second[i]] ;\n        }\n\n        return first.length() <= second.length() ;\n    }\n    bool isAlienSorted(vector<string>& words, string order) {\n\n        unordered_map<char,int> m;\n\n        int seq=0;\n        \n        for(auto i : order){\n            m[i]=seq++;\n        }\n\n        for(int i=0;i<words.size()-1;i++){\n            if(acc_to_dic(words[i],words[i+1])) continue;\n            else return false;\n        }\n        return true;\n    }\n};  "
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "[@ohYouCan](/ohYouCan) Thank\\'s it get accepted .Really want to appreciate you for helping as i was not able to find where i got my logic wrong "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "You have re-declared you map , and you acc_to_order method is using global one. which is basically empty."
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "[@KingCoderHK](/KingCoderHK)  it is like if they match according to dictionary then continue else return false if all words matched then at last we return true"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "if acc_to_dic(words[i],words[i+1]) is True, do you want to continue or return True? "
                    },
                    {
                        "username": "chezzyfries",
                        "content": "nice question. I underestimated it at first and came up with a wrong solution"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "To anyone getting error in this testcase [\"kuvp\",\"q\"] think a simple dictionary where if first character is small the obviously that word will come before the other word."
                    }
                ]
            },
            {
                "id": 1784237,
                "content": [
                    {
                        "username": "ayushluthra62",
                        "content": "Level : East to Medium But It is Easy as you can easily understand the logic part if you read it\\'s description carefully .<br>\\nHint : use Map <br>\\nMy solution Link : -> https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130389/c-easy-and-simple-solution-using-hashmap/"
                    },
                    {
                        "username": "Vinit171",
                        "content": "words =\n[\"mtkwpj\",\"wlaees\"]\norder =\n\"evhadxsqukcogztlnfjpiymbwr\"\n\nCan somebody explain, why it is giving \"True\" as an output."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Because m is occurring before w so returning true Check my solution  and don\\'t forgot to up vote it .\\n\\n\\nhttps://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130389/c-easy-and-simple-solution-using-hashmap/ "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just looking in the comments to see if someone wrote it should be medium or not :)"
                    },
                    {
                        "username": "_aakash027",
                        "content": "How come this is false\\nwords = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\\nand this is true\\nwords=[\"apap\",\"app\"], order=\"\"abcdefghijklmnopqrstuvwxyz\"\\n\\nthey both should be false "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@_aakash027](/_aakash027) the problem's description kinda tricky to understand, instead of check every characters you should just check until 2 of them are not equal or 1 of them is blank \n\nThe result is based on that position alone not the whole word\n\n`apap` and `app` -> first 2 chars are the same on both words so we skip\n3rd char is `a` < `p` because `a` comes before `b` in `order` string -> **we stop here** and conclude that word1 < word2 -> return `true`\n"
                    },
                    {
                        "username": "sumad200",
                        "content": "Its similar to how you look for a word in a dictionary (normal alphabetical order for the test cases mentioned above), \"apa..\" comes before \"apb..\",\"apc..\"........\"apo\" and so on till \"app\""
                    },
                    {
                        "username": "kaps146singh",
                        "content": "can some one help me with the problem in my code??\\nclass Solution {\\npublic:\\n    bool check(string one , string two,map<char,int>&seq){\\n        bool ans = true;\\n        int ind = 0;\\n        while(true){\\n            // auto k1 = one[ind];\\n            // auto k2 = two[ind];\\n            if(seq.at(one[ind]) > seq.at(two[ind])){\\n                ans = false;\\n                break;\\n            }\\n            if(ind<one.size() && ind>= two.size()) return false;\\n            else if(ind == one.size() && ind < two.size()) return true;\\n            ind++;\\n        }\\n        return ans;\\n    }\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        map<char,int>seq;\\n        int ind = 0;\\n        for(auto it : order)seq[it] = ind++;\\n        int n=words.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                string one = words[i];\\n                string two = words[j];\\n                if(check(one , two,seq) == false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\nthe error that i get is :\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  map::at"
                    },
                    {
                        "username": "tbekpro",
                        "content": "Try thinking of making an alphabet array and using it in some way.\\n\\nor check this 100% Faster Solution\\n[Java 100% Faster Alphabet Array](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130047/java-100-faster-solution/)\\n\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The brute force solution with O(n^3) time complexity gives 100% beats lol"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Check the constraint bro it\\'s quite small so the time is definitely not much"
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "can anyone plz tell me why this code failed\n\nTestcase\n words = [\"kuvp\",\"q\"] , order =\"ngxlkthsjuoqcpavbfdermiywz\"\n\nclass Solution {\nprivate:\n  unordered_map<char,int> m;\npublic:\n\n    bool acc_to_dic(string first , string second){\n        int mini=min(first.length(),second.length());\n        for(int i=0;i<mini;i++){\n            if(m[first[i]] != m[second[i]]) return m[first[i]] < m[second[i]] ;\n        }\n\n        return first.length() <= second.length() ;\n    }\n    bool isAlienSorted(vector<string>& words, string order) {\n\n        unordered_map<char,int> m;\n\n        int seq=0;\n        \n        for(auto i : order){\n            m[i]=seq++;\n        }\n\n        for(int i=0;i<words.size()-1;i++){\n            if(acc_to_dic(words[i],words[i+1])) continue;\n            else return false;\n        }\n        return true;\n    }\n};  "
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "[@ohYouCan](/ohYouCan) Thank\\'s it get accepted .Really want to appreciate you for helping as i was not able to find where i got my logic wrong "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "You have re-declared you map , and you acc_to_order method is using global one. which is basically empty."
                    },
                    {
                        "username": "Sarthakberi",
                        "content": "[@KingCoderHK](/KingCoderHK)  it is like if they match according to dictionary then continue else return false if all words matched then at last we return true"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "if acc_to_dic(words[i],words[i+1]) is True, do you want to continue or return True? "
                    },
                    {
                        "username": "chezzyfries",
                        "content": "nice question. I underestimated it at first and came up with a wrong solution"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "To anyone getting error in this testcase [\"kuvp\",\"q\"] think a simple dictionary where if first character is small the obviously that word will come before the other word."
                    }
                ]
            },
            {
                "id": 1784229,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "UNDERSTAND THE QUESTION:\nwords=[\"apathy\", \"ape\"] will return 'TRUE' in normal Dictionary\nWHY?\nIn Dictionary, LENGTH OF WORD DOESN'T MATTER.\nSuppose you want to search word \"apathy\", you opened Dictionary you get the word \"ape\".\nMy question is whether you search \"apathy\" before \"ape\"! or after \"ape\"!    OfCourse before \"ape\"\n\nThe thing is: \nYou compare the ith charcater of words[0] & ith charcater of words[1]:\n1. if this is equal then only compare next character\n2. if this is not equal, then take decision which will come first (words[0] or words[1]). NO NEED TO CHECK FURTHUR.\n\nIn example,  first two letter 'a' & 'p' are same. Thus compare 3rd letter i.e.  'a' in \"apathy\"  &  'e' in \"ape\"\nSince,  'a' comes before 'e' , Hence, will return true.\n\nIn Above, I considered the order=\"abcdefghijklmnopqrstuvwxyz\" (normal aplhabetical order)\nDo it for the given 'order'    \n\nUpvote if it helps :)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Did you also missed adding the length check validation in your comparator function \\uD83D\\uDE09\\uD83D\\uDC7A"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can someone please explain test cases to me "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "words=[\"apathy\", \"ape\"] will return \\'TRUE\\' in normal Dictionary\\nWHY?\\nIn Dictionary, LENGTH OF WORD DOESN\\'T MATTER.\\nSuppose you want to search word \"apathy\", you opened Dictionary you get the word \"ape\".\\nMy question is whether you search \"apathy\" before \"ape\"! or after \"ape\"! OfCourse before \"ape\""
                    },
                    {
                        "username": "Juned_78832",
                        "content": "Yeah, it should be in list of medium"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "words=[\"kuvp\",\"q\"]\\norder=\"ngxlkthsjuoqcpavbfdermiywz\"\\noutput=false\\nExpected=true\\nWhat\\'s wrong in this TestCase anyone help me please."
                    },
                    {
                        "username": "anjaliu949",
                        "content": "The first character \\'k\\' from first string comes before \\'q\\' according to the order given which is true. Hence it is returning true.\\nNOTE: We need not check for the rest  of the characters as soon as we encounter first different char from both strings."
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "If you understood the question in first try, trust me, you are a legend!"
                    },
                    {
                        "username": "Sayfuddin",
                        "content": "I don\\'t understand this problem. Please, anyone, explain this problem and how to solve this."
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "order - alphabet \\nalphabet for example: a,b,c,d,e,f .........\\n\\ncheck if it\\'s sorted alphabetically, exactly **order**"
                    },
                    {
                        "username": "souviknath535",
                        "content": "this is too hard for an easy problem or maybe i should just go home and sell fish"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Unfortunately in my case, the first read of this question asks my mind to return a sorted list. And hence I wasted 25 mins on that."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least you can just check to see if your sorted list is the same as the input list..."
                    }
                ]
            },
            {
                "id": 1784222,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "UNDERSTAND THE QUESTION:\nwords=[\"apathy\", \"ape\"] will return 'TRUE' in normal Dictionary\nWHY?\nIn Dictionary, LENGTH OF WORD DOESN'T MATTER.\nSuppose you want to search word \"apathy\", you opened Dictionary you get the word \"ape\".\nMy question is whether you search \"apathy\" before \"ape\"! or after \"ape\"!    OfCourse before \"ape\"\n\nThe thing is: \nYou compare the ith charcater of words[0] & ith charcater of words[1]:\n1. if this is equal then only compare next character\n2. if this is not equal, then take decision which will come first (words[0] or words[1]). NO NEED TO CHECK FURTHUR.\n\nIn example,  first two letter 'a' & 'p' are same. Thus compare 3rd letter i.e.  'a' in \"apathy\"  &  'e' in \"ape\"\nSince,  'a' comes before 'e' , Hence, will return true.\n\nIn Above, I considered the order=\"abcdefghijklmnopqrstuvwxyz\" (normal aplhabetical order)\nDo it for the given 'order'    \n\nUpvote if it helps :)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Did you also missed adding the length check validation in your comparator function \\uD83D\\uDE09\\uD83D\\uDC7A"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can someone please explain test cases to me "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "words=[\"apathy\", \"ape\"] will return \\'TRUE\\' in normal Dictionary\\nWHY?\\nIn Dictionary, LENGTH OF WORD DOESN\\'T MATTER.\\nSuppose you want to search word \"apathy\", you opened Dictionary you get the word \"ape\".\\nMy question is whether you search \"apathy\" before \"ape\"! or after \"ape\"! OfCourse before \"ape\""
                    },
                    {
                        "username": "Juned_78832",
                        "content": "Yeah, it should be in list of medium"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "words=[\"kuvp\",\"q\"]\\norder=\"ngxlkthsjuoqcpavbfdermiywz\"\\noutput=false\\nExpected=true\\nWhat\\'s wrong in this TestCase anyone help me please."
                    },
                    {
                        "username": "anjaliu949",
                        "content": "The first character \\'k\\' from first string comes before \\'q\\' according to the order given which is true. Hence it is returning true.\\nNOTE: We need not check for the rest  of the characters as soon as we encounter first different char from both strings."
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "If you understood the question in first try, trust me, you are a legend!"
                    },
                    {
                        "username": "Sayfuddin",
                        "content": "I don\\'t understand this problem. Please, anyone, explain this problem and how to solve this."
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "order - alphabet \\nalphabet for example: a,b,c,d,e,f .........\\n\\ncheck if it\\'s sorted alphabetically, exactly **order**"
                    },
                    {
                        "username": "souviknath535",
                        "content": "this is too hard for an easy problem or maybe i should just go home and sell fish"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Unfortunately in my case, the first read of this question asks my mind to return a sorted list. And hence I wasted 25 mins on that."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least you can just check to see if your sorted list is the same as the input list..."
                    }
                ]
            },
            {
                "id": 1784217,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "UNDERSTAND THE QUESTION:\nwords=[\"apathy\", \"ape\"] will return 'TRUE' in normal Dictionary\nWHY?\nIn Dictionary, LENGTH OF WORD DOESN'T MATTER.\nSuppose you want to search word \"apathy\", you opened Dictionary you get the word \"ape\".\nMy question is whether you search \"apathy\" before \"ape\"! or after \"ape\"!    OfCourse before \"ape\"\n\nThe thing is: \nYou compare the ith charcater of words[0] & ith charcater of words[1]:\n1. if this is equal then only compare next character\n2. if this is not equal, then take decision which will come first (words[0] or words[1]). NO NEED TO CHECK FURTHUR.\n\nIn example,  first two letter 'a' & 'p' are same. Thus compare 3rd letter i.e.  'a' in \"apathy\"  &  'e' in \"ape\"\nSince,  'a' comes before 'e' , Hence, will return true.\n\nIn Above, I considered the order=\"abcdefghijklmnopqrstuvwxyz\" (normal aplhabetical order)\nDo it for the given 'order'    \n\nUpvote if it helps :)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Did you also missed adding the length check validation in your comparator function \\uD83D\\uDE09\\uD83D\\uDC7A"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can someone please explain test cases to me "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "words=[\"apathy\", \"ape\"] will return \\'TRUE\\' in normal Dictionary\\nWHY?\\nIn Dictionary, LENGTH OF WORD DOESN\\'T MATTER.\\nSuppose you want to search word \"apathy\", you opened Dictionary you get the word \"ape\".\\nMy question is whether you search \"apathy\" before \"ape\"! or after \"ape\"! OfCourse before \"ape\""
                    },
                    {
                        "username": "Juned_78832",
                        "content": "Yeah, it should be in list of medium"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "words=[\"kuvp\",\"q\"]\\norder=\"ngxlkthsjuoqcpavbfdermiywz\"\\noutput=false\\nExpected=true\\nWhat\\'s wrong in this TestCase anyone help me please."
                    },
                    {
                        "username": "anjaliu949",
                        "content": "The first character \\'k\\' from first string comes before \\'q\\' according to the order given which is true. Hence it is returning true.\\nNOTE: We need not check for the rest  of the characters as soon as we encounter first different char from both strings."
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "If you understood the question in first try, trust me, you are a legend!"
                    },
                    {
                        "username": "Sayfuddin",
                        "content": "I don\\'t understand this problem. Please, anyone, explain this problem and how to solve this."
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "order - alphabet \\nalphabet for example: a,b,c,d,e,f .........\\n\\ncheck if it\\'s sorted alphabetically, exactly **order**"
                    },
                    {
                        "username": "souviknath535",
                        "content": "this is too hard for an easy problem or maybe i should just go home and sell fish"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Unfortunately in my case, the first read of this question asks my mind to return a sorted list. And hence I wasted 25 mins on that."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least you can just check to see if your sorted list is the same as the input list..."
                    }
                ]
            },
            {
                "id": 1784198,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "UNDERSTAND THE QUESTION:\nwords=[\"apathy\", \"ape\"] will return 'TRUE' in normal Dictionary\nWHY?\nIn Dictionary, LENGTH OF WORD DOESN'T MATTER.\nSuppose you want to search word \"apathy\", you opened Dictionary you get the word \"ape\".\nMy question is whether you search \"apathy\" before \"ape\"! or after \"ape\"!    OfCourse before \"ape\"\n\nThe thing is: \nYou compare the ith charcater of words[0] & ith charcater of words[1]:\n1. if this is equal then only compare next character\n2. if this is not equal, then take decision which will come first (words[0] or words[1]). NO NEED TO CHECK FURTHUR.\n\nIn example,  first two letter 'a' & 'p' are same. Thus compare 3rd letter i.e.  'a' in \"apathy\"  &  'e' in \"ape\"\nSince,  'a' comes before 'e' , Hence, will return true.\n\nIn Above, I considered the order=\"abcdefghijklmnopqrstuvwxyz\" (normal aplhabetical order)\nDo it for the given 'order'    \n\nUpvote if it helps :)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Did you also missed adding the length check validation in your comparator function \\uD83D\\uDE09\\uD83D\\uDC7A"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can someone please explain test cases to me "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "words=[\"apathy\", \"ape\"] will return \\'TRUE\\' in normal Dictionary\\nWHY?\\nIn Dictionary, LENGTH OF WORD DOESN\\'T MATTER.\\nSuppose you want to search word \"apathy\", you opened Dictionary you get the word \"ape\".\\nMy question is whether you search \"apathy\" before \"ape\"! or after \"ape\"! OfCourse before \"ape\""
                    },
                    {
                        "username": "Juned_78832",
                        "content": "Yeah, it should be in list of medium"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "words=[\"kuvp\",\"q\"]\\norder=\"ngxlkthsjuoqcpavbfdermiywz\"\\noutput=false\\nExpected=true\\nWhat\\'s wrong in this TestCase anyone help me please."
                    },
                    {
                        "username": "anjaliu949",
                        "content": "The first character \\'k\\' from first string comes before \\'q\\' according to the order given which is true. Hence it is returning true.\\nNOTE: We need not check for the rest  of the characters as soon as we encounter first different char from both strings."
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "If you understood the question in first try, trust me, you are a legend!"
                    },
                    {
                        "username": "Sayfuddin",
                        "content": "I don\\'t understand this problem. Please, anyone, explain this problem and how to solve this."
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "order - alphabet \\nalphabet for example: a,b,c,d,e,f .........\\n\\ncheck if it\\'s sorted alphabetically, exactly **order**"
                    },
                    {
                        "username": "souviknath535",
                        "content": "this is too hard for an easy problem or maybe i should just go home and sell fish"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Unfortunately in my case, the first read of this question asks my mind to return a sorted list. And hence I wasted 25 mins on that."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least you can just check to see if your sorted list is the same as the input list..."
                    }
                ]
            },
            {
                "id": 1784195,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "UNDERSTAND THE QUESTION:\nwords=[\"apathy\", \"ape\"] will return 'TRUE' in normal Dictionary\nWHY?\nIn Dictionary, LENGTH OF WORD DOESN'T MATTER.\nSuppose you want to search word \"apathy\", you opened Dictionary you get the word \"ape\".\nMy question is whether you search \"apathy\" before \"ape\"! or after \"ape\"!    OfCourse before \"ape\"\n\nThe thing is: \nYou compare the ith charcater of words[0] & ith charcater of words[1]:\n1. if this is equal then only compare next character\n2. if this is not equal, then take decision which will come first (words[0] or words[1]). NO NEED TO CHECK FURTHUR.\n\nIn example,  first two letter 'a' & 'p' are same. Thus compare 3rd letter i.e.  'a' in \"apathy\"  &  'e' in \"ape\"\nSince,  'a' comes before 'e' , Hence, will return true.\n\nIn Above, I considered the order=\"abcdefghijklmnopqrstuvwxyz\" (normal aplhabetical order)\nDo it for the given 'order'    \n\nUpvote if it helps :)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Did you also missed adding the length check validation in your comparator function \\uD83D\\uDE09\\uD83D\\uDC7A"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can someone please explain test cases to me "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "words=[\"apathy\", \"ape\"] will return \\'TRUE\\' in normal Dictionary\\nWHY?\\nIn Dictionary, LENGTH OF WORD DOESN\\'T MATTER.\\nSuppose you want to search word \"apathy\", you opened Dictionary you get the word \"ape\".\\nMy question is whether you search \"apathy\" before \"ape\"! or after \"ape\"! OfCourse before \"ape\""
                    },
                    {
                        "username": "Juned_78832",
                        "content": "Yeah, it should be in list of medium"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "words=[\"kuvp\",\"q\"]\\norder=\"ngxlkthsjuoqcpavbfdermiywz\"\\noutput=false\\nExpected=true\\nWhat\\'s wrong in this TestCase anyone help me please."
                    },
                    {
                        "username": "anjaliu949",
                        "content": "The first character \\'k\\' from first string comes before \\'q\\' according to the order given which is true. Hence it is returning true.\\nNOTE: We need not check for the rest  of the characters as soon as we encounter first different char from both strings."
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "If you understood the question in first try, trust me, you are a legend!"
                    },
                    {
                        "username": "Sayfuddin",
                        "content": "I don\\'t understand this problem. Please, anyone, explain this problem and how to solve this."
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "order - alphabet \\nalphabet for example: a,b,c,d,e,f .........\\n\\ncheck if it\\'s sorted alphabetically, exactly **order**"
                    },
                    {
                        "username": "souviknath535",
                        "content": "this is too hard for an easy problem or maybe i should just go home and sell fish"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Unfortunately in my case, the first read of this question asks my mind to return a sorted list. And hence I wasted 25 mins on that."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least you can just check to see if your sorted list is the same as the input list..."
                    }
                ]
            },
            {
                "id": 1784173,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "UNDERSTAND THE QUESTION:\nwords=[\"apathy\", \"ape\"] will return 'TRUE' in normal Dictionary\nWHY?\nIn Dictionary, LENGTH OF WORD DOESN'T MATTER.\nSuppose you want to search word \"apathy\", you opened Dictionary you get the word \"ape\".\nMy question is whether you search \"apathy\" before \"ape\"! or after \"ape\"!    OfCourse before \"ape\"\n\nThe thing is: \nYou compare the ith charcater of words[0] & ith charcater of words[1]:\n1. if this is equal then only compare next character\n2. if this is not equal, then take decision which will come first (words[0] or words[1]). NO NEED TO CHECK FURTHUR.\n\nIn example,  first two letter 'a' & 'p' are same. Thus compare 3rd letter i.e.  'a' in \"apathy\"  &  'e' in \"ape\"\nSince,  'a' comes before 'e' , Hence, will return true.\n\nIn Above, I considered the order=\"abcdefghijklmnopqrstuvwxyz\" (normal aplhabetical order)\nDo it for the given 'order'    \n\nUpvote if it helps :)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Did you also missed adding the length check validation in your comparator function \\uD83D\\uDE09\\uD83D\\uDC7A"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can someone please explain test cases to me "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "words=[\"apathy\", \"ape\"] will return \\'TRUE\\' in normal Dictionary\\nWHY?\\nIn Dictionary, LENGTH OF WORD DOESN\\'T MATTER.\\nSuppose you want to search word \"apathy\", you opened Dictionary you get the word \"ape\".\\nMy question is whether you search \"apathy\" before \"ape\"! or after \"ape\"! OfCourse before \"ape\""
                    },
                    {
                        "username": "Juned_78832",
                        "content": "Yeah, it should be in list of medium"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "words=[\"kuvp\",\"q\"]\\norder=\"ngxlkthsjuoqcpavbfdermiywz\"\\noutput=false\\nExpected=true\\nWhat\\'s wrong in this TestCase anyone help me please."
                    },
                    {
                        "username": "anjaliu949",
                        "content": "The first character \\'k\\' from first string comes before \\'q\\' according to the order given which is true. Hence it is returning true.\\nNOTE: We need not check for the rest  of the characters as soon as we encounter first different char from both strings."
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "If you understood the question in first try, trust me, you are a legend!"
                    },
                    {
                        "username": "Sayfuddin",
                        "content": "I don\\'t understand this problem. Please, anyone, explain this problem and how to solve this."
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "order - alphabet \\nalphabet for example: a,b,c,d,e,f .........\\n\\ncheck if it\\'s sorted alphabetically, exactly **order**"
                    },
                    {
                        "username": "souviknath535",
                        "content": "this is too hard for an easy problem or maybe i should just go home and sell fish"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Unfortunately in my case, the first read of this question asks my mind to return a sorted list. And hence I wasted 25 mins on that."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least you can just check to see if your sorted list is the same as the input list..."
                    }
                ]
            },
            {
                "id": 1784161,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "UNDERSTAND THE QUESTION:\nwords=[\"apathy\", \"ape\"] will return 'TRUE' in normal Dictionary\nWHY?\nIn Dictionary, LENGTH OF WORD DOESN'T MATTER.\nSuppose you want to search word \"apathy\", you opened Dictionary you get the word \"ape\".\nMy question is whether you search \"apathy\" before \"ape\"! or after \"ape\"!    OfCourse before \"ape\"\n\nThe thing is: \nYou compare the ith charcater of words[0] & ith charcater of words[1]:\n1. if this is equal then only compare next character\n2. if this is not equal, then take decision which will come first (words[0] or words[1]). NO NEED TO CHECK FURTHUR.\n\nIn example,  first two letter 'a' & 'p' are same. Thus compare 3rd letter i.e.  'a' in \"apathy\"  &  'e' in \"ape\"\nSince,  'a' comes before 'e' , Hence, will return true.\n\nIn Above, I considered the order=\"abcdefghijklmnopqrstuvwxyz\" (normal aplhabetical order)\nDo it for the given 'order'    \n\nUpvote if it helps :)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Did you also missed adding the length check validation in your comparator function \\uD83D\\uDE09\\uD83D\\uDC7A"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can someone please explain test cases to me "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "words=[\"apathy\", \"ape\"] will return \\'TRUE\\' in normal Dictionary\\nWHY?\\nIn Dictionary, LENGTH OF WORD DOESN\\'T MATTER.\\nSuppose you want to search word \"apathy\", you opened Dictionary you get the word \"ape\".\\nMy question is whether you search \"apathy\" before \"ape\"! or after \"ape\"! OfCourse before \"ape\""
                    },
                    {
                        "username": "Juned_78832",
                        "content": "Yeah, it should be in list of medium"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "words=[\"kuvp\",\"q\"]\\norder=\"ngxlkthsjuoqcpavbfdermiywz\"\\noutput=false\\nExpected=true\\nWhat\\'s wrong in this TestCase anyone help me please."
                    },
                    {
                        "username": "anjaliu949",
                        "content": "The first character \\'k\\' from first string comes before \\'q\\' according to the order given which is true. Hence it is returning true.\\nNOTE: We need not check for the rest  of the characters as soon as we encounter first different char from both strings."
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "If you understood the question in first try, trust me, you are a legend!"
                    },
                    {
                        "username": "Sayfuddin",
                        "content": "I don\\'t understand this problem. Please, anyone, explain this problem and how to solve this."
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "order - alphabet \\nalphabet for example: a,b,c,d,e,f .........\\n\\ncheck if it\\'s sorted alphabetically, exactly **order**"
                    },
                    {
                        "username": "souviknath535",
                        "content": "this is too hard for an easy problem or maybe i should just go home and sell fish"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Unfortunately in my case, the first read of this question asks my mind to return a sorted list. And hence I wasted 25 mins on that."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least you can just check to see if your sorted list is the same as the input list..."
                    }
                ]
            },
            {
                "id": 1784060,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "UNDERSTAND THE QUESTION:\nwords=[\"apathy\", \"ape\"] will return 'TRUE' in normal Dictionary\nWHY?\nIn Dictionary, LENGTH OF WORD DOESN'T MATTER.\nSuppose you want to search word \"apathy\", you opened Dictionary you get the word \"ape\".\nMy question is whether you search \"apathy\" before \"ape\"! or after \"ape\"!    OfCourse before \"ape\"\n\nThe thing is: \nYou compare the ith charcater of words[0] & ith charcater of words[1]:\n1. if this is equal then only compare next character\n2. if this is not equal, then take decision which will come first (words[0] or words[1]). NO NEED TO CHECK FURTHUR.\n\nIn example,  first two letter 'a' & 'p' are same. Thus compare 3rd letter i.e.  'a' in \"apathy\"  &  'e' in \"ape\"\nSince,  'a' comes before 'e' , Hence, will return true.\n\nIn Above, I considered the order=\"abcdefghijklmnopqrstuvwxyz\" (normal aplhabetical order)\nDo it for the given 'order'    \n\nUpvote if it helps :)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Did you also missed adding the length check validation in your comparator function \\uD83D\\uDE09\\uD83D\\uDC7A"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can someone please explain test cases to me "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "words=[\"apathy\", \"ape\"] will return \\'TRUE\\' in normal Dictionary\\nWHY?\\nIn Dictionary, LENGTH OF WORD DOESN\\'T MATTER.\\nSuppose you want to search word \"apathy\", you opened Dictionary you get the word \"ape\".\\nMy question is whether you search \"apathy\" before \"ape\"! or after \"ape\"! OfCourse before \"ape\""
                    },
                    {
                        "username": "Juned_78832",
                        "content": "Yeah, it should be in list of medium"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "words=[\"kuvp\",\"q\"]\\norder=\"ngxlkthsjuoqcpavbfdermiywz\"\\noutput=false\\nExpected=true\\nWhat\\'s wrong in this TestCase anyone help me please."
                    },
                    {
                        "username": "anjaliu949",
                        "content": "The first character \\'k\\' from first string comes before \\'q\\' according to the order given which is true. Hence it is returning true.\\nNOTE: We need not check for the rest  of the characters as soon as we encounter first different char from both strings."
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "If you understood the question in first try, trust me, you are a legend!"
                    },
                    {
                        "username": "Sayfuddin",
                        "content": "I don\\'t understand this problem. Please, anyone, explain this problem and how to solve this."
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "order - alphabet \\nalphabet for example: a,b,c,d,e,f .........\\n\\ncheck if it\\'s sorted alphabetically, exactly **order**"
                    },
                    {
                        "username": "souviknath535",
                        "content": "this is too hard for an easy problem or maybe i should just go home and sell fish"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Unfortunately in my case, the first read of this question asks my mind to return a sorted list. And hence I wasted 25 mins on that."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least you can just check to see if your sorted list is the same as the input list..."
                    }
                ]
            },
            {
                "id": 1784053,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "UNDERSTAND THE QUESTION:\nwords=[\"apathy\", \"ape\"] will return 'TRUE' in normal Dictionary\nWHY?\nIn Dictionary, LENGTH OF WORD DOESN'T MATTER.\nSuppose you want to search word \"apathy\", you opened Dictionary you get the word \"ape\".\nMy question is whether you search \"apathy\" before \"ape\"! or after \"ape\"!    OfCourse before \"ape\"\n\nThe thing is: \nYou compare the ith charcater of words[0] & ith charcater of words[1]:\n1. if this is equal then only compare next character\n2. if this is not equal, then take decision which will come first (words[0] or words[1]). NO NEED TO CHECK FURTHUR.\n\nIn example,  first two letter 'a' & 'p' are same. Thus compare 3rd letter i.e.  'a' in \"apathy\"  &  'e' in \"ape\"\nSince,  'a' comes before 'e' , Hence, will return true.\n\nIn Above, I considered the order=\"abcdefghijklmnopqrstuvwxyz\" (normal aplhabetical order)\nDo it for the given 'order'    \n\nUpvote if it helps :)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Did you also missed adding the length check validation in your comparator function \\uD83D\\uDE09\\uD83D\\uDC7A"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can someone please explain test cases to me "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "words=[\"apathy\", \"ape\"] will return \\'TRUE\\' in normal Dictionary\\nWHY?\\nIn Dictionary, LENGTH OF WORD DOESN\\'T MATTER.\\nSuppose you want to search word \"apathy\", you opened Dictionary you get the word \"ape\".\\nMy question is whether you search \"apathy\" before \"ape\"! or after \"ape\"! OfCourse before \"ape\""
                    },
                    {
                        "username": "Juned_78832",
                        "content": "Yeah, it should be in list of medium"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "words=[\"kuvp\",\"q\"]\\norder=\"ngxlkthsjuoqcpavbfdermiywz\"\\noutput=false\\nExpected=true\\nWhat\\'s wrong in this TestCase anyone help me please."
                    },
                    {
                        "username": "anjaliu949",
                        "content": "The first character \\'k\\' from first string comes before \\'q\\' according to the order given which is true. Hence it is returning true.\\nNOTE: We need not check for the rest  of the characters as soon as we encounter first different char from both strings."
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "If you understood the question in first try, trust me, you are a legend!"
                    },
                    {
                        "username": "Sayfuddin",
                        "content": "I don\\'t understand this problem. Please, anyone, explain this problem and how to solve this."
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "order - alphabet \\nalphabet for example: a,b,c,d,e,f .........\\n\\ncheck if it\\'s sorted alphabetically, exactly **order**"
                    },
                    {
                        "username": "souviknath535",
                        "content": "this is too hard for an easy problem or maybe i should just go home and sell fish"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Unfortunately in my case, the first read of this question asks my mind to return a sorted list. And hence I wasted 25 mins on that."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least you can just check to see if your sorted list is the same as the input list..."
                    }
                ]
            },
            {
                "id": 1784045,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "UNDERSTAND THE QUESTION:\nwords=[\"apathy\", \"ape\"] will return 'TRUE' in normal Dictionary\nWHY?\nIn Dictionary, LENGTH OF WORD DOESN'T MATTER.\nSuppose you want to search word \"apathy\", you opened Dictionary you get the word \"ape\".\nMy question is whether you search \"apathy\" before \"ape\"! or after \"ape\"!    OfCourse before \"ape\"\n\nThe thing is: \nYou compare the ith charcater of words[0] & ith charcater of words[1]:\n1. if this is equal then only compare next character\n2. if this is not equal, then take decision which will come first (words[0] or words[1]). NO NEED TO CHECK FURTHUR.\n\nIn example,  first two letter 'a' & 'p' are same. Thus compare 3rd letter i.e.  'a' in \"apathy\"  &  'e' in \"ape\"\nSince,  'a' comes before 'e' , Hence, will return true.\n\nIn Above, I considered the order=\"abcdefghijklmnopqrstuvwxyz\" (normal aplhabetical order)\nDo it for the given 'order'    \n\nUpvote if it helps :)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Did you also missed adding the length check validation in your comparator function \\uD83D\\uDE09\\uD83D\\uDC7A"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can someone please explain test cases to me "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "words=[\"apathy\", \"ape\"] will return \\'TRUE\\' in normal Dictionary\\nWHY?\\nIn Dictionary, LENGTH OF WORD DOESN\\'T MATTER.\\nSuppose you want to search word \"apathy\", you opened Dictionary you get the word \"ape\".\\nMy question is whether you search \"apathy\" before \"ape\"! or after \"ape\"! OfCourse before \"ape\""
                    },
                    {
                        "username": "Juned_78832",
                        "content": "Yeah, it should be in list of medium"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "words=[\"kuvp\",\"q\"]\\norder=\"ngxlkthsjuoqcpavbfdermiywz\"\\noutput=false\\nExpected=true\\nWhat\\'s wrong in this TestCase anyone help me please."
                    },
                    {
                        "username": "anjaliu949",
                        "content": "The first character \\'k\\' from first string comes before \\'q\\' according to the order given which is true. Hence it is returning true.\\nNOTE: We need not check for the rest  of the characters as soon as we encounter first different char from both strings."
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "If you understood the question in first try, trust me, you are a legend!"
                    },
                    {
                        "username": "Sayfuddin",
                        "content": "I don\\'t understand this problem. Please, anyone, explain this problem and how to solve this."
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "order - alphabet \\nalphabet for example: a,b,c,d,e,f .........\\n\\ncheck if it\\'s sorted alphabetically, exactly **order**"
                    },
                    {
                        "username": "souviknath535",
                        "content": "this is too hard for an easy problem or maybe i should just go home and sell fish"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Unfortunately in my case, the first read of this question asks my mind to return a sorted list. And hence I wasted 25 mins on that."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least you can just check to see if your sorted list is the same as the input list..."
                    }
                ]
            }
        ]
    },
    {
        "title": "Array of Doubled Pairs",
        "question_content": "<p>Given an integer array of even length <code>arr</code>, return <code>true</code><em> if it is possible to reorder </em><code>arr</code><em> such that </em><code>arr[2 * i + 1] = 2 * arr[2 * i]</code><em> for every </em><code>0 &lt;= i &lt; len(arr) / 2</code><em>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [3,1,3,6]\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [2,1,2,6]\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [4,-2,2,-4]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>arr.length</code> is even.</li>\n\t<li><code>-10<sup>5</sup> &lt;= arr[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 203183,
                "title": "java-c-python-match-from-the-smallest-or-biggest-100",
                "content": "## **Intuition**\\n**Let\\'s see a simple case**\\nAssume all interger are positive, for example `[2,4,4,8]`.\\nWe have one `x = 2`,  we need to match it with one `2x = 4`.\\nThen one `4` is gone, we have the other `x = 4`.\\nWe need to match it with one `2x = 8`.\\nFinaly no number left.\\n\\n**Why we start from `2`?**\\nBecause it\\'s the smallest and we no there is no `x/2` left.\\nSo we know we need to find `2x`\\n\\n\\n**What if the case negative?**\\nOne way is that start from the biggest (with abosolute value smallest),\\nand we aplly same logic.\\n\\nAnother way is that start from the smallest (with abosolute value biggest),\\nand we try to find `x/2` each turn.\\n<br>\\n\\n## **Explanation**\\n1. Count all numbers.\\n2. Loop all numbers on the order of its absolute.\\n    We have `counter[x]` of `x`, so we need the same amount of `2x` wo match them.\\n    If `c[x] > c[2 * x]`, then we return false\\n    If `c[x] <= c[2 * x]`, then we do `c[2 * x] -= c[x]` to remove matched `2x`.\\n\\n\\nDon\\'t worry about `0`, it doesn\\'t fit the logic above but it won\\'t break our algorithme.\\n\\nIn case count[0] is odd, it won\\'t get matched in the end.\\n(Anyway you can return false earlier here)\\n\\nIn case count[0] is even, we still have `c[0] <= c[2 * 0]`.\\nAnd we still need to check all other numbers.\\n<br>\\n\\n**Java, O(NlogK):**\\n```\\n    public boolean canReorderDoubled(int[] A) {\\n        Map<Integer, Integer> count = new TreeMap<>();\\n        for (int a : A)\\n            count.put(a, count.getOrDefault(a, 0) + 1);\\n        for (int x : count.keySet()) {\\n            if (count.get(x) == 0) continue;\\n            int want = x < 0 ? x / 2 : x * 2;\\n            if (x < 0 && x % 2 != 0 || count.get(x) > count.getOrDefault(want, 0))\\n                return false;\\n            count.put(want, count.get(want) - count.get(x));\\n        }\\n        return true;\\n    }\\n```\\n\\n**C++, O(N + KlogK)**\\n```\\n    bool canReorderDoubled(vector<int>& A) {\\n        unordered_map<int, int> c;\\n        for (int a : A) c[a]++;\\n        vector<int> keys;\\n        for (auto it : c)\\n            keys.push_back(it.first);\\n        sort(keys.begin(), keys.end(), [](int i, int j) {return abs(i) < abs(j);});\\n        for (int x : keys) {\\n            if (c[x] > c[2 * x])\\n                return false;\\n            c[2 * x] -= c[x];\\n        }\\n        return true;\\n    }\\n```\\n\\n**Python, O(N + KlogK), 100~200ms**\\n```\\n    def canReorderDoubled(self, A):\\n        c = collections.Counter(A)\\n        for x in sorted(c, key=abs):\\n            if c[x] > c[2 * x]:\\n                return False\\n            c[2 * x] -= c[x]\\n        return True\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public boolean canReorderDoubled(int[] A) {\\n        Map<Integer, Integer> count = new TreeMap<>();\\n        for (int a : A)\\n            count.put(a, count.getOrDefault(a, 0) + 1);\\n        for (int x : count.keySet()) {\\n            if (count.get(x) == 0) continue;\\n            int want = x < 0 ? x / 2 : x * 2;\\n            if (x < 0 && x % 2 != 0 || count.get(x) > count.getOrDefault(want, 0))\\n                return false;\\n            count.put(want, count.get(want) - count.get(x));\\n        }\\n        return true;\\n    }\\n```\n```\\n    bool canReorderDoubled(vector<int>& A) {\\n        unordered_map<int, int> c;\\n        for (int a : A) c[a]++;\\n        vector<int> keys;\\n        for (auto it : c)\\n            keys.push_back(it.first);\\n        sort(keys.begin(), keys.end(), [](int i, int j) {return abs(i) < abs(j);});\\n        for (int x : keys) {\\n            if (c[x] > c[2 * x])\\n                return false;\\n            c[2 * x] -= c[x];\\n        }\\n        return true;\\n    }\\n```\n```\\n    def canReorderDoubled(self, A):\\n        c = collections.Counter(A)\\n        for x in sorted(c, key=abs):\\n            if c[x] > c[2 * x]:\\n                return False\\n            c[2 * x] -= c[x]\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1396876,
                "title": "c-java-python-greedy-algorithm-clear-explanation-o-nlogn-clean-concise",
                "content": "**Idea**\\n- We greedily process elements starting from the smallest value, **WHY smallest value but not an arbitrary value?**\\n\\t- Because since it\\'s the smallest values, let say `x`, there is **only one choice** to pair with `x`:\\n\\t\\t- If `x` is a positive number, then it pairs with `y = x*2`, for example: `x = 4` pair with `y = 8`.\\n\\t\\t- If `x` is a non-positive number, then it pairs with `y = x/2`, for example: `x = -8` pair with `y = -4`.\\n\\t\\t- If there is no corresponding `y` then it\\'s IMPOSSIBLE, return FALSE.\\n\\t- If it\\'s an arbitrary value, let say `x`, **there are two choices**, either `x/2` or `x*2` is also a good pairing with `x` (no matter if x is a possible or negative number), if we choose `x/2` or `x*2` to pair with `x`, it **maybe WRONG**, because some other elements may need it to make pair.\\n\\tFor example: `arr = [2, 4, 1, 8]`\\n\\t\\t- If we process `x = 2` first, then there are 2 choices, either `4` or `1` can be paired with `2`, if we choose `4` -> **we got WRONG ANSWER**.\\n\\t\\t- Because `8` needs `4`, so `2` should be paired with `1`.\\n- So we need to sort our `arr` array first.\\n- When a pair of (`x` and `y`) match, we need to decrease their count. So we need to use a **HashTable** data structure to count the frequency of elements in the `arr` array.\\n\\n<iframe src=\"https://leetcode.com/playground/dRWkNhEK/shared\" frameBorder=\"0\" width=\"100%\" height=\"380\"></iframe>\\n\\n**Complexity**\\n- Time: `O(NlogN)`, where `N <= 3 * 10^4` is number of elements in `arr` array.\\n- Space: `O(N)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "**Idea**\\n- We greedily process elements starting from the smallest value, **WHY smallest value but not an arbitrary value?**\\n\\t- Because since it\\'s the smallest values, let say `x`, there is **only one choice** to pair with `x`:\\n\\t\\t- If `x` is a positive number, then it pairs with `y = x*2`, for example: `x = 4` pair with `y = 8`.\\n\\t\\t- If `x` is a non-positive number, then it pairs with `y = x/2`, for example: `x = -8` pair with `y = -4`.\\n\\t\\t- If there is no corresponding `y` then it\\'s IMPOSSIBLE, return FALSE.\\n\\t- If it\\'s an arbitrary value, let say `x`, **there are two choices**, either `x/2` or `x*2` is also a good pairing with `x` (no matter if x is a possible or negative number), if we choose `x/2` or `x*2` to pair with `x`, it **maybe WRONG**, because some other elements may need it to make pair.\\n\\tFor example: `arr = [2, 4, 1, 8]`\\n\\t\\t- If we process `x = 2` first, then there are 2 choices, either `4` or `1` can be paired with `2`, if we choose `4` -> **we got WRONG ANSWER**.\\n\\t\\t- Because `8` needs `4`, so `2` should be paired with `1`.\\n- So we need to sort our `arr` array first.\\n- When a pair of (`x` and `y`) match, we need to decrease their count. So we need to use a **HashTable** data structure to count the frequency of elements in the `arr` array.\\n\\n<iframe src=\"https://leetcode.com/playground/dRWkNhEK/shared\" frameBorder=\"0\" width=\"100%\" height=\"380\"></iframe>\\n\\n**Complexity**\\n- Time: `O(NlogN)`, where `N <= 3 * 10^4` is number of elements in `arr` array.\\n- Space: `O(N)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "codeTag": "Unknown"
            },
            {
                "id": 1396805,
                "title": "python-o-n-log-n-greedy-solution-explained",
                "content": "How to understand that you need to apply greedy strategy in some problem? It is a good question, and usually I try it after I see nothing else can work. In this specific problem it is quite easy to find greedy strategy. Let us think, we are given number `x`, what pair should we give to this number? It can be `2*x` or `x//2` (if x is even). So, we can not immedietly say, which pair we should choose? Is there any number such that it has only one pair? Yes, it is the number with smallest (or biggest) absolute value. For number with smallest absolute value `x` we can take as pair only `x*2`, no other choice. What is rest is to continue this process.\\n\\n1. We sort our number with key `abs(x)`.\\n2. Also we create `cnt` is Counter of all numbers: it can happen that we have some numbers several times.\\n3. Iterate through sorted `arr` and if we see that frequency of some number is already `0`: it can happen, because this number can be taken, we do nothing. If it is not zero, but we do not have pair `2*num`, return `False`. Finally, we decreasy frequencies of two numbers: `num` and `2*num`.\\n\\n#### Complexity\\nIt is `O(n log n)` to sort number and then `O(n)` to put them all into pairs, so overall time complexity is `O(n log n)`. Space complexity is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def canReorderDoubled(self, arr):\\n        cnt = Counter(arr)\\n        for num in sorted(arr, key = lambda x: abs(x)):\\n            if cnt[num] == 0: continue\\n            if cnt[2*num] == 0: return False\\n            cnt[num] -= 1\\n            cnt[2*num] -= 1\\n        \\n        return True\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def canReorderDoubled(self, arr):\\n        cnt = Counter(arr)\\n        for num in sorted(arr, key = lambda x: abs(x)):\\n            if cnt[num] == 0: continue\\n            if cnt[2*num] == 0: return False\\n            cnt[num] -= 1\\n            cnt[2*num] -= 1\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396834,
                "title": "c-simple-and-easy-solution-with-detailed-explanation",
                "content": "**Idea:**\\n1. We keep a frequency map.\\n2. Sort the array. Soon I\\'ll explain why it\\'s needed.\\n3. For each number, if we can find it and it\\'s double in the map, we decrement their frequencies.\\n4. If the map is empty, we return true.\\n\\n**Why does it work?**\\nWe need to reorder the array so that we have n/2 pairs of (x, x * 2).\\nSo all we need to do is keep track which numbers we used already for a different pair.\\nWhy do we have to sort?\\nFor example, if we have in the array [2, 4, 8, 1].\\nWe will get to the 2, find it\\'s double - 4, and then the 1 and 8 will stay without a pair!\\nIf we sort, then we go in an ascending order, so it won\\'t happen.\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        unordered_map<int, int> freq;\\n        for (auto num : arr) freq[num]++;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        for (auto num : arr) {\\n            if (freq[num] && freq[num*2]) {\\n                freq[num]--;\\n                freq[num*2]--;\\n            }\\n        }\\n        \\n        for (auto [a, b] : freq)\\n            if (b) return false;\\n        \\n        return true;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        unordered_map<int, int> freq;\\n        for (auto num : arr) freq[num]++;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        for (auto num : arr) {\\n            if (freq[num] && freq[num*2]) {\\n                freq[num]--;\\n                freq[num*2]--;\\n            }\\n        }\\n        \\n        for (auto [a, b] : freq)\\n            if (b) return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556099,
                "title": "c-map-easy-to-understand-well-commented-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    static bool compare(int a,int b){\\n        return abs(a)<abs(b);\\n    }\\n    bool canReorderDoubled(vector<int>& A) {\\n        sort(A.begin(),A.end(),compare);\\n        unordered_map<int,int> m;\\n        for(int i=0;i<A.size();i++)m[A[i]]++;\\n        for(int i=0;i<A.size();i++){\\n            if(m[A[i]]==0) //If element has been already used by smaller element\\n                continue;\\n            if(m[2*A[i]]==0) //If I am unable to get its pair, I will return false\\n                return false;\\n            m[2*A[i]]--,m[A[i]]--; //Subtracting frequency of this pair of elements from map\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    static bool compare(int a,int b){\\n        return abs(a)<abs(b);\\n    }\\n    bool canReorderDoubled(vector<int>& A) {\\n        sort(A.begin(),A.end(),compare);\\n        unordered_map<int,int> m;\\n        for(int i=0;i<A.size();i++)m[A[i]]++;\\n        for(int i=0;i<A.size();i++){\\n            if(m[A[i]]==0) //If element has been already used by smaller element\\n                continue;\\n            if(m[2*A[i]]==0) //If I am unable to get its pair, I will return false\\n                return false;\\n            m[2*A[i]]--,m[A[i]]--; //Subtracting frequency of this pair of elements from map\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203503,
                "title": "python-o-1-space-two-pointers",
                "content": "1. We sort the list (ascending) by absolute value and make sure the negative ones come before the positive ones. \\n2. Then we use two pointers. Since the values are ascending (by abs), the fast pointer never looks back and will only reach the end of the list if it falis to find a 2*x and returns false. When it does find a match, it marks the item with a dummy value so that the slow pointer can skip it.\\n3. Time is O(NlogN), Space is O(1).\\n```\\nclass Solution:\\n    def canReorderDoubled(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        dummy = 1000000\\n        A.sort(key=lambda x:(x>0,abs(x)))\\n        size =len(A)\\n        fast=0\\n        for i in range(size):\\n            if A[i]==dummy: continue\\n            if fast<=i: fast = i+1\\n            while fast<size and A[fast]!=2*A[i]: fast+=1\\n            if fast==size: return False\\n            A[fast] = dummy\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canReorderDoubled(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        dummy = 1000000\\n        A.sort(key=lambda x:(x>0,abs(x)))\\n        size =len(A)\\n        fast=0\\n        for i in range(size):\\n            if A[i]==dummy: continue\\n            if fast<=i: fast = i+1\\n            while fast<size and A[fast]!=2*A[i]: fast+=1\\n            if fast==size: return False\\n            A[fast] = dummy\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209564,
                "title": "java-heap-concise",
                "content": "```\\nclass Solution {\\n    \\n    public boolean canReorderDoubled(int[] A) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> {\\n            return Math.abs(a) - Math.abs(b);\\n        });\\n        for (int num : A) {\\n            pq.offer(num);\\n        }\\n        while (!pq.isEmpty()) {\\n            Integer num = pq.poll();\\n            if (!pq.remove(num * 2)) return false;\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public boolean canReorderDoubled(int[] A) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> {\\n            return Math.abs(a) - Math.abs(b);\\n        });\\n        for (int num : A) {\\n            pq.offer(num);\\n        }\\n        while (!pq.isEmpty()) {\\n            Integer num = pq.poll();\\n            if (!pq.remove(num * 2)) return false;\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397307,
                "title": "array-of-doubled-pairs-greedy-approach-w-explanation-c-python-java",
                "content": "**INTUITION:**\\nIf `x` is currently the array element with the least absolute value, it must pair with `2*x`, as there does not exist any other `x/2` to pair with it.\\n\\n**ALGORITHM:**\\n* Create a map m, `n = size of A`, store the frequency of each element in A into map m\\n* `cnt` = size of A\\n* for each key-value pair kv in map\\n\\t* if `m[key of kv] > 0`, then\\n\\t\\t* if `m[key of kv]` is `not 0` and `m[2* key of kv] > 0`\\n\\t\\t* x = `min` of `m[key of kv]` and `m[2* key of kv]`\\n\\t\\t* cnt = `cnt \\u2013 (x * 2)`\\n\\t\\t* Decrease `m[2 * key of kv]` by `x`\\n\\t\\t* Decrease `m[key of kv]` by `x`\\n\\t* Otherwise when `key of kv = 0`, then\\n\\t\\t* cnt = `cnt \\u2013 m[key of kv]`\\n\\t\\t* `m[key of kv] = 0`\\n* return `false` when `cnt is non-zero`, otherwise true\\n\\n**SOLUTION:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& A) {\\n      map <int, int> m;\\n      int n = A.size();\\n      for(int i = 0; i < n; i++)\\n      {\\n         m[A[i]]++;\\n      }\\n      int cnt = A.size();\\n      map <int, int> :: iterator it = m.begin();\\n      while(it != m.end())\\n      {\\n         if(m[it->first] > 0)\\n         {\\n            if(it->first != 0 && m[it->first * 2] > 0)\\n            {\\n               int x = min(m[it->first], m[it->first * 2]);\\n               cnt -= (x * 2);\\n               m[it->first * 2] -= x;\\n               m[it->first] -= x;\\n            }\\n            else if(it->first == 0) \\n/*That is the case for the value 0 from the vector.\\nSince there is no different element for 0*2, we directly do cnt -= m[it->first] and m[it->first] =0 \\nis clearing the map value of `0` since we won\\'t come back to it in any further iteration */\\n            {\\n               cnt -= m[it->first];\\n               m[it->first] = 0;\\n            }\\n         }\\n         it++;\\n      }\\n      return !cnt;\\n    }\\n};\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] A) {\\n        Map<Integer, Integer> count = new HashMap();\\n        for (int x: A)\\n        {\\n            count.put(x, count.getOrDefault(x, 0) + 1);\\n        }\\n        Integer[] B = new Integer[A.length];\\n        for (int i = 0; i < A.length; ++i)\\n        {\\n            B[i] = A[i] ;\\n        }\\n        Arrays.sort(B, Comparator.comparingInt(Math::abs));\\n        for (int x: B) \\n        {\\n            if(count.get(x) == 0)\\n            {\\n                continue ;\\n            }\\n            if(count.getOrDefault(2*x, 0) <= 0) \\n            {\\n                return false;\\n            }\\n            count.put(x, count.get(x) - 1);\\n            count.put(2*x, count.get(2*x) - 1);\\n        }\\n        return true;\\n    }\\n}\\n```\\n`In Python`\\n```\\nclass Solution(object):\\n    def canReorderDoubled(self, A):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        count = collections.Counter(A)\\n        for x in sorted(A, key = abs):\\n            if count[x] == 0: \\n                continue\\n            if count[2*x] == 0: \\n                return False\\n            count[x] -= 1\\n            count[2*x] -= 1\\n\\n        return True\\n        \\n```\\n**Complexity Analysis**\\n\\n**Time Complexity:** `O(NlogN)`, where N is the size of A.\\n**Space Complexity:** `O(N)`.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& A) {\\n      map <int, int> m;\\n      int n = A.size();\\n      for(int i = 0; i < n; i++)\\n      {\\n         m[A[i]]++;\\n      }\\n      int cnt = A.size();\\n      map <int, int> :: iterator it = m.begin();\\n      while(it != m.end())\\n      {\\n         if(m[it->first] > 0)\\n         {\\n            if(it->first != 0 && m[it->first * 2] > 0)\\n            {\\n               int x = min(m[it->first], m[it->first * 2]);\\n               cnt -= (x * 2);\\n               m[it->first * 2] -= x;\\n               m[it->first] -= x;\\n            }\\n            else if(it->first == 0) \\n/*That is the case for the value 0 from the vector.\\nSince there is no different element for 0*2, we directly do cnt -= m[it->first] and m[it->first] =0 \\nis clearing the map value of `0` since we won\\'t come back to it in any further iteration */\\n            {\\n               cnt -= m[it->first];\\n               m[it->first] = 0;\\n            }\\n         }\\n         it++;\\n      }\\n      return !cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] A) {\\n        Map<Integer, Integer> count = new HashMap();\\n        for (int x: A)\\n        {\\n            count.put(x, count.getOrDefault(x, 0) + 1);\\n        }\\n        Integer[] B = new Integer[A.length];\\n        for (int i = 0; i < A.length; ++i)\\n        {\\n            B[i] = A[i] ;\\n        }\\n        Arrays.sort(B, Comparator.comparingInt(Math::abs));\\n        for (int x: B) \\n        {\\n            if(count.get(x) == 0)\\n            {\\n                continue ;\\n            }\\n            if(count.getOrDefault(2*x, 0) <= 0) \\n            {\\n                return false;\\n            }\\n            count.put(x, count.get(x) - 1);\\n            count.put(2*x, count.get(2*x) - 1);\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def canReorderDoubled(self, A):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        count = collections.Counter(A)\\n        for x in sorted(A, key = abs):\\n            if count[x] == 0: \\n                continue\\n            if count[2*x] == 0: \\n                return False\\n            count[x] -= 1\\n            count[2*x] -= 1\\n\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397916,
                "title": "from-o-n-log-n-to-o-n-3-approaches-summarized-updated",
                "content": "### Approach # 1 - Match using a hashmap\\nProcess numbers in sorted order of the absolute value. Use a hashmap to remember what numbers (`2*x`) you expect to see. If you see an expected number, decrement its count, otherwise increment the count of the expected number (`2*x`). At the end all values in the expected hashmap should be zero.\\n\\n* Optimization: Since we expect to have 2*x for every x in the input, the sum of all the values should be a multiple of 3.\\n    \\n* Time: `O(n * log n)`\\n* Space: `O(n)`\\n\\n### Python \\n\\n```    \\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        if sum(arr)%3 != 0: return False\\n        \\n        expected = defaultdict(int)\\n        for a in sorted(arr, key = abs):\\n            if expected[a] > 0:\\n                expected[a] -= 1\\n            else:\\n                expected[2*a] += 1\\n        \\n        return all(x == 0 for x in expected.values())\\n```\\n\\n### Approach # 2 - Match using a frequency counter\\n\\nBasically the same underlying logic. Start with a frequency of all values in a hashmap. Match all duplicate values at once i.e. reduce frequency of `2*key` by frequency of `key`. If, at any point, we don\\'t have enough `2*key` to match with `key`, we return `False`. At the end we can just return `True`, however the hashmap would still contain redundant values. Same running time as the first approach, except that this approach will run faster if there are many duplicates.\\n\\n* Time: `O(n * log n)`\\n* Space: `O(n)`\\n\\n### Python\\n```\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        if sum(arr)%3 != 0: return False\\n        counter = Counter(arr)\\n        for key in sorted(counter, key = abs):\\n            if counter[key] > counter[2*key]: return False\\n            counter[2*key] -= counter[key]\\n        return True\\n```\\n\\n### Approach # 3 - Match all in groups, without sorting\\nCredits to @g27as\\nApproach is explained here: https://leetcode.com/problems/array-of-doubled-pairs/discuss/205960/JAVA-O(N)-time-O(N)-space-Solution\\n\\n### Summary:\\nWe use sort in the first two approaches to deal with the confusion of matching even values, say `2*x` with `x` or `4*x`. E.g. if we encounter `2`, we don\\'t know whether to match it with `1` or with `4`. Processing them in sorted order, we ensure that we always deal with smaller values first. So if we ever encounter `2`, we know `1` is already dealt with, so we always match with `4`.\\n\\nHowever, we can deal with this without having to sort the input or the keys of the hashmap, if we process such numbers in groups. If we have `1`, `2`, `4` and `8` in our hashmap and we encounter `4`, we reduce it to `1` and then start matching `1` to `2`, then `2` to `4` and then `4` to `8`. We do need to deal with `0` separately though, which is trivial.\\n\\n*  `n = len(arr)` and `N = max(arr)`\\n* Time: `O(n * log N)` in theory but practically runs as fast as `O(n)`\\n* Space: `O(n)`\\n\\n```\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        if sum(arr)%3 != 0: return False\\n        counter = Counter(arr)\\n        \\n        if 0 in counter:\\n            if counter[0]%2: return False\\n            counter.pop(0)\\n            \\n        for num in list(counter.keys()):\\n            if num not in counter: \\n                continue\\n            while num % 2 == 0 and num//2 in counter: \\n                num = num // 2\\n            while counter[num] > 0 and 2*num in counter:\\n                counter[2*num] -= counter[num]\\n                counter.pop(num)\\n                num = 2*num\\n            if counter[num] != 0: return False\\n\\n        return True\\n```\\n\\n### Update\\nHere is a slightly different implementation of the Approach#3. It is easy to argue that every entry in `counter` is popped exactly once and every iteration of the loop will pop at least one entry from `counter`. Hence this approach is `O(n)`.\\n\\n```\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        if sum(arr)%3 != 0: return False\\n        counter = Counter(arr)\\n        \\n        if 0 in counter:\\n            if counter[0]%2: return False\\n            counter.pop(0)\\n            \\n        while counter:\\n            num = next(iter(counter))\\n            while num % 2 == 0 and num//2 in counter: \\n                num = num // 2\\n            while counter[num] > 0 and 2*num in counter:\\n                counter[2*num] -= counter[num]\\n                counter.pop(num)\\n                num = 2*num\\n            if counter[num] != 0: return False\\n            counter.pop(num)\\n\\n        return True\\n```\\n\\n*The above indeed consistently runs faster than 100% all python3 submissions at the time of writing this.*\\n",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```    \\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        if sum(arr)%3 != 0: return False\\n        \\n        expected = defaultdict(int)\\n        for a in sorted(arr, key = abs):\\n            if expected[a] > 0:\\n                expected[a] -= 1\\n            else:\\n                expected[2*a] += 1\\n        \\n        return all(x == 0 for x in expected.values())\\n```\n```\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        if sum(arr)%3 != 0: return False\\n        counter = Counter(arr)\\n        for key in sorted(counter, key = abs):\\n            if counter[key] > counter[2*key]: return False\\n            counter[2*key] -= counter[key]\\n        return True\\n```\n```\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        if sum(arr)%3 != 0: return False\\n        counter = Counter(arr)\\n        \\n        if 0 in counter:\\n            if counter[0]%2: return False\\n            counter.pop(0)\\n            \\n        for num in list(counter.keys()):\\n            if num not in counter: \\n                continue\\n            while num % 2 == 0 and num//2 in counter: \\n                num = num // 2\\n            while counter[num] > 0 and 2*num in counter:\\n                counter[2*num] -= counter[num]\\n                counter.pop(num)\\n                num = 2*num\\n            if counter[num] != 0: return False\\n\\n        return True\\n```\n```\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        if sum(arr)%3 != 0: return False\\n        counter = Counter(arr)\\n        \\n        if 0 in counter:\\n            if counter[0]%2: return False\\n            counter.pop(0)\\n            \\n        while counter:\\n            num = next(iter(counter))\\n            while num % 2 == 0 and num//2 in counter: \\n                num = num // 2\\n            while counter[num] > 0 and 2*num in counter:\\n                counter[2*num] -= counter[num]\\n                counter.pop(num)\\n                num = 2*num\\n            if counter[num] != 0: return False\\n            counter.pop(num)\\n\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 203308,
                "title": "java-solution-one-hashmap-only-for-both-positive-and-negative-numbers",
                "content": "// (0). one map only: to count the frequency of apperance of each number\\n    // (1). Sort the array, then scan from the smalllest to find (x, 2x) pairs\\n    //   ___ (a) for negative number, we will see 2x first, the match should be half of it.  \\n    //  ___ (b). for positive, we will see x first, the match should be two times of it.\\n    // (2) once matched, update the map\\n    // (3). no need to put 0 into the map.\\n\\t    Example:  [3, 6, -4, -2, 0, 0, 14, 7, -2, -4]\\n\\t\\tYour stdout\\n\\t\\tmap: {-2=2, -4=2, 3=1, 6=1, 7=1, 14=1}\\n\\t\\tmap: {-2=0, -4=0, 3=1, 6=1, 7=1, 14=1} after process (-4, -2) pair\\n\\t\\tmap: {-2=0, -4=0, 3=0, 6=0, 7=1, 14=1} after process (3, 6) pair\\n\\t\\tmap: {-2=0, -4=0, 3=0, 6=0, 7=0, 14=0} after process (7, 14) pair\\n\\t\\tYour answer: true\\n   \\n    \\n\\n    \\n\\t\\n\\t```\\n    public boolean canReorderDoubled(int[] A) {\\n        \\n        int n = A.length;\\n        if (n % 2 != 0) return false;\\n        Arrays.sort(A);\\n        Map<Integer, Integer> map = new HashMap<>(); // <num, freq>\\n        for (int item : A) {\\n            if (item == 0) continue;\\n            map.put(item, map.getOrDefault(item, 0) + 1);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (A[i] != 0 && map.get(A[i]) > 0) {\\n                //System.out.println(\"map: \" + map);\\n                int target = A[i] * 2; // (3). positive, target = 2x \\n                if (A[i] < 0) { // (2) for negative (-4), the match should be half of it. \\n                    if (A[i] % 2 != 0) { // A[i] = -7, A[i] / 2 = -3\\n                        return false;\\n                    } else {\\n                        target = A[i] / 2; // negative: target = x\\n                    }\\n                }\\n                if (map.getOrDefault(target, 0) < map.get(A[i])) {\\n                    return false;\\n                } else {\\n                    // (4) once matched, update the map\\n                    map.put(target, map.get(target)  - map.get(A[i]));\\n                    map.put(A[i], 0);\\n                }\\n            }\\n        }\\n        //System.out.println(\"map: \" + map);\\n        return true;\\n    \\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canReorderDoubled(int[] A) {\\n        \\n        int n = A.length;\\n        if (n % 2 != 0) return false;\\n        Arrays.sort(A);\\n        Map<Integer, Integer> map = new HashMap<>(); // <num, freq>\\n        for (int item : A) {\\n            if (item == 0) continue;\\n            map.put(item, map.getOrDefault(item, 0) + 1);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (A[i] != 0 && map.get(A[i]) > 0) {\\n                //System.out.println(\"map: \" + map);\\n                int target = A[i] * 2; // (3). positive, target = 2x \\n                if (A[i] < 0) { // (2) for negative (-4), the match should be half of it. \\n                    if (A[i] % 2 != 0) { // A[i] = -7, A[i] / 2 = -3\\n                        return false;\\n                    } else {\\n                        target = A[i] / 2; // negative: target = x\\n                    }\\n                }\\n                if (map.getOrDefault(target, 0) < map.get(A[i])) {\\n                    return false;\\n                } else {\\n                    // (4) once matched, update the map\\n                    map.put(target, map.get(target)  - map.get(A[i]));\\n                    map.put(A[i], 0);\\n                }\\n            }\\n        }\\n        //System.out.println(\"map: \" + map);\\n        return true;\\n    \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1398380,
                "title": "c-greedy-explaination-with-code-hashmap",
                "content": "* Idea is really simple. We need to find the corresponding *2 x element* for every element in array.\\n* To keep track of count of each element we use a map that stores frequency of elements. \\n* Also, we need to sort the elements based on absolute value, so that we find the closest 2x of element starting from smaller one.\\n\\t* Ex : [2,1,4,8] \\n\\t* if we start from 2 , we will match it with 4 . But we need to match 2 with 1 and 4 with 8. \\n\\t* This case will fail if do not sort.\\n* So we then iterate over the array and find if there is an entry in map such that its value is 2x .\\n\\t* `if(mp.find(2*i) != mp.end())`\\n\\t\\t* If yes, then we check if frequency of that element is greater than or equal to i. \\n\\t\\t\\t* If no, then return false.\\n\\t\\t\\t* `if(mp[2*i] < mp[i]) return false;`\\n\\t\\t* Now, reduce the count of element as we have paired those elements\\n\\t\\t\\t* `mp[2*i] -= mp[i]; mp[i] = 0;`\\n* In the end, we check if any element is remaining in map which has not been paired. If there is some element then simply return false.\\n\\t* `for(auto& i : mp) if(i.second > 0) return false;`\\n* Other wise, return true. This means we have paired all the elements with their corresponding 2x respectively.\\n\\t\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    static bool compare(int &a, int &b)\\n    {\\n\\t\\treturn abs(a) < abs(b);\\n    }\\n    \\n    bool canReorderDoubled(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        if(n == 0) return true;\\n        \\n        unordered_map<int, int> mp;\\n        for(auto& i : arr) mp[i]++;\\n        \\n        sort(arr.begin(), arr.end(), compare);\\n        \\n        for(auto& i : arr)\\n        {\\n            if(mp.find(2*i) != mp.end())\\n            {\\n                if(mp[2*i] < mp[i]) return false;\\n                mp[2*i] -= mp[i];\\n                mp[i] = 0;\\n            }\\n        }\\n        \\n        for(auto& i : mp) if(i.second > 0) return false;\\n        return true;\\n    }\\n};\\n```\\n**Time : O(N logN)**\\n**Space : O(N)**\\n\\n**If you understood the explanation do upvote !!**",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool compare(int &a, int &b)\\n    {\\n\\t\\treturn abs(a) < abs(b);\\n    }\\n    \\n    bool canReorderDoubled(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        if(n == 0) return true;\\n        \\n        unordered_map<int, int> mp;\\n        for(auto& i : arr) mp[i]++;\\n        \\n        sort(arr.begin(), arr.end(), compare);\\n        \\n        for(auto& i : arr)\\n        {\\n            if(mp.find(2*i) != mp.end())\\n            {\\n                if(mp[2*i] < mp[i]) return false;\\n                mp[2*i] -= mp[i];\\n                mp[i] = 0;\\n            }\\n        }\\n        \\n        for(auto& i : mp) if(i.second > 0) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397176,
                "title": "javascript-building-up-solution-with-easy-explanation-o-n-log-n-time-o-n-space",
                "content": "The problem could be rephrased. Could we find a pair for each number in the array, so one element of the pair is twice bigger than other? \\n\\nTo easy check if there is an element in the array, we can use counter : a map which counts how many times each number appeared. For [-1, -2, 1, 1, 2, 2] counter would be (-1: 1, -2: 1, 1:2, 2:2).\\n\\n## Easy mistake\\nBut if we approach the map to make pairs for the elements immediately, we can run into trouble.\\nPresuming we have this array. [2, 4, 1, 8].\\nWe can pair 2 with 4. And find no pair for 1, cause the array is unsorted!\\nSo first of all, we should sort the array.\\n\\n## Sorting array in JS\\nBy default array sort in JS is compared number as they were characters: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort  It could be strange for someone who had come from python world. So be careful and pass the proper function to sort, to make it sort numbers. \\n```\\n    arr.sort((a, b) => a - b);\\n```\\n## Pairs for negative numbers\\nWhen you approach the sorted array and start with the smallest negative numbers, they should be **divided by 2** to identify their pairs. And when you jump to processing the positive ones, they should be **multiplied by 2**. Alternatively you can use sorting by modules, not real values  to escape this problem. \\n## Coding solution \\n```\\narr.sort((a, b) => a - b);\\nlet counter = new Map();\\nfor (let num of arr) {\\n\\tif(!counter.has(num)) {\\n\\t\\tcounter.set(num, 0);\\n\\t}\\n\\tcounter.set(num, counter.get(num) + 1);\\n}\\nfor (let num of arr) {\\n\\tif (!counter.has(num)) {\\n\\t\\tcontinue;\\n\\t}\\n\\tlet pair = num >= 0 ? num * 2 : num / 2;\\n\\tif(!counter.has(pair)) {\\n\\t\\treturn false;\\n\\t}\\n\\tfor (let k of [num, pair]) {\\n\\t\\tcounter.set(k, counter.get(k) - 1);\\n\\t\\tif (counter.get(k) === 0) {\\n\\t\\t\\tcounter.delete(k);\\n\\t\\t}\\n\\t}\\n}\\nreturn true;\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\n    arr.sort((a, b) => a - b);\\n```\n```\\narr.sort((a, b) => a - b);\\nlet counter = new Map();\\nfor (let num of arr) {\\n\\tif(!counter.has(num)) {\\n\\t\\tcounter.set(num, 0);\\n\\t}\\n\\tcounter.set(num, counter.get(num) + 1);\\n}\\nfor (let num of arr) {\\n\\tif (!counter.has(num)) {\\n\\t\\tcontinue;\\n\\t}\\n\\tlet pair = num >= 0 ? num * 2 : num / 2;\\n\\tif(!counter.has(pair)) {\\n\\t\\treturn false;\\n\\t}\\n\\tfor (let k of [num, pair]) {\\n\\t\\tcounter.set(k, counter.get(k) - 1);\\n\\t\\tif (counter.get(k) === 0) {\\n\\t\\t\\tcounter.delete(k);\\n\\t\\t}\\n\\t}\\n}\\nreturn true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 739533,
                "title": "java-beats-99-o-nlogn-time-o-1-space",
                "content": "1. sort the array\\n2. Consider two pointers at the start - i and j\\n3. if 2*i == j or i == 2*j (reverse to accomodate negatives) then we have solution, mark the two numbers as visited and move forward. To mark a number visited I update the value to 100001\\n4. if either i or j lands on visited, they move forward\\n5. else only j moves forward\\n\\n```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] A) {\\n        int n = A.length;\\n        Arrays.sort(A);\\n        int i=0,j=0;\\n        while(i<n && j<n) {\\n            if(A[i] == 100001)  { // check if visited\\n                i++;\\n            }\\n            else if(A[j] == 100001)  { // check if visited\\n                j++;\\n            }\\n           else if(2*A[i] == A[j] || A[i] == 2*A[j]) { // A[i] == 2*A[j] to accomodate negatives numbers : [-4, -2, 0, 0, 1, 2] \\n                A[i] = 100001; // mark visited\\n                A[j] = 100001; // mark visited\\n                i++;j++;\\n            }\\n            else {\\n                j++;\\n            }\\n        }\\n        while(i<n && A[i] == 100001) i++;\\n        return i>=n; // if any number left visited then its false\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] A) {\\n        int n = A.length;\\n        Arrays.sort(A);\\n        int i=0,j=0;\\n        while(i<n && j<n) {\\n            if(A[i] == 100001)  { // check if visited\\n                i++;\\n            }\\n            else if(A[j] == 100001)  { // check if visited\\n                j++;\\n            }\\n           else if(2*A[i] == A[j] || A[i] == 2*A[j]) { // A[i] == 2*A[j] to accomodate negatives numbers : [-4, -2, 0, 0, 1, 2] \\n                A[i] = 100001; // mark visited\\n                A[j] = 100001; // mark visited\\n                i++;j++;\\n            }\\n            else {\\n                j++;\\n            }\\n        }\\n        while(i<n && A[i] == 100001) i++;\\n        return i>=n; // if any number left visited then its false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397514,
                "title": "easy-c-solution-using-multiset",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    struct cmp{\\n        bool operator()(const int& a, const int& b) const {\\n            if (abs(a) == abs(b)) return a < b;\\n            else return abs(a) < abs(b);\\n        }\\n    };\\n    bool canReorderDoubled(vector<int>& arr) {\\n        int n = arr.size();\\n        multiset<int,cmp> m;\\n        for(auto i : arr)m.insert(i);\\n        while(m.size()){\\n            auto i = *m.begin();\\n            m.erase(m.begin());\\n            auto i2 = m.find(i*2);\\n            if(i2==m.end())return false;\\n            m.erase(i2);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct cmp{\\n        bool operator()(const int& a, const int& b) const {\\n            if (abs(a) == abs(b)) return a < b;\\n            else return abs(a) < abs(b);\\n        }\\n    };\\n    bool canReorderDoubled(vector<int>& arr) {\\n        int n = arr.size();\\n        multiset<int,cmp> m;\\n        for(auto i : arr)m.insert(i);\\n        while(m.size()){\\n            auto i = *m.begin();\\n            m.erase(m.begin());\\n            auto i2 = m.find(i*2);\\n            if(i2==m.end())return false;\\n            m.erase(i2);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 205960,
                "title": "java-o-n-time-o-n-space-solution",
                "content": "Still we first get a hashmap of all values in array and their counts. Since the problem is asking if we can reorder the array so the position of the values are not important here. We can think that what we are having in the hashmap are:\\n\\n..., a/4, a/2, a, 2*a, 4*a, ...\\n...,  x1,  x2, x3, x4,   x5, ...\\n\\n..., b/4, b/2, b, 2*b, 4*b, ...\\n...,  y1,  y2, y3, y4,   y5, ...\\n.\\n.\\n.\\n\\n\\nIn above example the hashmap is divided into several groups, where each group is a geometric series while ratio is 2. This makes the question to be \"return true if and only if it is possible to reorder **each group** such that A[2 * i + 1] = 2 * A[2 * i] for every 0 <= i < len(A) / 2\". If all groups returns true, then the problem should return true.\\nLet\\'s take at one group, for any number in the (middle of the) group, we have b/2, b, 2*b. Let\\'s assume the count for each number is x, y, z. We can tell that b needs to be paired with either b/2 or 2*b, meaning y <= x+z. Now let\\'s look at the smallest number b/i with count say count(b/i) = m, we can also tell that m needs to be at most equal to the count of the next smallest number say b/(i*2) and count(b/(i*2))=n, so we have m<=n. Taking example of \\nb1, b2, b3, b4, ...\\ny1, y2, y3, y4, ...\\n\\nand we will know that, to meet the problem\\'s requirement:\\n1. y1 - y2 + y3 - y4 + ... = 0\\n2. y1 - y2 <= 0 && y1 - y2 + y3 >= 0 && y1- y2 + y3 - y4 <= 0 && ....\\n\\nNow we can decide the whole question by checking the 2 conditions for each group. For each group, to find the smallest number (or the biggest if all numbers in the group is nagative), we just need to start with a random number in the group and try number /= 2 until number is odd or number is not contained in the array. \\n\\nSo the solution is like:\\n1. Get count hashmap\\n2. For each number in the map\\n\\t1. If this number (or group containing it) is visited before, skip it\\n\\t2. Get the smallest number in the group\\n\\t3. Start from the smallest number, calculate the result of (y1 - y2 + y3...) so far and check if it matches the requirement above.\\n\\t4. Check if the final result of (y1 - y2 + y3) for this group is 0.\\n\\nIn solution, each number will be visited 4 time at most:\\n1. When getting count hashmap\\n2. When checking if number is visited\\n3. When finding the smallest number\\n4. when calculating (y1 - y2 + y3)\\n\\nSo the total time complexity is O(N) and space complexity is O(N) as well by using one hashmap.\\n\\nCode:\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\t\\tpublic boolean canReorderDoubled(int[] A) {\\n\\t\\t\\tif(A == null || A.length == 0) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\t\\tfor(int a : A) {\\n\\t\\t\\t\\tmap.put(a, map.getOrDefault(a, 0) + 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile(map.size() > 0) {\\n\\t\\t\\t\\tint val = map.keySet().iterator().next();\\n\\t\\t\\t\\t// deal with 0\\n\\t\\t\\t\\tif(val == 0) {\\n\\t\\t\\t\\t\\tif(map.get(val) % 2 != 0) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tmap.remove(val);\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// get smallest num\\n\\t\\t\\t\\twhile(val % 2 == 0 && map.containsKey(val / 2)) {\\n\\t\\t\\t\\t\\tval /= 2;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// iterate\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tboolean plus = false;\\n\\t\\t\\t\\twhile(map.containsKey(val)) {\\n\\t\\t\\t\\t\\tcount += (plus ? map.get(val) : (0 - map.get(val)));\\n\\t\\t\\t\\t\\tif((plus && count < 0) || (!plus && count > 0)) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tplus = plus ? false : true;\\n\\t\\t\\t\\t\\tmap.remove(val);\\n\\t\\t\\t\\t\\tval *= 2;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(count != 0) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\'\\'\\'\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean canReorderDoubled(int[] A) {\\n\\t\\t\\tif(A == null || A.length == 0) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1397705,
                "title": "java-fast-solution-w-comments",
                "content": "```java\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        //Build count map.\\n        for (int num: arr) {\\n            if (!map.containsKey(num))\\n                map.put(num, 0);\\n            map.put(num, map.get(num) + 1);\\n        }\\n        \\n        //Create a sorted list of all unique elements. Sort by absolute value.\\n        List<Integer> list = new ArrayList<>(map.keySet());\\n        Collections.sort(list, (a, b) -> Integer.compare(Math.abs(a), Math.abs(b)));\\n        \\n        for (int num: list) {\\n            int count = map.get(num);\\n            //This means the number was already matched in a previous iteration.\\n            if (count == 0)\\n                continue;\\n            \\n            int pairCount = map.getOrDefault(2*num, 0);\\n            //If the number\\'s count is greater than that of its pair, then some copies of it will remain unmatched.\\n            if (count > pairCount)\\n                return false;\\n            \\n            //Update the count of the pair.\\n            map.put(2*num, pairCount - count);\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n\\n**Time Complexity**\\n\\n`O(NlogN)`. Sorting is the dominant factor.\\n\\n**Space Complexity**\\n\\n`O(N)`.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        //Build count map.\\n        for (int num: arr) {\\n            if (!map.containsKey(num))\\n                map.put(num, 0);\\n            map.put(num, map.get(num) + 1);\\n        }\\n        \\n        //Create a sorted list of all unique elements. Sort by absolute value.\\n        List<Integer> list = new ArrayList<>(map.keySet());\\n        Collections.sort(list, (a, b) -> Integer.compare(Math.abs(a), Math.abs(b)));\\n        \\n        for (int num: list) {\\n            int count = map.get(num);\\n            //This means the number was already matched in a previous iteration.\\n            if (count == 0)\\n                continue;\\n            \\n            int pairCount = map.getOrDefault(2*num, 0);\\n            //If the number\\'s count is greater than that of its pair, then some copies of it will remain unmatched.\\n            if (count > pairCount)\\n                return false;\\n            \\n            //Update the count of the pair.\\n            map.put(2*num, pairCount - count);\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396883,
                "title": "c-explained-with-comments-unordered-map-o-nlogn",
                "content": "```\\n\\n/*\\n\\nHarshit Gupta | 11th August, 2021\\n---------------------------------\\n\\nProblem Statement:\\n    Given an array of integers arr of even length, return true if and only if it is possible to \\n        reorder it such that arr[2 * i + 1] = 2 * arr[2 * i] for every 0 <= i < len(arr) / 2.\\n\\nExample 1:\\n    Input: arr = [3,1,3,6]\\n    Output: false\\n\\nExample 2:\\n    Input: arr = [2,1,2,6]\\n    Output: false\\n\\nExample 3:\\n    Input: arr = [4,-2,2,-4]\\n    Output: true\\n    Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].\\n\\nExample 4:\\n    Input: arr = [1,2,4,16,8,4]\\n    Output: false\\n\\n------\\n\\nSolution: 1. Sort on absolute Value\\n\\n        arr[2 * i + 1] = 2 * arr[2 * i]\\n\\n        i=0,    arr[1] = 2*arr[0]       => arr[0] = arr[1]/2\\n        i=1,    arr[3] = 2*arr[2]       => arr[2] = arr[3]/2\\n        i=2,    arr[5] = 2*arr[4]       => arr[4] = arr[5]/2\\n        ..\\n        i=n/2-1,  arr[n-1] = 2*arr[n-2] => arr[n-2] = arr[n-1]/2\\n\\n    1. Take a umap and get the count of each variable.\\n    2. Sort it on the absolute values of the array since we want to tackle the smallest first\\n        - This is done on absolute value since if normal values are taken the algo fails for negative values\\n        - Ex: [4,-2,2,-4] after normal sorting becomes [-4,-2,2,4] and for -4 we start searching for -8 which is wrong.\\n        - We must search for elements -2 and 2 and pair them up with bigger values.\\n    3. For all the array elements \\n        - If both arr[i] and 2*arr[i] exists, then decrement it\\'s count in umap\\n        - If arr[i] exists and 2*arr[i] doesn\\'t exist, then there is a problem and we return false!!\\n            - The reason why we need to check if arr[i] exists is that consider [1,2,...], for 1\\n                it will decrease both 1 and 2\\'s frequency and then when we come for 2, it has 0 freq\\n                which is fine and we shouldn\\'t return false here, we just move on to the next element.\\n                So, basically there is a problem when we can findarr[i] but not 2*arr[i], then we return false.\\n    4. If we are able to match for all the arr[] elements, then return true.\\n    \\n\\n    TC: O(nlogn)\\n    SC: O(n) for map\\n\\nParadigm:\\n---\\n    NOTE: \\n\\n    Similar Questions:\\n        1.\\n\\n*/\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        unordered_map<int, int> umap;\\n        for(int i=0; i<arr.size(); i++)\\n            umap[arr[i]]++;\\n        \\n        sort(arr.begin(), arr.end(),[](int i, int j) {return abs(i) < abs(j);});\\n        \\n        \\n        for(int i=0; i<arr.size(); i++){\\n            if(umap[arr[i]]>0 && umap[2*arr[i]]>0){\\n                umap[arr[i]]--;\\n                umap[2*arr[i]]--;\\n            }\\n            else if (umap[arr[i]]>0 && umap[2*arr[i]]<=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\n/*\\n\\nHarshit Gupta | 11th August, 2021\\n---------------------------------\\n\\nProblem Statement:\\n    Given an array of integers arr of even length, return true if and only if it is possible to \\n        reorder it such that arr[2 * i + 1] = 2 * arr[2 * i] for every 0 <= i < len(arr) / 2.\\n\\nExample 1:\\n    Input: arr = [3,1,3,6]\\n    Output: false\\n\\nExample 2:\\n    Input: arr = [2,1,2,6]\\n    Output: false\\n\\nExample 3:\\n    Input: arr = [4,-2,2,-4]\\n    Output: true\\n    Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].\\n\\nExample 4:\\n    Input: arr = [1,2,4,16,8,4]\\n    Output: false\\n\\n------\\n\\nSolution: 1. Sort on absolute Value\\n\\n        arr[2 * i + 1] = 2 * arr[2 * i]\\n\\n        i=0,    arr[1] = 2*arr[0]       => arr[0] = arr[1]/2\\n        i=1,    arr[3] = 2*arr[2]       => arr[2] = arr[3]/2\\n        i=2,    arr[5] = 2*arr[4]       => arr[4] = arr[5]/2\\n        ..\\n        i=n/2-1,  arr[n-1] = 2*arr[n-2] => arr[n-2] = arr[n-1]/2\\n\\n    1. Take a umap and get the count of each variable.\\n    2. Sort it on the absolute values of the array since we want to tackle the smallest first\\n        - This is done on absolute value since if normal values are taken the algo fails for negative values\\n        - Ex: [4,-2,2,-4] after normal sorting becomes [-4,-2,2,4] and for -4 we start searching for -8 which is wrong.\\n        - We must search for elements -2 and 2 and pair them up with bigger values.\\n    3. For all the array elements \\n        - If both arr[i] and 2*arr[i] exists, then decrement it\\'s count in umap\\n        - If arr[i] exists and 2*arr[i] doesn\\'t exist, then there is a problem and we return false!!\\n            - The reason why we need to check if arr[i] exists is that consider [1,2,...], for 1\\n                it will decrease both 1 and 2\\'s frequency and then when we come for 2, it has 0 freq\\n                which is fine and we shouldn\\'t return false here, we just move on to the next element.\\n                So, basically there is a problem when we can findarr[i] but not 2*arr[i], then we return false.\\n    4. If we are able to match for all the arr[] elements, then return true.\\n    \\n\\n    TC: O(nlogn)\\n    SC: O(n) for map\\n\\nParadigm:\\n---\\n    NOTE: \\n\\n    Similar Questions:\\n        1.\\n\\n*/\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        unordered_map<int, int> umap;\\n        for(int i=0; i<arr.size(); i++)\\n            umap[arr[i]]++;\\n        \\n        sort(arr.begin(), arr.end(),[](int i, int j) {return abs(i) < abs(j);});\\n        \\n        \\n        for(int i=0; i<arr.size(); i++){\\n            if(umap[arr[i]]>0 && umap[2*arr[i]]>0){\\n                umap[arr[i]]--;\\n                umap[2*arr[i]]--;\\n            }\\n            else if (umap[arr[i]]>0 && umap[2*arr[i]]<=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397844,
                "title": "java-solution-clean-code-complete-explanation",
                "content": "1. Let us first sort the array completely so that the negative numbers are on the left side.\\n2. Now we will create a hashmap to hold the count of all the numbers in from our given array. Eg -> occurence of every number \\n[3,1,3,6] => [{1 : 1}, {3 : 2}, {6 : 1}]\\n3. Now lets itterate over the given array.\\n4. If the number is negative and it will be the least negative number as the array is sorted already (Point 1 in the code).\\na. Now first we need to check wether this number is a multiple of 2 (Point A in the code). Reason behind this is that incase the number we are itterating over is -5, then 2 * -5 = -10 (which will definetly not be present in the array, as -5 > -10 and we are itterating over an SORTED array.)\\nb. Thus now we need to check if wether there is a number equal to x / 2, as this is the smallest number and x/2 of the number would never possibly be in the array (Point B in the code). If x / 2 exists then we simply decrease the occurence of x and x / 2 by 1. Else we return false.\\n5. Now if the number is not negative then it has to be positive (Point 2 in the code).\\na. If the number is smallest positive integer then it would be paired with a number which is 2 * x. Thus we find if 2 * x is present within our occurence hashmap. If it is present we go ahead or return false. (Point C in the code).\\nb. Similar to the negative part, if its pair is present then we will decrease both their occurences by one. (Point D in the code.)\\n6. Now since the array is over and if we dont come across any negative case for either positive or negative numbers, so we return true.\\n\\n**Key Take-away from the problem :**\\nSince the array is sorted, thus we need to check if :\\ni. x / 2 should be present for every negative number. If yes, then decrement by 1 ; else return false.\\nii. 2 * x should be present for every positive number. If yes, then decrement by 1 ; else return false.\\n\\n```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        Arrays.sort(arr);\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for(int x : arr){\\n            count.put(x, count.getOrDefault(x, 0) + 1);\\n        }\\n        for(int x : arr){\\n            if(count.get(x) > 0){\\n                if(x < 0){ // Point 1\\n                    if(x%2 == 0){ // Point A\\n                        if(count.getOrDefault(x/2, 0) > 0){ // Point B\\n                            count.put(x, count.get(x) - 1);\\n                            count.put(x/2, count.get(x/2) - 1);\\n                        } else {\\n                            return false;\\n                        }\\n                    } else {\\n                        return false;\\n                    }\\n                } else { // Point 2\\n                    if(count.getOrDefault(x*2, 0) > 0){ // Point C and D\\n                        count.put(x, count.get(x) - 1);\\n                        count.put(2*x, count.get(2*x) - 1);\\n                    } else {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\nPlease upvote if you understood or found the explanation helpful ^_^",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        Arrays.sort(arr);\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for(int x : arr){\\n            count.put(x, count.getOrDefault(x, 0) + 1);\\n        }\\n        for(int x : arr){\\n            if(count.get(x) > 0){\\n                if(x < 0){ // Point 1\\n                    if(x%2 == 0){ // Point A\\n                        if(count.getOrDefault(x/2, 0) > 0){ // Point B\\n                            count.put(x, count.get(x) - 1);\\n                            count.put(x/2, count.get(x/2) - 1);\\n                        } else {\\n                            return false;\\n                        }\\n                    } else {\\n                        return false;\\n                    }\\n                } else { // Point 2\\n                    if(count.getOrDefault(x*2, 0) > 0){ // Point C and D\\n                        count.put(x, count.get(x) - 1);\\n                        count.put(2*x, count.get(2*x) - 1);\\n                    } else {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397792,
                "title": "c-greedy-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, int> mp;\\n        for(int &x : arr) mp[x]++;\\n        \\n        auto lambda = [&](int &a, int &b){\\n            return abs(a) < abs(b);\\n        };\\n        \\n        sort(begin(arr), end(arr), lambda); //O(nlog(n))\\n        \\n        for(int &x : arr) { //O(n)\\n            if(mp[x] == 0) continue;\\n            \\n            if(mp.find(2*x) == end(mp) || mp[2*x] == 0) return false;\\n            \\n            mp[x]--;\\n            mp[2*x]--;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, int> mp;\\n        for(int &x : arr) mp[x]++;\\n        \\n        auto lambda = [&](int &a, int &b){\\n            return abs(a) < abs(b);\\n        };\\n        \\n        sort(begin(arr), end(arr), lambda); //O(nlog(n))\\n        \\n        for(int &x : arr) { //O(n)\\n            if(mp[x] == 0) continue;\\n            \\n            if(mp.find(2*x) == end(mp) || mp[2*x] == 0) return false;\\n            \\n            mp[x]--;\\n            mp[2*x]--;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769857,
                "title": "why-sorting-is-compulsory-here",
                "content": "```\\nWell sorting is compulsorty here \\nreason :-\\nlet\\'s say x is array element\\n\\nyou can either make pair of either\\nx and 2*x  ( if 2*x exist in array ) or\\nx and x/2  ( if  x/2 exist in array )\\n\\nnow for which pair i should search first  ?\\n\\ncase 1 : if i search for x and x*2  first \\n\\n[2, 4, 8, 1].\\nthis will make pair (2,4) and (8,1) and give wrong answer\\nideal pair should be (1,2) and (4,8)\\n\\ncase 2 : if i search for pair x and x/2 first \\n\\n[-4,-2,-8,-1]\\n\\nit will try to make pair (-4,-2) and (-8,-1) \\nstill failing .\\n\\nnow one may think that in case of negatives we can search for -ve bigger values \\nin case of 4 search for 2 and in case of -4 search for -8.\\n\\n[ -8 , -4, -1, -2, -16,-32]\\n\\nlet\\'s make pairs (-8,-16)  now -32 will not have any pair\\n\\n\\nnow you may have got the idea that we need to \\nmake pairs from the lowest possible value\\notherwise we may make wrong pair and \\nreturn false  answer.\\n```",
                "solutionTags": [],
                "code": "```\\nWell sorting is compulsorty here \\nreason :-\\nlet\\'s say x is array element\\n\\nyou can either make pair of either\\nx and 2*x  ( if 2*x exist in array ) or\\nx and x/2  ( if  x/2 exist in array )\\n\\nnow for which pair i should search first  ?\\n\\ncase 1 : if i search for x and x*2  first \\n\\n[2, 4, 8, 1].\\nthis will make pair (2,4) and (8,1) and give wrong answer\\nideal pair should be (1,2) and (4,8)\\n\\ncase 2 : if i search for pair x and x/2 first \\n\\n[-4,-2,-8,-1]\\n\\nit will try to make pair (-4,-2) and (-8,-1) \\nstill failing .\\n\\nnow one may think that in case of negatives we can search for -ve bigger values \\nin case of 4 search for 2 and in case of -4 search for -8.\\n\\n[ -8 , -4, -1, -2, -16,-32]\\n\\nlet\\'s make pairs (-8,-16)  now -32 will not have any pair\\n\\n\\nnow you may have got the idea that we need to \\nmake pairs from the lowest possible value\\notherwise we may make wrong pair and \\nreturn false  answer.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 203202,
                "title": "my-python-contest-solution-beats-100",
                "content": "```\\nclass Solution:\\n    def canReorderDoubled(self, A):\\n        cnt = collections.Counter(A)\\n        for a in sorted(A, key = abs):\\n            if cnt[a] and cnt[a * 2]:\\n                cnt[a] -= 1\\n                cnt[a * 2] -= 1  \\n        return all(cnt[a] == 0 for a in A)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canReorderDoubled(self, A):\\n        cnt = collections.Counter(A)\\n        for a in sorted(A, key = abs):\\n            if cnt[a] and cnt[a * 2]:\\n                cnt[a] -= 1\\n                cnt[a * 2] -= 1  \\n        return all(cnt[a] == 0 for a in A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010032,
                "title": "hashmap-solution-using-frequency-map-explained",
                "content": "class Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int val : arr){\\n            if(val != 0){\\n                map.put(val, map.getOrDefault(val, 0) + 1);  // making frequency map ie filling hashmap and freq of each element\\n            }\\n        }\\n        \\n        Arrays.sort(arr); \\n        \\n        for(int val : arr){\\n            if(map.containsKey(val) && map.containsKey(2 * val)){   // if arr contains both val and its double\\n                if(map.getOrDefault(val, 0) > 1){                   // then if frequency is greater than 1 \\n                    map.put(val, map.getOrDefault(val, 0) - 1);     // then decrease the frequency and put it again in hashmap\\n                }\\n                else{\\n                    map.remove(val);   // if freq is one then remove that val \\n                }\\n                \\n                if(map.getOrDefault(2 * val, 0) > 1){      // if double value\\'s frequency is greater than 1 \\n                    map.put(2 * val, map.getOrDefault(2 * val, 0) - 1);  // then decrease the frequency of that doubled value\\n                } \\n                else{\\n                    map.remove(2 * val);   // and if freqn of doubled value is 1 then remove that doubled value also\\n                }\\n            }\\n        }\\n        \\n        if(map.size() == 0){    // at last if size of hashmap is 0 then we are right and return true \\n            return true;\\n        }\\n        else{                   // if size is not = to 0 then return false\\n            return false;\\n        }\\n    }\\n}\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/e509032c-7cb9-46b0-aefa-2077638f5f72_1651738737.745449.jpeg)\\n![image](https://assets.leetcode.com/users/images/f7c5ca64-0cca-4d03-8361-40fac40bac71_1651738748.2936645.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int val : arr){\\n            if(val != 0){\\n                map.put(val, map.getOrDefault(val, 0) + 1);  // making frequency map ie filling hashmap and freq of each element\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1449674,
                "title": "c-map",
                "content": "This one is using two maps one for negative number and one for positive number\\n```\\nmap<int,int>M;\\n        map<int,int>M1;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]<0){\\n                M1[abs(arr[i])]++;\\n            }else{\\n                M[arr[i]]++;\\n            }\\n        }\\n        for(auto it:M){\\n            int a=2*it.first;\\n            int b=it.second;\\n            if(M.find(a)==M.end()){\\n                return false;\\n            }else if(M[a]!=b){\\n               if(b>M[a])\\n                return false;\\n                else{\\n                    M[a]=M[a]-b;\\n                }\\n            }else{\\n                M.erase(a);\\n            }\\n        }\\n        for(auto it:M1){\\n            int a=2*it.first;\\n            int b=it.second;\\n            if(M1.find(a)==M1.end()){\\n                return false;\\n            }else if(M1[a]!=b){\\n                if(b>M1[a])\\n                return false;\\n                else{\\n                    M1[a]=M1[a]-b;\\n                }\\n            }else{\\n                M1.erase(a);\\n            }\\n        }\\n        return true;\\n```\\nwe can also do it using custom comperator",
                "solutionTags": [],
                "code": "```\\nmap<int,int>M;\\n        map<int,int>M1;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]<0){\\n                M1[abs(arr[i])]++;\\n            }else{\\n                M[arr[i]]++;\\n            }\\n        }\\n        for(auto it:M){\\n            int a=2*it.first;\\n            int b=it.second;\\n            if(M.find(a)==M.end()){\\n                return false;\\n            }else if(M[a]!=b){\\n               if(b>M[a])\\n                return false;\\n                else{\\n                    M[a]=M[a]-b;\\n                }\\n            }else{\\n                M.erase(a);\\n            }\\n        }\\n        for(auto it:M1){\\n            int a=2*it.first;\\n            int b=it.second;\\n            if(M1.find(a)==M1.end()){\\n                return false;\\n            }else if(M1[a]!=b){\\n                if(b>M1[a])\\n                return false;\\n                else{\\n                    M1[a]=M1[a]-b;\\n                }\\n            }else{\\n                M1.erase(a);\\n            }\\n        }\\n        return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1397678,
                "title": "java-solution-easy-explanation-for-beginners-using-sort-and-map",
                "content": "```\\nclass Solution {\\n    //the problem basically says that we need to have pairs,\\n    //where the value of 1 element in pair should be twice that of other element.\\n    \\n    //We can just create a map of frequency of occurence of elements in the array.\\n    //We check for each element in iteration, if there is an element twice of it.\\n    //If there is then we reduce the frequency of both by 1 since we have found a pair.\\n    //We also increment out count by 2.\\n\\n    //If we are able to form pairs across the array,\\n    //then the value of our count should be equal to the length of the array.\\n    public boolean canReorderDoubled(int[] arr) {\\n        //We need to sort array for cases like this - [1,2,1,-8,8,-4,4,-4,2,-2]\\n        //We can see that at index 1, we get 2 and we immediately remove 4 and 2 from map.\\n        //This will not work because, we have 1 in index = 2 that requires the 2 in index 1.\\n        //Hence, sorting becomes necessary to avoid such cases.\\n        Arrays.sort(arr);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int num : arr) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        //Handling case where the array might contain 0.\\n        //If it does then we need to have even number of zeroes.\\n        if(map.containsKey(0) && map.get(0) % 2 != 0) {\\n            return false;\\n        }\\n\\n        int count = 0;\\n\\n        for(int i = 0; i < arr.length; i++) {\\n            if(map.containsKey(arr[i]) && map.containsKey(2 * arr[i])) {\\n\\n                //Don\\'t consider elements with frequency as 0.\\n                if(map.get(arr[i]) == 0 || map.get(2*arr[i]) == 0) {\\n                    continue;\\n                }\\n                count += 2;\\n                map.put(arr[i], map.get(arr[i]) - 1);\\n                map.put(2*arr[i], map.get(2*arr[i]) - 1);\\n            }\\n        }\\n        return count == arr.length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //the problem basically says that we need to have pairs,\\n    //where the value of 1 element in pair should be twice that of other element.\\n    \\n    //We can just create a map of frequency of occurence of elements in the array.\\n    //We check for each element in iteration, if there is an element twice of it.\\n    //If there is then we reduce the frequency of both by 1 since we have found a pair.\\n    //We also increment out count by 2.\\n\\n    //If we are able to form pairs across the array,\\n    //then the value of our count should be equal to the length of the array.\\n    public boolean canReorderDoubled(int[] arr) {\\n        //We need to sort array for cases like this - [1,2,1,-8,8,-4,4,-4,2,-2]\\n        //We can see that at index 1, we get 2 and we immediately remove 4 and 2 from map.\\n        //This will not work because, we have 1 in index = 2 that requires the 2 in index 1.\\n        //Hence, sorting becomes necessary to avoid such cases.\\n        Arrays.sort(arr);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int num : arr) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        //Handling case where the array might contain 0.\\n        //If it does then we need to have even number of zeroes.\\n        if(map.containsKey(0) && map.get(0) % 2 != 0) {\\n            return false;\\n        }\\n\\n        int count = 0;\\n\\n        for(int i = 0; i < arr.length; i++) {\\n            if(map.containsKey(arr[i]) && map.containsKey(2 * arr[i])) {\\n\\n                //Don\\'t consider elements with frequency as 0.\\n                if(map.get(arr[i]) == 0 || map.get(2*arr[i]) == 0) {\\n                    continue;\\n                }\\n                count += 2;\\n                map.put(arr[i], map.get(arr[i]) - 1);\\n                map.put(2*arr[i], map.get(2*arr[i]) - 1);\\n            }\\n        }\\n        return count == arr.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397650,
                "title": "c-simple-and-easy-solution-using-hashmap",
                "content": "here is my c++ solution , upvote if this helps you in  any way!\\nfeel free to ask any doubts , even if it\\'s silly ! ill try my best help you out!\\n\\nomg ! i got an upvote and im literally very happy!\\n\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\nsort(arr.begin() , arr.end());\\nmap<int,int> m;\\nfor(int i=0 ; i<arr.size() ; i++)\\n       m[arr[i]]++;\\nfor(int i=0 ; i<arr.size() ; i++)\\n{\\n    if( m[arr[i]]>0 &&m[2*arr[i]]>0)\\n       {\\n        m[arr[i]]--;\\n        m[2*arr[i]]--;\\n    }\\n}\\nfor(auto i:m)\\n{\\n    if(i.second>0) return false;\\n}\\n        return true;\\n    }\\n};\\n```\\nplease do upvote , it\\'ll help me get through collage :",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\nsort(arr.begin() , arr.end());\\nmap<int,int> m;\\nfor(int i=0 ; i<arr.size() ; i++)\\n       m[arr[i]]++;\\nfor(int i=0 ; i<arr.size() ; i++)\\n{\\n    if( m[arr[i]]>0 &&m[2*arr[i]]>0)\\n       {\\n        m[arr[i]]--;\\n        m[2*arr[i]]--;\\n    }\\n}\\nfor(auto i:m)\\n{\\n    if(i.second>0) return false;\\n}\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203191,
                "title": "java-17ms-o-200000-without-sorting-but-with-explanation",
                "content": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] A) {\\n        int offset=100000;\\n\\t\\t// Count the frequency of each number\\n        int[] freq= new int[2*offset];\\n        for (int n: A) freq[n+offset]++;\\n\\t\\t\\n        // deal with \"0\", there must be even 0s in array\\n        if (freq[0]%2==1) return false;\\n\\t\\t\\n        // from -100000 to 100000\\n        for (int i=0; i<2*offset; i++){\\n            // if there\\'s no current number left, skip\\n            if (freq[i]==0) continue;\\n\\t\\t\\t\\n\\t\\t    // otherwise calculate current number and it\\'s pair number, then get their frequencies\\n            int cur= i-offset, next= cur<0?cur/2:cur*2;\\n            int curCnt= freq[i], nextCnt= freq[next+offset];\\n\\t\\t\\t\\n\\t\\t    // if not enough pair number left, return false\\n            if (nextCnt<curCnt) return false;\\n\\t\\t\\t\\n\\t\\t    // otherwise update the frequency of pair number\\n            freq[next+offset]=nextCnt-curCnt;\\n        }\\n        return true;\\n    }\\n}\\n```\\nThis is just a contest code, I would still suggest using TreeMap or PriorityQueue during the interview.\\nAnyway, happy coding!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] A) {\\n        int offset=100000;\\n\\t\\t// Count the frequency of each number\\n        int[] freq= new int[2*offset];\\n        for (int n: A) freq[n+offset]++;\\n\\t\\t\\n        // deal with \"0\", there must be even 0s in array\\n        if (freq[0]%2==1) return false;\\n\\t\\t\\n        // from -100000 to 100000\\n        for (int i=0; i<2*offset; i++){\\n            // if there\\'s no current number left, skip\\n            if (freq[i]==0) continue;\\n\\t\\t\\t\\n\\t\\t    // otherwise calculate current number and it\\'s pair number, then get their frequencies\\n            int cur= i-offset, next= cur<0?cur/2:cur*2;\\n            int curCnt= freq[i], nextCnt= freq[next+offset];\\n\\t\\t\\t\\n\\t\\t    // if not enough pair number left, return false\\n            if (nextCnt<curCnt) return false;\\n\\t\\t\\t\\n\\t\\t    // otherwise update the frequency of pair number\\n            freq[next+offset]=nextCnt-curCnt;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529311,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        unordered_map<int,int> mp;\\n        for(int i: arr) mp[i]++;\\n        vector<int> k;\\n        for(auto x: mp) k.push_back(x.first);\\n        sort(k.begin(),k.end(),[](int a, int b){\\n            return abs(a) < abs(b);\\n        });\\n        for(int x:k){\\n            if(mp[x] > mp[2*x]) return false;\\n            mp[2*x] -= mp[x];\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        freq = Counter(arr)\\n        pos = []\\n        neg = []\\n        zero = 0\\n        for k, v in freq.items():\\n            if k > 0:\\n                pos.append(k)\\n            elif k < 0:\\n                neg.append(k)\\n            else:\\n                zero = v\\n        if zero % 2 == 1:\\n            return False\\n        pos.sort()\\n        neg.sort(reverse=True)\\n        for x in pos:\\n            if freq[x] == 0:\\n                continue\\n            if 2 * x not in freq or freq[2 * x] < freq[x]:\\n                return False\\n            freq[2 * x] -= freq[x]\\n        for x in neg:\\n            if freq[x] == 0:\\n                continue\\n            if 2 * x not in freq or freq[2 * x] < freq[x]:\\n                return False\\n            freq[2 * x] -= freq[x]\\n        return True\\n```\\n\\n```Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        int [] plus = new int [100011];\\n        int [] minus = new int [100011];\\n        for (int i : arr) {\\n        \\tif (i>=0) {\\n        \\t\\tplus[i]++;\\n        \\t} else {\\n        \\t\\tminus[-i]++;\\n        \\t}\\n        }\\n        if (plus[0]%2!=0) return false;\\n        int res = arr.length-plus[0];\\n        for (int i = 1; i<plus.length/2; i++) {\\n        \\tif (plus[i]>0) {\\n        \\tplus[2*i]-=plus[i];\\n        \\tres-=plus[i]*2;\\n        \\tif (plus[2*i] <0) return false;\\n        \\tplus[i] = 0;\\n        \\t}\\n        }\\n        for (int i = 1; i<minus.length/2; i++) {\\n        \\tif (minus[i]>0) {\\n        \\tminus[2*i]-=minus[i];\\n        \\tres-=minus[i]*2;\\n        \\tif (minus[2*i] <0) return false;\\n        \\tminus[i] = 0;\\n        \\t}\\n        }\\n        if (res != 0) return false;\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        unordered_map<int,int> mp;\\n        for(int i: arr) mp[i]++;\\n        vector<int> k;\\n        for(auto x: mp) k.push_back(x.first);\\n        sort(k.begin(),k.end(),[](int a, int b){\\n            return abs(a) < abs(b);\\n        });\\n        for(int x:k){\\n            if(mp[x] > mp[2*x]) return false;\\n            mp[2*x] -= mp[x];\\n        }\\n        return true;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        freq = Counter(arr)\\n        pos = []\\n        neg = []\\n        zero = 0\\n        for k, v in freq.items():\\n            if k > 0:\\n                pos.append(k)\\n            elif k < 0:\\n                neg.append(k)\\n            else:\\n                zero = v\\n        if zero % 2 == 1:\\n            return False\\n        pos.sort()\\n        neg.sort(reverse=True)\\n        for x in pos:\\n            if freq[x] == 0:\\n                continue\\n            if 2 * x not in freq or freq[2 * x] < freq[x]:\\n                return False\\n            freq[2 * x] -= freq[x]\\n        for x in neg:\\n            if freq[x] == 0:\\n                continue\\n            if 2 * x not in freq or freq[2 * x] < freq[x]:\\n                return False\\n            freq[2 * x] -= freq[x]\\n        return True\\n```\n```Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        int [] plus = new int [100011];\\n        int [] minus = new int [100011];\\n        for (int i : arr) {\\n        \\tif (i>=0) {\\n        \\t\\tplus[i]++;\\n        \\t} else {\\n        \\t\\tminus[-i]++;\\n        \\t}\\n        }\\n        if (plus[0]%2!=0) return false;\\n        int res = arr.length-plus[0];\\n        for (int i = 1; i<plus.length/2; i++) {\\n        \\tif (plus[i]>0) {\\n        \\tplus[2*i]-=plus[i];\\n        \\tres-=plus[i]*2;\\n        \\tif (plus[2*i] <0) return false;\\n        \\tplus[i] = 0;\\n        \\t}\\n        }\\n        for (int i = 1; i<minus.length/2; i++) {\\n        \\tif (minus[i]>0) {\\n        \\tminus[2*i]-=minus[i];\\n        \\tres-=minus[i]*2;\\n        \\tif (minus[2*i] <0) return false;\\n        \\tminus[i] = 0;\\n        \\t}\\n        }\\n        if (res != 0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130285,
                "title": "c-solution-using-map-and-sorting",
                "content": "# Algorithm\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the vector based on the absolute values.\\n2. Count the frequency of each element and store it in the map.\\n3. Iterate over the vector.\\n    a. If count of *arr[i]* is greater than zero and count of *arr[i]\\\\*2* is greater than zero then decrement the count of both *arr[i]* and *arr[i]\\\\*2*.\\n    b. Else return false.\\n4. return true;\\n\\n# Complexity\\n- Time complexity: O(Nlog(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(int &a, int &b){\\n        return abs(a) < abs(b);\\n    }\\n    bool canReorderDoubled(vector<int>& arr) {\\n        int n = arr.size();\\n        sort(arr.begin(),arr.end(),cmp);\\n        map<int,int> freq;\\n        for(int i=0;i<n;i++){      \\n            freq[arr[i]]++;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            if(freq[arr[i]] > 0){\\n                int val = arr[i]*2;\\n                if(freq[val] > 0){\\n                    freq[val]--;\\n                    freq[arr[i]]--;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(int &a, int &b){\\n        return abs(a) < abs(b);\\n    }\\n    bool canReorderDoubled(vector<int>& arr) {\\n        int n = arr.size();\\n        sort(arr.begin(),arr.end(),cmp);\\n        map<int,int> freq;\\n        for(int i=0;i<n;i++){      \\n            freq[arr[i]]++;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            if(freq[arr[i]] > 0){\\n                int val = arr[i]*2;\\n                if(freq[val] > 0){\\n                    freq[val]--;\\n                    freq[arr[i]]--;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860817,
                "title": "java-treemap-short-and-simple",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        Map<Integer, Integer> map = new TreeMap<>();\\n\\n        for (int n : arr) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n\\n        for (int n : map.keySet()) {\\n            if (map.get(n) > 0) {\\n                if (n < 0 && n % 2 != 0) return false;\\n\\n                int target = n < 0 ? n / 2 : n * 2;\\n\\n                if (map.get(n) > map.getOrDefault(target, 0)) {\\n                    return false;\\n                }\\n\\n                map.put(target, map.get(target) - map.get(n));\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n * logn), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        Map<Integer, Integer> map = new TreeMap<>();\\n\\n        for (int n : arr) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n\\n        for (int n : map.keySet()) {\\n            if (map.get(n) > 0) {\\n                if (n < 0 && n % 2 != 0) return false;\\n\\n                int target = n < 0 ? n / 2 : n * 2;\\n\\n                if (map.get(n) > map.getOrDefault(target, 0)) {\\n                    return false;\\n                }\\n\\n                map.put(target, map.get(target) - map.get(n));\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n * logn), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612536,
                "title": "c-using-map-and-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        sort(arr.begin(), arr.end(),[](int &a, int &b)\\n             {\\n                 return abs(a) < abs(b);\\n             });\\n        for(int n : arr)\\n        {\\n            m[n]++;\\n        }\\n        \\n        for(int n : arr)\\n        {\\n            if(m[n] <= 0) continue;\\n            m[n]--;\\n            if(m[2*n] > 0)\\n            {\\n                m[2*n]--;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        sort(arr.begin(), arr.end(),[](int &a, int &b)\\n             {\\n                 return abs(a) < abs(b);\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1896964,
                "title": "c-hashing-sorting-easy-to-understand-solution",
                "content": "```\\nbool canReorderDoubled(vector<int>& arr) {\\n        int n = arr.size();\\n        // int tot = n/2;\\n        // int count=0;\\n        unordered_map<int,int> mp;\\n        for(auto it : arr){\\n            mp[it]++;\\n        }\\n        // unordered_map<int,int> :: iterator p;\\n        sort(arr.begin(),arr.end());\\n        for(auto it : arr){\\n            if(!mp[it]) continue;\\n            mp[it]--;\\n            int val = 2*it;\\n            if(it<0 and it%2==0) val=it/2;\\n            if(!mp[val]) return false;\\n            mp[val]--;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool canReorderDoubled(vector<int>& arr) {\\n        int n = arr.size();\\n        // int tot = n/2;\\n        // int count=0;\\n        unordered_map<int,int> mp;\\n        for(auto it : arr){\\n            mp[it]++;\\n        }\\n        // unordered_map<int,int> :: iterator p;\\n        sort(arr.begin(),arr.end());\\n        for(auto it : arr){\\n            if(!mp[it]) continue;\\n            mp[it]--;\\n            int val = 2*it;\\n            if(it<0 and it%2==0) val=it/2;\\n            if(!mp[val]) return false;\\n            mp[val]--;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1682686,
                "title": "java-hashmap-solution-o-n-klogk",
                "content": "Time complexity : O(N + KlogK) where N : no of elements in array and K : unique keys in array. Comment and correct if you find anything wrong.\\n```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        \\n        Map<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int x : arr) {\\n            map.put(x, map.getOrDefault(x,0) +1);\\n        }\\n        List<Integer> keys = new ArrayList<>(map.keySet());\\n        \\n        Collections.sort(keys, Comparator.comparing(x -> Math.abs(x)));\\n        \\n        for(int k : keys) {\\n            int x = map.get(k);\\n            if(x == 0) continue;\\n            if(x > map.getOrDefault(k+k,0)) return false;\\n            map.put(k+k, map.get(k+k)-x);\\n        }\\n        return true;\\n    }\\n}****\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        \\n        Map<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int x : arr) {\\n            map.put(x, map.getOrDefault(x,0) +1);\\n        }\\n        List<Integer> keys = new ArrayList<>(map.keySet());\\n        \\n        Collections.sort(keys, Comparator.comparing(x -> Math.abs(x)));\\n        \\n        for(int k : keys) {\\n            int x = map.get(k);\\n            if(x == 0) continue;\\n            if(x > map.getOrDefault(k+k,0)) return false;\\n            map.put(k+k, map.get(k+k)-x);\\n        }\\n        return true;\\n    }\\n}****\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409141,
                "title": "java-clean-concise-optimal-code-greedy-technique-o-n-log-n-time",
                "content": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        \\n        Arrays.sort (arr);\\n        boolean[] visited = new boolean[arr.length];\\n        \\n        for (int i = 0, j = 1; i < arr.length; i++) {\\n            if (visited[i]) {\\n                continue;\\n            }\\n            \\n            while (j < arr.length && 2 * arr[i] != arr[j] && arr[i] != 2 * arr[j]) {\\n                j++;\\n            }\\n            \\n            if (j == arr.length) {\\n                return false;\\n            }\\n            \\n            visited[j++] = true;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        \\n        Arrays.sort (arr);\\n        boolean[] visited = new boolean[arr.length];\\n        \\n        for (int i = 0, j = 1; i < arr.length; i++) {\\n            if (visited[i]) {\\n                continue;\\n            }\\n            \\n            while (j < arr.length && 2 * arr[i] != arr[j] && arr[i] != 2 * arr[j]) {\\n                j++;\\n            }\\n            \\n            if (j == arr.length) {\\n                return false;\\n            }\\n            \\n            visited[j++] = true;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397889,
                "title": "c-o-nlog-n-step-by-step-detailed-explanation-short-concise-code-greedy-sorting-hashmap",
                "content": "What the Question means to say is that: \\nwe have to make n/2 pairs using the n numbers such that in each pair one number is double of the other. \\ni.e. of the n numbers (given **n is even**), we have to make n/2 pairs of form  (x, 2x) where x and 2x are numbers from arr. \\nPS: 2x means The number \"2x\" is 2 times the number \"x\".\\n\\nFirst we have to sort the array in a way such that smaller **absolute** values come first and bigger absolute values later. This is done because the middle the value the more chances it has of being both the smaller one (x) or bigger one (2x) in the pair (x, 2x).  Whereas the smaller the values the more they are restricted to be x only. \\nEg:  -2 , 1, 4,-1,  -4, 2\\nIn this if we have to make pairs of form (x,2x) \\n2 and -2 can be:\\nat x:                  like  (2, 4) and (-2, 4) \\nand at 2x too:  like (1,2) and (-1, -2) \\nWhereas 1, -1 can be at x only.\\nSo, we **\"greedily\"** take the smaller absolute values first and find 2x (double) for them. If we are able to find such 2x, we can fix that (x, 2x) as one pair.\\nThe sorting can be done by passing a custom comparator function to stl: sort as third argument like this:\\n\\n```sort(arr.begin(), arr.end(), comp); ```\\n\\nand the custom comparator function looks like this:\\n```   \\nstatic bool comp(int a, int b){\\n        return abs(a)<abs(b);    \\n    }\\n```\\n\\nAfter this we have our array arranged like this: -1, 1, -2,2, -4,4.....\\n\\nNow, we make a frequency hashtable of all the numbers in arr. This is done to keep track of the numbers i.e. if they are already used to form a pair or not.\\nThe frequency hashtable can be made simply in 2 lines like this:\\n```\\nunordered_map<int, int> count; \\nfor(int a: arr) count[a]++;\\n```\\n\\nNow we iterate through each and every element x in arr and see if 2x exists or not. Specifically we will see the frequency of 2x if it is >0 coz even if 2x was present but was already used by some previous number and now frequency is 0 in map then the fact is we cannot form pair for x now. If by anycase we find that we aren\\'t able to find 2x for a particular x, we can *return false* at the very instant. Because to form n/2 pairs each and every number should be the in a pair. \\n```\\nif(count[2*a]==0) return false;\\n```\\n\\nAnd if we find 2x with non zero freq (i.e. >0 ) freq in our hashtable then we can form a pair of this x , 2x. But now we cannot use this particular x and 2x again later so decrease their freq from hashtable by 1:\\n```\\ncount[a]--;\\ncount[2*a]--;\\n```\\n\\nSince we are using up some 2x for some x that came earlier, When we pass through those 2x in our *for loop* later , they won\\'t be there (they\\'ve already form a pair) so there\\'s no point in finding the double for them. So in our for loop in beginning only we would check the freq of x in our hashtable like this:\\n```\\nif(count[a]==0) continue;\\n```\\nWe would simply continue to the next element in array if the current element has 0 freq in our hashtable (meaning it is already part of a pair)\\n\\nAnd if we are able to complete this for loop for each and every element in arr. Means every element is a part of a pair and we have successfully made n/2 pairs such that one element is twice of other in every pair.\\nWe can simply return true now.\\n\\nFull Code:\\n\\n```\\nclass Solution {\\npublic:\\n    static bool comp(int a, int b){\\n        return abs(a)<abs(b);    \\n    }\\n    \\n    bool canReorderDoubled(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), comp);     \\n        int n=arr.size();\\n        unordered_map<int, int> count; \\n        for(int a: arr) count[a]++;\\n        for(int a: arr){\\n            if(count[a]==0) continue;\\n            if(count[2*a]==0) return false;\\n            count[a]--;\\n            count[2*a]--;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**Complexity Analysis:**\\nInitially we are sorting our array, The sorting using STL takes O(Nlog(N)) time.\\nAfter that we have two for loops which take O(N) time each.\\nSo, Overally Time Complexity:  O(Nlog(N)) + O(N) + O(N)  =  O(Nlog(N))\\nSo, the overally time complexity of our code is **O(Nlog(N))**\\n\\nSpace Complexity: Only extra space that we have used is the hashtable (unordered_map) that we have used (considering the sorting uses O(1) extra space). The hashtable can have at max n elements.\\nSo, the overall space complexity of our code is **O(N)**\\n\\n```\\nTC: O(N log(N))\\nSC: O(N)\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```sort(arr.begin(), arr.end(), comp); ```\n```   \\nstatic bool comp(int a, int b){\\n        return abs(a)<abs(b);    \\n    }\\n```\n```\\nunordered_map<int, int> count; \\nfor(int a: arr) count[a]++;\\n```\n```\\nif(count[2*a]==0) return false;\\n```\n```\\ncount[a]--;\\ncount[2*a]--;\\n```\n```\\nif(count[a]==0) continue;\\n```\n```\\nclass Solution {\\npublic:\\n    static bool comp(int a, int b){\\n        return abs(a)<abs(b);    \\n    }\\n    \\n    bool canReorderDoubled(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), comp);     \\n        int n=arr.size();\\n        unordered_map<int, int> count; \\n        for(int a: arr) count[a]++;\\n        for(int a: arr){\\n            if(count[a]==0) continue;\\n            if(count[2*a]==0) return false;\\n            count[a]--;\\n            count[2*a]--;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nTC: O(N log(N))\\nSC: O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397384,
                "title": "java-simple-solution-with-sorting-in-o-nlogn",
                "content": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        Arrays.sort(arr);\\n        for(int i=0; i<arr.length; i++)\\n            map.put(arr[i], map.getOrDefault(arr[i], 0)+1);\\n        \\n        if(map.get(0)!=null && map.get(0)%2!=0)\\n            return false;\\n        \\n        int count = map.getOrDefault(0, 0);\\n        map.put(0, 0);\\n        for(int i=arr.length-1; i>=0; i--) {\\n            Integer t1 = map.get(arr[i]);\\n            Integer t2 = map.get(arr[i]*2);\\n            if(t1!=null && t2!=null){\\n                //System.out.println(arr[i]+\" \"+(arr[i]*2));\\n                if(t1==0 || t2==0)\\n                    continue;\\n                map.put(arr[i], t1-1);\\n                map.put(arr[i]*2, t2-1);\\n                count+=2;\\n            }\\n        }\\n    \\n        return count==arr.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        Arrays.sort(arr);\\n        for(int i=0; i<arr.length; i++)\\n            map.put(arr[i], map.getOrDefault(arr[i], 0)+1);\\n        \\n        if(map.get(0)!=null && map.get(0)%2!=0)\\n            return false;\\n        \\n        int count = map.getOrDefault(0, 0);\\n        map.put(0, 0);\\n        for(int i=arr.length-1; i>=0; i--) {\\n            Integer t1 = map.get(arr[i]);\\n            Integer t2 = map.get(arr[i]*2);\\n            if(t1!=null && t2!=null){\\n                //System.out.println(arr[i]+\" \"+(arr[i]*2));\\n                if(t1==0 || t2==0)\\n                    continue;\\n                map.put(arr[i], t1-1);\\n                map.put(arr[i]*2, t2-1);\\n                count+=2;\\n            }\\n        }\\n    \\n        return count==arr.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397236,
                "title": "fast-easy-solution-with-queue-no-map-99",
                "content": "* sort and iterate the array, use the \"needed\" queue to verify the counterpart value exists later in the array\\n* for positive values: the first encountered value has to be the smaller of the pair - put its 2x counterpart in the queue\\n* for negative values: the first encountered value has to be the doubled one - put its /2 counterpart in the queue \\n```\\npublic boolean canReorderDoubled(int[] arr) {\\n\\tArrays.sort(arr);\\n\\tLinkedList<Integer> q= new LinkedList<>();\\n\\tfor(int elt:arr){\\n\\t\\tif(!q.isEmpty() && elt==q.getFirst()) q.removeFirst();\\n\\t\\telse if(elt<0){\\n\\t\\t\\tif(elt%2!=0) return false;  // quit early e.g. [-5,-2]\\n\\t\\t\\tq.addLast(elt/2);\\n\\t\\t}else q.addLast(elt*2);\\n\\t}\\n\\treturn q.isEmpty();\\n}",
                "solutionTags": [],
                "code": "* sort and iterate the array, use the \"needed\" queue to verify the counterpart value exists later in the array\\n* for positive values: the first encountered value has to be the smaller of the pair - put its 2x counterpart in the queue\\n* for negative values: the first encountered value has to be the doubled one - put its /2 counterpart in the queue \\n```\\npublic boolean canReorderDoubled(int[] arr) {\\n\\tArrays.sort(arr);\\n\\tLinkedList<Integer> q= new LinkedList<>();\\n\\tfor(int elt:arr){\\n\\t\\tif(!q.isEmpty() && elt==q.getFirst()) q.removeFirst();\\n\\t\\telse if(elt<0){\\n\\t\\t\\tif(elt%2!=0) return false;  // quit early e.g. [-5,-2]\\n\\t\\t\\tq.addLast(elt/2);\\n\\t\\t}else q.addLast(elt*2);\\n\\t}\\n\\treturn q.isEmpty();\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1397186,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        if(arr.length==0) return true;\\n        \\n        HashMap<Integer, Integer> freqMap = new HashMap<>();\\n        \\n        for(int elem: arr)\\n            freqMap.put(elem, freqMap.getOrDefault(elem, 0) + 1);\\n        \\n        // now we have to sort the array with absolute value,\\n        // so that i can always look for the double element in map\\n        // for that we need to convert this primitive type array into\\n        // Integer type array to use lamda function\\n        \\n        Integer[] ar = new Integer[arr.length];\\n        \\n        for(int i=0; i<arr.length; i++)\\n            ar[i] = arr[i];\\n        \\n        // sorting the array with lambda function\\n        \\n        Arrays.sort(ar, (a,b)->{\\n            return Math.abs(a)-Math.abs(b);\\n        });\\n        \\n        for(Integer elem: ar){\\n            // if elements freq is 0, then no need to look for its double\\n            if(freqMap.get(elem)==0) continue;\\n            \\n            //looking for double\\n            if(freqMap.getOrDefault(2*elem, 0)==0) return false;\\n            \\n            freqMap.put(elem, freqMap.get(elem) - 1);\\n            freqMap.put(2*elem, freqMap.get(2*elem) - 1);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        if(arr.length==0) return true;\\n        \\n        HashMap<Integer, Integer> freqMap = new HashMap<>();\\n        \\n        for(int elem: arr)\\n            freqMap.put(elem, freqMap.getOrDefault(elem, 0) + 1);\\n        \\n        // now we have to sort the array with absolute value,\\n        // so that i can always look for the double element in map\\n        // for that we need to convert this primitive type array into\\n        // Integer type array to use lamda function\\n        \\n        Integer[] ar = new Integer[arr.length];\\n        \\n        for(int i=0; i<arr.length; i++)\\n            ar[i] = arr[i];\\n        \\n        // sorting the array with lambda function\\n        \\n        Arrays.sort(ar, (a,b)->{\\n            return Math.abs(a)-Math.abs(b);\\n        });\\n        \\n        for(Integer elem: ar){\\n            // if elements freq is 0, then no need to look for its double\\n            if(freqMap.get(elem)==0) continue;\\n            \\n            //looking for double\\n            if(freqMap.getOrDefault(2*elem, 0)==0) return false;\\n            \\n            freqMap.put(elem, freqMap.get(elem) - 1);\\n            freqMap.put(2*elem, freqMap.get(2*elem) - 1);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397082,
                "title": "c-simple-easy-to-understand-multiset-solution",
                "content": "Explanation:\\nstart from the smallest and we try to find arr[i] or  arr[i]/2 each turn.\\nif not found, insert it into multiset otherwise remove it from multiset.\\n\\nCode:\\n```\\n bool canReorderDoubled(vector<int>& arr) {\\n       \\n        sort(begin(arr), end(arr));\\n        multiset<int> s;\\n        for(int i = 0; i<arr.size();i++){\\n         auto it = s.find(2 * arr[i]);\\n            if(it == s.end() && arr[i]%2 == 0)\\n                it = s.find(arr[i] / 2);\\n            if(it == s.end())\\n                s.insert(arr[i]);\\n            else\\n                s.erase(it);\\n        }\\n       \\n        \\n        return s.empty() == true;\\n\\t}\\n\\t\\n\\tupvote plz!!",
                "solutionTags": [],
                "code": "Explanation:\\nstart from the smallest and we try to find arr[i] or  arr[i]/2 each turn.\\nif not found, insert it into multiset otherwise remove it from multiset.\\n\\nCode:\\n```\\n bool canReorderDoubled(vector<int>& arr) {\\n       \\n        sort(begin(arr), end(arr));\\n        multiset<int> s;\\n        for(int i = 0; i<arr.size();i++){\\n         auto it = s.find(2 * arr[i]);\\n            if(it == s.end() && arr[i]%2 == 0)\\n                it = s.find(arr[i] / 2);\\n            if(it == s.end())\\n                s.insert(arr[i]);\\n            else\\n                s.erase(it);\\n        }\\n       \\n        \\n        return s.empty() == true;\\n\\t}\\n\\t\\n\\tupvote plz!!",
                "codeTag": "Unknown"
            },
            {
                "id": 1396885,
                "title": "rust-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn can_reorder_doubled(arr: Vec<i32>) -> bool {\\n        let mut hm = HashMap::new();\\n        for &a in &arr {\\n            *hm.entry(a).or_insert(0) += 1;\\n        }\\n        let mut v = hm.keys().cloned().collect::<Vec<_>>();\\n        v.sort_unstable_by_key(|k| k.abs());\\n        for k in &v {\\n            let n1 = *hm.get(k).unwrap();\\n            if n1 > 0 {\\n                if let Some(n2) = hm.get_mut(&(k * 2)) {\\n                    *n2 -= n1;\\n                    if *n2 < 0 {\\n                        return false;\\n                    }\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn can_reorder_doubled(arr: Vec<i32>) -> bool {\\n        let mut hm = HashMap::new();\\n        for &a in &arr {\\n            *hm.entry(a).or_insert(0) += 1;\\n        }\\n        let mut v = hm.keys().cloned().collect::<Vec<_>>();\\n        v.sort_unstable_by_key(|k| k.abs());\\n        for k in &v {\\n            let n1 = *hm.get(k).unwrap();\\n            if n1 > 0 {\\n                if let Some(n2) = hm.get_mut(&(k * 2)) {\\n                    *n2 -= n1;\\n                    if *n2 < 0 {\\n                        return false;\\n                    }\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1396875,
                "title": "official-solution-logic-explained-in-detail-complexity-analysis",
                "content": "***LOGIC***\\n(1) Since the question itself suggests reordering, we can assume that the order of the elements is not important. Thus, we can **sort**.\\n\\n(2) There can be multiple non-unique elements. Consider a case `1 2 4 2` -(sort)-> `1 2 2 4`. The answer is `True`. One `1` maps to `2`, and consequently, both get *consumed*. The remaining `2` can them map onto `4`. Easy!\\n\\nWe can thus store each of the element\\'s **counts**, and decrement both of them as they get *consumed*.\\n\\nNOTE: In case a number exists, `x`, for which `2x` does not exist in greater quantity, we can return early. Basically, there are lots of `1`s to satisfy, but not enough `2`s. Like in the case `1 1 1 2`. \\n\\nThe case of #`2x`s > #`x`s is still *allowed* - in hopes that those remaining `2x`s can still map onto `4x`s. This logic can continue on and on. [1]\\n\\n**Summary**:\\n- Create a dictionary of `{element: quantity_of_the_element}`\\n- Sort them\\n- Iterate over the elements one by one\\n    - if the `count[x] > count[2x]`, return False early.\\n    - else, `count[2x]-=count[x]` and keep going [2]\\n\\n***IMPLEMENTATION***\\nOne last thing: Negative numbers are messy while sorting. We can consider their `abs` values to make life easier. This still allows for the above logic to hold.\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        c = Counter(arr)\\n        for x in sorted(c, key=abs):\\n            if c[x] > c[2 * x]:\\n                return False\\n            c[2 * x] -= c[x]\\n        return True\\n```\\n\\n***COMPLEXITY ANALYSIS***\\nTime: `O(N + KlogK)`. `O(N)` for `Counter` and `O(KlogK)` for `K` elements in the dict, which may/not be `N`.\\nSpace: `O(N)` for `Counter`.\\n\\n***FOOTNOTES***\\n[1] Take `x=1` and look at `1 2 4 2` if you are still confused.\\n[2] `count[2x]` gets consumed with `count[x]`. No need to reduce `count[x]` since it has already been iterated over!\\n\\n**Upvote this if you found it helpful :D**",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        c = Counter(arr)\\n        for x in sorted(c, key=abs):\\n            if c[x] > c[2 * x]:\\n                return False\\n            c[2 * x] -= c[x]\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396854,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n         sort(arr.begin(),arr.end());\\n        map<int,int>m;\\n        for(auto i=0;i<arr.size();i++){\\n            m[arr[i]]++;\\n        }\\n        for(auto i:arr){\\n            if(m[i*2] && m[i]){\\n                m[i]--;\\n                m[2*i]--;\\n            }\\n\\n        }\\n        for(auto i:arr){\\n            if(m[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n         sort(arr.begin(),arr.end());\\n        map<int,int>m;\\n        for(auto i=0;i<arr.size();i++){\\n            m[arr[i]]++;\\n        }\\n        for(auto i:arr){\\n            if(m[i*2] && m[i]){\\n                m[i]--;\\n                m[2*i]--;\\n            }\\n\\n        }\\n        for(auto i:arr){\\n            if(m[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396783,
                "title": "easy-explanation-with-code-c",
                "content": "**Approach**:\\n1. Sort the array on the basis of its absolute values.\\nExample - ```[4,-2,2,-4]``` becomes ```[-2,2,-4,4]```.\\n2. Store the frequency of each element in a map.\\n3. Iterate over the array, and check if there is any element with value twice of it (as it will fulfill our requirement.)\\n4. If we get success in above step, we continue our operation, and decrease the frequencies by one.\\n5. If we dont get success, we simply return false.\\n6. The below code will make it more clear.\\n\\n*Please upvote if it\\'s helpful : )*\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& a) \\n    {\\n        int n = a.size();\\n        unordered_map<int, int> m;\\n        sort(a.begin(), a.end(), [&](int x, int y)  // step 1\\n             {\\n                 return abs(x) < abs(y);\\n             });\\n        \\n        for(int i=0;i<n;i++)\\n            m[a[i]]++;  // step 2\\n        \\n        for(int i=0;i<n;i++)  // step 3\\n        {\\n            if(m[a[i]] == 0)\\n                continue;\\n            \\n            if(m[2*a[i]] == 0)\\n                return 0;  // step 5\\n            \\n            m[a[i]]--;  // step 4\\n            m[2*a[i]]--;  // step 4\\n        }\\n        \\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```[4,-2,2,-4]```\n```[-2,2,-4,4]```\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& a) \\n    {\\n        int n = a.size();\\n        unordered_map<int, int> m;\\n        sort(a.begin(), a.end(), [&](int x, int y)  // step 1\\n             {\\n                 return abs(x) < abs(y);\\n             });\\n        \\n        for(int i=0;i<n;i++)\\n            m[a[i]]++;  // step 2\\n        \\n        for(int i=0;i<n;i++)  // step 3\\n        {\\n            if(m[a[i]] == 0)\\n                continue;\\n            \\n            if(m[2*a[i]] == 0)\\n                return 0;  // step 5\\n            \\n            m[a[i]]--;  // step 4\\n            m[2*a[i]]--;  // step 4\\n        }\\n        \\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015831,
                "title": "c-map-solution-faster-than-100-80ms",
                "content": "![image](https://assets.leetcode.com/users/images/e302727a-977d-4354-9253-4df8736598cc_1610598357.7909095.png)\\n\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& a) {\\n        map<int,int> m;\\n        for(int x:a) m[x]++;\\n        for(auto i:m)\\n        {\\n            int x=i.first;\\n            if(m[x])\\n            {\\n                if(x<0){\\n                    if(x&1) return false;\\n                    if(m[x/2]<m[x]) return false;\\n                    m[x/2]-=m[x];\\n                }\\n                else{\\n                    if(m[2*x]<m[x]) return false;\\n                    m[2*x]-=m[x];\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& a) {\\n        map<int,int> m;\\n        for(int x:a) m[x]++;\\n        for(auto i:m)\\n        {\\n            int x=i.first;\\n            if(m[x])\\n            {\\n                if(x<0){\\n                    if(x&1) return false;\\n                    if(m[x/2]<m[x]) return false;\\n                    m[x/2]-=m[x];\\n                }\\n                else{\\n                    if(m[2*x]<m[x]) return false;\\n                    m[2*x]-=m[x];\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 715792,
                "title": "python3-counter-array-of-doubled-pairs",
                "content": "```\\nclass Solution:\\n    def canReorderDoubled(self, A: List[int]) -> bool:\\n        c = Counter(A)\\n        for n in sorted(c.keys(), key=abs):\\n            while c[n] > 0 and c[(double := 2 * n)] > 0:\\n                c[n] -= 1\\n                c[double] -= 1\\n        return all(not v for v in c.values())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canReorderDoubled(self, A: List[int]) -> bool:\\n        c = Counter(A)\\n        for n in sorted(c.keys(), key=abs):\\n            while c[n] > 0 and c[(double := 2 * n)] > 0:\\n                c[n] -= 1\\n                c[double] -= 1\\n        return all(not v for v in c.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342168,
                "title": "c-concise-beats-96-time",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& A) {\\n        map<int, int> m;\\n        for(int x: A) m[x]++;\\n        for(auto &p: m) {\\n            int x = p.first;\\n            if(m[x]) {\\n                if(x < 0) {\\n                    if((x & 1) || m[x/2] < m[x]) return false;\\n                    m[x/2] -= m[x];                      \\n                }\\n                else {\\n                    if(m[2*x] < m[x]) return false;\\n                    m[2*x] -= m[x]; \\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& A) {\\n        map<int, int> m;\\n        for(int x: A) m[x]++;\\n        for(auto &p: m) {\\n            int x = p.first;\\n            if(m[x]) {\\n                if(x < 0) {\\n                    if((x & 1) || m[x/2] < m[x]) return false;\\n                    m[x/2] -= m[x];                      \\n                }\\n                else {\\n                    if(m[2*x] < m[x]) return false;\\n                    m[2*x] -= m[x]; \\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299697,
                "title": "cpp-8-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& A) {\\n        unordered_map<int, int> m;\\n        for(auto it : A)\\n            m[it]++;\\n        sort(A.begin(), A.end());\\n        for(auto it : A){\\n            if(!m[it]) continue;\\n            int val = it < 0 ? it / 2 : it * 2;\\n            if(!m[val]) return false;\\n            else m[val]--;\\n            m[it]--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& A) {\\n        unordered_map<int, int> m;\\n        for(auto it : A)\\n            m[it]++;\\n        sort(A.begin(), A.end());\\n        for(auto it : A){\\n            if(!m[it]) continue;\\n            int val = it < 0 ? it / 2 : it * 2;\\n            if(!m[val]) return false;\\n            else m[val]--;\\n            m[it]--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203423,
                "title": "954-array-of-doubled-pairs-c-unordered-map-and-heap",
                "content": "Explanation comes later...\\n\\n    class Solution {\\n\\tpublic:\\n\\t\\tbool canReorderDoubled(vector<int>& A) {\\n\\t\\t\\tunordered_map<int, int> mp;\\n\\t\\t\\tpriority_queue<int> q;\\n\\t\\t\\tfor(auto a : A) {mp[a]++; q.push(a);}\\n\\t\\t\\twhile(q.size()){\\n\\t\\t\\t\\tint num = q.top(); q.pop();\\n\\t\\t\\t\\tif(mp[num] <= 0) continue;\\n\\t\\t\\t\\tmp[num]--;\\n\\t\\t\\t\\tif(num >= 0 && num % 2 == 0 && mp.find(num/2) != mp.end() && mp[num/2] > 0){\\n\\t\\t\\t\\t\\tmp[num/2]--;\\n\\t\\t\\t\\t}else if(num < 0 && mp.find(num*2) != mp.end() && mp[num*2] > 0){\\n\\t\\t\\t\\t\\tmp[num*2]--;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool canReorderDoubled(vector<int>& A) {\\n\\t\\t\\tunordered_map<int, int> mp;\\n\\t\\t\\tpriority_queue<int> q;\\n\\t\\t\\tfor(auto a : A) {mp[a]++; q.push(a);}",
                "codeTag": "Java"
            },
            {
                "id": 203348,
                "title": "easy-understand-java-solution",
                "content": "1) i.e. `[-4, -2]`, -4 / 2 = -2. Update the count HashMap for both `-4` and `-2`. If you cannot find the other number `-2` paired with the current number `-4`, return false;\\n2) i.e. `[2, 4]`, 2 * 2 = 4. Update the count HashMap for both `2` and `4`. If you cannot find the other number `2` paired with the current number `4`, return false;\\n\\nBecause we will start from the smallest number, `sort` the whole array first.\\nVersion 1:\\n```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] A) {\\n        Arrays.sort(A);\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int num : A) {\\n            count.put(num, count.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        for (int num : A) {\\n            if (count.get(num) == 0) continue;\\n            if (num < 0) {\\n                if (num % 2 != 0) return false;\\n                int pairedCount = count.getOrDefault(num / 2, 0);         //Check the # of paired number;\\n                if (count.get(num) > pairedCount) return false;           //The number cannot match;\\n                count.put(num / 2, count.get(num / 2) - count.get(num));  //Update count HashMap;\\n            } else {\\n                int pairedCount = count.getOrDefault(num * 2, 0);\\n                if (count.get(num) > pairedCount) return false;\\n                count.put(num * 2, count.get(num * 2) - count.get(num));\\n            }\\n            count.put(num, 0);\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n\\nVersion 2: Sort array `[-4,2,4,-2]` to `[-2,-4,2,4]`\\n```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] A) {\\n        Integer[] nums = new Integer[A.length];\\n        Map<Integer, Integer> count = new HashMap<>();\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            nums[i] = A[i];\\n            count.put(A[i], count.getOrDefault(A[i], 0) + 1);\\n        }\\n        \\n        Arrays.sort(nums, new Comparator<Integer>() {\\n            public int compare(Integer a, Integer b) {\\n                if (a < 0 && b < 0) {\\n                    return b - a;\\n                }\\n                return a - b;\\n            }\\n        });\\n        \\n        for (int num : nums) {\\n            if (count.get(num) == 0) continue;\\n            int pairedCount = count.getOrDefault(num * 2, 0);\\n            if (count.get(num) > pairedCount) return false;\\n            \\n            count.put(num * 2, count.get(num * 2) - count.get(num));\\n            count.put(num, 0);\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] A) {\\n        Arrays.sort(A);\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int num : A) {\\n            count.put(num, count.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        for (int num : A) {\\n            if (count.get(num) == 0) continue;\\n            if (num < 0) {\\n                if (num % 2 != 0) return false;\\n                int pairedCount = count.getOrDefault(num / 2, 0);         //Check the # of paired number;\\n                if (count.get(num) > pairedCount) return false;           //The number cannot match;\\n                count.put(num / 2, count.get(num / 2) - count.get(num));  //Update count HashMap;\\n            } else {\\n                int pairedCount = count.getOrDefault(num * 2, 0);\\n                if (count.get(num) > pairedCount) return false;\\n                count.put(num * 2, count.get(num * 2) - count.get(num));\\n            }\\n            count.put(num, 0);\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] A) {\\n        Integer[] nums = new Integer[A.length];\\n        Map<Integer, Integer> count = new HashMap<>();\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            nums[i] = A[i];\\n            count.put(A[i], count.getOrDefault(A[i], 0) + 1);\\n        }\\n        \\n        Arrays.sort(nums, new Comparator<Integer>() {\\n            public int compare(Integer a, Integer b) {\\n                if (a < 0 && b < 0) {\\n                    return b - a;\\n                }\\n                return a - b;\\n            }\\n        });\\n        \\n        for (int num : nums) {\\n            if (count.get(num) == 0) continue;\\n            int pairedCount = count.getOrDefault(num * 2, 0);\\n            if (count.get(num) > pairedCount) return false;\\n            \\n            count.put(num * 2, count.get(num * 2) - count.get(num));\\n            count.put(num, 0);\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073177,
                "title": "best-java-solution-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // taken help\\n    public boolean canReorderDoubled(int[] arr) {\\n\\n        Map<Integer, Integer> count = new TreeMap<>();\\n        for (int a : arr)\\n            count.put(a, count.getOrDefault(a, 0) + 1);\\n        for (int x : count.keySet()) {\\n            if (count.get(x) == 0) continue;\\n            int want = x < 0 ? x / 2 : x * 2;\\n            if (x < 0 && x % 2 != 0 || count.get(x) > count.getOrDefault(want, 0))\\n                return false;\\n            count.put(want, count.get(want) - count.get(x));\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // taken help\\n    public boolean canReorderDoubled(int[] arr) {\\n\\n        Map<Integer, Integer> count = new TreeMap<>();\\n        for (int a : arr)\\n            count.put(a, count.getOrDefault(a, 0) + 1);\\n        for (int x : count.keySet()) {\\n            if (count.get(x) == 0) continue;\\n            int want = x < 0 ? x / 2 : x * 2;\\n            if (x < 0 && x % 2 != 0 || count.get(x) > count.getOrDefault(want, 0))\\n                return false;\\n            count.put(want, count.get(want) - count.get(x));\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917966,
                "title": "python-solution-using-counter",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Keep a count of each number in the arr in counts.\\n2. Sort the arr.\\n3. For each number in arr:\\n    a. If count of number has become 0 then skip.\\n    b. If (number * 2) is present in counts then decrement number and (number * 2)\\n4. At the end if count of all the numbers in counts has become 0 then return True else False.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        counts = collections.Counter(arr)\\n\\n        for num in sorted(arr, key=abs):\\n            if counts[num] == 0:\\n                continue\\n            if num*2 in counts:\\n                counts[num] -= 1\\n                counts[num*2] -= 1\\n        \\n        return all([True if counts[x] == 0 else False for x in counts])\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        counts = collections.Counter(arr)\\n\\n        for num in sorted(arr, key=abs):\\n            if counts[num] == 0:\\n                continue\\n            if num*2 in counts:\\n                counts[num] -= 1\\n                counts[num*2] -= 1\\n        \\n        return all([True if counts[x] == 0 else False for x in counts])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632405,
                "title": "treemap-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        int n = arr.length;\\n        TreeMap<Integer,Integer> map  = new TreeMap<>();\\n        for(int i =0;i<arr.length;i++){\\n            map.put(arr[i],map.getOrDefault(arr[i],0)+1);\\n        }\\n        for(int key:map.keySet()){\\n            int dbl = key*2;\\n            while(map.get(key)>0){\\n                if(map.containsKey(dbl) && map.get(dbl)>0){\\n                    map.put(dbl,map.get(dbl)-1);\\n                    map.put(key,map.get(key)-1);\\n                }\\n                // if not fount then why there is a need to check futher:)\\n                else{\\n                    break;\\n                }\\n            }\\n           \\n        }\\n        \\n// now check if any key has value greater than 0 it means it does not contains double value;\\n        for(int rs:map.keySet()){\\n            if(map.get(rs)>0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n} \\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        int n = arr.length;\\n        TreeMap<Integer,Integer> map  = new TreeMap<>();\\n        for(int i =0;i<arr.length;i++){\\n            map.put(arr[i],map.getOrDefault(arr[i],0)+1);\\n        }\\n        for(int key:map.keySet()){\\n            int dbl = key*2;\\n            while(map.get(key)>0){\\n                if(map.containsKey(dbl) && map.get(dbl)>0){\\n                    map.put(dbl,map.get(dbl)-1);\\n                    map.put(key,map.get(key)-1);\\n                }\\n                // if not fount then why there is a need to check futher:)\\n                else{\\n                    break;\\n                }\\n            }\\n           \\n        }\\n        \\n// now check if any key has value greater than 0 it means it does not contains double value;\\n        for(int rs:map.keySet()){\\n            if(map.get(rs)>0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531684,
                "title": "c-map-sorting-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*logn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        sort(arr.begin(), arr.end());\\n        map<int, int>m;\\n        for(int i=0; i<arr.size(); i++){\\n            m[arr[i]]++;\\n        }\\n        for(int i=0; i<arr.size(); i++){\\n            if(m.find(arr[i])!=m.end()){\\n                cout<<arr[i]<<endl;\\n                if(m.find(2*arr[i])!=m.end()){\\n                    cout<<arr[i]<<\" \"<<arr[i]*2<<\" \"<<i<<endl;\\n                    m[2*arr[i]]--;\\n                    if(m[2*arr[i]]==0){\\n                        m.erase(2*arr[i]);\\n                    }\\n                    m[arr[i]]--;\\n                    if(m[arr[i]]==0){\\n                        cout<<\"here\\\\n\";\\n                        m.erase(arr[i]);\\n                    }\\n                }\\n                else if(m.find(arr[i]/2)!=m.end() && arr[i]%2==0){\\n                    cout<<arr[i]<<\" h \"<<arr[i]/2<<\" \"<<i<<endl;\\n                    m[arr[i]/2]--;\\n                    if(m[arr[i]/2]==0){\\n                        m.erase(arr[i]/2);\\n                    }\\n                    m[arr[i]]--;\\n                    if(m[arr[i]]==0){\\n                        m.erase(arr[i]);\\n                    }\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        sort(arr.begin(), arr.end());\\n        map<int, int>m;\\n        for(int i=0; i<arr.size(); i++){\\n            m[arr[i]]++;\\n        }\\n        for(int i=0; i<arr.size(); i++){\\n            if(m.find(arr[i])!=m.end()){\\n                cout<<arr[i]<<endl;\\n                if(m.find(2*arr[i])!=m.end()){\\n                    cout<<arr[i]<<\" \"<<arr[i]*2<<\" \"<<i<<endl;\\n                    m[2*arr[i]]--;\\n                    if(m[2*arr[i]]==0){\\n                        m.erase(2*arr[i]);\\n                    }\\n                    m[arr[i]]--;\\n                    if(m[arr[i]]==0){\\n                        cout<<\"here\\\\n\";\\n                        m.erase(arr[i]);\\n                    }\\n                }\\n                else if(m.find(arr[i]/2)!=m.end() && arr[i]%2==0){\\n                    cout<<arr[i]<<\" h \"<<arr[i]/2<<\" \"<<i<<endl;\\n                    m[arr[i]/2]--;\\n                    if(m[arr[i]/2]==0){\\n                        m.erase(arr[i]/2);\\n                    }\\n                    m[arr[i]]--;\\n                    if(m[arr[i]]==0){\\n                        m.erase(arr[i]);\\n                    }\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3492807,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        map<int,int> mp;\\n        sort(arr.begin(),arr.end());\\n        for (int i=0; i<arr.size(); i++)mp[arr[i]]++;\\n        for (int i=0; i<arr.size(); i++){\\n            if (mp[arr[i]]==0)continue;\\n            if (mp[arr[i]*2]>0){\\n                mp[arr[i]*2]--;\\n                mp[arr[i]]--;\\n            }\\n        }\\n        for (auto vl: mp){\\n            if (vl.second!=0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        map<int,int> mp;\\n        sort(arr.begin(),arr.end());\\n        for (int i=0; i<arr.size(); i++)mp[arr[i]]++;\\n        for (int i=0; i<arr.size(); i++){\\n            if (mp[arr[i]]==0)continue;\\n            if (mp[arr[i]*2]>0){\\n                mp[arr[i]*2]--;\\n                mp[arr[i]]--;\\n            }\\n        }\\n        for (auto vl: mp){\\n            if (vl.second!=0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137523,
                "title": "easy-approach-c-using-hash-map-sorting-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        map<int,int>m;\\n        int j=0;\\n        for(auto i:arr){\\n            m[i]++;\\n        }\\n        for(auto i:arr ){\\n            if(m[i*2] && m[i] ){\\n                if(i==0 && m[i]>=2 || i!=0){\\n                j++;\\n                m[i*2]--;\\n                m[i]--;}\\n\\n            }\\n         \\n        }\\n      if(j==arr.size()/2) return true;\\n        return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        map<int,int>m;\\n        int j=0;\\n        for(auto i:arr){\\n            m[i]++;\\n        }\\n        for(auto i:arr ){\\n            if(m[i*2] && m[i] ){\\n                if(i==0 && m[i]>=2 || i!=0){\\n                j++;\\n                m[i*2]--;\\n                m[i]--;}\\n\\n            }\\n         \\n        }\\n      if(j==arr.size()/2) return true;\\n        return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585608,
                "title": "java-sort-and-hash-reuse-lc-2007",
                "content": "**Idea:** This is a simpler version of [LC 2007. Find Original Array From Doubled Array](https://leetcode.com/problems/find-original-array-from-doubled-array/discuss/2578885/Java-or-Sort-and-Hash-or-Explained). I\\'ve explained it there, so not gonna repeat. Please refer that solution.\\n>**T/S:** O(m lg m)/O(m), where m = size(arr)\\n```\\npublic boolean canReorderDoubled(int[] arr) {\\n\\tvar count = new HashMap<Integer, Integer>();\\n\\tvar nums = Arrays.stream(arr)\\n\\t\\t\\t\\t\\t .boxed()\\n\\t\\t\\t\\t\\t .toArray(Integer[]::new);\\t\\n\\tArrays.sort(nums, Comparator.comparing(Math::abs));\\n\\tArrays.stream(nums)\\n\\t\\t  .forEach(x -> count.compute(x, (k, v) -> v == null ? 1 : ++v));\\n\\n\\tfor (var n : nums) {\\n\\t\\tif (count.get(n) == 0)\\n\\t\\t\\tcontinue;\\n\\t\\tif (count.getOrDefault(2 * n, 0) == 0 || (n == 0 && count.getOrDefault(0, 0) < 2))\\n\\t\\t\\treturn false;\\n\\t\\tcount.compute(n, (k, v) -> --v);\\n\\t\\tcount.compute(2 * n, (k, v) -> --v);\\n\\t}\\n\\treturn true;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canReorderDoubled(int[] arr) {\\n\\tvar count = new HashMap<Integer, Integer>();\\n\\tvar nums = Arrays.stream(arr)\\n\\t\\t\\t\\t\\t .boxed()\\n\\t\\t\\t\\t\\t .toArray(Integer[]::new);\\t\\n\\tArrays.sort(nums, Comparator.comparing(Math::abs));\\n\\tArrays.stream(nums)\\n\\t\\t  .forEach(x -> count.compute(x, (k, v) -> v == null ? 1 : ++v));\\n\\n\\tfor (var n : nums) {\\n\\t\\tif (count.get(n) == 0)\\n\\t\\t\\tcontinue;\\n\\t\\tif (count.getOrDefault(2 * n, 0) == 0 || (n == 0 && count.getOrDefault(0, 0) < 2))\\n\\t\\t\\treturn false;\\n\\t\\tcount.compute(n, (k, v) -> --v);\\n\\t\\tcount.compute(2 * n, (k, v) -> --v);\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2580649,
                "title": "easy-c-solution-using-map-and-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& c) {\\n         unordered_map<int,int>mp;\\n        for(auto i:c) {\\n            mp[i]++;\\n        }\\n        sort(c.begin(),c.end());\\n        for(auto i:c) {\\n            if(mp[i]) {\\n                if(mp[2*i])\\n                 {\\n                mp[2*i]--;\\n                 mp[i]--;}\\n                else if(i%2==0 && mp[i/2])\\n                    {\\n                mp[(i/2)]--;\\n                 mp[i]--;}\\n                else \\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& c) {\\n         unordered_map<int,int>mp;\\n        for(auto i:c) {\\n            mp[i]++;\\n        }\\n        sort(c.begin(),c.end());\\n        for(auto i:c) {\\n            if(mp[i]) {\\n                if(mp[2*i])\\n                 {\\n                mp[2*i]--;\\n                 mp[i]--;}\\n                else if(i%2==0 && mp[i/2])\\n                    {\\n                mp[(i/2)]--;\\n                 mp[i]--;}\\n                else \\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580010,
                "title": "c-hashmap-sorting-easy-understanding-tc-o-n-log-n",
                "content": "**C++**\\n\\n```\\nclass Solution {\\npublic:bool static comp(int &i, int &j)\\n    {\\n        if(i < 0 && j < 0)\\n            return i > j;\\n        else\\n            return i<j;\\n    }\\n    bool canReorderDoubled(vector<int>& changed) {\\n        unordered_map<int,int> mp;\\n        for(auto it: changed){\\n            mp[it]++;\\n        }\\n        \\n       sort(changed.begin(), changed.end(), comp); // applied customize sorting \\n        for(auto it: changed) cout << it << \" \";\\n        vector<int> ans;\\n        for(auto it: changed){\\n            if(mp[it] > 0){\\n                    mp[it]--;\\n                    ans.push_back(it);\\n                    \\n                    if(mp[it * 2] > 0){\\n                        mp[it * 2]--;\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n            }\\n                \\n        }\\n    \\n        return true;\\n    }\\n};\\n```\\\\\\nSMAE AS -> https://leetcode.com/problems/find-original-array-from-doubled-array/ THIS PROBLEM\\nLink of this solution -> https://leetcode.com/problems/find-original-array-from-doubled-array/discuss/2580004/C%2B%2B-oror-HashMap-oror-Sorting-oror-TC-greater-NlogN \\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:bool static comp(int &i, int &j)\\n    {\\n        if(i < 0 && j < 0)\\n            return i > j;\\n        else\\n            return i<j;\\n    }\\n    bool canReorderDoubled(vector<int>& changed) {\\n        unordered_map<int,int> mp;\\n        for(auto it: changed){\\n            mp[it]++;\\n        }\\n        \\n       sort(changed.begin(), changed.end(), comp); // applied customize sorting \\n        for(auto it: changed) cout << it << \" \";\\n        vector<int> ans;\\n        for(auto it: changed){\\n            if(mp[it] > 0){\\n                    mp[it]--;\\n                    ans.push_back(it);\\n                    \\n                    if(mp[it * 2] > 0){\\n                        mp[it * 2]--;\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n            }\\n                \\n        }\\n    \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2460604,
                "title": "seperate-positive-and-negative",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def checkPos(self, arr):\\n        ctr = Counter()\\n        for el in arr:\\n            if ctr[el * 2] > 0:\\n                ctr[2 * el] -= 1\\n            else:\\n                ctr[el] += 1\\n        return sum(ctr.values()) == 0\\n    \\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        n = len(arr)\\n        pos = []\\n        neg = []\\n        for el in arr:\\n            if el >= 0:\\n                pos.append(el)\\n            else:\\n                neg.append(-el)\\n        pos.sort(reverse = True)\\n        neg.sort(reverse = True)\\n        return self.checkPos(pos) and self.checkPos(neg)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def checkPos(self, arr):\\n        ctr = Counter()\\n        for el in arr:\\n            if ctr[el * 2] > 0:\\n                ctr[2 * el] -= 1\\n            else:\\n                ctr[el] += 1\\n        return sum(ctr.values()) == 0\\n    \\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        n = len(arr)\\n        pos = []\\n        neg = []\\n        for el in arr:\\n            if el >= 0:\\n                pos.append(el)\\n            else:\\n                neg.append(-el)\\n        pos.sort(reverse = True)\\n        neg.sort(reverse = True)\\n        return self.checkPos(pos) and self.checkPos(neg)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102889,
                "title": "java-o-nlogn-hashing-sorting",
                "content": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        HashMap<Integer, Integer> hashmap = new HashMap<>();\\n\\t\\t\\n\\t\\t// Store freq of every number\\n        for(int num : arr) hashmap.put(num, hashmap.getOrDefault(num, 0) + 1);\\n        Arrays.sort(arr);\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            if(!hashmap.containsKey(arr[i])) continue;\\n\\t\\t\\t\\n\\t\\t\\t// If a number \\'n\\' is negative, and as the array is sorted, its pair element must be n / 2\\n\\t\\t\\t// Because for example if n = -12, it must have a pair element -6 (as the array is sorted we will not find -24 (-12 * 2) ahead of the current position)\\n            if(arr[i] < 0 && arr[i] % 2 != 0) return false;\\n\\t\\t\\t\\n\\t\\t\\t// In case of positive element, the pair element of current number n must be n * 2, the reason again being the array is sorted\\n\\t\\t\\t// In an array 2, 4, 6, ...  we won\\'t find the pair element of 2 as 1 because 2 is the smallest here\\n            int num = arr[i] > 0 ? arr[i] * 2 : arr[i] / 2;\\n\\t\\t\\t\\n            if(!hashmap.containsKey(num)) return false; // If pair element is not found\\n\\t\\t\\t\\n            hashmap.put(arr[i], hashmap.get(arr[i]) - 1);\\n            hashmap.put(num, hashmap.get(num) - 1);\\n            if(hashmap.get(arr[i]) == 0) hashmap.remove(arr[i]);\\n            if(hashmap.getOrDefault(num, -1) == 0) hashmap.remove(num);\\n        }\\n        \\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        HashMap<Integer, Integer> hashmap = new HashMap<>();\\n\\t\\t\\n\\t\\t// Store freq of every number\\n        for(int num : arr) hashmap.put(num, hashmap.getOrDefault(num, 0) + 1);\\n        Arrays.sort(arr);\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            if(!hashmap.containsKey(arr[i])) continue;\\n\\t\\t\\t\\n\\t\\t\\t// If a number \\'n\\' is negative, and as the array is sorted, its pair element must be n / 2\\n\\t\\t\\t// Because for example if n = -12, it must have a pair element -6 (as the array is sorted we will not find -24 (-12 * 2) ahead of the current position)\\n            if(arr[i] < 0 && arr[i] % 2 != 0) return false;\\n\\t\\t\\t\\n\\t\\t\\t// In case of positive element, the pair element of current number n must be n * 2, the reason again being the array is sorted\\n\\t\\t\\t// In an array 2, 4, 6, ...  we won\\'t find the pair element of 2 as 1 because 2 is the smallest here\\n            int num = arr[i] > 0 ? arr[i] * 2 : arr[i] / 2;\\n\\t\\t\\t\\n            if(!hashmap.containsKey(num)) return false; // If pair element is not found\\n\\t\\t\\t\\n            hashmap.put(arr[i], hashmap.get(arr[i]) - 1);\\n            hashmap.put(num, hashmap.get(num) - 1);\\n            if(hashmap.get(arr[i]) == 0) hashmap.remove(arr[i]);\\n            if(hashmap.getOrDefault(num, -1) == 0) hashmap.remove(num);\\n        }\\n        \\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959967,
                "title": "c-solution-easy-code",
                "content": "class Solution {\\npublic:\\n\\n    bool canReorderDoubled(vector<int>& arr) \\n    {\\n        sort(arr.begin(),arr.end());\\n        int n=arr.size();\\n        map<double,int>m;\\n        for(auto i:arr)\\n            m[i]++;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(m[arr[i]]>0)\\n            {\\n                if(m[2*arr[i]]>0)\\n                {\\n                    m[2*arr[i]]--;\\n                    m[arr[i]]--;\\n                }\\n                else if(m[(double)arr[i]/2]>0)\\n                {\\n                    m[(double)arr[i]/2]--;\\n                    m[arr[i]]--;\\n                }\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    bool canReorderDoubled(vector<int>& arr) \\n    {\\n        sort(arr.begin(),arr.end());\\n        int n=arr.size();\\n        map<double,int>m;\\n        for(auto i:arr)\\n            m[i]++;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(m[arr[i]]>0)\\n            {\\n                if(m[2*arr[i]]>0)\\n                {\\n                    m[2*arr[i]]--;\\n                    m[arr[i]]--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1927230,
                "title": "java-explained-each-step-100-working",
                "content": "## tried to explain each step in comments, \\n### please upvote if u like the solution <3\\n\\t\\n\\t\\n\\t\\n\\tclass Solution {\\n\\t\\tpublic boolean canReorderDoubled(int[] arr) {\\n\\t\\t\\tif(arr.length== 0) return true;\\n\\n\\t\\t\\t//Create a Hashmap to store the frequency of the elements\\n\\t\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\n\\t\\t\\tfor(int ele:arr){\\n\\t\\t\\t\\tmap.put(ele,map.getOrDefault(ele,0)+1);\\n\\t\\t\\t}\\n\\n\\t\\t\\t/* Now we need to sort the array, and after sorting if we traverse through each  element, we hope to find the double of the element, but this will be valid only for positive elements, \\n\\t\\t\\t for eg: we have a positive array: [4,2,7,14] \\n\\t\\t\\tAfter sorting it becomes :[2,4,7,14] \\n\\t\\t\\tIt can give us pairs like :(2,4), (7,14) \\n\\t\\t\\tbut for negative if we sort:[-8,-10,-5,-4]->[-10,-8,-5,-4]\\n\\t\\t\\there we will need to find the half of the first elements we encounter*/\\n\\n\\t\\t\\t//so we use the lambda expression, which will sort it using its absolute value\\n\\n\\t\\t\\tInteger[] ar = new Integer[arr.length];\\n\\t\\t\\tfor(int i=0;i<arr.length;i++) ar[i]=arr[i];\\n\\n\\t\\t\\tArrays.sort(ar,(a,b)->{\\n\\t\\t\\t\\treturn Math.abs(a)-Math.abs(b);\\n\\t\\t\\t}); // this statement will return +ve, i.e a>b, \\n\\t\\t\\t\\t// if returns -ve, i.e a<b, and 0,if a==b\\n\\t/* Now for an array [-8,-10, 4, 2, 0, 0,-4. 6,-5,3] \\n\\twe have [-4,-5,-8,-10,0,0,2,3,4,6]  in the sorted manner so we keep traversing from the first element pair it up with its double */\\n\\n\\t\\t\\tfor(int ele:ar){\\n\\t\\t\\t\\tif(map.get(ele)==0) continue;   //if the freq of that element gets exhausted we continue;                                       \\n\\n\\t\\t\\t\\tif(map.getOrDefault(2*ele,0)==0){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t/*if we need to have the double value of the element but the value exhausts we return false \\n\\n\\t\\t\\t   as we keep making pairs of elements we decrese the freq of the elements from the freq hashmap used.*/ \\n\\t\\t\\t\\t map.put(ele,map.get(ele)-1);\\n\\t\\t\\t\\t map.put(2*ele,map.get(2*ele)-1);\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\t\\n## Simple as that",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic boolean canReorderDoubled(int[] arr) {\\n\\t\\t\\tif(arr.length== 0) return true;\\n\\n\\t\\t\\t//Create a Hashmap to store the frequency of the elements\\n\\t\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\n\\t\\t\\tfor(int ele:arr){\\n\\t\\t\\t\\tmap.put(ele,map.getOrDefault(ele,0)+1);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1901383,
                "title": "java-efficient-solution-easy-understanding-explained-using-comments-hashmap",
                "content": "public boolean canReorderDoubled(int[] arr) {\\n\\n        if(arr.length % 2 != 0)\\n            return false;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        //1. Frequency Map\\n        for(int val: arr){\\n\\n            if(val != 0)        //As zero will always stay in map therefore it\\'s better not to add it in map  -->  Edge Case\\n                map.put(val, map.getOrDefault(val, 0) + 1);\\n        }\\n\\n        //2. Sort\\n        Arrays.sort(arr);     // Why? -> Case:      2 4 1 8\\n\\n        \\n        //3. Check and remove from map\\n        for(int val: arr){\\n            \\n            if(val != 0)\\n                continue;\\n            \\n            if(map.containsKey(val)  &&  map.containsKey(2*val)){\\n\\n                if(map.getOrDefault(val, 0) > 1)\\n                    map.put(val, map.getOrDefault(val, 0) -1);\\n                else\\n                    map.remove(val);\\n\\n\\n                if(map.getOrDefault(2*val, 0) > 1)\\n                    map.put(2*val, map.getOrDefault(2*val, 0) -1);\\n                else\\n                    map.remove(2*val);\\n            }\\n\\n        }\\n        \\n        //5. Check for the size\\n        if(map.size() == 0)\\n            return true;\\n\\n        else\\n            return false;\\n\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public boolean canReorderDoubled(int[] arr) {\\n\\n        if(arr.length % 2 != 0)\\n            return false;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        //1. Frequency Map\\n        for(int val: arr){\\n\\n            if(val != 0)        //As zero will always stay in map therefore it\\'s better not to add it in map  -->  Edge Case\\n                map.put(val, map.getOrDefault(val, 0) + 1);\\n        }\\n\\n        //2. Sort\\n        Arrays.sort(arr);     // Why? -> Case:      2 4 1 8\\n\\n        \\n        //3. Check and remove from map\\n        for(int val: arr){\\n            \\n            if(val != 0)\\n                continue;\\n            \\n            if(map.containsKey(val)  &&  map.containsKey(2*val)){\\n\\n                if(map.getOrDefault(val, 0) > 1)\\n                    map.put(val, map.getOrDefault(val, 0) -1);\\n                else\\n                    map.remove(val);\\n\\n\\n                if(map.getOrDefault(2*val, 0) > 1)\\n                    map.put(2*val, map.getOrDefault(2*val, 0) -1);\\n                else\\n                    map.remove(2*val);\\n            }\\n\\n        }\\n        \\n        //5. Check for the size\\n        if(map.size() == 0)\\n            return true;\\n\\n        else\\n            return false;\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1893460,
                "title": "java-tc-o-nlogn-sc-o-n-hashmap-solution",
                "content": "0s are being taken care of through getOrDefault method and if remaining at the very last then it doesn\\'t matter at all, hence True.\\n```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        Arrays.sort(arr);\\n      \\n        for(int val : arr){\\n            map.put(val, map.getOrDefault(val, 0) +1);\\n        }\\n        \\n        for(int val : arr){\\n            if(val == 0) continue;\\n            \\n            if(map.containsKey(val) && map.containsKey(2 * val)){\\n                \\n                if(map.getOrDefault(2 * val, 0) > 1) \\n                    map.put(2 * val, map.getOrDefault(2 * val, 0) -1);\\n                else map.remove(2 * val);\\n                \\n                if(map.getOrDefault(val, 0) > 1) \\n                    map.put(val, map.getOrDefault(val, 0) -1);\\n                else map.remove(val);              \\n            }\\n        }\\n        \\n        if(map.size() == 0 || (map.size() == 1 && map.containsKey(0))) return true;\\n        else return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        Arrays.sort(arr);\\n      \\n        for(int val : arr){\\n            map.put(val, map.getOrDefault(val, 0) +1);\\n        }\\n        \\n        for(int val : arr){\\n            if(val == 0) continue;\\n            \\n            if(map.containsKey(val) && map.containsKey(2 * val)){\\n                \\n                if(map.getOrDefault(2 * val, 0) > 1) \\n                    map.put(2 * val, map.getOrDefault(2 * val, 0) -1);\\n                else map.remove(2 * val);\\n                \\n                if(map.getOrDefault(val, 0) > 1) \\n                    map.put(val, map.getOrDefault(val, 0) -1);\\n                else map.remove(val);              \\n            }\\n        }\\n        \\n        if(map.size() == 0 || (map.size() == 1 && map.containsKey(0))) return true;\\n        else return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855388,
                "title": "java-ac-solution",
                "content": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int val:arr){\\n            if(val != 0)\\n                map.put(val,map.getOrDefault(val,0)+1); // creating frequency map\\n        }\\n        Arrays.sort(arr); \\n        for(int val:arr){\\n            if(map.containsKey(val) && map.containsKey(2*val)){ //if value and its double is present we decrease the frequency of that value in map\\n                if(map.getOrDefault(val,0) > 1)\\n                    map.put(val,map.getOrDefault(val,0)-1);\\n                else\\n                    map.remove(val);\\n                if(map.getOrDefault(2*val,0) > 1)\\n                    map.put(2*val,map.getOrDefault(2*val,0)-1);\\n                else\\n                    map.remove(2*val);\\n            }\\n        }\\n        if(map.size()==0) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int val:arr){\\n            if(val != 0)\\n                map.put(val,map.getOrDefault(val,0)+1); // creating frequency map\\n        }\\n        Arrays.sort(arr); \\n        for(int val:arr){\\n            if(map.containsKey(val) && map.containsKey(2*val)){ //if value and its double is present we decrease the frequency of that value in map\\n                if(map.getOrDefault(val,0) > 1)\\n                    map.put(val,map.getOrDefault(val,0)-1);\\n                else\\n                    map.remove(val);\\n                if(map.getOrDefault(2*val,0) > 1)\\n                    map.put(2*val,map.getOrDefault(2*val,0)-1);\\n                else\\n                    map.remove(2*val);\\n            }\\n        }\\n        if(map.size()==0) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840844,
                "title": "python-3-o-nlogn",
                "content": "```\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        count = collections.Counter(arr)\\n        for n in sorted(arr, key=abs):\\n            if count[n] == 0:\\n                continue\\n            if count[n * 2] == 0:\\n                return False\\n            count[n] -= 1\\n            count[n * 2] -= 1\\n        \\n        return True",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        count = collections.Counter(arr)\\n        for n in sorted(arr, key=abs):\\n            if count[n] == 0:\\n                continue\\n            if count[n * 2] == 0:\\n                return False\\n            count[n] -= 1\\n            count[n * 2] -= 1\\n        \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 1810465,
                "title": "python-optimised-counter-solution-explained",
                "content": "### Explanation\\n\\nThis solution is an extension of the official solution. For the intuition behind how to approach this problem, you may want to check out [the official solution](https://leetcode.com/problems/array-of-doubled-pairs/solution/) first before returning to this post.\\n\\nEssentially, having to continually decrement counters for each individual pair of elements is very time-consuming and inefficient. Since we know exactly how many times an element `x` appears in the array `arr`, we can remove the element entirely if we know that there are as many (or more) `2x` elements in `arr`. Conversely, if there aren\\'t enough `2x` elements, we can simply return False. This approach ensures that **we loop through each UNIQUE element only once**.\\n\\nOf course, there are some edge cases to take care of, namely if `x == 0` among other conditionals. For `x == 0`, we can simply check if there are an even number of zeros for it to pair among itself.\\n\\n---\\n\\n### Code\\n\\n```python\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        arr.sort(key=abs)  # Sort the array based on the absolute value\\n        cnt = Counter(arr)  # Count the number of each element in arr\\n        while cnt:\\n            x = next(iter(cnt.keys()))  # Get the next unique element x\\n\\t\\t\\t# Handle conditionals (written on multiple lines for clarity)\\n            if 2*x not in cnt or \\\\  # Condition 1: 2x does not exist in arr\\n\\t\\t\\t\\t\\t(x == 0 and cnt[x]&1) or \\\\  # Condition 2: Odd number of 0s in arr\\n\\t\\t\\t\\t\\tcnt[2*x] < cnt[x]:  # Condition 3: Insufficient 2x to pair with x in arr\\n                return False\\n            cnt[2*x] -= cnt[x]  # Remove the number of 2x elements needed for pairing with x\\n            _ = cnt.pop(x)  # All x paired; remove x entirely (for iteration purposes)\\n            if cnt[2*x] == 0 and x != 0:\\n                _ = cnt.pop(2*x)  # Only remove 2x if there are no more 2x left\\n        return True\\n```\\n\\n---\\n\\n### Result\\n\\n**TC: O(nlogn)**, where `n` is the length of `arr`, due to array sorting.\\n**SC: O(n)**, due to the `Counter` object used.\\n\\nAlthough there is no major improvement in the TC or SC, looping through unique elements is more efficient that looping through all elements, especially if the number of duplicates per element is very high.\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        arr.sort(key=abs)  # Sort the array based on the absolute value\\n        cnt = Counter(arr)  # Count the number of each element in arr\\n        while cnt:\\n            x = next(iter(cnt.keys()))  # Get the next unique element x\\n\\t\\t\\t# Handle conditionals (written on multiple lines for clarity)\\n            if 2*x not in cnt or \\\\  # Condition 1: 2x does not exist in arr\\n\\t\\t\\t\\t\\t(x == 0 and cnt[x]&1) or \\\\  # Condition 2: Odd number of 0s in arr\\n\\t\\t\\t\\t\\tcnt[2*x] < cnt[x]:  # Condition 3: Insufficient 2x to pair with x in arr\\n                return False\\n            cnt[2*x] -= cnt[x]  # Remove the number of 2x elements needed for pairing with x\\n            _ = cnt.pop(x)  # All x paired; remove x entirely (for iteration purposes)\\n            if cnt[2*x] == 0 and x != 0:\\n                _ = cnt.pop(2*x)  # Only remove 2x if there are no more 2x left\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760810,
                "title": "python-counter-o-n-solution",
                "content": "One O(n)-time way of handling this problem is to first find the largest number in the chain (linear time with a counter) and then walk down through the chain by dividing the number by two each time (linear time).\\n\\nThe tricky part of the problem is to handle groups of numbers such as ` [-11, -22, -22, -44, -44, -88]` the pairs should be `(-11, -22), (-22, -44), (-44, -88)` instead of `(-22, -44), (-22, -44)` and leave `-11` and `-88` alone. We can aviod this since we are walking in one direction (large to small), small to large works too.\\n\\nIn another case like `[2,1,1,4,8,8]`, since `8` is the largest number in this chain, there is not enough `4` to meet the requirement, we can return False in this case (L33-34)\\n\\nSimilar idea can be apply to [2007. Find Original Array From Doubled Array](https://leetcode.com/problems/find-original-array-from-doubled-array/).\\n\\n\\n```\\nclass Solution(object):\\n    def canReorderDoubled(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        n = len(arr)\\n        freq_dict = {}\\n        \\n        # create counter\\n        freq_dict = collections.Counter(arr)\\n\\n        # deal with zeros\\n        if 0 in freq_dict:\\n            if freq_dict[0] % 2 == 1:\\n                return False\\n            else:\\n                freq_dict[0] = 0\\n        \\n        for k in freq_dict.keys():\\n            if freq_dict[k] == 0:\\n                continue\\n            else:\\n                temp_k = k\\n                # walk up the chain\\n                while temp_k * 2 in freq_dict:\\n                    temp_k = temp_k * 2\\n                # walk down and process all numbers within the chain. mark the counts as 0\\n                while temp_k % 2 == 0 and temp_k / 2 in freq_dict:\\n                    freq_dict[temp_k / 2] -= freq_dict[temp_k]\\n                    freq_dict[temp_k] = 0\\n                    temp_k = temp_k / 2\\n                    if freq_dict[temp_k] < 0:\\n                        return False\\n                \\n        for k in freq_dict.keys():\\n            if freq_dict[k] != 0:\\n                return False  \\n        return True\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def canReorderDoubled(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        n = len(arr)\\n        freq_dict = {}\\n        \\n        # create counter\\n        freq_dict = collections.Counter(arr)\\n\\n        # deal with zeros\\n        if 0 in freq_dict:\\n            if freq_dict[0] % 2 == 1:\\n                return False\\n            else:\\n                freq_dict[0] = 0\\n        \\n        for k in freq_dict.keys():\\n            if freq_dict[k] == 0:\\n                continue\\n            else:\\n                temp_k = k\\n                # walk up the chain\\n                while temp_k * 2 in freq_dict:\\n                    temp_k = temp_k * 2\\n                # walk down and process all numbers within the chain. mark the counts as 0\\n                while temp_k % 2 == 0 and temp_k / 2 in freq_dict:\\n                    freq_dict[temp_k / 2] -= freq_dict[temp_k]\\n                    freq_dict[temp_k] = 0\\n                    temp_k = temp_k / 2\\n                    if freq_dict[temp_k] < 0:\\n                        return False\\n                \\n        for k in freq_dict.keys():\\n            if freq_dict[k] != 0:\\n                return False  \\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758410,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    //question is just saying that can you make this array into x and 2x pairs \\n    public boolean canReorderDoubled(int[] arr) {\\n     Arrays.sort(arr);//so can work for all positive and negative numbers\\n     HashMap<Double,Integer> hm=new HashMap<>();\\n     for(int p:arr)\\n     {\\n         double x=(double)p;\\n         if(hm.containsKey(x/2))\\n         {\\n             hm.put(x/2,hm.get(x/2)-1);\\n             if(hm.get(x/2)==0)\\n                 hm.remove(x/2);\\n         }else if(hm.containsKey(x*2))\\n         {\\n             hm.put(x*2,hm.get(x*2)-1);\\n             if(hm.get(x*2)==0)\\n                 hm.remove(x*2);\\n         }\\n         else\\n         hm.put(x,hm.getOrDefault(x,0)+1);\\n     }\\n     return hm.size()==0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //question is just saying that can you make this array into x and 2x pairs \\n    public boolean canReorderDoubled(int[] arr) {\\n     Arrays.sort(arr);//so can work for all positive and negative numbers\\n     HashMap<Double,Integer> hm=new HashMap<>();\\n     for(int p:arr)\\n     {\\n         double x=(double)p;\\n         if(hm.containsKey(x/2))\\n         {\\n             hm.put(x/2,hm.get(x/2)-1);\\n             if(hm.get(x/2)==0)\\n                 hm.remove(x/2);\\n         }else if(hm.containsKey(x*2))\\n         {\\n             hm.put(x*2,hm.get(x*2)-1);\\n             if(hm.get(x*2)==0)\\n                 hm.remove(x*2);\\n         }\\n         else\\n         hm.put(x,hm.getOrDefault(x,0)+1);\\n     }\\n     return hm.size()==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697933,
                "title": "simple-java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        HashMap<Integer,Integer> fmap=new HashMap<>();\\n        for(int val:arr){\\n            fmap.put(val,fmap.getOrDefault(val,0)+1);\\n        }\\n        Integer[] ar=new Integer[arr.length];\\n        for(int i=0;i<arr.length;i++){\\n            ar[i]=arr[i];\\n        }\\n        Arrays.sort(ar,(a,b)->{\\n            return Math.abs(a)-Math.abs(b);\\n        });\\n        for(int val:ar){\\n            if(fmap.get(val)==0) continue;\\n            \\n            if(fmap.getOrDefault(2*val,0)==0) return false;\\n            fmap.put(val,fmap.get(val)-1);\\n            fmap.put(2*val,fmap.get(2*val)-1);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        HashMap<Integer,Integer> fmap=new HashMap<>();\\n        for(int val:arr){\\n            fmap.put(val,fmap.getOrDefault(val,0)+1);\\n        }\\n        Integer[] ar=new Integer[arr.length];\\n        for(int i=0;i<arr.length;i++){\\n            ar[i]=arr[i];\\n        }\\n        Arrays.sort(ar,(a,b)->{\\n            return Math.abs(a)-Math.abs(b);\\n        });\\n        for(int val:ar){\\n            if(fmap.get(val)==0) continue;\\n            \\n            if(fmap.getOrDefault(2*val,0)==0) return false;\\n            fmap.put(val,fmap.get(val)-1);\\n            fmap.put(2*val,fmap.get(2*val)-1);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564119,
                "title": "c-easy-solution-using-map-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool compare(int a, int b){\\n        return abs(a) < abs(b);\\n    }\\n    bool canReorderDoubled(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), compare);\\n        map<int, int> mp;//store values and counts\\n        for(int i=0 ;i<arr.size(); i++) mp[arr[i]]++;\\n        for(int j=0 ;j<arr.size(); j++){\\n            if(mp.find(2*arr[j]) != mp.end() && mp[2*arr[j]] != 0 && mp[arr[j]] != 0){\\n                mp[arr[j]]--;\\n                mp[2*arr[j]]--;  \\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(int a, int b){\\n        return abs(a) < abs(b);\\n    }\\n    bool canReorderDoubled(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), compare);\\n        map<int, int> mp;//store values and counts\\n        for(int i=0 ;i<arr.size(); i++) mp[arr[i]]++;\\n        for(int j=0 ;j<arr.size(); j++){\\n            if(mp.find(2*arr[j]) != mp.end() && mp[2*arr[j]] != 0 && mp[arr[j]] != 0){\\n                mp[arr[j]]--;\\n                mp[2*arr[j]]--;  \\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486095,
                "title": "o-n-time-o-n-space-no-sort-required",
                "content": "```c++\\n\\tbool canReorderDoubled(vector<int>& arr) {\\n        unordered_map<int, int> d2c;\\n        for (int i: arr)\\n            d2c[i]++;\\n        if (d2c.find(0)!=d2c.end()&&d2c[0]%2!=0)\\n            return false;\\n        d2c.erase(0);\\n        for (int i: arr) {\\n            if (d2c.find(i)==d2c.end())\\n                continue;\\n            int cur = i;\\n            while( cur%2==0 && d2c.find(cur/2)!=d2c.end()) {\\n                cur = cur/2;\\n            }\\n            int need_as_double = 0;\\n            for (; d2c.find(cur)!=d2c.end(); cur*=2) {        \\n                d2c[cur] -= need_as_double;\\n                if (d2c[cur]<0)\\n                    return false;\\n                need_as_double = d2c[cur];\\n                d2c.erase(cur);\\n            }\\n            if (need_as_double!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```c++\\n\\tbool canReorderDoubled(vector<int>& arr) {\\n        unordered_map<int, int> d2c;\\n        for (int i: arr)\\n            d2c[i]++;\\n        if (d2c.find(0)!=d2c.end()&&d2c[0]%2!=0)\\n            return false;\\n        d2c.erase(0);\\n        for (int i: arr) {\\n            if (d2c.find(i)==d2c.end())\\n                continue;\\n            int cur = i;\\n            while( cur%2==0 && d2c.find(cur/2)!=d2c.end()) {\\n                cur = cur/2;\\n            }\\n            int need_as_double = 0;\\n            for (; d2c.find(cur)!=d2c.end(); cur*=2) {        \\n                d2c[cur] -= need_as_double;\\n                if (d2c[cur]<0)\\n                    return false;\\n                need_as_double = d2c[cur];\\n                d2c.erase(cur);\\n            }\\n            if (need_as_double!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1402805,
                "title": "python-super-easy-o-nlogn-hash-map-solution",
                "content": "```\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        cnts = Counter(arr)\\n        arr = sorted(arr)\\n        \\n        for n in arr:\\n            if cnts[n] == 0:\\n                continue\\n            h = n*2\\n            if h in cnts and cnts[h] > 0:\\n                cnts[n]-=1\\n                cnts[h]-=1\\n        \\n        return all(v == 0 for v in cnts.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        cnts = Counter(arr)\\n        arr = sorted(arr)\\n        \\n        for n in arr:\\n            if cnts[n] == 0:\\n                continue\\n            h = n*2\\n            if h in cnts and cnts[h] > 0:\\n                cnts[n]-=1\\n                cnts[h]-=1\\n        \\n        return all(v == 0 for v in cnts.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398677,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] A) {\\n        Map<Integer, Integer> count = new TreeMap<>();\\n        for (int a : A)\\n            count.put(a, count.getOrDefault(a, 0) + 1);\\n        for (int x : count.keySet()) {\\n            if (count.get(x) == 0) continue;\\n            int want = x < 0 ? x / 2 : x * 2;\\n            if (x < 0 && x % 2 != 0 || count.get(x) > count.getOrDefault(want, 0))\\n                return false;\\n            count.put(want, count.get(want) - count.get(x));\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] A) {\\n        Map<Integer, Integer> count = new TreeMap<>();\\n        for (int a : A)\\n            count.put(a, count.getOrDefault(a, 0) + 1);\\n        for (int x : count.keySet()) {\\n            if (count.get(x) == 0) continue;\\n            int want = x < 0 ? x / 2 : x * 2;\\n            if (x < 0 && x % 2 != 0 || count.get(x) > count.getOrDefault(want, 0))\\n                return false;\\n            count.put(want, count.get(want) - count.get(x));\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398645,
                "title": "java-hashmap-solution",
                "content": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        Arrays.sort(arr);\\n        Map<Integer, Integer> hm = new HashMap<>();\\n        \\n        for(int i = 0; i < arr.length; i++){\\n            int num = arr[i], targetNum = Integer.MIN_VALUE;\\n            \\n            if(num < 0 || num % 2 == 0)\\n                targetNum = (num < 0) ? num * 2 : (num / 2);\\n            \\n            if(hm.containsKey(targetNum)){\\n                hm.put(targetNum, hm.get(targetNum) - 1);\\n                \\n                if(hm.get(targetNum) == 0){\\n                    hm.remove(targetNum);\\n                }\\n            } else {\\n                hm.put(num, hm.getOrDefault(num, 0) + 1);\\n            }\\n        }\\n        \\n        return hm.size() == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        Arrays.sort(arr);\\n        Map<Integer, Integer> hm = new HashMap<>();\\n        \\n        for(int i = 0; i < arr.length; i++){\\n            int num = arr[i], targetNum = Integer.MIN_VALUE;\\n            \\n            if(num < 0 || num % 2 == 0)\\n                targetNum = (num < 0) ? num * 2 : (num / 2);\\n            \\n            if(hm.containsKey(targetNum)){\\n                hm.put(targetNum, hm.get(targetNum) - 1);\\n                \\n                if(hm.get(targetNum) == 0){\\n                    hm.remove(targetNum);\\n                }\\n            } else {\\n                hm.put(num, hm.getOrDefault(num, 0) + 1);\\n            }\\n        }\\n        \\n        return hm.size() == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398464,
                "title": "c-easy-to-understand-fast-and-efficient",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    static bool comp(int &i,int &j)\\n    {\\n        return abs(i)<abs(j);\\n    }   \\n    bool canReorderDoubled(vector<int>& arr) {\\n      int n=arr.size();\\n        if(n%2!=0)\\n        {\\n            return false;\\n        } \\n        if(n==0)\\n        return true;\\n        sort(arr.begin(),arr.end(),comp);\\n        unordered_map<int,int> mp;\\n        for(int x:arr)\\n        {\\n            mp[x]++;\\n        }    \\n        for(int i:arr)\\n        {\\n            if(mp.find(i*2)!=mp.end())\\n            {\\n                if(mp[i*2]<mp[i])\\n                 return false;\\n                 mp[i*2]-=mp[i];\\n                 mp[i]=0;\\n            }   \\n        }    \\n        for(auto pr:mp)\\n        if(pr.second>0)\\n        return false;    \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(int &i,int &j)\\n    {\\n        return abs(i)<abs(j);\\n    }   \\n    bool canReorderDoubled(vector<int>& arr) {\\n      int n=arr.size();\\n        if(n%2!=0)\\n        {\\n            return false;\\n        } \\n        if(n==0)\\n        return true;\\n        sort(arr.begin(),arr.end(),comp);\\n        unordered_map<int,int> mp;\\n        for(int x:arr)\\n        {\\n            mp[x]++;\\n        }    \\n        for(int i:arr)\\n        {\\n            if(mp.find(i*2)!=mp.end())\\n            {\\n                if(mp[i*2]<mp[i])\\n                 return false;\\n                 mp[i*2]-=mp[i];\\n                 mp[i]=0;\\n            }   \\n        }    \\n        for(auto pr:mp)\\n        if(pr.second>0)\\n        return false;    \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398460,
                "title": "c-array-of-doubled-pairs-optimized-code-easy",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    static bool comp(int &i,int &j)\\n    {\\n        return abs(i)<abs(j);\\n    }   \\n    bool canReorderDoubled(vector<int>& arr) {\\n      int n=arr.size();\\n        if(n%2!=0)\\n        {\\n            return false;\\n        } \\n        if(n==0)\\n        return true;\\n        sort(arr.begin(),arr.end(),comp);\\n        unordered_map<int,int> mp;\\n        for(int x:arr)\\n        {\\n            mp[x]++;\\n        }    \\n        for(int i:arr)\\n        {\\n            if(mp.find(i*2)!=mp.end())\\n            {\\n                if(mp[i*2]<mp[i])\\n                 return false;\\n                 mp[i*2]-=mp[i];\\n                 mp[i]=0;\\n            }   \\n        }    \\n        for(auto pr:mp)\\n        if(pr.second>0)\\n        return false;    \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(int &i,int &j)\\n    {\\n        return abs(i)<abs(j);\\n    }   \\n    bool canReorderDoubled(vector<int>& arr) {\\n      int n=arr.size();\\n        if(n%2!=0)\\n        {\\n            return false;\\n        } \\n        if(n==0)\\n        return true;\\n        sort(arr.begin(),arr.end(),comp);\\n        unordered_map<int,int> mp;\\n        for(int x:arr)\\n        {\\n            mp[x]++;\\n        }    \\n        for(int i:arr)\\n        {\\n            if(mp.find(i*2)!=mp.end())\\n            {\\n                if(mp[i*2]<mp[i])\\n                 return false;\\n                 mp[i*2]-=mp[i];\\n                 mp[i]=0;\\n            }   \\n        }    \\n        for(auto pr:mp)\\n        if(pr.second>0)\\n        return false;    \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398249,
                "title": "python-o-n-space-time-bfs",
                "content": "Algorithm is as follows-\\nif there are an odd number of zeroes, the answer is false. Otherwise, find the numbers whose halves are not present in the input: they\\'ll have to be matched with their doubles.\\nThen, do a BFS-like traversal of the input elements. For each distinct number in the input, use a Counter to keep track how many input elements equal to that number have not yet been visited. Keep visiting such numbers `el`, for which all elements of the input array equal to half of `el` have already been visited. With this order of visiting, we know that for the answer to be true, `el` would have to be matched with its double. Therefore, mark the double as visited, too. Update the `frist` list which contains input elements that have not yet been visited, and whose halves have all been visited already:\\n- if there is another input element equal to `el` not yet visited, add that number back to `frist`\\n- if not, but there is still a double of that value unvisited, add the double\\n- if not, but there is `4 * el` not yet visited, then now that number does not have its half unvisited\\n\\nIf during a visit to a number we find that no input elements equal to double that element are not yet visited, then the answer is false. Otherwise, the answer is True.\\nO(n) time and O(n) space.\\nThe most interesting part of the complexity analysis is the loop. It is O(n), because when a number is added to `frist`, and later when it is visited, it has a positive `c[el]`. With each iteration, two of the positive values in `c` are decreased. The loop does not continue if a negative value is reached. The initial sum of values in `c` is `n`.\\n\\n\\n```python\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        c = Counter(arr)\\n        if 0 in c and c[0] & 1:\\n            return False\\n        del c[0]\\n        frist = [el for el in c if el & 1 or el // 2 not in c]\\n        while frist:\\n            el = frist.pop()\\n            c[el] -= 1\\n            c[el * 2] -= 1\\n            if c[el * 2] < 0:\\n                return False\\n            if c[el]:\\n                frist.append(el)\\n\\t\\t\\telif c[el * 2]:\\n                frist.append(el * 2)\\n            elif el * 4 in c and c[el * 4]:\\n                frist.append(el * 4)\\n        return True\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        c = Counter(arr)\\n        if 0 in c and c[0] & 1:\\n            return False\\n        del c[0]\\n        frist = [el for el in c if el & 1 or el // 2 not in c]\\n        while frist:\\n            el = frist.pop()\\n            c[el] -= 1\\n            c[el * 2] -= 1\\n            if c[el * 2] < 0:\\n                return False\\n            if c[el]:\\n                frist.append(el)\\n\\t\\t\\telif c[el * 2]:\\n                frist.append(el * 2)\\n            elif el * 4 in c and c[el * 4]:\\n                frist.append(el * 4)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398027,
                "title": "c-o-1-space-o-nlogn-time-commented-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==0){\\n            return true;\\n        }\\n        sort(arr.begin(),arr.end());\\n        //finding the index of first non-negative number in the sorted array so that we can operate\\n        //on negative and non-negative numbers separately.\\n        int idx=0;\\n        while(idx<n && arr[idx]<0){\\n            idx++;\\n        }\\n        //Let\\'s work on negative numbers\\n        //As they are sorted in non-decreasing order so will traverse backwards i.e from idx-1 to 0;\\n        //count1 represents the total number which are still left to be paired;\\n        //prev represent index of highest number(highest because numbers are negative) which is still left to paired;\\n        int count1=0;\\n        int prev;\\n        for(int i=idx-1;i>=0;i--){\\n            //if there is no element left for pairing then we have to pair this number i.e arr[i]\\n            if(count1==0){\\n                prev=i;\\n                count1=1;\\n                continue;\\n            }\\n            //All those indices which helped in pairing are overwritten to INT_MAX so that we don\\'t pair them again.\\n            //so if we came to an index which is overwritten to INT_MAX then we will iterate till we get a number which\\n            //left for pairing\\n            //prev-- because we are traversing backwards\\n            while(arr[prev]==INT_MAX){\\n                prev--;\\n            }\\n            \\n            int val=arr[prev];\\n            int req=2*val;\\n            //IF CASE:\\n            //if let\\'s say we have to pair -3 (i.e arr[prev]=-3) but we encounter numbers like -3,-4,-5 which will not pair\\n            //it but there is possibility that -6 will come after them so we are increasing the count1 for these numbers so\\n            //that in future we know they are left for pairing\\n            //ELSE IF CASE:\\n            //let\\'s say we get to an index whose entry or number present on it will pair the arr[prev] then we will decrement\\n            //count1 as 1 number got paired also decrement the prev so that we get to the index whose number is left to paired\\n            //also the number at current index i.e i is overwritten to INT_MAX so that in future we will not pair it again with \\n            //it\\'s double\\n            //ELSE CASE:\\n            //as numbers are sorted so let\\'s say if we want to pair number -1 the current number is -3 and we know the later\\n            //numbers will be less than or equal to -3 so they will not be able to pair -1 hence -1 will not paired till the \\n            //end hence we return false;\\n            if(abs(arr[i])<abs(req)){\\n                count1++;\\n            }\\n            else if(arr[i]==req){\\n                arr[i]=INT_MAX;\\n                count1--;\\n                prev--;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        //If there are still numbers left(negative) to paired then we will return false\\n        if(count1){\\n            return false;\\n        }\\n        //now we will check for zeros as they will be paired among themselves so number of zeroes must be even.\\n        int zeros=0;\\n        while(idx<n && arr[idx]==0){\\n            zeros++;\\n            idx++;\\n        }\\n        //If the number of zeros is odd then we return false\\n        if(zeros%2!=0){\\n            return false;\\n        }\\n        //Now we traverse the positive numbers in the same way we traverse negative numbers just one difference we have to \\n        //frontwards in this case as number are already sorted in increasing order not backwards as in the case of negative\\n        //numbers\\n        for(int i=idx;i<n;i++){\\n            if(count1==0){\\n                prev=i;\\n                count1=1;\\n                continue;\\n            }\\n            while(arr[prev]==INT_MAX){\\n                //remember here ++ not --(going front)\\n                prev++;\\n            }\\n            int val=arr[prev];\\n            int req=2*val;\\n            if(arr[i]<req){\\n                count1++;\\n            }\\n            else if(arr[i]==req){\\n                count1--;\\n                //remember here ++ not -- (going front)\\n                prev++;\\n                arr[i]=INT_MAX;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(count1){\\n            return false;\\n        }\\n        //In the end if every number get paired then we will return true;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==0){\\n            return true;\\n        }\\n        sort(arr.begin(),arr.end());\\n        //finding the index of first non-negative number in the sorted array so that we can operate\\n        //on negative and non-negative numbers separately.\\n        int idx=0;\\n        while(idx<n && arr[idx]<0){\\n            idx++;\\n        }\\n        //Let\\'s work on negative numbers\\n        //As they are sorted in non-decreasing order so will traverse backwards i.e from idx-1 to 0;\\n        //count1 represents the total number which are still left to be paired;\\n        //prev represent index of highest number(highest because numbers are negative) which is still left to paired;\\n        int count1=0;\\n        int prev;\\n        for(int i=idx-1;i>=0;i--){\\n            //if there is no element left for pairing then we have to pair this number i.e arr[i]\\n            if(count1==0){\\n                prev=i;\\n                count1=1;\\n                continue;\\n            }\\n            //All those indices which helped in pairing are overwritten to INT_MAX so that we don\\'t pair them again.\\n            //so if we came to an index which is overwritten to INT_MAX then we will iterate till we get a number which\\n            //left for pairing\\n            //prev-- because we are traversing backwards\\n            while(arr[prev]==INT_MAX){\\n                prev--;\\n            }\\n            \\n            int val=arr[prev];\\n            int req=2*val;\\n            //IF CASE:\\n            //if let\\'s say we have to pair -3 (i.e arr[prev]=-3) but we encounter numbers like -3,-4,-5 which will not pair\\n            //it but there is possibility that -6 will come after them so we are increasing the count1 for these numbers so\\n            //that in future we know they are left for pairing\\n            //ELSE IF CASE:\\n            //let\\'s say we get to an index whose entry or number present on it will pair the arr[prev] then we will decrement\\n            //count1 as 1 number got paired also decrement the prev so that we get to the index whose number is left to paired\\n            //also the number at current index i.e i is overwritten to INT_MAX so that in future we will not pair it again with \\n            //it\\'s double\\n            //ELSE CASE:\\n            //as numbers are sorted so let\\'s say if we want to pair number -1 the current number is -3 and we know the later\\n            //numbers will be less than or equal to -3 so they will not be able to pair -1 hence -1 will not paired till the \\n            //end hence we return false;\\n            if(abs(arr[i])<abs(req)){\\n                count1++;\\n            }\\n            else if(arr[i]==req){\\n                arr[i]=INT_MAX;\\n                count1--;\\n                prev--;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        //If there are still numbers left(negative) to paired then we will return false\\n        if(count1){\\n            return false;\\n        }\\n        //now we will check for zeros as they will be paired among themselves so number of zeroes must be even.\\n        int zeros=0;\\n        while(idx<n && arr[idx]==0){\\n            zeros++;\\n            idx++;\\n        }\\n        //If the number of zeros is odd then we return false\\n        if(zeros%2!=0){\\n            return false;\\n        }\\n        //Now we traverse the positive numbers in the same way we traverse negative numbers just one difference we have to \\n        //frontwards in this case as number are already sorted in increasing order not backwards as in the case of negative\\n        //numbers\\n        for(int i=idx;i<n;i++){\\n            if(count1==0){\\n                prev=i;\\n                count1=1;\\n                continue;\\n            }\\n            while(arr[prev]==INT_MAX){\\n                //remember here ++ not --(going front)\\n                prev++;\\n            }\\n            int val=arr[prev];\\n            int req=2*val;\\n            if(arr[i]<req){\\n                count1++;\\n            }\\n            else if(arr[i]==req){\\n                count1--;\\n                //remember here ++ not -- (going front)\\n                prev++;\\n                arr[i]=INT_MAX;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(count1){\\n            return false;\\n        }\\n        //In the end if every number get paired then we will return true;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397951,
                "title": "go-solution-beats-100",
                "content": "```\\nfunc canReorderDoubled(arr []int) bool {\\n\\tsort.Slice(arr, func(i, j int) bool {\\n\\t\\treturn abs(arr[i]) < abs(arr[j])\\n\\t})\\n\\n\\tm := map[int]int{}\\n\\tfor _, n := range arr {\\n\\t\\tif x, ok := m[n/2]; ok && x != 0 && n%2 == 0 {\\n\\t\\t\\tm[n/2]--\\n\\t\\t} else {\\n\\t\\t\\tm[n]++\\n\\t\\t}\\n\\t}\\n\\n\\tfor _, v := range m {\\n\\t\\tif v != 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\nfunc abs(a int) int {\\n\\tif a >= 0 {\\n\\t\\treturn a\\n\\t}\\n\\treturn -a\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc canReorderDoubled(arr []int) bool {\\n\\tsort.Slice(arr, func(i, j int) bool {\\n\\t\\treturn abs(arr[i]) < abs(arr[j])\\n\\t})\\n\\n\\tm := map[int]int{}\\n\\tfor _, n := range arr {\\n\\t\\tif x, ok := m[n/2]; ok && x != 0 && n%2 == 0 {\\n\\t\\t\\tm[n/2]--\\n\\t\\t} else {\\n\\t\\t\\tm[n]++\\n\\t\\t}\\n\\t}\\n\\n\\tfor _, v := range m {\\n\\t\\tif v != 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\nfunc abs(a int) int {\\n\\tif a >= 0 {\\n\\t\\treturn a\\n\\t}\\n\\treturn -a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1397892,
                "title": "c-o-n-log-n-multiset-clean-easy-to-understand",
                "content": "The idea is for each i in range [0, n/2), there should exist an element arr[2*i + 1], such that (2 * arr[2*i] == arr[2*i+1]). (only if arr[i] >= 0).\\n**Note** for a[i] < 0, the equation will be  (arr[2*i] == 2 * arr[2*i+1].\\n\\nSo if we sort the given array than for each arr[i] (given, i < n/2) the above conditions should satisfy. And if it does\\'nt simply return false. \\n\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        multiset<int> ms;\\n        for(int i=0; i<arr.size(); i++){\\n            ms.insert(arr[i]);\\n        }\\n        int n = arr.size();\\n        for(int i=0; i<n/2; i++){\\n            auto it = ms.begin();\\n            int t = *it;\\n            ms.erase(it);\\n            if(t >= 0){\\n                auto it2 = ms.find(2 * t);\\n                if(it2 == ms.end()) return false;\\n                else ms.erase(it2);\\n            }\\n            else if(t < 0){\\n                if(t % 2 != 0) return false;\\n                auto it2 = ms.find((t) / 2);\\n                if(it2 == ms.end()) return false;\\n                else ms.erase(it2);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        multiset<int> ms;\\n        for(int i=0; i<arr.size(); i++){\\n            ms.insert(arr[i]);\\n        }\\n        int n = arr.size();\\n        for(int i=0; i<n/2; i++){\\n            auto it = ms.begin();\\n            int t = *it;\\n            ms.erase(it);\\n            if(t >= 0){\\n                auto it2 = ms.find(2 * t);\\n                if(it2 == ms.end()) return false;\\n                else ms.erase(it2);\\n            }\\n            else if(t < 0){\\n                if(t % 2 != 0) return false;\\n                auto it2 = ms.find((t) / 2);\\n                if(it2 == ms.end()) return false;\\n                else ms.erase(it2);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397677,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    bool canReorderDoubled(vector<int>& arr) \\n    { \\n        unordered_map<int,int> cnt;\\n        auto comp = [&](const int a, const int b)\\n        {\\n            return abs(a)<abs(b);    \\n        }; \\n        sort(arr.begin(), arr.end(), comp);\\n        for(auto num:arr){\\n            cnt[num]++;\\n        }\\n        \\n        for(auto num:arr)\\n        {\\n            if(cnt[num]==0)continue;\\n            if(cnt[2*num]==0)return false;\\n            cnt[num]--;\\n            cnt[2*num]--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    bool canReorderDoubled(vector<int>& arr) \\n    { \\n        unordered_map<int,int> cnt;\\n        auto comp = [&](const int a, const int b)\\n        {\\n            return abs(a)<abs(b);    \\n        }; \\n        sort(arr.begin(), arr.end(), comp);\\n        for(auto num:arr){\\n            cnt[num]++;\\n        }\\n        \\n        for(auto num:arr)\\n        {\\n            if(cnt[num]==0)continue;\\n            if(cnt[2*num]==0)return false;\\n            cnt[num]--;\\n            cnt[2*num]--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397609,
                "title": "array-of-doubled-pairs-java-simple-solution-using-sorting",
                "content": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        Arrays.sort(arr);\\n        \\n        Map<Integer, Integer> hm = new HashMap<>();\\n        \\n        for(int num: arr){\\n            hm.put(num, hm.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        for(int num: arr){\\n            if(hm.get(num) == 0)\\n                continue;\\n            \\n            if(num < 0 && num % 2 != 0)\\n                return false;\\n            \\n            int target = num < 0 ? num/2 : num*2;\\n            \\n            if(hm.getOrDefault(target, 0) > 0){\\n                hm.put(num, hm.get(num) - 1);\\n                hm.put(target, hm.get(target) - 1);\\n            }else{\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        Arrays.sort(arr);\\n        \\n        Map<Integer, Integer> hm = new HashMap<>();\\n        \\n        for(int num: arr){\\n            hm.put(num, hm.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        for(int num: arr){\\n            if(hm.get(num) == 0)\\n                continue;\\n            \\n            if(num < 0 && num % 2 != 0)\\n                return false;\\n            \\n            int target = num < 0 ? num/2 : num*2;\\n            \\n            if(hm.getOrDefault(target, 0) > 0){\\n                hm.put(num, hm.get(num) - 1);\\n                hm.put(target, hm.get(target) - 1);\\n            }else{\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397605,
                "title": "array-of-doubled-pairs-simple-java-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean canReorderDoubled(int[] ar) {\\n        \\n        if(ar.length==0)return true;\\n        Map<Integer,Integer> freq=new HashMap<>();\\n        \\n        for(int i=0;i<ar.length;i++)\\n            freq.put(ar[i],freq.getOrDefault(ar[i],0)+1);\\n        \\n        Integer[] arr=new Integer[ar.length];\\n        for(int i=0;i<ar.length;i++)\\n            arr[i]=ar[i];\\n        Arrays.sort(arr,(a,b)->{return Math.abs(a)-Math.abs(b);});\\n        \\n        for(Integer el:arr)\\n        {\\n            if(freq.get(el)==0) continue;\\n\\n            if(freq.getOrDefault(el*2,0)==0) return false;\\n            \\n            \\n            freq.put(el,freq.get(el)-1);\\n            freq.put(el*2,freq.get(el*2)-1);\\n                \\n        }\\n        return true;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canReorderDoubled(int[] ar) {\\n        \\n        if(ar.length==0)return true;\\n        Map<Integer,Integer> freq=new HashMap<>();\\n        \\n        for(int i=0;i<ar.length;i++)\\n            freq.put(ar[i],freq.getOrDefault(ar[i],0)+1);\\n        \\n        Integer[] arr=new Integer[ar.length];\\n        for(int i=0;i<ar.length;i++)\\n            arr[i]=ar[i];\\n        Arrays.sort(arr,(a,b)->{return Math.abs(a)-Math.abs(b);}",
                "codeTag": "Java"
            },
            {
                "id": 1397228,
                "title": "c-sort-hash-table-solution-o-nlogn",
                "content": "Runtime: 148 ms, faster than 65.68% of C++ online submissions for Array of Doubled Pairs.\\nMemory Usage: 58 MB, less than 59.39% of C++ online submissions for Array of Doubled Pairs.\\n\\n\\n```\\nWe use unorderedMap to track the count of each number in the array.\\nAs we have to process both +ve and -ve value so we sort the array in ascending order.\\nSo doubled negative value will be at far left and doubled positive value will be at far right.\\nAlso we find the doubled value of negative and odd value as target in the track Map.\\nOtherwise we just check the half the positive even value as target in the track Map.\\nCount the number of target found in the Map and then return true for N/2 count.\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        \\n        // sort array in ascending order\\n        sort(arr.begin(),arr.end());\\n        \\n        // track the count of the array elements\\n        unordered_map<int,int>track;\\n        \\n        // count of double or half value found in the track\\n        int match = 0;\\n        int target;\\n        int n = arr.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            // target => current value * 2 in case of negative and odd value\\n            // otherwise for positive value, target is half of current value\\n            if((arr[i]<0 || (arr[i]&1)))target = arr[i]*2;\\n            else target = arr[i]/2;\\n            \\n            // target exists in track, so decrement track count and increment match\\n            if(track[target])\\n            {\\n                track[target]--;\\n                match++;\\n            }\\n            else track[arr[i]]++;   // otherwise add track count of current value\\n        }\\n        \\n        // total target found == half of array in case of possible double array\\n        return match==n/2;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nWe use unorderedMap to track the count of each number in the array.\\nAs we have to process both +ve and -ve value so we sort the array in ascending order.\\nSo doubled negative value will be at far left and doubled positive value will be at far right.\\nAlso we find the doubled value of negative and odd value as target in the track Map.\\nOtherwise we just check the half the positive even value as target in the track Map.\\nCount the number of target found in the Map and then return true for N/2 count.\\n```\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        \\n        // sort array in ascending order\\n        sort(arr.begin(),arr.end());\\n        \\n        // track the count of the array elements\\n        unordered_map<int,int>track;\\n        \\n        // count of double or half value found in the track\\n        int match = 0;\\n        int target;\\n        int n = arr.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            // target => current value * 2 in case of negative and odd value\\n            // otherwise for positive value, target is half of current value\\n            if((arr[i]<0 || (arr[i]&1)))target = arr[i]*2;\\n            else target = arr[i]/2;\\n            \\n            // target exists in track, so decrement track count and increment match\\n            if(track[target])\\n            {\\n                track[target]--;\\n                match++;\\n            }\\n            else track[arr[i]]++;   // otherwise add track count of current value\\n        }\\n        \\n        // total target found == half of array in case of possible double array\\n        return match==n/2;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397108,
                "title": "javascript-solution-faster-than-100-and-mem-efficient-100",
                "content": "```\\nvar canReorderDoubled = function(arr) {\\n    let vc = new Map();\\n    \\n    for(var i = 0; i < arr.length; i++){\\n        vc.set(arr[i], (vc.get(arr[i])|0)+1);\\n    }\\n    \\n    vc = Array.from(vc.entries());\\n    vc.sort((a,b)=>a[0]-b[0]);\\n    \\n    vc = new Map(vc);\\n    for(var [val, count] of vc){\\n        if(val > 0){\\n            if(count === 0 || (vc.has(2*val) && vc.get(2*val) >= count)){\\n                if(count > 0){\\n                    vc.set(2*val, vc.get(2*val)-count);\\n                }\\n            }else{\\n                return false;\\n            }\\n        }else if(val < 0){\\n            if(count === 0 || (vc.has(val/2) && vc.get(val/2) >= count)){\\n                if(count > 0){\\n                    vc.set(val/2, vc.get(val/2)-count);   \\n                }\\n            }else{\\n                return false;\\n            }\\n        }else{\\n            if(count%2 === 1){\\n                return false;\\n            }\\n        }\\n        \\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar canReorderDoubled = function(arr) {\\n    let vc = new Map();\\n    \\n    for(var i = 0; i < arr.length; i++){\\n        vc.set(arr[i], (vc.get(arr[i])|0)+1);\\n    }\\n    \\n    vc = Array.from(vc.entries());\\n    vc.sort((a,b)=>a[0]-b[0]);\\n    \\n    vc = new Map(vc);\\n    for(var [val, count] of vc){\\n        if(val > 0){\\n            if(count === 0 || (vc.has(2*val) && vc.get(2*val) >= count)){\\n                if(count > 0){\\n                    vc.set(2*val, vc.get(2*val)-count);\\n                }\\n            }else{\\n                return false;\\n            }\\n        }else if(val < 0){\\n            if(count === 0 || (vc.has(val/2) && vc.get(val/2) >= count)){\\n                if(count > 0){\\n                    vc.set(val/2, vc.get(val/2)-count);   \\n                }\\n            }else{\\n                return false;\\n            }\\n        }else{\\n            if(count%2 === 1){\\n                return false;\\n            }\\n        }\\n        \\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1397072,
                "title": "array-of-doubled-pairs-pythion-o-nlogn-time-complexity-and-o-n-space-easy-using-dictionary",
                "content": "```\\n\\nclass Solution(object):\\n    def canReorderDoubled(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        arr.sort()\\n        \\n        \\n        d = {}\\n        \\n        for i in arr:\\n            d[float(i)] = d.get(float(i),0)+1\\n            \\n        \\n        for i in arr:\\n            i = float(i)\\n            if d[i]==0:\\n                continue\\n            \\n            else:\\n                \\n                d[i] -=1\\n                if(i>=0):\\n                    if(d.get(2*i,0)==0):\\n                        return False\\n                    else:\\n                        d[2*i]-=1\\n                else:\\n                    \\n                    if(d.get(i/2,0)==0):\\n                        return False\\n                    else:\\n                        d[i/2]-=1\\n                       \\n                        \\n                        \\n                    \\n        return True\\n                \\n\\t\\t\\t\\t\\n\\t",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def canReorderDoubled(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        arr.sort()\\n        \\n        \\n        d = {}",
                "codeTag": "Java"
            },
            {
                "id": 1397070,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def canReorderDoubled(self, arr):\\n        lookup = {}\\n        for num in arr:\\n            if num in lookup:\\n                lookup[num] += 1\\n            else:\\n                lookup[num] = 1\\n\\n        for num in sorted(arr, key=abs):\\n            if lookup[num] == 0:\\n                continue\\n            if 2 * num not in lookup or lookup[2 * num] == 0:\\n                return False\\n            lookup[num] -= 1\\n            lookup[2 * num] -= 1\\n        return True\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canReorderDoubled(self, arr):\\n        lookup = {}\\n        for num in arr:\\n            if num in lookup:\\n                lookup[num] += 1\\n            else:\\n                lookup[num] = 1\\n\\n        for num in sorted(arr, key=abs):\\n            if lookup[num] == 0:\\n                continue\\n            if 2 * num not in lookup or lookup[2 * num] == 0:\\n                return False\\n            lookup[num] -= 1\\n            lookup[2 * num] -= 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397039,
                "title": "a-solution-without-sorting-o-n-spaces-time-complexity-explained-javascript-100ms-beats-100",
                "content": "# Time complexity analyzation\\n> Update at *Thu, 12 Aug 2021 04:04:42 GMT*\\n\\nThe complexity of the solution is `O(N log M)` where N is the length of the array and M is the largest absolute value of the \"*left values*\".\\n\\nTo understand what the **left values** are, consider the problem in a \"pairing\" way.\\n\\nTo satisfy `arr[2*i+1] = 2*arr[2*i]` for each `i` where `0 \\u2264 i < len(arr)/2`, actually the elements of the array is paired into `(arr[2*i], arr[2*i+1])` by `i`.\\n\\nIf we called `arr[2*i]` the *left value* and `arr[2*i+1]` the *right value*, then the M in the time complexity becomes the **largest absolute value of left values** because in each loop it will pick up all odd values (left values) and their doubled values (right values), therefore in the last loop there must exist the last left value (and its doubled) to be picked up.\\n\\n## Difference between this solution and those with sorting\\n\\nThis solution is based on that **odd values must be the left value** while solutions with sorting are based on that **the smallest absolute value in the array must be the left value**.\\n\\n\\n## The best case\\n\\nThe best case of this solution is also `O(N)` where all left values are odd values.\\n\\n## The worst case\\n\\nConsider the following constraints given by the problem,\\n- `2 <= arr.length <= 3 * 10^4`\\n- `-10^5 <= arr[i] <= 10^5`\\n\\nWe can learn that the maximum value of N is `3 * 10^4` while M is `5 * 10^4` (so its right value can follow the constraints), therefore in the worst case, this solution is slower than those O(N log N) ones.\\n\\n## Conclusion\\n\\nThis solution performs validaity check following the given constraint, `arr[2*i+1] = 2*arr[2*i]`, during the process of the `O(N log M)` part, which should return as soon as possible once the first element fails the constraint.\\n\\nWhile in those sorting solutions, sorting part must be done before performing any check.\\n\\nTherefore in average case of this problem, I think that\\'s why my solution (slightly) performs better than those with sorting.\\n\\n(The conclusion is based on the constraint `-10^5 <= arr[i] <= 10^5`)\\n\\n```\\nfunction reduceDoubleCount (map, n, count) {\\n  const doubled = n * 2\\n  const diff = (map.get(doubled) ?? 0) - count\\n  if (diff < 0) return false\\n  else if (diff === 0) map.delete(doubled)\\n  else map.set(doubled, diff)\\n  return true\\n}\\n\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nvar canReorderDoubled = function (arr) {\\n  const counters = new Map()\\n  const reduceDouble = reduceDoubleCount.bind(null, counters)\\n  for (const n of arr) { counters.set(n, (counters.get(n) ?? 0) + 1) }\\n  while (counters.size > 0) {\\n    // remove odds and their doubled values\\n    for (const [n, count] of counters) {\\n      if (n === 0 || n % 2 !== 0 /* 1 or -1 */) {\\n        if (!reduceDouble(n, count)) { return false }\\n        counters.delete(n)\\n      }\\n    }\\n    // all values left are even, divide them by 2\\n    const entries = []\\n    for (const [n, count] of counters) {\\n      counters.delete(n)\\n      entries.push([n / 2, count])\\n    }\\n    for (const [n, count] of entries) {\\n      counters.set(n, count)\\n    }\\n  }\\n  return true\\n}\\n\\n```\\n\\n> More detailed explanation can be found here written in Chinese.\\n> https://medium.com/cow-say/954-array-of-doubled-pairs-aea486c9b470\\n>",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction reduceDoubleCount (map, n, count) {\\n  const doubled = n * 2\\n  const diff = (map.get(doubled) ?? 0) - count\\n  if (diff < 0) return false\\n  else if (diff === 0) map.delete(doubled)\\n  else map.set(doubled, diff)\\n  return true\\n}\\n\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nvar canReorderDoubled = function (arr) {\\n  const counters = new Map()\\n  const reduceDouble = reduceDoubleCount.bind(null, counters)\\n  for (const n of arr) { counters.set(n, (counters.get(n) ?? 0) + 1) }\\n  while (counters.size > 0) {\\n    // remove odds and their doubled values\\n    for (const [n, count] of counters) {\\n      if (n === 0 || n % 2 !== 0 /* 1 or -1 */) {\\n        if (!reduceDouble(n, count)) { return false }\\n        counters.delete(n)\\n      }\\n    }\\n    // all values left are even, divide them by 2\\n    const entries = []\\n    for (const [n, count] of counters) {\\n      counters.delete(n)\\n      entries.push([n / 2, count])\\n    }\\n    for (const [n, count] of entries) {\\n      counters.set(n, count)\\n    }\\n  }\\n  return true\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1397016,
                "title": "my-java-solution-using-treemap-and-checking-x-2-for-neg-and-2-x-for-positive",
                "content": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        if (arr == null || arr.length == 0) {\\n            return true;\\n        }\\n        Map<Integer, Integer> map = new TreeMap<>();\\n        for (int number : arr) {\\n            map.put(number, map.getOrDefault(number, 0) + 1);\\n        }\\n        for (int key : map.keySet()) {\\n            if (map.get(key) == 0)\\n                continue;\\n            // for negative number we look for x/2 and for positive number we look for x * 2\\n            int target = key >= 0 ? key * 2 : key / 2;\\n            if (key < 0 && key % 2 != 0 || map.get(key) > map.getOrDefault(target, 0))\\n                return false;\\n            map.put(target, map.get(target) - map.get(key));\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        if (arr == null || arr.length == 0) {\\n            return true;\\n        }\\n        Map<Integer, Integer> map = new TreeMap<>();\\n        for (int number : arr) {\\n            map.put(number, map.getOrDefault(number, 0) + 1);\\n        }\\n        for (int key : map.keySet()) {\\n            if (map.get(key) == 0)\\n                continue;\\n            // for negative number we look for x/2 and for positive number we look for x * 2\\n            int target = key >= 0 ? key * 2 : key / 2;\\n            if (key < 0 && key % 2 != 0 || map.get(key) > map.getOrDefault(target, 0))\\n                return false;\\n            map.put(target, map.get(target) - map.get(key));\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396927,
                "title": "python-o-n-lg-n-by-dict-and-sort-w-comment",
                "content": "Python O(n lg n) by dict and sort \\n\\n---\\n\\n```\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        \\n        # key: number\\n        # value: occurrence\\n        num_occ_dict = Counter(arr)\\n        \\n        # scan each number in arr, and sorted in absolute value\\n        for number in sorted(arr, key = abs ):\\n            \\n            # find all double pairs as many as possible\\n            while num_occ_dict[number] > 0 and num_occ_dict[2*number] > 0:\\n                \\n                # update occurrence of current double pair\\n                num_occ_dict[number] -= 1\\n                num_occ_dict[2*number] -= 1 \\n        \\n        # Accept if all number are paired\\n        # Reject, otherwise\\n        return all( occurrence == 0 for occurrence in num_occ_dict.values() )\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about sorted()](https://docs.python.org/3/library/functions.html#sorted)\\n\\n[2] [Python official docs about specialized dictionary Counter()](https://docs.python.org/3/library/collections.html#collections.Counter)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        \\n        # key: number\\n        # value: occurrence\\n        num_occ_dict = Counter(arr)\\n        \\n        # scan each number in arr, and sorted in absolute value\\n        for number in sorted(arr, key = abs ):\\n            \\n            # find all double pairs as many as possible\\n            while num_occ_dict[number] > 0 and num_occ_dict[2*number] > 0:\\n                \\n                # update occurrence of current double pair\\n                num_occ_dict[number] -= 1\\n                num_occ_dict[2*number] -= 1 \\n        \\n        # Accept if all number are paired\\n        # Reject, otherwise\\n        return all( occurrence == 0 for occurrence in num_occ_dict.values() )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396858,
                "title": "array-of-doubled-pairs-c-faster-than-50",
                "content": "**Key observations:**\\narr[2 * i + 1] = 2 * arr[2 * i] this condition here means that whether we can divide the entire array into pairs (a, b) where:\\n\\n\\tif a, b >= 0:\\n\\t\\ta <= b && 2 * a == b\\n\\telse:\\n\\t\\ta > b && 2 * a == b\\n\\t\\nWe will first sort the given input and check for every num[i]:\\n```\\n\\tif (num[i] >= 0) whether we have encountered some number num[i] / 2 (do check for num[i] % 2 == 0)\\n\\t\\tif we have encountered such a number then increase the number of pairs by one and reduce the count of (num[i] / 2) in the map\\n\\t\\telse increase the count of num[i] by one\\n\\telse if (num[i] < 0) whether we have encountered some number num[i] * 2\\n\\t\\tif we have encountered such a number then increase the number of pairs by one and reduce the count of nums[i] * 2 in the map \\n\\t\\telse increase the count of num[i] by one\\n```\\nin the end check whether all the numbers have been included in the pairs or not\\n\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        unordered_map<int, int> my_map;\\n        sort(arr.begin(), arr.end());\\n        int pairs = 0;\\n        for(int i = 0; i < arr.size(); i++){\\n            if(arr[i] < 0 && my_map.find(2 * arr[i]) != my_map.end()){\\n                 my_map[2 * arr[i]]--;\\n                if(my_map[2 * arr[i]] == 0) my_map.erase(2 * arr[i]);\\n                pairs++;   \\n            }\\n            else if(arr[i] >= 0 && arr[i] % 2 == 0 && my_map.find(arr[i] / 2) != my_map.end()){\\n                 my_map[arr[i] / 2]--;\\n                if(my_map[arr[i] / 2] == 0) my_map.erase(arr[i] / 2);\\n                pairs++;\\n            }\\n            else{\\n                my_map[arr[i]]++;\\n            }\\n        }\\n        return pairs == arr.size() / 2;\\n    }\\n};\\n```\\n\\n\\t",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n\\tif (num[i] >= 0) whether we have encountered some number num[i] / 2 (do check for num[i] % 2 == 0)\\n\\t\\tif we have encountered such a number then increase the number of pairs by one and reduce the count of (num[i] / 2) in the map\\n\\t\\telse increase the count of num[i] by one\\n\\telse if (num[i] < 0) whether we have encountered some number num[i] * 2\\n\\t\\tif we have encountered such a number then increase the number of pairs by one and reduce the count of nums[i] * 2 in the map \\n\\t\\telse increase the count of num[i] by one\\n```\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        unordered_map<int, int> my_map;\\n        sort(arr.begin(), arr.end());\\n        int pairs = 0;\\n        for(int i = 0; i < arr.size(); i++){\\n            if(arr[i] < 0 && my_map.find(2 * arr[i]) != my_map.end()){\\n                 my_map[2 * arr[i]]--;\\n                if(my_map[2 * arr[i]] == 0) my_map.erase(2 * arr[i]);\\n                pairs++;   \\n            }\\n            else if(arr[i] >= 0 && arr[i] % 2 == 0 && my_map.find(arr[i] / 2) != my_map.end()){\\n                 my_map[arr[i] / 2]--;\\n                if(my_map[arr[i] / 2] == 0) my_map.erase(arr[i] / 2);\\n                pairs++;\\n            }\\n            else{\\n                my_map[arr[i]]++;\\n            }\\n        }\\n        return pairs == arr.size() / 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348626,
                "title": "solved-in-o-n-but-approch-is-wrong-weak-test-cases",
                "content": "**Hopefully leetcode improve there test cases \\nThis code got submitted but failed at \\n[16,64,32,8,4,128,256,512,1024,2]**\\n\\nCode:-\\n```\\n class Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        int n = arr.length;\\n        for (int i = 0; i < n; i++) {\\n            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] % 2 == -1 || arr[i] % 2 == 1) {\\n                Integer count1 = map.get(arr[i]);\\n                Integer count2 = map.get(2 * arr[i]);\\n                if (count2 == null || count2 == 0) {\\n                    return false;\\n                }\\n                map.put(arr[i], count1 - 1);\\n                map.put(2 * arr[i], count2 - 1);\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] % 2 == 0) {\\n                Integer count1 = map.get(arr[i]);\\n                Integer count2 = map.get(2 * arr[i]);\\n                Integer count3 = map.get(arr[i] / 2);\\n                if (count1 != 0) {\\n                    if (count2 != null && count2 != 0 && (count3 == null || count3 == 0)) {\\n                        map.put(arr[i], count1 - 1);\\n                        map.put(2 * arr[i], count2 - 1);\\n                        if (arr[i] == 0) {\\n                            map.put(0, count1 - 2);\\n                        }\\n                    } else if (count3 != null && count3 != 0 && (count2 == null || count2 == 0)) {\\n                        map.put(arr[i], count1 - 1);\\n                        map.put(arr[i] / 2, count3 - 1);\\n                        if (arr[i] == 0) {\\n                            map.put(0, count1 - 2);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            Integer count1 = map.get(arr[i]);\\n            if (count1 != 0) {\\n                Integer count2 = map.get(2 * arr[i]);\\n                Integer count3 = map.get(arr[i] / 2);\\n                if (count2 != null && count2 != 0) {\\n                    map.put(arr[i], count1 - 1);\\n                    map.put(2 * arr[i], count2 - 1);\\n                    if (arr[i] == 0) {\\n                        map.put(0, count1 - 2);\\n                    }\\n                } else if (count3 != null && count3 != 0) {\\n                    map.put(arr[i], count1 - 1);\\n                    map.put(arr[i] / 2, count3 - 1);\\n                    if (arr[i] == 0) {\\n                        map.put(0, count1 - 2);\\n                    }\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n class Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        int n = arr.length;\\n        for (int i = 0; i < n; i++) {\\n            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] % 2 == -1 || arr[i] % 2 == 1) {\\n                Integer count1 = map.get(arr[i]);\\n                Integer count2 = map.get(2 * arr[i]);\\n                if (count2 == null || count2 == 0) {\\n                    return false;\\n                }\\n                map.put(arr[i], count1 - 1);\\n                map.put(2 * arr[i], count2 - 1);\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] % 2 == 0) {\\n                Integer count1 = map.get(arr[i]);\\n                Integer count2 = map.get(2 * arr[i]);\\n                Integer count3 = map.get(arr[i] / 2);\\n                if (count1 != 0) {\\n                    if (count2 != null && count2 != 0 && (count3 == null || count3 == 0)) {\\n                        map.put(arr[i], count1 - 1);\\n                        map.put(2 * arr[i], count2 - 1);\\n                        if (arr[i] == 0) {\\n                            map.put(0, count1 - 2);\\n                        }\\n                    } else if (count3 != null && count3 != 0 && (count2 == null || count2 == 0)) {\\n                        map.put(arr[i], count1 - 1);\\n                        map.put(arr[i] / 2, count3 - 1);\\n                        if (arr[i] == 0) {\\n                            map.put(0, count1 - 2);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            Integer count1 = map.get(arr[i]);\\n            if (count1 != 0) {\\n                Integer count2 = map.get(2 * arr[i]);\\n                Integer count3 = map.get(arr[i] / 2);\\n                if (count2 != null && count2 != 0) {\\n                    map.put(arr[i], count1 - 1);\\n                    map.put(2 * arr[i], count2 - 1);\\n                    if (arr[i] == 0) {\\n                        map.put(0, count1 - 2);\\n                    }\\n                } else if (count3 != null && count3 != 0) {\\n                    map.put(arr[i], count1 - 1);\\n                    map.put(arr[i] / 2, count3 - 1);\\n                    if (arr[i] == 0) {\\n                        map.put(0, count1 - 2);\\n                    }\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214532,
                "title": "c-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool compareAbs(int x1,int x2){\\n        return abs(x1)<abs(x2);\\n    }\\n    \\n    bool canReorderDoubled(vector<int>& arr) {\\n        unordered_map<int,int> count;\\n        for(int x : arr){\\n            if(count.find(x)!=count.end()){\\n                count[x]++;\\n            }\\n            else{\\n                count[x]=1;\\n            }\\n        }\\n        \\n        sort(arr.begin(),arr.end(),compareAbs);\\n        \\n        for(int x : arr){\\n            if(count[x]==0){\\n                continue;\\n            }\\n            if(count.find(2*x)==count.end() || count[2*x]==0){\\n                return false;\\n            }\\n            count[x]--;\\n            count[2*x]--;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compareAbs(int x1,int x2){\\n        return abs(x1)<abs(x2);\\n    }\\n    \\n    bool canReorderDoubled(vector<int>& arr) {\\n        unordered_map<int,int> count;\\n        for(int x : arr){\\n            if(count.find(x)!=count.end()){\\n                count[x]++;\\n            }\\n            else{\\n                count[x]=1;\\n            }\\n        }\\n        \\n        sort(arr.begin(),arr.end(),compareAbs);\\n        \\n        for(int x : arr){\\n            if(count[x]==0){\\n                continue;\\n            }\\n            if(count.find(2*x)==count.end() || count[2*x]==0){\\n                return false;\\n            }\\n            count[x]--;\\n            count[2*x]--;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201800,
                "title": "java-o-nlogn-clean-code",
                "content": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        // 1. Sort array\\n        // 2. 1-pass count with hash map and greedily group values of current\\'s half or double (for negative)\\n        Arrays.sort(arr);\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int a : arr) {\\n            if (a < 0 && count.containsKey(a * 2)) {\\n                int c = count.get(a * 2);\\n                if (c == 1) {\\n                    count.remove(a * 2);\\n                } else {\\n                    count.put(a * 2, c - 1);\\n                }\\n            } else if (a >= 0 && a % 2 == 0 && count.containsKey(a / 2)) {\\n                int c = count.get(a / 2);\\n                if (c == 1) {\\n                    count.remove(a / 2);\\n                } else {\\n                    count.put(a / 2, c - 1);\\n                }\\n            } else {\\n                count.put(a, 1 + count.getOrDefault(a, 0));\\n            }\\n        }\\n        return count.size() == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        // 1. Sort array\\n        // 2. 1-pass count with hash map and greedily group values of current\\'s half or double (for negative)\\n        Arrays.sort(arr);\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int a : arr) {\\n            if (a < 0 && count.containsKey(a * 2)) {\\n                int c = count.get(a * 2);\\n                if (c == 1) {\\n                    count.remove(a * 2);\\n                } else {\\n                    count.put(a * 2, c - 1);\\n                }\\n            } else if (a >= 0 && a % 2 == 0 && count.containsKey(a / 2)) {\\n                int c = count.get(a / 2);\\n                if (c == 1) {\\n                    count.remove(a / 2);\\n                } else {\\n                    count.put(a / 2, c - 1);\\n                }\\n            } else {\\n                count.put(a, 1 + count.getOrDefault(a, 0));\\n            }\\n        }\\n        return count.size() == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130324,
                "title": "java-hashmap-and-sorting-o-nlogn",
                "content": "class Solution {\\n    public boolean canReorderDoubled(int[] ar) {\\n\\t\\n        Integer arr[]=new Integer[ar.length];\\n        for(int i=0;i<arr.length;i++)arr[i]=ar[i];\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        Arrays.sort(arr, (a,b)->{\\n            return Math.abs(a)-Math.abs(b);\\n        });\\n        \\n        for(int i=0;i<arr.length;i++)\\n            map.put(arr[i],map.getOrDefault(arr[i],0)+1);\\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(map.get(arr[i])==0)\\n                continue;\\n            else if(!map.containsKey(2*arr[i]) || map.get(2*arr[i])==0)\\n                return false;\\n            else\\n            {\\n                map.put(arr[i],map.get(arr[i])-1);\\n                map.put(2*arr[i],map.get(2*arr[i])-1);          \\n            }\\n        }\\n      \\n     return true;   \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canReorderDoubled(int[] ar) {\\n\\t\\n        Integer arr[]=new Integer[ar.length];\\n        for(int i=0;i<arr.length;i++)arr[i]=ar[i];\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        Arrays.sort(arr, (a,b)->{\\n            return Math.abs(a)-Math.abs(b);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1046370,
                "title": "o-nlogn-sorting-hashmap-c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) { \\n        map<int,int> mp;\\n        for(int i=0; i<arr.size(); i++) mp[arr[i]]++;\\n        sort(arr.begin(),arr.end());  // sort , a will come first than 2*a \\n        mp.erase(0);\\n        for(int i=0; i<arr.size(); i++) {\\n             if(mp.count(arr[i]) && mp.count(arr[i]*2)) {\\n               int x=min(mp[arr[i]],mp[arr[i]*2]);\\n                    mp[arr[i]]-=x;\\n                    mp[arr[i]*2]-=x;           // remove the min. freq. of a and 2a in common \\n             }\\n        }\\n        int ans=0;\\n        for(pair<int,int> p : mp)  ans+=p.second; \\n        cout<<endl;\\n        return (ans==0);      /* if the sum of frequency is zero,the array is symmetric  Numof(a)==Numof(2*a)  */                                               \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) { \\n        map<int,int> mp;\\n        for(int i=0; i<arr.size(); i++) mp[arr[i]]++;\\n        sort(arr.begin(),arr.end());  // sort , a will come first than 2*a \\n        mp.erase(0);\\n        for(int i=0; i<arr.size(); i++) {\\n             if(mp.count(arr[i]) && mp.count(arr[i]*2)) {\\n               int x=min(mp[arr[i]],mp[arr[i]*2]);\\n                    mp[arr[i]]-=x;\\n                    mp[arr[i]*2]-=x;           // remove the min. freq. of a and 2a in common \\n             }\\n        }\\n        int ans=0;\\n        for(pair<int,int> p : mp)  ans+=p.second; \\n        cout<<endl;\\n        return (ans==0);      /* if the sum of frequency is zero,the array is symmetric  Numof(a)==Numof(2*a)  */                                               \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1012707,
                "title": "java-better-than-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean canReorderDoubled(int[] A) {\\n\\t\\t\\n\\t\\t\\tArrays.sort(A);\\n\\t\\t\\t\\n\\t\\t\\tHashMap<Integer,Integer> map=new HashMap<>();\\n\\t\\t\\t\\n\\t\\t\\tfor(int ele:A)\\n\\t\\t\\t\\tmap.put(ele,map.getOrDefault(ele,0)+1);\\n\\t\\t\\t\\t\\n\\t\\t\\tfor(int ele:A){\\n\\t\\t\\t\\n\\t\\t\\t\\tif(!map.containsKey(ele))\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tint db=0;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(ele<0 && ele%2!=0)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tdb=(ele<0)?(ele/2):(ele*2);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(map.containsKey(db)){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tmap.put(ele,map.get(ele)-1);\\n\\t\\t\\t\\t\\tmap.put(db,map.get(db)-1);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif(map.get(ele)==0)\\n\\t\\t\\t\\t\\t\\tmap.remove(ele);\\n\\t\\t\\t\\t\\tif(map.containsKey(db) && map.get(db)==0)\\n\\t\\t\\t\\t\\t\\tmap.remove(db);\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean canReorderDoubled(int[] A) {\\n\\t\\t\\n\\t\\t\\tArrays.sort(A);\\n\\t\\t\\t\\n\\t\\t\\tHashMap<Integer,Integer> map=new HashMap<>();\\n\\t\\t\\t\\n\\t\\t\\tfor(int ele:A)\\n\\t\\t\\t\\tmap.put(ele,map.getOrDefault(ele,0)+1);\\n\\t\\t\\t\\t\\n\\t\\t\\tfor(int ele:A){\\n\\t\\t\\t\\n\\t\\t\\t\\tif(!map.containsKey(ele))\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tint db=0;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(ele<0 && ele%2!=0)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tdb=(ele<0)?(ele/2):(ele*2);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(map.containsKey(db)){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tmap.put(ele,map.get(ele)-1);\\n\\t\\t\\t\\t\\tmap.put(db,map.get(db)-1);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif(map.get(ele)==0)\\n\\t\\t\\t\\t\\t\\tmap.remove(ele);\\n\\t\\t\\t\\t\\tif(map.containsKey(db) && map.get(db)==0)\\n\\t\\t\\t\\t\\t\\tmap.remove(db);\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 908941,
                "title": "python-solution-kinda-brute-force",
                "content": "```\\nclass Solution:\\n    def canReorderDoubled(self, A: List[int]) -> bool:\\n        A=collections.Counter(A)\\n        for i in sorted(A.keys()):\\n            if A[i]<=0: continue\\n            while A[i]>0:\\n                A[i]-=1\\n                if A[i*2]>0:\\n                    A[i*2]-=1\\n                elif A[i/2]>0:\\n                    A[i/2]-=1\\n                else:\\n                    return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canReorderDoubled(self, A: List[int]) -> bool:\\n        A=collections.Counter(A)\\n        for i in sorted(A.keys()):\\n            if A[i]<=0: continue\\n            while A[i]>0:\\n                A[i]-=1\\n                if A[i*2]>0:\\n                    A[i*2]-=1\\n                elif A[i/2]>0:\\n                    A[i/2]-=1\\n                else:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907538,
                "title": "python-solution-no-sorting-heap-easy-to-understand",
                "content": "```\\n    class Solution:\\n\\t\\tdef canReorderDoubled(self, A: List[int]) -> bool:\\n\\t\\t\\td = {}\\n\\t\\t\\tfor x in A:\\n\\t\\t\\t\\td[x] = d.get(x, 0) + 1\\n\\t\\t\\tif d.get(0, 0) % 2 == 1: return False\\n\\t\\t\\td[0] = 0\\n\\n\\t\\t\\t# Odd numbers can only be placed at even index.\\n\\t\\t\\t# After all odd numbers have been taken care of and we only\\n\\t\\t\\t# have even numbers, we should be able to divide them by 2 and\\n\\t\\t\\t# perform the same procedure\\n\\n\\t\\t\\tmulti = 1\\n\\t\\t\\twhile sum(d.values()) != 0:\\n\\t\\t\\t\\tfor x in d:\\n\\t\\t\\t\\t\\tif (x // multi) % 2 == 0: continue\\n\\t\\t\\t\\t\\tif d[x] == 0: continue\\n\\t\\t\\t\\t\\tif d.get(x*2, 0) < d[x]:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\td[x*2] -= d[x]\\n\\t\\t\\t\\t\\td[x] = 0\\n\\t\\t\\t\\tmulti *= 2\\n\\t\\t\\treturn True\\n```",
                "solutionTags": [],
                "code": "```\\n    class Solution:\\n\\t\\tdef canReorderDoubled(self, A: List[int]) -> bool:\\n\\t\\t\\td = {}\\n\\t\\t\\tfor x in A:\\n\\t\\t\\t\\td[x] = d.get(x, 0) + 1\\n\\t\\t\\tif d.get(0, 0) % 2 == 1: return False\\n\\t\\t\\td[0] = 0\\n\\n\\t\\t\\t# Odd numbers can only be placed at even index.\\n\\t\\t\\t# After all odd numbers have been taken care of and we only\\n\\t\\t\\t# have even numbers, we should be able to divide them by 2 and\\n\\t\\t\\t# perform the same procedure\\n\\n\\t\\t\\tmulti = 1\\n\\t\\t\\twhile sum(d.values()) != 0:\\n\\t\\t\\t\\tfor x in d:\\n\\t\\t\\t\\t\\tif (x // multi) % 2 == 0: continue\\n\\t\\t\\t\\t\\tif d[x] == 0: continue\\n\\t\\t\\t\\t\\tif d.get(x*2, 0) < d[x]:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\td[x*2] -= d[x]\\n\\t\\t\\t\\t\\td[x] = 0\\n\\t\\t\\t\\tmulti *= 2\\n\\t\\t\\treturn True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886224,
                "title": "rust-translated-24ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn can_reorder_doubled(a: Vec<i32>) -> bool {\\n        use std::collections::BTreeMap;\\n\\n        let mut count = BTreeMap::<i32, i32>::new();\\n        for &x in &a {\\n            *count.entry(x).or_default() += 1;\\n        }\\n        let keys = count.keys().copied().collect::<Vec<i32>>();\\n        for x in keys {\\n            if count[&x] == 0 {\\n                continue;\\n            }\\n            let wanted = if x < 0 { x / 2 } else { x * 2 };\\n            if x < 0 && x & 1 == 1 || count[&x] > *count.get(&wanted).unwrap_or(&0) {\\n                return false;\\n            }\\n            *count.entry(wanted).or_default() -= count[&x];\\n        }\\n        true\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_can_reorder_doubled() {\\n        assert_eq!(Solution::can_reorder_doubled(vec![3, 1, 3, 6]), false);\\n    }\\n\\n    #[test]\\n    fn test_can_reorder_doubled_02() {\\n        assert_eq!(Solution::can_reorder_doubled(vec![2, 1, 2, 6]), false);\\n    }\\n\\n    #[test]\\n    fn test_can_reorder_doubled_03() {\\n        assert_eq!(Solution::can_reorder_doubled(vec![4, -2, 2, -4]), true);\\n    }\\n\\n    #[test]\\n    fn test_can_reorder_doubled_04() {\\n        assert_eq!(\\n            Solution::can_reorder_doubled(vec![1, 2, 4, 16, 8, 4]),\\n            false\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn can_reorder_doubled(a: Vec<i32>) -> bool {\\n        use std::collections::BTreeMap;\\n\\n        let mut count = BTreeMap::<i32, i32>::new();\\n        for &x in &a {\\n            *count.entry(x).or_default() += 1;\\n        }\\n        let keys = count.keys().copied().collect::<Vec<i32>>();\\n        for x in keys {\\n            if count[&x] == 0 {\\n                continue;\\n            }\\n            let wanted = if x < 0 { x / 2 } else { x * 2 };\\n            if x < 0 && x & 1 == 1 || count[&x] > *count.get(&wanted).unwrap_or(&0) {\\n                return false;\\n            }\\n            *count.entry(wanted).or_default() -= count[&x];\\n        }\\n        true\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_can_reorder_doubled() {\\n        assert_eq!(Solution::can_reorder_doubled(vec![3, 1, 3, 6]), false);\\n    }\\n\\n    #[test]\\n    fn test_can_reorder_doubled_02() {\\n        assert_eq!(Solution::can_reorder_doubled(vec![2, 1, 2, 6]), false);\\n    }\\n\\n    #[test]\\n    fn test_can_reorder_doubled_03() {\\n        assert_eq!(Solution::can_reorder_doubled(vec![4, -2, 2, -4]), true);\\n    }\\n\\n    #[test]\\n    fn test_can_reorder_doubled_04() {\\n        assert_eq!(\\n            Solution::can_reorder_doubled(vec![1, 2, 4, 16, 8, 4]),\\n            false\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 739357,
                "title": "java-simple-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] A) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Arrays.sort(A);\\n        for (int a : A){\\n            map.put(a, map.getOrDefault(a, 0) + 1);\\n        }\\n        int count = 0;\\n        for (int a : A){\\n            int y = 2 * a;\\n            if (map.containsKey(a) && map.containsKey(y)){\\n                map.put(a, map.get(a) - 1);\\n                map.put(y, map.get(y) - 1);\\n                if (map.get(a) == 0){\\n                    map.remove(a);\\n                }\\n                if (a != y && map.get(y) == 0){\\n                    map.remove(y);\\n                }\\n                count++;\\n            }\\n        }\\n        return count == A.length / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] A) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Arrays.sort(A);\\n        for (int a : A){\\n            map.put(a, map.getOrDefault(a, 0) + 1);\\n        }\\n        int count = 0;\\n        for (int a : A){\\n            int y = 2 * a;\\n            if (map.containsKey(a) && map.containsKey(y)){\\n                map.put(a, map.get(a) - 1);\\n                map.put(y, map.get(y) - 1);\\n                if (map.get(a) == 0){\\n                    map.remove(a);\\n                }\\n                if (a != y && map.get(y) == 0){\\n                    map.remove(y);\\n                }\\n                count++;\\n            }\\n        }\\n        return count == A.length / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551532,
                "title": "954-array-of-doubled-pairs-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Counter Match**\\n| O(T): O(nlgn) | O(S): O(n) | Rt: 608ms | \\n```python\\n    def canReorderDoubled(self, A: List[int]) -> bool:\\n        ct = collections.Counter(A)\\n        for k in sorted(ct, key=abs):\\n            if not ct[k]: continue\\n            if ct[2 * k] < ct[k]: return False\\n            ct[2*k] -= ct[k]\\n        return True\\n```",
                "solutionTags": [],
                "code": "```python\\n    def canReorderDoubled(self, A: List[int]) -> bool:\\n        ct = collections.Counter(A)\\n        for k in sorted(ct, key=abs):\\n            if not ct[k]: continue\\n            if ct[2 * k] < ct[k]: return False\\n            ct[2*k] -= ct[k]\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 530919,
                "title": "python-fast-and-no-sort",
                "content": "```\\nclass Solution(object):\\n    def canReorderDoubled(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        cnts={} # frequency of the number\\n        roots = set() # collection of x where x is the smallest in chain x, 2x, 4x, 8x ...\\n        zerocnt = 0\\n        \\n        for i in A:\\n            if not i:\\n                zerocnt+=1\\n                continue\\n                \\n            if i in cnts:\\n                cnts[i]+=1\\n            else:\\n                cnts[i]=1\\n                \\n                if i%2 or i//2 not in cnts:\\n                    roots.add(i)\\n                \\n                if 2*i in cnts:\\n                    roots.remove(2*i)\\n        \\n        if zerocnt%2: return False\\n        \\n        for i in roots:\\n            buf=cnts[i]\\n            while 2*i in cnts:\\n                buf=cnts[2*i]-buf\\n                if buf<0: return False\\n                i*=2\\n            if buf>0: return False\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canReorderDoubled(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        cnts={} # frequency of the number\\n        roots = set() # collection of x where x is the smallest in chain x, 2x, 4x, 8x ...\\n        zerocnt = 0\\n        \\n        for i in A:\\n            if not i:\\n                zerocnt+=1\\n                continue\\n                \\n            if i in cnts:\\n                cnts[i]+=1\\n            else:\\n                cnts[i]=1\\n                \\n                if i%2 or i//2 not in cnts:\\n                    roots.add(i)\\n                \\n                if 2*i in cnts:\\n                    roots.remove(2*i)\\n        \\n        if zerocnt%2: return False\\n        \\n        for i in roots:\\n            buf=cnts[i]\\n            while 2*i in cnts:\\n                buf=cnts[2*i]-buf\\n                if buf<0: return False\\n                i*=2\\n            if buf>0: return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506517,
                "title": "c-ordered-map-and-eliminate-number-by-pairs",
                "content": "[1,2,2,4] \\neliminate [1,2] first, then [2,4]\\n[-4,-2,-2,-1]\\neliminate [-4, -2] first then [-2, -1]\\n\\neach time as long as there is no enough count to be decremented, return false.\\n\\n```\\nbool canReorderDoubled(vector<int>& A) {\\n        map<int, int> mmap;\\n        for(int a: A) {\\n            ++mmap[a];\\n        }\\n        if(mmap[0] % 2) return false;\\n        \\n        for(auto it: mmap) {\\n            if(it.second > 0) {\\n                int target = it.first < 0 ? it.first/2 : it.first * 2;\\n                if(!mmap.count(target) || mmap[target] < mmap[it.first]) {\\n                        return false;\\n                }\\n \\n                mmap[target] -= mmap[it.first];\\n                mmap[it.first] = 0;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool canReorderDoubled(vector<int>& A) {\\n        map<int, int> mmap;\\n        for(int a: A) {\\n            ++mmap[a];\\n        }\\n        if(mmap[0] % 2) return false;\\n        \\n        for(auto it: mmap) {\\n            if(it.second > 0) {\\n                int target = it.first < 0 ? it.first/2 : it.first * 2;\\n                if(!mmap.count(target) || mmap[target] < mmap[it.first]) {\\n                        return false;\\n                }\\n \\n                mmap[target] -= mmap[it.first];\\n                mmap[it.first] = 0;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 499736,
                "title": "easy-c-solution-with-sort-and-dictionary",
                "content": "```\\n    public class Solution\\n    {\\n        public bool CanReorderDoubled(int[] nums)\\n        {\\n            IDictionary<int, int> val2Count = new Dictionary<int, int>();\\n            Array.Sort(nums, (n1, n2) => Math.Abs(n1).CompareTo(Math.Abs(n2)));\\n            foreach (var num in nums)\\n            {\\n                if (!val2Count.ContainsKey(num))\\n                {\\n                    val2Count[num] = 0;\\n                }\\n\\n                val2Count[num]++;\\n            }\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                var curr = nums[i];\\n                var doubled = curr * 2;\\n\\n                if (!val2Count.ContainsKey(curr))\\n                {\\n                    //used as odd\\n                    continue;\\n                }\\n\\n                val2Count[curr]--;\\n                if (val2Count[curr] == 0)\\n                {\\n                    val2Count.Remove(curr);\\n                }\\n\\n                if (!val2Count.ContainsKey(doubled))\\n                {\\n                    return false;\\n                }\\n\\n                val2Count[doubled]--;\\n                if (val2Count[doubled] == 0)\\n                {\\n                    val2Count.Remove(doubled);\\n                }\\n            }\\n\\n            return true;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        public bool CanReorderDoubled(int[] nums)\\n        {\\n            IDictionary<int, int> val2Count = new Dictionary<int, int>();\\n            Array.Sort(nums, (n1, n2) => Math.Abs(n1).CompareTo(Math.Abs(n2)));\\n            foreach (var num in nums)\\n            {\\n                if (!val2Count.ContainsKey(num))\\n                {\\n                    val2Count[num] = 0;\\n                }\\n\\n                val2Count[num]++;\\n            }\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                var curr = nums[i];\\n                var doubled = curr * 2;\\n\\n                if (!val2Count.ContainsKey(curr))\\n                {\\n                    //used as odd\\n                    continue;\\n                }\\n\\n                val2Count[curr]--;\\n                if (val2Count[curr] == 0)\\n                {\\n                    val2Count.Remove(curr);\\n                }\\n\\n                if (!val2Count.ContainsKey(doubled))\\n                {\\n                    return false;\\n                }\\n\\n                val2Count[doubled]--;\\n                if (val2Count[doubled] == 0)\\n                {\\n                    val2Count.Remove(doubled);\\n                }\\n            }\\n\\n            return true;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 450824,
                "title": "javascript-solution-with-hash-map-space-100",
                "content": "```\\nvar canReorderDoubled = function(A) {\\n    A.sort(function(a,b) {\\n        if(a < 0 && b < 0) return b-a;\\n        return a-b;\\n    })\\n    let pair = 0;\\n    let map = new Map();\\n    for(let i = 0; i < A.length; i++) {\\n        if(!map.has(A[i])) {\\n            if(!map.has(A[i]*2)) map.set(A[i]*2, 1);\\n            else map.set(A[i]*2, map.get(A[i]*2)+1);\\n        }\\n        else {\\n            map.set(A[i], map.get(A[i])-1);\\n            if(map.get(A[i]) === 0) map.delete(A[i]);\\n            pair++;\\n        }\\n    }\\n    return pair === A.length/2;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar canReorderDoubled = function(A) {\\n    A.sort(function(a,b) {\\n        if(a < 0 && b < 0) return b-a;\\n        return a-b;\\n    })\\n    let pair = 0;\\n    let map = new Map();\\n    for(let i = 0; i < A.length; i++) {\\n        if(!map.has(A[i])) {\\n            if(!map.has(A[i]*2)) map.set(A[i]*2, 1);\\n            else map.set(A[i]*2, map.get(A[i]*2)+1);\\n        }\\n        else {\\n            map.set(A[i], map.get(A[i])-1);\\n            if(map.get(A[i]) === 0) map.delete(A[i]);\\n            pair++;\\n        }\\n    }\\n    return pair === A.length/2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 383177,
                "title": "java-solution-with-explanation",
                "content": "**Idea**\\nThe basic idea is to see if we can divide the input into pairs `<a, 2*a>`. First intuition should be using `freq` map and trying to see if we have `partner` element for every element.\\nBut the order in which we pair up elements is important, why?\\nFor example: `[1,1,2,2,4,8]`. If we pair up `<1,2>, <2,4>`, we do not have partner for another `1`. But if we pair up this way `<1,2>, <1,2>, <4,8>`.  What changed? The reason is `2` can sit on the left side or on right side but `1` can not in this case.\\nSo greedy strategy is to start with small numbers on left and their partners on the right. That will work.\\n\\nBut for negative numbers, we will run into the same issue even if we sort them. Ex: `[-8,-4,-2,-2,-1,-1]`, while scanning `-2` will be paired with `-4`. So for negatives, we need to change the definition of `partner` to `x/2`. Then `<-8,-4>,<-2,-1>,<-2,-1>`.\\n\\n\\n```\\npublic boolean canReorderDoubled(int[] A) {\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        for(int a : A)\\n            freq.put(a, freq.getOrDefault(a, 0)+1);\\n        Arrays.sort(A);\\n        for(int a : A){\\n            int val = a, partner = 2*a;\\n            if(val < 0)\\n                partner = a/2;\\n            if(freq.containsKey(val) && freq.containsKey(partner)){\\n                freq.put(partner, freq.get(partner)-1);\\n                if(freq.get(partner) == 0)\\n                    freq.remove(partner);\\n                if(!freq.containsKey(val)) break;\\n                freq.put(val, freq.get(val)-1);\\n                if(freq.get(val) == 0)\\n                    freq.remove(val);\\n            }\\n        }\\n        return freq.isEmpty();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canReorderDoubled(int[] A) {\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        for(int a : A)\\n            freq.put(a, freq.getOrDefault(a, 0)+1);\\n        Arrays.sort(A);\\n        for(int a : A){\\n            int val = a, partner = 2*a;\\n            if(val < 0)\\n                partner = a/2;\\n            if(freq.containsKey(val) && freq.containsKey(partner)){\\n                freq.put(partner, freq.get(partner)-1);\\n                if(freq.get(partner) == 0)\\n                    freq.remove(partner);\\n                if(!freq.containsKey(val)) break;\\n                freq.put(val, freq.get(val)-1);\\n                if(freq.get(val) == 0)\\n                    freq.remove(val);\\n            }\\n        }\\n        return freq.isEmpty();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 368483,
                "title": "fast-and-easy-to-understand-c",
                "content": "In this solution, positive and negative numbers are separated, counted and sorted.\\nThen we search inside each map for the corresponding item of the pair.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& A)\\n    {\\n        map<int, int> dataPos;\\n        map<int, int> dataNeg;\\n        \\n        int countZeroes = 0;\\n        \\n        for (int i: A)\\n        {\\n            if (i > 0)\\n                dataPos[i]++;\\n            else if (i < 0)\\n                dataNeg[i]++;\\n            else\\n                countZeroes++;\\n        }\\n        \\n        if (countZeroes % 2 != 0)\\n            return false;\\n        \\n        for (map<int, int>::iterator it = dataPos.begin(); it != dataPos.end(); ++it)\\n        {\\n            if (it->second > 0)\\n            {\\n                if (dataPos[it->first * 2] < it->second)\\n                    return false;\\n\\n                dataPos[it->first * 2] -= it->second;\\n            }\\n        }\\n        \\n        for (map<int, int>::reverse_iterator it = dataNeg.rbegin(); it != dataNeg.rend(); ++it)\\n        {\\n            if (it->second > 0)\\n            {\\n                if (dataNeg[it->first * 2] < it->second)\\n                    return false;\\n\\n                dataNeg[it->first * 2] -= it->second;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\nEasy right?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& A)\\n    {\\n        map<int, int> dataPos;\\n        map<int, int> dataNeg;\\n        \\n        int countZeroes = 0;\\n        \\n        for (int i: A)\\n        {\\n            if (i > 0)\\n                dataPos[i]++;\\n            else if (i < 0)\\n                dataNeg[i]++;\\n            else\\n                countZeroes++;\\n        }\\n        \\n        if (countZeroes % 2 != 0)\\n            return false;\\n        \\n        for (map<int, int>::iterator it = dataPos.begin(); it != dataPos.end(); ++it)\\n        {\\n            if (it->second > 0)\\n            {\\n                if (dataPos[it->first * 2] < it->second)\\n                    return false;\\n\\n                dataPos[it->first * 2] -= it->second;\\n            }\\n        }\\n        \\n        for (map<int, int>::reverse_iterator it = dataNeg.rbegin(); it != dataNeg.rend(); ++it)\\n        {\\n            if (it->second > 0)\\n            {\\n                if (dataNeg[it->first * 2] < it->second)\\n                    return false;\\n\\n                dataNeg[it->first * 2] -= it->second;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332326,
                "title": "python-o-n-solution",
                "content": "\\n```\\n    def canReorderDoubled(self, A: List[int]) -> bool:\\n        \\n        groups = [collections.defaultdict(int) for _ in range(32)]\\n        \\n        zero_cnt = 0\\n        for n in A:\\n            if n==0:\\n                zero_cnt += 1\\n                continue\\n            p = int(math.log2(n&(-n)) )\\n            groups[p][n] += 1\\n            \\n        if zero_cnt%2!=0:\\n            return False\\n        \\n        for i in range(32):\\n            for n in groups[i]:\\n                if groups[i][n]==0:\\n                    continue\\n                if 2*n not in groups[i+1] or groups[i+1][2*n]<groups[i][n]:\\n                    return False\\n                groups[i+1][2*n] -= groups[i][n]\\n                \\n        return True\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    def canReorderDoubled(self, A: List[int]) -> bool:\\n        \\n        groups = [collections.defaultdict(int) for _ in range(32)]\\n        \\n        zero_cnt = 0\\n        for n in A:\\n            if n==0:\\n                zero_cnt += 1\\n                continue\\n            p = int(math.log2(n&(-n)) )\\n            groups[p][n] += 1\\n            \\n        if zero_cnt%2!=0:\\n            return False\\n        \\n        for i in range(32):\\n            for n in groups[i]:\\n                if groups[i][n]==0:\\n                    continue\\n                if 2*n not in groups[i+1] or groups[i+1][2*n]<groups[i][n]:\\n                    return False\\n                groups[i+1][2*n] -= groups[i][n]\\n                \\n        return True\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 204272,
                "title": "contributor-s-solution",
                "content": "Hey guys, glad to see so many submissions to this problem! I was in fact asked this question during an interview, here is an implementation that is slightly more elegant than the code I wrote under time pressure, but is the same basic idea.\\n\\nIt only beats about 60% of Go submissions, you guys are good!\\n\\n```\\nfunc canReorderDoubled(A []int) bool {\\n    sort.Ints(A)\\n    counts := make(map[int]int)\\n    for _, x := range A {\\n        if x < 0 {\\n            if counts[2 * x] > 0 {\\n                counts[2 * x]--\\n                if counts[2 * x] == 0 {\\n                    delete(counts, 2 * x)\\n                }\\n            } else {\\n                counts[x]++\\n            }\\n        } else if x == 0 {\\n            counts[0]++\\n        } else {\\n            if x == 1 {\\n                counts[1]++\\n            } else if x % 2 == 0 && counts[x / 2] != 0 {\\n                counts[x / 2]--\\n                if counts[x / 2] == 0 {\\n                    delete(counts, x / 2)\\n                }\\n            } else {\\n                counts[x]++\\n            }\\n        }\\n    }\\n    n := len(counts)\\n    if n == 0 {\\n        return true\\n    }\\n    if n == 1 {\\n        return (counts[0] != 0) && (counts[0] % 2 == 0)\\n    }\\n    return false\\n}\\n```\\n\\nLike the posted greedy solution, this is O(NlogN).",
                "solutionTags": [],
                "code": "```\\nfunc canReorderDoubled(A []int) bool {\\n    sort.Ints(A)\\n    counts := make(map[int]int)\\n    for _, x := range A {\\n        if x < 0 {\\n            if counts[2 * x] > 0 {\\n                counts[2 * x]--\\n                if counts[2 * x] == 0 {\\n                    delete(counts, 2 * x)\\n                }\\n            } else {\\n                counts[x]++\\n            }\\n        } else if x == 0 {\\n            counts[0]++\\n        } else {\\n            if x == 1 {\\n                counts[1]++\\n            } else if x % 2 == 0 && counts[x / 2] != 0 {\\n                counts[x / 2]--\\n                if counts[x / 2] == 0 {\\n                    delete(counts, x / 2)\\n                }\\n            } else {\\n                counts[x]++\\n            }\\n        }\\n    }\\n    n := len(counts)\\n    if n == 0 {\\n        return true\\n    }\\n    if n == 1 {\\n        return (counts[0] != 0) && (counts[0] % 2 == 0)\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 203657,
                "title": "java-sort-2-pointers-no-hashmap-o-n-lg-n-20ms-11lines",
                "content": "```\\npublic boolean canReorderDoubled(int[] A) {\\n        Arrays.sort(A); // O(n*lg(n))\\n        int n = A.length;\\n        boolean[] paired = new boolean[n];\\n        for(int i = 0, j = 1; i < n; i++) { // O(n)\\n            if (paired[i]) continue;\\n            while(j < n && A[j] != 2*A[i] && 2*A[j] != A[i])\\n                j++;\\n            if (j == n) return false;\\n            paired[j++] = true;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canReorderDoubled(int[] A) {\\n        Arrays.sort(A); // O(n*lg(n))\\n        int n = A.length;\\n        boolean[] paired = new boolean[n];\\n        for(int i = 0, j = 1; i < n; i++) { // O(n)\\n            if (paired[i]) continue;\\n            while(j < n && A[j] != 2*A[i] && 2*A[j] != A[i])\\n                j++;\\n            if (j == n) return false;\\n            paired[j++] = true;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 203242,
                "title": "c-using-multiset",
                "content": "O(nlogn): convert negatives to positive and always check if the smallest have its double in the set. If we found a pair, remove them from the set. (I think there is a flaw: the negatives shall be considered separately)\\nSearching the double using binary search.\\n\\n```\\n    bool canReorderDoubled(vector<int>& A) {\\n        multiset<int> pos,neg;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            if(A[i]>=0) pos.insert(A[i]);\\n            else neg.insert(-A[i]);\\n        }\\n        if(pos.size()%2 || neg.size()%2) return 0;\\n        return checkpairs(pos) && checkpairs(neg);\\n     }\\n    bool checkpairs(multiset<int> ms)\\n    {\\n        auto it=ms.begin();\\n        while(ms.size())\\n        {\\n            it=ms.begin();\\n            auto it1=ms.upper_bound((*it)*2);\\n            --it1;\\n            if(it1!=ms.begin() && *it1==*it*2)\\n            {\\n                ms.erase(it1);\\n                ms.erase(ms.begin());\\n            }\\n            else return 0;\\n        }\\n        return 1;        \\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\n    bool canReorderDoubled(vector<int>& A) {\\n        multiset<int> pos,neg;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            if(A[i]>=0) pos.insert(A[i]);\\n            else neg.insert(-A[i]);\\n        }\\n        if(pos.size()%2 || neg.size()%2) return 0;\\n        return checkpairs(pos) && checkpairs(neg);\\n     }\\n    bool checkpairs(multiset<int> ms)\\n    {\\n        auto it=ms.begin();\\n        while(ms.size())\\n        {\\n            it=ms.begin();\\n            auto it1=ms.upper_bound((*it)*2);\\n            --it1;\\n            if(it1!=ms.begin() && *it1==*it*2)\\n            {\\n                ms.erase(it1);\\n                ms.erase(ms.begin());\\n            }\\n            else return 0;\\n        }\\n        return 1;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 203225,
                "title": "java-n-2-solution-using-priorityqueue",
                "content": "```\\n     public boolean canReorderDoubled(int[] A) {\\n        PriorityQueue<Integer> positive = new PriorityQueue<>();\\n        PriorityQueue<Integer> negative = new PriorityQueue<>((a,b)->b-a);\\n        for (int i : A) {\\n           if(i >= 0) positive.add(i);\\n            else negative.add(i);\\n        }\\n        while (!positive.isEmpty()) \\n            if (!positive.remove(positive.poll() * 2))  return false;\\n        \\n        while (!negative.isEmpty())\\n            if (!negative.remove(negative.poll() * 2)) return false;\\n\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n     public boolean canReorderDoubled(int[] A) {\\n        PriorityQueue<Integer> positive = new PriorityQueue<>();\\n        PriorityQueue<Integer> negative = new PriorityQueue<>((a,b)->b-a);\\n        for (int i : A) {\\n           if(i >= 0) positive.add(i);\\n            else negative.add(i);\\n        }\\n        while (!positive.isEmpty()) \\n            if (!positive.remove(positive.poll() * 2))  return false;\\n        \\n        while (!negative.isEmpty())\\n            if (!negative.remove(negative.poll() * 2)) return false;\\n\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070316,
                "title": "simple-solution-using-dictionary",
                "content": "# Explanation\\nFrom smallest to largest number (sort input array), check if we\\'ve \"seen\" $$x/2$$ or $$2*x$$. Decrement the count at each encounter.\\n\\nAt the end of our count, the length of the input array should be twice the the number of pairs: $$count*2 == len(arr)$$\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        \\n        seen = defaultdict(int)\\n        count = 0\\n\\n        for num in sorted(arr):\\n\\n            if seen[2*num] > 0: \\n                count += 1\\n                seen[2*num] -= 1\\n            elif seen[num/2] > 0:\\n                count += 1\\n                seen[num/2] -= 1\\n            else:\\n                seen[num] += 1\\n\\n        return count*2 == len(arr)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        \\n        seen = defaultdict(int)\\n        count = 0\\n\\n        for num in sorted(arr):\\n\\n            if seen[2*num] > 0: \\n                count += 1\\n                seen[2*num] -= 1\\n            elif seen[num/2] > 0:\\n                count += 1\\n                seen[num/2] -= 1\\n            else:\\n                seen[num] += 1\\n\\n        return count*2 == len(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055656,
                "title": "easiest-solution-without-using-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort the array and count the total numbers which are having their doubles in the array and then compare it with the length of the array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort the given array in non decreasing order.\\n- Initialise a count variable which will store the count of the total numbers which can form the given doublet pairs.\\n- Take two variable i and j two run two pointers approach using while loop and run the loop till the greater index doesn\\'t traverse the whole array.\\n- Make sure your greater pointer must always points to the index greater than the previous pointer if it becomes smaller then make it greater.\\n- Initialise all the numbers with a number that is not available in the array so that we can\\'t use the same number to form our doublet twice.\\n- On sorting we get two cases, first for negative numbers which are arranged in non increasing order by absolute value and positive numbers which are arranged in non decreasing order.\\n- For the negative sequences check if the pointer at smaller index has magnitude twice than the pointer at greater index and vice versa for the positive numbers.\\n- Increase the count and j , i according to the cases.\\n- We can\\'t increase our i pointer if it doesn\\'t have any doublet because we have to make doublet pair of all the indexes so return false when you can\\'t get any suitable index for i.\\n- Now at the last compare the count with the length of the array which will give all the indexes which forms the doublet if it equals to the length then return true otherwise false.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        int count=0;\\n        int i=0,j=1;\\n        while(j<n){\\n            if(i>=j){\\n                j++;\\n                continue;\\n            }\\n            if(arr[i]==1000000){\\n                i++;\\n                continue;\\n            }\\n            if(arr[i]>0 && 2*arr[i]==arr[j]){\\n                count+=2;\\n                arr[i]=arr[j]=1e6;\\n                i++;\\n                j++;\\n            }\\n            else if(arr[i]==2*arr[j]){\\n                count+=2;\\n                arr[i]=arr[j]=1e6;\\n                i++;\\n                j++;\\n            }\\n            else if(arr[i]>0 && 2*arr[i]>arr[j]){\\n                j++;\\n            }\\n            else if(arr[i]<0 && arr[i]>2*arr[j]){\\n                j++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        cout<<count<<endl;\\n        return count==n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        int count=0;\\n        int i=0,j=1;\\n        while(j<n){\\n            if(i>=j){\\n                j++;\\n                continue;\\n            }\\n            if(arr[i]==1000000){\\n                i++;\\n                continue;\\n            }\\n            if(arr[i]>0 && 2*arr[i]==arr[j]){\\n                count+=2;\\n                arr[i]=arr[j]=1e6;\\n                i++;\\n                j++;\\n            }\\n            else if(arr[i]==2*arr[j]){\\n                count+=2;\\n                arr[i]=arr[j]=1e6;\\n                i++;\\n                j++;\\n            }\\n            else if(arr[i]>0 && 2*arr[i]>arr[j]){\\n                j++;\\n            }\\n            else if(arr[i]<0 && arr[i]>2*arr[j]){\\n                j++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        cout<<count<<endl;\\n        return count==n;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4053592,
                "title": "java-time-o-n-logn-space-o-1",
                "content": "\\n# Approach\\nWe need to pointers to keep track of index we\\'re at and index we\\'re checking for double value. I\\'ve called the first pointer p and the second one dp (aka double pointer).\\n\\nThis is an approach that works only for some cases.\\n- sort the array\\n- loop through the first half of elements (i = 0 -> arr.lenght/2 - 1)\\n    -  starting from dp + 1, look for an element twice arr[p]\\n    - if such element is found, incremenet p, go to the next i\\n\\nThis approach is not correct for a case like [-6,-4,-3,-2,2,4]. Here, our pairs are [-6,-3], [-4,-2] and [2,4]. p will be at -6, then -4, then -3. It has no clue that -3 has been used by dp. To let p know that it shouldn\\'t use -3, I use a constant called min that assigns a value less than minimum value in the array to the elements used by dp. When p meets such elements, it goes to the next element not used by dp. \\n\\nTherefore, the above algorithm should be updated like this:\\n- sort the array\\n- loop through the first half of elements (i = 0 -> arr.lenght/2 - 1)\\n    -  if p has been used by dp, go to the next unused index\\n    - starting from dp + 1, look for an element twice arr[p]\\n    - if such element is found, change its value to min, incremenet p, go to the next i\\n\\nPS: My code may need some modifications to become shorter.\\n\\n# Complexity\\n- Time complexity:\\nO(n.logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        // p: index of current element\\n        // dp: index of an element double the element at p\\n        // min: an indicator to mark indexes that are doubles of other elements\\n        //      we use min to stop p from reading previously used elements (jump over such elements)\\n        int p = 0, dp = -1, min = Integer.MIN_VALUE;\\n\\n        Arrays.sort(arr);\\n\\n        for (int i = 0; i < arr.length / 2; i++){\\n            // if the element has been used as a dp, go to the next unused element\\n            while (arr[p] == min)\\n                p++;\\n            dp = Math.max(dp + 1, p + 1);\\n\\n            while(dp < arr.length){\\n                // for negative elements, element at the lower index\\n                // should be twice the element at the higher index\\n                if (arr[p] <= 0 && arr[dp] <= 0){\\n                    if (arr[p] == 2 * arr[dp]) {\\n                        arr[dp] = min;\\n                        p++;\\n                        break;\\n                    }\\n                }\\n                // for positive elements, element at the lower index\\n                // should be half the element at the higher index\\n                else if (arr[p] * 2 == arr[dp]) {\\n                    arr[dp] = min;\\n                    p++;\\n                    break;\\n                }\\n                dp++;\\n            }\\n\\n            if (dp == arr.length)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        // p: index of current element\\n        // dp: index of an element double the element at p\\n        // min: an indicator to mark indexes that are doubles of other elements\\n        //      we use min to stop p from reading previously used elements (jump over such elements)\\n        int p = 0, dp = -1, min = Integer.MIN_VALUE;\\n\\n        Arrays.sort(arr);\\n\\n        for (int i = 0; i < arr.length / 2; i++){\\n            // if the element has been used as a dp, go to the next unused element\\n            while (arr[p] == min)\\n                p++;\\n            dp = Math.max(dp + 1, p + 1);\\n\\n            while(dp < arr.length){\\n                // for negative elements, element at the lower index\\n                // should be twice the element at the higher index\\n                if (arr[p] <= 0 && arr[dp] <= 0){\\n                    if (arr[p] == 2 * arr[dp]) {\\n                        arr[dp] = min;\\n                        p++;\\n                        break;\\n                    }\\n                }\\n                // for positive elements, element at the lower index\\n                // should be half the element at the higher index\\n                else if (arr[p] * 2 == arr[dp]) {\\n                    arr[dp] = min;\\n                    p++;\\n                    break;\\n                }\\n                dp++;\\n            }\\n\\n            if (dp == arr.length)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978331,
                "title": "a-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool CanReorderDoubled(int[] arr) {\\n        var dict = new Dictionary<int, int>();\\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            if (dict.ContainsKey(arr[i])) dict[arr[i]]++;\\n            else dict.Add(arr[i], 1);\\n        }\\n        if (dict.ContainsKey(0))\\n        {\\n            if (dict[0] % 2 != 0) return false;\\n            dict.Remove(0);\\n        }\\n        Array.Sort(arr);\\n        for (int i = 0; i < arr.Length; i++)\\n        {\\n            if (!dict.ContainsKey(arr[i])) continue;\\n            if (dict.ContainsKey(arr[i] * 2))\\n            {\\n                var min = Math.Min(dict[arr[i]], dict[arr[i] * 2]);\\n                dict[arr[i]] -= min;\\n                if (dict[arr[i]] == 0) dict.Remove(arr[i]);\\n                dict[arr[i] * 2] -= min;\\n                if (dict[arr[i] * 2] == 0) dict.Remove(arr[i] * 2);\\n            }\\n        }\\n        return dict.Count == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool CanReorderDoubled(int[] arr) {\\n        var dict = new Dictionary<int, int>();\\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            if (dict.ContainsKey(arr[i])) dict[arr[i]]++;\\n            else dict.Add(arr[i], 1);\\n        }\\n        if (dict.ContainsKey(0))\\n        {\\n            if (dict[0] % 2 != 0) return false;\\n            dict.Remove(0);\\n        }\\n        Array.Sort(arr);\\n        for (int i = 0; i < arr.Length; i++)\\n        {\\n            if (!dict.ContainsKey(arr[i])) continue;\\n            if (dict.ContainsKey(arr[i] * 2))\\n            {\\n                var min = Math.Min(dict[arr[i]], dict[arr[i] * 2]);\\n                dict[arr[i]] -= min;\\n                if (dict[arr[i]] == 0) dict.Remove(arr[i]);\\n                dict[arr[i] * 2] -= min;\\n                if (dict[arr[i] * 2] == 0) dict.Remove(arr[i] * 2);\\n            }\\n        }\\n        return dict.Count == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905858,
                "title": "use-sorting-and-a-frequency-map-well-explained",
                "content": "# Approach\\nMain idea is to form a pair like [a, b] where a=arr[i], b=a*2\\nin other words first number \\'a\\' should be two times smaller then 2nd number \\'b\\'\\nIf we sort the array in ascending order we can get ALL small numbers \\'a\\' on the left\\ni.e by sorting an array we are confident that arr[i]=a, now we need to find 2*a as a second number \\'b\\'\\n\\n```\\n// Example:\\n// a a b a b a b  a  a  b  b  b\\n// 2,3,4,5,6,9,10,12,15,18,24,30\\n// |_|_| | | | |  |  |  |  |  |\\n//   |___|_| | |  |  |  |  |  |\\n//       |___|_|  |  |  |  |  |\\n//           |____|__|__|  |  | \\n//                |__|_____|  |\\n//                   |________|\\n```\\n\\nThe only exception is negative number, for a negative number \\'a\\' formula looks like this\\na=arr[i], b=a/2\\n\\nIn order to find second number \\'b\\' in O(1) time we use \\'Frequency map\\' and keep track of the taken numbers\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar canReorderDoubled = function(arr) {\\n    const fm={};\\n    for(const n of arr) fm[n]=fm[n]+1||1;\\n    arr.sort((a,b)=>a-b);\\n\\n    let pairsCount=0;\\n    for(let i=0;i<arr.length;i++){\\n        let a=arr[i], b=(a<0 && a/2%1===0)?a/2:a*2;\\n        \\n        // handling use case with zero\\n        if(a===b && fm[a]<2) continue;\\n\\n        if(fm[b]&&fm[b]>0&&fm[a]>0) {\\n            fm[b]--;\\n            fm[a]--;\\n            pairsCount++;\\n        }\\n    }\\n    return pairsCount===arr.length/2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Example:\\n// a a b a b a b  a  a  b  b  b\\n// 2,3,4,5,6,9,10,12,15,18,24,30\\n// |_|_| | | | |  |  |  |  |  |\\n//   |___|_| | |  |  |  |  |  |\\n//       |___|_|  |  |  |  |  |\\n//           |____|__|__|  |  | \\n//                |__|_____|  |\\n//                   |________|\\n```\n```\\nvar canReorderDoubled = function(arr) {\\n    const fm={};\\n    for(const n of arr) fm[n]=fm[n]+1||1;\\n    arr.sort((a,b)=>a-b);\\n\\n    let pairsCount=0;\\n    for(let i=0;i<arr.length;i++){\\n        let a=arr[i], b=(a<0 && a/2%1===0)?a/2:a*2;\\n        \\n        // handling use case with zero\\n        if(a===b && fm[a]<2) continue;\\n\\n        if(fm[b]&&fm[b]>0&&fm[a]>0) {\\n            fm[b]--;\\n            fm[a]--;\\n            pairsCount++;\\n        }\\n    }\\n    return pairsCount===arr.length/2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3892695,
                "title": "python-3-solution-with-sorting-without-key-abs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n\\n        # sort the array and get the count of each num\\n        arr.sort()\\n        cnt = defaultdict(int)\\n        for num in arr:\\n            cnt[num] += 1\\n\\n        # iterate over the array\\n            # num < 0 -> the cnt of the num has to be smaller than the num / 2\\n                # update the cnt\\n\\n            # num >= 0 -> the cnt of the num has to be smaller than the num * 2\\n                # update the cnt\\n            \\n        for num in arr:\\n            if num < 0 and cnt[num]:\\n                if cnt[num] > cnt[num / 2]:\\n                    return False\\n                cnt[num / 2] -= cnt[num]\\n                cnt[num] = 0\\n            elif num >= 0 and cnt[num]:\\n                if cnt[num] > cnt[num * 2]:\\n                    return False\\n                cnt[num * 2] -= cnt[num]\\n                cnt[num] = 0\\n        return True \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n\\n        # sort the array and get the count of each num\\n        arr.sort()\\n        cnt = defaultdict(int)\\n        for num in arr:\\n            cnt[num] += 1\\n\\n        # iterate over the array\\n            # num < 0 -> the cnt of the num has to be smaller than the num / 2\\n                # update the cnt\\n\\n            # num >= 0 -> the cnt of the num has to be smaller than the num * 2\\n                # update the cnt\\n            \\n        for num in arr:\\n            if num < 0 and cnt[num]:\\n                if cnt[num] > cnt[num / 2]:\\n                    return False\\n                cnt[num / 2] -= cnt[num]\\n                cnt[num] = 0\\n            elif num >= 0 and cnt[num]:\\n                if cnt[num] > cnt[num * 2]:\\n                    return False\\n                cnt[num * 2] -= cnt[num]\\n                cnt[num] = 0\\n        return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832987,
                "title": "greedy-soln-sorting",
                "content": "# Complexity\\n- Time complexity: $$O(nlog(n))$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        unordered_map<double,int> m;\\n\\n        for(auto it : arr)\\n         m[1.0*it]++;\\n\\n        for(int i=0; i<arr.size(); i++)\\n        {\\n            if(m[arr[i]]) //if a number is present\\n            {\\n             m[arr[i]]--;\\n             double mul = arr[i] >= 0 ? 2.0 : 0.5; //then, its [double/half] should also be present\\n             if(m[mul*arr[i]])\\n                 m[mul*arr[i]]--;\\n             else\\n              return false; //if not present, then return false\\n            }\\n        }\\n        return true; //all pairs were present, so return true\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        unordered_map<double,int> m;\\n\\n        for(auto it : arr)\\n         m[1.0*it]++;\\n\\n        for(int i=0; i<arr.size(); i++)\\n        {\\n            if(m[arr[i]]) //if a number is present\\n            {\\n             m[arr[i]]--;\\n             double mul = arr[i] >= 0 ? 2.0 : 0.5; //then, its [double/half] should also be present\\n             if(m[mul*arr[i]])\\n                 m[mul*arr[i]]--;\\n             else\\n              return false; //if not present, then return false\\n            }\\n        }\\n        return true; //all pairs were present, so return true\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779621,
                "title": "c-easy-maps-s-olution-with-explanation",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreating a map and adding all values of array to it. \\nThen run a loop in array and chek if the number and its double is present in map or not , it not then return false and if then reduce the count from the map.\\n\\nIF any count left i.e any number which is still left in map who has not found its match then return false;\\nelse true;\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        \\n    \\n       \\n\\n        sort(arr.begin(),arr.end());\\n        map<int,int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            mp[arr[i]]++;\\n        }\\n        \\n        for(auto num:arr){\\n            if(mp[num]&& mp[num*2]){\\n                mp[num]--;\\n                mp[num*2]--;\\n            }\\n        }\\n        for(auto [a, b]:mp)\\n            if(b) return false;\\n            return true;\\n\\n    }\\n};\\n\\n\\n\\n// arr[2*i+1] = 2 * arr[2*i]\\n// i==0 arr[1] =2*arr[0];\\n// i==1 arr[3]=2*arr[2];\\n// i==2 arr[5] = 2*arr[4];\\n// i==3 arr[7] = 2*arr[6];\\n// i==4 arr[9] = 2*arr[8];\\n// i==5\\n\\n// -4 -2 2 4 \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        \\n    \\n       \\n\\n        sort(arr.begin(),arr.end());\\n        map<int,int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            mp[arr[i]]++;\\n        }\\n        \\n        for(auto num:arr){\\n            if(mp[num]&& mp[num*2]){\\n                mp[num]--;\\n                mp[num*2]--;\\n            }\\n        }\\n        for(auto [a, b]:mp)\\n            if(b) return false;\\n            return true;\\n\\n    }\\n};\\n\\n\\n\\n// arr[2*i+1] = 2 * arr[2*i]\\n// i==0 arr[1] =2*arr[0];\\n// i==1 arr[3]=2*arr[2];\\n// i==2 arr[5] = 2*arr[4];\\n// i==3 arr[7] = 2*arr[6];\\n// i==4 arr[9] = 2*arr[8];\\n// i==5\\n\\n// -4 -2 2 4 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763458,
                "title": "dart-solution",
                "content": "# Code\\n```\\nclass Solution {\\n  bool canReorderDoubled(List<int> arr) {\\n    Map<int, int> count = {};\\n    for (int x in arr) {\\n      count[x] = (count[x] ?? 0) + 1;\\n    }\\n\\n    List<int> b = List.from(arr);\\n    b.sort((a, b) => a.abs().compareTo(b.abs()));\\n\\n    for (int x in b) {\\n      if (count[x] == 0) continue;\\n      if (count[2 * x] == null || count[2 * x] == 0) return false;\\n\\n      count[x] = count[x]! - 1;\\n      count[2 * x] = count[2 * x]! - 1;\\n    }\\n\\n    return true;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  bool canReorderDoubled(List<int> arr) {\\n    Map<int, int> count = {};\\n    for (int x in arr) {\\n      count[x] = (count[x] ?? 0) + 1;\\n    }\\n\\n    List<int> b = List.from(arr);\\n    b.sort((a, b) => a.abs().compareTo(b.abs()));\\n\\n    for (int x in b) {\\n      if (count[x] == 0) continue;\\n      if (count[2 * x] == null || count[2 * x] == 0) return false;\\n\\n      count[x] = count[x]! - 1;\\n      count[2 * x] = count[2 * x]! - 1;\\n    }\\n\\n    return true;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752069,
                "title": "map-unique-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) \\n    {\\n        map<int, int> m;\\n\\n        sort(arr.begin(), arr.end());\\n        \\n        for (int i=0; i<arr.size(); i++)\\n        {\\n            int x = arr[i];\\n            int y = x*2;\\n           \\n            if(m.find(y)!=m.end())\\n            {\\n                m[y]--;\\n                if(m[y] == 0)\\n                    m.erase(y);\\n            }\\n            // agar curr element even h to ham check krenge ki\\n            // uska half map me already h ya nhi..\\n            // agr curr element odd hoga to obvious baat h uska half\\n            // check krne ki need nhi h tab ham uska double check\\n            // karenge(kyuki x ka ya to half ya double inse hi pair banana h)\\n            else if(x%2==0 && m.find(x/2)!=m.end())\\n            {\\n                m[x/2]--;\\n                if(m[x/2] == 0)\\n                    m.erase(x/2);\\n            }\\n            else\\n            {\\n                m[x]++;\\n            }\\n        }\\n\\n        if(m.size() == 0)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) \\n    {\\n        map<int, int> m;\\n\\n        sort(arr.begin(), arr.end());\\n        \\n        for (int i=0; i<arr.size(); i++)\\n        {\\n            int x = arr[i];\\n            int y = x*2;\\n           \\n            if(m.find(y)!=m.end())\\n            {\\n                m[y]--;\\n                if(m[y] == 0)\\n                    m.erase(y);\\n            }\\n            // agar curr element even h to ham check krenge ki\\n            // uska half map me already h ya nhi..\\n            // agr curr element odd hoga to obvious baat h uska half\\n            // check krne ki need nhi h tab ham uska double check\\n            // karenge(kyuki x ka ya to half ya double inse hi pair banana h)\\n            else if(x%2==0 && m.find(x/2)!=m.end())\\n            {\\n                m[x/2]--;\\n                if(m[x/2] == 0)\\n                    m.erase(x/2);\\n            }\\n            else\\n            {\\n                m[x]++;\\n            }\\n        }\\n\\n        if(m.size() == 0)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708981,
                "title": "c-solution-ii-by-using-frequency-count",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) \\n    {\\n        unordered_map<int,int>mp;\\n        for(auto x: arr)\\n        {\\n            mp[x]++;\\n        }\\n        sort(arr.begin(),arr.end());\\n         for(auto x: arr)\\n         {\\n             int twice=2*x;\\n             if(mp.find(twice)!=mp.end() and mp.find(x)!=mp.end())\\n             {\\n                 if(mp[x]>0 and mp[twice]>0)\\n                 {\\n                 mp[x]--;\\n                 mp[twice]--;\\n                 }\\n             }\\n         }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            // cout<<it->second<<\" \";\\n            if(it->second!=0)\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) \\n    {\\n        unordered_map<int,int>mp;\\n        for(auto x: arr)\\n        {\\n            mp[x]++;\\n        }\\n        sort(arr.begin(),arr.end());\\n         for(auto x: arr)\\n         {\\n             int twice=2*x;\\n             if(mp.find(twice)!=mp.end() and mp.find(x)!=mp.end())\\n             {\\n                 if(mp[x]>0 and mp[twice]>0)\\n                 {\\n                 mp[x]--;\\n                 mp[twice]--;\\n                 }\\n             }\\n         }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            // cout<<it->second<<\" \";\\n            if(it->second!=0)\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3671397,
                "title": "queue-to-check-if-everything-has-a-double-in-the-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Intuition is to sort the arr and append the first element into queue\\n- If the next element is not the double of the first element in the queue and is greater than the double that means will not have a double at all in the array. Hence return False\\n- If it is lesser append into the queue\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Implementation is the below one using queue\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- O(NlogN+N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n\\n        def solve_2(arr:List[int]) -> bool:\\n            arr.sort()\\n            queue = []\\n\\n            def isDouble(curr,top):\\n                if top < 0:\\n                    if 2*curr == top:\\n                        return True\\n                    else:\\n                        return False\\n                else:\\n                    if 2*top == curr:\\n                        return True\\n                    else:\\n                        return False\\n\\n            def checker(top):\\n                if top >= 0:\\n                    return 2*top\\n                else:\\n                    return top//2\\n\\n            for i in range(len(arr)):\\n                if len(queue) == 0:\\n                    queue.append(arr[i])\\n                else:\\n                    top = queue[0]\\n                    curr = arr[i]\\n\\n                    if isDouble(curr,top):\\n                        queue.pop(0)\\n                    else:\\n                        if checker(top) < arr[i]:\\n                            return False\\n                        else:\\n                            queue.append(arr[i])\\n            \\n            if len(queue) == 0:\\n                return True\\n            else:\\n                return False\\n\\n\\n        return solve_2(arr)\\n        # return False\\n        # return False\\n\\n                        \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n\\n        def solve_2(arr:List[int]) -> bool:\\n            arr.sort()\\n            queue = []\\n\\n            def isDouble(curr,top):\\n                if top < 0:\\n                    if 2*curr == top:\\n                        return True\\n                    else:\\n                        return False\\n                else:\\n                    if 2*top == curr:\\n                        return True\\n                    else:\\n                        return False\\n\\n            def checker(top):\\n                if top >= 0:\\n                    return 2*top\\n                else:\\n                    return top//2\\n\\n            for i in range(len(arr)):\\n                if len(queue) == 0:\\n                    queue.append(arr[i])\\n                else:\\n                    top = queue[0]\\n                    curr = arr[i]\\n\\n                    if isDouble(curr,top):\\n                        queue.pop(0)\\n                    else:\\n                        if checker(top) < arr[i]:\\n                            return False\\n                        else:\\n                            queue.append(arr[i])\\n            \\n            if len(queue) == 0:\\n                return True\\n            else:\\n                return False\\n\\n\\n        return solve_2(arr)\\n        # return False\\n        # return False\\n\\n                        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659271,
                "title": "swift-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n   func canReorderDoubled(_ arr: [Int]) -> Bool {\\n    var arr = arr.sorted()\\n    var length = arr.count\\n    var map = [Int:Int]()\\n    for i in arr{\\n        map[i,default:0] += 1\\n    }\\n    \\n    for i in 0..<length{\\n        if map[arr[i]] == 0 {\\n            continue\\n        }\\n        if map[arr[i] * 2] ?? 0 > 0{\\n            map[arr[i] * 2]! -= 1\\n            map[arr[i]]! -= 1\\n        }\\n    }\\n    \\n    for i in map{\\n        if i.value != 0{\\n            return false\\n        }\\n    }\\n    return true\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n   func canReorderDoubled(_ arr: [Int]) -> Bool {\\n    var arr = arr.sorted()\\n    var length = arr.count\\n    var map = [Int:Int]()\\n    for i in arr{\\n        map[i,default:0] += 1\\n    }\\n    \\n    for i in 0..<length{\\n        if map[arr[i]] == 0 {\\n            continue\\n        }\\n        if map[arr[i] * 2] ?? 0 > 0{\\n            map[arr[i] * 2]! -= 1\\n            map[arr[i]]! -= 1\\n        }\\n    }\\n    \\n    for i in map{\\n        if i.value != 0{\\n            return false\\n        }\\n    }\\n    return true\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649567,
                "title": "array-of-doubled-pairs",
                "content": "# Code\\n```\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        arr.sort()\\n        d = {}\\n        count = 0\\n        for i in arr:\\n            if i>0:\\n                if i in d:\\n                    d[i]+=1\\n                else:\\n                    if i%2!=0 and i not in d:\\n                        d[i]=1\\n                    elif i not in d :\\n                        if i//2 not in d:\\n                            d[i] = 1\\n                        elif d[i//2]==0:\\n                            d[i] = 1\\n                        else:\\n                            d[i//2]-=1\\n                            count +=1\\n            else:\\n                if i in d:\\n                    d[i]+=1\\n                else:\\n                    if (i%2!=0 and i not in d) and i*2 not in d:\\n                        d[i]=1\\n                    if i not in d :\\n                        if i*2 not in d:\\n                            d[i] = 1\\n                        elif i*2 in d:\\n                            if d[i*2]==0:\\n                                d[i] = 1\\n                            else:\\n                                d[i*2]-=1\\n                                count+=1\\n        count+= arr.count(0)//2\\n        if count>= len(arr)//2:\\n            return (True)\\n        else:\\n            return (False)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        arr.sort()\\n        d = {}\\n        count = 0\\n        for i in arr:\\n            if i>0:\\n                if i in d:\\n                    d[i]+=1\\n                else:\\n                    if i%2!=0 and i not in d:\\n                        d[i]=1\\n                    elif i not in d :\\n                        if i//2 not in d:\\n                            d[i] = 1\\n                        elif d[i//2]==0:\\n                            d[i] = 1\\n                        else:\\n                            d[i//2]-=1\\n                            count +=1\\n            else:\\n                if i in d:\\n                    d[i]+=1\\n                else:\\n                    if (i%2!=0 and i not in d) and i*2 not in d:\\n                        d[i]=1\\n                    if i not in d :\\n                        if i*2 not in d:\\n                            d[i] = 1\\n                        elif i*2 in d:\\n                            if d[i*2]==0:\\n                                d[i] = 1\\n                            else:\\n                                d[i*2]-=1\\n                                count+=1\\n        count+= arr.count(0)//2\\n        if count>= len(arr)//2:\\n            return (True)\\n        else:\\n            return (False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639939,
                "title": "c-sort-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        map<int,int> mp;\\n    sort(arr.begin(),arr.end());\\n        for (int i=0; i<arr.size(); i++)\\n        {\\n            mp[arr[i]]++;\\n        }\\n        for (int i=0; i<arr.size(); i++){\\n            if (mp[arr[i]]==0)continue;\\n            if (mp[arr[i]*2]>0){\\n                mp[arr[i]*2]--;\\n                mp[arr[i]]--;\\n            }\\n        }\\n        for (auto it: mp){\\n            if(it.second)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        map<int,int> mp;\\n    sort(arr.begin(),arr.end());\\n        for (int i=0; i<arr.size(); i++)\\n        {\\n            mp[arr[i]]++;\\n        }\\n        for (int i=0; i<arr.size(); i++){\\n            if (mp[arr[i]]==0)continue;\\n            if (mp[arr[i]*2]>0){\\n                mp[arr[i]*2]--;\\n                mp[arr[i]]--;\\n            }\\n        }\\n        for (auto it: mp){\\n            if(it.second)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497946,
                "title": "o-n-time-and-storage-using-python-counter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo, we have an array and we want to rearrange the numbers so that every odd-indexed number is twice the preceding number.  This suggested to me that what we\\'re doing is trying to find (x,2x) pairs from the numbers, so I started out thinking that maybe this could be solved by some kind of graph analysis (e.g., do the numbers form a bipartite graph).  After a while, though, I settled on an approach closer to the problem statement:  For every number in ```nums``` (I renamed ```arr```), look for twice that number in ```nums``` and remove both from the list; at the end, if we\\'ve got an empty list, the result is ```True```.\\n\\nIn the end, I found that doing ```|nums|``` lookups and handling the \"remove both\" got a TLE for the big examples.  In particular, I got it on the test case that\\'s thousands of numbers, all 0\\'s, 1\\'s or 2\\'s.  So, I started thinking about one of my favorite constructs, the Python ```Counter```.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, I count all the values in ```nums``` using a Counter.  Then, I go through the value:count pairs in increasing abs(value).  For each pair of values, call it ```num_value``` and \"dbl_num_value\", I see whether there are more ```x``` values than there are ```2*x``` values; if that\\'s the case, the result is already ```False```, since we can\\'t pair all the ```x```s.  Otherwise, I subtract the ```x``` count from the ```2*x``` count and set the ```x``` count to 0.   Finally, at the end, I look at the total counts in the Counter, and iff it\\'s 0, then the result is ```True```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe part of the heavy lifting is done by the ```Counter``` constructor; it\\'s still $$O(n)$$ and probably all executed in implementation code (C++) rather than the Python interpreter.  The other part is the manipulation of the resulting counts, but this, too, is at worst $$O(n)$$ (depends on the number of counters).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe only input-dependent storage (other than the input array) is the Counter, which grows as $$O(n)$$ at worst, ususally smaller if values are frequently repeated.\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def canReorderDoubled(self, nums: List[int]) -> bool:\\n        counts = Counter( nums )\\n        if counts == 0:\\n            return True\\n        for num_val in sorted( counts.keys(), key = abs ):\\n            num_count = counts[ num_val ]\\n            dbl_num_val = 2 * num_val\\n            dbl_num_count = counts[ dbl_num_val ]\\n            if num_count > dbl_num_count:    # Not enough to cover \"num_val\"\\n                return False\\n            else:\\n                counts[ dbl_num_val ] -= counts[ num_val ]\\n                counts[ num_val ] = 0\\n        return counts.total() == 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```nums```\n```arr```\n```nums```\n```True```\n```|nums|```\n```Counter```\n```nums```\n```num_value```\n```x```\n```2*x```\n```False```\n```x```\n```x```\n```2*x```\n```x```\n```True```\n```Counter```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def canReorderDoubled(self, nums: List[int]) -> bool:\\n        counts = Counter( nums )\\n        if counts == 0:\\n            return True\\n        for num_val in sorted( counts.keys(), key = abs ):\\n            num_count = counts[ num_val ]\\n            dbl_num_val = 2 * num_val\\n            dbl_num_count = counts[ dbl_num_val ]\\n            if num_count > dbl_num_count:    # Not enough to cover \"num_val\"\\n                return False\\n            else:\\n                counts[ dbl_num_val ] -= counts[ num_val ]\\n                counts[ num_val ] = 0\\n        return counts.total() == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491296,
                "title": "java-using-hashmap-and-sorting-with-comments",
                "content": "\\n // b <==========954. Array of Doubled Pairs ==========>\\n    // https://leetcode.com/problems/array-of-doubled-pairs/description/\\n\\n    // [0,0,2,4,1,8], [-16,-2,-8,-4] : Test cases to dry run\\n\\n    // Hume basically yahan pe pucha hai ki can we rearrange array such that array\\n    // ` becomes like [a,2a,b,2b,c,2c,d,2d].\\n\\n    // So hume basically har ek element ke liye uska pair dhundhna hai. Aur agar har\\n    // ek element ke liye uska pair mil jata hai to wo rearrange ho sakta hai.\\n\\n    // Humne hashmap mai har ek element ki frequency nikali\\n    // Ab agar humne array ko normally sort kiya to hume array aise milega.\\n    // -16,-8,-4,-2,0,0,1,2,4,8,. Jisme hume -ve elements ke liye unka half check\\n    // karna padega aur +ve elements ke liye unka double.\\n\\n    // Ab agar mai chahta hun ki mujhe har element ka double he check karna page, to\\n    // isiliye maine Arr ko apne hisab se sorrt karunga. To do this, mujhe Apna ek\\n    // Integer class ka array banana padega since int is a primitive type.\\n\\n    // So now the array will be sorted like treating the -ve number as +ve.\\n\\n    // 0,0,1,2,-2,4,-4,-8,8,-16.\\n\\n```\\npublic boolean canReorderDoubled(int[] arr) {\\n\\n        int n = arr.length;\\n        Integer[] Arr = new Integer[n];\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\\n            Arr[i] = arr[i];\\n        }\\n\\n        Arrays.sort(Arr, (a, b) -> { // Sorting the array as if the -ve number are +ve.\\n            return Math.abs(a) - Math.abs(b);\\n        });\\n\\n        for (int ele : Arr) {\\n            if (map.get(ele) == 0) // If frequency is zero, the element has already been paired.\\n                continue;\\n            if (map.getOrDefault(ele * 2, 0) <= 0) // If we cannot find a 2*ele, we cannot pair this element. Hence\\n                                                   // returning false.\\n                return false;\\n\\n            // Since a pairing requires both elements, decreasing the frequency of both the\\n            // elements of the pair.\\n            map.put(ele, map.get(ele) - 1);\\n            map.put(2 * ele, map.get(ele * 2) - 1);\\n        }\\n\\n        return true;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canReorderDoubled(int[] arr) {\\n\\n        int n = arr.length;\\n        Integer[] Arr = new Integer[n];\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\\n            Arr[i] = arr[i];\\n        }\\n\\n        Arrays.sort(Arr, (a, b) -> { // Sorting the array as if the -ve number are +ve.\\n            return Math.abs(a) - Math.abs(b);\\n        });\\n\\n        for (int ele : Arr) {\\n            if (map.get(ele) == 0) // If frequency is zero, the element has already been paired.\\n                continue;\\n            if (map.getOrDefault(ele * 2, 0) <= 0) // If we cannot find a 2*ele, we cannot pair this element. Hence\\n                                                   // returning false.\\n                return false;\\n\\n            // Since a pairing requires both elements, decreasing the frequency of both the\\n            // elements of the pair.\\n            map.put(ele, map.get(ele) - 1);\\n            map.put(2 * ele, map.get(ele * 2) - 1);\\n        }\\n\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3480833,
                "title": "array-of-doubled-pairs",
                "content": "# Intuition\\nArray of Doubled Pairs\\n\\n# Approach\\nArray of Doubled Pairs\\n\\n# Complexity\\n- Time complexity:\\nArray of Doubled Pairs\\n\\n- Space complexity:\\nArray of Doubled Pairs\\n\\n# Code\\n```\\nclass Solution {\\n    func canReorderDoubled(_ arr: [Int]) -> Bool {\\n        var answer = true\\n        var arr = arr\\n        arr.sort()\\n        while answer {\\n            var n = arr[0]\\n            for i in 1..<arr.count {\\n                if n == arr[i] / 2 && arr[i] % 2 != 1 || n == arr[i] * 2 {\\n                    arr.remove(at: i)\\n                    arr.removeFirst()\\n                    answer = true\\n                    break\\n                } else {\\n                    answer = false\\n                }\\n            }\\n            if arr.isEmpty {\\n                break\\n            }\\n        }\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func canReorderDoubled(_ arr: [Int]) -> Bool {\\n        var answer = true\\n        var arr = arr\\n        arr.sort()\\n        while answer {\\n            var n = arr[0]\\n            for i in 1..<arr.count {\\n                if n == arr[i] / 2 && arr[i] % 2 != 1 || n == arr[i] * 2 {\\n                    arr.remove(at: i)\\n                    arr.removeFirst()\\n                    answer = true\\n                    break\\n                } else {\\n                    answer = false\\n                }\\n            }\\n            if arr.isEmpty {\\n                break\\n            }\\n        }\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472207,
                "title": "hashing-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) \\n    {\\n        vector<int> p, n;\\n        map<int,int> m;\\n        int zeros=0;\\n        for(auto it: arr) \\n        {\\n            if(it>0) p.push_back(it);\\n            else if(it<0) n.push_back(it);\\n            else zeros++;\\n            if(it) m[it]++;\\n        }\\n        if(zeros%2) return false;\\n        sort(p.begin(),p.end());\\n        sort(n.begin(),n.end(),greater<int>());\\n        for(auto it: p)\\n        {\\n            if(m[it]>0)\\n            {\\n                if(m[2*it]>0)\\n                {\\n                    m[it]--;\\n                    m[2*it]--;\\n                }\\n                else return false;\\n            }\\n        }\\n        for(auto it: n)\\n        {\\n            if(m[it]>0)\\n            {\\n                if(m[2*it]>0)\\n                {\\n                    m[it]--;\\n                    m[2*it]--;\\n                }\\n                else return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) \\n    {\\n        vector<int> p, n;\\n        map<int,int> m;\\n        int zeros=0;\\n        for(auto it: arr) \\n        {\\n            if(it>0) p.push_back(it);\\n            else if(it<0) n.push_back(it);\\n            else zeros++;\\n            if(it) m[it]++;\\n        }\\n        if(zeros%2) return false;\\n        sort(p.begin(),p.end());\\n        sort(n.begin(),n.end(),greater<int>());\\n        for(auto it: p)\\n        {\\n            if(m[it]>0)\\n            {\\n                if(m[2*it]>0)\\n                {\\n                    m[it]--;\\n                    m[2*it]--;\\n                }\\n                else return false;\\n            }\\n        }\\n        for(auto it: n)\\n        {\\n            if(m[it]>0)\\n            {\\n                if(m[2*it]>0)\\n                {\\n                    m[it]--;\\n                    m[2*it]--;\\n                }\\n                else return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399480,
                "title": "simple-c-solution-using-multiset",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        multiset<int> st;\\n\\n        for(int i=0 ; i<n ; i++) st.insert(arr[i]);\\n        sort(arr.begin() , arr.end());\\n\\n        for(int i=0 ; i<n ; i++){\\n            if(st.find(arr[i])!=st.end() and st.find(2*arr[i])!=st.end()){\\n                auto it = st.find(arr[i]);\\n                st.erase(it);\\n                it = st.find(2*arr[i]);\\n                if(it!=st.end())\\n                    st.erase(it);\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        return st.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        multiset<int> st;\\n\\n        for(int i=0 ; i<n ; i++) st.insert(arr[i]);\\n        sort(arr.begin() , arr.end());\\n\\n        for(int i=0 ; i<n ; i++){\\n            if(st.find(arr[i])!=st.end() and st.find(2*arr[i])!=st.end()){\\n                auto it = st.find(arr[i]);\\n                st.erase(it);\\n                it = st.find(2*arr[i]);\\n                if(it!=st.end())\\n                    st.erase(it);\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        return st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393346,
                "title": "c-easy-solution-using-hash-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        unordered_map<int,int> mp;\\n        int n=arr.size();\\n        for (int c : arr) {\\n            mp[c]++;\\n        }\\n        sort(arr.begin(),arr.end());\\n        vector<int> ans;\\n        for (int i=0;i<n;i++) {\\n            if (mp[arr[i]] && mp[arr[i]*2]) {\\n                mp[arr[i]]--;\\n                mp[arr[i]*2]--;\\n                ans.push_back(arr[i]);\\n            }\\n        }\\n        for (auto& m : mp) {\\n            if (m.second) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        unordered_map<int,int> mp;\\n        int n=arr.size();\\n        for (int c : arr) {\\n            mp[c]++;\\n        }\\n        sort(arr.begin(),arr.end());\\n        vector<int> ans;\\n        for (int i=0;i<n;i++) {\\n            if (mp[arr[i]] && mp[arr[i]*2]) {\\n                mp[arr[i]]--;\\n                mp[arr[i]*2]--;\\n                ans.push_back(arr[i]);\\n            }\\n        }\\n        for (auto& m : mp) {\\n            if (m.second) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356103,
                "title": "solution-using-hash-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Save all elements in a hash table. \\n2. Sort the given array.\\n3. Starting from 0,\\n      a. for negative numbers, check for the presence of num/2.\\n      b. for positive numbers, check for the presense of num * 2.\\n    with this approach target numbers always lie to the right of current number.\\n      c. If target numbers are found, subtract them and update their frequencies. Maintain a tracking variable \"consumed numbers\". \\n      d. Handle zero has a special case.\\n4. When the array is parsed, check if all numbers have been consumed.\\n\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint N;\\n\\nint consumed_numbers;\\nstruct LL\\n{\\n    int val;\\n    int freq;\\n    struct LL* next;\\n};\\n\\nvoid merge (int* a, int l, int m, int r)\\n{\\n    int i, j, k;\\n    int n1, n2;\\n\\n    n1 = m - l + 1;\\n    n2 = r - m;\\n\\n    int L[n1];\\n    int R[n2];\\n\\n    for (i = 0; i < n1; i++)\\n        L[i] = a[l + i];\\n    for (i = 0; i < n2; i++)\\n        R[i] = a[m+1 + i];\\n\\n    i = j = 0;\\n    k = l;\\n    while (i < n1 && j < n2)\\n    {\\n        if (L[i] < R[j])\\n        {\\n            a[k] = L[i];\\n            i++;\\n        }\\n        else\\n        {\\n            a[k] = R[j];\\n            j++;\\n        }\\n        k++;\\n    }\\n    while (i < n1)\\n    {\\n        {\\n            a[k] = L[i];\\n            i++;\\n        }\\n        k++;\\n    }\\n    while (j < n2)\\n    {\\n        {\\n            a[k] = R[j];\\n            j++;\\n        }\\n        k++;\\n    }\\n\\n\\n}\\n\\nvoid mergesort (int* a, int l, int r)\\n{\\n    int m;\\n    if (l < r)\\n    {\\n        m = l + (r - l)/2;\\n\\n        mergesort (a, l, m);\\n        mergesort (a, m+1, r);\\n\\n        merge (a, l, m, r);\\n    }\\n}\\n\\n#define HASH(x) ((100000 + (x))%4999)\\n\\nstruct LL* new_node (int val)\\n{\\n    struct LL* temp = (struct LL*) malloc (sizeof(struct LL));\\n    temp->val = val;\\n    temp->next = NULL;\\n    temp->freq = 1;\\n    return temp;\\n}\\n\\nstruct LL* HT[4999];\\n\\nvoid save (int val)\\n{\\n    int h = HASH(val);\\n\\n    if (HT[h])\\n    {\\n        if (HT[h]->val == val)\\n        {\\n            HT[h]->freq++;\\n            return;\\n        }\\n        if (HT[h]->next)\\n        {\\n            struct LL* node = HT[h];\\n\\n            while (node->next)\\n            {\\n                if (node->next->val == val)\\n                {\\n                    node->next->freq++;\\n                    return;\\n                }\\n                node = node->next;\\n            }\\n\\n            node->next = new_node (val);\\n        }\\n    }\\n    else\\n    {\\n        HT[h] = new_node (val);\\n    }\\n}\\n\\n\\n\\nint get_freq (int val)\\n{\\n    int h = HASH(val);\\n\\n    if (HT[h])\\n    {\\n        if (HT[h]->val == val && HT[h]->freq > 0)\\n        {\\n            return HT[h]->freq;\\n        }\\n        if (HT[h]->next)\\n        {\\n            struct LL* node = HT[h];\\n\\n            while (node->next)\\n            {\\n                if (node->next->val == val && node->next->freq > 0)\\n                    return node->next->freq;\\n                node = node->next;\\n            }\\n        }\\n    }\\n    return 0;\\n}\\n\\nvoid set_freq (int val, int freq)\\n{\\n    int h = HASH(val);\\n\\n    if (HT[h])\\n    {\\n        if (HT[h]->val == val)\\n        {\\n            HT[h]->freq = freq;\\n            return;\\n        }\\n        if (HT[h]->next)\\n        {\\n            struct LL* node = HT[h];\\n            while (node->next)\\n            {\\n                if (node->next->val == val)\\n                {\\n                    node->next->freq = freq;\\n                    return;\\n                }\\n                node = node->next;\\n            }\\n        }\\n    }\\n}\\n\\n\\n\\nvoid delete (int a, int b)\\n{\\n    int fa = get_freq (a);\\n    int fb = get_freq (b);\\n\\n    //printf (\"Deleting %d and %d. consumed = %d\\\\n\", a, b, consumed_numbers);\\n\\n    if (fa > fb)\\n    {\\n        set_freq (a, fa-fb);\\n        set_freq (b, 0);\\n        consumed_numbers -= 2 * fb;\\n    }\\n    else\\n    {\\n        set_freq (b, fb-fa);\\n        set_freq (a, 0);\\n        consumed_numbers -= 2 * fa;\\n    }\\n\\n    //printf (\"Exiting Delete consumed = %d\\\\n\", consumed_numbers);\\n}\\n\\nbool canReorderDoubled(int* arr, int arrSize)\\n{\\n    N = arrSize;\\n    consumed_numbers = N;\\n    int freq1, freq2;\\n    int zero_count = 0;\\n    memset (HT, 0, sizeof(struct LL*) * 4999);\\n    for (int i = 0; i < N; i++)\\n    {\\n        save (arr[i]);\\n    }\\n    mergesort (arr, 0, arrSize-1);\\n\\n    for (int i = 0; i < arrSize; i++)\\n    {\\n        if (arr[i] < 0)\\n        {\\n            if (arr[i] % 2 == 0 && get_freq(arr[i]) && get_freq(arr[i] / 2))\\n                delete (arr[i], arr[i] / 2);\\n        }\\n        else if (arr[i] > 0)\\n        {\\n            if (get_freq(arr[i]) && get_freq(arr[i] * 2))\\n            {\\n                delete (arr[i], arr[i] * 2);\\n            }\\n        }\\n        else\\n        {\\n            zero_count++;\\n            consumed_numbers--;\\n        }\\n    }\\n    if (zero_count % 2 != 0)\\n        consumed_numbers = 1;\\n    return (consumed_numbers == 0);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nint N;\\n\\nint consumed_numbers;\\nstruct LL\\n{\\n    int val;\\n    int freq;\\n    struct LL* next;\\n};\\n\\nvoid merge (int* a, int l, int m, int r)\\n{\\n    int i, j, k;\\n    int n1, n2;\\n\\n    n1 = m - l + 1;\\n    n2 = r - m;\\n\\n    int L[n1];\\n    int R[n2];\\n\\n    for (i = 0; i < n1; i++)\\n        L[i] = a[l + i];\\n    for (i = 0; i < n2; i++)\\n        R[i] = a[m+1 + i];\\n\\n    i = j = 0;\\n    k = l;\\n    while (i < n1 && j < n2)\\n    {\\n        if (L[i] < R[j])\\n        {\\n            a[k] = L[i];\\n            i++;\\n        }\\n        else\\n        {\\n            a[k] = R[j];\\n            j++;\\n        }\\n        k++;\\n    }\\n    while (i < n1)\\n    {\\n        {\\n            a[k] = L[i];\\n            i++;\\n        }\\n        k++;\\n    }\\n    while (j < n2)\\n    {\\n        {\\n            a[k] = R[j];\\n            j++;\\n        }\\n        k++;\\n    }\\n\\n\\n}\\n\\nvoid mergesort (int* a, int l, int r)\\n{\\n    int m;\\n    if (l < r)\\n    {\\n        m = l + (r - l)/2;\\n\\n        mergesort (a, l, m);\\n        mergesort (a, m+1, r);\\n\\n        merge (a, l, m, r);\\n    }\\n}\\n\\n#define HASH(x) ((100000 + (x))%4999)\\n\\nstruct LL* new_node (int val)\\n{\\n    struct LL* temp = (struct LL*) malloc (sizeof(struct LL));\\n    temp->val = val;\\n    temp->next = NULL;\\n    temp->freq = 1;\\n    return temp;\\n}\\n\\nstruct LL* HT[4999];\\n\\nvoid save (int val)\\n{\\n    int h = HASH(val);\\n\\n    if (HT[h])\\n    {\\n        if (HT[h]->val == val)\\n        {\\n            HT[h]->freq++;\\n            return;\\n        }\\n        if (HT[h]->next)\\n        {\\n            struct LL* node = HT[h];\\n\\n            while (node->next)\\n            {\\n                if (node->next->val == val)\\n                {\\n                    node->next->freq++;\\n                    return;\\n                }\\n                node = node->next;\\n            }\\n\\n            node->next = new_node (val);\\n        }\\n    }\\n    else\\n    {\\n        HT[h] = new_node (val);\\n    }\\n}\\n\\n\\n\\nint get_freq (int val)\\n{\\n    int h = HASH(val);\\n\\n    if (HT[h])\\n    {\\n        if (HT[h]->val == val && HT[h]->freq > 0)\\n        {\\n            return HT[h]->freq;\\n        }\\n        if (HT[h]->next)\\n        {\\n            struct LL* node = HT[h];\\n\\n            while (node->next)\\n            {\\n                if (node->next->val == val && node->next->freq > 0)\\n                    return node->next->freq;\\n                node = node->next;\\n            }\\n        }\\n    }\\n    return 0;\\n}\\n\\nvoid set_freq (int val, int freq)\\n{\\n    int h = HASH(val);\\n\\n    if (HT[h])\\n    {\\n        if (HT[h]->val == val)\\n        {\\n            HT[h]->freq = freq;\\n            return;\\n        }\\n        if (HT[h]->next)\\n        {\\n            struct LL* node = HT[h];\\n            while (node->next)\\n            {\\n                if (node->next->val == val)\\n                {\\n                    node->next->freq = freq;\\n                    return;\\n                }\\n                node = node->next;\\n            }\\n        }\\n    }\\n}\\n\\n\\n\\nvoid delete (int a, int b)\\n{\\n    int fa = get_freq (a);\\n    int fb = get_freq (b);\\n\\n    //printf (\"Deleting %d and %d. consumed = %d\\\\n\", a, b, consumed_numbers);\\n\\n    if (fa > fb)\\n    {\\n        set_freq (a, fa-fb);\\n        set_freq (b, 0);\\n        consumed_numbers -= 2 * fb;\\n    }\\n    else\\n    {\\n        set_freq (b, fb-fa);\\n        set_freq (a, 0);\\n        consumed_numbers -= 2 * fa;\\n    }\\n\\n    //printf (\"Exiting Delete consumed = %d\\\\n\", consumed_numbers);\\n}\\n\\nbool canReorderDoubled(int* arr, int arrSize)\\n{\\n    N = arrSize;\\n    consumed_numbers = N;\\n    int freq1, freq2;\\n    int zero_count = 0;\\n    memset (HT, 0, sizeof(struct LL*) * 4999);\\n    for (int i = 0; i < N; i++)\\n    {\\n        save (arr[i]);\\n    }\\n    mergesort (arr, 0, arrSize-1);\\n\\n    for (int i = 0; i < arrSize; i++)\\n    {\\n        if (arr[i] < 0)\\n        {\\n            if (arr[i] % 2 == 0 && get_freq(arr[i]) && get_freq(arr[i] / 2))\\n                delete (arr[i], arr[i] / 2);\\n        }\\n        else if (arr[i] > 0)\\n        {\\n            if (get_freq(arr[i]) && get_freq(arr[i] * 2))\\n            {\\n                delete (arr[i], arr[i] * 2);\\n            }\\n        }\\n        else\\n        {\\n            zero_count++;\\n            consumed_numbers--;\\n        }\\n    }\\n    if (zero_count % 2 != 0)\\n        consumed_numbers = 1;\\n    return (consumed_numbers == 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3215228,
                "title": "using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing two maps, one for non-negative int and negative int\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n       map<int,int>mp;\\n       map<int,int,greater<int>>mp2;\\n        for(auto x:arr){\\n            if(x>=0) mp[x]++;\\n            else mp2[x]++;\\n        }\\n        if(mp.find(0)!=mp.end()){\\n            if(mp[0]%2!=0) return false;\\n            else mp.erase(0);\\n        }\\n        for(auto x:mp){\\n            while(x.second>0){\\n                if(mp.find(2*x.first)!=mp.end()&&mp[2*x.first]>0){\\n                    x.second--;\\n                    mp[2*x.first]--;\\n                }\\n                else return false;\\n            }\\n        }\\n         for(auto x:mp2){\\n            while(x.second>0){\\n                if(mp2.find(2*x.first)!=mp2.end()&&mp2[2*x.first]>0){\\n                    x.second--;\\n                    mp2[2*x.first]--;\\n                }\\n                else return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n       map<int,int>mp;\\n       map<int,int,greater<int>>mp2;\\n        for(auto x:arr){\\n            if(x>=0) mp[x]++;\\n            else mp2[x]++;\\n        }\\n        if(mp.find(0)!=mp.end()){\\n            if(mp[0]%2!=0) return false;\\n            else mp.erase(0);\\n        }\\n        for(auto x:mp){\\n            while(x.second>0){\\n                if(mp.find(2*x.first)!=mp.end()&&mp[2*x.first]>0){\\n                    x.second--;\\n                    mp[2*x.first]--;\\n                }\\n                else return false;\\n            }\\n        }\\n         for(auto x:mp2){\\n            while(x.second>0){\\n                if(mp2.find(2*x.first)!=mp2.end()&&mp2[2*x.first]>0){\\n                    x.second--;\\n                    mp2[2*x.first]--;\\n                }\\n                else return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188314,
                "title": "o-n-log-n-time-using-arr-sort-js-solution-for-954-array-of-doubled-pairs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\n\\nconst canReorderDoubled = (arr) => {\\n    const counter = arr.reduce((counter, num) => {\\n        counter[num] = (counter[num] || 0) + 1;\\n        return counter;\\n    }, {});\\n    const sortedNums = Object.keys(counter).sort((a, b) => a - b);\\n\\n    for (let curNum of sortedNums) {\\n        if (!(curNum in counter)) {\\n            continue;\\n        }\\n\\n        const curNumAmount = counter[curNum];\\n        const doubledNum = (curNum < 0) ? curNum / 2 : 2 * curNum;\\n        const doubledNumAmount = counter[doubledNum];\\n\\n        delete counter[curNum];\\n\\n        if (curNum === 0) {\\n            if (curNumAmount % 2) {\\n                return false;\\n            }\\n        } else {\\n            if (!doubledNumAmount || doubledNumAmount < curNumAmount) {\\n                return false;\\n            }\\n\\n            if (doubledNumAmount === curNumAmount) {\\n                delete counter[doubledNum];\\n            } else {\\n                counter[doubledNum] = doubledNumAmount - curNumAmount;\\n            }\\n        }\\n    }\\n\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\n\\nconst canReorderDoubled = (arr) => {\\n    const counter = arr.reduce((counter, num) => {\\n        counter[num] = (counter[num] || 0) + 1;\\n        return counter;\\n    }, {});\\n    const sortedNums = Object.keys(counter).sort((a, b) => a - b);\\n\\n    for (let curNum of sortedNums) {\\n        if (!(curNum in counter)) {\\n            continue;\\n        }\\n\\n        const curNumAmount = counter[curNum];\\n        const doubledNum = (curNum < 0) ? curNum / 2 : 2 * curNum;\\n        const doubledNumAmount = counter[doubledNum];\\n\\n        delete counter[curNum];\\n\\n        if (curNum === 0) {\\n            if (curNumAmount % 2) {\\n                return false;\\n            }\\n        } else {\\n            if (!doubledNumAmount || doubledNumAmount < curNumAmount) {\\n                return false;\\n            }\\n\\n            if (doubledNumAmount === curNumAmount) {\\n                delete counter[doubledNum];\\n            } else {\\n                counter[doubledNum] = doubledNumAmount - curNumAmount;\\n            }\\n        }\\n    }\\n\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3188227,
                "title": "o-n-2-time-using-map-js-solution-for-954-array-of-doubled-pairs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n ^ 2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nconst getMinNumFromIterable = (nums) => {\\n    let min = +Infinity;\\n    for (let num of nums) {\\n        if (num < min) {\\n            min = num;\\n        }\\n    }\\n    return min;\\n};\\n\\nconst canReorderDoubled = (arr) => {\\n    const counter = arr.reduce((counter, num) => {\\n        counter.set(num, (counter.get(num) || 0) + 1);\\n        return counter;\\n    }, new Map());\\n\\n    while (counter.size) {\\n        const curNum = getMinNumFromIterable(counter.keys());\\n        const curNumAmount = counter.get(curNum);\\n        const doubledNum = (curNum < 0) ? curNum / 2 : 2 * curNum;\\n        const doubledNumAmount = counter.get(doubledNum);\\n\\n        counter.delete(curNum);\\n\\n        if (curNum === 0) {\\n            if (curNumAmount % 2) {\\n                return false;\\n            }\\n        } else {\\n            if (!doubledNumAmount || doubledNumAmount < curNumAmount) {\\n                return false;\\n            }\\n\\n            if (doubledNumAmount === curNumAmount) {\\n                counter.delete(doubledNum);\\n            } else {\\n                counter.set(doubledNum, doubledNumAmount - curNumAmount);\\n            }\\n        }\\n    }\\n\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nconst getMinNumFromIterable = (nums) => {\\n    let min = +Infinity;\\n    for (let num of nums) {\\n        if (num < min) {\\n            min = num;\\n        }\\n    }\\n    return min;\\n};\\n\\nconst canReorderDoubled = (arr) => {\\n    const counter = arr.reduce((counter, num) => {\\n        counter.set(num, (counter.get(num) || 0) + 1);\\n        return counter;\\n    }, new Map());\\n\\n    while (counter.size) {\\n        const curNum = getMinNumFromIterable(counter.keys());\\n        const curNumAmount = counter.get(curNum);\\n        const doubledNum = (curNum < 0) ? curNum / 2 : 2 * curNum;\\n        const doubledNumAmount = counter.get(doubledNum);\\n\\n        counter.delete(curNum);\\n\\n        if (curNum === 0) {\\n            if (curNumAmount % 2) {\\n                return false;\\n            }\\n        } else {\\n            if (!doubledNumAmount || doubledNumAmount < curNumAmount) {\\n                return false;\\n            }\\n\\n            if (doubledNumAmount === curNumAmount) {\\n                counter.delete(doubledNum);\\n            } else {\\n                counter.set(doubledNum, doubledNumAmount - curNumAmount);\\n            }\\n        }\\n    }\\n\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3148089,
                "title": "easy-faster-efficient-java-son",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        Map<Integer, Integer> map = new TreeMap<>();\\n\\n        for(int i = 0; i < arr.length; i++){\\n            int val = arr[i];\\n            map.put(val, map.getOrDefault(val, 0) + 1);\\n        }\\n\\n        for(int key : map.keySet()){\\n            if(map.get(key) == 0){\\n                continue;\\n            }\\n            if(key < 0 && key % 2 != 0){\\n                return false;\\n            }\\n            int tar = key < 0 ? key / 2 : key * 2;\\n            \\n            if(map.get(key) > map.getOrDefault(tar, 0)){\\n                return false;\\n            }\\n            map.put(tar, map.get(tar) - map.get(key));\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        Map<Integer, Integer> map = new TreeMap<>();\\n\\n        for(int i = 0; i < arr.length; i++){\\n            int val = arr[i];\\n            map.put(val, map.getOrDefault(val, 0) + 1);\\n        }\\n\\n        for(int key : map.keySet()){\\n            if(map.get(key) == 0){\\n                continue;\\n            }\\n            if(key < 0 && key % 2 != 0){\\n                return false;\\n            }\\n            int tar = key < 0 ? key / 2 : key * 2;\\n            \\n            if(map.get(key) > map.getOrDefault(tar, 0)){\\n                return false;\\n            }\\n            map.put(tar, map.get(tar) - map.get(key));\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138108,
                "title": "one-sort-one-for-easy-to-understand-ts-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are sorting array in that order [(-1 to -100), zeroes, (1 to 100)];\\nEvery time we start from first element and search if there\\'s one two times bigger, if yes we delete both elements and next itteration will start again from first element. \\n\\n\\n# Code\\n```\\nfunction canReorderDoubled(arr: number[]): boolean {\\n  const sorted = arr.sort((a: number, b: number) => {\\n    if (b < 0 && a < 0) {\\n      return b - a;\\n    }\\n\\n    return a - b;\\n  });\\n\\n  const copy: number[] = [...sorted];\\n\\n  for (const el of sorted) {\\n    if (!copy.includes(el)) {\\n      continue;\\n    }\\n\\n    const index = copy.indexOf(el * 2);\\n\\n    if (~index) {\\n      copy.splice(index, 1);\\n      copy.splice(0, 1);\\n      continue;\\n    }\\n\\n    return false;\\n  }\\n\\n  return true;\\n};\\n\\n```\\n\\n\\nProbably can be optimised with while loop.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction canReorderDoubled(arr: number[]): boolean {\\n  const sorted = arr.sort((a: number, b: number) => {\\n    if (b < 0 && a < 0) {\\n      return b - a;\\n    }\\n\\n    return a - b;\\n  });\\n\\n  const copy: number[] = [...sorted];\\n\\n  for (const el of sorted) {\\n    if (!copy.includes(el)) {\\n      continue;\\n    }\\n\\n    const index = copy.indexOf(el * 2);\\n\\n    if (~index) {\\n      copy.splice(index, 1);\\n      copy.splice(0, 1);\\n      continue;\\n    }\\n\\n    return false;\\n  }\\n\\n  return true;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3135199,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        auto cmp = [](int a, int b) {\\n            return a < 0 && b < 0 ? a > b : a < b;\\n        };\\n        map<int, int, decltype(cmp)> values(cmp);\\n        for(auto num: arr)\\n            ++values[num];\\n        \\n        for(auto& [value, count]: values) {\\n            if(count == 0)\\n                continue;\\n            \\n            if(count > values[2 * value])\\n                return false;\\n            \\n            values[2 * value] -= count;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        auto cmp = [](int a, int b) {\\n            return a < 0 && b < 0 ? a > b : a < b;\\n        };\\n        map<int, int, decltype(cmp)> values(cmp);\\n        for(auto num: arr)\\n            ++values[num];\\n        \\n        for(auto& [value, count]: values) {\\n            if(count == 0)\\n                continue;\\n            \\n            if(count > values[2 * value])\\n                return false;\\n            \\n            values[2 * value] -= count;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132482,
                "title": "c-using-map-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution{\\npublic:\\n    bool canReorderDoubled(vector<int>& arr){\\n        // arr[1]=2*arr[0]\\n\\n        // arr[3]=2*arr[2]\\n\\n        // arr[5]=2*arr[4]\\n\\n        int n=arr.size();\\n        map<int,int> m;\\n        for(int i=0;i<n;i++) m[arr[i]]++;\\n        for(auto i:m){\\n            while(m[i.first]>0){\\n                if(m[2*i.first]>0){\\n                    m[i.first]--;\\n                    m[2*i.first]--;\\n                }\\n                else break;\\n            }\\n        }\\n        for(auto i:m){\\n            if(i.second>0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    bool canReorderDoubled(vector<int>& arr){\\n        // arr[1]=2*arr[0]\\n\\n        // arr[3]=2*arr[2]\\n\\n        // arr[5]=2*arr[4]\\n\\n        int n=arr.size();\\n        map<int,int> m;\\n        for(int i=0;i<n;i++) m[arr[i]]++;\\n        for(auto i:m){\\n            while(m[i.first]>0){\\n                if(m[2*i.first]>0){\\n                    m[i.first]--;\\n                    m[2*i.first]--;\\n                }\\n                else break;\\n            }\\n        }\\n        for(auto i:m){\\n            if(i.second>0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132301,
                "title": "python-short-solution-using-counter-beats-98-o-nlogn",
                "content": "# Approach\\nThis problem is just asking whether or not we can make pairs using every element in the array, so that pair[0] * 2 == pair[1]. We use a counter to get the elements in the array by count, and then sort them by the smallest absolute values (note that if we simply sort in increasing order, we will place -4 before -2, which will mess us up!). Now that we have it sorted, we go through and make sure that for each key, key*2 is in the counter, and that we have enough copies of that to satisfy our key. If both of those are true, we simply subtract counter[key] from counter[key*2], since we only have that many copies of it left to use. Since we are going in increasing order by absolute value, we are guaranteed to reach key before key*2, and if we have any copies of key left, we can only pair them with key*2 (since we are guaranteed to have already used up all copies of key/2). \\n\\n# Complexity\\n- Time complexity: O(NlogN), where N = number of unique elements in the list (sorting the counter takes NlogN time, the for loop takes only O(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) (only space is the counter)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        counter = Counter(arr)\\n        for key in sorted(counter.keys(), key=lambda x: abs(x)): # sort the list based on absolute value\\n            if counter[key] == 0: continue # this can happen if we\\'ve already removed the key bc we encountered half of it\\n            if key*2 not in counter or counter[key] > counter[key*2]: return False # If double the key isn\\'t in the list, or if there aren\\'t enough of that key, then return false\\n            counter[key*2] -= counter[key] # we\\'ve made this many groups of [key,key*2]\\n        return True # If we make it through we must be done\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canReorderDoubled(self, arr: List[int]) -> bool:\\n        counter = Counter(arr)\\n        for key in sorted(counter.keys(), key=lambda x: abs(x)): # sort the list based on absolute value\\n            if counter[key] == 0: continue # this can happen if we\\'ve already removed the key bc we encountered half of it\\n            if key*2 not in counter or counter[key] > counter[key*2]: return False # If double the key isn\\'t in the list, or if there aren\\'t enough of that key, then return false\\n            counter[key*2] -= counter[key] # we\\'ve made this many groups of [key,key*2]\\n        return True # If we make it through we must be done\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131849,
                "title": "c-easy-solution-with-explanation",
                "content": "# Intuition\\nReplace i by i/2 in the formula arr[2*i+1]==2*arr[2*i] and also in 0<=i<len(arr)/2 so it will transform to arr[i+1]==2*arr[i] for all i in 0<=i<=len(arr). Hence now we need to find if we can make an array such that each element is double of its previous element.\\n\\n# Approach\\nSort array and store every element in the map along with it\\'s frequency and now check for every element if it is in map and its double (2*arr[i]) is also in map. If yes then reduce both element\\'s frequency by 1. If frequency becomes 0 then erase elements. At the end if the size of map is 0 then we can form such an array because we used all elements that satisfied the condition.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        map<int,int> m;\\n        for(auto i:arr)\\n        {\\n            m[i]++;\\n        }\\n        sort(arr.begin(),arr.end());\\n        for(auto &i:arr)\\n        {\\n            int a1 = 2*i;\\n            if(m.find(i)!=m.end() && m.find(a1)!=m.end())\\n            {\\n                m[i]--;\\n                m[a1]--;\\n                if(m[i]==0)\\n                m.erase(i);\\n                if(m[a1]==0)\\n                m.erase(a1);\\n            }\\n        }\\n        \\n        if(m.size()==0)\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        map<int,int> m;\\n        for(auto i:arr)\\n        {\\n            m[i]++;\\n        }\\n        sort(arr.begin(),arr.end());\\n        for(auto &i:arr)\\n        {\\n            int a1 = 2*i;\\n            if(m.find(i)!=m.end() && m.find(a1)!=m.end())\\n            {\\n                m[i]--;\\n                m[a1]--;\\n                if(m[i]==0)\\n                m.erase(i);\\n                if(m[a1]==0)\\n                m.erase(a1);\\n            }\\n        }\\n        \\n        if(m.size()==0)\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131699,
                "title": "c-simple-o-n-log-n-greedy-solution",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Greedy\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        map<int,int> mp;\\n        for(auto e:arr) mp[e]++;\\n        for(auto e:arr){\\n            if(!mp[e]) continue;\\n            if (e<0 && e%2!=0) return false;\\n            int y=e>0?e*2:e/2;\\n            if (!mp[y]) return false;\\n            mp[e]--;\\n            mp[y]--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        map<int,int> mp;\\n        for(auto e:arr) mp[e]++;\\n        for(auto e:arr){\\n            if(!mp[e]) continue;\\n            if (e<0 && e%2!=0) return false;\\n            int y=e>0?e*2:e/2;\\n            if (!mp[y]) return false;\\n            mp[e]--;\\n            mp[y]--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131056,
                "title": "easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        map<int,int>m;\\n        for(auto a:arr)\\n        {\\n            m[a]++;\\n        }\\n        for(auto [k,v]:m)\\n        {\\n            if(v!=0)\\n            {\\n                if(m.find(2*k)!=m.end() && m[2*k]>0)\\n                {\\n                    int a=min(v,m[2*k]);\\n                    m[k]-=a;\\n                    m[2*k]-=a;\\n                }\\n            }\\n        }\\n        for(auto a:m)\\n        {\\n            if(a.second>0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        map<int,int>m;\\n        for(auto a:arr)\\n        {\\n            m[a]++;\\n        }\\n        for(auto [k,v]:m)\\n        {\\n            if(v!=0)\\n            {\\n                if(m.find(2*k)!=m.end() && m[2*k]>0)\\n                {\\n                    int a=min(v,m[2*k]);\\n                    m[k]-=a;\\n                    m[2*k]-=a;\\n                }\\n            }\\n        }\\n        for(auto a:m)\\n        {\\n            if(a.second>0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129960,
                "title": "area-of-doubled-pairs",
                "content": "Idea:\\n\\nWe keep a frequency map.\\nSort the array. Soon I\\'ll explain why it\\'s needed.\\nFor each number, if we can find it and it\\'s double in the map, we decrement their frequencies.\\nIf the map is empty, we return true.\\nWhy does it work?\\nWe need to reorder the array so that we have n/2 pairs of (x, x * 2).\\nSo all we need to do is keep track which numbers we used already for a different pair.\\nWhy do we have to sort?\\nFor example, if we have in the array [2, 4, 8, 1].\\nWe will get to the 2, find it\\'s double - 4, and then the 1 and 8 will stay without a pair!\\nIf we sort, then we go in an ascending order, so it won\\'t happen.\\n\\n# Complexity\\n- Time complexity:\\n0(n*n)\\n\\n- Space complexity:\\n0(n*n)\\n\\n# Code\\n```\\n\\n    class Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& c) {\\n         unordered_map<int,int>mp;\\n        for(auto i:c) {\\n            mp[i]++;\\n        }\\n        sort(c.begin(),c.end());\\n        for(auto i:c) {\\n            if(mp[i]) {\\n                if(mp[2*i])\\n                 {\\n                mp[2*i]--;\\n                 mp[i]--;}\\n                else if(i%2==0 && mp[i/2])\\n                    {\\n                mp[(i/2)]--;\\n                 mp[i]--;}\\n                else \\n                    return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n    class Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& c) {\\n         unordered_map<int,int>mp;\\n        for(auto i:c) {\\n            mp[i]++;\\n        }\\n        sort(c.begin(),c.end());\\n        for(auto i:c) {\\n            if(mp[i]) {\\n                if(mp[2*i])\\n                 {\\n                mp[2*i]--;\\n                 mp[i]--;}\\n                else if(i%2==0 && mp[i/2])\\n                    {\\n                mp[(i/2)]--;\\n                 mp[i]--;}\\n                else \\n                    return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129497,
                "title": "simple-c-solution-using-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        map<int,int>m;\\n        map<int,int,greater<int>>mp;\\n        int count=0;\\n        for(auto i:arr){\\n            if(i==0)\\n               count++;\\n            else if(i<0)\\n               mp[i]++;\\n            else\\n                m[i]++;\\n        }   \\n        if(count%2!=0) return false;\\n\\n        cout<<\"size : \"<<m.size()<<\" \"<<mp.size()<<endl;\\n\\n        for(auto i:m){\\n            if(i.second==0) continue;\\n            int x=i.first*2;\\n            if(m[x]>=i.second){\\n                m[x]-=i.second;\\n            }\\n            else\\n                return false;\\n        }\\n\\n        for(auto i:mp){\\n            if(i.second==0) continue;\\n            if(mp[i.first*2]>=i.second){\\n                mp[i.first*2]-=i.second;\\n            }\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        map<int,int>m;\\n        map<int,int,greater<int>>mp;\\n        int count=0;\\n        for(auto i:arr){\\n            if(i==0)\\n               count++;\\n            else if(i<0)\\n               mp[i]++;\\n            else\\n                m[i]++;\\n        }   \\n        if(count%2!=0) return false;\\n\\n        cout<<\"size : \"<<m.size()<<\" \"<<mp.size()<<endl;\\n\\n        for(auto i:m){\\n            if(i.second==0) continue;\\n            int x=i.first*2;\\n            if(m[x]>=i.second){\\n                m[x]-=i.second;\\n            }\\n            else\\n                return false;\\n        }\\n\\n        for(auto i:mp){\\n            if(i.second==0) continue;\\n            if(mp[i.first*2]>=i.second){\\n                mp[i.first*2]-=i.second;\\n            }\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3119983,
                "title": "c-code-using-map-and-sorting",
                "content": "**Please Upvote If helpful\\nComment down your doubts for instant answer** \\n```cpp\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        map<int,int> mpp;\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<arr.size();i++) mpp[arr[i]]++;\\n\\n        for(int i=0;i<arr.size();i++){\\n            if(mpp[arr[i]]>0){\\n                cout<<arr[i]<<endl;\\n                if(mpp.find(arr[i]*2)!=mpp.end() && mpp[arr[i]*2]>0){\\n                    mpp[arr[i]]--;\\n                    mpp[arr[i]*2]--;\\n                }else if(arr[i]%2==0 && mpp.find(arr[i]/2)!=mpp.end() && mpp[arr[i]/2]>0){\\n                    mpp[arr[i]]--;\\n                    mpp[arr[i]/2]--;\\n                }\\n                else return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n        map<int,int> mpp;\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<arr.size();i++) mpp[arr[i]]++;\\n\\n        for(int i=0;i<arr.size();i++){\\n            if(mpp[arr[i]]>0){\\n                cout<<arr[i]<<endl;\\n                if(mpp.find(arr[i]*2)!=mpp.end() && mpp[arr[i]*2]>0){\\n                    mpp[arr[i]]--;\\n                    mpp[arr[i]*2]--;\\n                }else if(arr[i]%2==0 && mpp.find(arr[i]/2)!=mpp.end() && mpp[arr[i]/2]>0){\\n                    mpp[arr[i]]--;\\n                    mpp[arr[i]/2]--;\\n                }\\n                else return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3012395,
                "title": "c-clean-concise",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n       map<int,int> p;\\n        int c=0;\\n        for(auto i :arr)\\n            p[i]++;\\n        vector<int> a,y;\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<n;i++)\\n        {\\n          if(p[arr[i]]>0)\\n            {\\n                  p[arr[i]]--;\\n                if(p[2*arr[i]]>0)\\n                { c++;\\n                  p[arr[i]*2]--;\\n                }\\n                else\\n                  p[arr[i]]++;        \\n            }\\n        }\\n        if(c==n/2)\\n        return 1;\\n        else\\n        return 0; \\n    }\\n};\\n//Please Upvote if u like it\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReorderDoubled(vector<int>& arr) {\\n       map<int,int> p;\\n        int c=0;\\n        for(auto i :arr)\\n            p[i]++;\\n        vector<int> a,y;\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<n;i++)\\n        {\\n          if(p[arr[i]]>0)\\n            {\\n                  p[arr[i]]--;\\n                if(p[2*arr[i]]>0)\\n                { c++;\\n                  p[arr[i]*2]--;\\n                }\\n                else\\n                  p[arr[i]]++;        \\n            }\\n        }\\n        if(c==n/2)\\n        return 1;\\n        else\\n        return 0; \\n    }\\n};\\n//Please Upvote if u like it\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575636,
                "content": [
                    {
                        "username": "tanuja739",
                        "content": "![image](https://assets.leetcode.com/users/images/43a85bce-3b80-4f74-aede-5cb890257643_1628669580.2757003.png)\\n"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "you are not supposed to post solutions here"
                    }
                ]
            }
        ]
    }
]