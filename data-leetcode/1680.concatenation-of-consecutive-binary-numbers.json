[
    {
        "title": "Concatenation of Consecutive Binary Numbers",
        "question_content": "Given an integer n, return the decimal value of the binary string formed by concatenating the binary representations of 1 to n in order, modulo 109 + 7.\n&nbsp;\nExample 1:\n\nInput: n = 1\nOutput: 1\nExplanation: \"1\" in binary corresponds to the decimal value 1. \n\nExample 2:\n\nInput: n = 3\nOutput: 27\nExplanation: In binary, 1, 2, and 3 corresponds to \"1\", \"10\", and \"11\".\nAfter concatenating them, we have \"11011\", which corresponds to the decimal value 27.\n\nExample 3:\n\nInput: n = 12\nOutput: 505379714\nExplanation: The concatenation results in \"1101110010111011110001001101010111100\".\nThe decimal value of that is 118505380540.\nAfter modulo 109 + 7, the result is 505379714.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 105",
        "solutions": [
            {
                "id": 2612407,
                "title": "c-diagram-related-problems",
                "content": "![image](https://assets.leetcode.com/users/images/6822f124-b599-40a1-96d6-5e6111ee2ca9_1663902113.3584025.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3eecab6-bc21-49e9-b535-fc455f96fe8e_1663903076.2444859.png)\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    \\n    int numberOfBits(int n) {\\n\\t\\t  return log2(n) + 1;\\n    }\\n    \\n    int concatenatedBinary(int n) {\\n        long ans = 0, MOD = 1e9 + 7;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            int len = numberOfBits(i);\\n            ans = ((ans << len) % MOD + i) % MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**EDIT 1**\\n**Optimization** in `numberOfBits` function\\n```cpp\\nint numberOfBits(int n) {\\n   int leadingZeros = __builtin_clz(n);\\n   return 32 - leadingZeros;\\n}\\n```\\n\\n**EDIT 2**\\nAnother way of **calculating length of binary number** suggested by @CoolBud\\n```cpp\\nint numberOfBits(int n) {\\n    return log2(n) + 1;\\n}\\n```\\n\\n**EDIT 3**\\nAnother way of **calculating length of binary number** suggested by @Sopindm\\n```cpp\\nint concatenatedBinary(int n) {\\n        long ans = 0, MOD = 1e9 + 7, len = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if(__builtin_popcount(i) == 1) ++len;\\n            ans = ((ans << len) % MOD + i) % MOD;\\n        }\\n        return ans;\\n}\\n```\\n\\n**Binary Representation Related Problems**\\n[1. Add Binary ](https://leetcode.com/problems/add-binary/)\\n[2. Add Two Numbers ](https://leetcode.com/problems/add-two-numbers/)\\n[3. Counting Bits ](https://leetcode.com/problems/counting-bits/)\\n[4. Binary Watch ](https://leetcode.com/problems/binary-watch/)\\n[5. Reverse Bits ](https://leetcode.com/problems/reverse-bits/)\\n[6. Binary Number with Alternating Bits ](https://leetcode.com/problems/binary-number-with-alternating-bits/)\\n[7. Hamming Distance ](https://leetcode.com/problems/hamming-distance/)\\n[8. Prime Number of Set Bits in Binary Representation ](https://leetcode.com/problems/prime-number-of-set-bits-in-binary-representation/)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    \\n    int numberOfBits(int n) {\\n\\t\\t  return log2(n) + 1;\\n    }\\n    \\n    int concatenatedBinary(int n) {\\n        long ans = 0, MOD = 1e9 + 7;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            int len = numberOfBits(i);\\n            ans = ((ans << len) % MOD + i) % MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nint numberOfBits(int n) {\\n   int leadingZeros = __builtin_clz(n);\\n   return 32 - leadingZeros;\\n}\\n```\n```cpp\\nint numberOfBits(int n) {\\n    return log2(n) + 1;\\n}\\n```\n```cpp\\nint concatenatedBinary(int n) {\\n        long ans = 0, MOD = 1e9 + 7, len = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if(__builtin_popcount(i) == 1) ++len;\\n            ans = ((ans << len) % MOD + i) % MOD;\\n        }\\n        return ans;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612207,
                "title": "java-explained-in-detail-fast-o-n-solution-bit-manipulation-math",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n\\n**Java (Bit Manipulation) - Clean Code**\\n\\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        final long modulo = (long) (1e9 + 7);\\n        long result = 0;\\n        int binaryDigits = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if ((i & (i - 1)) == 0) binaryDigits++;\\n            result = ((result << binaryDigits) + i) % modulo;\\n        }\\n        return (int) result;\\n    }\\n}\\n```\\n\\n**Java (Bit Manipulation) - With Explanation**\\n\\n```\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\n// where N is n.\\nclass Solution {\\n\\n    // Approach:\\n    // Using bit manipulation as described below.\\n    // A bit of description for the bitwise operations used, if you are not familiar.\\n    // 1. & - Bitwise AND operation:\\n    //    0 & 0 = 0,\\n    //    1 & 0 = 0,\\n    //    1 & 1 = 1.\\n    //    Example : 1101 & 1010 = 1000\\n    //\\n    // 2. << - Shift Left operation, by n position:\\n    //    Example:\\n    //    11 (3) << 2 (n position) = 1100 (14)\\n    //\\n\\n    public int concatenatedBinary(int n) {\\n\\n        final long modulo = (long) (1e9 + 7);\\n        long result = 0;\\n\\n        // This records the number of binaryDigits we need to shift left.\\n        int binaryDigits = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n\\n            // If i is a power of 2, we add one additional binaryDigits to shift.\\n            // Example:\\n            // i = 8 (1000), i-1 = 7 (111)\\n            // i & (i-1) = 1000 & 111 = 0\\n            // So we know we have increased the binaryDigits from 3 (in 111) to 4 (in 1000).\\n            if ((i & (i - 1)) == 0) {\\n                binaryDigits++;\\n            }\\n\\n            // With the updated binaryDigits, we now can concatenate i to the result.\\n            // Each time get the remainder of the result % modulo.\\n            // Example:\\n            // i = 2\\n            // result = 1 (1) << 2 (n position) + 10 (2) = 100 (4) + 10 (2) = 110 (6).\\n            // i = 3\\n            // result = 110 (6) << 2 (n position) + 11 (3) = 11000 (24) + 11 (3) = 11011 (27).\\n            //\\n            result = ((result << binaryDigits) + i) % modulo;\\n        }\\n        return (int) result;\\n    }\\n}\\n```\\n\\n**Java (Math) - With Explanation**\\n```\\nclass Solution {\\n    \\n    // Approach:\\n    // We concatenate by shifting position of result with division and multiplication, then add the number.\\n    // As there are a lot of repetitions in shifting of positions, it is much less efficient than using bit manipulation.\\n    \\n    public int concatenatedBinary(int n) {\\n        final long modulo = (long) (1e9 + 7);\\n        long result = 0;\\n        for (int i = 1; i <= n; i++) {\\n            // For each i, we shift left the position of result with * 2,\\n            // while shifting right the position of i with / 2.\\n            int temp = i;\\n            while (temp > 0) {\\n                temp /= 2;\\n                result *= 2;\\n            }\\n            // Add the i to the result and get the remainder of modulo.\\n            result = (result + i) % modulo;\\n        }\\n        return (int) result;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        final long modulo = (long) (1e9 + 7);\\n        long result = 0;\\n        int binaryDigits = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if ((i & (i - 1)) == 0) binaryDigits++;\\n            result = ((result << binaryDigits) + i) % modulo;\\n        }\\n        return (int) result;\\n    }\\n}\\n```\n```\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\n// where N is n.\\nclass Solution {\\n\\n    // Approach:\\n    // Using bit manipulation as described below.\\n    // A bit of description for the bitwise operations used, if you are not familiar.\\n    // 1. & - Bitwise AND operation:\\n    //    0 & 0 = 0,\\n    //    1 & 0 = 0,\\n    //    1 & 1 = 1.\\n    //    Example : 1101 & 1010 = 1000\\n    //\\n    // 2. << - Shift Left operation, by n position:\\n    //    Example:\\n    //    11 (3) << 2 (n position) = 1100 (14)\\n    //\\n\\n    public int concatenatedBinary(int n) {\\n\\n        final long modulo = (long) (1e9 + 7);\\n        long result = 0;\\n\\n        // This records the number of binaryDigits we need to shift left.\\n        int binaryDigits = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n\\n            // If i is a power of 2, we add one additional binaryDigits to shift.\\n            // Example:\\n            // i = 8 (1000), i-1 = 7 (111)\\n            // i & (i-1) = 1000 & 111 = 0\\n            // So we know we have increased the binaryDigits from 3 (in 111) to 4 (in 1000).\\n            if ((i & (i - 1)) == 0) {\\n                binaryDigits++;\\n            }\\n\\n            // With the updated binaryDigits, we now can concatenate i to the result.\\n            // Each time get the remainder of the result % modulo.\\n            // Example:\\n            // i = 2\\n            // result = 1 (1) << 2 (n position) + 10 (2) = 100 (4) + 10 (2) = 110 (6).\\n            // i = 3\\n            // result = 110 (6) << 2 (n position) + 11 (3) = 11000 (24) + 11 (3) = 11011 (27).\\n            //\\n            result = ((result << binaryDigits) + i) % modulo;\\n        }\\n        return (int) result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    // Approach:\\n    // We concatenate by shifting position of result with division and multiplication, then add the number.\\n    // As there are a lot of repetitions in shifting of positions, it is much less efficient than using bit manipulation.\\n    \\n    public int concatenatedBinary(int n) {\\n        final long modulo = (long) (1e9 + 7);\\n        long result = 0;\\n        for (int i = 1; i <= n; i++) {\\n            // For each i, we shift left the position of result with * 2,\\n            // while shifting right the position of i with / 2.\\n            int temp = i;\\n            while (temp > 0) {\\n                temp /= 2;\\n                result *= 2;\\n            }\\n            // Add the i to the result and get the remainder of modulo.\\n            result = (result + i) % modulo;\\n        }\\n        return (int) result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961446,
                "title": "detailed-thought-process-with-steps-example-o-n-time-java-8-1-liner",
                "content": "```\\nn = 3\\n1 - 1\\n2 - 10\\n3 - 11\\n\\n123 -> 11011 --> \\n\\n(1 * 2^4) + (1 * 2 ^3 + 0 * 2 ^ 2) + (1 * 2^1 + 1 * 2^0)\\n\\n(1 * 2^4) + (2 * 2 ^2 + 0 * 2 ^ 2) + (2 * 2^0 + 1 * 2^0)\\n\\n(1 * 2^4) + (2 + 0) * 2 ^2  + (2 + 1)* 2^0\\n\\n(1)* 2^4 + (2) * 2 ^2  + (3)* 2^0\\n\\n((1)* 2^4 + (2) * 2 ^2)  + (3)* 2^0\\n\\n((1)* 2^2 + (2)) * 2 ^2)  + (3)* 2^0\\n\\n(4 + 2) * 2^2 + 3\\n\\n24 + 3 \\n\\n27\\n\\n```\\n\\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int MOD = 1_000_000_007;\\n        long sum = 0;\\n        for (int i = 1; i <= n; i++)\\n            sum = (sum * (int)Math.pow(2, Integer.toBinaryString(i).length()) + i) % MOD; // sum = ((sum << Integer.toBinaryString(i).length()) + i) % MOD;\\n\\n        return (int)sum;\\n    }\\n}\\n```\\n\\n****************\\n\\n**Bitwise O(n) Time**\\n\\n```\\nclass Solution {\\n    // TC - O(n)\\n    public int concatenatedBinary(int n) {\\n        int MOD = 1_000_000_007;\\n        long sum = 0;\\n        int length = 0;\\n        \\n        for(int i = 1; i <= n; i++) {\\n            if((i & (i - 1)) == 0)\\n                length++;\\n            sum = ((sum << length) | i) % MOD;\\n        }\\n        \\n        return (int) sum;\\n    }\\n}\\n```\\n\\n****************\\n\\nJava-8: 1 Liner using Long.range and reduce\\n\\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n\\t\\treturn (int) LongStream.range(1, n + 1).reduce(0, (sum, i) -> (sum * (int) Math.pow(2, Long.toBinaryString(i).length()) + i) % 1_000_000_007);\\n    }\\n}\\n```\\n\\n\\nIf you like solution - **upvote**.",
                "solutionTags": [],
                "code": "```\\nn = 3\\n1 - 1\\n2 - 10\\n3 - 11\\n\\n123 -> 11011 --> \\n\\n(1 * 2^4) + (1 * 2 ^3 + 0 * 2 ^ 2) + (1 * 2^1 + 1 * 2^0)\\n\\n(1 * 2^4) + (2 * 2 ^2 + 0 * 2 ^ 2) + (2 * 2^0 + 1 * 2^0)\\n\\n(1 * 2^4) + (2 + 0) * 2 ^2  + (2 + 1)* 2^0\\n\\n(1)* 2^4 + (2) * 2 ^2  + (3)* 2^0\\n\\n((1)* 2^4 + (2) * 2 ^2)  + (3)* 2^0\\n\\n((1)* 2^2 + (2)) * 2 ^2)  + (3)* 2^0\\n\\n(4 + 2) * 2^2 + 3\\n\\n24 + 3 \\n\\n27\\n\\n```\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int MOD = 1_000_000_007;\\n        long sum = 0;\\n        for (int i = 1; i <= n; i++)\\n            sum = (sum * (int)Math.pow(2, Integer.toBinaryString(i).length()) + i) % MOD; // sum = ((sum << Integer.toBinaryString(i).length()) + i) % MOD;\\n\\n        return (int)sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    // TC - O(n)\\n    public int concatenatedBinary(int n) {\\n        int MOD = 1_000_000_007;\\n        long sum = 0;\\n        int length = 0;\\n        \\n        for(int i = 1; i <= n; i++) {\\n            if((i & (i - 1)) == 0)\\n                length++;\\n            sum = ((sum << length) | i) % MOD;\\n        }\\n        \\n        return (int) sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n\\t\\treturn (int) LongStream.range(1, n + 1).reduce(0, (sum, i) -> (sum * (int) Math.pow(2, Long.toBinaryString(i).length()) + i) % 1_000_000_007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037323,
                "title": "python-o-n-and-o-log-2-n-fast-and-short-explained",
                "content": "One way to solve this problem in competition is just create very long binary string and then find result of division by `10**9 + 7` and it will work fine. However in interview setup it is not the best idea and I prefer more honest way. Let us look at first several `n` to see how it works:\\n`1`\\n`110`\\n`11011`\\n`11011100`\\n\\nLet us try to find answer to `n`, using information about `n-1`. `110` = `1 * 100 + 10` (all in binary representation), `11011 = 110 * 100 + 11`, `11011100 = 11011 * 1000 + 100` and so on. We can see that on each step we need to multiply number by **lenght** of new number and add new number (and use `%M`) and that is all!\\n\\n**Complexity**: time complexity is `O(n)`, space is `O(1)`.\\n\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n):\\n        ans, M = 0, 10**9 + 7\\n        for x in range(n):\\n            ans = (ans * (1 << (len(bin(x+1)) - 2)) + x+1) % M\\n        return ans \\n```\\n\\n**Further thoughts** When you found `O(n)` solution, you should ask a question, can you do better? Here I had very strong intuition that you can do it faster and I came up with `O(log^2 n)` solution. Then I checked discussions and there is in fact at least two solutions with this complexity: one uses idea of geometrical progressions: idea behind is the following: we can see that in binary representation of desired number there will be `O(log n)` sequences of ones with equal gaps for each of `O(log n)` lengths of numbers. You can find this solution in discussion, I will code my own version if I have time. Another solution using matrix multiplications and I was very impressed to see it.\\n\\n### Faster solution with O(log^2 n) complexity\\n\\nIt is easier to chose some `n` and go into details about this `n`. Let us choose `n = 54` and discuss how my algorithm works:\\n\\nFunction `bin_pow` will return powers of `2`, which sum to given number, for example `bin_pow(37) = [1, 4, 32]`, because `1 + 4 + 32 = 37`.\\n\\nNow, we have `n = 54`, and we have:\\n1. `1` number with length `1`: just `1`\\n2. `2` numbers with length `2`: `10, 11`\\n3. `4` numbers with length `3`: `100, 101, 110, 111`.\\n4. `8` numbers with length `4`: `1000, ..., 1111`\\n5. `16` numbers with length `5`: `10000, ..., 11111`.\\nNow, we have 23 more numbers and we keep to split them into groups:\\n6. `16` numbers with lenght `6`, which **start with** `10....`, that is `100000, 100001, ... 101111`. Why we choose `16` of them? Because it is the biggest group we can take such that this group is full: given start we have all possible endings.\\n7. `4` numbers with length `6`, which **start with** `1100`, that is `110000, 110001, 110010, 110011`\\n8. `2` numbers with length `6`, which **start with** `11010`, that is `110100` and `110101`.\\n9. `1` number with length `6`: `110110`, which is equal to `54`, our last number.\\n\\nWe will keep lenghts of our groups in list `B`, so we have:\\n`B = [1, 2, 4, 8, 16, 16, 4, 2, 1`]\\n\\nWe will keep length of numbers in each group in list `C`, so we have:\\n`C = [1, 2, 3, 4, 5, 6, 6, 6, 6]`\\n\\nSo far we have the following picture:\\n\\n`[1][10 11][100 101 110 111] ...   [110000, 110001, 110010, 110011], [110100, 110101], [110110]`\\n\\nWe will keep starting places of each group in list `D`, in our case we have:\\n`D = [266, 262, 250, 218, 138, 42, 18, 6, 0]`.\\nLet us look from the end: last group we do not need to multiply by anything, previous group has `1` number with length `6`, so we need to multiply it by `2^6`. Next we have `2*6 + 1*6` shift, `4*6 + 2*6 + 1*6`, `16*6 + 4*6 + 2*6 + 1*6`, `16*5 + 16*6 + 4*6 + 2*6 + 1*6` and so on: it can be done efficiently, using `accumulate` function in python.\\n\\nFinal step is to iterate over our groups and evaluate number modulo `10**9 + 7` in each group:\\n\\nLet us look at group `[110000, 110001, 110010, 110011]` for better underastnding. This group will be somewhere in the middle of number, like `...[110000, 110001, 110010, 110011]...` and we need to understand what impact it has on our number, we need several values:\\n1. Place, where this group is located, for this we use `D` list, `d` for given group.\\n2. Lenth of elements in each group, for this we use `C` list, `c` for given group.\\n3. Number of elements in our group, for this we use `B` list, `b` for given group.\\n4. Also we need to now, from which element we start, in our case it is `110000`, we can evaluate it as `a - b + 1`, where `a` is corresponding element in `accumulate(B)`: here we have `accumulate(B) = [1, 3, 7, 15, 31, 47, 51, 53, 54]` and `51-4 + 1 = 48` is current number we start with, `a` for given group\\n\\nFinally, we need to do some mathematics: we need to evaluate sum:\\n`[(a-b+1) * 2^(b*c) + (a-b+2)*2^(b*(c-1)) + ... +  (a-b + c-1) * 2^(b*1) + (a-b + c) * 2^(b*0)]*2^d`.\\n\\nThis formula can be written in closed form! It is almost like sum of geometrical progression, but in fact, sum of several of them which lead us to closed form solution. We also need to work using modular arithmetic, so we use powerful `pow` python function. In my notation `t1 = [2^(bc) - 1] % MOD` and `t2 = [1/(2^c - 1)] % MOD`. Here we use Fermat\\'s little theorem to evaluate inverse number in modular arithmetic. \\n\\n**Complexity**: time complexity of evaluating `B, C, D` lists is just `O(log n)`. However when we work with `pow` function, complexity to evaluate sum in each group will be also `O(log n)`, which leasd to `O(log^2 n)` time complexity. Space complexity is `O(log n)`.\\n\\n\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n):\\n        def bin_pow(num): return [1<<i for i, b in enumerate(bin(num)[:1:-1]) if b == \"1\"]\\n        ans, MOD, q = 0, 10**9 + 7, len(bin(n)) - 3\\n\\n        B = bin_pow((1<<q) - 1) + bin_pow(n - (1<<q) + 1)[::-1]\\n        C = list(range(1, q+1)) + [q+1]*(len(B) - q)\\n        D = list(accumulate(i*j for i,j in zip(B[::-1], C[::-1])))[::-1][1:] + [0]\\n        \\n        for a, b, c, d in zip(accumulate(B), B, C, D):\\n            t1 = pow(2, b*c, MOD) - 1\\n            t2 = pow(pow(2, c, MOD)-1, MOD - 2, MOD)\\n            ans += t2*((a-b+1+t2)*t1-b)*pow(2, d, MOD)\\n\\n        return ans % MOD\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n):\\n        ans, M = 0, 10**9 + 7\\n        for x in range(n):\\n            ans = (ans * (1 << (len(bin(x+1)) - 2)) + x+1) % M\\n        return ans \\n```\n```\\nclass Solution:\\n    def concatenatedBinary(self, n):\\n        def bin_pow(num): return [1<<i for i, b in enumerate(bin(num)[:1:-1]) if b == \"1\"]\\n        ans, MOD, q = 0, 10**9 + 7, len(bin(n)) - 3\\n\\n        B = bin_pow((1<<q) - 1) + bin_pow(n - (1<<q) + 1)[::-1]\\n        C = list(range(1, q+1)) + [q+1]*(len(B) - q)\\n        D = list(accumulate(i*j for i,j in zip(B[::-1], C[::-1])))[::-1][1:] + [0]\\n        \\n        for a, b, c, d in zip(accumulate(B), B, C, D):\\n            t1 = pow(2, b*c, MOD) - 1\\n            t2 = pow(pow(2, c, MOD)-1, MOD - 2, MOD)\\n            ans += t2*((a-b+1+t2)*t1-b)*pow(2, d, MOD)\\n\\n        return ans % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612371,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n**Approach 1: Bit Manipulation**\\n\\n**C++**\\n\\n```cpp\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\nclass Solution {\\npublic:\\n    // the idea is to use bit manipulation to set the current number based on the previous number\\n    // for example, \\n    // n = 1, ans = 0b1\\n    // n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\\n    // i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\\n    // n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \\n    // i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\\n    // n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\\n    // i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\\n    // so now we can see a pattern here\\n    // we need to shift `l` bits of the previous ans to the left and add the current `i` \\n    // how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\\n    int concatenatedBinary(int n) {\\n        // `l` is the bit length to be shifted\\n        int M = 1e9 + 7, l = 0;\\n        // use long here as it potentially could overflow for int\\n        long ans = 0;\\n        for (int i = 1; i <= n; i++) {\\n            // i & (i - 1) means removing the rightmost set bit\\n            // e.g. 100100 -> 100000\\n            //      000001 -> 000000\\n            //      000000 -> 000000\\n            // after removal, if it is 0, then it means it is power of 2\\n            // as all power of 2 only contains 1 set bit\\n            // if it is power of 2, we increase the bit length `l`\\n            if ((i & (i - 1)) == 0) l += 1;\\n            // (ans << l) means shifting the orginal answer `l` bits to th left\\n            // (x | i) means  using OR operation to set the bit\\n            // e.g. 0001 << 3 = 0001000\\n            // e.g. 0001000 | 0001111 = 0001111\\n            ans = ((ans << l) | i) % M;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Java**\\n\\n```java\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\nclass Solution {\\n    // the idea is to use bit manipulation to set the current number based on the previous number\\n    // for example, \\n    // n = 1, ans = 0b1\\n    // n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\\n    // i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\\n    // n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \\n    // i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\\n    // n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\\n    // i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\\n    // so now we can see a pattern here\\n    // we need to shift `l` bits of the previous ans to the left and add the current `i` \\n    // how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\\n    public int concatenatedBinary(int n) {\\n        // `l` is the bit length to be shifted\\n        int M = 1000000007, l = 0;\\n        // use long here as it potentially could overflow for int\\n        long ans = 0;\\n        for (int i = 1; i <= n; i++) {\\n            // i & (i - 1) means removing the rightmost set bit\\n            // e.g. 100100 -> 100000\\n            //      000001 -> 000000\\n            //      000000 -> 000000\\n            // after removal, if it is 0, then it means it is power of 2\\n            // as all power of 2 only contains 1 set bit\\n            // if it is power of 2, we increase the bit length `l`\\n            if ((i & (i - 1)) == 0) l += 1;\\n            // (ans << l) means shifting the orginal answer `l` bits to th left\\n            // (x | i) means  using OR operation to set the bit\\n            // e.g. 0001 << 3 = 0001000\\n            // e.g. 0001000 | 0001111 = 0001111\\n            ans = ((ans << l) | i) % M;\\n        }\\n        return (int) ans;\\n    }\\n}\\n```\\n\\n**Python**\\n\\n```py\\n# Time Complexity: O(N)\\n# Space Complexity: O(1)\\nclass Solution:\\n    # the idea is to use bit manipulation to set the current number based on the previous number\\n    # for example, \\n    # n = 1, ans = 0b1\\n    # n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\\n    # i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\\n    # n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \\n    # i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\\n    # n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\\n    # i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\\n    # so now we can see a pattern here\\n    # we need to shift `l` bits of the previous ans to the left and add the current `i` \\n    # how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\\n    def concatenatedBinary(self, n: int) -> int:\\n        M = 10 ** 9 + 7\\n        # `l` is the bit length to be shifted\\n        l, ans = 0, 0\\n        for i in range(1, n + 1):\\n            # i & (i - 1) means removing the rightmost set bit\\n            # e.g. 100100 -> 100000\\n            #      000001 -> 000000\\n            #      000000 -> 000000\\n            # after removal, if it is 0, then it means it is power of 2\\n            # as all power of 2 only contains 1 set bit\\n            # if it is power of 2, we increase the bit length `l`\\n            if i & (i - 1) == 0:\\n                l += 1\\n            # (ans << l) means shifting the orginal answer `l` bits to th left\\n            # (x | i) means  using OR operation to set the bit\\n            # e.g. 0001 << 3 = 0001000\\n            # e.g. 0001000 | 0001111 = 0001111\\n            ans = ((ans << l) | i) % M\\n        return ans\\n```\\n\\n**Go**\\n\\n```go\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\n\\n// the idea is to use bit manipulation to set the current number based on the previous number\\n// for example, \\n// n = 1, ans = 0b1\\n// n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\\n// i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\\n// n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \\n// i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\\n// n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\\n// i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\\n// so now we can see a pattern here\\n// we need to shift `l` bits of the previous ans to the left and add the current `i` \\n// how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\\nfunc concatenatedBinary(n int) int {\\n    // `l` is the bit length to be shifted\\n    ans, l, M := 0, 0, 1_000_000_007\\n    for i := 1; i <= n; i++ {\\n        // i & (i - 1) means removing the rightmost set bit\\n        // e.g. 100100 -> 100000\\n        //      000001 -> 000000\\n        //      000000 -> 000000\\n        // after removal, if it is 0, then it means it is power of 2\\n        // as all power of 2 only contains 1 set bit\\n        // if it is power of 2, we increase the bit length `l`\\n        if (i & (i - 1) == 0) {\\n            l += 1\\n        }\\n        // (ans << l) means shifting the orginal answer `l` bits to th left\\n        // (x | i) means  using OR operation to set the bit\\n        // e.g. 0001 << 3 = 0001000\\n        // e.g. 0001000 | 0001111 = 0001111\\n        ans = ((ans << l) | i) % M\\n    }   \\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\nclass Solution {\\npublic:\\n    // the idea is to use bit manipulation to set the current number based on the previous number\\n    // for example, \\n    // n = 1, ans = 0b1\\n    // n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\\n    // i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\\n    // n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \\n    // i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\\n    // n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\\n    // i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\\n    // so now we can see a pattern here\\n    // we need to shift `l` bits of the previous ans to the left and add the current `i` \\n    // how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\\n    int concatenatedBinary(int n) {\\n        // `l` is the bit length to be shifted\\n        int M = 1e9 + 7, l = 0;\\n        // use long here as it potentially could overflow for int\\n        long ans = 0;\\n        for (int i = 1; i <= n; i++) {\\n            // i & (i - 1) means removing the rightmost set bit\\n            // e.g. 100100 -> 100000\\n            //      000001 -> 000000\\n            //      000000 -> 000000\\n            // after removal, if it is 0, then it means it is power of 2\\n            // as all power of 2 only contains 1 set bit\\n            // if it is power of 2, we increase the bit length `l`\\n            if ((i & (i - 1)) == 0) l += 1;\\n            // (ans << l) means shifting the orginal answer `l` bits to th left\\n            // (x | i) means  using OR operation to set the bit\\n            // e.g. 0001 << 3 = 0001000\\n            // e.g. 0001000 | 0001111 = 0001111\\n            ans = ((ans << l) | i) % M;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```java\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\nclass Solution {\\n    // the idea is to use bit manipulation to set the current number based on the previous number\\n    // for example, \\n    // n = 1, ans = 0b1\\n    // n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\\n    // i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\\n    // n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \\n    // i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\\n    // n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\\n    // i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\\n    // so now we can see a pattern here\\n    // we need to shift `l` bits of the previous ans to the left and add the current `i` \\n    // how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\\n    public int concatenatedBinary(int n) {\\n        // `l` is the bit length to be shifted\\n        int M = 1000000007, l = 0;\\n        // use long here as it potentially could overflow for int\\n        long ans = 0;\\n        for (int i = 1; i <= n; i++) {\\n            // i & (i - 1) means removing the rightmost set bit\\n            // e.g. 100100 -> 100000\\n            //      000001 -> 000000\\n            //      000000 -> 000000\\n            // after removal, if it is 0, then it means it is power of 2\\n            // as all power of 2 only contains 1 set bit\\n            // if it is power of 2, we increase the bit length `l`\\n            if ((i & (i - 1)) == 0) l += 1;\\n            // (ans << l) means shifting the orginal answer `l` bits to th left\\n            // (x | i) means  using OR operation to set the bit\\n            // e.g. 0001 << 3 = 0001000\\n            // e.g. 0001000 | 0001111 = 0001111\\n            ans = ((ans << l) | i) % M;\\n        }\\n        return (int) ans;\\n    }\\n}\\n```\n```py\\n# Time Complexity: O(N)\\n# Space Complexity: O(1)\\nclass Solution:\\n    # the idea is to use bit manipulation to set the current number based on the previous number\\n    # for example, \\n    # n = 1, ans = 0b1\\n    # n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\\n    # i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\\n    # n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \\n    # i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\\n    # n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\\n    # i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\\n    # so now we can see a pattern here\\n    # we need to shift `l` bits of the previous ans to the left and add the current `i` \\n    # how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\\n    def concatenatedBinary(self, n: int) -> int:\\n        M = 10 ** 9 + 7\\n        # `l` is the bit length to be shifted\\n        l, ans = 0, 0\\n        for i in range(1, n + 1):\\n            # i & (i - 1) means removing the rightmost set bit\\n            # e.g. 100100 -> 100000\\n            #      000001 -> 000000\\n            #      000000 -> 000000\\n            # after removal, if it is 0, then it means it is power of 2\\n            # as all power of 2 only contains 1 set bit\\n            # if it is power of 2, we increase the bit length `l`\\n            if i & (i - 1) == 0:\\n                l += 1\\n            # (ans << l) means shifting the orginal answer `l` bits to th left\\n            # (x | i) means  using OR operation to set the bit\\n            # e.g. 0001 << 3 = 0001000\\n            # e.g. 0001000 | 0001111 = 0001111\\n            ans = ((ans << l) | i) % M\\n        return ans\\n```\n```go\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\n\\n// the idea is to use bit manipulation to set the current number based on the previous number\\n// for example, \\n// n = 1, ans = 0b1\\n// n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\\n// i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\\n// n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \\n// i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\\n// n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\\n// i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\\n// so now we can see a pattern here\\n// we need to shift `l` bits of the previous ans to the left and add the current `i` \\n// how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\\nfunc concatenatedBinary(n int) int {\\n    // `l` is the bit length to be shifted\\n    ans, l, M := 0, 0, 1_000_000_007\\n    for i := 1; i <= n; i++ {\\n        // i & (i - 1) means removing the rightmost set bit\\n        // e.g. 100100 -> 100000\\n        //      000001 -> 000000\\n        //      000000 -> 000000\\n        // after removal, if it is 0, then it means it is power of 2\\n        // as all power of 2 only contains 1 set bit\\n        // if it is power of 2, we increase the bit length `l`\\n        if (i & (i - 1) == 0) {\\n            l += 1\\n        }\\n        // (ans << l) means shifting the orginal answer `l` bits to th left\\n        // (x | i) means  using OR operation to set the bit\\n        // e.g. 0001 << 3 = 0001000\\n        // e.g. 0001000 | 0001111 = 0001111\\n        ans = ((ans << l) | i) % M\\n    }   \\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961350,
                "title": "c-o-n-time-iterative",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. \\n\\nLet `f(n)` be the answer. `sum_len(a, b) = sum( len(i) | a <= i <= b)` and `len(i)` is the number of bits in `i`.\\n\\nFor example: `len(1) = 1`, `len(3) = 2`, `len(6) = 3`. `sum_len(1,4) = len(1) + len(2) + len(3) + len(4) = 1 + 2 + 2 + 3 = 8`.\\n\\nSo we have\\n\\n```plaintext\\nf(n)   = (1 << sum_len(2, n))   + (2 << sum_len(3, n))   + ... + ((n - 1) << sum_len(n, n)) + (n << 0)\\n\\n// Example: f(4) = 11011100 = (1 << (2+2+3)) + (2 << (2+3)) + (3 << 3) + (4 << 0)\\n\\nf(n-1) = (1 << sum_len(2, n-1)) + (2 << sum_len(3, n-1)) + ... + ((n - 1) << 0)\\n\\nf(n) = (f(n-1) << len(n)) + n\\n```\\n\\nSince `f(0) = 0`, we can iteratively build `f(n)`.\\n\\n```plaintext\\nf(0) = 0\\nf(1) = 1     = (f(0) << 1) + 1  // len(1) = 1\\nf(2) = 110   = (f(1) << 2) + 2  // len(2) = 2\\nf(3) = 11011 = (f(2) << 2) + 3  // len(3) = 2\\n...\\n```\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0, mod = 1e9+7;\\n        for (int i = 1; i <= n; ++i) {\\n            int len = 0;\\n            for (int j = i; j; j >>= 1, ++len);\\n            ans = ((ans << len) % mod + i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2.\\n\\nWe spent `O(logN)` time for calculating the `len`. We can reduce it to `O(1)` with the help of `__builtin_clz` which returns the number of leading zeros for a number, so `len = 32 - __builtin_clz(i)`. (Thanks 0xFFFFFFFF)\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0, mod = 1e9+7;\\n        for (int i = 1; i <= n; ++i) ans = ((ans << (32 - __builtin_clz(i))) % mod + i) % mod;\\n        return ans;\\n    }\\n};\\n```\\n\\nOr, with the observation that the `len` only increment when the `i` is a power of `2`, we can increment `len` only when `i` has a single bit `1`. We can check this via `(i & (i - 1)) == 0`. (Thanks @LVL99)\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0, mod = 1e9+7, len = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if ((i & (i - 1)) == 0) ++len;\\n            ans = ((ans << len) % mod + i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```plaintext\\nf(n)   = (1 << sum_len(2, n))   + (2 << sum_len(3, n))   + ... + ((n - 1) << sum_len(n, n)) + (n << 0)\\n\\n// Example: f(4) = 11011100 = (1 << (2+2+3)) + (2 << (2+3)) + (3 << 3) + (4 << 0)\\n\\nf(n-1) = (1 << sum_len(2, n-1)) + (2 << sum_len(3, n-1)) + ... + ((n - 1) << 0)\\n\\nf(n) = (f(n-1) << len(n)) + n\\n```\n```plaintext\\nf(0) = 0\\nf(1) = 1     = (f(0) << 1) + 1  // len(1) = 1\\nf(2) = 110   = (f(1) << 2) + 2  // len(2) = 2\\nf(3) = 11011 = (f(2) << 2) + 3  // len(3) = 2\\n...\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0, mod = 1e9+7;\\n        for (int i = 1; i <= n; ++i) {\\n            int len = 0;\\n            for (int j = i; j; j >>= 1, ++len);\\n            ans = ((ans << len) % mod + i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0, mod = 1e9+7;\\n        for (int i = 1; i <= n; ++i) ans = ((ans << (32 - __builtin_clz(i))) % mod + i) % mod;\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0, mod = 1e9+7, len = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if ((i & (i - 1)) == 0) ++len;\\n            ans = ((ans << len) % mod + i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037355,
                "title": "c-super-simple-short-and-easy-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long res = 0, mod = 1e9+7, len_of_curr = 0;\\n        for (int i = 1; i <= n; i++) {\\n\\t\\t\\n\\t\\t\\t// the len increases every time we reach a number which is a power of two.\\n            if ((i & (i-1)) == 0)\\n                len_of_curr++;\\n\\t\\t\\t\\t\\n            res = (res << len_of_curr) % mod;\\n            res += i % mod;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long res = 0, mod = 1e9+7, len_of_curr = 0;\\n        for (int i = 1; i <= n; i++) {\\n\\t\\t\\n\\t\\t\\t// the len increases every time we reach a number which is a power of two.\\n            if ((i & (i-1)) == 0)\\n                len_of_curr++;\\n\\t\\t\\t\\t\\n            res = (res << len_of_curr) % mod;\\n            res += i % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612211,
                "title": "short-c-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=yMwSJfpSYEo\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0, mod = 1e9+7, length = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            \\n            if ((i & (i - 1)) == 0) length++;\\n            ans = ((ans << length) + i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0, mod = 1e9+7, length = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            \\n            if ((i & (i - 1)) == 0) length++;\\n            ans = ((ans << length) + i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963549,
                "title": "python-log-n-2-approach",
                "content": "![image](https://assets.leetcode.com/users/images/6dba8f5e-8013-4afc-a829-719065047032_1607360527.7108207.png)\\n\\nO(logn) level to iterate \\nin each level calculating result of power for O(logn)\\n\\n```\\nclass Solution(object):\\n    def concatenatedBinary(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        def multiply(X, Y):\\n            return [[sum(a*b for a,b in zip(X_row,Y_col)) % 1000000007 for Y_col in zip(*Y)] for X_row in X]\\n        \\n        ans, acc, level = [[1], [2], [1]], 1, 1\\n        while acc < n:\\n            M = 2 ** (level + 1)\\n\\t\\t\\t\\n\\t\\t\\t# number of matrix production in this level\\n            x = take = min(n, M - 1) - acc\\n            \\n\\t\\t\\tmat = [[M, 1, 0], [0, 1, 1], [0, 0, 1]]\\n\\t\\t\\t\\n\\t\\t\\t# for example\\n\\t\\t\\t# num^13 = num * num^4 * num^8\\n\\t\\t\\t# num^6 = num^2 * num^4\\n            while x > 0:\\n                if x & 1: ans = multiply(mat, ans)\\n                mat, x = multiply(mat, mat), x >> 1\\n            \\n\\t\\t\\tacc, level = acc + take, level + 1\\n        \\n        return ans[0][0]\\n```\\n\\ncredit to @ckclark",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def concatenatedBinary(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        def multiply(X, Y):\\n            return [[sum(a*b for a,b in zip(X_row,Y_col)) % 1000000007 for Y_col in zip(*Y)] for X_row in X]\\n        \\n        ans, acc, level = [[1], [2], [1]], 1, 1\\n        while acc < n:\\n            M = 2 ** (level + 1)\\n\\t\\t\\t\\n\\t\\t\\t# number of matrix production in this level\\n            x = take = min(n, M - 1) - acc\\n            \\n\\t\\t\\tmat = [[M, 1, 0], [0, 1, 1], [0, 0, 1]]\\n\\t\\t\\t\\n\\t\\t\\t# for example\\n\\t\\t\\t# num^13 = num * num^4 * num^8\\n\\t\\t\\t# num^6 = num^2 * num^4\\n            while x > 0:\\n                if x & 1: ans = multiply(mat, ans)\\n                mat, x = multiply(mat, mat), x >> 1\\n            \\n\\t\\t\\tacc, level = acc + take, level + 1\\n        \\n        return ans[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961525,
                "title": "c-beginner-friendly-easy-understanding",
                "content": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    \\n    int concatenatedBinary(int n) {\\n        string s=decimalToBinary(n);\\n        return binaryToDecimal(s);\\n    }\\n\\t\\n\\tstring decimalToBinary(int n) { \\n         string str=\"\";\\n        for(int i=n;i>=1;--i){\\n            int no=i;\\n            while(no){\\n                str+=(no%2)+\\'0\\';\\n                no/=2;\\n            }\\n        }\\n        return str;\\n    } \\n    \\n    int binaryToDecimal(string n){\\n        long long ans=0,powe=1;\\n        for(int j=0;j<n.size();++j){\\n                long long now=(n[j]-\\'0\\')*(powe);\\n                powe*=2;\\n                powe%=mod;\\n                ans+=now;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    \\n    int concatenatedBinary(int n) {\\n        string s=decimalToBinary(n);\\n        return binaryToDecimal(s);\\n    }\\n\\t\\n\\tstring decimalToBinary(int n) { \\n         string str=\"\";\\n        for(int i=n;i>=1;--i){\\n            int no=i;\\n            while(no){\\n                str+=(no%2)+\\'0\\';\\n                no/=2;\\n            }\\n        }\\n        return str;\\n    } \\n    \\n    int binaryToDecimal(string n){\\n        long long ans=0,powe=1;\\n        for(int j=0;j<n.size();++j){\\n                long long now=(n[j]-\\'0\\')*(powe);\\n                powe*=2;\\n                powe%=mod;\\n                ans+=now;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612403,
                "title": "c-bit-manipulation-appraoch",
                "content": "**If you like it, please give a star, to my [Github](https://github.com/champmaniac/LeetCode) Repository and upvote this post.**\\n\\n**Intuition:**\\nThe answer is the **sum** of the binary representations of the numbers from `1 to n`. The binary representation of a number is the sum of the **powers** of `2` that make up the number. The powers of `2` are the same as the **binary** representation of the number.\\n\\n**Approach:**\\n* Iterate through the numbers from `1 to n` and add the `binary` representation of `each` number to the `answer`.\\n* `ans` `= ans<<`(`number of bits in the binary representation of the current number`) + `binary representation of the current number.`\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        int mod = 1e9 + 7;\\n        long long ans = 0;\\n        int len = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if ((i & (i - 1)) == 0) {\\n                len++;\\n            }\\n            ans = ((ans << len) + i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(n)**, where `n`: input number\\n**Space Complexity:** **O(1)**\\n****\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        int mod = 1e9 + 7;\\n        long long ans = 0;\\n        int len = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if ((i & (i - 1)) == 0) {\\n                len++;\\n            }\\n            ans = ((ans << len) + i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037348,
                "title": "python-3-bit-manipulation-4-solutions-1-line-o-n-44ms",
                "content": "# Straightforward solution\\n- Iteratively shift sum to the left by counter bit length and add the counter.\\n- Iteratively get modulo 10\\\\*\\\\*9+7 to avoid slow big int operations.\\n- Time complexity is O(n), space complexity is O(1).\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        s = 0\\n        for i in range(1, n+1):\\n            s = (s << i.bit_length() | i) % 1000000007\\n            \\n        return s\\n```\\n# Functional approach\\nThe same algorithm in 1 line.\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return reduce(lambda s, i: (s << i.bit_length() | i) % 1000000007, range(1, n+1))\\n```\\n# Lazy memoization\\n- Since task for small ```n``` is a subtask for big ```n``` we can cache all ```n``` to avoid duplicated calculations.\\n- Time complexity is O(n), space complexity is O(n).\\n```\\nclass Solution:\\n    mem = [0]\\n        \\n    def concatenatedBinary(self, n: int) -> int:\\n        for i in range(len(Solution.mem), n+1):\\n            Solution.mem.append((Solution.mem[-1] << i.bit_length() | i) % 1000000007)\\n        \\n        return Solution.mem[n]\\n```\\n# Greedy memoization, 44ms\\n- Since we know n <= 10\\\\*\\\\*5 we can precalculate all ```n```.\\n- Time complexity is O(1) and initialization O(n), space complexity is O(n)\\n```\\nclass Solution:\\n    mem = list(accumulate(range(100001), lambda s, i: (s << i.bit_length() | i) % 1000000007))\\n        \\n    def concatenatedBinary(self, n: int) -> int:\\n        return Solution.mem[n]\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        s = 0\\n        for i in range(1, n+1):\\n            s = (s << i.bit_length() | i) % 1000000007\\n            \\n        return s\\n```\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return reduce(lambda s, i: (s << i.bit_length() | i) % 1000000007, range(1, n+1))\\n```\n```n```\n```n```\n```n```\n```\\nclass Solution:\\n    mem = [0]\\n        \\n    def concatenatedBinary(self, n: int) -> int:\\n        for i in range(len(Solution.mem), n+1):\\n            Solution.mem.append((Solution.mem[-1] << i.bit_length() | i) % 1000000007)\\n        \\n        return Solution.mem[n]\\n```\n```n```\n```\\nclass Solution:\\n    mem = list(accumulate(range(100001), lambda s, i: (s << i.bit_length() | i) % 1000000007))\\n        \\n    def concatenatedBinary(self, n: int) -> int:\\n        return Solution.mem[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612781,
                "title": "python-easiest-solution-brute-force-beats-95",
                "content": "Things I learnt which might benefit everyone :\\n* The `bin()` function in python returns the binary value **prefixed with 0b**, for our solution we use the `format()` to get rid of those prefixes.\\n* To convert a binary to an integer equivalent, which can actually be done using `int()` , by passing in 2 as the second parameter\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        string = \"\"\\n        for i in range(1,n+1):\\n            string+=format(i,\"b\")\\n        return int(string,2)%(10**9 + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        string = \"\"\\n        for i in range(1,n+1):\\n            string+=format(i,\"b\")\\n        return int(string,2)%(10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037347,
                "title": "java-bit-manipulation-without-any-library-function-o-n-time-o-1-space",
                "content": "\\n```\\n\\tpublic int concatenatedBinary(int n) {\\n        int digits = 0, MOD = 1000000007;\\n        long result = 0;\\n        for(int i = 1; i <= n; i++){\\n\\t\\t\\t/* if \"i\" is a power of 2, then we have one additional digit in\\n\\t\\t\\t   its the binary equivalent compared to that of i-1 */\\n            if((i & (i - 1)) == 0) digits++; \\n            result = ((result << digits) + i) % MOD;\\n        }\\n        \\n        return (int) result;\\n    }",
                "solutionTags": [],
                "code": "\\n```\\n\\tpublic int concatenatedBinary(int n) {\\n        int digits = 0, MOD = 1000000007;\\n        long result = 0;\\n        for(int i = 1; i <= n; i++){\\n\\t\\t\\t/* if \"i\" is a power of 2, then we have one additional digit in\\n\\t\\t\\t   its the binary equivalent compared to that of i-1 */\\n            if((i & (i - 1)) == 0) digits++; \\n            result = ((result << digits) + i) % MOD;\\n        }\\n        \\n        return (int) result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 961352,
                "title": "python-clean-solution-using-lowbit-o-n-o-1",
                "content": "**Idea**\\n\\nWe simply go through every number from `1` to `n`  and update `ans`. The idea is somewhat similar to rolling hash.\\n\\nIn Python, `bin()` comes in handy. The `bin()` method converts and returns the binary equivalent string of a given integer. For example, `bin(3)` returns `0b11`.\\n\\nIf we are not using `bin()`, we can update the length of the binary representation, `l`, whenever we see `x & -x == x`. The idea of `x & -x` comes from Fenwick Tree, which gives us the low bit of `x`. And this condition checks if `x` is something like `100...0`.\\n\\n</br>\\n\\n**Complexity**\\n\\n- Time complexity: `O(N)`\\n- Space complexity: `O(1)`\\n\\n</br>\\n\\n**Python**\\n\\nusing lowbit (`x & -x`):\\n\\n```Python\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        ans, l, MOD = 0, 0, 10 ** 9 + 7\\n        for x in range(1, n + 1):\\n            if x & (-x) == x: l += 1\\n            ans = (ans * (1 << l) + x) % MOD\\n        return ans \\n```\\n\\nusing `bin()`:\\n\\n\\n```Python\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        ans, MOD = 0, 10 ** 9 + 7\\n        for x in range(1, n + 1):\\n            ans = (ans * (1 << (len(bin(x)) - 2)) + x) % MOD\\n        return ans \\n```\\n",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        ans, l, MOD = 0, 0, 10 ** 9 + 7\\n        for x in range(1, n + 1):\\n            if x & (-x) == x: l += 1\\n            ans = (ans * (1 << l) + x) % MOD\\n        return ans \\n```\n```Python\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        ans, MOD = 0, 10 ** 9 + 7\\n        for x in range(1, n + 1):\\n            ans = (ans * (1 << (len(bin(x)) - 2)) + x) % MOD\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612330,
                "title": "java-simple-using-log-function",
                "content": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long result=1;\\n        int length=0;\\n        for(int i=2;i<=n;i++) {\\n            // length of number in binary form\\n            length=((int)(Math.log(i)/Math.log(2)))+1;\\n            result=((result<<length)+i)%1000000007;\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long result=1;\\n        int length=0;\\n        for(int i=2;i<=n;i++) {\\n            // length of number in binary form\\n            length=((int)(Math.log(i)/Math.log(2)))+1;\\n            result=((result<<length)+i)%1000000007;\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612315,
                "title": "java-single-line-solution-90-faster-code-beginner-friendly",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int modulo = 1000000007;\\n        \\n        long ans =0;\\n        for(int i=1; i<=n; i++){\\n            ans = (((ans<<(1+(int)(Math.log(i) / Math.log(2))))%modulo)+i)%modulo;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int modulo = 1000000007;\\n        \\n        long ans =0;\\n        for(int i=1; i<=n; i++){\\n            ans = (((ans<<(1+(int)(Math.log(i) / Math.log(2))))%modulo)+i)%modulo;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038088,
                "title": "c-4-solutions-compared-and-explained-80-time-100-space",
                "content": "So, for the first one I wanted to give me the extra challenge of not using `long` (more on that later) and so I decided to count from `1` to `n`, get the bits right and religiously add one bit at a time.\\n\\nTo do so I declared a sole support variable `res` in the main scope of the function, and a few more in our main loop:\\n* `i` will be our main pointer, going from `1` to `n`, as mentioned;\\n* `j` will take the value of `i` and copy it, just to be disassembled, bit by bit;\\n* `bits` is going to be our storage for the bits of each number initially stored in `j` - given the maximum input size, we are fine with just `17` bits;\\n* `pos` is the pointer we will use to work on `bits`, initially set to `0` (first cell).\\n\\nNow, in our main loop we will:\\n* assign the value of `i` to `j`, as mentioned;\\n* extract all the bits and store them in `bits`, with the added convenience of storing them in reverse order;\\n* we will then reverse all the bits in `bits` into `res`, resetting `pos` to `0` again and at each step updating `res` to be double its previous value modulo `1000000007`, plus the current bit.\\n\\nOnce done, we can return `res` :)\\n\\nThe code, running at around 30% time, with significantly low memory consumption (arrays, what would we do without them?):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        // support variables\\n        int res = 0;\\n        for (int i = 1, j, bits[17], pos = 0; i <= n; i++) {\\n            j = i;\\n            // extracting the bits\\n            while (j) {\\n                bits[pos++] = j % 2;\\n                j >>= 1;\\n            }\\n            // applying the bits\\n            while (pos) {\\n                res = (res * 2) % 1000000007 + bits[--pos];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nNow, can we do better?\\n\\nBut of course, starting with removing the modulo operation, which is notoriously rather expensive, and changing the solution to this (bumped up to 40%):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        // support variables\\n        int res = 0;\\n        for (int i = 1, j, bits[17], pos = 0; i <= n; i++) {\\n            j = i;\\n            // extracting the bits\\n            while (j) {\\n                bits[pos++] = j % 2;\\n                j >>= 1;\\n            }\\n            // applying the bits\\n            while (pos) {\\n                res <<= 1;\\n                res = (res > 1000000007 ? res - 1000000007 : res) + bits[--pos];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nCan we do even better? Sure.\\n\\nI admit I did not want to go there not to add extra complexity, but we really do not need to store the bit in `bits` if we \"read\" them from the left, so here is some further optimisation\\n\\nTo do so, we will add an extra support variable, `hasSeenBit`, and in our main loop we will change things a bit and have `j` be our binary pointer (is that even a term? Well, let\\'s pretend it is), being initialised to `1 << bitLmt`, with `bitLmt` expressing the maximum amount of bits we will ever need - for example for `n == 20`, `bitLmt` will be set to `5` (`20` is `10100` in binary representation).\\n\\nWe will, in each loop:\\n* reset `j` to be `1 << bitLmt` and `hasSeenBit` to be `false`;\\n* we will then extract each bit with `bool(i & j)`, which in our previous example will give us `1`, `0`, `1`, `0` and `0`, as expected;\\n* update `hasSeenBit`, so that it will be and stay `true` as soon as the first bit is found;\\n* once a bit has been found, update `res` with the logic discussed above.\\n\\nThe code, which bumped with this change alone to almost 60%:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        // support variables\\n        int res = 0;\\n        bool hasSeenBit;\\n        for (int i = 1, j, bit, bitLmt = ceil(log2(n)); i <= n; i++) {\\n            // preparing for a new loop\\n            j = 1 << 17;\\n            hasSeenBit = false;\\n            // extracting the bits\\n            while (j) {\\n                // getting the next bit, from the left\\n                bit = bool(i & j);\\n                // updating hasSeenBit\\n                hasSeenBit |= bit;\\n                // updating res, only after we have found at least a bit\\n                if (hasSeenBit) {\\n                    res <<= 1;\\n                    res = (res > 1000000007 ? res - 1000000007 : res) + bit;\\n                }\\n                j >>= 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAnd finally the last \"cheap\" one - computing the length in bits of each number, shifting `res` (a `long`, not to risk overflows) by that amount and applying the same logic with modulo and, this time, the whole number in one go.\\n\\nThe last part in particular - not having to split the number into single bits, had the time jump over 80%:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        // support variables\\n        long res = 0;\\n        for (int i = 1, j, bitLen; i <= n; i++) {\\n            j = i;\\n            bitLen = 0;\\n            // computing the length in bits of i\\n            while (j) {\\n                bitLen++;\\n                j >>= 1;\\n            }\\n            // shifting res by bitLen bits\\n            res = (res << bitLen) % 1000000007 + i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        // support variables\\n        int res = 0;\\n        for (int i = 1, j, bits[17], pos = 0; i <= n; i++) {\\n            j = i;\\n            // extracting the bits\\n            while (j) {\\n                bits[pos++] = j % 2;\\n                j >>= 1;\\n            }\\n            // applying the bits\\n            while (pos) {\\n                res = (res * 2) % 1000000007 + bits[--pos];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        // support variables\\n        int res = 0;\\n        for (int i = 1, j, bits[17], pos = 0; i <= n; i++) {\\n            j = i;\\n            // extracting the bits\\n            while (j) {\\n                bits[pos++] = j % 2;\\n                j >>= 1;\\n            }\\n            // applying the bits\\n            while (pos) {\\n                res <<= 1;\\n                res = (res > 1000000007 ? res - 1000000007 : res) + bits[--pos];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        // support variables\\n        int res = 0;\\n        bool hasSeenBit;\\n        for (int i = 1, j, bit, bitLmt = ceil(log2(n)); i <= n; i++) {\\n            // preparing for a new loop\\n            j = 1 << 17;\\n            hasSeenBit = false;\\n            // extracting the bits\\n            while (j) {\\n                // getting the next bit, from the left\\n                bit = bool(i & j);\\n                // updating hasSeenBit\\n                hasSeenBit |= bit;\\n                // updating res, only after we have found at least a bit\\n                if (hasSeenBit) {\\n                    res <<= 1;\\n                    res = (res > 1000000007 ? res - 1000000007 : res) + bit;\\n                }\\n                j >>= 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        // support variables\\n        long res = 0;\\n        for (int i = 1, j, bitLen; i <= n; i++) {\\n            j = i;\\n            bitLen = 0;\\n            // computing the length in bits of i\\n            while (j) {\\n                bitLen++;\\n                j >>= 1;\\n            }\\n            // shifting res by bitLen bits\\n            res = (res << bitLen) % 1000000007 + i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037372,
                "title": "javascript-short-4-liner-simple-solution",
                "content": "```javascript\\nvar concatenatedBinary = function(n) {\\n    let num = 0;\\n    \\n    for(let i = 1; i <= n; i++) {\\n        //OR num *= (1 << i.toString(2).length)\\n        num *= (2 ** i.toString(2).length) \\n        num += i;\\n        num %= (10 ** 9 + 7)\\n    }\\n    return num;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```javascript\\nvar concatenatedBinary = function(n) {\\n    let num = 0;\\n    \\n    for(let i = 1; i <= n; i++) {\\n        //OR num *= (1 << i.toString(2).length)\\n        num *= (2 ** i.toString(2).length) \\n        num += i;\\n        num %= (10 ** 9 + 7)\\n    }\\n    return num;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 961570,
                "title": "c-truly-o-n-solution-4-lines",
                "content": "f(n) = f(n-1) * m(n) + n\\n\\nm(1)=2\\nm(2)=4\\nm(3)=4\\nm(4)=8\\n....\\nm(n) increases only when (n & n - 1) == 0\\n\\n```\\npublic class Solution\\n{\\n    public int ConcatenatedBinary(int n)\\n    {\\n        long m = 1, res = 0, mod = (long)Math.Pow(10, 9) + 7;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            if (i == m) // or ((i & i - 1) == 0)\\n                m <<= 1;\\n            res = (res * m + i) % mod;\\n        }\\n        return (int)res;\\n    }\\n}\\n```\\n\\n\\nShorter version\\n```\\npublic class Solution\\n{\\n    public int ConcatenatedBinary(int n)\\n    {\\n        long m = 1, res = 0, mod = (long)Math.Pow(10, 9) + 7;\\n        for (int i = 1; i <= n; i++)\\n            res = (res * (i == m ? m <<= 1 : m) + i) % mod;\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int ConcatenatedBinary(int n)\\n    {\\n        long m = 1, res = 0, mod = (long)Math.Pow(10, 9) + 7;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            if (i == m) // or ((i & i - 1) == 0)\\n                m <<= 1;\\n            res = (res * m + i) % mod;\\n        }\\n        return (int)res;\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public int ConcatenatedBinary(int n)\\n    {\\n        long m = 1, res = 0, mod = (long)Math.Pow(10, 9) + 7;\\n        for (int i = 1; i <= n; i++)\\n            res = (res * (i == m ? m <<= 1 : m) + i) % mod;\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037649,
                "title": "python-o-n-o-log-n-2-follow-up-with-explanation",
                "content": "## **O(n) Solution**\\n### Idea\\nGo from 1 to `n`. For each `i`, shift the answer left for the length of the binary of `i`, plus `i` and mod `p=10**9+7`.\\n\\nOptimizations include: \\n1) Maintain the length of current `i` with `cur_ibit` and use `next_bit` to detect when to increase. I bet this would be faster than calling `int.bit_length()` on every `i`.\\n2) Use `ans |= i` instead of `ans += i` as the last bits that fit `i` will always be zeros.\\n\\n```python\\nclass Solution:\\n    def concatenatedBinary(self, n: int, p: int = 10 ** 9 + 7) -> int:\\n        ans = 0\\n        next_bit = 1\\n        cur_ibit = 0\\n        for i in range(1, n+1):\\n            if i >= next_bit:\\n                next_bit <<= 1\\n                cur_ibit += 1\\n            ans <<= cur_ibit\\n            ans |= i\\n            ans %= p\\n        return ans\\n```\\n\\n#### Complexity\\n- O(n) time. Going over through `1..n`. \\n- O(1) space. Only a few extra variables.\\n\\n#### Submission stats\\nRuntime: 972 ms (beats 94.60 %)\\nMemory Usage: 14.1 MB (beats 84.51 %)\\n\\n## **O((log n)^2) Solution**\\nWe can achieve better time complexity with some math -- more specifically, matrix multiplication. \\n \\n #### Idea\\n When processing with `i`, the accumulation of `ans` goes as `ans = (ans << i.bit_length()) + i`. If we use a vector of `v[i] = [ans[i], i+1, 1]`, we can write this process as matrix operation `v[i+1] = M_B @ v[i]`: \\n![image](https://assets.leetcode.com/users/images/6c747977-4e3a-41f7-8eb5-b5ea77450547_1611760024.7572007.png),\\nwhere `B = 1 << i.bit_length()` and it is the same for all `2^k <= i < 2^(k+1)`.\\n\\nThe good thing now is that we can fast compute the accumulative effect of those `2^k <= i < 2^(k+1)` (`2^k` of them) that share the same `B` using matrix power ![image](https://assets.leetcode.com/users/images/c220dfd3-54a4-4336-a7d2-f70a3ad71238_1611760413.3877525.png), which takes O(k) time (see `matpowv()`).\\n\\nNow for a given `n`. Say `n = 25`. We start with `v[0] = [0, 1, 1]`. Then we do this matrix power thing for `i` in `[1, 2)`, `[2, 4)`, `[4, 8)`, `[8, 16)`, `[16, 26)`. That is, we calculate ![image](https://assets.leetcode.com/users/images/ab09df56-2b5c-4495-bb37-0a0bac920f29_1611760793.1534994.png) for `B, k = 2, 0`; `4, 1`; `8, 2`; `16, 3`; `32, 4`. In code, we do not explicitly keep `k` but instead use `min(bit, n - bit)` to get the power term. The final answer is `v[25][0]`.\\n\\nOptimizations:\\n1) Same as before, use `bit` to keep track of the most significant bit instead of calculate it every time.\\n2) Collapse matrices into the vector (`matpowv()`) every time to reduce the number of multiplication and additions from 3^3 (matrix multiplies matrix, `matmul()`) to 3^2 (matrix multiplies vector, `mv()`).\\n\\n\\n```python\\ndef matmul(X, Y, p):\\n    return [[sum(a * b for a, b in zip(X_row, Y_col)) % p for Y_col in zip(*Y)] for X_row in X]\\n\\ndef mv(X, v, p):\\n    return [sum(a * b for a, b in zip(X_row, v)) % p for X_row in X]\\n\\ndef matpowv(X, n, v, p):\\n    while n > 0:\\n        if n & 1: v = mv(X, v, p)\\n        X, n = matmul(X, X, p), n >> 1\\n    return v\\n\\nclass Solution:\\n    def concatenatedBinary(self, n: int, p: int = 10 ** 9 + 7) -> int:\\n        n += 1\\n        v = [0, 1, 1]\\n        bit = 1\\n        while bit < n:\\n            M = bit << 1\\n            mat = [\\n                [M, 1, 0],\\n                [0, 1, 1],\\n                [0, 0, 1],\\n            ]\\n            npow = min(bit, n - bit)\\n            v = matpowv(mat, npow, v, p)\\n            bit = M\\n        return v[0]\\n```\\n\\n### Complexity\\n- O((log n)^2) time. O(log n) for going up bit by bit from 1 to n. For each bit, O(log bit) ~ O(log n) for calculating the matrix pow. The size of matrices are irrelavent of n and are always 3x3 and thus the time complexity for matmul is O(1).\\n- O(1) space. The matrices involved take up O(1) space (irrelavent of n). \\n\\n### Submission stats\\nRuntime: 292 ms (beats 97.66 %)\\nMemory Usage: 14.3 MB (beats 53.67 %)\\n\\n---\\nIf you find this helpful, please **upvote**! Thank you!!! :-)\\n\\nAcknowledgement: The idea of the matrix solution comes from [@rbx](https://leetcode.com/rbx)\\'s [post](https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/discuss/963549/python-(log(n))-2-approach).",
                "solutionTags": [
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```python\\nclass Solution:\\n    def concatenatedBinary(self, n: int, p: int = 10 ** 9 + 7) -> int:\\n        ans = 0\\n        next_bit = 1\\n        cur_ibit = 0\\n        for i in range(1, n+1):\\n            if i >= next_bit:\\n                next_bit <<= 1\\n                cur_ibit += 1\\n            ans <<= cur_ibit\\n            ans |= i\\n            ans %= p\\n        return ans\\n```\n```python\\ndef matmul(X, Y, p):\\n    return [[sum(a * b for a, b in zip(X_row, Y_col)) % p for Y_col in zip(*Y)] for X_row in X]\\n\\ndef mv(X, v, p):\\n    return [sum(a * b for a, b in zip(X_row, v)) % p for X_row in X]\\n\\ndef matpowv(X, n, v, p):\\n    while n > 0:\\n        if n & 1: v = mv(X, v, p)\\n        X, n = matmul(X, X, p), n >> 1\\n    return v\\n\\nclass Solution:\\n    def concatenatedBinary(self, n: int, p: int = 10 ** 9 + 7) -> int:\\n        n += 1\\n        v = [0, 1, 1]\\n        bit = 1\\n        while bit < n:\\n            M = bit << 1\\n            mat = [\\n                [M, 1, 0],\\n                [0, 1, 1],\\n                [0, 0, 1],\\n            ]\\n            npow = min(bit, n - bit)\\n            v = matpowv(mat, npow, v, p)\\n            bit = M\\n        return v[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037629,
                "title": "concatenation-of-consecutive-binary-numbers-python-o-n-o-log-n-2-follow-up-with-explanation",
                "content": "## **O(n) Solution**\\n### Idea\\nGo from 1 to `n`. For each `i`, shift the answer left for the length of the binary of `i`, plus `i` and mod `p=10**9+7`.\\n\\nOptimizations include: \\n1) Maintain the length of current `i` with `cur_ibit` and use `next_bit` to detect when to increase. I bet this would be faster than calling `int.bit_length()` on every `i`.\\n2) Use `ans |= i` instead of `ans += i` as the last bits that fit `i` will always be zeros.\\n\\n```python\\nclass Solution:\\n    def concatenatedBinary(self, n: int, p: int = 10 ** 9 + 7) -> int:\\n        ans = 0\\n        next_bit = 1\\n        cur_ibit = 0\\n        for i in range(1, n+1):\\n            if i >= next_bit:\\n                next_bit <<= 1\\n                cur_ibit += 1\\n            ans <<= cur_ibit\\n            ans |= i\\n            ans %= p\\n        return ans\\n```\\n\\n#### Complexity\\n- O(n) time. Going over through `1..n`. \\n- O(1) space. Only a few extra variables.\\n\\n#### Submission stats\\nRuntime: 972 ms (beats 94.60 %)\\nMemory Usage: 14.1 MB (beats 84.51 %)\\n\\n## **O((log n)^2) Solution**\\nWe can achieve better time complexity with some math -- more specifically, matrix multiplication. \\n \\n #### Idea\\n When processing with `i`, the accumulation of `ans` goes as `ans = (ans << i.bit_length()) + i`. If we use a vector of `v[i] = [ans[i], i+1, 1]`, we can write this process as matrix operation `v[i+1] = M_B @ v[i]`: \\n![image](https://assets.leetcode.com/users/images/6c747977-4e3a-41f7-8eb5-b5ea77450547_1611760024.7572007.png),\\nwhere `B = 1 << i.bit_length()` and it is the same for all `2^k <= i < 2^(k+1)`.\\n\\nThe good thing now is that we can fast compute the accumulative effect of those `2^k <= i < 2^(k+1)` (`2^k` of them) that share the same `B` using matrix power ![image](https://assets.leetcode.com/users/images/c220dfd3-54a4-4336-a7d2-f70a3ad71238_1611760413.3877525.png), which takes O(k) time (see `matpowv()`).\\n\\nNow for a given `n`. Say `n = 25`. We start with `v[0] = [0, 1, 1]`. Then we do this matrix power thing for `i` in `[1, 2)`, `[2, 4)`, `[4, 8)`, `[8, 16)`, `[16, 26)`. That is, we calculate ![image](https://assets.leetcode.com/users/images/ab09df56-2b5c-4495-bb37-0a0bac920f29_1611760793.1534994.png) for `B, k = 2, 0`; `4, 1`; `8, 2`; `16, 3`; `32, 4`. In code, we do not explicitly keep `k` but instead use `min(bit, n - bit)` to get the power term. The final answer is `v[25][0]`.\\n\\nOptimizations:\\n1) Same as before, use `bit` to keep track of the most significant bit instead of calculate it every time.\\n2) Collapse matrices into the vector (`matpowv()`) every time to reduce the number of multiplication and additions from 3^3 (matrix multiplies matrix, `matmul()`) to 3^2 (matrix multiplies vector, `mv()`).\\n\\n\\n```python\\ndef matmul(X, Y, p):\\n    return [[sum(a * b for a, b in zip(X_row, Y_col)) % p for Y_col in zip(*Y)] for X_row in X]\\n\\ndef mv(X, v, p):\\n    return [sum(a * b for a, b in zip(X_row, v)) % p for X_row in X]\\n\\ndef matpowv(X, n, v, p):\\n    while n > 0:\\n        if n & 1: v = mv(X, v, p)\\n        X, n = matmul(X, X, p), n >> 1\\n    return v\\n\\nclass Solution:\\n    def concatenatedBinary(self, n: int, p: int = 10 ** 9 + 7) -> int:\\n        n += 1\\n        v = [0, 1, 1]\\n        bit = 1\\n        while bit < n:\\n            M = bit << 1\\n            mat = [\\n                [M, 1, 0],\\n                [0, 1, 1],\\n                [0, 0, 1],\\n            ]\\n            npow = min(bit, n - bit)\\n            v = matpowv(mat, npow, v, p)\\n            bit = M\\n        return v[0]\\n```\\n\\n### Complexity\\n- O((log n)^2) time. O(log n) for going up bit by bit from 1 to n. For each bit, O(log bit) ~ O(log n) for calculating the matrix pow. The size of matrices are irrelavent of n and are always 3x3 and thus the time complexity for matmul is O(1).\\n- O(1) space. The matrices involved take up O(1) space (irrelavent of n). \\n\\n### Submission stats\\nRuntime: 292 ms (beats 97.66 %)\\nMemory Usage: 14.3 MB (beats 53.67 %)\\n\\n---\\nIf you find this helpful, please **upvote**! Thank you!!! :-)\\n\\nAcknowledgement: The idea of the matrix solution comes from [@rbx](https://leetcode.com/rbx)\\'s [post](https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/discuss/963549/python-(log(n))-2-approach).",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```python\\nclass Solution:\\n    def concatenatedBinary(self, n: int, p: int = 10 ** 9 + 7) -> int:\\n        ans = 0\\n        next_bit = 1\\n        cur_ibit = 0\\n        for i in range(1, n+1):\\n            if i >= next_bit:\\n                next_bit <<= 1\\n                cur_ibit += 1\\n            ans <<= cur_ibit\\n            ans |= i\\n            ans %= p\\n        return ans\\n```\n```python\\ndef matmul(X, Y, p):\\n    return [[sum(a * b for a, b in zip(X_row, Y_col)) % p for Y_col in zip(*Y)] for X_row in X]\\n\\ndef mv(X, v, p):\\n    return [sum(a * b for a, b in zip(X_row, v)) % p for X_row in X]\\n\\ndef matpowv(X, n, v, p):\\n    while n > 0:\\n        if n & 1: v = mv(X, v, p)\\n        X, n = matmul(X, X, p), n >> 1\\n    return v\\n\\nclass Solution:\\n    def concatenatedBinary(self, n: int, p: int = 10 ** 9 + 7) -> int:\\n        n += 1\\n        v = [0, 1, 1]\\n        bit = 1\\n        while bit < n:\\n            M = bit << 1\\n            mat = [\\n                [M, 1, 0],\\n                [0, 1, 1],\\n                [0, 0, 1],\\n            ]\\n            npow = min(bit, n - bit)\\n            v = matpowv(mat, npow, v, p)\\n            bit = M\\n        return v[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961368,
                "title": "java-simple-easy-o-n-solution",
                "content": "The idea is to add powers of 2 if the last bit is 1.\\n\\n```\\n    public int concatenatedBinary(int n) {\\n        long res = 0, mul = 1;\\n        int mod = 1_000_000_007;\\n        for(int i = n; i > 0; --i){\\n            int no = i;\\n            while(no > 0){\\n                if(no % 2 == 1) res = (res + mul) % mod;\\n                no >>= 1;\\n                mul = (mul<<1) % mod;\\n            }\\n        }\\n        \\n        return (int)res;\\n    }",
                "solutionTags": [],
                "code": "The idea is to add powers of 2 if the last bit is 1.\\n\\n```\\n    public int concatenatedBinary(int n) {\\n        long res = 0, mul = 1;\\n        int mod = 1_000_000_007;\\n        for(int i = n; i > 0; --i){\\n            int no = i;\\n            while(no > 0){\\n                if(no % 2 == 1) res = (res + mul) % mod;\\n                no >>= 1;\\n                mul = (mul<<1) % mod;\\n            }\\n        }\\n        \\n        return (int)res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2612473,
                "title": "c-bit-manipulation-fully-explained-solution",
                "content": "Countbits function returns the number of bits in the number n\\nLet\\'s understand this with an example, \\n\\nWe will take the example of a decimal number(base 10).\\nIf we take log10(n)+1 it will return the number of digits in the base 10.\\n\\nFor example, \\n\\nlog10(121)+1 = 3\\nlog10(87)+1 = 2\\nlog10(2)+1 = 1\\n\\nNow, the same goes for a log base 2 in a binary system.\\nlog2(5)+1 = 3\\nlog2(3)+1 = 2\\nlog2(1)+1 = 2\\n\\nOnce we have the number of bits, we can continue ahead\\n\\n1. we just left shift our temp variable by the number of bits in ith number\\n2. then we xor temp with i\\n\\nFor example,\\n\\ntemp=0;\\nn=2;\\ni->1 to 2;\\nFor i=1,\\n(temp<<1)^i -> (0<<1)^1 -> (00)^01 -> 01\\ntemp = 01\\n\\nnext ,\\n\\nFor i=2,\\n(temp<<2)^i -> (01<<2)^2 -> (0100)^10 -> 0110\\ntemp = 110 -> 6\\nso 6 will be the answer in this way\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long int MOD = 1e9+7;\\n    \\n    int countbits(int n){\\n        return log2(n)+1;\\n    }\\n    \\n    int concatenatedBinary(int n) {\\n        \\n        long long temp = 0;\\n        for(int i=1;i<=n;i++) temp = ((temp<<countbits(i))^i)%MOD;\\n        return temp%MOD;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long int MOD = 1e9+7;\\n    \\n    int countbits(int n){\\n        return log2(n)+1;\\n    }\\n    \\n    int concatenatedBinary(int n) {\\n        \\n        long long temp = 0;\\n        for(int i=1;i<=n;i++) temp = ((temp<<countbits(i))^i)%MOD;\\n        return temp%MOD;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037296,
                "title": "javascript-easy-solution-beats-95",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nThere are less efficient solutions which involve converting numbers to strings, or calculating the binary length each time, but the most efficient solution is actually even more basic, since we know precisely when a binary number will increase its length by 1.\\n\\nSo we can just iterate through while using **len** to keep track of how much you need to multiply **ans** by in order to fit **i** into the new **ans**. Don\\'t forget to mod by **1e9+7**.\\n\\n---\\n\\n***Javascript Code:***\\n\\nThe best result for the code below is **148ms / 39.8MB** (95% / 84%).\\n```javascript\\nvar concatenatedBinary = function(n) {\\n    let ans = 1, len = 0b100\\n    for (let i = 2; i <= n; i++) {\\n        if (i === len) len <<= 1\\n        ans = (ans * len + i) % 1000000007\\n    }\\n    return ans\\n};\\n```\\nThe same code but with decimal instead of binary for **len**:\\n```javascript\\nvar concatenatedBinary = function(n) {\\n    let ans = 1, len = 4\\n    for (let i = 2; i <= n; i++) {\\n        if (i === len) len *= 2\\n        ans = (ans * len + i) % 1000000007\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar concatenatedBinary = function(n) {\\n    let ans = 1, len = 0b100\\n    for (let i = 2; i <= n; i++) {\\n        if (i === len) len <<= 1\\n        ans = (ans * len + i) % 1000000007\\n    }\\n    return ans\\n};\\n```\n```javascript\\nvar concatenatedBinary = function(n) {\\n    let ans = 1, len = 4\\n    for (let i = 2; i <= n; i++) {\\n        if (i === len) len *= 2\\n        ans = (ans * len + i) % 1000000007\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1037274,
                "title": "c-from-tle-to-40ms",
                "content": "inituitive brute force. We add each number bit by bit. But this will be TLE.\\n```\\nclass Solution {\\n public:\\n  int concatenatedBinary(int n) {\\n    int ans = 0;\\n\\t\\n\\tstack<int> stk;\\n\\n    for (int i = 1; i <= n; ++i) {\\n      int x = i;\\n\\n      while (x > 0) {\\n        stk.push(x % 2);\\n        x /= 2;\\n      }\\n\\n      while (!stk.empty()) {\\n        ans = ans * 2 + stk.top();\\n        stk.pop();\\n\\n        ans %= 1000000007;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\\n\\nWe can optimize the following part to reduce the cost.\\n```\\n      while (!stk.empty()) {\\n        ans = ans * 2 + stk.top();\\n        stk.pop();\\n\\n        ans %= 1000000007;\\n      }\\n```\\nupdate it to\\n```\\nans = (ans << len) % mod + i;\\n```\\n\\nWhat happend here is with the second solution we add the whole number with one ```<<``` operation instead of multiple ```<<``` operations with the first solution.\\n```len``` is the binary length of a number which is equal to stack length of the first solution.\\nIn another words, we recude ```<<``` operator from ```len``` times to 1 time.\\n\\nSolution 2,\\n```\\nclass Solution {\\n public:\\n  int concatenatedBinary(int n) {\\n    long ans = 0;\\n    const int mod = 1000000007;\\n\\n    for (int i = 1; i <= n; ++i) {\\n      int x = i, len = 0;\\n\\n      while (x > 0) {\\n        ++len;\\n        x /= 2;\\n      }\\n\\n      ans = (ans << len) % mod + i;\\n    }\\n\\n    return ans % mod;\\n  }\\n};\\n```\\n\\nThanks to @jitendragupta1981,  we could make it more reasonable.\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0;\\n        const int mod = 1000000007;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            int x = i, len = 0;\\n            \\n            while (x > 0) {\\n                ++len;\\n                x /= 2;\\n            }\\n            \\n            ans = ((ans << len) + i) % mod; // or ans = ((ans << len) | i) % mod;\\n        }\\n        \\n        return ans % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  int concatenatedBinary(int n) {\\n    int ans = 0;\\n\\t\\n\\tstack<int> stk;\\n\\n    for (int i = 1; i <= n; ++i) {\\n      int x = i;\\n\\n      while (x > 0) {\\n        stk.push(x % 2);\\n        x /= 2;\\n      }\\n\\n      while (!stk.empty()) {\\n        ans = ans * 2 + stk.top();\\n        stk.pop();\\n\\n        ans %= 1000000007;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\n```\\n      while (!stk.empty()) {\\n        ans = ans * 2 + stk.top();\\n        stk.pop();\\n\\n        ans %= 1000000007;\\n      }\\n```\n```\\nans = (ans << len) % mod + i;\\n```\n```<<```\n```<<```\n```len```\n```<<```\n```len```\n```\\nclass Solution {\\n public:\\n  int concatenatedBinary(int n) {\\n    long ans = 0;\\n    const int mod = 1000000007;\\n\\n    for (int i = 1; i <= n; ++i) {\\n      int x = i, len = 0;\\n\\n      while (x > 0) {\\n        ++len;\\n        x /= 2;\\n      }\\n\\n      ans = (ans << len) % mod + i;\\n    }\\n\\n    return ans % mod;\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0;\\n        const int mod = 1000000007;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            int x = i, len = 0;\\n            \\n            while (x > 0) {\\n                ++len;\\n                x /= 2;\\n            }\\n            \\n            ans = ((ans << len) + i) % mod; // or ans = ((ans << len) | i) % mod;\\n        }\\n        \\n        return ans % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612136,
                "title": "daily-leetcoding-challenge-september-day-23",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Change to Binary String\n\n  \n**Approach 2:** Math\n\n  \n**Approach 3:** Math (Bitwise Operation)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 3:** Math (Bitwise Operation)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 961447,
                "title": "python-c-simple-4-liner-inbuilt-and-bitwise",
                "content": "Using Python Inbuilt bin method:\\nPython\\n```\\n def concatenatedBinary(self, n: int) -> int:\\n        res = \"\"\\n        for i in range(1,n+1):\\n            res+=bin(i)[2:]\\n        return int(res,2)%(10**9 + 7)\\n```\\n\\nUsing bitwise operation:\\nC++\\n\\n```\\nint concatenatedBinary(int n) {\\n        long int res = 0, shift = 0 ;\\n        long int mod = 1e9 + 7;\\n        for (long int i = 1; i<=n; i++){\\n            if( (i & (i-1)) == 0)\\n                shift+=1;\\n            res = ((res<<shift)|i )%mod;\\n            \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n def concatenatedBinary(self, n: int) -> int:\\n        res = \"\"\\n        for i in range(1,n+1):\\n            res+=bin(i)[2:]\\n        return int(res,2)%(10**9 + 7)\\n```\n```\\nint concatenatedBinary(int n) {\\n        long int res = 0, shift = 0 ;\\n        long int mod = 1e9 + 7;\\n        for (long int i = 1; i<=n; i++){\\n            if( (i & (i-1)) == 0)\\n                shift+=1;\\n            res = ((res<<shift)|i )%mod;\\n            \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 961399,
                "title": "java-python-3-bit-manipulations",
                "content": "```java\\n    private static final List<Integer> table = new ArrayList<>(Arrays.asList(0));\\n    public int concatenatedBinary(int n) {\\n        if (table.size() <= n) {\\n            long num = table.get(table.size() - 1);\\n            for (int i = table.size(); i <= n; ++i) {\\n                num <<= 32 - Integer.numberOfLeadingZeros(i);\\n                num |= i;\\n                num %= 1_000_000_007;\\n                table.add((int)num);\\n            }\\n        }\\n        return table.get(n);\\n    }\\n```\\n```python\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\\'\\'.join(bin(i)[2 :] for i in range(1, n + 1)), 2) % (10 ** 9 + 7)\\n```",
                "solutionTags": [],
                "code": "```java\\n    private static final List<Integer> table = new ArrayList<>(Arrays.asList(0));\\n    public int concatenatedBinary(int n) {\\n        if (table.size() <= n) {\\n            long num = table.get(table.size() - 1);\\n            for (int i = table.size(); i <= n; ++i) {\\n                num <<= 32 - Integer.numberOfLeadingZeros(i);\\n                num |= i;\\n                num %= 1_000_000_007;\\n                table.add((int)num);\\n            }\\n        }\\n        return table.get(n);\\n    }\\n```\n```python\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\\'\\'.join(bin(i)[2 :] for i in range(1, n + 1)), 2) % (10 ** 9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1376623,
                "title": "c-easy-solution-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        \\n        //start from n to 1\\n        long long ans=1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            //calculate the bits in the current number (i)\\n            long long  num=(log(i)/log(2)) + 1;\\n            //left shift the bits as we need to append the i\\n            ans=ans<<num;\\n            ans|=i;\\n            ans%=1000000007;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        \\n        //start from n to 1\\n        long long ans=1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            //calculate the bits in the current number (i)\\n            long long  num=(log(i)/log(2)) + 1;\\n            //left shift the bits as we need to append the i\\n            ans=ans<<num;\\n            ans|=i;\\n            ans%=1000000007;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038608,
                "title": "java-with-explaination-o-n-time-o-1-space-minimum-lines-bitwise",
                "content": "1. if it is asked to make a decimal number how would concatenation work?\\nfor example ->\\nsuppose 1 is first number and we want to concate it with 2. it can be written as 1* 10+2=12\\nsuppose 1 is first number and we want to concate it with 21. it can be written as 1* 100+21=121\\nsuppose 1 is first number and we want to concate it with 342. it can be written as 1* 1000+341=1341\\nso what we can deduce is the result of append is like = original_num* pow(10,lengthOfSecondString) + secondString.\\nin case of 1 and 341. length of 341 is 3 so, res= 1* pow(10,3) + 341\\n2. so we just need to run loop from 2 to n and start applying above logic to build the answer.\\n3. second observation. since above example is in decimal system that is why we are multiplying by 10 power. if it is binary me need to multiply by power (2,lengthOfSecondNumber).\\n4. Now question is we need to find length of number in binary format. log of a number in base 2 will give the length of number in binary format +1. just like log of a number base 10 +1 gives length in decimal format. In java log base 2 method is not available only base 10 is available. so we can use below log property. \\n5. for this we could use below formula - \\nMath.log2(n) = Math.log10(n)/Math.log10(2);\\n6.now we have length. we can using power method to multiply firstNumber* pow(2,lengthOfSecond) or we can use left shift operator. as we know left shift by 1 is multiply by 2. and left shift of length will be multiply by 2^length.\\n\\n\\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long result=1;\\n        int length=0;\\n        for(int i=2;i<=n;i++) {\\n            length=((int)(Math.log(i)/Math.log(2)))+1;\\n            result=((result<<length)+i)%1000000007;\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long result=1;\\n        int length=0;\\n        for(int i=2;i<=n;i++) {\\n            length=((int)(Math.log(i)/Math.log(2)))+1;\\n            result=((result<<length)+i)%1000000007;\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019740,
                "title": "very-simple-java-solution-with-explanation",
                "content": "Here is the process how you can derive recurrent formula\\n\\nresult(n) = result(n - 1) * 2^binaryDigitsOf(n) + n\\n\\nwhere binaryDigitsOf(n) is the number of binary digits needed to write number n. \\n\\ni = 1:\\n1 -> \"1\" = 1\\nresult is 1\\n\\ni = 2:\\n2 -> \"1\"\"10\" = (110) = (1 10) = 1 * 4 + 2 = result * 2^binaryDigitsOf(2) + 2 = result * 2^binaryDigitsOf(i) + i = 6\\nresult is 6\\n\\ni = 3:\\n3 -> \"110\"\"11\" = (11011) = (110 11) = 6 * 4 + 3 = result * 2^binaryDigitsOf(3) + 3 = result * 2^binaryDigitsOf(i) + i = 27\\nresult is 27\\n\\ni = 4:\\n4 -> \"11011\"\"100\" = (11011100)  = (11011 100) = 27 * 8 + 4 = result * 2^binaryDigitsOf(4) + 4 = result * 2^binaryDigitsOf(i) + i = 220\\nresult is 220\\n\\nAnd so on until n. We just need to take care of overflow, because of that we use long instead of int and do modulo operation. At the end we convert it to the int. That\\'s it. Enjoy in code!\\n\\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        \\n\\t\\tint MOD = 1_000_000_007;\\n\\t\\t\\n\\t\\tlong[] powersOf2 = getPowersOf2();\\n\\t\\t\\n\\t\\tlong result = 0;\\n\\t\\t\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tresult = (result * powersOf2[getNumberOfBinaryDigits(i, powersOf2)] + i) % MOD;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn (int) (result % MOD);\\n    }\\n\\t\\n\\tprivate int getNumberOfBinaryDigits(int n, long[] powersOf2) {\\n\\t\\t\\n\\t\\tfor (int i = 1; i < 32; i++) {\\n\\t\\t\\tif (powersOf2[i] > n) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t} else if (powersOf2[i] == n) {\\n\\t\\t\\t\\treturn i + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn 1000; // never will come here\\n\\t}\\n\\n\\tprivate long[] getPowersOf2() {\\n\\t\\tlong[] powersOf2 = new long[32];\\n\\t\\t\\n\\t\\tpowersOf2[0] = 1;\\n\\t\\t\\n\\t\\tfor (int i = 1; i < 32; i++) {\\n\\t\\t\\tpowersOf2[i] = 2 * powersOf2[i - 1];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn powersOf2;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        \\n\\t\\tint MOD = 1_000_000_007;\\n\\t\\t\\n\\t\\tlong[] powersOf2 = getPowersOf2();\\n\\t\\t\\n\\t\\tlong result = 0;\\n\\t\\t\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tresult = (result * powersOf2[getNumberOfBinaryDigits(i, powersOf2)] + i) % MOD;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn (int) (result % MOD);\\n    }\\n\\t\\n\\tprivate int getNumberOfBinaryDigits(int n, long[] powersOf2) {\\n\\t\\t\\n\\t\\tfor (int i = 1; i < 32; i++) {\\n\\t\\t\\tif (powersOf2[i] > n) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t} else if (powersOf2[i] == n) {\\n\\t\\t\\t\\treturn i + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn 1000; // never will come here\\n\\t}\\n\\n\\tprivate long[] getPowersOf2() {\\n\\t\\tlong[] powersOf2 = new long[32];\\n\\t\\t\\n\\t\\tpowersOf2[0] = 1;\\n\\t\\t\\n\\t\\tfor (int i = 1; i < 32; i++) {\\n\\t\\t\\tpowersOf2[i] = 2 * powersOf2[i - 1];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn powersOf2;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612717,
                "title": "python-one-line-solution-94-beats",
                "content": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\"\".join([bin(i)[2:] for i in range(1,n+1)]),2)%(10**9+7)\\n    \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\"\".join([bin(i)[2:] for i in range(1,n+1)]),2)%(10**9+7)\\n    \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 2612278,
                "title": "c-must-know-method-explained",
                "content": "Understanding: In a **binary represenatation**, **1110** = 14 can be written as: **1100** + **10** = (**11**<<*2*) +  (**10**<<*0*) = *12+2 = 14*.\\n(All Binary Notation are in Bold.) \\nExample:\\nLets say n = *3*.\\nSo, concatenation would be: **1 10 11 100**\\nEach time we concatenate, we left shift our previous number by length of binary representation of that number.\\nSo, at *1*, we have *1*.\\nAt *2*, we have **1** **10**, (**1**<<*2*) + **10** = *4 + 2 = 6*,One left shifts twice to create space for the new number which has *2* bits in it. \\nAt *3*, similarly, **110** **11**, 6 is left shifted twice, so* 6x2x2 = 24 + 3*(the new number) = *27*.\\n\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int concatenatedBinary(int n) {\\n        long ans = 0;\\n        int length = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            //Length increases on each power of two.\\n            if ((i&(i - 1)) == 0) \\n                ++length;\\n            //Left shift by that length.\\n            ans = ((ans << length) % mod + i) % mod;\\n            cout << length << endl;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int concatenatedBinary(int n) {\\n        long ans = 0;\\n        int length = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            //Length increases on each power of two.\\n            if ((i&(i - 1)) == 0) \\n                ++length;\\n            //Left shift by that length.\\n            ans = ((ans << length) % mod + i) % mod;\\n            cout << length << endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1037382,
                "title": "c-o-n-solution",
                "content": "Left shift the answer every time by len and add the number, and then increment the length value at powers of 2.\\n```\\n  int concatenatedBinary(int n) {\\n    long ans=0;\\n    int mod=1e9+7,len=1;\\n    for(int i=1;i<=n;++i){\\n        ans=(ans<<len)%mod+i;\\n        if((i&(i+1))==0)\\n            len++;\\n    }\\n\\treturn ans % mod;\\n  }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n  int concatenatedBinary(int n) {\\n    long ans=0;\\n    int mod=1e9+7,len=1;\\n    for(int i=1;i<=n;++i){\\n        ans=(ans<<len)%mod+i;\\n        if((i&(i+1))==0)\\n            len++;\\n    }\\n\\treturn ans % mod;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 961432,
                "title": "java-simple",
                "content": "**1680. Concatenation of Consecutive Binary Numbers**\\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int i=1;\\n        int mod = (int)Math.pow(10,9) + 7;\\n        StringBuilder sb = new StringBuilder();\\n        while(i<=n){\\n            sb.append(Integer.toBinaryString(i)); // Build string with integers\\n            i++;\\n        }\\n        String binary = sb.toString();\\n        int current = 0;\\n        for(i=0; i<binary.length();i++){\\n            current += binary.charAt(i) ==\\'1\\'? 1:0; // add 1 if it is a 1\\n            if(i+1 != binary.length()) // only multiply if it is not the last place or else it will be too big!\\n                current = ((current % mod) * 2) % mod; // modular multiplication to avoid overflow\\n        }\\n        return current;\\n    }\\n}\\n```\\n**PROBLEM OVERVIEW**\\nGiven an int, n, concatenate all numbers from 1 to n in binary. Convert this binary number into decimal. Numbers may be large so return the answer mod 10^9 + 7.\\n\\n**SOLUTION ANALYSIS**\\nUse a StringBuilder for efficient String concatenation. For each decimal value 1 to n, we can use Java\\'s inbuilt function Integer.toBinaryString(int i) to concatenate the binary representation.\\n\\nAfter that, we need to use modular multiplication to avoid overflow. To convert binary to decimal, we typically add 1 if it is a 1 at that place value and then multiply the sum by 2. However, bcause the number may be too large, we take the remainder of the current number and mod (10^9 + 7) before and after multiplying. By doing so, we prevent overflow.\\n\\nFor modular multiplication, the typical code is like this :\\n```\\npublic int modularMultiplication(int a, int b, int mod){\\n\\treturn ((a%mod) * (b%mod)) % mod;\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int i=1;\\n        int mod = (int)Math.pow(10,9) + 7;\\n        StringBuilder sb = new StringBuilder();\\n        while(i<=n){\\n            sb.append(Integer.toBinaryString(i)); // Build string with integers\\n            i++;\\n        }\\n        String binary = sb.toString();\\n        int current = 0;\\n        for(i=0; i<binary.length();i++){\\n            current += binary.charAt(i) ==\\'1\\'? 1:0; // add 1 if it is a 1\\n            if(i+1 != binary.length()) // only multiply if it is not the last place or else it will be too big!\\n                current = ((current % mod) * 2) % mod; // modular multiplication to avoid overflow\\n        }\\n        return current;\\n    }\\n}\\n```\n```\\npublic int modularMultiplication(int a, int b, int mod){\\n\\treturn ((a%mod) * (b%mod)) % mod;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615214,
                "title": "c-hand-written-explanation-o-n",
                "content": "\\n![image](https://assets.leetcode.com/users/images/4e2c3444-ae8d-4f8e-92f6-2998b7e7ec9f_1663958420.934887.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n     \\n        long long int i=1, k=1, z, sum = 1, bit, M = 1e9+7;\\n        \\n        while(i != n)\\n        {\\n            z = pow(2,k);\\n            bit = pow(2,k+1);\\n            k++;\\n    \\n            while(z-- && i != n)\\n            {\\n                i++;\\n                sum = ((sum*bit)%M + i)%M;\\n            }\\n        }\\n        return sum%M;\\n    }\\n};  \\n```\\n\\uD83D\\uDC47 Please Upvote if you find helpful \\u2764",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n     \\n        long long int i=1, k=1, z, sum = 1, bit, M = 1e9+7;\\n        \\n        while(i != n)\\n        {\\n            z = pow(2,k);\\n            bit = pow(2,k+1);\\n            k++;\\n    \\n            while(z-- && i != n)\\n            {\\n                i++;\\n                sum = ((sum*bit)%M + i)%M;\\n            }\\n        }\\n        return sum%M;\\n    }\\n};  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613556,
                "title": "c-using-bit-manipulation-explained-100",
                "content": "Using BitManipulation...\\n\\nWell, we have to concatente the binary presentation of a consective numbers; Okey that\\'s all until now\\nLet\\'s create a new problem using this problem which simple than this one instead of concatenting the the binary presentation Let\\'s concatente the numbers their self :\\nso for example **n = 9** so our numbers are **1, 2, 3, 4, 5, 6, 7, 8, 9** and we should get ***123456789***\\nto do so :\\nIt\\'s simple **sum = 1**\\nnext step we should get **12** : how would we do that ?? it\\'s obvious that we should multiply the sum by 10 to be come 10 in this case then add our next number which is 2 to be become **sum = 12** (why we multiply by **10** ? we\\'ll answer that lately)\\n**sum = 12** and the next num is **3** so we should get **123** we do the same **sum = sum * 10** which will get us **sum = 120 **then add **3 **easily we will have **123**\\nand so on until we get **123456789**\\n```\\n1-2 (e1) - 0\\n0-0-3\\n```\\nto make this give us **123** it\\'s obvious that we need to add 0 in (e1)\\nOkey but the max number here is not 9\\nos let\\'s take **11** for example **(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)**\\nwe should get **[123456789]1011** the **123456789** which is the part one, we already explained it what about **1011** how can we add it, so :\\n**sum = 123456789**\\n**for i = 10**\\nshould we multiply by 10, Let\\'s do so\\n```\\n1-2-3-4-5-6-7-8-9-0\\n0-0-0-0-0-0-0-0-1-0\\n................0-0 we can stop here obviously not our solution the number was ruined !!\\n```\\nI think we should reserve a two new places for the current number to get its place\\nso We have something like :\\n```\\n1-2-3-4-5-6-7-8-9-0-0\\n0-0-0-0-0-0-0-0-0-1-0\\n```\\nit\\'s clear that we wil get our answer\\nso here we multiply by 100 not 10\\nif n = 120 when we\\'ll reach 100 for **(100, 101, 102, ..., 120)** we should start to multiply by 1000 (3 zeroes = digit count) so we can handle digits count in number...\\nit\\'s simple we should start mult = 10\\nso we can always do this until `i = mult then mult should be multiplied by 10 to become mult = 100`\\nand so one when `i = mult again (mult = 100) mult *= 10` to become mult = 1000 so we can reserve three spots for the new number **(100 - 999)** and so on\\nLet\\'s go back to our problem, I think now it looks a little more simple !!!\\nSo it\\'s the same as decimal.... we should concatenate **12 and 13** we should reserve two empty spots (0) beside 12 for 13 means whe should multiply by 100 **(10 ^ (number of spots we need))**\\nIn binary we have 1001 and 111 it\\'s simple we just need to reserve 3 empty spots (0) for 111 beside 1001 so we should make 1001 become **[1001]000** then easly add **111** to have `[1001]111 := 1001111`\\nso we need only to know the length of the number that we\\'re gonna concatenate and reserve the spots for it\\nin decimal we multiply to reserve spots but in binary we shoud shift right to reserve spot\\n`12 and 13 :: 12 * 100 = 1200 `**(we got two empty spots = 2 trailing zeroes)** we add 13 to become **1213**\\n`1001 and 111 ::: 1001 << 3` **(digits count in the number [111 in this case])** = 1001000 then add **111** to become **1001111** we will just add number in decimal system and surely that will what we get in binary presentation or if we did a binary addition opperation\\nso **for n = 5** we have **1, 10, 11, 100, 101**\\n**result = 0**\\n**digit_count = 1**\\nsign_that_digit_count_increased = 2 (means if we reach 2 than 2 - 3 numbers will have 2 digits, and so one `\"{ i in [2 ^ n, 2 ^ (n + 1) - 1] ::: digits count of i is n }\"`\\n\\nwe should do simply\\n```\\nfor i = 0 ------> n;\\n\\tif (i == sign_that_digit_count_increased)\\n\\t\\tsign_that_digit_count_increased *= 2 (2 = 10(binary), 4 = 100(binary), 8 = 1000, 16 = 10000, 32 = 100000, ...)\\n\\t\\tdigit_count += 1\\n\\tresult = result << digit_count (to reserve for the new number);\\n\\tresult += i;\\n```\\n\\nor instead of \" sign_that_digit_count_increased \" we just have to check if (i & i + 1) is zero for example 100 and 11, 1000 and 111, 10000 and 1111; cause every consective numbers have at least one bit active commun between them expect (2 ^ n and 2 ^ n - 1) for every n\\nI hope It\\'s all clear\\n\\n```\\nclass Solution {\\npublic:\\n    long long   sum = 0;\\n    long long   MOD = 1000000007;\\n\\n    int concatenatedBinary(int n) {\\n        int length_b = 0;\\n        \\n        for (int i=1; i<=n; i++)\\n        {\\n            if ((i & (i - 1)) == 0)\\n                length_b++;\\n            sum = ((sum << length_b) + i) % MOD;\\n        }\\n        return (sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n1-2 (e1) - 0\\n0-0-3\\n```\n```\\n1-2-3-4-5-6-7-8-9-0\\n0-0-0-0-0-0-0-0-1-0\\n................0-0 we can stop here obviously not our solution the number was ruined !!\\n```\n```\\n1-2-3-4-5-6-7-8-9-0-0\\n0-0-0-0-0-0-0-0-0-1-0\\n```\n```\\nfor i = 0 ------> n;\\n\\tif (i == sign_that_digit_count_increased)\\n\\t\\tsign_that_digit_count_increased *= 2 (2 = 10(binary), 4 = 100(binary), 8 = 1000, 16 = 10000, 32 = 100000, ...)\\n\\t\\tdigit_count += 1\\n\\tresult = result << digit_count (to reserve for the new number);\\n\\tresult += i;\\n```\n```\\nclass Solution {\\npublic:\\n    long long   sum = 0;\\n    long long   MOD = 1000000007;\\n\\n    int concatenatedBinary(int n) {\\n        int length_b = 0;\\n        \\n        for (int i=1; i<=n; i++)\\n        {\\n            if ((i & (i - 1)) == 0)\\n                length_b++;\\n            sum = ((sum << length_b) + i) % MOD;\\n        }\\n        return (sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612730,
                "title": "c-nothing-fancy-clean-and-simple-solution",
                "content": "```\\n int concatenatedBinary(int n) {\\n        int ans=0;\\n        long long bit=1;\\n        for(int i=n;i>0;i--)\\n        {\\n            int num=i;\\n            while(num)\\n            {\\n             if(num%2) ans= (ans+bit)%1000000007;\\n              num/=2;\\n              bit= (bit*2)%1000000007;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int concatenatedBinary(int n) {\\n        int ans=0;\\n        long long bit=1;\\n        for(int i=n;i>0;i--)\\n        {\\n            int num=i;\\n            while(num)\\n            {\\n             if(num%2) ans= (ans+bit)%1000000007;\\n              num/=2;\\n              bit= (bit*2)%1000000007;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2612637,
                "title": "simple-easy-o-n-log-n-o-n",
                "content": "Since we are concatenating binary numbers from left to right , for every number we have to **left shift our result floor[ log(n)+1]** times and **add our current number** .\\n```\\nE.g. Consider 3\\nres = 0                1 (1)                110 ( 1<<2 (i.e.log(2)+1) + 2)                               11011 ( 110<<2 (i.e. log(3)+1) + 3)  \\n1 to N                    1                                     2                                               3\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int log2(int n ){\\n        int c = 0;\\n        while(n>1){\\n          n /=2;\\n            c++;\\n        }\\n        return c;\\n    }\\n    \\n    int concatenatedBinary(int n) {\\n    \\n        int mod = 1e9+7;\\n        long long ans = 0;\\n        for(int i =1;i<=n;i++){\\n            \\n            int a = log2(i)+1; \\n            ans = ans << a;\\n            ans = ans + i;\\n            if(ans>mod){\\n                ans = ans%mod;\\n            }\\n            \\n        }\\n       \\n        return ans%mod;\\n    }\\n};\\n```\\n**Time Complexity : O(n logn)\\nSpace Complexity : O(1)**\\n\\n**Note :** This can be easily reduced to **O(n)** if we keep the count of bits from the start of the loop .",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nE.g. Consider 3\\nres = 0                1 (1)                110 ( 1<<2 (i.e.log(2)+1) + 2)                               11011 ( 110<<2 (i.e. log(3)+1) + 3)  \\n1 to N                    1                                     2                                               3\\n```\n```\\nclass Solution {\\npublic:\\n    int log2(int n ){\\n        int c = 0;\\n        while(n>1){\\n          n /=2;\\n            c++;\\n        }\\n        return c;\\n    }\\n    \\n    int concatenatedBinary(int n) {\\n    \\n        int mod = 1e9+7;\\n        long long ans = 0;\\n        for(int i =1;i<=n;i++){\\n            \\n            int a = log2(i)+1; \\n            ans = ans << a;\\n            ans = ans + i;\\n            if(ans>mod){\\n                ans = ans%mod;\\n            }\\n            \\n        }\\n       \\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612199,
                "title": "bruteforce-faster-than-100-no-formula-fooling-leetcode-judge-static-accepted",
                "content": "No Formula, No Nothing, Plain brute force with a twist.  \\n\\nSo my first idea to run a bruteforce gave me TLE. I tried to think but did not get any clever solutions, so being lazy to think i fooled leetcode judge like this.\\n\\nPrecomputed all the binary strings using a static array. This array will only be computed once and will be used commonly by all the testcases and the bruteforce solution passes.\\n\\n```\\nclass Solution {\\n\\nstatic String arr[] = new String[100001];\\n\\npublic void build() {\\n\\tfor(int i=1; i<=100000; i++) {\\n\\t\\tarr[i] = Integer.toBinaryString(i);\\n\\t}\\n}\\n\\nint mod = 1000000007;\\n\\npublic int getVal(int n) {\\n\\tint val = 0;\\n\\tfor(int i=1; i<=n; i++) {\\n\\t\\tfor(int j=0; j<arr[i].length(); j++) {\\n\\t\\t\\tint x = arr[i].charAt(j)-\\'0\\';\\n\\t\\t\\tval = (val*2 + x)%mod;\\n\\t\\t}\\n\\t}\\n\\treturn val;\\n}\\n\\npublic int concatenatedBinary(int n) {\\n\\tif(arr[1]==null) {\\n\\t\\tbuild();\\n\\t}\\n\\treturn getVal(n);\\n}\\n}\\n```\\n\\nUpdate : Faster than 100%\\n\\nNow along with computing binary string I added 3 line modification to calculate the answers as well. This makes the solution faster than 100% of the submissions, taking run time from 1600 ms to 24 ms\\n\\n![image](https://assets.leetcode.com/users/images/dcd46e72-933a-4e57-ad9c-cefbe6ef4e7e_1663896534.6957574.png)\\n\\nCode \\n\\nclass Solution {\\n    \\n    static String arr[] = new String[100001];\\n    \\n    static int ans[] = new int[100001];\\n    \\n    public void build() {\\n        for(int i=1; i<=100000; i++) {\\n            arr[i] = Integer.toBinaryString(i);\\n        }\\n    }\\n    \\n    int mod = 1000000007;\\n    \\n    public int getVal(int n) {\\n        int val = 0;\\n        for(int i=1; i<=n; i++) {\\n            for(int j=0; j<arr[i].length(); j++) {\\n                int x = arr[i].charAt(j)-\\'0\\';\\n                val = (val*2 + x)%mod;\\n            }\\n            ans[i] = val;\\n        }\\n        return val;\\n    }\\n    \\n    public int concatenatedBinary(int n) {\\n        if(arr[1]==null) {\\n            build();\\n            getVal(100000);\\n        }\\n        return ans[n];\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\nstatic String arr[] = new String[100001];\\n\\npublic void build() {\\n\\tfor(int i=1; i<=100000; i++) {\\n\\t\\tarr[i] = Integer.toBinaryString(i);\\n\\t}\\n}\\n\\nint mod = 1000000007;\\n\\npublic int getVal(int n) {\\n\\tint val = 0;\\n\\tfor(int i=1; i<=n; i++) {\\n\\t\\tfor(int j=0; j<arr[i].length(); j++) {\\n\\t\\t\\tint x = arr[i].charAt(j)-\\'0\\';\\n\\t\\t\\tval = (val*2 + x)%mod;\\n\\t\\t}\\n\\t}\\n\\treturn val;\\n}\\n\\npublic int concatenatedBinary(int n) {\\n\\tif(arr[1]==null) {\\n\\t\\tbuild();\\n\\t}\\n\\treturn getVal(n);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612180,
                "title": "100-faster-c-solution-24ms-runtime-10-lines-of-code",
                "content": "## Kindly Upvote \\uD83D\\uDC4D the solution if you like it...\\n\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        int next = 1, length = 1;\\n        long max_n = pow(10, 9) + 7, result = 0;\\n        for (int i = 0; i <= n; i++) {\\n            if (i == next) {\\n                next *= 2;\\n                length++;\\n            }\\n            \\n            result = (result * next + i) % max_n;\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n\\n## If you reached here and the solution worked for you please upvote its free \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        int next = 1, length = 1;\\n        long max_n = pow(10, 9) + 7, result = 0;\\n        for (int i = 0; i <= n; i++) {\\n            if (i == next) {\\n                next *= 2;\\n                length++;\\n            }\\n            \\n            result = (result * next + i) % max_n;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963886,
                "title": "the-o-log-n-log-n-you-need-to-know",
                "content": "The following is the `O(log(n) * log(n))` solution which is faster than the `O(n)` and can work for very large `n`.\\n```\\nMOD = pow(10, 9) + 7\\n\\ndef modInverse(n):\\n    return pow(n, MOD - 2, MOD)\\n\\ndef sumGeometricSeries(r, n):\\n    return (pow(r, n, MOD) - 1) * modInverse(r - 1)\\n\\ndef sumBinaryOfLength(n, r):\\n    res = pow(2, n - 1, MOD) * sumGeometricSeries(pow(2, n, MOD), r - pow(2, n - 1, MOD) + 1)\\n    res %= MOD\\n    res += (sumGeometricSeries(pow(2, n, MOD), r - pow(2, n - 1, MOD) + 1) - 1 - (r - pow(2, n - 1, MOD))) * modInverse(pow(2, n, MOD) - 1)\\n    return res % MOD\\n\\nclass Solution(object):\\n    def concatenatedBinary(self, n):\\n        curr_size = 1\\n        res = 0\\n        for b in range(n.bit_length(), 0, -1):\\n            res += sumBinaryOfLength(b, min(n, pow(2, b) - 1)) * curr_size\\n            res %= MOD\\n            curr_size *= pow(2, (min(n, pow(2, b) - 1) - pow(2, b - 1) + 1) * b, MOD)\\n            curr_size %= MOD\\n        return (res + MOD) % MOD\\n```",
                "solutionTags": [],
                "code": "```\\nMOD = pow(10, 9) + 7\\n\\ndef modInverse(n):\\n    return pow(n, MOD - 2, MOD)\\n\\ndef sumGeometricSeries(r, n):\\n    return (pow(r, n, MOD) - 1) * modInverse(r - 1)\\n\\ndef sumBinaryOfLength(n, r):\\n    res = pow(2, n - 1, MOD) * sumGeometricSeries(pow(2, n, MOD), r - pow(2, n - 1, MOD) + 1)\\n    res %= MOD\\n    res += (sumGeometricSeries(pow(2, n, MOD), r - pow(2, n - 1, MOD) + 1) - 1 - (r - pow(2, n - 1, MOD))) * modInverse(pow(2, n, MOD) - 1)\\n    return res % MOD\\n\\nclass Solution(object):\\n    def concatenatedBinary(self, n):\\n        curr_size = 1\\n        res = 0\\n        for b in range(n.bit_length(), 0, -1):\\n            res += sumBinaryOfLength(b, min(n, pow(2, b) - 1)) * curr_size\\n            res %= MOD\\n            curr_size *= pow(2, (min(n, pow(2, b) - 1) - pow(2, b - 1) + 1) * b, MOD)\\n            curr_size %= MOD\\n        return (res + MOD) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961983,
                "title": "javascript-solutions",
                "content": "```\\n/////////////////////////////// Solution 1 //////////////////////////////////\\n// 1260ms\\nconst mod = BigInt(1e9 + 7);\\nconst concatenatedBinary = (n) => {\\n    let res = 0n;\\n    let shift = 1n;\\n    for (let i = 1n; i <= n; i++) {\\n        if (i == (1n << shift)) shift++;\\n        res <<= shift;\\n        res += i;\\n        res %= mod;\\n    }\\n    return Number(res);\\n};\\n\\n// 664ms\\nconst MOD = 1e9 + 7;\\nconst concatenatedBinary = (n) => {\\n    let res = 0;\\n    let shift = 1;\\n    for (let i = 1; i <= n; i++) {\\n        if (i == (1 << shift)) shift++;\\n        res *= (2 ** shift); // difference, don\\'t know what the hack: res << shift cause Number overflow while res * (2 ** shift) not, both should work the same\\n        res += i;\\n        res %= MOD;\\n    }\\n    return res;\\n};\\n\\n\\n/////////////////////////////// Solution 2 //////////////////////////////////\\n// reference: https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/discuss/961350/C%2B%2B-O(N)-time-iterative\\n// 1396ms\\nconst mod = BigInt(1e9 + 7);\\nconst concatenatedBinary = (n) => {\\n    let res = 0n;\\n    for (let i = 1n, shift = 0n; i <= n; i++) {\\n        let singleBit = (i & (i - 1n)) == 0n;\\n        if (singleBit) shift++;\\n        res <<= shift;\\n        res += i;\\n        res %= mod;\\n    }\\n    return Number(res);\\n};\\n\\n// 672ms\\nconst MOD = 1e9 + 7;\\nconst concatenatedBinary = (n) => {\\n    let res = 0;\\n    for (let i = 1, shift = 0; i <= n; i++) {\\n        let singleBit = (i & (i - 1)) == 0;\\n        if (singleBit) shift++;\\n        res *= (2 ** shift); // difference\\n        res += i;\\n        res %= MOD;\\n    }\\n    return res;\\n};\\n\\n/////////////////////////////// Solution 3 //////////////////////////////////\\n// 2400ms\\nconst mod = 1e9 + 7;\\nconst concatenatedBinary = (n) => {\\n    let res = 0;\\n    for (let i = 1; i <= n; i++) {\\n        let bin = i.toString(2);\\n        let shift = bin.length;\\n        res *= (2 ** shift);\\n        res += i;\\n        res %= mod;\\n    }\\n    return res;\\n};\\n\\n/////////////////////////////// Solution 4 //////////////////////////////////\\n// 180ms\\nconst mod = 1e9 + 7;\\nconst concatenatedBinary = (n) => {\\n    let t = 2;\\n    let res = 0;\\n    for (let i = 1; i <= n; i++) {\\n        if (i == t) {\\n            t *= 2;\\n        }\\n        res = res * t + i;\\n        res %= mod;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/////////////////////////////// Solution 1 //////////////////////////////////\\n// 1260ms\\nconst mod = BigInt(1e9 + 7);\\nconst concatenatedBinary = (n) => {\\n    let res = 0n;\\n    let shift = 1n;\\n    for (let i = 1n; i <= n; i++) {\\n        if (i == (1n << shift)) shift++;\\n        res <<= shift;\\n        res += i;\\n        res %= mod;\\n    }\\n    return Number(res);\\n};\\n\\n// 664ms\\nconst MOD = 1e9 + 7;\\nconst concatenatedBinary = (n) => {\\n    let res = 0;\\n    let shift = 1;\\n    for (let i = 1; i <= n; i++) {\\n        if (i == (1 << shift)) shift++;\\n        res *= (2 ** shift); // difference, don\\'t know what the hack: res << shift cause Number overflow while res * (2 ** shift) not, both should work the same\\n        res += i;\\n        res %= MOD;\\n    }\\n    return res;\\n};\\n\\n\\n/////////////////////////////// Solution 2 //////////////////////////////////\\n// reference: https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/discuss/961350/C%2B%2B-O(N)-time-iterative\\n// 1396ms\\nconst mod = BigInt(1e9 + 7);\\nconst concatenatedBinary = (n) => {\\n    let res = 0n;\\n    for (let i = 1n, shift = 0n; i <= n; i++) {\\n        let singleBit = (i & (i - 1n)) == 0n;\\n        if (singleBit) shift++;\\n        res <<= shift;\\n        res += i;\\n        res %= mod;\\n    }\\n    return Number(res);\\n};\\n\\n// 672ms\\nconst MOD = 1e9 + 7;\\nconst concatenatedBinary = (n) => {\\n    let res = 0;\\n    for (let i = 1, shift = 0; i <= n; i++) {\\n        let singleBit = (i & (i - 1)) == 0;\\n        if (singleBit) shift++;\\n        res *= (2 ** shift); // difference\\n        res += i;\\n        res %= MOD;\\n    }\\n    return res;\\n};\\n\\n/////////////////////////////// Solution 3 //////////////////////////////////\\n// 2400ms\\nconst mod = 1e9 + 7;\\nconst concatenatedBinary = (n) => {\\n    let res = 0;\\n    for (let i = 1; i <= n; i++) {\\n        let bin = i.toString(2);\\n        let shift = bin.length;\\n        res *= (2 ** shift);\\n        res += i;\\n        res %= mod;\\n    }\\n    return res;\\n};\\n\\n/////////////////////////////// Solution 4 //////////////////////////////////\\n// 180ms\\nconst mod = 1e9 + 7;\\nconst concatenatedBinary = (n) => {\\n    let t = 2;\\n    let res = 0;\\n    for (let i = 1; i <= n; i++) {\\n        if (i == t) {\\n            t *= 2;\\n        }\\n        res = res * t + i;\\n        res %= mod;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 961547,
                "title": "c-simple-o-n-using-binary-length",
                "content": "```csharp\\npublic int ConcatenatedBinary(int n)\\n{\\n\\tlong result = 0;\\n\\tint MOD = (int)(1E9) + 7;\\n\\tint binaryLength = 0;\\n\\n\\tfor (int i = 1; i <= n; i++)\\n\\t{\\n\\t\\tif ((i & (i - 1)) == 0)\\n\\t\\t{\\n\\t\\t\\tbinaryLength++;\\n\\t\\t}\\n\\n\\t\\tresult = ((result << binaryLength) + i) % MOD;\\n\\t}\\n\\n\\treturn (int)(result % MOD); \\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int ConcatenatedBinary(int n)\\n{\\n\\tlong result = 0;\\n\\tint MOD = (int)(1E9) + 7;\\n\\tint binaryLength = 0;\\n\\n\\tfor (int i = 1; i <= n; i++)\\n\\t{\\n\\t\\tif ((i & (i - 1)) == 0)\\n\\t\\t{\\n\\t\\t\\tbinaryLength++;\\n\\t\\t}\\n\\n\\t\\tresult = ((result << binaryLength) + i) % MOD;\\n\\t}\\n\\n\\treturn (int)(result % MOD); \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 961469,
                "title": "c-easy-to-understand-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n\\t// get number of bits in a number\\n    int getBinary(int n) {\\n        int count = 0;\\n        while(n > 0) {\\n            n = n / 2;\\n            count++;\\n        }\\n        return count;\\n    }\\n    int concatenatedBinary(int n) {\\n        long long ans = 1;\\n        int mod = 1e9 + 7;\\n        for(int i = 2; i <= n; i++) {\\n            int  bits = getBinary(i);  // number of bits in i\\n            ans = ((ans << bits) % mod + i) % mod; // left shift the answer by number of bits and add current element into it\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// get number of bits in a number\\n    int getBinary(int n) {\\n        int count = 0;\\n        while(n > 0) {\\n            n = n / 2;\\n            count++;\\n        }\\n        return count;\\n    }\\n    int concatenatedBinary(int n) {\\n        long long ans = 1;\\n        int mod = 1e9 + 7;\\n        for(int i = 2; i <= n; i++) {\\n            int  bits = getBinary(i);  // number of bits in i\\n            ans = ((ans << bits) % mod + i) % mod; // left shift the answer by number of bits and add current element into it\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615081,
                "title": "asymptomatic-o-1-constant-time-solution-using-static",
                "content": "```\\nclass Solution {\\n    static final int N = 100001, mod = 1000000007;\\n    static int res[];\\n    Solution(){\\n        if(res==null){\\n            res=new int[N];\\n            for(int i=1,n=0,pow=1;i<N;i++){\\n                if(i==pow){\\n                    pow<<=1;\\n                    n++;\\n                }\\n                res[i]=(int)((((long)res[i-1]<<n)|i)%mod);\\n            }\\n        }\\n    }\\n    public int concatenatedBinary(int n) {\\n        return res[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static final int N = 100001, mod = 1000000007;\\n    static int res[];\\n    Solution(){\\n        if(res==null){\\n            res=new int[N];\\n            for(int i=1,n=0,pow=1;i<N;i++){\\n                if(i==pow){\\n                    pow<<=1;\\n                    n++;\\n                }\\n                res[i]=(int)((((long)res[i-1]<<n)|i)%mod);\\n            }\\n        }\\n    }\\n    public int concatenatedBinary(int n) {\\n        return res[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614165,
                "title": "python-very-easy-to-understand",
                "content": "**Complexity: time complexity is O(n), space is O(1).  **\\n\\nn=1  1\\nn=2  110\\nn=3  11011\\nn=4  11011100\\n\\nLet us try to find answer to n by using the value of n-1 \\n\\nn=3\\n\\nWe have to calculate the value of 3 (11011) by using the value of 2\\n n=2 (3-1) \\nvalue =110\\n\\nBinary of 3=11(length 2)\\nSo we multiply the initial value by 100 (1+ 2 zeroes)\\nvalue_3 = value_2 *(100) +3\\n\\t  110 * 100 + 11\\n\\t  11000 + 11\\n\\t  11011\\n\\n\\nSimilarly\\n\\nn=4\\nbinary of 4=100(lenth 3)\\nSo we multiply the initial value by 1000 (1+ 3 zeroes)\\nvalue_4 = value_3 *(1000) + 4\\n\\t 11011 * 1000  + 100\\n\\t 11011000  + 100\\n\\t 11011100\\n\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n):\\n        ans, M = 0, 10**9 + 7\\n        for x in range(1,n+1):\\n            ans= (ans*(1<<(len(bin(x))-2))+x)%M\\n        return ans\\n\\t\\t\\n```\\n\\t\\t\\n\\n# **Try to understand the below line:**\\n **ans= (ans*(1<<(len(bin(x))-2))+x)%M**\\n \\n1. Since we have to return modulus of 10^9 +7\\n\\tans= (-------) %M\\n\\t\\n2. We have to multiply the ans of previous value by power of 10 and have to add value of x\\n\\tans = ( ans*(----) + x) %M\\n\\t\\n3. left shift of integer easily give us the value like 10,100,1000,1000,...\\n\\tans= ( ans*(1<< (-------)) + x) %M\\n\\t\\n4. we have to do left shift of 1 by the binary length of x \\n\\tans= ( ans*(1<< (len(bin(x)) + x) %M\\n\\t\\n5. But the binary form of any number always start with 0B or 0b. So we have to reduce the lenth by 2\\n\\tans= ( ans*(1<< (len(bin(x))-2)) + x) %M\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n):\\n        ans, M = 0, 10**9 + 7\\n        for x in range(1,n+1):\\n            ans= (ans*(1<<(len(bin(x))-2))+x)%M\\n        return ans\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613843,
                "title": "python-simple-python-solution-using-bin-function",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 3110 ms, faster than 38.58% of Python3 online submissions for Concatenation of Consecutive Binary Numbers.\\n# Memory Usage: 15.9 MB, less than 22.05% of Python3 online submissions for Concatenation of Consecutive Binary Numbers.\\n\\n\\tclass Solution:\\n\\t\\tdef concatenatedBinary(self, n: int) -> int:\\n\\n\\t\\t\\tbinary = \\'\\'\\n\\n\\t\\t\\tfor num in range(1, n+1):\\n\\n\\t\\t\\t\\tbinary = binary + bin(num)[2:]\\n\\n\\t\\t\\tresult = int(binary, 2)\\n\\n\\t\\t\\treturn result % (10**9 + 7)\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 3110 ms, faster than 38.58% of Python3 online submissions for Concatenation of Consecutive Binary Numbers.\\n# Memory Usage: 15.9 MB, less than 22.05% of Python3 online submissions for Concatenation of Consecutive Binary Numbers.\\n\\n\\tclass Solution:\\n\\t\\tdef concatenatedBinary(self, n: int) -> int:\\n\\n\\t\\t\\tbinary = \\'\\'\\n\\n\\t\\t\\tfor num in range(1, n+1):\\n\\n\\t\\t\\t\\tbinary = binary + bin(num)[2:]\\n\\n\\t\\t\\tresult = int(binary, 2)\\n\\n\\t\\t\\treturn result % (10**9 + 7)\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2613567,
                "title": "go-bit-manipulation",
                "content": "Let\\'s say `n = 3`. To concatenate numbers 1, 2, 3 (binary: `1`, `10`, `11`), we do the following:\\n1. Add `1` to the result; `ans = 1`\\n2. Move the result two bits left to make a space for the next number; `ans = 100`\\n3. Add `10`; `ans = 110`\\n4. Move the result two more bits left; `ans = 11000`\\n5. Add `11`; `ans = 11011`.\\n \\nTo understand, how much do we need to move `ans` to the left, we create variable `power`, which is incremented every time when `i` is increased twice.\\n\\n```\\nfunc concatenatedBinary(n int) int {\\n    ans := 0\\n    threshold := 1\\n    power := 0\\n    for i := 1; i <= n; i++ {\\n        if i >= threshold {\\n            threshold = threshold << 1\\n            power += 1            \\n        }\\n        ans = (ans << power + i) % 1000000007\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunc concatenatedBinary(n int) int {\\n    ans := 0\\n    threshold := 1\\n    power := 0\\n    for i := 1; i <= n; i++ {\\n        if i >= threshold {\\n            threshold = threshold << 1\\n            power += 1            \\n        }\\n        ans = (ans << power + i) % 1000000007\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2613321,
                "title": "python-o-n-simple-solution",
                "content": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        arr = []\\n        \\n\\t\\t# append each binary to arr\\n        for i in range(1, n + 1):\\n            arr.append(bin(i)[2:])\\n            \\n        return int(\\'\\'.join(arr), 2) % (pow(10, 9) + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        arr = []\\n        \\n\\t\\t# append each binary to arr\\n        for i in range(1, n + 1):\\n            arr.append(bin(i)[2:])\\n            \\n        return int(\\'\\'.join(arr), 2) % (pow(10, 9) + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613049,
                "title": "python-bit-manipulation-o-n-easy-to-understand",
                "content": "suppose we have two integers A and B with binary(a1,a2,..,an) and (b1,b2,..,bm) and we need to add the binary of both the digits\\nthen what we can do is shift the bits of A to the left side m times which is the length of the second integer and add the second integer to the value  like : ` A<<m + B`\\n\\nfor example A = 1 and B = 2 the binary representaions will be 1 and 10\\nto add A and B binary strings we will have do a leftshift operation 2 times on 1(bin - 1) and the result will be 4(bin -100) and after that we will add 2 to the result that will  be 6(bin - 110)\\n\\nfor this particular problem we can keep track of number of digits in B like if B is a power of 2 then we will increase number of digits \\n\\nif a number n is a power of 2 then the value n&(n-1) will always be 0 because there will be no matching set bits in n and (n-1) numbers\\n\\n\\n\\n```\\n\\nclass Solution:    \\n    def concatenatedBinary(self, n: int) -> int:\\n\\t    mod = 10**9 + 7\\n        digitsToLeftShift = 1                                #  number of digits to leftshift\\n        curr = 1                                                   #  current value to return\\n        for i in range(2,n+1):\\n            if not i&(i-1):                                       #  if i is power of 2 then increment digits to leftshift\\n                digitsToLeftShift += 1\\n            curr = ((curr<<digitsToLeftShift) + i) % mod     # append the binary and assign to curr\\n        return curr\\n      \\n\\t \\n\\t Time Complexity : O(N)\\n\\t Space Complexity: O(1)\\n\\t \\n```\\n\\t \\n\\t \\n\\t \\n![image](https://assets.leetcode.com/users/images/ce9a97d0-3439-4c0f-99d2-34a368859233_1663915498.0950859.png)\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nclass Solution:    \\n    def concatenatedBinary(self, n: int) -> int:\\n\\t    mod = 10**9 + 7\\n        digitsToLeftShift = 1                                #  number of digits to leftshift\\n        curr = 1                                                   #  current value to return\\n        for i in range(2,n+1):\\n            if not i&(i-1):                                       #  if i is power of 2 then increment digits to leftshift\\n                digitsToLeftShift += 1\\n            curr = ((curr<<digitsToLeftShift) + i) % mod     # append the binary and assign to curr\\n        return curr\\n      \\n\\t \\n\\t Time Complexity : O(N)\\n\\t Space Complexity: O(1)\\n\\t \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612607,
                "title": "todays-solution",
                "content": "class Solution {\\n    public int concatenatedBinary(int n) {\\n        final long modulo = (long) (1e9 + 7);\\n        long result = 0;\\n        int binaryDigits = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if ((i & (i - 1)) == 0) binaryDigits++;\\n            result = ((result << binaryDigits) + i) % modulo;\\n        }\\n        return (int) result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int concatenatedBinary(int n) {\\n        final long modulo = (long) (1e9 + 7);\\n        long result = 0;\\n        int binaryDigits = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if ((i & (i - 1)) == 0) binaryDigits++;\\n            result = ((result << binaryDigits) + i) % modulo;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2612549,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Bit Manipulation***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        \\n        long long mod = 1e9 + 7;\\n        \\n        long long res = 0;\\n        \\n        for(int i = 1; i <= n; i++)\\n        {\\n            // find the length of curr num\\n            \\n            int len = 0;\\n            \\n            int num = i;\\n            \\n            while(num)\\n            {\\n                len++;\\n                \\n                num = num >> 1;\\n            }\\n            \\n            // left shift the res by len\\n            \\n            res = (res << len) % mod;\\n            \\n            // add the curr num to the res\\n            \\n            res = (res % mod + i % mod) % mod;\\n        }\\n        \\n        return res % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        \\n        long long mod = 1e9 + 7;\\n        \\n        long long res = 0;\\n        \\n        for(int i = 1; i <= n; i++)\\n        {\\n            // find the length of curr num\\n            \\n            int len = 0;\\n            \\n            int num = i;\\n            \\n            while(num)\\n            {\\n                len++;\\n                \\n                num = num >> 1;\\n            }\\n            \\n            // left shift the res by len\\n            \\n            res = (res << len) % mod;\\n            \\n            // add the curr num to the res\\n            \\n            res = (res % mod + i % mod) % mod;\\n        }\\n        \\n        return res % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612432,
                "title": "javascript-solution",
                "content": "```\\nvar concatenatedBinary = function(n) {\\n    let number = 0; \\n    for(let i = 1; i <= n; i++) {\\n        number *= (1 << i.toString(2).length)\\n        number += i;\\n        number %= (10 ** 9 + 7)\\n    }\\n    return number;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar concatenatedBinary = function(n) {\\n    let number = 0; \\n    for(let i = 1; i <= n; i++) {\\n        number *= (1 << i.toString(2).length)\\n        number += i;\\n        number %= (10 ** 9 + 7)\\n    }\\n    return number;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1038406,
                "title": "python-1-liner-solution",
                "content": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\\'\\'.join([str(bin(i))[2:] for i in range(1, n+1)]), 2)%(10**9+7)    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\\'\\'.join([str(bin(i))[2:] for i in range(1, n+1)]), 2)%(10**9+7)    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037271,
                "title": "rust-one-liner-solution",
                "content": "```rust\\nconst DIV: u64 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn concatenated_binary(n: i32) -> i32 {\\n        (2..=n).fold(1_u64, |acc, x| {\\n            ((acc << (32 - x.leading_zeros())) + x as u64) % DIV\\n        }) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nconst DIV: u64 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn concatenated_binary(n: i32) -> i32 {\\n        (2..=n).fold(1_u64, |acc, x| {\\n            ((acc << (32 - x.leading_zeros())) + x as u64) % DIV\\n        }) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 961628,
                "title": "go-o-n-with-explanation",
                "content": "The rule described means every time left-shift, then add the number\\n\\n```\\nnumber = 1, string = 1\\nnumber = 2, string left shift 2 bits = 100, adds number 2 becomes 110\\nnumber = 3, string left shift 2 bits = 11000, adds number 3 beomces 11011\\n...\\n```\\n\\nThe technique is to use bit-wise operation to find number of digits for the number, then do left-sift and add number. Also, add number mean bit-wise operation `or`.\\n\\nupdate at 1/28, original code find digits is not efficient, change to new one\\n\\n```golang\\nfunc concatenatedBinary(n int) int {\\n\\tnum, digits := 1, 1\\n\\tvar ans int\\n\\tmod := int(1e9 + 7)\\n\\n\\tfor ; num <= n; num++ {\\n        if num == 1 << digits {\\n\\t\\t\\tdigits++\\n\\t\\t}\\n\\n\\t\\tans = ans << digits\\n\\t\\tans |= num\\n\\n\\t\\tans = ans % mod\\n\\t}\\n\\n\\treturn ans\\n}\\n```\\n\\noriginal\\n\\n```golang\\nfunc concatenatedBinary(n int) int {\\n\\tmod := int64(1e9 + 7)\\n\\tvar ans int64\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tsize := digits(i)\\n\\t\\tans = ((ans << size) | int64(i)) % mod\\n\\t}\\n\\n\\treturn int(ans)\\n}\\n\\nfunc digits(i int) int {\\n\\tvar shift int\\n\\n\\tfor shift = 31; (1<<shift)&i == 0; shift-- {\\n\\t}\\n\\n\\treturn shift + 1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nnumber = 1, string = 1\\nnumber = 2, string left shift 2 bits = 100, adds number 2 becomes 110\\nnumber = 3, string left shift 2 bits = 11000, adds number 3 beomces 11011\\n...\\n```\n```golang\\nfunc concatenatedBinary(n int) int {\\n\\tnum, digits := 1, 1\\n\\tvar ans int\\n\\tmod := int(1e9 + 7)\\n\\n\\tfor ; num <= n; num++ {\\n        if num == 1 << digits {\\n\\t\\t\\tdigits++\\n\\t\\t}\\n\\n\\t\\tans = ans << digits\\n\\t\\tans |= num\\n\\n\\t\\tans = ans % mod\\n\\t}\\n\\n\\treturn ans\\n}\\n```\n```golang\\nfunc concatenatedBinary(n int) int {\\n\\tmod := int64(1e9 + 7)\\n\\tvar ans int64\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tsize := digits(i)\\n\\t\\tans = ((ans << size) | int64(i)) % mod\\n\\t}\\n\\n\\treturn int(ans)\\n}\\n\\nfunc digits(i int) int {\\n\\tvar shift int\\n\\n\\tfor shift = 31; (1<<shift)&i == 0; shift-- {\\n\\t}\\n\\n\\treturn shift + 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2615275,
                "title": "java-binary-strings-solution",
                "content": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int MOD = 1000000007;\\n        int res = 1;\\n        for (int i=2;i<=n;i++){\\n            String s = Integer.toBinaryString(i);\\n            for (char c: s.toCharArray()){\\n                res=(res*2+c-48)%MOD;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int MOD = 1000000007;\\n        int res = 1;\\n        for (int i=2;i<=n;i++){\\n            String s = Integer.toBinaryString(i);\\n            for (char c: s.toCharArray()){\\n                res=(res*2+c-48)%MOD;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614914,
                "title": "java-string-straight-forward-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        StringBuilder str = new StringBuilder();\\n        for(int i = 1; i <= n; i++)\\n            str.append(Integer.toBinaryString(i));\\n        int MAX = 1000000007;\\n        int res = 0;\\n        String s = str.reverse().toString();\\n        int c = 1;\\n        for(int i = 0; i < s.length(); i++){\\n            res += (s.charAt(i)-\\'0\\')*c;\\n            res %= MAX;\\n            c *= 2;\\n            c %= MAX;\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        StringBuilder str = new StringBuilder();\\n        for(int i = 1; i <= n; i++)\\n            str.append(Integer.toBinaryString(i));\\n        int MAX = 1000000007;\\n        int res = 0;\\n        String s = str.reverse().toString();\\n        int c = 1;\\n        for(int i = 0; i < s.length(); i++){\\n            res += (s.charAt(i)-\\'0\\')*c;\\n            res %= MAX;\\n            c *= 2;\\n            c %= MAX;\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614507,
                "title": "super-easy-c-one-liner-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long int ans=0;\\n        int i=1;\\n        while(i<=n){\\n            ans=((ans<<(1+int(log2(i))))%1000000007+i)%1000000007;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long int ans=0;\\n        int i=1;\\n        while(i<=n){\\n            ans=((ans<<(1+int(log2(i))))%1000000007+i)%1000000007;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613890,
                "title": "python-js-go-c-o-n-by-bit-operation-w-comment",
                "content": "Python/JS/Go/C++ O(n) by bit operation \\n\\n---\\n\\nDemonstration with n = 3\\n\\n1 = 0b 1\\n2 = 0b 10\\n3 = 0b 11\\n\\nConcatenation from 1 to 3 in binary = 0b 1 10 11 = 0b 11011 = 27 in decimal\\n\\n---\\n\\n**Implementation**:\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n\\n        constant = 10**9 + 7\\n        summation = 0\\n        bit_width = 0\\n        \\n        # iterate from 1 to n\\n        for i in range(1, n+1):\\n            \\n            # update binary bit width when we meet power of 2\\n            if i & i-1 == 0:\\n                bit_width += 1\\n            \\n            # use binary left rotation to implement concatenation\\n            summation = summation << bit_width\\n            \\n            # add with current number\\n            summation = summation | i\\n            \\n            # mod with constant defined by description\\n            summation %= constant\\n        \\n        return summation\\n```\\n\\n---\\n\\nJavascript\\n\\n```\\nvar concatenatedBinary = function(n) {\\n    \\n    const constant = 10**9 + 7;\\n    let summation = 0;\\n    let bit_width = 0;\\n\\n    // iterate from 1 to n\\n    for( let i = 1 ; i <= n ; i++ ){\\n\\n        // update binary bit width when we meet power of 2\\n        if( 0 == (i & i-1) ){\\n            bit_width += 1;\\n        }\\n\\n\\n        // use binary left rotation to implement concatenation\\n        summation = summation * (2 ** bit_width);\\n       \\n        // add with current number\\n        summation = summation + i;\\n\\n        // mod with constant defined by description\\n        summation = summation % constant;\\n    }\\n\\n    return summation;\\n        \\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nfunc concatenatedBinary(n int) int {\\n        \\n    const constant = int(1e9+7)\\n    summation := 0\\n    bit_width := 0\\n\\n    // iterate from 1 to n\\n    for i := 1 ; i <= n ; i++ {\\n\\n        // update binary bit width when we meet power of 2\\n        if 0 == (i & (i-1) ){\\n            bit_width += 1;\\n        }\\n\\n\\n        // use binary left rotation to implement concatenation\\n        summation = summation << bit_width;\\n       \\n        // add with current number\\n        summation = summation | i;\\n\\n        // mod with constant defined by description\\n        summation = summation % constant;\\n    }\\n\\n    return summation;\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n\\n        int constant = 1e9 + 7;\\n        long summation = 0;\\n        int bit_width = 0;\\n        \\n        // iterate from 1 to n\\n        for( int i = 1 ; i <= n ; i++ ){\\n            \\n            // update binary bit width when we meet power of 2\\n            if( 0 == (i & i-1) ){\\n                bit_width += 1;\\n            }\\n                \\n            \\n            // use binary left rotation to implement concatenation\\n            summation = summation << bit_width;\\n            \\n            // add with current number\\n            summation = summation | i;\\n            \\n            // mod with constant defined by description\\n            summation %= constant;\\n        }\\n        \\n        return int(summation);\\n        \\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n\\n        constant = 10**9 + 7\\n        summation = 0\\n        bit_width = 0\\n        \\n        # iterate from 1 to n\\n        for i in range(1, n+1):\\n            \\n            # update binary bit width when we meet power of 2\\n            if i & i-1 == 0:\\n                bit_width += 1\\n            \\n            # use binary left rotation to implement concatenation\\n            summation = summation << bit_width\\n            \\n            # add with current number\\n            summation = summation | i\\n            \\n            # mod with constant defined by description\\n            summation %= constant\\n        \\n        return summation\\n```\n```\\nvar concatenatedBinary = function(n) {\\n    \\n    const constant = 10**9 + 7;\\n    let summation = 0;\\n    let bit_width = 0;\\n\\n    // iterate from 1 to n\\n    for( let i = 1 ; i <= n ; i++ ){\\n\\n        // update binary bit width when we meet power of 2\\n        if( 0 == (i & i-1) ){\\n            bit_width += 1;\\n        }\\n\\n\\n        // use binary left rotation to implement concatenation\\n        summation = summation * (2 ** bit_width);\\n       \\n        // add with current number\\n        summation = summation + i;\\n\\n        // mod with constant defined by description\\n        summation = summation % constant;\\n    }\\n\\n    return summation;\\n        \\n};\\n```\n```\\nfunc concatenatedBinary(n int) int {\\n        \\n    const constant = int(1e9+7)\\n    summation := 0\\n    bit_width := 0\\n\\n    // iterate from 1 to n\\n    for i := 1 ; i <= n ; i++ {\\n\\n        // update binary bit width when we meet power of 2\\n        if 0 == (i & (i-1) ){\\n            bit_width += 1;\\n        }\\n\\n\\n        // use binary left rotation to implement concatenation\\n        summation = summation << bit_width;\\n       \\n        // add with current number\\n        summation = summation | i;\\n\\n        // mod with constant defined by description\\n        summation = summation % constant;\\n    }\\n\\n    return summation;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n\\n        int constant = 1e9 + 7;\\n        long summation = 0;\\n        int bit_width = 0;\\n        \\n        // iterate from 1 to n\\n        for( int i = 1 ; i <= n ; i++ ){\\n            \\n            // update binary bit width when we meet power of 2\\n            if( 0 == (i & i-1) ){\\n                bit_width += 1;\\n            }\\n                \\n            \\n            // use binary left rotation to implement concatenation\\n            summation = summation << bit_width;\\n            \\n            // add with current number\\n            summation = summation | i;\\n            \\n            // mod with constant defined by description\\n            summation %= constant;\\n        }\\n        \\n        return int(summation);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613324,
                "title": "python-elegant-short-one-line-reducing",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n*log(n))\\n    Memory: O(1)\\n    \"\"\"\\n\\n    MOD = 10 ** 9 + 7\\n\\n    def concatenatedBinary(self, n: int) -> int:\\n        return reduce(lambda x, y: ((x << y.bit_length()) | y) % self.MOD, range(1, n + 1))\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n*log(n))\\n    Memory: O(1)\\n    \"\"\"\\n\\n    MOD = 10 ** 9 + 7\\n\\n    def concatenatedBinary(self, n: int) -> int:\\n        return reduce(lambda x, y: ((x << y.bit_length()) | y) % self.MOD, range(1, n + 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613197,
                "title": "very-simple-code-bit-manu-c",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int mod = 1e9 + 7;\\n\\n    int concatenatedBinary(int n)\\n    {\\n        long long ans = 0;\\n        int i = 1;\\n\\n        while (i <= n)\\n        {\\n            int leftShift = log2(i) + 1;\\n            ans <<= leftShift;\\n            ans = (ans | i++) % mod;\\n        }\\n\\n        return (ans % mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int mod = 1e9 + 7;\\n\\n    int concatenatedBinary(int n)\\n    {\\n        long long ans = 0;\\n        int i = 1;\\n\\n        while (i <= n)\\n        {\\n            int leftShift = log2(i) + 1;\\n            ans <<= leftShift;\\n            ans = (ans | i++) % mod;\\n        }\\n\\n        return (ans % mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613168,
                "title": "simple-solution-python-bit-manipulation",
                "content": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        ans = \\'\\'\\n        for i in range(1, n + 1):\\n            ans += str(bin(i)[2:])\\n            \\n        return int(ans, 2) % ((10**9) + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        ans = \\'\\'\\n        for i in range(1, n + 1):\\n            ans += str(bin(i)[2:])\\n            \\n        return int(ans, 2) % ((10**9) + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613123,
                "title": "java-bit-manipulation",
                "content": "```\\n\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long ans = 0;\\n        int bit_count = 0;\\n        for(int i=1; i<=n; i++){\\n            if((i&(i-1))  == 0)\\n                bit_count++;\\n            \\n            ans = ((ans << bit_count) | i)%1000000007;\\n        }\\n        return (int)ans;\\n    }\\n}\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public int concatenatedBinary(int n) {\\n        long ans = 0;\\n        int bit_count = 0;\\n        for(int i=1; i<=n; i++){\\n            if((i&(i-1))  == 0)\\n                bit_count++;\\n            \\n            ans = ((ans << bit_count) | i)%1000000007;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2612987,
                "title": "java-100-fast-solution",
                "content": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        final long mod = (long)(1e9 + 7);\\n        long result = 0;\\n        int size = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            if((i & (i-1)) == 0)\\n            {\\n                size++;\\n            }\\n            result = ((result << size) | i)%mod;\\n        }\\n        \\n        return (int)result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        final long mod = (long)(1e9 + 7);\\n        long result = 0;\\n        int size = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            if((i & (i-1)) == 0)\\n            {\\n                size++;\\n            }\\n            result = ((result << size) | i)%mod;\\n        }\\n        \\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612731,
                "title": "java-solution-one-liner",
                "content": "1 Liner using Long.range and reduce\\n\\n```\\npublic int concatenatedBinary(int n) {\\n\\t\\treturn (int) LongStream.range(1, n + 1).reduce(0, (sum, i) -> (sum * (int) Math.pow(2, Long.toBinaryString(i).length()) + i) % 1_000_000_007);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int concatenatedBinary(int n) {\\n\\t\\treturn (int) LongStream.range(1, n + 1).reduce(0, (sum, i) -> (sum * (int) Math.pow(2, Long.toBinaryString(i).length()) + i) % 1_000_000_007);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2612660,
                "title": "concise-and-easy-js-solution-with-explanation-o-n",
                "content": "Main idea: What concatenating actually does is, to shift the origin values to the left and then plus the new values.\\n\\nFor example: 2 concat 3 = 10 concat 11 => 10 shift 2 bits then add 11 = 1011.\\n\\nAlso: \\n1. Shifting n bits is equal to mulitply by 2 ** n. \\n2. For i that 2 ** (n-1) <= i < 2 ** n we shift the same number of bits n.\\n\\nSo now the coding part becomes simple:\\n\\n```\\nvar concatenatedBinary = function(n) {\\n    let mod = 10 ** 9 + 7;\\n    let mul = 2;\\n    \\n    let ans = 1;\\n    for(let i = 2; i <= n; i++){\\n        if(i === mul) mul *= 2;\\n        ans = (ans * mul + i) % mod;\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar concatenatedBinary = function(n) {\\n    let mod = 10 ** 9 + 7;\\n    let mul = 2;\\n    \\n    let ans = 1;\\n    for(let i = 2; i <= n; i++){\\n        if(i === mul) mul *= 2;\\n        ans = (ans * mul + i) % mod;\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2612435,
                "title": "simple-python3-solution-o-n-log-n-time",
                "content": "***UPVOTE*** if it is helpfull\\n```\\n\\nclass Solution:\\n    def countBits(self,x):\\n        ab = 0\\n        while x:\\n            x >>= 1\\n            ab += 1\\n        return ab\\n    def concatenatedBinary(self, n: int) -> int:\\n        res = 0\\n        mod = 10**9 + 7\\n        for i in range(1, n+1):\\n            res = ((res << self.countBits(i)) + i) % mod\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def countBits(self,x):\\n        ab = 0\\n        while x:\\n            x >>= 1\\n            ab += 1\\n        return ab\\n    def concatenatedBinary(self, n: int) -> int:\\n        res = 0\\n        mod = 10**9 + 7\\n        for i in range(1, n+1):\\n            res = ((res << self.countBits(i)) + i) % mod\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612325,
                "title": "c-solution-easy-to-understand",
                "content": "\\t#Please upvote, It it is helpful :)\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint concatenatedBinary(int n) {\\n\\t\\t\\tlong long ans = 0;\\n\\t\\t\\tint M = 1e9+7;\\n\\t\\t\\tstring num = \"\";\\n\\t\\t\\t// concatinating the numbers\\n\\t\\t\\tfor(int i = n; i >= 1; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint t = i;\\n\\t\\t\\t\\twhile(t)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnum += t%2 + \\'0\\';\\n\\t\\t\\t\\t\\tt /= 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// evaluating num\\n\\t\\t\\tint pow = 1;\\n\\t\\t\\tfor(int i = 0; i < num.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong long t = (num[i]-\\'0\\')*pow;\\n\\t\\t\\t\\tpow *= 2;\\n\\t\\t\\t\\tpow %= M;\\n\\t\\t\\t\\tans += t;\\n\\t\\t\\t\\tans %= M;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans%M;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint concatenatedBinary(int n) {\\n\\t\\t\\tlong long ans = 0;\\n\\t\\t\\tint M = 1e9+7;\\n\\t\\t\\tstring num = \"\";\\n\\t\\t\\t// concatinating the numbers\\n\\t\\t\\tfor(int i = n; i >= 1; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint t = i;\\n\\t\\t\\t\\twhile(t)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnum += t%2 + \\'0\\';\\n\\t\\t\\t\\t\\tt /= 2;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2612274,
                "title": "java-easy-and-short-solution",
                "content": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long res = 0;\\n        int m = 1000000007;\\n        for(int i=1;i<=n;i++){\\n           String s = Integer.toBinaryString(i);\\n            res = (res << s.length() ) %m;\\n            res = (res+i)%m;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long res = 0;\\n        int m = 1000000007;\\n        for(int i=1;i<=n;i++){\\n           String s = Integer.toBinaryString(i);\\n            res = (res << s.length() ) %m;\\n            res = (res+i)%m;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612159,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int mod=1e9+7;\\n    int concatenatedBinary(int n) {\\n        long long int ans=0;\\n        for(long long int i=1;i<=n;i++)\\n        {\\n            ans=(ans<<(long long int)(log2(i)+1))%mod;\\n            ans=(ans+i)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int mod=1e9+7;\\n    int concatenatedBinary(int n) {\\n        long long int ans=0;\\n        for(long long int i=1;i<=n;i++)\\n        {\\n            ans=(ans<<(long long int)(log2(i)+1))%mod;\\n            ans=(ans+i)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284280,
                "title": "using-long-easy-logic-without-need-of-explanation",
                "content": "```\\nclass Solution {\\n\\tpublic int concatenatedBinary(int n) {\\n\\t\\tlong res = 0;\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tres = (res * (int) Math.pow(2, Integer.toBinaryString(i).length()) + i) % 1000000007;\\n\\t\\t}\\n\\t\\treturn (int) res;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int concatenatedBinary(int n) {\\n\\t\\tlong res = 0;\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tres = (res * (int) Math.pow(2, Integer.toBinaryString(i).length()) + i) % 1000000007;\\n\\t\\t}\\n\\t\\treturn (int) res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940790,
                "title": "python-o-n-pure-bit-manipulation-without-strings-explanation",
                "content": "Concatenation in binary is analagous to shifting left the overall result by the amount of bits necessary to store the next number to concatenate and then summing the value. For example:\\n```\\nresult= 1 = 0b1\\nnext_number = 2 = 0b10\\n\\nresult << 2 => result = 0b100\\nresult = result + next_number = 0b100 + 0b10 = 0b110\\n```\\n\\n```python\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        result = 0\\n        MOD = (10**9 + 7)\\n        L = 0\\n        for num in range(1, n + 1):\\n            # Reached a new length. e.g. 1, 10, 100, 1000, etc...\\n            # We could also compute the length for every number as math.floor(math.log2(num) + 1)\\n            # As per https://en.wikipedia.org/wiki/Bit-length\\n            if (num & (num - 1)) == 0:\\n                L += 1\\n            result = ((result << L) + num) % MOD\\n        return result\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nresult= 1 = 0b1\\nnext_number = 2 = 0b10\\n\\nresult << 2 => result = 0b100\\nresult = result + next_number = 0b100 + 0b10 = 0b110\\n```\n```python\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        result = 0\\n        MOD = (10**9 + 7)\\n        L = 0\\n        for num in range(1, n + 1):\\n            # Reached a new length. e.g. 1, 10, 100, 1000, etc...\\n            # We could also compute the length for every number as math.floor(math.log2(num) + 1)\\n            # As per https://en.wikipedia.org/wiki/Bit-length\\n            if (num & (num - 1)) == 0:\\n                L += 1\\n            result = ((result << L) + num) % MOD\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212044,
                "title": "c-faster-than-99-37",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint concatenatedBinary(int n) {\\n\\t\\tint64_t ans = 0;\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tint bits = 32 - __builtin_clz(i);\\n\\t\\t\\tans = (ans << bits | i) % 1\\'000\\'000\\'007;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint concatenatedBinary(int n) {\\n\\t\\tint64_t ans = 0;\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tint bits = 32 - __builtin_clz(i);\\n\\t\\t\\tans = (ans << bits | i) % 1\\'000\\'000\\'007;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037956,
                "title": "c-easy-and-simple-bit-manipulation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int concatenatedBinary(int n) {\\n        long long int result=1;\\n        int total_bits=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            total_bits =  (int)log2(i)+1;\\n            result= (result<< total_bits) +i;\\n            if(result>INT_MAX)\\n                result= result%1000000007;\\n            \\n        }\\n        return result%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int concatenatedBinary(int n) {\\n        long long int result=1;\\n        int total_bits=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            total_bits =  (int)log2(i)+1;\\n            result= (result<< total_bits) +i;\\n            if(result>INT_MAX)\\n                result= result%1000000007;\\n            \\n        }\\n        return result%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037953,
                "title": "c-o-n-fast-and-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int concatenatedBinary(int n) {\\n        long long int result=1;\\n        int total_bits=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            total_bits =  (int)log2(i)+1;\\n            result= (result<< total_bits) +i;\\n            if(result>INT_MAX)\\n                result= result%1000000007;\\n            \\n        }\\n        return result%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int concatenatedBinary(int n) {\\n        long long int result=1;\\n        int total_bits=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            total_bits =  (int)log2(i)+1;\\n            result= (result<< total_bits) +i;\\n            if(result>INT_MAX)\\n                result= result%1000000007;\\n            \\n        }\\n        return result%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037831,
                "title": "cpp-recursion-easy-to-understand-with-explanation",
                "content": "We will be using recursion to solve this question. Assume that we have an answer till `n-1` returned by the recursive function. We store this in the `temp` variable. \\n\\nNow, from this `temp`, we need to calculate the final answer for the given `n`.\\n\\n* Shift the answer returned for `n-1` (stored in `temp`) by the number of bits to represent `n`.\\n* Add `n` to that.\\n* Return (with mod `1000000007`)\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    unsigned int helper(unsigned int n) \\n    { \\n       unsigned int count = 0; \\n       while (n) \\n       { \\n            count++; \\n            n >>= 1; \\n        } \\n        return count; \\n    } \\n    \\n    int concatenatedBinary(int n) {\\n        if (n == 1){\\n            return 1;\\n        }\\n        \\n        long temp = concatenatedBinary(n-1);\\n        \\n        return ((temp<<helper(n)) + n)%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    unsigned int helper(unsigned int n) \\n    { \\n       unsigned int count = 0; \\n       while (n) \\n       { \\n            count++; \\n            n >>= 1; \\n        } \\n        return count; \\n    } \\n    \\n    int concatenatedBinary(int n) {\\n        if (n == 1){\\n            return 1;\\n        }\\n        \\n        long temp = concatenatedBinary(n-1);\\n        \\n        return ((temp<<helper(n)) + n)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037641,
                "title": "python-simple-solution-casting-of-types-using-built-ins",
                "content": "Approach: Convert int to binary (string to join) and then back to int.\\n\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        binaryString = \"\" #our result in form of a string\\n        for i in range(1,n+1):\\n            #cast integer i into binary, and then to string, and remove the \"0b\" component in the front\\n            binaryString += str(bin(i))[2:]\\n        #cast from binary to integer\\n        decimal = int(binaryString, 2)\\n\\n        return decimal % 1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        binaryString = \"\" #our result in form of a string\\n        for i in range(1,n+1):\\n            #cast integer i into binary, and then to string, and remove the \"0b\" component in the front\\n            binaryString += str(bin(i))[2:]\\n        #cast from binary to integer\\n        decimal = int(binaryString, 2)\\n\\n        return decimal % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037587,
                "title": "python-straightforward",
                "content": "This is straightforward but non-optimal solution. Luckily it can pass when I did for the daily chanllenge. \\nAfter reading the LC solution, I realilze this might be one advantange of Python, and the Math solution might be what the problem wants to test ...\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        res = \\'\\'\\n        \\n        for i in range(1, n+1):\\n            res += bin(i)[2:]\\n        \\n        \\n        return int(res,2) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        res = \\'\\'\\n        \\n        for i in range(1, n+1):\\n            res += bin(i)[2:]\\n        \\n        \\n        return int(res,2) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037513,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        \\n        int mod = 1000000007;\\n        int num = 0;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            String binaryRep = Integer.toBinaryString(i);\\n            \\n            for(char ch:binaryRep.toCharArray())\\n            {\\n                int val = (ch==\\'0\\')?0:1;\\n                \\n                num = ((num*2)%mod + val)%mod;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        \\n        int mod = 1000000007;\\n        int num = 0;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            String binaryRep = Integer.toBinaryString(i);\\n            \\n            for(char ch:binaryRep.toCharArray())\\n            {\\n                int val = (ch==\\'0\\')?0:1;\\n                \\n                num = ((num*2)%mod + val)%mod;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037339,
                "title": "python-using-bin-and-int-functions",
                "content": "\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        stp = \"\"\\n        for i in range(0, n+1):\\n            stp +=bin(i)[2:]\\n        return int(stp, 2) % (10**9 + 7)\\n```\\n\\nUpdated Code :\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        stp = []\\n        for i in range(0, n+1):\\n            stp.append(bin(i)[2:])\\n        stp = \"\".join(stp)\\n        return int(stp, 2) % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        stp = \"\"\\n        for i in range(0, n+1):\\n            stp +=bin(i)[2:]\\n        return int(stp, 2) % (10**9 + 7)\\n```\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        stp = []\\n        for i in range(0, n+1):\\n            stp.append(bin(i)[2:])\\n        stp = \"\".join(stp)\\n        return int(stp, 2) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037306,
                "title": "concatenation-of-consecutive-binary-numbers-python-one-liner",
                "content": "You can use `bin(integer)[2:]` or `format(integer, \\'b\\')` or `f\\'{integer:b}\\'` to get binary string. Then convert it back to `int` from `binary` by `int(string, 2)`.\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\\'\\'.join([format(x, \\'b\\') for x in range(1, n + 1)]), 2) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\\'\\'.join([format(x, \\'b\\') for x in range(1, n + 1)]), 2) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037258,
                "title": "c-easy-to-understand-included-comments-in-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long  int M = 1000000007;//modulo operator\\n      long long  int d1=0,res;\\n        for(long long int i=1;i<=n;i++){\\n            d1=((d1<<(int(log2(i))+1))%M+i)%M;//shifting the bits to left side \\n           \\n            \\n        }\\n      \\n     \\n        return d1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long  int M = 1000000007;//modulo operator\\n      long long  int d1=0,res;\\n        for(long long int i=1;i<=n;i++){\\n            d1=((d1<<(int(log2(i))+1))%M+i)%M;//shifting the bits to left side \\n           \\n            \\n        }\\n      \\n     \\n        return d1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965373,
                "title": "c-o-nlogn-simple-solution",
                "content": "```\\n    #define mod 1000000007\\nint concatenatedBinary(int n) \\n{\\n\\tlong ret=0,p=1;\\n\\tfor(int i=n;i>=1;--i)\\n\\t{\\n\\t\\tint temp=i;\\n\\t\\twhile(temp)\\n\\t\\t{\\n\\t\\t\\tret+=(temp&1)*p;\\n\\t\\t\\ttemp/=2;\\n\\t\\t\\tp*=2;   \\n\\t\\t\\tp%=mod;\\n\\t\\t\\tret%=mod;\\n\\t\\t}\\n\\t}\\n\\treturn ret;\\n}\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    #define mod 1000000007\\nint concatenatedBinary(int n) \\n{\\n\\tlong ret=0,p=1;\\n\\tfor(int i=n;i>=1;--i)\\n\\t{\\n\\t\\tint temp=i;\\n\\t\\twhile(temp)\\n\\t\\t{\\n\\t\\t\\tret+=(temp&1)*p;\\n\\t\\t\\ttemp/=2;\\n\\t\\t\\tp*=2;   \\n\\t\\t\\tp%=mod;\\n\\t\\t\\tret%=mod;\\n\\t\\t}\\n\\t}\\n\\treturn ret;\\n}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 962240,
                "title": "simple-recursive-1-line-c-python-solution",
                "content": "The idea is to use a simple formula:\\n**a(n) = a(n-1) * 2^(1 + floor(log2(n))) + n**\\n**C++:** \\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int concatenatedBinary(int n) {\\n        return (n == 1) ? 1 : (concatenatedBinary(n - 1) * (long)(pow(2, 1 + (int)log2(n))) + n) % mod;\\n    }\\n};\\n```\\n**PS:** The declaration line of mod can be removed and it can be directly placed in the return statement of the function.\\n\\n**Python:**\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return 1 if n == 1 else (self.concatenatedBinary(n - 1) * int(math.pow(2, 1 + int(math.log2(n)))) + n) % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int concatenatedBinary(int n) {\\n        return (n == 1) ? 1 : (concatenatedBinary(n - 1) * (long)(pow(2, 1 + (int)log2(n))) + n) % mod;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return 1 if n == 1 else (self.concatenatedBinary(n - 1) * int(math.pow(2, 1 + int(math.log2(n)))) + n) % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962051,
                "title": "python-4-line-solution-easy",
                "content": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        result = \"\"\\n        for i in range(1, n+1):\\n            result = result + bin(i)[2:]\\n        return int(result , 2) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        result = \"\"\\n        for i in range(1, n+1):\\n            result = result + bin(i)[2:]\\n        return int(result , 2) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961968,
                "title": "easy-solution-with-explanation-c",
                "content": "let\\'s take an example \\n**n = 3**\\n\\n**Intially ans = 1;**\\n\\n\\n**for i --> 2**\\n\\tnumber of bits in 2 is 2;\\n\\tshift answer by number of bits i.e. 2 ans add i\\n\\tans = 1 << 2 + 2\\n\\t\\t= 6\\n\\n**for i --> 3**\\n\\tnumber of bits in 3 is 2;\\n\\tshift answer by number of bits i.e. 2 ans add i\\n\\tans = 6 << 2 + 3\\n\\t\\t= 27\\n\\n**so, answer is 27.**\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long ans = 1;\\n        int mod = 1e9 + 7;\\n        for(int i = 2; i <= n; i++) {\\n            int bits = (int)log2(i)+1;  // count number of bits in i\\n            ans = ((ans << bits) % mod + i) % mod; // left shift current ans by number of bits in i and current element to ans.\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long ans = 1;\\n        int mod = 1e9 + 7;\\n        for(int i = 2; i <= n; i++) {\\n            int bits = (int)log2(i)+1;  // count number of bits in i\\n            ans = ((ans << bits) % mod + i) % mod; // left shift current ans by number of bits in i and current element to ans.\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961818,
                "title": "c-simple-o-nlogn-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int concatenatedBinary(int n) \\n    {\\n        long long mod=1e9+7;\\n        long long sum=0,mul=1;\\n        for(int i=n;i>0;i--)\\n        {\\n            int k=i;\\n            while(k>0)\\n            {\\n                sum=sum+(mul*(k%2))%mod;\\n                k=k/2;\\n                mul=(mul*2)%mod;\\n            }\\n        }\\n        return sum%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int concatenatedBinary(int n) \\n    {\\n        long long mod=1e9+7;\\n        long long sum=0,mul=1;\\n        for(int i=n;i>0;i--)\\n        {\\n            int k=i;\\n            while(k>0)\\n            {\\n                sum=sum+(mul*(k%2))%mod;\\n                k=k/2;\\n                mul=(mul*2)%mod;\\n            }\\n        }\\n        return sum%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961456,
                "title": "python-o-n-100-faster-easy-to-understand",
                "content": "```\\n#Try to understand this without using any Brute-force approach. (Its Competitive Programming, Learn as much as you can) :-)\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        l,ans =0,0\\n        for i in range(1,n+1):    \\n            if i & (i - 1) == 0:\\n                l+=1\\n            ans=((ans <<l)|i)%(10**9+7)\\n        return(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n#Try to understand this without using any Brute-force approach. (Its Competitive Programming, Learn as much as you can) :-)\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        l,ans =0,0\\n        for i in range(1,n+1):    \\n            if i & (i - 1) == 0:\\n                l+=1\\n            ans=((ans <<l)|i)%(10**9+7)\\n        return(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961455,
                "title": "python-using-bin-and-int-function",
                "content": "**Easy to understand and using bin() and int() functions**\\n*Simple python3 solution*\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        b, m = [], (10 ** 9) + 7\\n        for i in range(1, n + 1):\\n            s = bin(i)\\n            b.append(s[2:])\\n        s = \\'\\'.join(b)\\n        return int(s, 2) % m\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        b, m = [], (10 ** 9) + 7\\n        for i in range(1, n + 1):\\n            s = bin(i)\\n            b.append(s[2:])\\n        s = \\'\\'.join(b)\\n        return int(s, 2) % m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961424,
                "title": "java-clean-o-n-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int concatenatedBinary(int n) {\\n\\t\\t\\tlong size = 0, result = 0;\\n\\n\\t\\t\\tint ma = (int)1e9+7;\\n\\n\\t\\t\\tfor(int i = 1;i<=n;i++) {\\n\\t\\t\\t\\tif((i&(i-1)) == 0) size++;\\n\\n\\t\\t\\t\\tresult = ((result << size) | i)%ma;\\n\\t\\t\\t}\\n\\t\\t\\treturn (int)result;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int concatenatedBinary(int n) {\\n\\t\\t\\tlong size = 0, result = 0;\\n\\n\\t\\t\\tint ma = (int)1e9+7;\\n\\n\\t\\t\\tfor(int i = 1;i<=n;i++) {\\n\\t\\t\\t\\tif((i&(i-1)) == 0) size++;\\n\\n\\t\\t\\t\\tresult = ((result << size) | i)%ma;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 961397,
                "title": "brute-force-works",
                "content": "```\\ndef d(n):  \\n    return bin(n).replace(\"0b\", \"\") \\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        a=\"\"\\n        for i in range(1,n+1):\\n            a+=d(i)\\n        return int(a,2)%(pow(10,9)+7)\\n```\\n\\nNo idea whats the point of this question?",
                "solutionTags": [],
                "code": "```\\ndef d(n):  \\n    return bin(n).replace(\"0b\", \"\") \\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        a=\"\"\\n        for i in range(1,n+1):\\n            a+=d(i)\\n        return int(a,2)%(pow(10,9)+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961376,
                "title": "javascript-solution",
                "content": "\\tvar concatenatedBinary = function(n) {\\n\\t\\tconst mod = 1000000007;\\n\\t\\tlet len = 1, num = 0;\\n\\n\\t\\tfor (let i = 1; i <= n; i++) {\\n\\t\\t\\tfor (let j = 0; j < len; j++) {\\n\\t\\t\\t\\t num = (num << 1) % mod;\\n\\t\\t\\t}\\n\\n\\t\\t\\tnum = (num + i) % mod;\\n\\n\\t\\t\\tif (((i+1) & i) === 0) {\\n\\t\\t\\t\\tlen++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn num;\\n\\t};\\n\\n\\t/*\\n\\t  1  10  11  100 101 110 111 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111\\n\\n\\t  1  6   27  220 \\n\\t*/",
                "solutionTags": [],
                "code": "\\tvar concatenatedBinary = function(n) {\\n\\t\\tconst mod = 1000000007;\\n\\t\\tlet len = 1, num = 0;\\n\\n\\t\\tfor (let i = 1; i <= n; i++) {\\n\\t\\t\\tfor (let j = 0; j < len; j++) {\\n\\t\\t\\t\\t num = (num << 1) % mod;\\n\\t\\t\\t}\\n\\n\\t\\t\\tnum = (num + i) % mod;\\n\\n\\t\\t\\tif (((i+1) & i) === 0) {\\n\\t\\t\\t\\tlen++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn num;\\n\\t};\\n\\n\\t/*\\n\\t  1  10  11  100 101 110 111 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111\\n\\n\\t  1  6   27  220 \\n\\t*/",
                "codeTag": "Unknown"
            },
            {
                "id": 961371,
                "title": "python3-1-line",
                "content": "**Algo**\\nScan from `1` to `n` and concatenate their binary representation together. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\"\".join(bin(i)[2:] for i in range(1, n+1)), 2) % 1_000_000_007\\n```\\n\\nEdited on 12/08/2020\\nA more reasonable approach is given below. \\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        ans = k = 0\\n        for x in range(1, n+1): \\n            if not x & x-1: k += 1\\n            ans = ((ans << k) + x) % 1_000_000_007\\n        return ans \\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\"\".join(bin(i)[2:] for i in range(1, n+1)), 2) % 1_000_000_007\\n```\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        ans = k = 0\\n        for x in range(1, n+1): \\n            if not x & x-1: k += 1\\n            ans = ((ans << k) + x) % 1_000_000_007\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871440,
                "title": "easy-java-solution-using-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // coppied (Bit manupulation)\\n    public int concatenatedBinary(int n) {\\n        int mod = 1000000007;\\n        \\n        long ans =0;\\n        for(int i=1; i<=n; i++){\\n            ans = (((ans<<(1+(int)(Math.log(i) / Math.log(2))))%mod)+i)%mod;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // coppied (Bit manupulation)\\n    public int concatenatedBinary(int n) {\\n        int mod = 1000000007;\\n        \\n        long ans =0;\\n        for(int i=1; i<=n; i++){\\n            ans = (((ans<<(1+(int)(Math.log(i) / Math.log(2))))%mod)+i)%mod;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795168,
                "title": "c-clear-and-smart-brute-force-solution",
                "content": "# Intuition\\nThis a brute force solution but with good optimization.\\n\\n# Approach\\nSo solve this problem for n = 3. if n = 3 then our concatenated string s = 11011. if s is a string then the result will be for each i res += s[i] * 2 ^ (n - i - 1). So my code is the same logic but I started counting from the end \\'cause when I count from the end I don\\'t need calculate 2 power of i I just multiply current pow to 2 and MOD it.\\n\\n# Complexity\\n- Time complexity:\\nO(20 * n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using i64 = long long;\\n\\n    const int mod = 1e9 + 7;\\n\\n    int concatenatedBinary(int n) {\\n        int res = 0, cur = 1;\\n        \\n        for (int i = n; i > 0; i--) {\\n            int x = i;\\n            while (x > 0) {\\n                if (x & 1) {\\n                    res = (res + cur) % mod;\\n                }\\n                cur = (cur * 2) % mod;\\n                x /= 2;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using i64 = long long;\\n\\n    const int mod = 1e9 + 7;\\n\\n    int concatenatedBinary(int n) {\\n        int res = 0, cur = 1;\\n        \\n        for (int i = n; i > 0; i--) {\\n            int x = i;\\n            while (x > 0) {\\n                if (x & 1) {\\n                    res = (res + cur) % mod;\\n                }\\n                cur = (cur * 2) % mod;\\n                x /= 2;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325772,
                "title": "simplest-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        res = \"\"\\n        for x in range(1, n+1):\\n            res += bin(x)[2:]\\n        return int(res, 2) % (10**9+7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        res = \"\"\\n        for x in range(1, n+1):\\n            res += bin(x)[2:]\\n        return int(res, 2) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658623,
                "title": "python-solution-bitwise-left-shift-o-n-explaination",
                "content": "```\\n# Every time the earlier bits gonna shifted towards left side \\n# & left shift = multiply by 2\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        num = 1\\n        for i in range(2, n+1):\\n            num = ((num << i.bit_length()) + i) % (10**9 + 7)\\n        return num\\n            \\n```",
                "solutionTags": [],
                "code": "```\\n# Every time the earlier bits gonna shifted towards left side \\n# & left shift = multiply by 2\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        num = 1\\n        for i in range(2, n+1):\\n            num = ((num << i.bit_length()) + i) % (10**9 + 7)\\n        return num\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2638924,
                "title": "c-o-n",
                "content": "Here We Use the Logic:\\nSuppose we have n=3\\nSo,  we can express it as Sum of 1* 2^4 + 2* 2^2 + 3* 2^0 =27\\nThe Powers of 2 as we go left in the Sum is just the addition of log base 2 of later numbers added with 1\\nAfter that it\\'s just normal modulo arithmetic\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) \\n    {\\n        long long int ans=0;\\n        int M=pow(10,9)+7;\\n        long long int raise=1;\\n        int LOG;\\n        while(n>0)\\n        {\\n            ans=((ans%M)+((n%M)*(raise))%M)%M;\\n            LOG=log(n)/log(2);\\n            LOG++;\\n            LOG=pow(2,LOG);\\n            raise=((raise%M)*(LOG%M))%M;\\n            n--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) \\n    {\\n        long long int ans=0;\\n        int M=pow(10,9)+7;\\n        long long int raise=1;\\n        int LOG;\\n        while(n>0)\\n        {\\n            ans=((ans%M)+((n%M)*(raise))%M)%M;\\n            LOG=log(n)/log(2);\\n            LOG++;\\n            LOG=pow(2,LOG);\\n            raise=((raise%M)*(LOG%M))%M;\\n            n--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618852,
                "title": "easy-optimized-short-c-solution",
                "content": "class Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        \\n        int dig=1;\\n        long long res=1;\\n        for(int i=2; i<=n; i++)\\n        {\\n            if(i>=pow(2, dig)) dig++;\\n            res=res<<dig;\\n            res+=i;\\n            res=res%1000000007;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        \\n        int dig=1;\\n        long long res=1;\\n        for(int i=2; i<=n; i++)\\n        {\\n            if(i>=pow(2, dig)) dig++;\\n            res=res<<dig;\\n            res+=i;\\n            res=res%1000000007;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2616510,
                "title": "concatenation-of-consecutive-binary-numbers",
                "content": "class Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        ans,lft=0,0\\n**        # modulo = 1000000007\\n**        #iterate through n\\n        for i in range(1,n+1):\\n            if i & (i-1) == 0:\\n                lft += 1\\n                #here we use left shift operator to get our result\\n            ans = ((ans << lft)| i) % (10 ** 9 + 7)\\n        return ans\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        ans,lft=0,0\\n**        # modulo = 1000000007\\n**        #iterate through n\\n        for i in range(1,n+1):\\n            if i & (i-1) == 0:\\n                lft += 1\\n                #here we use left shift operator to get our result\\n            ans = ((ans << lft)| i) % (10 ** 9 + 7)\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 2615468,
                "title": "detailed-commented-solution-with-steps-0-n-time-c",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    step 1: initilize ans = 1;\\n    step 2: make a function to count the leftmostsetbit in a number coz this will tell us to shift the number to the left as new numbers are comming to add\\n    step 3: now add the number in the shifted value\\n    12 will be like\\n    1 -> \"1\"\\n    2 ->\" 10 \" so ans = (1<<2) + 2\\n    3-> \"11\" so ans =  (ans <<2) + 3\\n    and so on\\n    \\n    \\n    */\\n    const long long int mod = 1e9+7;\\n    int leftmostSetBit(int n){\\n        int pos = 0;\\n        while(n>0){\\n            n = n>>1; // do the right shift untill the number is zero\\n            pos++;\\n        }\\n        return pos;\\n    }\\n    int concatenatedBinary(int n) {\\n        // 12 ka \\n        long long int ans = 1;\\n        int siz = leftmostSetBit(n);\\n        int t = n;\\n        for(int i = 2;i<=n;i++){\\n            int s = leftmostSetBit(i);\\n            ans = ((ans<<s)+i)%mod;// leftShift of Negative values\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    step 1: initilize ans = 1;\\n    step 2: make a function to count the leftmostsetbit in a number coz this will tell us to shift the number to the left as new numbers are comming to add\\n    step 3: now add the number in the shifted value\\n    12 will be like\\n    1 -> \"1\"\\n    2 ->\" 10 \" so ans = (1<<2) + 2\\n    3-> \"11\" so ans =  (ans <<2) + 3\\n    and so on\\n    \\n    \\n    */\\n    const long long int mod = 1e9+7;\\n    int leftmostSetBit(int n){\\n        int pos = 0;\\n        while(n>0){\\n            n = n>>1; // do the right shift untill the number is zero\\n            pos++;\\n        }\\n        return pos;\\n    }\\n    int concatenatedBinary(int n) {\\n        // 12 ka \\n        long long int ans = 1;\\n        int siz = leftmostSetBit(n);\\n        int t = n;\\n        for(int i = 2;i<=n;i++){\\n            int s = leftmostSetBit(i);\\n            ans = ((ans<<s)+i)%mod;// leftShift of Negative values\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615104,
                "title": "python-bitwise-solution-o-1-space-complexity-o-n-time-complexity",
                "content": "```\\n\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        m=\"\"\\n        for i in range(1, (n+1)):\\n            a = bin(i)\\n            m += a[2:]\\n        m = int(m,2)\\n        \\n        if m >=pow(10,9) +7:\\n            m = m % (pow(10,9) +7)\\n            \\n        return m\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        m=\"\"\\n        for i in range(1, (n+1)):\\n            a = bin(i)\\n            m += a[2:]\\n        m = int(m,2)\\n        \\n        if m >=pow(10,9) +7:\\n            m = m % (pow(10,9) +7)\\n            \\n        return m\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2615049,
                "title": "c-diagram-related-problems-python-solutions",
                "content": "![image](https://assets.leetcode.com/users/images/a51840d3-03ae-48dc-91b6-3ae2ff1159c3_1663954899.9468222.png)\\n![image](https://assets.leetcode.com/users/images/6414f0a5-9d9d-45bc-b455-a3a29782b012_1663954919.334429.png)\\n```\\nclass Solution {\\npublic:\\n    \\n    int numberOfBits(int n) {\\n\\t\\t  return log2(n) + 1;\\n    }\\n    \\n    int concatenatedBinary(int n) {\\n        long ans = 0, MOD = 1e9 + 7;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            int len = numberOfBits(i);\\n            ans = ((ans << len) % MOD + i) % MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**EDIT 1**\\n**Optimization** in `numberOfBits` function\\n```\\nint numberOfBits(int n) {\\n   int leadingZeros = __builtin_clz(n);\\n   return 32 - leadingZeros;\\n}\\n```\\n**EDIT 2**\\nAnother way of ***calculating length of binary number*** suggested by @CoolBud\\n```\\nint numberOfBits(int n) {\\n    return log2(n) + 1;\\n}\\n```\\n**EDIT 3**\\nAnother way of **calculating length of binary number** suggested by @Sopindm\\n```\\nint concatenatedBinary(int n) {\\n        long ans = 0, MOD = 1e9 + 7, len = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if(__builtin_popcount(i) == 1) ++len;\\n            ans = ((ans << len) % MOD + i) % MOD;\\n        }\\n        return ans;\\n}\\n```\\n**Binary Representation Related Problems**\\n1. Add Binary\\n2. Add Two Numbers\\n3. Counting Bits\\n4. Binary Watch\\n5. Reverse Bits\\n6. Binary Number with Alternating Bits\\n7. Hamming Distance\\n8. Prime Number of Set Bits in Binary Representation\\n# Python code\\n**Method 1**\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        mod=10**9 +7\\n        size=0\\n        res=0\\n        for i in range(1,n+1):\\n            if(i&(i-1)==0):\\n                size+=1\\n            res=((res<<size)%mod +i)%mod\\n        return res \\n```\\n**Method 2**\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        res=\"\"\\n        for i in range(1,n+1):\\n            res+=bin(i).replace(\\'0b\\',\\'\\')\\n        return int(res,2) %(10**9 +7)\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Bit Manipulation",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int numberOfBits(int n) {\\n\\t\\t  return log2(n) + 1;\\n    }\\n    \\n    int concatenatedBinary(int n) {\\n        long ans = 0, MOD = 1e9 + 7;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            int len = numberOfBits(i);\\n            ans = ((ans << len) % MOD + i) % MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nint numberOfBits(int n) {\\n   int leadingZeros = __builtin_clz(n);\\n   return 32 - leadingZeros;\\n}\\n```\n```\\nint numberOfBits(int n) {\\n    return log2(n) + 1;\\n}\\n```\n```\\nint concatenatedBinary(int n) {\\n        long ans = 0, MOD = 1e9 + 7, len = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if(__builtin_popcount(i) == 1) ++len;\\n            ans = ((ans << len) % MOD + i) % MOD;\\n        }\\n        return ans;\\n}\\n```\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        mod=10**9 +7\\n        size=0\\n        res=0\\n        for i in range(1,n+1):\\n            if(i&(i-1)==0):\\n                size+=1\\n            res=((res<<size)%mod +i)%mod\\n        return res \\n```\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        res=\"\"\\n        for i in range(1,n+1):\\n            res+=bin(i).replace(\\'0b\\',\\'\\')\\n        return int(res,2) %(10**9 +7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615041,
                "title": "simple-java-solution-4-lines-of-code",
                "content": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long val=0, i=0;\\n        while(i++<n)\\n            val= ((val<<(1+(int)(Math.log(i)/Math.log(2))))+i)%1000000007;\\n        return (int)val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long val=0, i=0;\\n        while(i++<n)\\n            val= ((val<<(1+(int)(Math.log(i)/Math.log(2))))+i)%1000000007;\\n        return (int)val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615004,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\n    int helper(int i)\\n    {\\n        return log2(i)+1;\\n    }\\npublic:\\n    int concatenatedBinary(int n) {\\n        long  ans=0,mod=1e9+7;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int len=helper(i);\\n            ans=((ans<<len)%mod+i)%mod;\\n            cout<<ans<<\" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int helper(int i)\\n    {\\n        return log2(i)+1;\\n    }\\npublic:\\n    int concatenatedBinary(int n) {\\n        long  ans=0,mod=1e9+7;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int len=helper(i);\\n            ans=((ans<<len)%mod+i)%mod;\\n            cout<<ans<<\" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2614994,
                "title": "c-javascript-simulation-bitwise",
                "content": "<iframe src=\"https://leetcode.com/playground/i9vaEivy/shared\" frameBorder=\"0\" width=\"100%\" height=\"340\"></iframe>",
                "solutionTags": [
                    "C",
                    "JavaScript",
                    "Math",
                    "Bit Manipulation",
                    "Simulation"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/i9vaEivy/shared\" frameBorder=\"0\" width=\"100%\" height=\"340\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2614971,
                "title": "c-bit-manipulation-fast-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int length(int n){\\n        return log2(n) + 1; // length of binary representation of a n number\\n        \\n    }\\n    int concatenatedBinary(int n) {\\n        long ans = 0; // even tho return type is int.\\n        int mod = 1e9 + 7;\\n        \\n        for(int i=1;i<=n;i++){\\n            int len = length(i);\\n            ans = ((ans << len) % mod + i) % mod; // left shift the ans and then add the i number init,(concatenate)\\n        }\\n        \\n        \\n        \\n        return ans % mod;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int length(int n){\\n        return log2(n) + 1; // length of binary representation of a n number\\n        \\n    }\\n    int concatenatedBinary(int n) {\\n        long ans = 0; // even tho return type is int.\\n        int mod = 1e9 + 7;\\n        \\n        for(int i=1;i<=n;i++){\\n            int len = length(i);\\n            ans = ((ans << len) % mod + i) % mod; // left shift the ans and then add the i number init,(concatenate)\\n        }\\n        \\n        \\n        \\n        return ans % mod;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614848,
                "title": "c-recursive-solution",
                "content": "int concatenatedBinary(int n) {\\n        \\n        long long mod = 1000000007;\\n        if(n==1)\\n            return 1;\\n        \\n        long long val  = concatenatedBinary(n-1)*pow(2,ceil(log2(n+1)));\\n        return (val+n)%mod;\\n    }",
                "solutionTags": [],
                "code": "int concatenatedBinary(int n) {\\n        \\n        long long mod = 1000000007;\\n        if(n==1)\\n            return 1;\\n        \\n        long long val  = concatenatedBinary(n-1)*pow(2,ceil(log2(n+1)));\\n        return (val+n)%mod;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2614701,
                "title": "java-simple-solution-better-than-100-with-explanation-1-general-method-2-binary-operation",
                "content": "```\\n/* approach:- \\n            the approach is pretty simple but all the matter is the way in which we can do it so the it will be very efficient in terms of time complexity\\n            \\n       -> So we need to interate from 1 to given n and concatenate all binary string from 1 to n and return the result\\n       -> The result can be pretty big as n can be 1<n<10^5  which an int cant hold so wee are using long annd make sure to do mod with 10^9+7 to get the value for bigger n values\\n       \\n       -> Now convert the number to binary string and find it length \\n       \\n         general approach                     |             binary operation\\n                                              |\\n   1.String bs=Integer.to binaryString(n);    |    1.if (n&(n-1)) ==0   len++;\\n     int len=bs.length()                      |      ex:- for 4-> (4 & 3) -> (100&011)==0 so len++\\n       \\n      -> Now append the number(binary string) to the previous binary string.\\n      \\n       general approach                       |             binary operation\\n                                              |\\n   1.  result = result+n                      |    1. result=result|num \\n       general string appending               |       or will work same as + operation\\n                                              |\\n                                              |\\n       o(n) better then 50%                   |     o(n) better than 100%        \\n      \\n*/\\n\\n\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long res=0;\\n        int mod=1000_000_007;\\n        int len=0;\\n        for(int i=1;i<=n;i++){\\n            //String binarystring=Integer.toBinaryString(i);\\n            if((i&(i-1))==0)\\n                len++;\\n            res=(res<<len|i)%mod;\\n            //res=(res+i)%mod;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n/* approach:- \\n            the approach is pretty simple but all the matter is the way in which we can do it so the it will be very efficient in terms of time complexity\\n            \\n       -> So we need to interate from 1 to given n and concatenate all binary string from 1 to n and return the result\\n       -> The result can be pretty big as n can be 1<n<10^5  which an int cant hold so wee are using long annd make sure to do mod with 10^9+7 to get the value for bigger n values\\n       \\n       -> Now convert the number to binary string and find it length \\n       \\n         general approach                     |             binary operation\\n                                              |\\n   1.String bs=Integer.to binaryString(n);    |    1.if (n&(n-1)) ==0   len++;\\n     int len=bs.length()                      |      ex:- for 4-> (4 & 3) -> (100&011)==0 so len++\\n       \\n      -> Now append the number(binary string) to the previous binary string.\\n      \\n       general approach                       |             binary operation\\n                                              |\\n   1.  result = result+n                      |    1. result=result|num \\n       general string appending               |       or will work same as + operation\\n                                              |\\n                                              |\\n       o(n) better then 50%                   |     o(n) better than 100%        \\n      \\n*/\\n\\n\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long res=0;\\n        int mod=1000_000_007;\\n        int len=0;\\n        for(int i=1;i<=n;i++){\\n            //String binarystring=Integer.toBinaryString(i);\\n            if((i&(i-1))==0)\\n                len++;\\n            res=(res<<len|i)%mod;\\n            //res=(res+i)%mod;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614685,
                "title": "c-easy-beginner-friendly-95-fast-short",
                "content": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long int ans = 0, mod = 1e9 + 7;\\n        int sz = 0;\\n        \\n        for(int i = 1; i<=n; i++){\\n            if((i&(i-1)) == 0)\\n                sz++;\\n            \\n            ans = (ans*(1<<sz) + i)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6ca6396a-6878-4d2d-bf38-1c71c91c2721_1663948202.0333488.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long int ans = 0, mod = 1e9 + 7;\\n        int sz = 0;\\n        \\n        for(int i = 1; i<=n; i++){\\n            if((i&(i-1)) == 0)\\n                sz++;\\n            \\n            ans = (ans*(1<<sz) + i)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614583,
                "title": "brute-force-python",
                "content": "\\'\\'\\'\\ndef concatenatedBinary(self, n: int) -> int:\\n\\n\\t\\t\\tres=\\'\\'\\n\\t\\t   for i in range(1,n+1):\\n\\t\\t\\t\\tres=res+bin(i)[2:]\\n\\t\\t\\tres=int(res,2)\\n\\t\\t\\treturn res%1000000007\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\ndef concatenatedBinary(self, n: int) -> int:\\n\\n\\t\\t\\tres=\\'\\'\\n\\t\\t   for i in range(1,n+1):\\n\\t\\t\\t\\tres=res+bin(i)[2:]\\n\\t\\t\\tres=int(res,2)\\n\\t\\t\\treturn res%1000000007\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2614546,
                "title": "c-100-memory-100-runtime-o-n",
                "content": "Memory usage on this seems pretty random, ranges from 25% to 100% on identical submissions. Runtime is consistently 100%.\\n```\\nint concatenatedBinary(int n){\\n    long res = 0; // long so that intermediate results fit in memory\\n    int modnum = pow(10, 9) + 7;\\n    int numbits;\\n\\t\\n    for ( int i=1; i<=n; i++ ){\\n\\t\\t// Get number of bits in binary representation\\n        numbits = 32 - __builtin_clz(i); \\n\\t\\t// right shift result by number of bits, add i, then take modulus\\n        res = ((res<<numbits) + i)%modnum; \\n    }\\n    \\n    return(res);\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e74fd5cc-2f6c-48ea-82fd-03b6832aa943_1663945583.184223.png)\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint concatenatedBinary(int n){\\n    long res = 0; // long so that intermediate results fit in memory\\n    int modnum = pow(10, 9) + 7;\\n    int numbits;\\n\\t\\n    for ( int i=1; i<=n; i++ ){\\n\\t\\t// Get number of bits in binary representation\\n        numbits = 32 - __builtin_clz(i); \\n\\t\\t// right shift result by number of bits, add i, then take modulus\\n        res = ((res<<numbits) + i)%modnum; \\n    }\\n    \\n    return(res);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2614492,
                "title": "c-short-solution-using-bit-manipulation",
                "content": "**Simple Loop**\\n\\n```\\npublic int ConcatenatedBinary(int n)\\n{\\n\\tlong result = 0;\\n\\tlong m = 2;\\n\\tlong mod = 1000000007;\\n\\n\\tfor (int i = 1; i <= n; i++)\\n\\t{\\n\\t\\tif (i == m)\\n\\t\\t{\\n\\t\\t\\tm *= 2;\\n\\t\\t}\\n\\t\\tresult = (result * m + i) % mod;\\n\\t}\\n\\treturn (int)result;\\n}\\n```\\n**Bit Manipulation**\\n\\n```\\npublic int ConcatenatedBinary(int n)\\n{\\n\\n\\tlong result = 0;\\n\\tvar mod = 1000000007;\\n\\tfor (var i = 1; i <= n; i++)\\n\\t{\\n\\t\\tvar binary = Convert.ToString(i, 2);\\n\\t\\tresult = (result << binary.Length) % mod;\\n\\t\\tresult = (result + i) % mod;\\n\\t}\\n\\n\\treturn (int)result;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\npublic int ConcatenatedBinary(int n)\\n{\\n\\tlong result = 0;\\n\\tlong m = 2;\\n\\tlong mod = 1000000007;\\n\\n\\tfor (int i = 1; i <= n; i++)\\n\\t{\\n\\t\\tif (i == m)\\n\\t\\t{\\n\\t\\t\\tm *= 2;\\n\\t\\t}\\n\\t\\tresult = (result * m + i) % mod;\\n\\t}\\n\\treturn (int)result;\\n}\\n```\n```\\npublic int ConcatenatedBinary(int n)\\n{\\n\\n\\tlong result = 0;\\n\\tvar mod = 1000000007;\\n\\tfor (var i = 1; i <= n; i++)\\n\\t{\\n\\t\\tvar binary = Convert.ToString(i, 2);\\n\\t\\tresult = (result << binary.Length) % mod;\\n\\t\\tresult = (result + i) % mod;\\n\\t}\\n\\n\\treturn (int)result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2614351,
                "title": "python-one-line-with-explanation",
                "content": "**Solution**\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\"\".join(bin(x)[2:] for x in range(1, n + 1)), 2) % 1000000007\\n```\\n\\n**Explanation**\\n \\nFirst we have :\\n```\\nbin(x)[2:] for x in range(1, n + 1)\\n```\\nThis loops through from 1 to n (inclusive) and and converts the number to binary. We then slice the result to remove the \\'0b\\' prefix that\\'s there by default. The total result of the above segment is a python generator (think of it as a list of the each of the values. i.e. [bin(1), bin(2), ...])\\n\\nExpanding, we have :\\n```\\n\"\".join( bin(x)[2:] for x in range(1, n + 1) )\\n```\\nThis gets the above generator and converts it to a string (it concatenates each value in the \\'list\\')\\n\\nExpanding futher, we have :\\n```\\nint( \"\".join(bin(x)[2:] for x in range(1, n + 1)) , 2)\\n```\\nThis just converts the resultant string to a binary number\\n\\nAnd finally :\\n```\\nreturn int(\"\".join(bin(x)[2:] for x in range(1, n + 1)), 2) % 1000000007\\n```\\nThis returns the result modulo 10 ^ 9 + 7 as required.\\n```\\n\\n\\n\\n```\\nIf you found this solution helpful, please upvote it \\uD83D\\uDE01",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\"\".join(bin(x)[2:] for x in range(1, n + 1)), 2) % 1000000007\\n```\n```\\nbin(x)[2:] for x in range(1, n + 1)\\n```\n```\\n\"\".join( bin(x)[2:] for x in range(1, n + 1) )\\n```\n```\\nint( \"\".join(bin(x)[2:] for x in range(1, n + 1)) , 2)\\n```\n```\\nreturn int(\"\".join(bin(x)[2:] for x in range(1, n + 1)), 2) % 1000000007\\n```\n```\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614346,
                "title": "c-o-n-simple-code",
                "content": "```\\nint mostSigBit(int n)\\n{\\n \\n    // calculate the  number\\n    // of leading zeroes\\n    int k = __builtin_clz(n);\\n \\n    // position of the most\\n    // significant digit:\\n    return sizeof(int)*8 - k;\\n}\\n\\nlong long MOD = 1e9+7;\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n)\\n    {\\n        long long ret = 0;\\n        for(int i=1; i<=n; i++)\\n        {\\n            int iLen = mostSigBit(i);\\n            ret <<= iLen;\\n            ret += i;\\n            ret %= MOD;\\n        }\\n        return ret;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint mostSigBit(int n)\\n{\\n \\n    // calculate the  number\\n    // of leading zeroes\\n    int k = __builtin_clz(n);\\n \\n    // position of the most\\n    // significant digit:\\n    return sizeof(int)*8 - k;\\n}\\n\\nlong long MOD = 1e9+7;\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n)\\n    {\\n        long long ret = 0;\\n        for(int i=1; i<=n; i++)\\n        {\\n            int iLen = mostSigBit(i);\\n            ret <<= iLen;\\n            ret += i;\\n            ret %= MOD;\\n        }\\n        return ret;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614213,
                "title": "complete-explaination-using-overview-binary-diagram",
                "content": "```\\n/*\\n    Observation:\\n    -----------\\n    \\n    Let\\'s see changes for 3(N)\\n        n     result_dec_value      binary_of_current_n     result_binary_string\\n        1        1                     1                           1\\n        2        6                     10                          110\\n        3        27                    11                          11011\\n        \\n    Here in the above sequence of operations we can clearly observe that\\n    appending the binary form of current n to an existing resultent binary\\n    string, will left shift the resultent binary string by the numbers of\\n    total bits in current n.\\n    \\n    For example:\\n    -----------\\n        n -> 1, result_dec_val -> 1, bin(1) -> 1, result_bin -> 1\\n        \\n        n -> 2, result_dec_val -> ?, bin(2) -> 10, result_bin -> 110\\n        \\n        result_dec_val = (prev_result_bin << (total_bits_in_current_n)) + n;\\n        \\n                       = (1 << 2) + 2\\n                       = 4 + 2\\n                       = 6\\n                       \\n        NOTE: 1. (1 << 2) nothing but -> (2 * 2)\\n              2. total_bits_in_current_n -> means bits that are\\n              responsible to represent the value of n.(avoid leading 0 bits)\\n              \\n              \\n        so therefore, we can conclude that\\n        \\n        If we have equivalent decemal value for all binaries [1, (n - 1)],\\n        from that we can evaluate decimal for n by using formula\\n        \\n        decVal(n) = [decVal(n - 1) << (log2(n) + 1)] + n\\n        \\n        here in the above formula : (log2(n) + 1) gives total number bits in n in base 2\\n        decVal(n - 1) : decimal value calculated so far from binaries of [1, n - 1]\\n        \\n        the formula can be placed inside a for loop & n is replaced by loop variable\\n        let say i.\\n\\n*/\\n\\nclass Solution {\\n    \\n    private static final int M = 1_000_000_000 + 7;\\n    \\n    private int log2(int n) {\\n        return (int)(Math.log10(n) / Math.log10(2)) + 1;\\n    }\\n    \\n    public int concatenatedBinary(int n) {\\n        long decVal = 1;\\n        for(int i = 2; i <= n; i += 1) {\\n            decVal = ((decVal << log2(i)) % M + i) % M;\\n        }\\n        \\n        return (int)decVal;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n    Observation:\\n    -----------\\n    \\n    Let\\'s see changes for 3(N)\\n        n     result_dec_value      binary_of_current_n     result_binary_string\\n        1        1                     1                           1\\n        2        6                     10                          110\\n        3        27                    11                          11011\\n        \\n    Here in the above sequence of operations we can clearly observe that\\n    appending the binary form of current n to an existing resultent binary\\n    string, will left shift the resultent binary string by the numbers of\\n    total bits in current n.\\n    \\n    For example:\\n    -----------\\n        n -> 1, result_dec_val -> 1, bin(1) -> 1, result_bin -> 1\\n        \\n        n -> 2, result_dec_val -> ?, bin(2) -> 10, result_bin -> 110\\n        \\n        result_dec_val = (prev_result_bin << (total_bits_in_current_n)) + n;\\n        \\n                       = (1 << 2) + 2\\n                       = 4 + 2\\n                       = 6\\n                       \\n        NOTE: 1. (1 << 2) nothing but -> (2 * 2)\\n              2. total_bits_in_current_n -> means bits that are\\n              responsible to represent the value of n.(avoid leading 0 bits)\\n              \\n              \\n        so therefore, we can conclude that\\n        \\n        If we have equivalent decemal value for all binaries [1, (n - 1)],\\n        from that we can evaluate decimal for n by using formula\\n        \\n        decVal(n) = [decVal(n - 1) << (log2(n) + 1)] + n\\n        \\n        here in the above formula : (log2(n) + 1) gives total number bits in n in base 2\\n        decVal(n - 1) : decimal value calculated so far from binaries of [1, n - 1]\\n        \\n        the formula can be placed inside a for loop & n is replaced by loop variable\\n        let say i.\\n\\n*/\\n\\nclass Solution {\\n    \\n    private static final int M = 1_000_000_000 + 7;\\n    \\n    private int log2(int n) {\\n        return (int)(Math.log10(n) / Math.log10(2)) + 1;\\n    }\\n    \\n    public int concatenatedBinary(int n) {\\n        long decVal = 1;\\n        for(int i = 2; i <= n; i += 1) {\\n            decVal = ((decVal << log2(i)) % M + i) % M;\\n        }\\n        \\n        return (int)decVal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614128,
                "title": "rust-one-liner",
                "content": "```rust\\nimpl Solution {\\n    pub fn concatenated_binary(n: i32) -> i32 {\\n        (1..=n as u64).fold(0u64, |o, i| {\\n            ((o << 64 - i.leading_zeros()) + i) % 1_000_000_007\\n        }) as i32\\n    }\\n}\\n```\\n\\nA more readable one without `fold`:\\n```rust\\nimpl Solution {\\n    pub fn concatenated_binary(n: i32) -> i32 {\\n        let mut o = 0;\\n        for i in 1..=n as u64 {\\n            o <<= 64 - i.leading_zeros();\\n            o += i;\\n            o %= 1_000_000_007\\n        }\\n        o as i32\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn concatenated_binary(n: i32) -> i32 {\\n        (1..=n as u64).fold(0u64, |o, i| {\\n            ((o << 64 - i.leading_zeros()) + i) % 1_000_000_007\\n        }) as i32\\n    }\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn concatenated_binary(n: i32) -> i32 {\\n        let mut o = 0;\\n        for i in 1..=n as u64 {\\n            o <<= 64 - i.leading_zeros();\\n            o += i;\\n            o %= 1_000_000_007\\n        }\\n        o as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2613932,
                "title": "c-easy-and-explained-solution-beginner-friendly-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    string binary(int n)\\n    {\\n        string t=\"\";\\n        while(n!=0)\\n        {\\n            if(n%2!=0)\\n            {\\n                t+=\\'1\\';\\n            }\\n            else\\n            {\\n                t+=\\'0\\';\\n            }\\n            n/=2;\\n        }\\n        reverse(t.begin(),t.end());\\n        return t;\\n    }\\n    int concatenatedBinary(int n) \\n    {\\n        string s=\"\";\\n        const int N=1e9+7;\\n        long long ans=0;\\n        int j=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            s+=binary(i); //Function  to calculate the binary of every number upto n\\n        }\\n        int m=s.length(),p=1;\\n        for(int i=m-1;i>=0;i--)\\n        {\\n            if(s[i]!=0)  // Checking if char is 0 or not, it prevents from TLE because we only perform operarions when s[i]=1\\n            {\\n                ans+=p*(s[i]-\\'0\\');\\n                ans%=N;  //Modulo 1e9+7;\\n            }\\n            p*=2;\\n            p%=N; //Modulo 1e9+7            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string binary(int n)\\n    {\\n        string t=\"\";\\n        while(n!=0)\\n        {\\n            if(n%2!=0)\\n            {\\n                t+=\\'1\\';\\n            }\\n            else\\n            {\\n                t+=\\'0\\';\\n            }\\n            n/=2;\\n        }\\n        reverse(t.begin(),t.end());\\n        return t;\\n    }\\n    int concatenatedBinary(int n) \\n    {\\n        string s=\"\";\\n        const int N=1e9+7;\\n        long long ans=0;\\n        int j=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            s+=binary(i); //Function  to calculate the binary of every number upto n\\n        }\\n        int m=s.length(),p=1;\\n        for(int i=m-1;i>=0;i--)\\n        {\\n            if(s[i]!=0)  // Checking if char is 0 or not, it prevents from TLE because we only perform operarions when s[i]=1\\n            {\\n                ans+=p*(s[i]-\\'0\\');\\n                ans%=N;  //Modulo 1e9+7;\\n            }\\n            p*=2;\\n            p%=N; //Modulo 1e9+7            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613926,
                "title": "python-simple-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef concatenatedBinary(self, n: int) -> int:\\n\\t\\t\\tmod = 1000000007\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor num in range(1,n+1):    \\n\\t\\t\\t\\tres = res << num.bit_length() # left shifting length of the binary value of num\\n\\t\\t\\t\\tres = (res | num) % mod # adding the current number\\n\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef concatenatedBinary(self, n: int) -> int:\\n\\t\\t\\tmod = 1000000007\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor num in range(1,n+1):    \\n\\t\\t\\t\\tres = res << num.bit_length() # left shifting length of the binary value of num\\n\\t\\t\\t\\tres = (res | num) % mod # adding the current number\\n\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2613841,
                "title": "c-fastest-and-easiest-basic-shift-operation",
                "content": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long int val=0;\\n        int i=1;\\n        while(i<=n)\\n        {\\n            val=((val << (1 + int(log2(i)))) % 1000000007 +i) % 1000000007;\\n            i ++ ;\\n        }\\n        return val;\\n    }\\n};\\n```\\nDo upvote if its helpful,Thanks.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long int val=0;\\n        int i=1;\\n        while(i<=n)\\n        {\\n            val=((val << (1 + int(log2(i)))) % 1000000007 +i) % 1000000007;\\n            i ++ ;\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613775,
                "title": "java-simple-2-line-solution-linear-o-n",
                "content": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int mod = 1000000007;\\n        long value = 0;\\n        // iterate for all numbers till n\\n        for(int i=1;i<=n;i++)\\n            value = ((value << countBits(i)) + i)%mod;        \\n        return (int)value;\\n    }\\n    // util to get total bit count\\n    private int countBits(int n)\\n    {\\n        int count = 0;\\n        while (n != 0)\\n        {\\n            count++;\\n            n >>= 1;\\n        }\\n          \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int mod = 1000000007;\\n        long value = 0;\\n        // iterate for all numbers till n\\n        for(int i=1;i<=n;i++)\\n            value = ((value << countBits(i)) + i)%mod;        \\n        return (int)value;\\n    }\\n    // util to get total bit count\\n    private int countBits(int n)\\n    {\\n        int count = 0;\\n        while (n != 0)\\n        {\\n            count++;\\n            n >>= 1;\\n        }\\n          \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613659,
                "title": "c-iterative-easy-to-understand",
                "content": "Let f(n) = concatenation of binary numbers from 1 to n\\nSo we need to find f(n)\\n\\nWe append the numbers from 1 to n one by one in a loop.\\nTo find f(i),\\n\\twe left shift the f(i-1) by number of bits in i, and add i to it\\n\\tthen we take the mod\\n\\n**eg.** n = 4\\nf(1) = 1\\n\\tf(2) = 1<<(number of bits in 2) + 2 = 1<<2 + 2 = 100 + 10 = 110\\n\\tf(3) = 11<<(number of bits in 3) + 3 = 11<<2 + 3 = 11000 + 11 = 11011\\n\\tf(4) = 1011<<(number of bits in 4) + 4 = 11011<< 3 + 4 = 11011000 + 100 = 11011100\\n(also taking mod 1e9+7 simultaneously in each step to avoid overflow)\\n\\n```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long ans = 0;\\n        for(long long i=1; i<=n; i++) {\\n            ans = ((ans << ((int)floor(log2(i)) + 1)) + i)%MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long ans = 0;\\n        for(long long i=1; i<=n; i++) {\\n            ans = ((ans << ((int)floor(log2(i)) + 1)) + i)%MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613633,
                "title": "blazingly-fast-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        if(n == 1) return 1;\\n        long long prev = 1;\\n        long long bits = 1;\\n        for(int i = 2; i <= n; i ++) {\\n            if((i & (i - 1)) == 0) {\\n                bits ++;\\n            }\\n            prev <<= bits;\\n            prev = prev + i;\\n            prev %= ((int)1e9 + 7);\\n        } \\n        return (int) prev;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        if(n == 1) return 1;\\n        long long prev = 1;\\n        long long bits = 1;\\n        for(int i = 2; i <= n; i ++) {\\n            if((i & (i - 1)) == 0) {\\n                bits ++;\\n            }\\n            prev <<= bits;\\n            prev = prev + i;\\n            prev %= ((int)1e9 + 7);\\n        } \\n        return (int) prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613478,
                "title": "c-o-n-easy-solution",
                "content": "In this problem we are traversing from 1 to n and then \\ncalculating binary length of every ith value and then left shifting with previous value and adding current decimal value.\\n\\n**For calculating length of binary digit-**\\nwe are using [ 1 + log2(i) ] = digit length\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        int i;\\n        long long int val = 0;\\n        for(i=1;i<=n;i++){\\n            val = ((val << (1 + int(log2(i)))) % 1000000007 + i) % 1000000007;\\n        }\\n        return val;\\n    }\\n};\\n```\\n\\nIn last we are doing mod 10^9 + 7.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        int i;\\n        long long int val = 0;\\n        for(i=1;i<=n;i++){\\n            val = ((val << (1 + int(log2(i)))) % 1000000007 + i) % 1000000007;\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613464,
                "title": "python-bin-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef concatenatedBinary(self, n: int) -> int:\\n\\t\\t\\tm=10**9+7\\n\\t\\t\\ttemp=\"\"\\n\\t\\t\\tfor _ in range(1,n+1):\\n\\t\\t\\t\\ttemp+=bin(_)[2:]\\n\\t\\t\\treturn int(temp,2)%m",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef concatenatedBinary(self, n: int) -> int:\\n\\t\\t\\tm=10**9+7\\n\\t\\t\\ttemp=\"\"\\n\\t\\t\\tfor _ in range(1,n+1):\\n\\t\\t\\t\\ttemp+=bin(_)[2:]\\n\\t\\t\\treturn int(temp,2)%m",
                "codeTag": "Java"
            },
            {
                "id": 2613430,
                "title": "python-one-line-solution",
                "content": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\"\".join([bin(i)[2:] for i in range(1, n+1)]), base=2) % 1000000007",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\"\".join([bin(i)[2:] for i in range(1, n+1)]), base=2) % 1000000007",
                "codeTag": "Java"
            },
            {
                "id": 2613297,
                "title": "simplest-fastest-quickest-java-solution-via-bit-manipulation-all-himself-by-lord-noddy",
                "content": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long res=0;\\n        int mod=1_000_000_007;\\n        \\n        int size=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if((i&(i-1))==0) size++;\\n            \\n            res=(res<<size|i) % mod;\\n        }\\n        return (int) res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long res=0;\\n        int mod=1_000_000_007;\\n        \\n        int size=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if((i&(i-1))==0) size++;\\n            \\n            res=(res<<size|i) % mod;\\n        }\\n        return (int) res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613296,
                "title": "rust-modular-math",
                "content": "If you like my solutions, you should check out [my github repo](https://github.com/SvetlinZarev/coding-challenges/tree/main/leetcode)\\n\\n\\n### Modular arithmetic\\n\\nThe concatenation of `A` and `B`, i.e.`AB`, can be expressed\\nas: `A * 2.pow(BITS-B.leading_zeroes()) + B`. In other words we\\nshift `A` some positions to the left in order to fit `B` to the\\nright of `A`: `(A << BITS-B.leading_zeroes()) + B`\\n\\nNo we can use modular arithmetic to calculate the result:\\n\\n* `(a*b) mod c == ((a mod c) * (b mod c)) mod c`\\n* `(a+b) mod c == ((a mod c) + (b mod c)) mod c`\\n\\n#### Sticking strictly to the formula:\\n\\n```rust\\nconst MOD: u64 = 10u64.pow(9) + 7;\\n\\npub fn concatenated_binary(n: i32) -> i32 {\\n    assert!(n >= 0 && n <= 10i32.pow(5));\\n    let n = n as u64;\\n\\n    let mut answer = 0u64;\\n\\n    for x in 1..=n {\\n        // (a*b) mod c == ((a mod c) * (b mod c)) mod c\\n\\n        // We\\'ve already %MOD-ed the answer at the end of the loop,\\n        // thus we can skip %MOD-ing it here. It\\'s left just to make\\n        // it more similar to the formula above\\n        let a = answer % MOD;\\n\\n        //  Calculate how many places we have to move\\n        // \"answer\" to the left in order to be able to\\n        // concatenate it with X\\n        let b = (1 << 64 - x.leading_zeros()) % MOD;\\n\\n        // Move \"answer\" to the left and take to MOD\\n        let m = (a * b) % MOD;\\n\\n        // (a+b) mod c == ((a mod c) + (b mod c)) mod c\\n        //\\n        // We know that X is in the range [0:10^5], thus\\n        // it\\'s always smaller than MOD, so we don\\'t\\n        // need to do (X % MOD). And M was already %-ed above\\n        //\\n        // Concatenate X and take the MOD\\n        answer = (x + m) % MOD;\\n    }\\n\\n    answer as i32\\n}\\n```\\n\\n#### Optimizing the multiplications\\n\\n* Because N can be at most `10^5` it\\'s will always be smaller than the\\n  MOD (`10^9+7`), thus we don\\'t need to %MOD the `n` values\\n* The largest bitshift value of `N` 10^5`( i.e. `2^17`) we calculate is smaller\\n  than the MOD, thus we can avoid doing the %MOD here as well\\n* Multiplying by a power of two is equal to a bit-shift to the left\\n\\nGiven those three points we can optimize:\\n```text\\nlet a = answer % MOD;\\nlet b = (1 << 64 - x.leading_zeros()) % MOD;\\nlet m = (a * b) % MOD;\\n```\\n\\nto just \\n```text\\nlet y = (answer << 64 - x.leading_zeros()) % MOD;\\n```\\n\\n```rust\\nconst MOD: u64 = 10u64.pow(9) + 7;\\n\\npub fn concatenated_binary(n: i32) -> i32 {\\n    assert!(n >= 0 && n <= 10i32.pow(5));\\n    let n = n as u64;\\n\\n    let mut answer = 0u64;\\n\\n    for x in 1..=n {\\n        let y = (answer << 64 - x.leading_zeros()) % MOD;\\n        answer = (x + y) % MOD;\\n    }\\n\\n    answer as i32\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Math"
                ],
                "code": "```rust\\nconst MOD: u64 = 10u64.pow(9) + 7;\\n\\npub fn concatenated_binary(n: i32) -> i32 {\\n    assert!(n >= 0 && n <= 10i32.pow(5));\\n    let n = n as u64;\\n\\n    let mut answer = 0u64;\\n\\n    for x in 1..=n {\\n        // (a*b) mod c == ((a mod c) * (b mod c)) mod c\\n\\n        // We\\'ve already %MOD-ed the answer at the end of the loop,\\n        // thus we can skip %MOD-ing it here. It\\'s left just to make\\n        // it more similar to the formula above\\n        let a = answer % MOD;\\n\\n        //  Calculate how many places we have to move\\n        // \"answer\" to the left in order to be able to\\n        // concatenate it with X\\n        let b = (1 << 64 - x.leading_zeros()) % MOD;\\n\\n        // Move \"answer\" to the left and take to MOD\\n        let m = (a * b) % MOD;\\n\\n        // (a+b) mod c == ((a mod c) + (b mod c)) mod c\\n        //\\n        // We know that X is in the range [0:10^5], thus\\n        // it\\'s always smaller than MOD, so we don\\'t\\n        // need to do (X % MOD). And M was already %-ed above\\n        //\\n        // Concatenate X and take the MOD\\n        answer = (x + m) % MOD;\\n    }\\n\\n    answer as i32\\n}\\n```\n```text\\nlet a = answer % MOD;\\nlet b = (1 << 64 - x.leading_zeros()) % MOD;\\nlet m = (a * b) % MOD;\\n```\n```text\\nlet y = (answer << 64 - x.leading_zeros()) % MOD;\\n```\n```rust\\nconst MOD: u64 = 10u64.pow(9) + 7;\\n\\npub fn concatenated_binary(n: i32) -> i32 {\\n    assert!(n >= 0 && n <= 10i32.pow(5));\\n    let n = n as u64;\\n\\n    let mut answer = 0u64;\\n\\n    for x in 1..=n {\\n        let y = (answer << 64 - x.leading_zeros()) % MOD;\\n        answer = (x + y) % MOD;\\n    }\\n\\n    answer as i32\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2613252,
                "title": "java-solution-bit-manipulation-and-string",
                "content": "### Please Upvote !!! **(\\u25E0\\u203F\\u25E0)**\\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int mod = 1000000007;\\n        long bin = 0;\\n        int len = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n            // checks if i is power of 2 \\n            // (length of binary number increases by +1 with every power of 2)\\n            if ((i & (i - 1)) == 0) len++;      \\n            bin = ((bin << len) | i) % mod;\\n        }\\n\\n        return (int) bin;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\\n#### OR\\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int mod = 1000000007;\\n        long bin = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n            String binaryStr = Integer.toBinaryString(i);\\n            bin = ((bin << binaryStr.length()) | i) % mod;\\n        }\\n\\n        return (int) bin;\\n    }\\n}\\n\\n// TC: O(n * logn) - Integer.toBinaryString() takes logn time\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int mod = 1000000007;\\n        long bin = 0;\\n        int len = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n            // checks if i is power of 2 \\n            // (length of binary number increases by +1 with every power of 2)\\n            if ((i & (i - 1)) == 0) len++;      \\n            bin = ((bin << len) | i) % mod;\\n        }\\n\\n        return (int) bin;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int mod = 1000000007;\\n        long bin = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n            String binaryStr = Integer.toBinaryString(i);\\n            bin = ((bin << binaryStr.length()) | i) % mod;\\n        }\\n\\n        return (int) bin;\\n    }\\n}\\n\\n// TC: O(n * logn) - Integer.toBinaryString() takes logn time\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613227,
                "title": "rust-one-liner-with-comments",
                "content": "The algorithm - maintain a running \"sum\" that we keep modulo the given prime. For each number, shift the sum the number of steps necessary to accomodate all the set bits in the number, and OR in the bits into the sum.\\n\\nImplementation notes - just a few minor tweaks compared to other published solutions for this pretty easy problem:\\n* I used `reduce` here instead of `fold`, so that we initialize the running sum with 1, instead of initializing the `fold` state with 0 and then OR:ing in the 1. On the other hand, we have to make an `.unwrap()`, which we wouldn\\'t have to do with a `fold`.\\n* `SumType` and `SumType::BITS` to avoid magic values.\\n\\n```\\ntype SumType = i64;\\nconst MOD: SumType = 1000000007;\\n\\nimpl Solution {\\n    pub fn concatenated_binary(n: i32) -> i32 {\\n        (1..=n as SumType).reduce(|acc, num| ((acc << (SumType::BITS - num.leading_zeros())) | num) % MOD).unwrap() as _\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype SumType = i64;\\nconst MOD: SumType = 1000000007;\\n\\nimpl Solution {\\n    pub fn concatenated_binary(n: i32) -> i32 {\\n        (1..=n as SumType).reduce(|acc, num| ((acc << (SumType::BITS - num.leading_zeros())) | num) % MOD).unwrap() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2613203,
                "title": "3-lines-of-code-place-value-and-facevalue-manipulation-c-explaination-faster-100",
                "content": "Trick is to add left shift of previous number formed till now by the size of binary string formed by the present number(Place Value) and then adding the present number.\\n\\nDoing left shift by size \\'sz\\' is equivalent to multiplying by \\'sz\\'th power of 2.\\nSize of strings can be updated whenever we hit powers of 2.\\ndo take mod(1e9+7) whenever possible inorder to avoid overflows.\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        int ans=0,sz=0;\\n        for(int i=1;i<=n;i++){\\n            if(i==(1<<sz))sz++;// increments whenever we hit next power of 2\\n            ans=((ans*1LL*(1<<sz))%md+i)%md; // left shift previous number formed then add i, then take mod\\n        }\\n        return ans;\\n    }\\n};\\n```\\nHOPE THIS HELPS :)",
                "solutionTags": [
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        int ans=0,sz=0;\\n        for(int i=1;i<=n;i++){\\n            if(i==(1<<sz))sz++;// increments whenever we hit next power of 2\\n            ans=((ans*1LL*(1<<sz))%md+i)%md; // left shift previous number formed then add i, then take mod\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613189,
                "title": "one-line-python-solution",
                "content": "```\\ndef concatenatedBinary(self, n: int) -> int:\\n\\treturn int(\"\".join([bin(i)[2:] for i in range(1, n+1)]), 2) % (10**9 + 7)",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef concatenatedBinary(self, n: int) -> int:\\n\\treturn int(\"\".join([bin(i)[2:] for i in range(1, n+1)]), 2) % (10**9 + 7)",
                "codeTag": "Python3"
            },
            {
                "id": 2613134,
                "title": "c-bit-manipulation-explanation-o-n-logn",
                "content": "```\\n\\nHere I took every bit and compute how much it will contribute to the answer . \\nn = 3 , we have to take 1 (1) , 2 (10), 3(11) . So the anwer will (decimal value of 11011) % 1e9+7 . \\nif we will travarse from back we can get the answer . But the problem arrives when ,if we are on Xth bit and (1<<X) is not fit in our datatype . \\nSo for that problem we will take  (1<<(X-1)) % 1e9+7 and multiply it with 2. \\nThat\\'s how we\\'ll get all value of (1<<X) without overflow and add it to the answer according to the condition ( bit is set or not) . \\n\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int mul(int a , int b){\\n        return 1ll*a*b%mod;\\n    }\\n    int sum(int a ,int b){\\n        a += b;\\n        a %= mod;\\n        return a;\\n    }\\n    int concatenatedBinary(int n) {\\n        int val = 0 , idx = 0 , prev = 1;\\n        for(int i = n ; i >=1 ;i--){\\n            int cur = i;\\n            while(cur > 0 ){\\n                int rem = cur%2;\\n                if(idx == 0){\\n                    val = sum(val,rem)%mod;;\\n                    prev = 1;\\n                }else{\\n                    int multi = mul(prev,2)%mod;\\n                    if(rem)\\n                        val = sum(multi,val)%mod;\\n                    prev = multi;\\n                }\\n                cur >>= 1;\\n                idx++;\\n            }\\n        }\\n        return val;\\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int mul(int a , int b){\\n        return 1ll*a*b%mod;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2613128,
                "title": "brute-force-works-self-explanatory",
                "content": "Two brute force ways since the constraint is small\\nFYI, the __builtin_clz is to count the leading zeros of the integer. \\nThe later one may be a bit faster.\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        const int mod = 1e9 + 7;\\n        long long ans = 0;\\n        for (int i = 1; i <= n; ++ i) {\\n            int len = 0;\\n            for (int j = i; j; j >>= 1) ++ len;\\n            ans = (ans << len | i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        const int mod = 1e9 + 7;\\n        long long ans = 0;\\n        for (int i = 1; i <= n; ++ i) {\\n            int len = 32 - __builtin_clz(i);\\n            ans = (ans << len | i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        const int mod = 1e9 + 7;\\n        long long ans = 0;\\n        for (int i = 1; i <= n; ++ i) {\\n            int len = 0;\\n            for (int j = i; j; j >>= 1) ++ len;\\n            ans = (ans << len | i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        const int mod = 1e9 + 7;\\n        long long ans = 0;\\n        for (int i = 1; i <= n; ++ i) {\\n            int len = 32 - __builtin_clz(i);\\n            ans = (ans << len | i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613118,
                "title": "c-bit-manipulation-easy-approach",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0, i=0, x = 1;\\n        while(x <= n){\\n            if((x&(x-1)) == 0)\\n                i++;\\n            ans = ((ans << i) | x)%1000000007;\\n            x++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0, i=0, x = 1;\\n        while(x <= n){\\n            if((x&(x-1)) == 0)\\n                i++;\\n            ans = ((ans << i) | x)%1000000007;\\n            x++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2613035,
                "title": "100-fast-javascript-solution-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/7bfba09e-bc39-4517-9086-b2d8eca5725a_1663914882.3470545.png)\\n```\\nvar concatenatedBinary = function(n) {\\n     let ans = 1, len = 4\\n    for (let i = 2; i <= n; i++) {\\n        if (i === len) len *= 2\\n        ans = (ans * len + i) % 1000000007;\\n    }\\n    return ans\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar concatenatedBinary = function(n) {\\n     let ans = 1, len = 4\\n    for (let i = 2; i <= n; i++) {\\n        if (i === len) len *= 2\\n        ans = (ans * len + i) % 1000000007;\\n    }\\n    return ans\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2613006,
                "title": "c-o-n",
                "content": "\\tpublic int ConcatenatedBinary(int n) \\n\\t\\t{\\n\\t\\t\\tlong current =  0;\\n\\t\\t\\tlong modulo = 1_000_000_000 + 7;\\n\\t\\t\\tfor(long i = 1; i <= n; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong power = 1;\\n\\t\\t\\t\\twhile(power <= i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpower = power*2;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcurrent = (current*power)%modulo;\\n\\t\\t\\t\\tcurrent = (current + i)%modulo;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn (int)current;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\tpublic int ConcatenatedBinary(int n) \\n\\t\\t{\\n\\t\\t\\tlong current =  0;\\n\\t\\t\\tlong modulo = 1_000_000_000 + 7;\\n\\t\\t\\tfor(long i = 1; i <= n; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong power = 1;\\n\\t\\t\\t\\twhile(power <= i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpower = power*2;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcurrent = (current*power)%modulo;\\n\\t\\t\\t\\tcurrent = (current + i)%modulo;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn (int)current;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2612834,
                "title": "c-solution",
                "content": "```\\nint mod = 1e9+7; \\n\\nint concatenatedBinary(int n){\\n    long ans = 0;\\n    int k = 0;\\n    for (int i = 1 ; i <= n ; i++){\\n        if ((i & (i-1)) == 0){\\n            k++;\\n        }\\n        ans <<= k;\\n        ans |= i;\\n        ans %= mod;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint mod = 1e9+7; \\n\\nint concatenatedBinary(int n){\\n    long ans = 0;\\n    int k = 0;\\n    for (int i = 1 ; i <= n ; i++){\\n        if ((i & (i-1)) == 0){\\n            k++;\\n        }\\n        ans <<= k;\\n        ans |= i;\\n        ans %= mod;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2612810,
                "title": "c-solution-bit-manipulation-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/637abd8d-1252-4b74-b076-34c2ace3c940_1663910848.5433705.png)\\n\\n\\n```\\npublic int ConcatenatedBinary(int n) {\\n        long res = 0;\\n        int shift = 0;\\n        int m = 1000000007;\\n        \\n        for(int i=1; i<=n; i++){\\n            if((i&(i-1)) == 0)\\n                shift++;\\n\\n            res = ((res<<shift) | i)%m;\\n        }\\n        \\n        return (int)(res%m);\\n    }\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\npublic int ConcatenatedBinary(int n) {\\n        long res = 0;\\n        int shift = 0;\\n        int m = 1000000007;\\n        \\n        for(int i=1; i<=n; i++){\\n            if((i&(i-1)) == 0)\\n                shift++;\\n\\n            res = ((res<<shift) | i)%m;\\n        }\\n        \\n        return (int)(res%m);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2612739,
                "title": "java-concise-o-n-with-explanation",
                "content": "First of all, the number of left-shifts is the number of `2` we need to multiply.\\n\\nFor instance, when `n = 3`,\\n* It is `1`, `10`, and `11`.\\n* We start with `1`, and we left-shift 2 positions after we add `10`, which get us `110`  `= ` `1 * 2 * 2 + 2 = 6`.\\n* And then we left-shift two positions again after we add `11`, which give us `11011` `=` `6 * 2 * 2 + 3 = 27`.\\n\\n```\\n    private static int MOD = 1000000007;\\n\\n    public int concatenatedBinary(int n) {\\n        long ans = 0;\\n        int highest = 2;\\n        for (int i = 1; i <= n; i++) {\\n            if (i >= highest) {\\n                highest *= 2;\\n            }\\n            ans = (ans * highest + i) % MOD;\\n        }\\n        return (int) ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n    private static int MOD = 1000000007;\\n\\n    public int concatenatedBinary(int n) {\\n        long ans = 0;\\n        int highest = 2;\\n        for (int i = 1; i <= n; i++) {\\n            if (i >= highest) {\\n                highest *= 2;\\n            }\\n            ans = (ans * highest + i) % MOD;\\n        }\\n        return (int) ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2612684,
                "title": "c-bit-manipulation-6-lines-clean-and-concise",
                "content": "**Video Explanation :**\\n[https://www.youtube.com/watch?v=97UNhXjpiVc](http://)\\n\\n**Code :** \\n```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int concatenatedBinary(int n) {\\n        \\n        long long int ans=0;\\n        int p=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int tt=log2(i);\\n            ans=((ans<<(tt+1))%mod+i)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int concatenatedBinary(int n) {\\n        \\n        long long int ans=0;\\n        int p=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int tt=log2(i);\\n            ans=((ans<<(tt+1))%mod+i)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612635,
                "title": "java-bitwise-operation-3-solutions",
                "content": "\\n# one line solution:\\n```\\n\\n    //Runtime: 311 ms, faster than 54.55% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    //Memory Usage: 42.3 MB, less than 29.87% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    public int concatenatedBinary(int n) {\\n        return (int) LongStream.range(2, n + 1)\\n                .reduce(1, (sum, i) -> ((sum << Long.toBinaryString(i).length()) | i) % 1_000_000_007);\\n    }\\n```\\n\\n\\n# Bitwise operation\\n```\\n\\t//Runtime: 84 ms, faster than 90.91% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    //Memory Usage: 40.8 MB, less than 81.82% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    //Bitwise operation\\n    //Time: O(N); Space: O(1)\\n    public int concatenatedBinary(int n) {\\n        final int MODULO = 1_000_000_007;\\n\\n        long res = 1, shift = 1;\\n        for (int i = 2; i <= n; i++){\\n            if ((i & (i - 1)) == 0) shift++;\\n            res = ((res << shift) | i) % MODULO;\\n        }\\n        return (int) (res);\\n    }\\n```\\n\\n\\n\\n```\\n    //Runtime: 468 ms, faster than 46.75% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    //Memory Usage: 121.9 MB, less than 5.19% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    //Integer.toBinaryString\\n    //Time: O(N * lgN); Space: O(N)\\n    public int concatenatedBinary_1(int n) {\\n        final int MODULO = 1_000_000_007;\\n\\n        long res = 1;\\n        for (int i = 2; i <= n; i++){\\n            int shift = Integer.toBinaryString(i).length(); //consume time....\\n//            int shift = Integer.toString(i, 2).length();\\n            res = ((res << shift) | i) % MODULO;\\n        }\\n        return (int) (res);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    //Runtime: 311 ms, faster than 54.55% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    //Memory Usage: 42.3 MB, less than 29.87% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    public int concatenatedBinary(int n) {\\n        return (int) LongStream.range(2, n + 1)\\n                .reduce(1, (sum, i) -> ((sum << Long.toBinaryString(i).length()) | i) % 1_000_000_007);\\n    }\\n```\n```\\n\\t//Runtime: 84 ms, faster than 90.91% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    //Memory Usage: 40.8 MB, less than 81.82% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    //Bitwise operation\\n    //Time: O(N); Space: O(1)\\n    public int concatenatedBinary(int n) {\\n        final int MODULO = 1_000_000_007;\\n\\n        long res = 1, shift = 1;\\n        for (int i = 2; i <= n; i++){\\n            if ((i & (i - 1)) == 0) shift++;\\n            res = ((res << shift) | i) % MODULO;\\n        }\\n        return (int) (res);\\n    }\\n```\n```\\n    //Runtime: 468 ms, faster than 46.75% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    //Memory Usage: 121.9 MB, less than 5.19% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    //Integer.toBinaryString\\n    //Time: O(N * lgN); Space: O(N)\\n    public int concatenatedBinary_1(int n) {\\n        final int MODULO = 1_000_000_007;\\n\\n        long res = 1;\\n        for (int i = 2; i <= n; i++){\\n            int shift = Integer.toBinaryString(i).length(); //consume time....\\n//            int shift = Integer.toString(i, 2).length();\\n            res = ((res << shift) | i) % MODULO;\\n        }\\n        return (int) (res);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2612612,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        const long MOD= 1e9+7;\\n        long long ans=0;\\n        for (int i=1;i<=n;i++) {\\n            \\n            ans=ans<<(long)(log2(i)+1);\\n            ans=(ans|i)%MOD;\\n        }\\n                      return ans%MOD;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        const long MOD= 1e9+7;\\n        long long ans=0;\\n        for (int i=1;i<=n;i++) {\\n            \\n            ans=ans<<(long)(log2(i)+1);\\n            ans=(ans|i)%MOD;\\n        }\\n                      return ans%MOD;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612588,
                "title": "0-ms",
                "content": "Calculating `dp` once for all numbers, then every test case is O(1).\\n**C++**\\n```cpp\\nlong long dp[100001] = {};\\nclass Solution {\\npublic:\\nint concatenatedBinary(int n) {\\n    if (!dp[1])\\n        for (auto i = 1; i <= 100000; ++i)\\n            dp[i] = ((dp[i - 1] << ((int)log2(i) + 1)) + i) % 1000000007;\\n    return dp[n];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long dp[100001] = {};\\nclass Solution {\\npublic:\\nint concatenatedBinary(int n) {\\n    if (!dp[1])\\n        for (auto i = 1; i <= 100000; ++i)\\n            dp[i] = ((dp[i - 1] << ((int)log2(i) + 1)) + i) % 1000000007;\\n    return dp[n];\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612509,
                "title": "c-96-65-faster-than-all-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        int next = 1, length = 1;\\n        long max_n = pow(10, 9) + 7, result = 0;\\n        for (int i = 0; i <= n; i++) {\\n            if (i == next) {\\n                next *= 2;\\n                length++;\\n            }\\n            \\n            result = (result * next + i) % max_n;\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        int next = 1, length = 1;\\n        long max_n = pow(10, 9) + 7, result = 0;\\n        for (int i = 0; i <= n; i++) {\\n            if (i == next) {\\n                next *= 2;\\n                length++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2612492,
                "title": "swift-fast-and-simple-solution",
                "content": "```\\nclass Solution {\\n    func concatenatedBinary(_ n: Int) -> Int {\\n        var binaryArray = [Bool]()\\n        for i in 1...n {\\n            binaryArray += i.toBinary()\\n        }\\n        var result = 0\\n        for bool in binaryArray {\\n            result = result * 2 % 1000000007\\n            if bool {\\n                result += 1\\n            }\\n        }\\n        return result\\n    }\\n}\\n\\nextension Int {\\n    func toBinary() -> [Bool] {\\n        var i = self\\n        var result = [Bool]()\\n        while i != 0 {\\n            if i % 2 != 0 {\\n                result.insert(true, at: 0)\\n            } else {\\n                result.insert(false, at: 0)\\n            }\\n            i /= 2\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func concatenatedBinary(_ n: Int) -> Int {\\n        var binaryArray = [Bool]()\\n        for i in 1...n {\\n            binaryArray += i.toBinary()\\n        }\\n        var result = 0\\n        for bool in binaryArray {\\n            result = result * 2 % 1000000007\\n            if bool {\\n                result += 1\\n            }\\n        }\\n        return result\\n    }\\n}\\n\\nextension Int {\\n    func toBinary() -> [Bool] {\\n        var i = self\\n        var result = [Bool]()\\n        while i != 0 {\\n            if i % 2 != 0 {\\n                result.insert(true, at: 0)\\n            } else {\\n                result.insert(false, at: 0)\\n            }\\n            i /= 2\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612485,
                "title": "python-3-line-solution-easy-approach",
                "content": "\\n        bin_str = \\'\\'\\n        for i in range(1, n+1): bin_str += bin(i)[2:]\\n        return int(bin_str, 2)%(10**9 + 7)",
                "solutionTags": [],
                "code": "\\n        bin_str = \\'\\'\\n        for i in range(1, n+1): bin_str += bin(i)[2:]\\n        return int(bin_str, 2)%(10**9 + 7)",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570251,
                "content": [
                    {
                        "username": "ToffeeLu",
                        "content": "Generally, 10^5 means it could accept even O(nlogn) solutions, but actually it could not accept O(32n) solution.\\nAlso the run & submit button are not consistent, when I click run for the largest test case 100000, it goes well, but when I submit, TLE for a smaller test case.\\nNot to say this question is harder for some language.\\nBad question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "100 medium questions solved yay"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "congrats broo!\\n"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "congratulations mate! Wish you best wishes"
                    },
                    {
                        "username": "piyushboorra",
                        "content": " ` int concatenatedBinary(int n) {\n        int M=1e9+7;\n\n        vector<int>pref(n+1);\n\n        long long int ans=0;\n\n        pref[n]=0;\n\n        for(int i=n-1;i>=1;i--)\n\n        {\n            pref[i]=pref[i+1]+(log2(i+1)+1);\n\n        }\n        for(long long int i=1;i<=n;i++)\n\n        {\n            ans|=((i<<pref[i])%M);\n\n        }\n        return ans%M;\n\n    }`\nwhy this code fails on 3rd sample test case(when n=12) ?"
                    }
                ]
            },
            {
                "id": 1979089,
                "content": [
                    {
                        "username": "ToffeeLu",
                        "content": "Generally, 10^5 means it could accept even O(nlogn) solutions, but actually it could not accept O(32n) solution.\\nAlso the run & submit button are not consistent, when I click run for the largest test case 100000, it goes well, but when I submit, TLE for a smaller test case.\\nNot to say this question is harder for some language.\\nBad question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "100 medium questions solved yay"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "congrats broo!\\n"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "congratulations mate! Wish you best wishes"
                    },
                    {
                        "username": "piyushboorra",
                        "content": " ` int concatenatedBinary(int n) {\n        int M=1e9+7;\n\n        vector<int>pref(n+1);\n\n        long long int ans=0;\n\n        pref[n]=0;\n\n        for(int i=n-1;i>=1;i--)\n\n        {\n            pref[i]=pref[i+1]+(log2(i+1)+1);\n\n        }\n        for(long long int i=1;i<=n;i++)\n\n        {\n            ans|=((i<<pref[i])%M);\n\n        }\n        return ans%M;\n\n    }`\nwhy this code fails on 3rd sample test case(when n=12) ?"
                    }
                ]
            },
            {
                "id": 2005613,
                "content": [
                    {
                        "username": "ToffeeLu",
                        "content": "Generally, 10^5 means it could accept even O(nlogn) solutions, but actually it could not accept O(32n) solution.\\nAlso the run & submit button are not consistent, when I click run for the largest test case 100000, it goes well, but when I submit, TLE for a smaller test case.\\nNot to say this question is harder for some language.\\nBad question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "100 medium questions solved yay"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "congrats broo!\\n"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "congratulations mate! Wish you best wishes"
                    },
                    {
                        "username": "piyushboorra",
                        "content": " ` int concatenatedBinary(int n) {\n        int M=1e9+7;\n\n        vector<int>pref(n+1);\n\n        long long int ans=0;\n\n        pref[n]=0;\n\n        for(int i=n-1;i>=1;i--)\n\n        {\n            pref[i]=pref[i+1]+(log2(i+1)+1);\n\n        }\n        for(long long int i=1;i<=n;i++)\n\n        {\n            ans|=((i<<pref[i])%M);\n\n        }\n        return ans%M;\n\n    }`\nwhy this code fails on 3rd sample test case(when n=12) ?"
                    }
                ]
            }
        ]
    }
]