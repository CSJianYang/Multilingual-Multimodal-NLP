[
    {
        "title": "Lowest Common Ancestor of a Binary Search Tree",
        "question_content": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: &ldquo;The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).&rdquo;\n&nbsp;\nExample 1:\n\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\nOutput: 6\nExplanation: The LCA of nodes 2 and 8 is 6.\n\nExample 2:\n\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\nOutput: 2\nExplanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\n\nExample 3:\n\nInput: root = [2,1], p = 2, q = 1\nOutput: 2\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [2, 105].\n\t-109 <= Node.val <= 109\n\tAll Node.val are unique.\n\tp != q\n\tp and q will exist in the BST.",
        "solutions": [
            {
                "id": 64963,
                "title": "3-lines-with-o-1-space-1-liners-alternatives",
                "content": "Just walk down from the whole tree's root as long as both p and q are in the same subtree (meaning their values are both smaller or both larger than root's). This walks straight from the root to the LCA, not looking at the rest of the tree, so it's pretty much as fast as it gets. A few ways to do it:\\n\\n**Iterative, O(1) space**\\n\\nPython\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        while (root.val - p.val) * (root.val - q.val) > 0:\\n            root = (root.left, root.right)[p.val > root.val]\\n        return root\\n\\nJava\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        while ((root.val - p.val) * (root.val - q.val) > 0)\\n            root = p.val < root.val ? root.left : root.right;\\n        return root;\\n    }\\n\\n(in case of overflow, I'd do `(root.val - (long)p.val) * (root.val - (long)q.val)`)\\n\\nDifferent Python\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        a, b = sorted([p.val, q.val])\\n        while not a <= root.val <= b:\\n            root = (root.left, root.right)[a > root.val]\\n        return root\\n\\n\"Long\" Python, maybe easiest to understand\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        while root:\\n            if p.val < root.val > q.val:\\n                root = root.left\\n            elif p.val > root.val < q.val:\\n                root = root.right\\n            else:\\n                return root\\n\\n**Recursive**\\n\\nPython\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        next = p.val < root.val > q.val and root.left or \\\\\\n               p.val > root.val < q.val and root.right\\n        return self.lowestCommonAncestor(next, p, q) if next else root\\n\\nPython One-Liner\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        return root if (root.val - p.val) * (root.val - q.val) < 1 else \\\\\\n               self.lowestCommonAncestor((root.left, root.right)[p.val > root.val], p, q)\\n\\nJava One-Liner\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        return (root.val - p.val) * (root.val - q.val) < 1 ? root :\\n               lowestCommonAncestor(p.val < root.val ? root.left : root.right, p, q);\\n    }\\n\\n\"Long\" Python, maybe easiest to understand\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        if p.val < root.val > q.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        if p.val > root.val < q.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        return root",
                "solutionTags": [],
                "code": "Just walk down from the whole tree's root as long as both p and q are in the same subtree (meaning their values are both smaller or both larger than root's). This walks straight from the root to the LCA, not looking at the rest of the tree, so it's pretty much as fast as it gets. A few ways to do it:\\n\\n**Iterative, O(1) space**\\n\\nPython\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        while (root.val - p.val) * (root.val - q.val) > 0:\\n            root = (root.left, root.right)[p.val > root.val]\\n        return root\\n\\nJava\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        while ((root.val - p.val) * (root.val - q.val) > 0)\\n            root = p.val < root.val ? root.left : root.right;\\n        return root;\\n    }\\n\\n(in case of overflow, I'd do `(root.val - (long)p.val) * (root.val - (long)q.val)`)\\n\\nDifferent Python\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        a, b = sorted([p.val, q.val])\\n        while not a <= root.val <= b:\\n            root = (root.left, root.right)[a > root.val]\\n        return root\\n\\n\"Long\" Python, maybe easiest to understand\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        while root:\\n            if p.val < root.val > q.val:\\n                root = root.left\\n            elif p.val > root.val < q.val:\\n                root = root.right\\n            else:\\n                return root\\n\\n**Recursive**\\n\\nPython\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        next = p.val < root.val > q.val and root.left or \\\\\\n               p.val > root.val < q.val and root.right\\n        return self.lowestCommonAncestor(next, p, q) if next else root\\n\\nPython One-Liner\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        return root if (root.val - p.val) * (root.val - q.val) < 1 else \\\\\\n               self.lowestCommonAncestor((root.left, root.right)[p.val > root.val], p, q)\\n\\nJava One-Liner\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        return (root.val - p.val) * (root.val - q.val) < 1 ? root :\\n               lowestCommonAncestor(p.val < root.val ? root.left : root.right, p, q);\\n    }\\n\\n\"Long\" Python, maybe easiest to understand\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        if p.val < root.val > q.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        if p.val > root.val < q.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        return root",
                "codeTag": "Python3"
            },
            {
                "id": 64980,
                "title": "c-recursive-and-iterative",
                "content": "Well, remember to take advantage of the property of binary search trees, which is, `node -> left -> val < node -> val < node -> right -> val`. Moreover, both `p` and `q` will be the descendants of the `root` of the subtree that contains both of them. And the `root` with the largest depth is just the lowest common ancestor. This idea can be turned into the following simple recursive code.\\n\\n```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if ((root -> val > p -> val) && (root -> val > q -> val)) {\\n            return lowestCommonAncestor(root -> left, p, q);\\n        }\\n        if ((root -> val < p -> val) && (root -> val < q -> val)) {\\n            return lowestCommonAncestor(root -> right, p, q);\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\nOf course, we can also solve it iteratively.\\n\\n```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* cur = root;\\n        while (true) {\\n            if (p -> val < cur -> val && q -> val < cur -> val) {\\n                cur = cur -> left;\\n            } else if (p -> val > cur -> val && q -> val > cur -> val) {\\n                cur = cur -> right;\\n            } else {\\n                break;\\n            }\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if ((root -> val > p -> val) && (root -> val > q -> val)) {\\n            return lowestCommonAncestor(root -> left, p, q);\\n        }\\n        if ((root -> val < p -> val) && (root -> val < q -> val)) {\\n            return lowestCommonAncestor(root -> right, p, q);\\n        }\\n        return root;\\n    }\\n};\\n```\n```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* cur = root;\\n        while (true) {\\n            if (p -> val < cur -> val && q -> val < cur -> val) {\\n                cur = cur -> left;\\n            } else if (p -> val > cur -> val && q -> val > cur -> val) {\\n                cur = cur -> right;\\n            } else {\\n                break;\\n            }\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347857,
                "title": "c-java-python-iterate-in-bst-picture-explain-time-o-h-space-o-1",
                "content": "**\\u2714\\uFE0F Solution 1: Iterate in BST**\\n- Let `large = max(p.val, q.val)`, `small = min(p.val, q.val)`.\\n- We keep iterate `root` in our BST:\\n\\t- If `root.val > large` then both node `p` and `q` belong to the left subtree, go to left by `root = root.left`.\\n\\t- If `root.val < small` then both node `p` and `q` belong to the right subtree, go to right by `root = root.right`.\\n\\t- Now, `small <= root.val <= large` the current `root` is the LCA between `q` and `p`.\\n\\n![image](https://assets.leetcode.com/users/images/c9441871-3cdd-49fa-b4f4-7ab1f88779f1_1626682525.9321432.png)\\n\\n<iframe src=\"https://leetcode.com/playground/QdSyKrz6/shared\" frameBorder=\"0\" width=\"100%\" height=\"350\"></iframe>\\n\\nComplexity:\\n- Time: `O(H)`, where `H` is the heigh of Binary Tree.\\n- Space: `O(1)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Find LCA of general Binary Tree**\\n- There are two other solutions, which take `O(N)` in Time Complexity to find the LCA between `p` and `q` in the general **Binary Tree**, please check out this article: [236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/1306476)\\n\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome**! Thanks.",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Solution 1: Iterate in BST**\\n- Let `large = max(p.val, q.val)`, `small = min(p.val, q.val)`.\\n- We keep iterate `root` in our BST:\\n\\t- If `root.val > large` then both node `p` and `q` belong to the left subtree, go to left by `root = root.left`.\\n\\t- If `root.val < small` then both node `p` and `q` belong to the right subtree, go to right by `root = root.right`.\\n\\t- Now, `small <= root.val <= large` the current `root` is the LCA between `q` and `p`.\\n\\n![image](https://assets.leetcode.com/users/images/c9441871-3cdd-49fa-b4f4-7ab1f88779f1_1626682525.9321432.png)\\n\\n<iframe src=\"https://leetcode.com/playground/QdSyKrz6/shared\" frameBorder=\"0\" width=\"100%\" height=\"350\"></iframe>\\n\\nComplexity:\\n- Time: `O(H)`, where `H` is the heigh of Binary Tree.\\n- Space: `O(1)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Find LCA of general Binary Tree**\\n- There are two other solutions, which take `O(N)` in Time Complexity to find the LCA between `p` and `q` in the general **Binary Tree**, please check out this article: [236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/1306476)\\n\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome**! Thanks.",
                "codeTag": "Unknown"
            },
            {
                "id": 64954,
                "title": "my-java-solution",
                "content": "    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if(root.val > p.val && root.val > q.val){\\n                return lowestCommonAncestor(root.left, p, q);\\n            }else if(root.val < p.val && root.val < q.val){\\n                return lowestCommonAncestor(root.right, p, q);\\n            }else{\\n                return root;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if(root.val > p.val && root.val > q.val){\\n                return lowestCommonAncestor(root.left, p, q);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 65074,
                "title": "python-iterative-solution",
                "content": "    class Solution:\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        while root:\\n            if root.val > p.val and root.val > q.val:\\n                root = root.left\\n            elif root.val < p.val and root.val < q.val:\\n                root = root.right\\n            else:\\n                return root",
                "solutionTags": [],
                "code": "    class Solution:\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        while root:\\n            if root.val > p.val and root.val > q.val:\\n                root = root.left\\n            elif root.val < p.val and root.val < q.val:\\n                root = root.right\\n            else:\\n                return root",
                "codeTag": "Java"
            },
            {
                "id": 1394823,
                "title": "explained-easy-iterative-python-solution",
                "content": "We will rely upon the invariant of the BST to solve the exercise. We know that the left subtree of each node contains nodes with smaller values and the right subtree contains nodes with greater values. We also know that if two nodes, x and y, are on different subtrees of a node z (one in the left portion and one in the right portion), then x and y have z as the lowest common ancestor. Having these facts in mind, a possible solution looks like the following:\\n\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        while True:\\n            if root.val > p.val and root.val > q.val:\\n                root = root.left\\n            elif root.val < p.val and root.val < q.val:\\n                root = root.right\\n            else:\\n                return root\\n```\\n\\nNote: Since we are guaranteed that p and q exist in the tree, we do not need to check for edges cases.\\n\\nConsider upvoting, if you found this post useful. :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        while True:\\n            if root.val > p.val and root.val > q.val:\\n                root = root.left\\n            elif root.val < p.val and root.val < q.val:\\n                root = root.right\\n            else:\\n                return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65183,
                "title": "my-python-recursive-solution",
                "content": "\\n\\n    class Solution:\\n        # @param {TreeNode} root\\n        # @param {TreeNode} p\\n        # @param {TreeNode} q\\n        # @return {TreeNode}\\n        def lowestCommonAncestor(self, root, p, q):\\n            if not root or not p or not q:\\n                return None\\n            if (max(p.val, q.val) < root.val):\\n                return self.lowestCommonAncestor(root.left, p, q)\\n            elif (min(p.val, q.val) > root.val):\\n                return self.lowestCommonAncestor(root.right, p, q)\\n            else:\\n                return root",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 1347824,
                "title": "c-simple-and-efficient-short-recursive-iterative-solutions",
                "content": "**Recursive:**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (p->val < root->val && q->val < root->val)\\n            return lowestCommonAncestor(root->left, p, q);\\n        else if (p->val > root->val && q->val > root->val)\\n            return lowestCommonAncestor(root->right, p, q);\\n        else return root;\\n    }\\n};\\n```\\n****\\n**Iterative:**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while (root) {\\n            if (p->val < root->val && q->val < root->val) root = root->left;\\n            else if (p->val > root->val && q->val > root->val) root = root->right;\\n            else return root;\\n        }\\n        return root;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (p->val < root->val && q->val < root->val)\\n            return lowestCommonAncestor(root->left, p, q);\\n        else if (p->val > root->val && q->val > root->val)\\n            return lowestCommonAncestor(root->right, p, q);\\n        else return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while (root) {\\n            if (p->val < root->val && q->val < root->val) root = root->left;\\n            else if (p->val > root->val && q->val > root->val) root = root->right;\\n            else return root;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 64955,
                "title": "clear-java-10-ms",
                "content": "    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==null) return null;\\n        if(p.val<root.val&&q.val<root.val) {\\n            return lowestCommonAncestor(root.left,p,q);\\n        }\\n        else if(p.val>root.val&&q.val>root.val){\\n            return lowestCommonAncestor(root.right,p,q);\\n        }\\n        else\\n        return root;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==null) return null;\\n        if(p.val<root.val&&q.val<root.val) {\\n            return lowestCommonAncestor(root.left,p,q);\\n        }\\n        else if(p.val>root.val&&q.val>root.val){\\n            return lowestCommonAncestor(root.right,p,q);\\n        }\\n        else\\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 541362,
                "title": "javascript-iterative-recursive",
                "content": "### Iterative solution\\n- Time Complexity: O(H)\\n- Space Complexity: O(1)\\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function(root, p, q) {\\n    while (root) {\\n        if (root.val < p.val && root.val < q.val) {\\n            root = root.right;\\n        }\\n        else if (root.val > p.val && root.val > q.val) {\\n            root = root.left;\\n        } else {\\n            break;\\n        }\\n    }\\n    return root;\\n};\\n```\\n### Recursive solution\\n- Time Complexity: O(H)\\n- Space Complexity: O(H)\\n\\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if (root.val < p.val && root.val < q.val) {\\n        return lowestCommonAncestor(root.right, p, q);\\n    }\\n    if (root.val > p.val && root.val > q.val) {\\n        return lowestCommonAncestor(root.left, p, q);\\n    }\\n    return root;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function(root, p, q) {\\n    while (root) {\\n        if (root.val < p.val && root.val < q.val) {\\n            root = root.right;\\n        }\\n        else if (root.val > p.val && root.val > q.val) {\\n            root = root.left;\\n        } else {\\n            break;\\n        }\\n    }\\n    return root;\\n};\\n```\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if (root.val < p.val && root.val < q.val) {\\n        return lowestCommonAncestor(root.right, p, q);\\n    }\\n    if (root.val > p.val && root.val > q.val) {\\n        return lowestCommonAncestor(root.left, p, q);\\n    }\\n    return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1348584,
                "title": "java-lowest-common-ancestor-of-bst-explained-solution",
                "content": "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n    \\n\\t// it is BST so that we should take advantage of it\\n\\t// there is only three cases\\n\\t\\n\\t// 1st one is that if both p & q are smaller than the root then call the left subtree\\n        if(p.val < root.val && q.val < root.val)\\n\\t\\t{\\n            return lowestCommonAncestor(root.left,p,q);\\n        }\\n\\t\\t// 2nd if both p & q are greter than the root then call the right subtree\\n\\t\\telse if(p.val > root.val && q.val > root.val)\\n\\t\\t{\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n\\t\\t// 3rd is that we get our answer that is root :)\\n\\t\\telse\\n\\t\\t{\\n            return root;\\n        }\\n        \\n    }\\n}\\n\\n<<<<<<<<<<< upvote if you like it >>>>>>>>>>>>",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n    \\n\\t// it is BST so that we should take advantage of it\\n\\t// there is only three cases\\n\\t\\n\\t// 1st one is that if both p & q are smaller than the root then call the left subtree\\n        if(p.val < root.val && q.val < root.val)\\n\\t\\t{\\n            return lowestCommonAncestor(root.left,p,q);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2414941,
                "title": "python-detailed-explanation-easily-understood-o-h-o-n",
                "content": "Method 1: `O(n)`\\nWe can search through the tree\\n```\\n1) If the value p or q exist the left/right subtree\\n\\t-  return the node\\n2) Until a node have both left and right nodes return, it is the LCA of p and q.\\n   Else, either left or right node is the LCA\\n```\\n```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\t\\tdef find_lca(root, p, q):\\n\\t\\t\\tif root in [p, q, None]:\\n\\t\\t\\t\\treturn root\\n\\n\\t\\t\\tleft = find_lca(root.left, p, q)\\n\\t\\t\\tright = find_lca(root.right, p, q)\\n\\n\\t\\t\\tif left is not None and right is not None: \\n\\t\\t\\t\\treturn root\\n\\t\\t\\telif left is not None: \\n\\t\\t\\t\\treturn left\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn right\\n\\n\\t\\tif p.val == q.val:\\n\\t\\t\\treturn root\\n\\n\\t\\treturn find_lca(root, p, q)\\n```\\n**Time Complexity**: `O(n)`\\n**Space Complexity**: `O(n)`\\n<br/>\\n\\nMethod 2: `O(h)` where h is the height of the tree\\nFirst, we could set 3 condition to find out which subtree(s) do `p` and `q` place.\\n\\nLet `min_val` be `min(p.val, q.val)`\\nand `max_val` be `max(p.val, q.val)`\\n\\n```\\n1) min_val <= node.val <= max_val\\n\\t- It means min_val is inside the left subtree and max_val is inside the right subtree\\n\\t  -> The LCA is the node\\n\\t  \\n2) min_val < max_val < node.val\\n\\t- It means min_val and max_val are inside the left subtree\\n\\t  -> The LCA is inside the left subtree\\n\\t  \\n3) node.val  > max_val  > min_val\\n\\t- It means min_val and max_val are inside the right subtree\\n\\t  -> The LCA is inside the right subtree\\n```\\n\\n```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\tif p.val < q.val:\\n\\t\\tmin_val = p.val\\n\\t\\tmax_val = q.val\\n\\telse:\\n\\t\\tmin_val = q.val\\n\\t\\tmax_val = p.val\\n\\n\\twhile True:\\n\\t\\tif min_val <= root.val <= max_val:\\n\\t\\t\\treturn root\\n\\t\\telif max_val < root.val:\\n\\t\\t\\troot = root.left\\n\\t\\telse:\\n\\t\\t\\troot = root.right\\n```\\n**Time Complexity**: `O(h)` where h is the height of the tree\\n**Space Complexity**: `O(1)`",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n1) If the value p or q exist the left/right subtree\\n\\t-  return the node\\n2) Until a node have both left and right nodes return, it is the LCA of p and q.\\n   Else, either left or right node is the LCA\\n```\n```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\t\\tdef find_lca(root, p, q):\\n\\t\\t\\tif root in [p, q, None]:\\n\\t\\t\\t\\treturn root\\n\\n\\t\\t\\tleft = find_lca(root.left, p, q)\\n\\t\\t\\tright = find_lca(root.right, p, q)\\n\\n\\t\\t\\tif left is not None and right is not None: \\n\\t\\t\\t\\treturn root\\n\\t\\t\\telif left is not None: \\n\\t\\t\\t\\treturn left\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn right\\n\\n\\t\\tif p.val == q.val:\\n\\t\\t\\treturn root\\n\\n\\t\\treturn find_lca(root, p, q)\\n```\n```\\n1) min_val <= node.val <= max_val\\n\\t- It means min_val is inside the left subtree and max_val is inside the right subtree\\n\\t  -> The LCA is the node\\n\\t  \\n2) min_val < max_val < node.val\\n\\t- It means min_val and max_val are inside the left subtree\\n\\t  -> The LCA is inside the left subtree\\n\\t  \\n3) node.val  > max_val  > min_val\\n\\t- It means min_val and max_val are inside the right subtree\\n\\t  -> The LCA is inside the right subtree\\n```\n```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\tif p.val < q.val:\\n\\t\\tmin_val = p.val\\n\\t\\tmax_val = q.val\\n\\telse:\\n\\t\\tmin_val = q.val\\n\\t\\tmax_val = p.val\\n\\n\\twhile True:\\n\\t\\tif min_val <= root.val <= max_val:\\n\\t\\t\\treturn root\\n\\t\\telif max_val < root.val:\\n\\t\\t\\troot = root.left\\n\\t\\telse:\\n\\t\\t\\troot = root.right\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 65093,
                "title": "simple-java-solution",
                "content": "    If the given both nodes values are less than that of root, then both the nodes must be on the left side of the root , so now we have to check only left tree of the root.\\n    Otherwise If the given both nodes values are greater than that of root, then both the nodes must be on the right side of the root , so now we have to check only right tree of the root.\\n    Otherwise . both the nodes will be on the either side of the root, this implies the lowest common ancestor is root.\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if(p.val < root.val && q.val < root.val){\\n            return lowestCommonAncestor(root.left,p,q);}\\n            else if(p.val > root.val && q.val > root.val){\\n            return lowestCommonAncestor(root.right,p,q);}\\n            else{\\n            return root;}\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    If the given both nodes values are less than that of root, then both the nodes must be on the left side of the root , so now we have to check only left tree of the root.\\n    Otherwise If the given both nodes values are greater than that of root, then both the nodes must be on the right side of the root , so now we have to check only right tree of the root.\\n    Otherwise . both the nodes will be on the either side of the root, this implies the lowest common ancestor is root.\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if(p.val < root.val && q.val < root.val){\\n            return lowestCommonAncestor(root.left,p,q);}\\n            else if(p.val > root.val && q.val > root.val){\\n            return lowestCommonAncestor(root.right,p,q);}\\n            else{\\n            return root;}\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2413331,
                "title": "python-easiest-solution-detailed-graph-explantion-dfs-beginner-friendly",
                "content": "![image](https://assets.leetcode.com/users/images/44e4d220-c0b3-496e-94fb-ca29f3721af3_1660267475.6685576.png)\\n\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        # found what we want or there is nothing \\n        if (root == p or root == q or not root): return root \\n        \\n        #recursion\\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q) \\n        \\n        if left and right: return root    # found common ancestor \\n        elif left: return left\\n        elif right: return right\\n```\\n**Please UPVOTE if you LIKE !!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        # found what we want or there is nothing \\n        if (root == p or root == q or not root): return root \\n        \\n        #recursion\\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q) \\n        \\n        if left and right: return root    # found common ancestor \\n        elif left: return left\\n        elif right: return right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65008,
                "title": "11ms-java-solution-3-lines",
                "content": "     public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root.val<Math.min(p.val,q.val)) return lowestCommonAncestor(root.right,p,q);\\n        if(root.val>Math.max(p.val,q.val)) return lowestCommonAncestor(root.left,p,q);\\n        return root;\\n    }",
                "solutionTags": [],
                "code": "     public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root.val<Math.min(p.val,q.val)) return lowestCommonAncestor(root.right,p,q);\\n        if(root.val>Math.max(p.val,q.val)) return lowestCommonAncestor(root.left,p,q);\\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2413386,
                "title": "java-4ms-100-faster-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\n\\tpublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n\\t// Base Case\\n        if (root == null) {\\n            return null;\\n        } else if (p.val < root.val && q.val < root.val) { // if current root value is greater than both p and q value that means root is in left of current root\\n            return lowestCommonAncestor(root.left, p, q); \\n        } else if (p.val > root.val && q.val > root.val) { // if current root value is lesser than both p and q value that means root is in right of current root\\n            return lowestCommonAncestor(root.right, p, q);\\n        } else {\\n            return root; // if root value is between both left and right of the root then we got the least common ancestor\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\n\\tpublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n\\t// Base Case\\n        if (root == null) {\\n            return null;\\n        } else if (p.val < root.val && q.val < root.val) { // if current root value is greater than both p and q value that means root is in left of current root\\n            return lowestCommonAncestor(root.left, p, q); \\n        } else if (p.val > root.val && q.val > root.val) { // if current root value is lesser than both p and q value that means root is in right of current root\\n            return lowestCommonAncestor(root.right, p, q);\\n        } else {\\n            return root; // if root value is between both left and right of the root then we got the least common ancestor\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3575320,
                "title": "beats-100-log-n-only-3-lines-code-best-explaination-c-python-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First we will check that the node is null or not \\n- if both Q,P are smaller then ROOT then it will be in left.\\n- if both q,p are grater then root then it will be in right.\\n- if not the current root is the answer!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(H)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return nullptr;\\n        if(root->val>p->val&&root->val>q->val) return lowestCommonAncestor(root->left,p,q);\\n        if(root->val<p->val&&root->val<q->val) return lowestCommonAncestor(root->right,p,q);\\n        return root;        \\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/528179d1-2cbe-47c7-a3c9-79372d690859_1685362528.162892.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return nullptr;\\n        if(root->val>p->val&&root->val>q->val) return lowestCommonAncestor(root->left,p,q);\\n        if(root->val<p->val&&root->val<q->val) return lowestCommonAncestor(root->right,p,q);\\n        return root;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237609,
                "title": "java-solution-easy-solution-5ms-runtime-interesting-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn the first place when i understood the problem description it was clear that i have to use DFS ofcourse and as it is based on Binary Search Tree (BST), i got to an interesting observation that we know ancestor will be that node at which the two given nodes `p` and `q` will split or wont be a part of same subtree after that particular node.\\nSo lets see how to solve it.\\n\\n**Problem Link** : https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is quite straight forward. The Algorithm will check if `p` and `q` falls under same subtree i.e the left one or right one then it will recursively call that subtree to search the ancestor.\\nOtherwise if `p` and `q` are separated and they belongs to different subtree then that particular node is the ancestor.\\n\\nFor example\\n```\\np = 3\\nq = 5\\n```\\nlets say `current node = 6` then we know that the `p` and `q` will fall under left subtree of this particular node.\\nAgain lets say the `current node = 2` then we know that `p` and `q` will fall under right subtree of the particular node. \\n\\nFor above these situations we will search through that particular subtree recursively.\\nNow if these conditions doesn\\'t satisfied, there will be 2 cases and we will simply return that current node. \\n\\n**Cases:**\\n- The current node is equals to any of `p` or `q`.\\n- If the `current node = 4` then `p` will belongs to left subtree and `q` will belongs to right subtree and vice-verse.\\n\\nIn any of these two cases we will simply return current node as our answer.\\nThis is how the algorithm will work to find the common ancestor.\\n# Complexity\\n- Time complexity: O(h)\\n`h` is the height of the tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(h)\\nTotal `h` stack spaces in recursive calls.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root.val > p.val && root.val > q.val){\\n            return lowestCommonAncestor(root.left,p,q);\\n        }\\n        if(root.val < p.val && root.val < q.val){\\n            return lowestCommonAncestor(root.right,p,q);\\n        }\\n        //  If above 2 conditions doesn\\'t satisfy then \\n        //  2 cases will arise. For them we simply return \\n        //  the current node.\\n        return root;\\n    }\\n}\\n```\\nI hope the approach is easy and understandable. Please do comment if any doubts or suggestions .\\n\\nPLEASE DO UPVOTE MATES !!!\\n\\nThank You !!!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\np = 3\\nq = 5\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root.val > p.val && root.val > q.val){\\n            return lowestCommonAncestor(root.left,p,q);\\n        }\\n        if(root.val < p.val && root.val < q.val){\\n            return lowestCommonAncestor(root.right,p,q);\\n        }\\n        //  If above 2 conditions doesn\\'t satisfy then \\n        //  2 cases will arise. For them we simply return \\n        //  the current node.\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413340,
                "title": "c-2-ways-to-solve",
                "content": "**Solved LIVE ON TWITCH.  Tune in at 6pm Pacific Time.  Link in profile.**\\n\\n1st way (brought to you by Q_ULTIMAS / OVERFITT) :\\n\\n\\t1. If both P and Q are less than the root, go left\\n\\t2. If both P and Q are greater than the root, go right\\n\\t3. if P and Q are split between left and right, then we have found the LCA.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        int current = root->val;\\n        if(p->val < current && q->val < current) {\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n        else if(p->val > current && q->val > current) {\\n            return lowestCommonAncestor(root->right, p, q);\\n        }\\n        else{\\n            return root;\\n        }\\n    }\\n};\\n```\\n\\n\\n2nd way (sub-optimal, home grown junk by me):\\n\\nThe first node to have two trues (out of left, right ,and current) is our LCA.\\n\\n```\\nclass Solution {\\n    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q, TreeNode*& lca) {\\n        if(!root || lca) return false;\\n        \\n        bool left = dfs(root->left, p, q, lca);\\n        bool right = dfs(root->right, p, q, lca);\\n        \\n        bool cur = false;\\n        if(root == p || root == q) {\\n            cur = true;\\n        }\\n        if(left + right + cur >= 2) {\\n            lca = root;\\n            return false;\\n        }\\n        return left || right || cur;   \\n    }\\n    \\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* ans = nullptr;\\n        dfs(root, p, q, ans);\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        int current = root->val;\\n        if(p->val < current && q->val < current) {\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n        else if(p->val > current && q->val > current) {\\n            return lowestCommonAncestor(root->right, p, q);\\n        }\\n        else{\\n            return root;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q, TreeNode*& lca) {\\n        if(!root || lca) return false;\\n        \\n        bool left = dfs(root->left, p, q, lca);\\n        bool right = dfs(root->right, p, q, lca);\\n        \\n        bool cur = false;\\n        if(root == p || root == q) {\\n            cur = true;\\n        }\\n        if(left + right + cur >= 2) {\\n            lca = root;\\n            return false;\\n        }\\n        return left || right || cur;   \\n    }\\n    \\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* ans = nullptr;\\n        dfs(root, p, q, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65091,
                "title": "my-java-solution-to-share",
                "content": "public class Solution {\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(p.val>q.val)\\n            return lowestCommonAncestor(root, q,p);\\n        if(root.val>= p.val && root.val<=q.val)\\n            return root;\\n        return lowestCommonAncestor(root.val>p.val?root.left:root.right, p,q);    \\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(p.val>q.val)\\n            return lowestCommonAncestor(root, q,p);\\n        if(root.val>= p.val && root.val<=q.val)\\n            return root;\\n        return lowestCommonAncestor(root.val>p.val?root.left:root.right, p,q);    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 65051,
                "title": "c-solution-40ms",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(!root){\\n                return NULL;\\n            }\\n            // check if the current value is larger than both nodes , go left\\n            if(p->val < root->val && q->val < root->val){\\n                lowestCommonAncestor(root->left , p , q);\\n             // go right\\n            }else if(p->val > root->val && q->val > root->val){\\n                lowestCommonAncestor(root->right , p , q);\\n            }// my LCA \\n            else{\\n                return root;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(!root){\\n                return NULL;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 65157,
                "title": "my-java-solution",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            while(true){\\n              if((root.val-p.val)*(root.val-q.val)<=0) return root;\\n              if(p.val<root.val){\\n                 root=root.left;\\n              }\\n             else{\\n                  root=root.right;\\n              }\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            while(true){\\n              if((root.val-p.val)*(root.val-q.val)<=0) return root;\\n              if(p.val<root.val){\\n                 root=root.left;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 3231689,
                "title": "235-space-96-79-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We are given the root of a binary search tree and two nodes p and q.\\n2. We start traversing from the root of the binary search tree.\\n3. If the value of both p and q is less than the value of the root, then the LCA will be in the left subtree. So, we recursively call the function on the left subtree.\\n4. If the value of both p and q is greater than the value of the root, then the LCA will be in the right subtree. So, we recursively call the function on the right subtree.\\n5. If one value is less than the root and the other is greater than the root, then root is the LCA. So, we return the root.\\n\\n# Complexity\\n- Time complexity:\\n80.42%\\n\\n- Space complexity:\\n96.79%\\n\\n# Code\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        # If the value of p and q is less than root, then LCA will be in the left subtree\\n        if p.val < root.val and q.val < root.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        # If the value of p and q is greater than root, then LCA will be in the right subtree\\n        elif p.val > root.val and q.val > root.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        # If one value is less and the other is greater, then root is the LCA\\n        else:\\n            return root\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        # If the value of p and q is less than root, then LCA will be in the left subtree\\n        if p.val < root.val and q.val < root.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        # If the value of p and q is greater than root, then LCA will be in the right subtree\\n        elif p.val > root.val and q.val > root.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        # If one value is less and the other is greater, then root is the LCA\\n        else:\\n            return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520007,
                "title": "python-iterative-recursive-beats-99-simple-solutions",
                "content": "## Solution 1 - Iterative\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        while True:\\n            if p.val < root.val and q.val < root.val:\\n                root = root.left\\n            elif p.val > root.val and q.val > root.val:\\n                root = root.right\\n            else:\\n                return root\\n```\\n\\n## Solution 2 - Recursive\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if p.val > root.val and q.val > root.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        elif p.val < root.val and q.val < root.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        else:\\n            return root\\n```\\n\\n***If you liked the above solutions then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        while True:\\n            if p.val < root.val and q.val < root.val:\\n                root = root.left\\n            elif p.val > root.val and q.val > root.val:\\n                root = root.right\\n            else:\\n                return root\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if p.val > root.val and q.val > root.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        elif p.val < root.val and q.val < root.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        else:\\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167549,
                "title": "c-solution-by-comparing-the-values",
                "content": "\\nSince in bst value less than root are to left and greater than root are to right, we make use of it.\\n\\nIf the value of root is equal to anyone of p & q it means it is LCA since second value will be velow it.\\nElse we check if both value lie on left and right side, then in this case root will be LCA since both are on different side.\\nIn case if both values are on same side, we check which side do they belong to and pass that to our function\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n         if(!root){\\n            return NULL;\\n        }\\n        if(root->val==p->val || root->val==q->val)\\n            return root;\\n        if(root->val<max(p->val,q->val) && root->val>min(p->val,q->val)){\\n            return root;\\n        }\\n        // both are less than root then lca is left side\\n        else if(root->val >max(p->val,q->val)){\\n            return lowestCommonAncestor(root->left,p,q);\\n        }\\n        else\\n            return lowestCommonAncestor(root->right,p,q);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n         if(!root){\\n            return NULL;\\n        }\\n        if(root->val==p->val || root->val==q->val)\\n            return root;\\n        if(root->val<max(p->val,q->val) && root->val>min(p->val,q->val)){\\n            return root;\\n        }\\n        // both are less than root then lca is left side\\n        else if(root->val >max(p->val,q->val)){\\n            return lowestCommonAncestor(root->left,p,q);\\n        }\\n        else\\n            return lowestCommonAncestor(root->right,p,q);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158059,
                "title": "python-dfs",
                "content": "###  235. Lowest Common Ancestor of a Binary Search Tree\\n```\\n> \\u7C7B\\u578B\\uFF1ADFS\\u5206\\u5236\\n> Time Complexity O(h)\\n> Space Complexity O(1)\\n```\\n\\n\\u6839\\u636EBST\\u7684\\u7279\\u6027\\uFF0C\\u5982\\u679C`p`\\u548C`q`\\u91CC\\u9762\\u6700\\u5927\\u7684\\u503C\\u90FD\\u6BD4`root.val`\\u5C0F\\u7684\\u8BDD\\uFF0C\\u90A3\\u8BC1\\u660E`p`\\u548C`q`\\u90FD\\u5728\\u5DE6\\u8FB9\\uFF0C\\u6240\\u4EE5\\u5F80\\u5DE6\\u8FB9\\u9012\\u5F52\\u5C31\\u884C\\uFF0C\\u53F3\\u8FB9\\u9012\\u5F52\\u9053\\u7406\\u76F8\\u540C\\u3002\\u7136\\u540E\\u7B2C\\u4E09\\u79CDcase\\u5F53`root.val`\\u7B49\\u4E8E`p`\\u548C`q`\\u4E4B\\u95F4\\u4E00\\u4E2A\\u7684\\u65F6\\u5019\\uFF0C\\u76F4\\u63A5\\u8FD4\\u56DE`root`\\u5373\\u53EF\\uFF0C\\u56E0\\u4E3A\\u627E\\u5230\\u4E86\\n\\n```\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        if not root: return None\\n        if max(p.val, q.val) < root.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        if min(p.val, q.val) > root.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        return root   \\n```",
                "solutionTags": [],
                "code": "```\\n> \\u7C7B\\u578B\\uFF1ADFS\\u5206\\u5236\\n> Time Complexity O(h)\\n> Space Complexity O(1)\\n```\n```\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        if not root: return None\\n        if max(p.val, q.val) < root.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        if min(p.val, q.val) > root.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        return root   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 65184,
                "title": "no-comparison-needed-java",
                "content": "    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            \\n            if(root==null || root==p || root==q) return root;\\n            \\n            TreeNode left = lowestCommonAncestor(root.left,p,q);\\n            TreeNode right = lowestCommonAncestor(root.right,p,q);\\n            \\n            if(left==null) return right;\\n            if(right==null) return left;\\n            \\n            return root;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            \\n            if(root==null || root==p || root==q) return root;\\n            \\n            TreeNode left = lowestCommonAncestor(root.left,p,q);\\n            TreeNode right = lowestCommonAncestor(root.right,p,q);\\n            \\n            if(left==null) return right;\\n            if(right==null) return left;\\n            \\n            return root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2413931,
                "title": "java-c-classic-recursion",
                "content": "Move recursively through the tree until 1 and 2 are greater than or less than the root, which means they are in the same subtree. \\n\\n#### Java:\\n\\n```java\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (p.val < root.val && q.val < root.val)\\n            return lowestCommonAncestor(root.left, p, q);\\n        if (p.val > root.val && q.val > root.val)\\n            return lowestCommonAncestor(root.right, p, q);\\n        else\\n            return root;\\n    }\\n```\\n\\nThe same, but shorter: \\n\\n```java\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        return (root.val - p.val) * (root.val - q.val) < 1 ? \\n            root : lowestCommonAncestor(p.val < root.val ? root.left : root.right, p, q);\\n    }\\n\\t\\n```\\n#### C++\\n```cpp\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (p->val < root->val && q->val < root->val)\\n            return lowestCommonAncestor(root->left, p, q);\\n        if (p->val > root->val && q->val > root->val)\\n            return lowestCommonAncestor(root->right, p, q);\\n        else\\n            return root;\\n    }\\n```\\n\\nThe same, but shorter: \\n\\n```cpp\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n         return (root->val - p->val) * (root->val - q->val) < 1 ? \\n             root : lowestCommonAncestor(p->val < root->val ? root->left : root->right, p, q);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (p.val < root.val && q.val < root.val)\\n            return lowestCommonAncestor(root.left, p, q);\\n        if (p.val > root.val && q.val > root.val)\\n            return lowestCommonAncestor(root.right, p, q);\\n        else\\n            return root;\\n    }\\n```\n```java\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        return (root.val - p.val) * (root.val - q.val) < 1 ? \\n            root : lowestCommonAncestor(p.val < root.val ? root.left : root.right, p, q);\\n    }\\n\\t\\n```\n```cpp\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (p->val < root->val && q->val < root->val)\\n            return lowestCommonAncestor(root->left, p, q);\\n        if (p->val > root->val && q->val > root->val)\\n            return lowestCommonAncestor(root->right, p, q);\\n        else\\n            return root;\\n    }\\n```\n```cpp\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n         return (root->val - p->val) * (root->val - q->val) < 1 ? \\n             root : lowestCommonAncestor(p->val < root->val ? root->left : root->right, p, q);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2504620,
                "title": "very-easy-100-fully-explained-c-java-python-js-c-python3-iterative-recursive",
                "content": "# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        // Loop till root becomes null...\\n        while(root!= NULL){\\n            // If the value of p node and the q node is greater than the value of root node...\\n            if(p->val > root->val && q->val > root->val){\\n                root = root->right;\\n            }\\n            // If the value of p node and the q node is less than the value of root node...\\n            else if (p->val < root->val && q->val < root->val){\\n                root = root->left;\\n            }\\n            // Otherwise, return the root...\\n            else{\\n                return root;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n\\n# **Java Solution:**\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        // If the value of root node is greater than the value of p node and less than the value of q node...\\n        if(root.val > p.val && root.val < q.val){\\n            return root;\\n        }\\n        // If the value of p node and the q node is less than the value of root node...\\n        else if(root.val > p.val && root.val > q.val){\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        // If the value of p node and the q node is greater than the value of root node...\\n        else if(root.val < p.val && root.val < q.val){\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\n# **Python/Python3 Solution:**\\n```\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        if root:\\n            # If the value of p node and the q node is greater than the value of root node...\\n            if root.val > p.val and root.val > q.val:\\n                return self.lowestCommonAncestor(root.left, p, q)\\n            # If the value of p node and the q node is less than the value of root node...\\n            elif root.val < p.val and root.val < q.val:\\n                return self.lowestCommonAncestor(root.right, p, q)\\n            else:\\n                return root\\n```\\n                \\n# **JavaScript Solution:**\\n```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    // If the value of root node is greater than the value of p node and less than the value of q node...\\n    if(root.val > p.val && root.val < q.val){\\n        return root;\\n    }\\n    // If the value of p node and the q node is less than the value of root node...\\n    else if(root.val > p.val && root.val > q.val){\\n        return lowestCommonAncestor(root.left, p, q);\\n    }\\n    // If the value of p node and the q node is greater than the value of root node...\\n    else if(root.val < p.val && root.val < q.val){\\n        return lowestCommonAncestor(root.right, p, q);\\n    }\\n    return root;\\n};\\n```\\n\\n# **C Language:**\\n```\\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\\n    // Loop till root becomes null...\\n    while(root!= NULL){\\n        // If the value of p node and the q node is greater than the value of root node...\\n        if(p->val > root->val && q->val > root->val){\\n            root = root->right;\\n        }\\n        // If the value of p node and the q node is less than the value of root node...\\n        else if (p->val < root->val && q->val < root->val){\\n            root = root->left;\\n        }\\n        // Otherwise, return the root...\\n        else{\\n            return root;\\n        }\\n    }\\n    return NULL;\\n}\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Tree",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        // Loop till root becomes null...\\n        while(root!= NULL){\\n            // If the value of p node and the q node is greater than the value of root node...\\n            if(p->val > root->val && q->val > root->val){\\n                root = root->right;\\n            }\\n            // If the value of p node and the q node is less than the value of root node...\\n            else if (p->val < root->val && q->val < root->val){\\n                root = root->left;\\n            }\\n            // Otherwise, return the root...\\n            else{\\n                return root;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        // If the value of root node is greater than the value of p node and less than the value of q node...\\n        if(root.val > p.val && root.val < q.val){\\n            return root;\\n        }\\n        // If the value of p node and the q node is less than the value of root node...\\n        else if(root.val > p.val && root.val > q.val){\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        // If the value of p node and the q node is greater than the value of root node...\\n        else if(root.val < p.val && root.val < q.val){\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        if root:\\n            # If the value of p node and the q node is greater than the value of root node...\\n            if root.val > p.val and root.val > q.val:\\n                return self.lowestCommonAncestor(root.left, p, q)\\n            # If the value of p node and the q node is less than the value of root node...\\n            elif root.val < p.val and root.val < q.val:\\n                return self.lowestCommonAncestor(root.right, p, q)\\n            else:\\n                return root\\n```\n```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    // If the value of root node is greater than the value of p node and less than the value of q node...\\n    if(root.val > p.val && root.val < q.val){\\n        return root;\\n    }\\n    // If the value of p node and the q node is less than the value of root node...\\n    else if(root.val > p.val && root.val > q.val){\\n        return lowestCommonAncestor(root.left, p, q);\\n    }\\n    // If the value of p node and the q node is greater than the value of root node...\\n    else if(root.val < p.val && root.val < q.val){\\n        return lowestCommonAncestor(root.right, p, q);\\n    }\\n    return root;\\n};\\n```\n```\\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\\n    // Loop till root becomes null...\\n    while(root!= NULL){\\n        // If the value of p node and the q node is greater than the value of root node...\\n        if(p->val > root->val && q->val > root->val){\\n            root = root->right;\\n        }\\n        // If the value of p node and the q node is less than the value of root node...\\n        else if (p->val < root->val && q->val < root->val){\\n            root = root->left;\\n        }\\n        // Otherwise, return the root...\\n        else{\\n            return root;\\n        }\\n    }\\n    return NULL;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413256,
                "title": "python-easy-runtime-95-94",
                "content": "![image](https://assets.leetcode.com/users/images/b09acb43-60ad-44ee-b63d-59955357ddc8_1660264965.5501003.png)\\n\\ncase i)\\nif root.val is the smallest or the greatest among p.val, q.val, and root.val, then traverse down\\n\\ncase ii)\\nif case (i) is false <=>\\nif root.val is in between p.val and q.val: p and q are seperated by root(which is an ancester of p and q)\\nor if root.val is p.val or root.val is q.val => root is LCA -> return root\\n\\n```\\ndef lowestCommonAncestor(self, root, p, q):\\n    while True:\\n        if root.val < min(p.val,q.val):\\n            root = root.right\\n        elif root.val > max(p.val,q.val):\\n            root = root.left\\n        else:\\n            return root\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef lowestCommonAncestor(self, root, p, q):\\n    while True:\\n        if root.val < min(p.val,q.val):\\n            root = root.right\\n        elif root.val > max(p.val,q.val):\\n            root = root.left\\n        else:\\n            return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1322878,
                "title": "solution-swift-lowest-common-ancestor-of-a-binary-search-tree-test-cases",
                "content": "```swift\\nclass Solution {\\n    func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\\n        guard let rootVal = root?.val, let nodeP = p, let nodeQ = q else { return nil }\\n        switch (p: nodeP.val, q: nodeQ.val) {\\n        case let val where rootVal > val.p && rootVal > val.q:\\n            return lowestCommonAncestor(root?.left, nodeP, nodeQ)\\n        case let val where rootVal < val.p && rootVal < val.q:\\n            return lowestCommonAncestor(root?.right, nodeP, nodeQ)\\n        default:\\n            return root\\n        }\\n    }\\n}\\n```\\n\\n```swift\\n// MARK: - Test cases -\\n\\n// Result: Executed 3 tests, with 0 failures (0 unexpected) in 0.062 (0.064) seconds\\n\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let tree = solution.lowestCommonAncestor(TreeNode([6,2,8,0,4,7,9,nil,nil,3,5]), TreeNode(2), TreeNode(8))\\n        XCTAssertEqual(tree!.val, 6)\\n    }\\n    \\n    func test1() {\\n        let tree = solution.lowestCommonAncestor(TreeNode([6,2,8,0,4,7,9,nil,nil,3,5]), TreeNode(2), TreeNode(4))\\n        XCTAssertEqual(tree!.val, 2)\\n    }\\n    \\n    func test2() {\\n        let tree = solution.lowestCommonAncestor(TreeNode([2,1]), TreeNode(2), TreeNode(1))\\n        XCTAssertEqual(tree!.val, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init(_ val: Int) {\\n        self.val = val\\n        self.left = nil\\n        self.right = nil\\n    }\\n    \\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        \\n        val = head; left = nil; right = nil\\n        \\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\\n        guard let rootVal = root?.val, let nodeP = p, let nodeQ = q else { return nil }\\n        switch (p: nodeP.val, q: nodeQ.val) {\\n        case let val where rootVal > val.p && rootVal > val.q:\\n            return lowestCommonAncestor(root?.left, nodeP, nodeQ)\\n        case let val where rootVal < val.p && rootVal < val.q:\\n            return lowestCommonAncestor(root?.right, nodeP, nodeQ)\\n        default:\\n            return root\\n        }\\n    }\\n}\\n```\n```swift\\n// MARK: - Test cases -\\n\\n// Result: Executed 3 tests, with 0 failures (0 unexpected) in 0.062 (0.064) seconds\\n\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let tree = solution.lowestCommonAncestor(TreeNode([6,2,8,0,4,7,9,nil,nil,3,5]), TreeNode(2), TreeNode(8))\\n        XCTAssertEqual(tree!.val, 6)\\n    }\\n    \\n    func test1() {\\n        let tree = solution.lowestCommonAncestor(TreeNode([6,2,8,0,4,7,9,nil,nil,3,5]), TreeNode(2), TreeNode(4))\\n        XCTAssertEqual(tree!.val, 2)\\n    }\\n    \\n    func test2() {\\n        let tree = solution.lowestCommonAncestor(TreeNode([2,1]), TreeNode(2), TreeNode(1))\\n        XCTAssertEqual(tree!.val, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init(_ val: Int) {\\n        self.val = val\\n        self.left = nil\\n        self.right = nil\\n    }\\n    \\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        \\n        val = head; left = nil; right = nil\\n        \\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059255,
                "title": "simple-java-beats-100-runtime-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find the lowest common ancestor (LCA) node of two given nodes in the BST.\\nIt means we have to find the **lowest common parent node**.\\nIn a BST, left TreeNode value is smaller than root value and right TreeNode value is greater than the root value.\\n**Right TreeNode value > Root value > Left TreeNode value**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    1. If p and q are smaller than root value, search in left sub-tree.\\n    2. If p and q are greater, search in right sub-tree.\\n    3. If p is smaller and q is greater or vice-versa, return root node.\\n\\nFollow the code below to understand the solution.\\n\\n         **If this solution helped you, give it an up-vote to help others** \\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        //if both the values are smaller than root value\\n        //then search in the left sub-tree.\\n        if (p.val < root.val && q.val < root.val)\\n        {\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        //if both the values are greater than root value\\n        //then search in the right sub-tree.\\n        else if (p.val > root.val && q.val > root.val)\\n        {\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        //if one value is greater and other is smaller, that means,\\n        //one node in left sub-tree and other in right sub-tree.\\n        //In that case, the root is the LCA.\\n        else\\n        {\\n            //hence, return root.\\n            return root;\\n        }   \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        //if both the values are smaller than root value\\n        //then search in the left sub-tree.\\n        if (p.val < root.val && q.val < root.val)\\n        {\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        //if both the values are greater than root value\\n        //then search in the right sub-tree.\\n        else if (p.val > root.val && q.val > root.val)\\n        {\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        //if one value is greater and other is smaller, that means,\\n        //one node in left sub-tree and other in right sub-tree.\\n        //In that case, the root is the LCA.\\n        else\\n        {\\n            //hence, return root.\\n            return root;\\n        }   \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045251,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n         while (root) {\\n            if (p->val < root->val && q->val < root->val)\\n                root = root->left;\\n            else if (p->val > root->val && q->val > root->val)\\n                root = root->right;\\n            else return root;\\n        }\\n        return root;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n         while (root) {\\n            if (p->val < root->val && q->val < root->val)\\n                root = root->left;\\n            else if (p->val > root->val && q->val > root->val)\\n                root = root->right;\\n            else return root;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413347,
                "title": "c-4-line-detailed-explanation-dfs-beginner-friendly",
                "content": "![image](https://assets.leetcode.com/users/images/4d397ce8-6cdd-4ec7-885b-d7eeb827b2ae_1660268129.6445835.png)\\n\\n```\\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\\n    if(root == p || root == q || !root) return root;   // found what we want or there is nothing\\n    struct TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n    struct TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n    return !left?right:!right?left:root;\\n}\\n```\\n\\nHere\\'s the code for better understand:\\n```\\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\\n     \\n    // found what we want or there is nothing\\n    if(root == p || root == q || !root) \\n        return root;   // found what we want or there is nothing\\n    \\n    struct TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n    struct TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n    \\n    if (left && right)\\n        return root\\n    else if (left)\\n        return left\\n    else if (right)\\n        return right\\n    else \\n        return NULL;\\n}\\n```\\n**Please UPVOTE if you LIKE**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\\n    if(root == p || root == q || !root) return root;   // found what we want or there is nothing\\n    struct TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n    struct TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n    return !left?right:!right?left:root;\\n}\\n```\n```\\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\\n     \\n    // found what we want or there is nothing\\n    if(root == p || root == q || !root) \\n        return root;   // found what we want or there is nothing\\n    \\n    struct TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n    struct TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n    \\n    if (left && right)\\n        return root\\n    else if (left)\\n        return left\\n    else if (right)\\n        return right\\n    else \\n        return NULL;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1376663,
                "title": "c-solution-recursive-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL) return NULL;\\n        if(root->val < p->val && root->val < q->val){\\n            return lowestCommonAncestor(root->right, p, q);\\n        }\\n        if(root->val > p->val && root->val > q->val){\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n        else \\n            return root;\\n    }\\n};\\n```\\nPlease Upvote if you like the solution  and comment if have doubts",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL) return NULL;\\n        if(root->val < p->val && root->val < q->val){\\n            return lowestCommonAncestor(root->right, p, q);\\n        }\\n        if(root->val > p->val && root->val > q->val){\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n        else \\n            return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356461,
                "title": "java-binary-tree-common-parent",
                "content": "\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root.val > p.val && root.val > q.val)\\n            return lowestCommonAncestor(root.left, p, q);\\n        if (root.val < p.val && root.val < q.val)\\n            return lowestCommonAncestor(root.right, p, q);\\n        else\\n            return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root.val > p.val && root.val > q.val)\\n            return lowestCommonAncestor(root.left, p, q);\\n        if (root.val < p.val && root.val < q.val)\\n            return lowestCommonAncestor(root.right, p, q);\\n        else\\n            return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616289,
                "title": "very-simple-c-with-explanation",
                "content": "Solving the problem by following steps\\n(Kindly read the code (Bottom) then see the explanation)\\n1. if root value is null then definetely there will not be any element \\n`  if(root==nullptr)return nullptr;`\\n\\n2. if our root value matches with either of two nodes p or q then we\\'ll return the root bcoz definitely  \\n    any node value ancestor is root then other node will come below that root node.\\n\\t` if(root==p || root==q)return root;`\\n\\t\\n3. we\\'ll call both side of the current node and if both value comes as not null value that means\\n   below the current node both the nodes (p,q) comes\\n   ` TreeNode *LeftS=lowestCommonAncestor(root->left,p,q);`\\n  ` TreeNode *RightS=lowestCommonAncestor(root->right,p,q);`\\n  \\n\\t  ` if(LeftS !=nullptr && RightS!=nullptr)\\n            return root; `\\n   \\n4. if above condition is not satisfy then we\\'ll check which node returned as not null we\\'ll return that\\n`else if(LeftS!=nullptr)\\n            return LeftS;`\\n6.  5.  else vice versa as above (4.)point\\n\\t`else \\n            return RightS;`\\n\\n```\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==nullptr)return nullptr;\\n        if(root==p || root==q)return root;\\n        \\n        TreeNode *LeftS=lowestCommonAncestor(root->left,p,q);\\n        TreeNode *RightS=lowestCommonAncestor(root->right,p,q);\\n        if(LeftS !=nullptr && RightS!=nullptr)\\n            return root; //in the both side of current root both p,q node exist\\n        \\n        else if(LeftS!=nullptr)\\n            return LeftS;\\n        else \\n            return RightS;\\n    }\\n```\\n\\uD83D\\uDE42 ***why you guys always forget to upvote, it motivates me to make such post.***\\n<a href=\"https://cutt.ly/KalyanChannel\"> \\uD83C\\uDFA1 **You Can Checkout The Youtube Channel Here \\u270B\\uD83C\\uDFFB** \\uD83C\\uDFA1  </a>",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==nullptr)return nullptr;\\n        if(root==p || root==q)return root;\\n        \\n        TreeNode *LeftS=lowestCommonAncestor(root->left,p,q);\\n        TreeNode *RightS=lowestCommonAncestor(root->right,p,q);\\n        if(LeftS !=nullptr && RightS!=nullptr)\\n            return root; //in the both side of current root both p,q node exist\\n        \\n        else if(LeftS!=nullptr)\\n            return LeftS;\\n        else \\n            return RightS;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3825701,
                "title": "java-4-liner-100-fast-easy-solution",
                "content": "### We need to find the diverging point, the node at the diverging point will always be the common ancestor\\n\\n- As given tree is a BST, the diverging point can be determined by checking if both nodes are on the same side or not ie. both nodes are less than current node or greater than current node.\\n\\n- If any one node fails this condition, then we can be sure it is the diverging point and return that node\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) auxilary space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n     if(root == null) return root;\\n     if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n     else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n     else return root;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF THIS WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n     if(root == null) return root;\\n     if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n     else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n     else return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509931,
                "title": "java-100-fast-only-3-line-code-recursive-approach",
                "content": "class Solution {\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (p.val > root.val && q.val > root.val) return lowestCommonAncestor(root.right, p, q);\\n        else if (p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left, p, q);\\n        else return root;\\n    }\\n\\n}\\n**Please UpVote if you like the solution**",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (p.val > root.val && q.val > root.val) return lowestCommonAncestor(root.right, p, q);\\n        else if (p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left, p, q);\\n        else return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 862386,
                "title": "simple-recursive-and-iterative-solution",
                "content": "```\\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n\\tif p.Val < root.Val && q.Val < root.Val {\\n\\t\\treturn lowestCommonAncestor(root.Left, p, q)\\n\\t}\\n\\tif p.Val > root.Val && q.Val > root.Val {\\n\\t\\treturn lowestCommonAncestor(root.Right, p, q)\\n\\t}\\n\\treturn root\\n}\\n\\n```\\n\\n```\\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n\\tfor root != nil {\\n\\t\\tif p.Val < root.Val && q.Val < root.Val {\\n\\t\\t\\troot = root.Left\\n\\t\\t}else if p.Val > root.Val && q.Val > root.Val {\\n\\t\\t\\troot = root.Right\\n\\t\\t}else {\\n\\t\\t\\treturn root\\n\\t\\t}\\n\\t}\\n\\treturn nil\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n\\tif p.Val < root.Val && q.Val < root.Val {\\n\\t\\treturn lowestCommonAncestor(root.Left, p, q)\\n\\t}\\n\\tif p.Val > root.Val && q.Val > root.Val {\\n\\t\\treturn lowestCommonAncestor(root.Right, p, q)\\n\\t}\\n\\treturn root\\n}\\n\\n```\n```\\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n\\tfor root != nil {\\n\\t\\tif p.Val < root.Val && q.Val < root.Val {\\n\\t\\t\\troot = root.Left\\n\\t\\t}else if p.Val > root.Val && q.Val > root.Val {\\n\\t\\t\\troot = root.Right\\n\\t\\t}else {\\n\\t\\t\\treturn root\\n\\t\\t}\\n\\t}\\n\\treturn nil\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 693896,
                "title": "python-explained-simple-solution",
                "content": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        ## APPROACH : RECURSION ##\\n        ## LOGIC ##\\n        # Both p and q are smaller than current node, then search left-subtree by recursive\\n        # Both p and q are larger than current node, then search right-subtree by recursive\\n        # Both p and q are not on the same side of current node, then current node must be the Lowest common ancestor of ( p, q )\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        cur_value = root.val\\n        if p.val > cur_value and q.val > cur_value:\\n            return self.lowestCommonAncestor( root.right, p, q)\\n        \\n        elif p.val < cur_value and q.val < cur_value:\\n            return self.lowestCommonAncestor( root.left, p, q)\\n        else:\\n            return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        ## APPROACH : RECURSION ##\\n        ## LOGIC ##\\n        # Both p and q are smaller than current node, then search left-subtree by recursive\\n        # Both p and q are larger than current node, then search right-subtree by recursive\\n        # Both p and q are not on the same side of current node, then current node must be the Lowest common ancestor of ( p, q )\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        cur_value = root.val\\n        if p.val > cur_value and q.val > cur_value:\\n            return self.lowestCommonAncestor( root.right, p, q)\\n        \\n        elif p.val < cur_value and q.val < cur_value:\\n            return self.lowestCommonAncestor( root.left, p, q)\\n        else:\\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 677460,
                "title": "javascript-recursive-iterative-solution",
                "content": "**Recursive:**\\n```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if(p.val > root.val && q.val > root.val) return lowestCommonAncestor(root.right, p, q);\\n    \\n    if(p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left, p , q);\\n    \\n    return root;\\n};\\n```\\n**Iterative:**\\n```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    while(true){\\n        if(p.val < root.val && q.val < root.val) root = root.left;\\n\\n        else if(p.val > root.val && q.val > root.val) root = root.right;\\n\\n        else return root;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if(p.val > root.val && q.val > root.val) return lowestCommonAncestor(root.right, p, q);\\n    \\n    if(p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left, p , q);\\n    \\n    return root;\\n};\\n```\n```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    while(true){\\n        if(p.val < root.val && q.val < root.val) root = root.left;\\n\\n        else if(p.val > root.val && q.val > root.val) root = root.right;\\n\\n        else return root;\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 65092,
                "title": "3-lines-non-recursive-solution-in-java",
                "content": "    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        while(true){\\n          if((root.val-p.val)*(root.val-q.val) <= 0) return root;\\n          root = p.val < root.val ? root.left : root.right;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        while(true){\\n          if((root.val-p.val)*(root.val-q.val) <= 0) return root;\\n          root = p.val < root.val ? root.left : root.right;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2805318,
                "title": "java-runtime-4ms-faster-than-100-3-lines-o-1-space",
                "content": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left, p, q);\\n        else if (p.val > root.val && q.val > root.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2ac59181-46e4-4a4e-ba7e-3bc834430fb3_1668225339.6344059.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left, p, q);\\n        else if (p.val > root.val && q.val > root.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236931,
                "title": "java-simple-explanation-with-tc-sc-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) { //base condition\\n            return root;\\n        }\\n        \\n        //we use a while loop to traverse in the BST\\n        while(root != null) {\\n            \\n            //if the value of current node is greater than both the value then we go on the left side\\n            if(root.val > p.val && root.val > q.val) {\\n                root = root.left;\\n                \\n            //if the value of current node is lesser than both the value then we go on the right side\\n            } else if(root.val < p.val && root.val < q.val) {\\n                root = root.right;\\n                \\n            //if both the condition fails then it means that one node is on the left and the other node is on the right side, so in this case LCA will be the current node itself. So we break the loop and return the current node as LCA from line no 33\\n            } else {\\n                break;\\n            }\\n        }\\n        return root;\\n    }\\n}\\n\\n//Time Complexity: O(h), where h is the height of the tree.\\n//Space Complexity: Since we are not doing any recursive call, so space complexity is constant.\\n//Please upvote the solution if you like it",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) { //base condition\\n            return root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2185308,
                "title": "python3-simple-recursive-solution",
                "content": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if p is None or q is None:\\n            return None\\n        if root == p or root == q:\\n            return root\\n        if (root.left == p and root.right ==q) or (root.right == p and root.left == q):\\n            return root\\n        if p.val < root.val and q.val < root.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        elif p.val > root.val and q.val > root.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        \\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if p is None or q is None:\\n            return None\\n        if root == p or root == q:\\n            return root\\n        if (root.left == p and root.right ==q) or (root.right == p and root.left == q):\\n            return root\\n        if p.val < root.val and q.val < root.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        elif p.val > root.val and q.val > root.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212409,
                "title": "its-simpler-than-you-think-javascript",
                "content": "The simple solution is to trace the tree looking for both P and Q at same time. As soon as your paths diverge, thats your LCA!\\n\\n``` \\nvar lowestCommonAncestor = function(root, p, q) {\\n    \\n    //set root as LCA\\n    //trace tree together\\n    //as soon as they diverge, thats LCA\\n    \\n    let lca = root    \\n    let current = root\\n    while (current != null) {\\n                lca = current\\n                console.log(\"adding \"+current.val)\\n                if (p.val > current.val && q.val > current.val) {\\n                    current = current.right                \\n                } else if (p.val < current.val && q.val < current.val) {             \\n                    current = current.left\\n                } else {\\n                    console.log(\"found! LCA is \"+lca.val) \\n                    break\\n                }\\n                \\n    } //while\\n    console.log(\"LCA is \"+lca.val) \\n    return lca\\n",
                "solutionTags": [],
                "code": "The simple solution is to trace the tree looking for both P and Q at same time. As soon as your paths diverge, thats your LCA!\\n\\n``` \\nvar lowestCommonAncestor = function(root, p, q) {\\n    \\n    //set root as LCA\\n    //trace tree together\\n    //as soon as they diverge, thats LCA\\n    \\n    let lca = root    \\n    let current = root\\n    while (current != null) {\\n                lca = current\\n                console.log(\"adding \"+current.val)\\n                if (p.val > current.val && q.val > current.val) {\\n                    current = current.right                \\n                } else if (p.val < current.val && q.val < current.val) {             \\n                    current = current.left\\n                } else {\\n                    console.log(\"found! LCA is \"+lca.val) \\n                    break\\n                }\\n                \\n    } //while\\n    console.log(\"LCA is \"+lca.val) \\n    return lca\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3165048,
                "title": "easy-java-recursion-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nYe sab nahi ata mujhe bro. Itna aata toh kamaal ho jaata\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nYe bhi nahi aata\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==q || root==p) return root;\\n        if(root.val<q.val && root.val>p.val) return root;\\n        if(root.val<q.val && root.val<p.val) return lowestCommonAncestor(root.right,p,q);\\n        if(root.val>q.val && root.val>p.val) return lowestCommonAncestor(root.left,p,q);\\n        else return root;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==q || root==p) return root;\\n        if(root.val<q.val && root.val>p.val) return root;\\n        if(root.val<q.val && root.val<p.val) return lowestCommonAncestor(root.right,p,q);\\n        if(root.val>q.val && root.val>p.val) return lowestCommonAncestor(root.left,p,q);\\n        else return root;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693726,
                "title": "an-easy-readable-and-understandable-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        // Both p and q are on the left\\n        if (p->val < root->val && q->val < root->val) {\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n\\n        // Both p and q are on the right\\n        if (p->val > root->val && q->val > root->val) {\\n            return lowestCommonAncestor(root->right, p, q);\\n        }\\n\\n        // 1. p and q are on different sides\\n        // OR\\n        // 2. Either p or q is equal to the root\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        // Both p and q are on the left\\n        if (p->val < root->val && q->val < root->val) {\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n\\n        // Both p and q are on the right\\n        if (p->val > root->val && q->val > root->val) {\\n            return lowestCommonAncestor(root->right, p, q);\\n        }\\n\\n        // 1. p and q are on different sides\\n        // OR\\n        // 2. Either p or q is equal to the root\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413199,
                "title": "daily-leetcoding-challenge-august-day-12",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2161853,
                "title": "java-recursive-solution-with-little-bit-intuition-clearly-explained",
                "content": "Explanation:\\nGiven tree is a binary search tree. And if you go through the constraints then its given that both nodes P and Q will be present and they are not equal i.e. P != Q.\\nThis means we don\\'t need to check the null condition because we will never touch the leaf node as the nodes will always be available. We don\\'t need to check the equality also (I will explain why), hence in the worst case we need to traverse just before the leaf node.\\n\\nSince this is a BST, we have three cases to handle.\\n1. P and Q fall on same side of the root (either both left or both right)\\n2. P and Q fall on opposite sides of the root (either P left Q right or vice versa).\\n3. Either P or Q matches the root.\\n\\nWe do a recursive DFS starting from the root node. \\n1. If P and Q fall on opposite sides, then current root is the LCA. Because this is the lowest common point you can reach both points. We dont need to recur further and return.\\n2. If either P or Q matches the root then the current root is LCA because the other will be child of the current node. Hence we dont recur further and return.\\n3. If they fall on same side of the current root, then we recur left or right depending on the points.\\n\\nPlease give your comments and upvote if it helps.\\n\\n```\\n\\tpublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if ( p.val < root.val && q.val < root.val ) return this.lowestCommonAncestor(root.left, p, q);\\n        if ( p.val > root.val && q.val > root.val ) return this.lowestCommonAncestor(root.right, p, q);\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\tpublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if ( p.val < root.val && q.val < root.val ) return this.lowestCommonAncestor(root.left, p, q);\\n        if ( p.val > root.val && q.val > root.val ) return this.lowestCommonAncestor(root.right, p, q);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 322190,
                "title": "python-very-simple-iterative-solution-faster-than-99",
                "content": "```\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        while True:\\n            if p.val <= root.val <= q.val or q.val <= root.val <= p.val:\\n                return root \\n            if p.val > root.val and q.val > root.val:\\n                root = root.right\\n            elif p.val < root.val and q.val < root.val:\\n                root = root.left\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        while True:\\n            if p.val <= root.val <= q.val or q.val <= root.val <= p.val:\\n                return root \\n            if p.val > root.val and q.val > root.val:\\n                root = root.right\\n            elif p.val < root.val and q.val < root.val:\\n                root = root.left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65072,
                "title": "simple-java-solution",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if (p == null || q == null || root == null){\\n                return null;\\n            }\\n            if (p.val < root.val && q.val < root.val){\\n                return lowestCommonAncestor (root.left, p , q);\\n            }\\n            else if (p.val > root.val && q.val > root.val){\\n                return lowestCommonAncestor (root.right, p , q);\\n            }\\n            else {\\n                return root;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if (p == null || q == null || root == null){\\n                return null;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 65083,
                "title": "1-line-solution-java",
                "content": "If both p and q in same direction (less or greater than), then change the root to its child in that direction. otherwise for all other cases it has to be the root.    \\n  \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        return (p.val<root.val && q.val<root.val) ? lowestCommonAncestor(root.left,p,q) : (p.val>root.val && q.val>root.val) ? lowestCommonAncestor(root.right,p,q) : root;\\n        }",
                "solutionTags": [
                    "Binary Search",
                    "Tree"
                ],
                "code": "If both p and q in same direction (less or greater than), then change the root to its child in that direction. otherwise for all other cases it has to be the root.    \\n  \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        return (p.val<root.val && q.val<root.val) ? lowestCommonAncestor(root.left,p,q) : (p.val>root.val && q.val>root.val) ? lowestCommonAncestor(root.right,p,q) : root;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2827050,
                "title": "python-easy-solution",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        curr=root\\n        while curr:\\n            if p.val>curr.val and q.val>curr.val:\\n                curr=curr.right\\n            elif p.val<curr.val and q.val<curr.val:\\n                curr=curr.left\\n            else:\\n                return curr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        curr=root\\n        while curr:\\n            if p.val>curr.val and q.val>curr.val:\\n                curr=curr.right\\n            elif p.val<curr.val and q.val<curr.val:\\n                curr=curr.left\\n            else:\\n                return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704717,
                "title": "python-easy-way-to-find-lowest-common-ancestor-of-a-binary-search-tree-96-faster",
                "content": "**IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        curr = root\\n        \\n        while curr:\\n            if p.val>curr.val and q.val>curr.val:\\n                curr = curr.right\\n            elif p.val<curr.val and q.val<curr.val:\\n                curr = curr.left\\n            else:\\n                return curr\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        curr = root\\n        \\n        while curr:\\n            if p.val>curr.val and q.val>curr.val:\\n                curr = curr.right\\n            elif p.val<curr.val and q.val<curr.val:\\n                curr = curr.left\\n            else:\\n                return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704082,
                "title": "store-parent-path-last-common-node",
                "content": "```\\n#define ff              first\\n#define ss              second\\n#define pb              push_back\\n#define mp              make_pair\\n#define mt              make_tuple\\n#define pii             pair<int,int>\\n#define vi              vector<int>\\n#define mii             map<int,int>\\n#define FIO             ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\\nconst int N = 1e5 + 10;\\n\\nclass Solution\\n{\\npublic:\\n    map<int, list<int>> g;\\n    mii par;\\n    vi x_path;\\n    vi y_path;\\n    void dfs(int src, int parent)\\n    {\\n        par[src] = parent;\\n        for (auto nbr : g[src])\\n        {\\n            if (nbr != parent)\\n            {\\n                dfs(nbr, src);\\n            }\\n        }\\n    }\\n    vi findPath(int node)\\n    {\\n        vi path;\\n        int parent = par[node];\\n        path.pb(node);\\n        while (parent != -1)\\n        {\\n            path.pb(parent);\\n            parent = par[parent];\\n        }\\n        reverse(path.begin(), path.end());\\n        return path;\\n    }\\n    TreeNode *reqNode(TreeNode *root, int data)\\n    {\\n        if (root == NULL)\\n            return NULL;\\n        if (root->val == data)\\n            return root;\\n        TreeNode *l = reqNode(root->left, data);\\n        TreeNode *r = reqNode(root->right, data);\\n        return l == NULL ? r : l;\\n    }\\n    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *x, TreeNode *y)\\n    {\\n        FIO;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        while (!q.empty())\\n        {\\n            auto f = q.front();\\n            q.pop();\\n            int u = f->val;\\n            if (f->left != NULL)\\n            {\\n                int v = f->left->val;\\n                g[u].push_back(v);\\n                q.push(f->left);\\n            }\\n            if (f->right != NULL)\\n            {\\n                int v = f->right->val;\\n                g[u].push_back(v);\\n                q.push(f->right);\\n            }\\n        }\\n        dfs(root->val, -1);\\n        x_path = findPath(x->val);\\n        y_path = findPath(y->val);\\n        int lca = -1;\\n        int mn = min(x_path.size(), y_path.size());\\n        for (int i = 0; i < mn; i++)\\n        {\\n            if (x_path[i] == y_path[i])\\n            {\\n                lca = x_path[i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n\\n        return reqNode(root, lca);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n#define ff              first\\n#define ss              second\\n#define pb              push_back\\n#define mp              make_pair\\n#define mt              make_tuple\\n#define pii             pair<int,int>\\n#define vi              vector<int>\\n#define mii             map<int,int>\\n#define FIO             ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\\nconst int N = 1e5 + 10;\\n\\nclass Solution\\n{\\npublic:\\n    map<int, list<int>> g;\\n    mii par;\\n    vi x_path;\\n    vi y_path;\\n    void dfs(int src, int parent)\\n    {\\n        par[src] = parent;\\n        for (auto nbr : g[src])\\n        {\\n            if (nbr != parent)\\n            {\\n                dfs(nbr, src);\\n            }\\n        }\\n    }\\n    vi findPath(int node)\\n    {\\n        vi path;\\n        int parent = par[node];\\n        path.pb(node);\\n        while (parent != -1)\\n        {\\n            path.pb(parent);\\n            parent = par[parent];\\n        }\\n        reverse(path.begin(), path.end());\\n        return path;\\n    }\\n    TreeNode *reqNode(TreeNode *root, int data)\\n    {\\n        if (root == NULL)\\n            return NULL;\\n        if (root->val == data)\\n            return root;\\n        TreeNode *l = reqNode(root->left, data);\\n        TreeNode *r = reqNode(root->right, data);\\n        return l == NULL ? r : l;\\n    }\\n    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *x, TreeNode *y)\\n    {\\n        FIO;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        while (!q.empty())\\n        {\\n            auto f = q.front();\\n            q.pop();\\n            int u = f->val;\\n            if (f->left != NULL)\\n            {\\n                int v = f->left->val;\\n                g[u].push_back(v);\\n                q.push(f->left);\\n            }\\n            if (f->right != NULL)\\n            {\\n                int v = f->right->val;\\n                g[u].push_back(v);\\n                q.push(f->right);\\n            }\\n        }\\n        dfs(root->val, -1);\\n        x_path = findPath(x->val);\\n        y_path = findPath(y->val);\\n        int lca = -1;\\n        int mn = min(x_path.size(), y_path.size());\\n        for (int i = 0; i < mn; i++)\\n        {\\n            if (x_path[i] == y_path[i])\\n            {\\n                lca = x_path[i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n\\n        return reqNode(root, lca);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2662502,
                "title": "simple-o-h-recursive-iterative-solutions",
                "content": "**Recursive Solution**\\n```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\tif root.val > p.val and root.val > q.val: #if the root is bigger than both nodes \\n\\t\\treturn self.lowestCommonAncestor(root.left,p,q) #both nodes must be to the left of root\\n\\telif root.val < p.val and root.val < q.val: #if the root is smaller than both nodes\\n\\t\\treturn self.lowestCommonAncestor(root.right,p,q) #both nodes must be to the right of the root\\n\\treturn root #otherwise the nodes are on either side of the root or one of the nodes is the root, so we return the root\\n```\\n\\n**Iterative Solution**\\n```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\twhile True:\\n\\t\\tif root.val > p.val and root.val > q.val: #if the root is bigger than both nodes \\n\\t\\t\\troot = root.left\\n\\t\\telif root.val < p.val and root.val < q.val: #if the root is smaller than both nodes\\n\\t\\t\\troot = root.right #both nodes must be to the right of the root\\n\\t\\telse: #otherwise the nodes are on either side of the root or one of the nodes is the root, so we return the root\\n\\t\\t\\treturn root \\n```\\n\\nThese two solutions use the same insight, which is that we need to take advantage of the fact this is a binary search tree. This means that the tree has the property that, for some node ```node``` with two descendents, ```node.left.val < node.val < node.right.val```. The lowest common ancestor of the two nodes will either be a node such that ```node.val == p.val``` or ```node.val == q.val```, or a node such that ```p``` and ```q``` are on either side of it --> ```p.val < node.val < q.val``` or ```q.val < node.val < p.val```. Therefore, we just need to figure out what to do if neither of those things are true. If ```node.val > p.val and node.val > q.val```, both nodes have a smaller value than ```node```, which means that they must be to the left in our tree. Similarly, if ```node.val < p.val and node.val < q.val```, then both nodes have a bigger value than ```node```, so they must be to the right in our tree. The way we move to the right or left is slightly different between the recursive and iterative solutions, but it functions the exact same. This solution is ```O(H)```, where ```H``` is the height of the tree, since it would only ever need to look at one path down the tree. \\n\\nP.S. we use ```while True``` for the iterative solution because we are guaranteed in the problem that ```p``` and ```q``` will exist in the tree. If we were not given this information and wanted to handle the possibility that one or both of the nodes did not exist in the tree, then we could use ```while root``` and add some logic for what happens after breaking out of the ```while``` loop (when we finished looking through the tree.\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\tif root.val > p.val and root.val > q.val: #if the root is bigger than both nodes \\n\\t\\treturn self.lowestCommonAncestor(root.left,p,q) #both nodes must be to the left of root\\n\\telif root.val < p.val and root.val < q.val: #if the root is smaller than both nodes\\n\\t\\treturn self.lowestCommonAncestor(root.right,p,q) #both nodes must be to the right of the root\\n\\treturn root #otherwise the nodes are on either side of the root or one of the nodes is the root, so we return the root\\n```\n```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\twhile True:\\n\\t\\tif root.val > p.val and root.val > q.val: #if the root is bigger than both nodes \\n\\t\\t\\troot = root.left\\n\\t\\telif root.val < p.val and root.val < q.val: #if the root is smaller than both nodes\\n\\t\\t\\troot = root.right #both nodes must be to the right of the root\\n\\t\\telse: #otherwise the nodes are on either side of the root or one of the nodes is the root, so we return the root\\n\\t\\t\\treturn root \\n```\n```node```\n```node.left.val < node.val < node.right.val```\n```node.val == p.val```\n```node.val == q.val```\n```p```\n```q```\n```p.val < node.val < q.val```\n```q.val < node.val < p.val```\n```node.val > p.val and node.val > q.val```\n```node```\n```node.val < p.val and node.val < q.val```\n```node```\n```O(H)```\n```H```\n```while True```\n```p```\n```q```\n```while root```\n```while```",
                "codeTag": "Python3"
            },
            {
                "id": 2413953,
                "title": "4-line-simple-solution-c",
                "content": "**Time Complexity : O(h) (h is height of tree)\\nSpace Complexity : O(h) (Recursive stack calls)**\\n```\\n \\n        if(root == p || root == q)return root;\\n        if(root->val > min(p->val,q->val) && root->val < max(q->val,p->val))return root;\\n        if(root->val > max(q->val,p->val))return lowestCommonAncestor(root->left,p,q);\\n        return lowestCommonAncestor(root->right,p,q);\\n        \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n \\n        if(root == p || root == q)return root;\\n        if(root->val > min(p->val,q->val) && root->val < max(q->val,p->val))return root;\\n        if(root->val > max(q->val,p->val))return lowestCommonAncestor(root->left,p,q);\\n        return lowestCommonAncestor(root->right,p,q);\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1348197,
                "title": "c-solution-iterative-and-recursive",
                "content": "**Iterative**\\n```csharp\\npublic TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)\\n{\\n\\twhile (root != null)\\n\\t{\\n\\t\\tif (root.val > p.val && root.val > q.val)\\n\\t\\t\\troot = root.left;\\n\\t\\telse if (root.val < p.val && root.val < q.val)\\n\\t\\t\\troot = root.right;\\n\\t\\telse\\n\\t\\t\\tbreak;\\n\\t}\\n\\n\\treturn root;\\n}\\n```\\n\\n**Recursive**\\n\\n```csharp\\npublic TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)\\n{\\n\\tif (root == null) return null;\\n\\n\\tif (root.val < p.val && root.val < q.val)\\n\\t\\treturn LowestCommonAncestor(root.right, p, q);\\n\\telse if (root.val > p.val && root.val > q.val)\\n\\t\\treturn LowestCommonAncestor(root.left, p, q);\\n\\n\\treturn root;\\n}\\n```",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```csharp\\npublic TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)\\n{\\n\\twhile (root != null)\\n\\t{\\n\\t\\tif (root.val > p.val && root.val > q.val)\\n\\t\\t\\troot = root.left;\\n\\t\\telse if (root.val < p.val && root.val < q.val)\\n\\t\\t\\troot = root.right;\\n\\t\\telse\\n\\t\\t\\tbreak;\\n\\t}\\n\\n\\treturn root;\\n}\\n```\n```csharp\\npublic TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)\\n{\\n\\tif (root == null) return null;\\n\\n\\tif (root.val < p.val && root.val < q.val)\\n\\t\\treturn LowestCommonAncestor(root.right, p, q);\\n\\telse if (root.val > p.val && root.val > q.val)\\n\\t\\treturn LowestCommonAncestor(root.left, p, q);\\n\\n\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 173855,
                "title": "javascript-solution",
                "content": "```\\n// Lowest Common Ancestor must sit between p and q\\n// p < Lowest Common Ancestor < q\\nvar lowestCommonAncestor = (root, p, q) => {\\n  // Lowest Common Ancestor bigger than both p and q so we move left\\n  if (p.val < root.val && q.val < root.val) {\\n    return lowestCommonAncestor(root.left, p, q);\\n  }\\n  // Lowest Common Ancestor small than both p and q so we move right\\n  if (p.val > root.val && q.val > root.val) {\\n    return lowestCommonAncestor(root.right, p, q);\\n  }\\n  return root;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Lowest Common Ancestor must sit between p and q\\n// p < Lowest Common Ancestor < q\\nvar lowestCommonAncestor = (root, p, q) => {\\n  // Lowest Common Ancestor bigger than both p and q so we move left\\n  if (p.val < root.val && q.val < root.val) {\\n    return lowestCommonAncestor(root.left, p, q);\\n  }\\n  // Lowest Common Ancestor small than both p and q so we move right\\n  if (p.val > root.val && q.val > root.val) {\\n    return lowestCommonAncestor(root.right, p, q);\\n  }\\n  return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 65108,
                "title": "javascript-solution-if-anyone-is-interested",
                "content": "    var lowestCommonAncestor = function(root, p, q) {\\n        if (p.val < root.val && q.val < root.val) {\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        else if (p.val > root.val && q.val > root.val) {\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        else {\\n            return root;\\n        }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var lowestCommonAncestor = function(root, p, q) {\\n        if (p.val < root.val && q.val < root.val) {\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        else if (p.val > root.val && q.val > root.val) {\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        else {\\n            return root;\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 64995,
                "title": "java-method-spends-10ms",
                "content": "public class LowestCommonAncestorofaBinarySearchTree {\\n\\n\\tpublic static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p,\\n\\t\\t\\tTreeNode q) {\\n\\t\\tint min = p.val, max = q.val;\\n\\t\\tif (min > max) {\\n\\t\\t\\tmin = q.val;\\n\\t\\t\\tmax = p.val;\\n\\t\\t}\\n\\t\\twhile (true) {\\n\\t\\t\\tif (root.val < min)\\n\\t\\t\\t\\troot = root.right;\\n\\t\\t\\telse if (root.val > max)\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}\\n}\\n\\n\\nplease, who can tell me a less-than-10ms method",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "public class LowestCommonAncestorofaBinarySearchTree {\\n\\n\\tpublic static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p,\\n\\t\\t\\tTreeNode q) {\\n\\t\\tint min = p.val, max = q.val;\\n\\t\\tif (min > max) {\\n\\t\\t\\tmin = q.val;\\n\\t\\t\\tmax = p.val;\\n\\t\\t}\\n\\t\\twhile (true) {\\n\\t\\t\\tif (root.val < min)\\n\\t\\t\\t\\troot = root.right;\\n\\t\\t\\telse if (root.val > max)\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}\\n}\\n\\n\\nplease, who can tell me a less-than-10ms method",
                "codeTag": "Java"
            },
            {
                "id": 65125,
                "title": "my-40ms-c-solution",
                "content": "    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(!root) return root;\\n        \\n        \\tif((root->val - p->val)*(root->val - q->val)<=0) return root;\\n\\n        \\tif((root->val - p->val)>0 && (root->val - q->val)>0) return lowestCommonAncestor(root->left,p,q);\\n\\n        \\tif((root->val - p->val)<0 && (root->val - q->val)<0) return lowestCommonAncestor(root->right,p,q);\\n        \\n        }",
                "solutionTags": [],
                "code": "    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(!root) return root;\\n        \\n        \\tif((root->val - p->val)*(root->val - q->val)<=0) return root;\\n\\n        \\tif((root->val - p->val)>0 && (root->val - q->val)>0) return lowestCommonAncestor(root->left,p,q);\\n\\n        \\tif((root->val - p->val)<0 && (root->val - q->val)<0) return lowestCommonAncestor(root->right,p,q);\\n        \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 65167,
                "title": "python-easy-to-understand-recursive-solution-with-comments",
                "content": "\\n    def lowestCommonAncestor(self, root, p, q):\\n        if not root:\\n            return \\n        # p and q are on the different side of root,\\n        # or at least one of them is root\\n        if (root.val-p.val)*(root.val-q.val)<=0:\\n            return root\\n        # both p and q are on the left side of root\\n        elif root.val > p.val and root.val > q.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        # both p and q are on the right side of root\\n        else:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n\\t\\t\\t\\n\\tdef lowestCommonAncestor(self, root, p, q):\\n        if not root:\\n            return root\\n        if (root.val-p.val)*(root.val-q.val) <= 0:\\n            return root\\n        node = root.left if (root.val > p.val and root.val > q.val) else root.right\\n        return self.lowestCommonAncestor(node, p, q)",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "\\n    def lowestCommonAncestor(self, root, p, q):\\n        if not root:\\n            return \\n        # p and q are on the different side of root,\\n        # or at least one of them is root\\n        if (root.val-p.val)*(root.val-q.val)<=0:\\n            return root\\n        # both p and q are on the left side of root\\n        elif root.val > p.val and root.val > q.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        # both p and q are on the right side of root\\n        else:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n\\t\\t\\t\\n\\tdef lowestCommonAncestor(self, root, p, q):\\n        if not root:\\n            return root\\n        if (root.val-p.val)*(root.val-q.val) <= 0:\\n            return root\\n        node = root.left if (root.val > p.val and root.val > q.val) else root.right\\n        return self.lowestCommonAncestor(node, p, q)",
                "codeTag": "Python3"
            },
            {
                "id": 65188,
                "title": "my-accepted-java-solution",
                "content": "    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n             if(root==null)\\n            \\t return null;\\n             if(p.val<root.val&&q.val<root.val)\\n             {\\n            \\t return lowestCommonAncestor(root.left,p,q);\\n             }\\n             if(p.val>root.val&&q.val>root.val)\\n             {\\n            \\t return lowestCommonAncestor(root.right,p,q);\\n             }else{\\n            \\t \\n            \\t return root;\\n             }\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n             if(root==null)\\n            \\t return null;\\n             if(p.val<root.val&&q.val<root.val)\\n             {\\n            \\t return lowestCommonAncestor(root.left,p,q);\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 65194,
                "title": "accepted-c-recursive-solution",
                "content": "well, it's too simple to explain,just make use of BST\\n\\n    struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\\n        \\n        \\tif (p->val<root->val && q->val<root->val)\\n        \\t\\treturn lowestCommonAncestor(root->left,p,q);\\n        \\tif (p->val>root->val && q->val>root->val)\\n        \\t\\treturn lowestCommonAncestor(root->right,p,q);\\n        \\treturn root;\\n        }",
                "solutionTags": [],
                "code": "well, it's too simple to explain,just make use of BST\\n\\n    struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\\n        \\n        \\tif (p->val<root->val && q->val<root->val)\\n        \\t\\treturn lowestCommonAncestor(root->left,p,q);\\n        \\tif (p->val>root->val && q->val>root->val)\\n        \\t\\treturn lowestCommonAncestor(root->right,p,q);\\n        \\treturn root;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 65199,
                "title": "java-python-3-iterative-and-recursive-codes-w-brief-comments-and-analysis",
                "content": "**Iterative code**\\n\\n```java\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        while (((long)root.val - p.val) * ((long)root.val - q.val) > 0) { // root.val is not between p.val and q.val.\\n            root = root.val > p.val ? root.left : root.right; // search LCA.\\n        }\\n        return root; // found.\\n    }\\n```\\n```python\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        while (root.val - p.val )  * (root.val - q.val) > 0:\\n            root = root.left if root.val > p.val else root.right\\n        return root \\n```\\n**Analysis:**\\nTime: Average `O(logn)` worst `O(n)`, space: `O(1)`.\\n\\n----\\n\\n**Recursive code**\\n\\n```java\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (p.val > q.val) {\\n            // make sure the 2nd argument < the 3rd.\\n            return lowestCommonAncestor(root, q, p);\\n        }\\n        if (root.val < p.val) { // root.val is not between p.val and q.val.\\n            return lowestCommonAncestor(root.right, p, q); // search LCA.\\n        }else if (root.val > q.val) { // root.val is not between p.val and q.val.\\n            return lowestCommonAncestor(root.left, p, q); // search LCA.\\n        }\\n        return root; // found.\\n    }\\n```\\n```python\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if p.val > q.val:\\n            return self.lowestCommonAncestor(root, q, p)\\n        if root.val > q.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        elif root.val < p.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        return root\\n```\\n**Analysis:**\\n\\nTime & space: average `O(logn)`, worst `O(n)`.\\n\\n-----\\n\\n**The following are oblelete content and just for my own reference**\\n\\nA robust and flexible code should consider corner cases, such as:\\n\\n1) at least one of *root, p,* and *q* is null;\\n\\n2) at least one of *p & q* is not a node in the tree rooted at *root*.\\n\\nThe following code with *lgn* average time complexity can deal with above corner cases. \\n\\n        private boolean binarySearch(TreeNode t, TreeNode n){\\n        if(t==null) return false;\\n        if(t.val == n.val) return true;\\n        return n.val<t.val? \\n                binarySearch(t.left, n) : \\n                binarySearch(t.right, n);\\n        }\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n          if(root==null || p==null || q==null || \\n              !binarySearch(root, p) || !binarySearch(root, q)) \\n                  return null;\\n          if(p.val == q.val) return p;\\n          TreeNode r = root;\\n          while((p.val-r.val)*(q.val-r.val) > 0)\\n              r = p.val<r.val? r.left : r.right;\\n          return r;\\n        }\\n\\n\\n  [1]: https://leetcode.com/discuss/44946/my-java-solution",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        while (((long)root.val - p.val) * ((long)root.val - q.val) > 0) { // root.val is not between p.val and q.val.\\n            root = root.val > p.val ? root.left : root.right; // search LCA.\\n        }\\n        return root; // found.\\n    }\\n```\n```python\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        while (root.val - p.val )  * (root.val - q.val) > 0:\\n            root = root.left if root.val > p.val else root.right\\n        return root \\n```\n```java\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (p.val > q.val) {\\n            // make sure the 2nd argument < the 3rd.\\n            return lowestCommonAncestor(root, q, p);\\n        }\\n        if (root.val < p.val) { // root.val is not between p.val and q.val.\\n            return lowestCommonAncestor(root.right, p, q); // search LCA.\\n        }else if (root.val > q.val) { // root.val is not between p.val and q.val.\\n            return lowestCommonAncestor(root.left, p, q); // search LCA.\\n        }\\n        return root; // found.\\n    }\\n```\n```python\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if p.val > q.val:\\n            return self.lowestCommonAncestor(root, q, p)\\n        if root.val > q.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        elif root.val < p.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3423810,
                "title": "java-easiest-solution-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(h) where h is the height of the tree\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/cd920865-22d7-476a-ac9d-772053c6a946_1681655015.8161445.png)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        \\n        // If the root is null, then there is no LCA, so return null.\\n        if(root == null){\\n            return root;\\n        }\\n\\n        // Get the value of the current node.\\n        int cur = root.val;\\n\\n        // If both p and q are greater than the current node, then the LCA is in the right subtree.\\n        if(cur < p.val && cur < q.val){\\n            return lowestCommonAncestor(root.right, p, q); // Recurse on the right subtree.\\n        }\\n        // If both p and q are less than the current node, then the LCA is in the left subtree.\\n        if(cur > p.val && cur > q.val){\\n            return lowestCommonAncestor(root.left, p, q); // Recurse on the left subtree.\\n        }\\n        // Otherwise, the current node is the LCA.\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        \\n        // If the root is null, then there is no LCA, so return null.\\n        if(root == null){\\n            return root;\\n        }\\n\\n        // Get the value of the current node.\\n        int cur = root.val;\\n\\n        // If both p and q are greater than the current node, then the LCA is in the right subtree.\\n        if(cur < p.val && cur < q.val){\\n            return lowestCommonAncestor(root.right, p, q); // Recurse on the right subtree.\\n        }\\n        // If both p and q are less than the current node, then the LCA is in the left subtree.\\n        if(cur > p.val && cur > q.val){\\n            return lowestCommonAncestor(root.left, p, q); // Recurse on the left subtree.\\n        }\\n        // Otherwise, the current node is the LCA.\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272679,
                "title": "best-o-h-solution",
                "content": "# Approach 1\\nRecursive Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(h)$$ --> h is height of the BST\\n\\n- Space complexity:\\n$$O(h)$$ --> h is height of the BST\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == NULL || p->val == root->val || q->val == root->val)\\n            return root;\\n        if (p->val < root->val && q->val < root->val)\\n                return lowestCommonAncestor(root->left, p, q);\\n        if (p->val > root->val && q->val > root->val)\\n                return lowestCommonAncestor(root->right, p, q); \\n        return root;\\n    }\\n};\\n```\\n\\n# Approach 2\\nIterative Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(h)$$ --> h is height of the BST\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while (true) {\\n            if ((p->val <= root->val && q->val >= root->val) || (p->val >= root->val && q->val <= root->val))\\n                return root;\\n            if (p->val < root->val && q->val < root->val)\\n                root = root->left;\\n            else\\n                root = root->right;        \\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == NULL || p->val == root->val || q->val == root->val)\\n            return root;\\n        if (p->val < root->val && q->val < root->val)\\n                return lowestCommonAncestor(root->left, p, q);\\n        if (p->val > root->val && q->val > root->val)\\n                return lowestCommonAncestor(root->right, p, q); \\n        return root;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while (true) {\\n            if ((p->val <= root->val && q->val >= root->val) || (p->val >= root->val && q->val <= root->val))\\n                return root;\\n            if (p->val < root->val && q->val < root->val)\\n                root = root->left;\\n            else\\n                root = root->right;        \\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249910,
                "title": "very-easy-solution-python-uwu",
                "content": "\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        while root:\\n            if p.val < root.val > q.val:\\n                root = root.left\\n            elif p.val > root.val < q.val:\\n                root = root.right\\n            else:\\n                return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        while root:\\n            if p.val < root.val > q.val:\\n                root = root.left\\n            elif p.val > root.val < q.val:\\n                root = root.right\\n            else:\\n                return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222242,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        int current = root->val;\\n        if(p->val < current && q->val < current) {\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n        else if(p->val > current && q->val > current) {\\n            return lowestCommonAncestor(root->right, p, q);\\n        }\\n        else{\\n            return root;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        int current = root->val;\\n        if(p->val < current && q->val < current) {\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n        else if(p->val > current && q->val > current) {\\n            return lowestCommonAncestor(root->right, p, q);\\n        }\\n        else{\\n            return root;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977966,
                "title": "python-easy-simple-dfs-solution-100-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if not root:\\n            return None\\n        if root.val == p.val:\\n            return p\\n        elif root.val == q.val:\\n            return q \\n        # condition when the root is the shared parent of node p and q\\n        elif root.val < max(p.val, q.val) and root.val > min(p.val, q.val):\\n            return root\\n        \\n        return self.lowestCommonAncestor(root.left, p, q) or self.lowestCommonAncestor(root.right, p, q)\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if not root:\\n            return None\\n        if root.val == p.val:\\n            return p\\n        elif root.val == q.val:\\n            return q \\n        # condition when the root is the shared parent of node p and q\\n        elif root.val < max(p.val, q.val) and root.val > min(p.val, q.val):\\n            return root\\n        \\n        return self.lowestCommonAncestor(root.left, p, q) or self.lowestCommonAncestor(root.right, p, q)\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708829,
                "title": "easiest-solution-ever-4-lines-solution",
                "content": "\\t\\t\\n\\t\\t\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n\\t\\t\\t\\tif(p.val<root.val && q.val<root.val)\\n\\t\\t\\t\\t\\treturn lowestCommonAncestor(root.left, p, q);\\n\\t\\t\\t\\tif(p.val>root.val && q.val>root.val)\\n\\t\\t\\t\\t\\treturn lowestCommonAncestor(root.right, p, q);\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n\\t\\t\\t\\tif(p.val<root.val && q.val<root.val)\\n\\t\\t\\t\\t\\treturn lowestCommonAncestor(root.left, p, q);\\n\\t\\t\\t\\tif(p.val>root.val && q.val>root.val)\\n\\t\\t\\t\\t\\treturn lowestCommonAncestor(root.right, p, q);\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2414690,
                "title": "q235-c-86-9-faster-recursive-iterative-3-line-solution",
                "content": "### C++ Solution \\nFor **recursive** method\\n```\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root->val >  p->val && root->val >  q->val) return lowestCommonAncestor(root->left , p, q);\\n        if (root->val <  p->val && root->val <  q->val) return lowestCommonAncestor(root->right, p, q);\\n        return root;\\n    }\\n```\\n\\n**The complexity of this solution:**\\n-\\tTime: O(H)\\n-\\tSpace: O(H)\\n\\n**If you loved this solution then please up vote to motivate me \\uD83D\\uDE0A**\\n___\\nAlso, For **iterative** method\\n```\\n\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* current = root;\\n        while (1) {\\n            if (p->val < current->val && q->val < current->val) current = current->left;\\n            else \\n                if (p->val > current->val && q->val > current->val) current = current->right;\\n            else \\n                break;\\n        }\\n        return current;\\n    }\\n```\\n\\n**Complexity:**\\n-\\tTime: O(H)\\n-\\tSpace: O(1)\\n\\nResult:\\n![image](https://assets.leetcode.com/users/images/4c7f686a-d7c9-4fb5-84cd-95ee071a5666_1660295308.4577987.png)\\n\\n\\n**If you loved this solution then please up vote to motivate me, and enjoy your coding\\uD83D\\uDE0A**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root->val >  p->val && root->val >  q->val) return lowestCommonAncestor(root->left , p, q);\\n        if (root->val <  p->val && root->val <  q->val) return lowestCommonAncestor(root->right, p, q);\\n        return root;\\n    }\\n```\n```\\n\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* current = root;\\n        while (1) {\\n            if (p->val < current->val && q->val < current->val) current = current->left;\\n            else \\n                if (p->val > current->val && q->val > current->val) current = current->right;\\n            else \\n                break;\\n        }\\n        return current;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2413850,
                "title": "c-4-approach-recursive-iterative",
                "content": "In this question we have to find **Lowest Common Ancestor** in Binary Search Tree\\n\\n\\n### Approach 1\\n1. In this is Approach we store path of p and q node in vector\\n2. Created GetPath function that give path of p and p\\n3. When  we get Path of p and q then we\\'ll made map to find LCA\\n```\\nclass Solution {\\npublic:\\n    \\n    void GetPath(TreeNode* root, TreeNode *target,vector<TreeNode*>& path)\\n   {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        \\n        path.push_back(root);\\n        if(root->val==target->val)\\n        {\\n\\n            return ;\\n        }\\n        if(root->val>target->val)\\n        {\\n            return GetPath(root->left,target,path);\\n        }\\n    \\n        else\\n        {\\n            return GetPath(root->right,target,path);\\n        }\\n        \\n    }\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        vector<TreeNode*> pathP;\\n        vector<TreeNode*> pathQ;\\n        GetPath(root,p,pathP);\\n        GetPath(root,q,pathQ);\\n        map<TreeNode*,int> findmap;\\n        for(auto i:pathP)\\n        {\\n            findmap[i]++;\\n        }\\n        for(int i=pathQ.size()-1;i>=0;i--)\\n        {\\n            if(findmap[pathQ[i]]>0)\\n            {\\n                return pathQ[i];\\n            }\\n        }\\n        \\n      \\n        return NULL;       \\n    }\\n};\\n```\\n\\n### Approach 2\\n1. root ==NULL is base condition \\n2. if any of the node root==p||root==q then we\\'ll return root \\n3. We\\'ll get  leftans and rightans \\n4. if (rightans==NULL)  return leftans;\\n5. else if(leftans==NULL) return rightans;\\n6. else return root;\\n7. This approach can work Binary Tree as well but In here we\\'ve Binary Search Tree so we can optimise it as well \\n\\n```\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n      \\n        if(root==NULL)\\n            return NULL;\\n        if(root==p||root==q)\\n        \\n            return root;\\n    \\n \\n        TreeNode* leftans= lowestCommonAncestor(root->left,p,q);\\n\\n        TreeNode* rightans= lowestCommonAncestor(root->right,p,q);\\n        if(rightans==NULL)\\n        {\\n\\n            return leftans;\\n        }\\n        else if(leftans==NULL)\\n        {\\n            return rightans;\\n        }\\n        else {\\n            return root;\\n        }\\n        \\n        \\n    }\\n};\\n```\\n\\n### Approach 3\\n\\n\\n1. Root value must be between p and q node\\n2. if ((root -> val > p -> val) && (root -> val > q -> val)) then we\\'ll move in left direction\\n3.  if ((root -> val < p -> val) && (root -> val < q -> val)) then we\\'ll move in right direction\\n4.  if root->val between p and q then we\\'ll return root \\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if ((root -> val > p -> val) && (root -> val > q -> val)) {\\n            return lowestCommonAncestor(root -> left, p, q);\\n        }\\n        if ((root -> val < p -> val) && (root -> val < q -> val)) {\\n            return lowestCommonAncestor(root -> right, p, q);\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n### Approach 4\\nThis is approach is same as last Apprach we doing it by while loop\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n     \\n        while(root)\\n        {\\n            if(root->val>p->val&&root->val>q->val)\\n            {\\n                root=root->left;\\n            }\\n            else if(root->val<p->val&&root->val<q->val)\\n            {\\n                root=root->right;\\n            }\\n            else\\n            {\\n                return root;\\n            }\\n        }\\n        return NULL;\\n        \\n        \\n    }\\n};\\n```\\nIf you like all the approach then make sure upvote my solution",
                "solutionTags": [
                    "Binary Search",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void GetPath(TreeNode* root, TreeNode *target,vector<TreeNode*>& path)\\n   {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        \\n        path.push_back(root);\\n        if(root->val==target->val)\\n        {\\n\\n            return ;\\n        }\\n        if(root->val>target->val)\\n        {\\n            return GetPath(root->left,target,path);\\n        }\\n    \\n        else\\n        {\\n            return GetPath(root->right,target,path);\\n        }\\n        \\n    }\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        vector<TreeNode*> pathP;\\n        vector<TreeNode*> pathQ;\\n        GetPath(root,p,pathP);\\n        GetPath(root,q,pathQ);\\n        map<TreeNode*,int> findmap;\\n        for(auto i:pathP)\\n        {\\n            findmap[i]++;\\n        }\\n        for(int i=pathQ.size()-1;i>=0;i--)\\n        {\\n            if(findmap[pathQ[i]]>0)\\n            {\\n                return pathQ[i];\\n            }\\n        }\\n        \\n      \\n        return NULL;       \\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n      \\n        if(root==NULL)\\n            return NULL;\\n        if(root==p||root==q)\\n        \\n            return root;\\n    \\n \\n        TreeNode* leftans= lowestCommonAncestor(root->left,p,q);\\n\\n        TreeNode* rightans= lowestCommonAncestor(root->right,p,q);\\n        if(rightans==NULL)\\n        {\\n\\n            return leftans;\\n        }\\n        else if(leftans==NULL)\\n        {\\n            return rightans;\\n        }\\n        else {\\n            return root;\\n        }\\n        \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if ((root -> val > p -> val) && (root -> val > q -> val)) {\\n            return lowestCommonAncestor(root -> left, p, q);\\n        }\\n        if ((root -> val < p -> val) && (root -> val < q -> val)) {\\n            return lowestCommonAncestor(root -> right, p, q);\\n        }\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n     \\n        while(root)\\n        {\\n            if(root->val>p->val&&root->val>q->val)\\n            {\\n                root=root->left;\\n            }\\n            else if(root->val<p->val&&root->val<q->val)\\n            {\\n                root=root->right;\\n            }\\n            else\\n            {\\n                return root;\\n            }\\n        }\\n        return NULL;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413537,
                "title": "java-cpp-100-faster-code-easy-solution",
                "content": "\\tPLEASE  UPVOTE IF YOU LIKE.\\n\\t\\n\\n```\\nclass Solution {\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        \\n        if(root == null || (p.val <= root.val && q.val >= root.val) || (p.val >= root.val && q.val <= root.val))\\n            return root;\\n        else if(root.val >= p.val)\\n            return lowestCommonAncestor(root.left, p, q);\\n        else\\n            return lowestCommonAncestor(root.right, p, q);\\n    }\\n}\\n```\\n\\n\\tCPP\\n```\\nclass Solution {\\npublic:\\n\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t\\tif(!root or root==p or root==q) return root;\\n\\t\\tTreeNode *l=lowestCommonAncestor(root->left,p,q);\\n\\t\\tTreeNode *r=lowestCommonAncestor(root->right,p,q);\\n\\t\\tif(l && r) return root; //if current node has p and q on respective side\\n\\t\\treturn !l?r:l;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        \\n        if(root == null || (p.val <= root.val && q.val >= root.val) || (p.val >= root.val && q.val <= root.val))\\n            return root;\\n        else if(root.val >= p.val)\\n            return lowestCommonAncestor(root.left, p, q);\\n        else\\n            return lowestCommonAncestor(root.right, p, q);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t\\tif(!root or root==p or root==q) return root;\\n\\t\\tTreeNode *l=lowestCommonAncestor(root->left,p,q);\\n\\t\\tTreeNode *r=lowestCommonAncestor(root->right,p,q);\\n\\t\\tif(l && r) return root; //if current node has p and q on respective side\\n\\t\\treturn !l?r:l;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271459,
                "title": "python-i-have-a-simple-solution-for-you",
                "content": "## I have a simple solution for you :) \\n** [Click here.](https://linktr.ee/anandchauhan)\\n\\n\\n+ Easy solution\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        cur =root\\n        while cur:\\n            if p.val > cur.val and q.val > cur.val:\\n                cur = cur.right\\n            elif p.val < cur.val and q.val < cur.val:\\n                cur = cur.left\\n            else:\\n                return cur\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        cur =root\\n        while cur:\\n            if p.val > cur.val and q.val > cur.val:\\n                cur = cur.right\\n            elif p.val < cur.val and q.val < cur.val:\\n                cur = cur.left\\n            else:\\n                return cur\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256920,
                "title": "c-space-o-1-time-o-n-some-new-idea-explanation",
                "content": "\\n\\n# Solution\\n\\n```C++\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode*& p, TreeNode*&q) {\\n        //Case 1: one is the ancestor to another.\\n        TreeNode* node;\\n        int pval = p->val;\\n        int qval = q->val;\\n        //Case 1.1: If q is ancestor of p, then in the traveeling of finding p-> val, you can meet q  earilier. \\n        node = root;\\n        while(node->val != pval) {\\n            if(node == q) return q;\\n            node = pval < node->val?node->left:node->right;\\n        }\\n        //Case 1.2: If p is ancestor of q, then in the travelling of finding q->val, you can meet p earilier. \\n        node = root;\\n        while(node->val != qval) {\\n            if(node == p) return p;\\n            node=qval<node->val?node->left:node->right;\\n        }\\n\\n        //Case 2: no one is the ancestor to another.\\n        if(p->val == q->val) return p;  \\n        if(p->val>q->val) swap(p,q);//swap to make sure p->val<=q->val\\n        while(p->right) p=p->right;\\n        while(q->left) q=q->left;\\n        //Start to find value int the bound (begin,end)  in BST\\n        int begin=p->val, end=q->val;\\n        while(!(begin<root->val && root->val<end)) {\\n            root=(root->val > end)?root->left:root->right;\\n        }\\n\\n        return root;\\n    }\\n};\\n```\\n\\n# Explanation\\nTo solve this problem, we seperate it into two cases. \\nCase 1: one is the ancestor to another.\\nCase 2: no one is the ancestor to another.\\nIf Case 1 is not happended, then solve the case 2 \\n\\nFor the case 1, \\nCase 1.1: If q is ancestor of p, then in the traveeling of finding p-> val, you can memet q earilier. \\nCase 1.2: If p is ancestor of q, then in the travelling of finding q->val, you can meet p earilier. \\n\\nFor the case 2.\\nTo decide the nodes of p and q to see who own the value smaller than another one.\\nThe tree node with samller value is called smallNode, and another one is called largeNode.\\nThe value `begin` in right-most node of smallNode is node most close to lowest common ancestor of p and q.\\nThe value `end` in left-most node of largeNode is node most close to lowest common ancestor of p and q.\\n\\nAnd the value of lowest common ancestor must be the only one node in the interval (begin, end).\\nThus, we can find the lowest common ancestor of p & q that is the node that its value is belong to (begin,end)\\n\\n# Complexity \\n**Time Complexity O(N)**\\nWhen the BST is not balanace, then we may use O(N) to find the node. \\nWe use 5 times in BST to find the node depending on the height of BST.\\n**Space Complexity O(1)**\\nWe only declare some constant number of variable in this algorithm, \\nso the space complexity is O(1) here. \\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode*& p, TreeNode*&q) {\\n        //Case 1: one is the ancestor to another.\\n        TreeNode* node;\\n        int pval = p->val;\\n        int qval = q->val;\\n        //Case 1.1: If q is ancestor of p, then in the traveeling of finding p-> val, you can meet q  earilier. \\n        node = root;\\n        while(node->val != pval) {\\n            if(node == q) return q;\\n            node = pval < node->val?node->left:node->right;\\n        }\\n        //Case 1.2: If p is ancestor of q, then in the travelling of finding q->val, you can meet p earilier. \\n        node = root;\\n        while(node->val != qval) {\\n            if(node == p) return p;\\n            node=qval<node->val?node->left:node->right;\\n        }\\n\\n        //Case 2: no one is the ancestor to another.\\n        if(p->val == q->val) return p;  \\n        if(p->val>q->val) swap(p,q);//swap to make sure p->val<=q->val\\n        while(p->right) p=p->right;\\n        while(q->left) q=q->left;\\n        //Start to find value int the bound (begin,end)  in BST\\n        int begin=p->val, end=q->val;\\n        while(!(begin<root->val && root->val<end)) {\\n            root=(root->val > end)?root->left:root->right;\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059451,
                "title": "c-recursive-solution-faster-than-99-66-explained-solution",
                "content": "In this approach we will just check that values of p and q nodes are greater than root node or less than root node. If both p and q values are greater than root shift to right node of BST and if both p and q values are less than root node shift to left node otherwise return root node.\\n\\n\\'\\'\\'\\n\\n\\t\\tclass Solution {\\n\\t\\t\\n\\tpublic:\\n\\t\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t\\t\\n\\t\\t\\t// Check if p and q values are less than root value to shift to left of root node\\n\\t\\t\\tif(p->val < root->val && q->val < root->val)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn lowestCommonAncestor(root->left,p,q);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// Check if p and q values are greater than root value to shift to right of root node\\n\\t\\t\\telse if(p->val > root->val && q->val > root->val)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn lowestCommonAncestor(root->right,p,q);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\t\\n\\tpublic:\\n\\t\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t\\t\\n\\t\\t\\t// Check if p and q values are less than root value to shift to left of root node\\n\\t\\t\\tif(p->val < root->val && q->val < root->val)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn lowestCommonAncestor(root->left,p,q);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1779221,
                "title": "c-simplest-recursive-solution-using-bst-property",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root->val==p->val || root->val==q->val) return root;\\n        if(root->val>p->val && root->val<q->val) return root;\\n        if(root->val>q->val && root->val<p->val) return root;\\n        \\n        if(p->val>root->val && q->val>root->val) return lowestCommonAncestor(root->right, p, q);\\n        return lowestCommonAncestor(root->left, p, q);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root->val==p->val || root->val==q->val) return root;\\n        if(root->val>p->val && root->val<q->val) return root;\\n        if(root->val>q->val && root->val<p->val) return root;\\n        \\n        if(p->val>root->val && q->val>root->val) return lowestCommonAncestor(root->right, p, q);\\n        return lowestCommonAncestor(root->left, p, q);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349304,
                "title": "c-clean-easy-iterative-method-explanation",
                "content": "**Solution:**\\n\\n**Approach:** \\nThis problem statement can be solved using both recursive and iterative methods. Here, we are going to talk about an easy iterative way to implement this concept `LCA`.\\n\\n* Simply start iterating from the root. Whenever, we find a node which lies between the two given nodes, we have found out the `LCA of p and q`.\\n* Otherwise, we have got `two base cases`:\\n\\t* Check if the value of root node is greater than both the given nodes. If this condition is satisfied, our `LCA` would always lie on the `left subtree`. Thus, assign value `root->left` to `root`.\\n\\t* Check if the value of root node is less than both the given nodes. If this condition is satisfied, our `LCA` would always lie on the `right subtree`. Thus, assign value `root->right` to `root`.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while(root != NULL){\\n            if(root->val > p->val and root->val > q->val){\\n                root = root->left;\\n            }    \\n            else if(root->val < p->val and root->val < q->val){\\n                root = root->right;\\n            }\\n            else\\n                break;\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n`Time Complexity`: **`O(n)`**\\n`Space Complexity`:  **`O(1)`**\\nwhere **n** is **height** of the given **BST**.\\n\\n\\n**Feel free to share your approach or any improvements as well.**",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while(root != NULL){\\n            if(root->val > p->val and root->val > q->val){\\n                root = root->left;\\n            }    \\n            else if(root->val < p->val and root->val < q->val){\\n                root = root->right;\\n            }\\n            else\\n                break;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347816,
                "title": "lowest-common-ancestor-of-a-binary-search-tree-c-recursion-with-approach",
                "content": "# **APPROACH:**\\nWe recursively traverse the BST: (LCA = Lowest Common Ancestor)\\n* If node\\u2019s value is greater than both p and q then our LCA lies in the left side of the node. \\n* If it\\u2019s is smaller than both p and p, then LCA lies on the right side. \\n* Otherwise, the root is LCA (assuming that both p and q are present in BST).\\n\\n# **ALGORITHM:**\\n1. Create a recursive function that takes a node and the two values p and q.\\n2. If the value of the current node is less than both p and q, then LCA lies in the right subtree. Call the recursive function for the right subtree.\\n3. If the value of the current node is greater than both p and q, then LCA lies in the left subtree. Call the recursive function for the left subtree.\\n4. If both the above cases are false then return the current node as LCA.\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n      if(root == NULL || root == p || root == q)\\n      {\\n          return root ;\\n      }\\n      TreeNode* left = lowestCommonAncestor(root->left ,  p ,  q);\\n      TreeNode* right = lowestCommonAncestor(root->right , p , q);\\n      if(left != NULL && right != NULL)\\n      {\\n          return root ;\\n      }\\n      else\\n      {\\n          if(left == NULL)\\n          {\\n              return right ;\\n          }\\n          return left ;\\n      }\\n    }\\n};\\n```\\n**Time Complexity: O(h)\\nSpace Complexity: O(h)\\nWhere \\'h\\' is the height of the tree**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n      if(root == NULL || root == p || root == q)\\n      {\\n          return root ;\\n      }\\n      TreeNode* left = lowestCommonAncestor(root->left ,  p ,  q);\\n      TreeNode* right = lowestCommonAncestor(root->right , p , q);\\n      if(left != NULL && right != NULL)\\n      {\\n          return root ;\\n      }\\n      else\\n      {\\n          if(left == NULL)\\n          {\\n              return right ;\\n          }\\n          return left ;\\n      }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706182,
                "title": "java-3-line-easy-solution-o-log-n",
                "content": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left , p, q);\\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left , p, q);\\n        return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 65070,
                "title": "2-line-java-solution",
                "content": "    if ((p.val - root.val) * (root.val - q.val) >= 0) return root;\\n    return (p.val > root.val) ? lowestCommonAncestor(root.right, p, q) : lowestCommonAncestor(root.left, p, q);",
                "solutionTags": [],
                "code": "    if ((p.val - root.val) * (root.val - q.val) >= 0) return root;\\n    return (p.val > root.val) ? lowestCommonAncestor(root.right, p, q) : lowestCommonAncestor(root.left, p, q);",
                "codeTag": "Unknown"
            },
            {
                "id": 65088,
                "title": "rainbowsecret-c-solution",
                "content": "    class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            while( (root->val-p->val)*(root->val-q->val) > 0){\\n                root = root->val > p->val ? root->left : root->right;\\n            }\\n            return root;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            while( (root->val-p->val)*(root->val-q->val) > 0){\\n                root = root->val > p->val ? root->left : root->right;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 65098,
                "title": "sharing-my-44ms-c-solution",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n     \\n    class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(root == NULL)\\n                return NULL;\\n            \\n            if(root == p || root == q)\\n                return root;\\n                \\n            TreeNode* left  =  lowestCommonAncestor(root->left, p, q);\\n            TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n            \\n            if(left && right)\\n                return root;\\n            \\n            else if(left)\\n                return left;\\n                \\n            else\\n                return right;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(root == NULL)\\n                return NULL;\\n            \\n            if(root == p || root == q)\\n                return root;\\n                \\n            TreeNode* left  =  lowestCommonAncestor(root->left, p, q);\\n            TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n            \\n            if(left && right)\\n                return root;\\n            \\n            else if(left)\\n                return left;\\n                \\n            else\\n                return right;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 65115,
                "title": "simple-while-loop-java-solution",
                "content": "    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            boolean change=true;\\n            while(change){       //when p and q on the two side of BST (or one is equal to root), exit the loop\\n                change=false;\\n                while(p.val<root.val&&q.val<root.val){\\n                    root=root.left;\\n                    change=true;\\n                }\\n                \\n                while(p.val>root.val&&q.val>root.val){\\n                    root=root.right;\\n                    change=true;\\n                }\\n            }\\n            \\n            \\n            return root;\\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            boolean change=true;\\n            while(change){       //when p and q on the two side of BST (or one is equal to root), exit the loop\\n                change=false;\\n                while(p.val<root.val&&q.val<root.val){\\n                    root=root.left;\\n                    change=true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 65137,
                "title": "20ms-c-solution-iterative",
                "content": "    typedef struct TreeNode tn;\\n    /* tn* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) */\\n    tn* lowestCommonAncestor(tn* root, tn* p, tn* q)\\n    {\\n      /* assume p is on the left */\\n      if(p->val>q->val)\\n      {\\n        tn* tmp = p;\\n        p=q, q=tmp;\\n      }\\n      \\n      tn* lca = root;\\n      while(!(p->val<=lca->val && q->val>=lca->val))\\n      {\\n        if(p->val > lca->val)\\n          lca = lca->right;\\n        else if(q->val < lca->val)\\n          lca = lca->left;\\n      }    \\n    \\n      return lca;\\n    }",
                "solutionTags": [
                    "Binary Search",
                    "Tree"
                ],
                "code": "    typedef struct TreeNode tn;\\n    /* tn* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) */\\n    tn* lowestCommonAncestor(tn* root, tn* p, tn* q)\\n    {\\n      /* assume p is on the left */\\n      if(p->val>q->val)\\n      {\\n        tn* tmp = p;\\n        p=q, q=tmp;\\n      }\\n      \\n      tn* lca = root;\\n      while(!(p->val<=lca->val && q->val>=lca->val))\\n      {\\n        if(p->val > lca->val)\\n          lca = lca->right;\\n        else if(q->val < lca->val)\\n          lca = lca->left;\\n      }    \\n    \\n      return lca;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 65187,
                "title": "my-1-line-java-solution",
                "content": "The solution is simple:\\n\\n    return ((p.val-root.val)*(q.val-root.val)<=0) ? root : lowestCommonAncestor(p.val>root.val?root.right:root.left, p, q);",
                "solutionTags": [
                    "Java"
                ],
                "code": "The solution is simple:\\n\\n    return ((p.val-root.val)*(q.val-root.val)<=0) ? root : lowestCommonAncestor(p.val>root.val?root.right:root.left, p, q);",
                "codeTag": "Unknown"
            },
            {
                "id": 3974521,
                "title": "3-best-c-solutions-recursive-and-iterative-approach-beats-100",
                "content": "## [Similar question - LCA of binary tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3959105/2-easy-c-solutions-recursive-and-iterative-approach-beats-100/?envType=list&envId=r8ctlrc6) \\n\\n## Image for simple understanding\\n![Solution](https://assets.leetcode.com/users/images/7689ea13-2767-4d54-a050-9a3de386f732_1693285333.1166608.png) \\n\\n##### Image credits to @hiepit \\n\\n# Code\\n```\\n// Recursive solution - Same as LCA of binary tree\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n        \\n        TreeNode *leftAns = lowestCommonAncestor(root->left, p, q);\\n        TreeNode *rightAns = lowestCommonAncestor(root->right, p, q);\\n\\n        if(leftAns != NULL && rightAns != NULL)\\n            return root;\\n        else if(leftAns != NULL && rightAns == NULL)\\n            return leftAns;\\n        return rightAns;\\n    }\\n};\\n\\n// Recurisve solution - Binary search tree property\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        // If both nodes have smaller value than root, go left\\n        if(root->val > p->val && root->val > q->val){\\n            return lowestCommonAncestor(root -> left, p, q);\\n        }\\n        // If both nodes have higher value than root, go right\\n        if(root->val < p->val && root->val < q->val){\\n            return lowestCommonAncestor(root -> right, p, q);\\n        }\\n        return root;\\n    }\\n};\\n\\n// Iterative solution - Binary search tree property\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while(root != NULL){\\n            // If both nodes have smaller value than root, go left\\n            if(root->val > p->val && root->val > q->val)\\n                root = root->left;\\n            // If both nodes have higher value than root, go right\\n            else if(root->val < p->val && root->val < q->val)\\n                root = root->right;\\n            else \\n                break;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n// Recursive solution - Same as LCA of binary tree\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n        \\n        TreeNode *leftAns = lowestCommonAncestor(root->left, p, q);\\n        TreeNode *rightAns = lowestCommonAncestor(root->right, p, q);\\n\\n        if(leftAns != NULL && rightAns != NULL)\\n            return root;\\n        else if(leftAns != NULL && rightAns == NULL)\\n            return leftAns;\\n        return rightAns;\\n    }\\n};\\n\\n// Recurisve solution - Binary search tree property\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        // If both nodes have smaller value than root, go left\\n        if(root->val > p->val && root->val > q->val){\\n            return lowestCommonAncestor(root -> left, p, q);\\n        }\\n        // If both nodes have higher value than root, go right\\n        if(root->val < p->val && root->val < q->val){\\n            return lowestCommonAncestor(root -> right, p, q);\\n        }\\n        return root;\\n    }\\n};\\n\\n// Iterative solution - Binary search tree property\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while(root != NULL){\\n            // If both nodes have smaller value than root, go left\\n            if(root->val > p->val && root->val > q->val)\\n                root = root->left;\\n            // If both nodes have higher value than root, go right\\n            else if(root->val < p->val && root->val < q->val)\\n                root = root->right;\\n            else \\n                break;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867300,
                "title": "lowest-common-ancestor-of-bst-in-java-100-fast-solution-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that in bst the two nodes p and q can lie on either sides of root or at same side of the root. Therefore, the lowest common ancestor will be the node that splits both the nodes on either side of the bst or the node which itself is either of p or q.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/13eefeec-a9e2-4ac6-a036-1426669612a5_1691240130.2432892.png)\\n\\nWe know that in bst the two nodes p and q can lie on either sides of root or at same side of the root. For eg in the above example 1, 2 and 8 lie on opposite sides of 6 and thus 6 is LCA(2, 8).\\n\\nTherefore, we can conclude that lowest common ancestor for two nodes will the node that splits both p and q to either side of itself.\\n\\n![image.png](https://assets.leetcode.com/users/images/bf283ff0-c57d-4f15-93c2-0555da122bb4_1691240151.3338797.png)\\n\\n\\nIn example 2, we can see that both nodes p and q do not lie at left nor at right of any node thus, in such case the root is the LCA. this is because if p and q both do not lie on same side then that means that root node is one of the node from p or q. Thus, it becomes LCA.\\n\\nTherefore, we traverse the bst and move to left or right according to node value until root becomes null or we find the split in paths. Once split in paths is found or node is equal to either p or q then we return that node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(h) {height of bst}\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) {No extra space used}\\n\\nIf this helped you in clearing the concept and solve the question then please upvote the solution!!!\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        while(root != null){\\n            if(root.val > p.val && root.val > q.val){\\n                root = root.left;\\n            } else if(root.val < p.val && root.val < q.val){\\n                root = root.right;\\n            } else{\\n                return root;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        while(root != null){\\n            if(root.val > p.val && root.val > q.val){\\n                root = root.left;\\n            } else if(root.val < p.val && root.val < q.val){\\n                root = root.right;\\n            } else{\\n                return root;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643526,
                "title": "c-simple-and-efficient-recursive-algorithm",
                "content": "This algorithm finds the lowest common ancestor of nodes p and q in a binary tree by traversing the tree recursively, checking the left and right subtrees. If one of the subtrees is NULL, it means the LCA must be in the other subtree. If both subtrees are not NULL, the current root is the LCA.\\n\\n1.If the root is NULL or equal to either of the two nodes (p or q), return the root.\\n2.Recursively call the function on the left subtree, storing the result in the variable left.\\n3.Recursively call the function on the right subtree, storing the result in the variable right.\\n4.If left is NULL, return right.\\n5.If right is NULL, return left. Otherwise, return the root.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n        TreeNode* left = lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right = lowestCommonAncestor(root->right,p,q);\\n        if(left == NULL)\\n            return right;\\n        else if(right == NULL)\\n            return left;\\n        else return root;\\n    }\\n};\\n```\\n\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n        TreeNode* left = lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right = lowestCommonAncestor(root->right,p,q);\\n        if(left == NULL)\\n            return right;\\n        else if(right == NULL)\\n            return left;\\n        else return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579443,
                "title": "using-bst-property-cpp-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- **Utilize the properties of the binary search tree:** `Take advantage of the fact that the binary search tree is organized in a way that values on the left subtree are less than the root, and values on the right subtree are greater than the root. This property can guide you in determining which subtree to explore based on the values of the nodes p and q.`\\n\\n- **Recurse through the tree:**` Use a recursive approach to traverse the binary search tree. Compare the values of the current node with the values of p and q to determine the lowest common ancestor. If the current node\\'s value is greater than both p and q, recurse on the left subtree. If the current node\\'s value is less than both p and q, recurse on the right subtree. By recursively traversing the tree, you can narrow down the search and find the lowest common ancestor efficiently.`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The function lowestCommonAncestor takes three parameters: root, p, and q.\\n- If the root is NULL, indicating the end of the tree, the function returns NULL.\\n- If the value of the root node is equal to either the value of p or q, the function returns the root node, as it is the lowest common ancestor.\\n- If the value of root is between the values of p and q, inclusive, the function returns the root node, as it is the lowest common ancestor.\\n- If the value of root is greater than both p and q, the function recursively calls lowestCommonAncestor on the left subtree (root->left) to find the lowest common ancestor.\\n- If the value of root is less than both p and q, the function recursively calls lowestCommonAncestor on the right subtree (root->right) to find the lowest common ancestor.\\n- If none of the above conditions are met, the function returns NULL, indicating that the lowest common ancestor was not found.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`The time complexity of the provided code is O(h), where h is the height of the binary search tree. In the worst case, the binary search tree can be skewed, resulting in a time complexity of O(n), where n is the number of nodes in the tree. This is because in the worst case, we may need to traverse the entire height of the tree to reach the lowest common ancestor.`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`The space complexity of the code is O(h) as well, considering the space used by the recursive calls. In the worst case, the recursive call stack can have a maximum depth equal to the height of the tree. However, if the binary search tree is balanced, the height of the tree would be log(n), resulting in a space complexity of O(log n).`\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return NULL;\\n\\n        if(root->val == p->val || root->val == q->val)\\n        return root;\\n\\n        if(root->val > p->val && root->val < q->val)\\n        return root;\\n        else if(root->val > q->val && root->val < p->val)\\n        return root;\\n\\n        if(root->val > p->val && root->val > q->val)\\n        return lowestCommonAncestor(root->left,p,q);\\n        else if(root->val < p->val && root->val < q->val)\\n        return lowestCommonAncestor(root->right,p,q);\\n\\n        return NULL;\\n    }\\n};\\n```\\n![PLEASE UPVOTE.jpg](https://assets.leetcode.com/users/images/896ffe2e-eb4e-4e91-bb1f-a6ea5ff76166_1685464267.7967212.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return NULL;\\n\\n        if(root->val == p->val || root->val == q->val)\\n        return root;\\n\\n        if(root->val > p->val && root->val < q->val)\\n        return root;\\n        else if(root->val > q->val && root->val < p->val)\\n        return root;\\n\\n        if(root->val > p->val && root->val > q->val)\\n        return lowestCommonAncestor(root->left,p,q);\\n        else if(root->val < p->val && root->val < q->val)\\n        return lowestCommonAncestor(root->right,p,q);\\n\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439106,
                "title": "java-simple-recursive-solution-iterative-solution-in-o-h-with-detailed-explanation",
                "content": "# Intuition\\nSince the given binary tree is a BST, and we assume `p` and `q` will exist in this BST, the LCA of `p` and `q` actually is the first node that splits `p.val` and `q.val`, i.e. it is either `p.val <= LCA.val <= q.val` or `q.val <= LCA.val <= p.val` (since all `node.val` are unique, in reality there will be at most one \"=\"). In this case, we can simplify this problem to a simple search problem within BST.\\n\\nNote that if we do not have the constraint \"`p` and `q` will exist in this BST\", we have to traverse the entire BST to check the existence `p` and `q`. The following \"first spliting node\" method will not be applicable any more.\\n\\n# Approach\\nWe can either use recursion or iteration to solve this problem.\\n\\n---\\nRecursive approach:\\nBase case: if the root is null, then return null.\\nRecursive rule:\\n- if both `p.val` and `q.val` are smaller than `root.val`, then the LCA must be within the root\\'s left subtree, so we search the root\\'s left child;\\n- if both `p.val` and `q.val` are greater than `root.val`, then the LCA must be within the root\\'s right subtree, so we search the root\\'s right child;\\n- otherwise, `root` splits `p` and `q`, so we return root as our result.\\n\\n---\\nIterative approach:\\nThe logic is very similar to recursive approach, but by using iteration, we can avoid using O(h) space on the stack.\\nSo basically we create a pointer starting from `root`. We create a while-loop to search LCA until `root` becomes `null`.\\n- if both `p.val` and `q.val` are smaller than `root.val`, then the LCA must be within the root\\'s left subtree, so we substitute `root` by its left child and continue the loop;\\n- if both `p.val` and `q.val` are greater than `root.val`, then the LCA must be within the root\\'s right subtree, so we substitute `root` by its right child and continue the loop;\\n- otherwise, `root` splits `p` and `q`, so we return root as our result.\\n\\n# Complexity\\n- Time complexity: $$O(h)$$ for both recursive & iterative approach\\n\\n- Space complexity: $$O(h)$$ for recursive approach, $$O(1)$$ for iterative approach\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        // Recursive approach\\n        if (root == null) return null;\\n        if (p.val < root.val && q.val < root.val) {\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        if (p.val > root.val && q.val > root.val) {\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        // Iterative approach\\n        TreeNode node = root;\\n        while (node != null) {\\n            if (p.val < node.val && q.val < node.val) {\\n                node = node.left;\\n            }\\n            else if (p.val > node.val && q.val > node.val) {\\n                node = node.right;\\n            }\\n            else {\\n                return node;\\n            }\\n        }\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        // Recursive approach\\n        if (root == null) return null;\\n        if (p.val < root.val && q.val < root.val) {\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        if (p.val > root.val && q.val > root.val) {\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        // Iterative approach\\n        TreeNode node = root;\\n        while (node != null) {\\n            if (p.val < node.val && q.val < node.val) {\\n                node = node.left;\\n            }\\n            else if (p.val > node.val && q.val > node.val) {\\n                node = node.right;\\n            }\\n            else {\\n                return node;\\n            }\\n        }\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954299,
                "title": "c-3-line-code-clean-and-simple-code",
                "content": "![image](https://assets.leetcode.com/users/images/039a21bb-7bed-4802-b673-e5ffb6782c22_1672071057.0214615.png)\\n\\n**T->O(Height of Tree) && S->O(Height of Tree) [ASS]**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tTreeNode* lowestCommonAncestor(TreeNode* curr,TreeNode* p,TreeNode* q) {\\n\\t\\t\\t\\tif(!curr) return NULL;\\n\\t\\t\\t\\tif(p->val<curr->val && q->val<curr->val) return lowestCommonAncestor(curr->left,p,q);\\n\\t\\t\\t\\tif(p->val>curr->val && q->val>curr->val) return lowestCommonAncestor(curr->right,p,q);\\n\\t\\t\\t\\treturn curr;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tTreeNode* lowestCommonAncestor(TreeNode* curr,TreeNode* p,TreeNode* q) {\\n\\t\\t\\t\\tif(!curr) return NULL;\\n\\t\\t\\t\\tif(p->val<curr->val && q->val<curr->val) return lowestCommonAncestor(curr->left,p,q);\\n\\t\\t\\t\\tif(p->val>curr->val && q->val>curr->val) return lowestCommonAncestor(curr->right,p,q);\\n\\t\\t\\t\\treturn curr;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2838219,
                "title": "java-iterative",
                "content": "```\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        TreeNode node = root;\\n        while (node != null) {\\n            if (node.val > p.val && node.val > q.val) {\\n                node = node.left;\\n            } else if (node.val < p.val && node.val < q.val) {\\n                node = node.right;\\n            } else return node;\\n        }\\n        return null;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        TreeNode node = root;\\n        while (node != null) {\\n            if (node.val > p.val && node.val > q.val) {\\n                node = node.left;\\n            } else if (node.val < p.val && node.val < q.val) {\\n                node = node.right;\\n            } else return node;\\n        }\\n        return null;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2792989,
                "title": "c-solution-lowest-common-ancestor-of-a-binary-search-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        //base case\\n        if(root == NULL)\\n            return NULL;\\n        \\n        if(root->val > p->val && root->val > q->val)\\n            return lowestCommonAncestor(root->left , p , q);\\n        \\n        else if(root->val < p->val && root->val < q->val)\\n            return lowestCommonAncestor(root->right , p , q);\\n        \\n        else\\n            return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        //base case\\n        if(root == NULL)\\n            return NULL;\\n        \\n        if(root->val > p->val && root->val > q->val)\\n            return lowestCommonAncestor(root->left , p , q);\\n        \\n        else if(root->val < p->val && root->val < q->val)\\n            return lowestCommonAncestor(root->right , p , q);\\n        \\n        else\\n            return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786116,
                "title": "c-easy-to-understand-solution",
                "content": "# Upvote if its helps\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(p==q) return p;\\n        if(p==root || q==root) return root;\\n        TreeNode* temp=root;\\n        while(temp){\\n            if(temp->val>p->val&& temp->val>q->val){\\n                temp=temp->left;\\n            }\\n            else if(temp->val<p->val&& temp->val<q->val){\\n                temp=temp->right;\\n            }\\n            else return temp;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(p==q) return p;\\n        if(p==root || q==root) return root;\\n        TreeNode* temp=root;\\n        while(temp){\\n            if(temp->val>p->val&& temp->val>q->val){\\n                temp=temp->left;\\n            }\\n            else if(temp->val<p->val&& temp->val<q->val){\\n                temp=temp->right;\\n            }\\n            else return temp;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741086,
                "title": "235-lowest-common-ancestor-of-a-binary-search-tree",
                "content": "// see the code is very easy why >> coz of bst see cases\\n// either on l and r  >> both on l >> both on r >> the root it self is the ans \\n// now see if a both val are not on l or r means one is on l and one is on r so the point where they split is the point of the lca \\n// just dry run any eg and sorted \\n// pls upvote if you like the sol :)\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) \\n    {\\n      if(root==null)\\n          return null ;\\n        if( root.val>p.val && root.val>q.val){\\n            return  lowestCommonAncestor(root.left,p,q) ;\\n        }\\n        else if(p.val >root.val && q.val> root.val){\\n            return lowestCommonAncestor(root.right,p,q) ;\\n        }\\n         return root;\\n            \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) \\n    {\\n      if(root==null)\\n          return null ;\\n        if( root.val>p.val && root.val>q.val){\\n            return  lowestCommonAncestor(root.left,p,q) ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2415659,
                "title": "java-javascript-python-short-clean-easy",
                "content": "```java []\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        int max = Math.max(p.val, q.val), min = Math.min(p.val, q.val);\\n        if(root.val == min || root.val == max)    return root;\\n        if(root.val < max && root.val > min)  return root;\\n        return lowestCommonAncestor(min > root.val ? root.right : root.left, p, q);\\n    }\\n}\\n```\\n```javascript []\\nvar lowestCommonAncestor = function(root, p, q) {\\n    let max = Math.max(p.val, q.val), min = Math.min(p.val, q.val)\\n    if(root.val == min || root.val == max)    return root\\n    if(root.val < max && root.val > min)  return root\\n    return lowestCommonAncestor(min > root.val ? root.right : root.left, p, q)\\n};\\n```\\n```python []\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        mx, mn = max(p.val, q.val), min(p.val, q.val)\\n        if root.val == mn or root.val == mx:\\n            return root\\n        if root.val < mx and root.val > mn:\\n            return root\\n        return self.lowestCommonAncestor(root.right if mn > root.val else root.left, p, q)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```java []\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        int max = Math.max(p.val, q.val), min = Math.min(p.val, q.val);\\n        if(root.val == min || root.val == max)    return root;\\n        if(root.val < max && root.val > min)  return root;\\n        return lowestCommonAncestor(min > root.val ? root.right : root.left, p, q);\\n    }\\n}\\n```\n```javascript []\\nvar lowestCommonAncestor = function(root, p, q) {\\n    let max = Math.max(p.val, q.val), min = Math.min(p.val, q.val)\\n    if(root.val == min || root.val == max)    return root\\n    if(root.val < max && root.val > min)  return root\\n    return lowestCommonAncestor(min > root.val ? root.right : root.left, p, q)\\n};\\n```\n```python []\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        mx, mn = max(p.val, q.val), min(p.val, q.val)\\n        if root.val == mn or root.val == mx:\\n            return root\\n        if root.val < mx and root.val > mn:\\n            return root\\n        return self.lowestCommonAncestor(root.right if mn > root.val else root.left, p, q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415215,
                "title": "lowest-ancestor-in-bst-recursion-bst-property",
                "content": "Hi,\\n\\nSince the basic principle of BST is the item to the left is less than the root and item to the right is greater than the root.\\n\\nWe have to find the root which has value inbetween given left and right.\\n\\n```\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n\\t\\tif(p.val<root.val && q.val<root.val)\\n\\t\\t\\treturn lowestCommonAncestor(root.left, p, q);\\n\\t\\tif(p.val>root.val && q.val>root.val)\\n\\t\\t\\treturn lowestCommonAncestor(root.right, p, q);\\n\\t\\treturn root;\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "Hi,\\n\\nSince the basic principle of BST is the item to the left is less than the root and item to the right is greater than the root.\\n\\nWe have to find the root which has value inbetween given left and right.\\n\\n```\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n\\t\\tif(p.val<root.val && q.val<root.val)\\n\\t\\t\\treturn lowestCommonAncestor(root.left, p, q);\\n\\t\\tif(p.val>root.val && q.val>root.val)\\n\\t\\t\\treturn lowestCommonAncestor(root.right, p, q);\\n\\t\\treturn root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2413895,
                "title": "simple-iterative-solution",
                "content": "Simple iterative solution to get LCA.\\n```\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* cur = root;\\n        while (true) {\\n            if (p -> val < cur -> val && q -> val < cur -> val) {\\n                cur = cur -> left;\\n            } else if (p -> val > cur -> val && q -> val > cur -> val) {\\n                cur = cur -> right;\\n            } else {\\n                break;\\n            }\\n        }\\n        return cur;\\n    \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "```\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* cur = root;\\n        while (true) {\\n            if (p -> val < cur -> val && q -> val < cur -> val) {\\n                cur = cur -> left;\\n            } else if (p -> val > cur -> val && q -> val > cur -> val) {\\n                cur = cur -> right;\\n            } else {\\n                break;\\n            }\\n        }\\n        return cur;\\n    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2288554,
                "title": "c-solution-easy-approach-with-explanation-tc-o-n-sc-o-n-recursive-stack-space",
                "content": "```\\n\\n // If this helps plz consider upvote :)\\n \\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        // Logic is simple \\n        // first point where we can\\'t able to determine whether node is on left or right part of tree is the our LCA\\n        if(root == NULL){\\n            return NULL;\\n        }\\n        \\n        int curr = root->val;\\n        \\n        // curr value is less than value of both q and p go on right sub tree\\n        if(curr < p->val && curr < q->val){\\n            return lowestCommonAncestor(root->right,p,q);\\n        }\\n        \\n        // curr value is greater than both q and p then search on left sub tree;\\n        if(curr > p->val && curr > q->val){\\n            return lowestCommonAncestor(root->left,p,q);\\n        }\\n        \\n        \\n        return root;\\n    }\\n};\\n\\n // If this helps plz consider upvote :)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n\\n // If this helps plz consider upvote :)\\n \\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        // Logic is simple \\n        // first point where we can\\'t able to determine whether node is on left or right part of tree is the our LCA\\n        if(root == NULL){\\n            return NULL;\\n        }\\n        \\n        int curr = root->val;\\n        \\n        // curr value is less than value of both q and p go on right sub tree\\n        if(curr < p->val && curr < q->val){\\n            return lowestCommonAncestor(root->right,p,q);\\n        }\\n        \\n        // curr value is greater than both q and p then search on left sub tree;\\n        if(curr > p->val && curr > q->val){\\n            return lowestCommonAncestor(root->left,p,q);\\n        }\\n        \\n        \\n        return root;\\n    }\\n};\\n\\n // If this helps plz consider upvote :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271203,
                "title": "c-short-clean-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!***\\n\\t\\n\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        if(!root) return NULL;\\n        \\n        if(root->val == p->val || root->val==q->val) return root;\\n        \\n        if(root->val > p->val && root->val > q->val){\\n            return lowestCommonAncestor(root->left,p,q);\\n        }\\n        else if(root->val < p->val && root->val < q->val){\\n            return lowestCommonAncestor(root->right,p,q);\\n        }\\n        \\n        TreeNode *a=lowestCommonAncestor(root->left,p,q);\\n        TreeNode *b=lowestCommonAncestor(root->right,p,q);\\n        \\n        if(!a) return b;\\n        else if (!b) return a;\\n        else if(a && b) return root;\\n        return NULL;\\n    }",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!***\\n\\t\\n\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        if(!root) return NULL;\\n        \\n        if(root->val == p->val || root->val==q->val) return root;\\n        \\n        if(root->val > p->val && root->val > q->val){\\n            return lowestCommonAncestor(root->left,p,q);\\n        }\\n        else if(root->val < p->val && root->val < q->val){\\n            return lowestCommonAncestor(root->right,p,q);\\n        }\\n        \\n        TreeNode *a=lowestCommonAncestor(root->left,p,q);\\n        TreeNode *b=lowestCommonAncestor(root->right,p,q);\\n        \\n        if(!a) return b;\\n        else if (!b) return a;\\n        else if(a && b) return root;\\n        return NULL;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2101631,
                "title": "o-h-time-3-line-of-logic-with-comment-c-easy-solution",
                "content": "```\\n// if both are larger then root go right recursively\\n// if both are smaller then root go left recursively\\n// else return the root\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root)   return root;\\n        if(p->val>root->val and q->val>root->val){\\n            return lowestCommonAncestor(root->right, p, q);\\n        }\\n        else if(p->val<root->val and q->val<root->val){\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// if both are larger then root go right recursively\\n// if both are smaller then root go left recursively\\n// else return the root\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root)   return root;\\n        if(p->val>root->val and q->val>root->val){\\n            return lowestCommonAncestor(root->right, p, q);\\n        }\\n        else if(p->val<root->val and q->val<root->val){\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742451,
                "title": "c-easiest-approach",
                "content": "**Please upvote if you like this approach \\\\ solution** \\uD83D\\uDE0A\\t\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\n\\t\\t\\tTreeNode* currNode = root;\\n\\n\\t\\t\\twhile(currNode != NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(currNode->val > p->val && currNode->val > q->val)           \\n\\t\\t\\t\\t\\tcurrNode = currNode->left;\\n\\n\\t\\t\\t\\telse if(currNode->val < p->val && currNode->val < q->val)\\n\\t\\t\\t\\t\\tcurrNode = currNode->right;\\n\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn currNode;\\n\\t\\t\\t}\\n\\t\\t\\treturn NULL;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\n\\t\\t\\tTreeNode* currNode = root;\\n\\n\\t\\t\\twhile(currNode != NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(currNode->val > p->val && currNode->val > q->val)           \\n\\t\\t\\t\\t\\tcurrNode = currNode->left;\\n\\n\\t\\t\\t\\telse if(currNode->val < p->val && currNode->val < q->val)\\n\\t\\t\\t\\t\\tcurrNode = currNode->right;\\n\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn currNode;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1652166,
                "title": "simple-recursion-solution",
                "content": "**Simple Solution**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        //IMP :\\n        //CASE1 : If root->val > p and root->val > q then LCA might be in left-subtree\\n        //CASE2 : if root->vl < p and root->val <p then LCA might be in right-subtree\\n        //CASE3 :  if none  of the cases is correct then it might  p is in left and q is in right or vice-verse then root->val which is pointing is the LCA \\n        \\n        if(!root)return nullptr;\\n        if(root->val < p->val and root->val <q->val)\\n            return lowestCommonAncestor(root->right,p,q);\\n        if(root->val > p->val and root->val > q->val)\\n            return lowestCommonAncestor(root->left,p,q);\\n        return root;\\n         \\n    }\\n};\\n```\\n\\n**TC : O(H) H is the height of BST**\\n*if you liked the post then please upvote thats keeps me motivating*\\uD83C\\uDF88\\uD83D\\uDE01\\n**:) happy coding**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        //IMP :\\n        //CASE1 : If root->val > p and root->val > q then LCA might be in left-subtree\\n        //CASE2 : if root->vl < p and root->val <p then LCA might be in right-subtree\\n        //CASE3 :  if none  of the cases is correct then it might  p is in left and q is in right or vice-verse then root->val which is pointing is the LCA \\n        \\n        if(!root)return nullptr;\\n        if(root->val < p->val and root->val <q->val)\\n            return lowestCommonAncestor(root->right,p,q);\\n        if(root->val > p->val and root->val > q->val)\\n            return lowestCommonAncestor(root->left,p,q);\\n        return root;\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448532,
                "title": "lowest-common-ancestor-of-a-binary-search-tree-java-recursion-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null){\\n            return null;\\n        } else if (root.val > p.val && root.val > q.val){\\n            return lowestCommonAncestor(root.left, p, q);\\n        } else if (root.val < p.val && root.val < q.val){\\n\\t\\t\\treturn lowestCommonAncestor(root.right, p, q);\\n        } else {\\n            return root;\\n        }\\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE. Happy Coding and keep up the good work.\\nFeel free to give your suggestions or correct me in the comments.\\nThanks for reading.\\uD83D\\uDE43",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null){\\n            return null;\\n        } else if (root.val > p.val && root.val > q.val){\\n            return lowestCommonAncestor(root.left, p, q);\\n        } else if (root.val < p.val && root.val < q.val){\\n\\t\\t\\treturn lowestCommonAncestor(root.right, p, q);\\n        } else {\\n            return root;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433131,
                "title": "js-o-n-solution-with-explanation",
                "content": "```\\nvar lowestCommonAncestor = function(root, p, q) { \\n\\t// condition 1: if both p and q node value if less than the root node value,\\n\\t// that means that both nodes lie on its left side\\n    if(root.val > p.val && root.val > q.val) {\\n        return lowestCommonAncestor(root.left, p, q);\\n    } else if(root.val < p.val && root.val < q.val) {\\n\\t\\t// condition2: if both p and q node value is greater than the root node value, \\n\\t\\t// that means that both nodes lie on its right side\\n        return lowestCommonAncestor(root.right, p, q);\\n    }\\n\\t// condition 3: if p and q node lie on either side of the root node, that means\\n\\t// root node itself is the lowest common ancestor, so return root node\\n    return root;\\n};\\n```\\nTime Complexity = O(n)\\nSpace Complexity = O(n) [call stack]",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar lowestCommonAncestor = function(root, p, q) { \\n\\t// condition 1: if both p and q node value if less than the root node value,\\n\\t// that means that both nodes lie on its left side\\n    if(root.val > p.val && root.val > q.val) {\\n        return lowestCommonAncestor(root.left, p, q);\\n    } else if(root.val < p.val && root.val < q.val) {\\n\\t\\t// condition2: if both p and q node value is greater than the root node value, \\n\\t\\t// that means that both nodes lie on its right side\\n        return lowestCommonAncestor(root.right, p, q);\\n    }\\n\\t// condition 3: if p and q node lie on either side of the root node, that means\\n\\t// root node itself is the lowest common ancestor, so return root node\\n    return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1348583,
                "title": "lowest-common-ancestor-of-a-binary-search-tree-recursion-commented",
                "content": "```\\n//function to check element is present or not \\n bool isPresent(TreeNode* root, TreeNode* node){\\n        if(root == NULL) return false;\\n        if(root->val == node->val) return true;\\n        return isPresent(root->left,node) | isPresent(root->right,node);\\n    }\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t//either anyone is present as a root\\n\\t// or both are present in oppsite side\\n\\t//then root will be LCA\\n        if(    root->val == p->val || root->val == q->val \\n           || (isPresent(root->left,p) && isPresent(root->right,q))\\n           || (isPresent(root->left,q) && isPresent(root->right,p))\\n          ) \\n              return root;\\n     //otherwise if both are in left side recusively call for left subtree   \\n        if(isPresent(root->left,p) && isPresent(root->left,q)){\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n\\t\\t//o.w. right subtree\\n        else \\n            return lowestCommonAncestor(root->right, p, q);\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//function to check element is present or not \\n bool isPresent(TreeNode* root, TreeNode* node){\\n        if(root == NULL) return false;\\n        if(root->val == node->val) return true;\\n        return isPresent(root->left,node) | isPresent(root->right,node);\\n    }\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t//either anyone is present as a root\\n\\t// or both are present in oppsite side\\n\\t//then root will be LCA\\n        if(    root->val == p->val || root->val == q->val \\n           || (isPresent(root->left,p) && isPresent(root->right,q))\\n           || (isPresent(root->left,q) && isPresent(root->right,p))\\n          ) \\n              return root;\\n     //otherwise if both are in left side recusively call for left subtree   \\n        if(isPresent(root->left,p) && isPresent(root->left,q)){\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n\\t\\t//o.w. right subtree\\n        else \\n            return lowestCommonAncestor(root->right, p, q);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1295569,
                "title": "c-recursive-and-conversion-to-iteration",
                "content": "## Basic Idea of the Question\\nThis question is similar to [236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/) except that the fact that the tree given to us is actually a Binary Search Tree helps us to find the elements more quickly.\\n\\nThe basic idea is that the Lowest Common Ancestor is a place where the paths from the root to the nodes diverge, or where one of the paths ends and the other continues.\\nThere can be one of three cases:\\n\\n1. Either one of them is the current subtree\\'s root itself.\\n2. Or they are in different subtrees.\\n3. Or they are in the same subtree.\\n\\nCases 1 and 2 are our base cases, since here the root will the LCA. Let\\'s consider these one by one to think why that is true.\\n\\n### Case 1:\\nIf one of the nodes is the root and the other one is one of the children of the root (assuming that the given nodes are not equal), then the Lowest Common Ancestor of these nodes is the node which is equal to the root, since the last common node in the paths from the root to these nodes, is that node. So we return the current root here.\\n\\n### Case 2:\\nIf the nodes are in different subtrees, then the path from the root of the tree to these nodes, will always diverge at this subtree\\'s root, thus making the current root as the LCA. So we return the current root again.\\n\\nIf both of the nodes are in the same subtree, then that means that we have not found the diverging point yet, so we recurse on whichever subtree they are in.\\n<br/>\\n## Approach\\nNow this is the exact same approach I used in the general question with Binary Trees as well. But here this approach can be made faster, since we can find whether a node exists in a particular subtree in O(1) (which was O(n) in the Binary Trees). We can check this by just comparing the node\\'s value to the value of the root. If it is less than root\\'s value, then the node is in the left subtree, else it is in the right subtree.\\nWe don\\'t have to worry about the grandparent\\'s value, since that would have already been checked in the upper levels.\\n<br/>\\n## Code\\nThe code for the above approach can be written as follows:\\n```\\nTreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {\\n\\tif(p == root || q == root) return root;\\n\\telse if(p->val < root->val) {\\n\\t\\t//p is in the left subtree\\n\\t\\tif(q->val < root->val) {\\n\\t\\t\\t//q is also in the left subtree\\n\\t\\t\\t//go left\\n\\t\\t\\treturn lowestCommonAncestor(root->left, p, q);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t//q is in the right subtree\\n\\t\\t\\t//they are in different subtrees\\n\\t\\t\\t//thus root is the LCA\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}\\n\\telse {\\n\\t\\t//p is in the right subtree\\n\\t\\tif(q->val > root->val) {\\n\\t\\t\\t//q is also in the right subtree\\n\\t\\t\\t//go right\\n\\t\\t\\treturn lowestCommonAncestor(root->right, p, q);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t//q is in the left subtree\\n\\t\\t\\t//root is the LCA\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nAs you can see, this solution is recursive, but since the recursion is only tail recursion (i.e there is only one recursive call per function call), we can easily convert this into iterative solution.\\n\\nThe iterative solution can be written as follows:\\n```\\nTreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {\\n\\twhile(root != p && root!= q) {\\n\\t\\tif(p->val < root->val) {\\n\\t\\t\\tif(q->val < root->val) {\\n\\t\\t\\t\\t//go left\\n\\t\\t\\t\\troot = root->left;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t//root is the LCA\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif(q->val < root->val) {\\n\\t\\t\\t\\t//root is the LCA\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t//go right\\n\\t\\t\\t\\troot = root->right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn root;\\n}\\n```\\n\\n**Time: O(h)** where h is the height of the BST, since in the worst case we would find the LCA at the second last level (when p and q are leaves). In a balanced BST, this will be O(logn), since the height is maintained O(logn) in it.\\n\\n**Space: O(h)** in the case of the recursive solution (the call stack space), and **O(1)** in the case of the iterative solution.\\n\\nFeel free to ask any doubts or suggest any corrections/improvements in the comments.\\nUpvote the post if you liked it!\\n",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nTreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {\\n\\tif(p == root || q == root) return root;\\n\\telse if(p->val < root->val) {\\n\\t\\t//p is in the left subtree\\n\\t\\tif(q->val < root->val) {\\n\\t\\t\\t//q is also in the left subtree\\n\\t\\t\\t//go left\\n\\t\\t\\treturn lowestCommonAncestor(root->left, p, q);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t//q is in the right subtree\\n\\t\\t\\t//they are in different subtrees\\n\\t\\t\\t//thus root is the LCA\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}\\n\\telse {\\n\\t\\t//p is in the right subtree\\n\\t\\tif(q->val > root->val) {\\n\\t\\t\\t//q is also in the right subtree\\n\\t\\t\\t//go right\\n\\t\\t\\treturn lowestCommonAncestor(root->right, p, q);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t//q is in the left subtree\\n\\t\\t\\t//root is the LCA\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\nTreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {\\n\\twhile(root != p && root!= q) {\\n\\t\\tif(p->val < root->val) {\\n\\t\\t\\tif(q->val < root->val) {\\n\\t\\t\\t\\t//go left\\n\\t\\t\\t\\troot = root->left;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t//root is the LCA\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif(q->val < root->val) {\\n\\t\\t\\t\\t//root is the LCA\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t//go right\\n\\t\\t\\t\\troot = root->right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 741744,
                "title": "swift",
                "content": "```\\nclass Solution {\\n    func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\\n        guard let root = root, let p = p, let q = q else { return nil }\\n                \\n        if root.val < p.val && root.val < q.val {\\n            return lowestCommonAncestor(root.right, p, q)\\n        } else if root.val > p.val && root.val > q.val {\\n            return lowestCommonAncestor(root.left, p, q)\\n        } else {\\n            return root\\n        }\\n        return nil\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\\n        guard let root = root, let p = p, let q = q else { return nil }\\n                \\n        if root.val < p.val && root.val < q.val {\\n            return lowestCommonAncestor(root.right, p, q)\\n        } else if root.val > p.val && root.val > q.val {\\n            return lowestCommonAncestor(root.left, p, q)\\n        } else {\\n            return root\\n        }\\n        return nil\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649712,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null)\\n            return null;\\n        else if (root.val >= p.val && root.val <= q.val || root.val <= p.val && root.val >= q.val)\\n            return root;\\n        else if (root. val >= p.val)\\n            return LowestCommonAncestor(root.left, p, q);\\n        else\\n            return LowestCommonAncestor(root.right, p, q);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null)\\n            return null;\\n        else if (root.val >= p.val && root.val <= q.val || root.val <= p.val && root.val >= q.val)\\n            return root;\\n        else if (root. val >= p.val)\\n            return LowestCommonAncestor(root.left, p, q);\\n        else\\n            return LowestCommonAncestor(root.right, p, q);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 447701,
                "title": "golang-iterative-solution",
                "content": "```go\\n/**\\n * Definition for TreeNode.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *ListNode\\n *     Right *ListNode\\n * }\\n */\\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n\\tval1, val2 := p.Val, q.Val\\n\\tcur := root\\n\\tfor {\\n\\t\\tswitch {\\n\\t\\tcase val1 < cur.Val && val2 < cur.Val:\\n\\t\\t\\tcur = cur.Left\\n\\t\\tcase val1 > cur.Val && val2 > cur.Val:\\n\\t\\t\\tcur = cur.Right\\n\\t\\tdefault:\\n\\t\\t\\treturn cur\\n\\t\\t}\\n\\t}\\n\\treturn root\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n/**\\n * Definition for TreeNode.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *ListNode\\n *     Right *ListNode\\n * }\\n */\\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n\\tval1, val2 := p.Val, q.Val\\n\\tcur := root\\n\\tfor {\\n\\t\\tswitch {\\n\\t\\tcase val1 < cur.Val && val2 < cur.Val:\\n\\t\\t\\tcur = cur.Left\\n\\t\\tcase val1 > cur.Val && val2 > cur.Val:\\n\\t\\t\\tcur = cur.Right\\n\\t\\tdefault:\\n\\t\\t\\treturn cur\\n\\t\\t}\\n\\t}\\n\\treturn root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 198717,
                "title": "5-lines-simple-java-solution-faster-than-100-o-1-space-complexity",
                "content": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        while(root != null){\\n            if(p.val < root.val && q.val < root.val) root = root.left;\\n            else if(p.val > root.val && q.val > root.val) root = root.right;\\n            else return root;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        while(root != null){\\n            if(p.val < root.val && q.val < root.val) root = root.left;\\n            else if(p.val > root.val && q.val > root.val) root = root.right;\\n            else return root;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168777,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        pval, qval = min(p.val,q.val), max(p.val,q.val)\\n        res = root\\n        while not pval <= res.val <= qval:\\n            if res.val < pval:\\n                res = res.right\\n            else:\\n                res = res.left\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        pval, qval = min(p.val,q.val), max(p.val,q.val)\\n        res = root\\n        while not pval <= res.val <= qval:\\n            if res.val < pval:\\n                res = res.right\\n            else:\\n                res = res.left\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65078,
                "title": "javascript-solution",
                "content": "    var lowestCommonAncestor = function(root, p, q) {\\n        //If the value of p is less than the root and q is less than the root, go to the left\\n        if (p.val < root.val && q.val < root.val) {\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        //If the value of p is greater than the root and q is greater than the root, go to the right\\n        else if (p.val > root.val && q.val > root.val) {\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        //We found it!\\n        else {\\n            return root;\\n        }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var lowestCommonAncestor = function(root, p, q) {\\n        //If the value of p is less than the root and q is less than the root, go to the left\\n        if (p.val < root.val && q.val < root.val) {\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        //If the value of p is greater than the root and q is greater than the root, go to the right\\n        else if (p.val > root.val && q.val > root.val) {\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        //We found it!\\n        else {\\n            return root;\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 65085,
                "title": "share-some-extension-lca-of-k-nodes-in-a-bst-or-binary-tree",
                "content": "original question 1: LCA of 2 nodes in a BST.\\n\\nsolution 1:\\n\\n    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if (root == null || p == null || q == null)\\n                return null;\\n            \\n            TreeNode result = root; \\n            int l = min(p.val, q.val);\\n            int r = max(p.val, q.val);\\n            while (!(l <= result.val && result.val <= r))\\n                if (result.val < l)\\n                    result = result.right;\\n                else\\n                    result = result.left;\\n            return result;\\n        }\\n        int min(int a, int b){\\n            return a < b? a: b;\\n        }\\n        int max(int a, int b){\\n            return a > b? a: b;\\n        }\\n    }\\n\\nextension question 2: to find LCA of two node in binary tree, e.g., not binary search tree.\\n\\nsolution 2:\\n\\n    public class Solution {\\n        TreeNode result = null;\\n        boolean findp = false;\\n        boolean findq = false;\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            dfs(root, p, q);\\n            return result;\\n        }\\n        int dfs(TreeNode root, TreeNode p, TreeNode q){\\n            if (root == null || (findp && findq))\\n                return 0;\\n                \\n            int cur = 0;\\n            if (root == p){\\n                cur += 2;\\n                findp = true;\\n            }\\n            if (root == q){\\n                cur +=1;\\n                findq = true;\\n            }\\n               \\n            int left = dfs(root.left, p, q);\\n            int right = dfs(root.right, p, q);\\n    \\n            if (cur + left + right == 3 && result == null)\\n                result = root;\\n            return cur + left + right;\\n        }\\n    }\\n\\nextension question 3: LCA of k nodes in BST. \\n\\nsolution 3: only need to find max and min of k nodes and then to chang root into root.left or root.right according to the relationship of root.val and [min, max]. if root.val < min, let root = root.right; if root.val > max, let root = root.left; else this root is the answer. The complexity of time is O(k + logn) generally, and O(n) worst, and space is O(logn) generally, and O(n) worst.\\n\\nextension question 4: LCA of k nodes in binary tree(with the assumption of nodes are diffrent from each other).\\n\\nsolution 4.1: time O(n), space O(k + logn) to O(n);\\n\\n        class Solution{\\n            HashSet<TreeNode> hash = new HashSet<TreeNode>();\\n            TreeNode result = null;        \\n            TreeNode lowestCommonAncestor(TreeNode root, TreeNode[] nodes, int k)\\n            {\\n                for (node: nodes)\\n                    hash.put(node);\\n                dfs(root, nodes, k);\\n                return result;\\n            }\\n            int dfs(TreeNode root, int k){\\n                if (root == null || result != null)\\n                    return 0;\\n                \\n                int cur = hash.containsKey(root)? 1: 0;\\n                int l = dfs(root.left);\\n                int r = dfs(root.right);\\n                if (cur + l + r == k && result == null)\\n                    result = root;\\n                return l + r + cur;\\n            }\\n        }\\n\\nsolution 4.2: time O(n), space O(n), to convert the binary tree to BST, then to solve it. The conversion needs inorder traversal of the original binary tree and number assignment in new BST, thus it needs O(n) time and space.Because the solution of LCA of k nodes in BST need no more time and space than this transformation, the totle time and space is as above.\\n\\nsolution 4.3: time O(n + klogk), space O(k + logn + klogn), getting huffman codings of the k nodes and then obtaining the longest common preffix of these huffman codings and then finding the TreeNode corresponding to the preffix in the binary tree.",
                "solutionTags": [
                    "Binary Search",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if (root == null || p == null || q == null)\\n                return null;\\n            \\n            TreeNode result = root; \\n            int l = min(p.val, q.val);\\n            int r = max(p.val, q.val);\\n            while (!(l <= result.val && result.val <= r))\\n                if (result.val < l)\\n                    result = result.right;\\n                else\\n                    result = result.left;\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 65107,
                "title": "3-lines-concise-python-resolution",
                "content": "    class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        if (p.val <= root.val <= q.val or q.val <= root.val <= p.val): return root.val\\n        if (p.val < root.val and q.val < root.val): return self.lowestCommonAncestor(root.left, p, q)\\n        if (p.val > root.val and q.val > root.val): return self.lowestCommonAncestor(root.right, p, q)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        if (p.val <= root.val <= q.val or q.val <= root.val <= p.val): return root.val\\n        if (p.val < root.val and q.val < root.val): return self.lowestCommonAncestor(root.left, p, q)\\n        if (p.val > root.val and q.val > root.val): return self.lowestCommonAncestor(root.right, p, q)",
                "codeTag": "Java"
            },
            {
                "id": 65121,
                "title": "python-iterative-at-116-ms",
                "content": "    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if p == q:\\n            return p\\n        if not root or not p or not q:\\n            return None\\n        min_val = min(p.val, q.val)\\n        max_val = max(p.val, q.val)\\n        \\n        curr = root\\n        while curr:\\n            if curr.val>=min_val and curr.val<=max_val:\\n                return curr\\n            elif curr.val<min_val and curr.val<max_val:\\n                curr = curr.right\\n            elif curr.val>min_val and curr.val>max_val:\\n                curr = curr.left\\n                \\n        return None",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if p == q:\\n            return p\\n        if not root or not p or not q:\\n            return None\\n        min_val = min(p.val, q.val)\\n        max_val = max(p.val, q.val)\\n        \\n        curr = root\\n        while curr:\\n            if curr.val>=min_val and curr.val<=max_val:\\n                return curr\\n            elif curr.val<min_val and curr.val<max_val:\\n                curr = curr.right\\n            elif curr.val>min_val and curr.val>max_val:\\n                curr = curr.left\\n                \\n        return None",
                "codeTag": "Python3"
            },
            {
                "id": 65130,
                "title": "9ms-java-solution",
                "content": "    public class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        \\n\\t\\tif ((p.val <= root.val && q.val >= root.val)\\n\\t\\t\\t\\t|| (p.val >= root.val && q.val <= root.val)) {\\n\\t\\t\\treturn root;\\n\\t\\t} else if (p.val < root.val && q.val < root.val) {\\n\\t\\t\\treturn lowestCommonAncestor(root.left, p, q);\\n\\t\\t}else{\\n\\t\\t\\treturn lowestCommonAncestor(root.right, p, q);\\n\\t\\t}\\n\\t\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        \\n\\t\\tif ((p.val <= root.val && q.val >= root.val)\\n\\t\\t\\t\\t|| (p.val >= root.val && q.val <= root.val)) {\\n\\t\\t\\treturn root;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 65198,
                "title": "share-my-simple-c-code",
                "content": "     struct TreeNode {\\n          int val;\\n          TreeNode *left;\\n          TreeNode *right;\\n          TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n      };\\n     \\n    class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(p->val == root->val || q->val == root->val || (p->val < root->val && q->val > root->val) || (q->val < root->val && p->val > root->val))\\n            {\\n            \\treturn root;\\n            }\\n            else if(p->val < root->val && q->val < root->val)\\n            {\\n            \\treturn lowestCommonAncestor(root->left,p,q);\\n            }\\n            else\\n            \\treturn lowestCommonAncestor(root->right,p,q);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(p->val == root->val || q->val == root->val || (p->val < root->val && q->val > root->val) || (q->val < root->val && p->val > root->val))\\n            {\\n            \\treturn root;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3930446,
                "title": "easy-iterative-solution-using-traversal-in-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        pv=p.val\\n        qv=q.val\\n        while(root!=None):\\n            if pv <root.val and qv<root.val:\\n                root=root.left\\n            elif pv>root.val and qv>root.val:\\n                root=root.right\\n            else:\\n                return root\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        pv=p.val\\n        qv=q.val\\n        while(root!=None):\\n            if pv <root.val and qv<root.val:\\n                root=root.left\\n            elif pv>root.val and qv>root.val:\\n                root=root.right\\n            else:\\n                return root\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724176,
                "title": "easy-to-understand-c-solution-recursive-o-logn",
                "content": "# Intuition & Approach\\n\\n-If root value is strictly greater then both the given value p and q then the possible common ancestor will always be in the left side of the tree.And root value is strictly lesser then p and q then the common ancestor will always be in right side of the tree.\\n-If previous two conditions is not satisfied then current root is the answer.\\n\\n\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(logn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root->val>p->val && root->val>q->val)\\n        {\\n           return lowestCommonAncestor(root->left,p,q);\\n        }\\n        else if(root->val<p->val && root->val<q->val)\\n        {\\n           return lowestCommonAncestor(root->right,p,q);\\n        }\\n        else \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root->val>p->val && root->val>q->val)\\n        {\\n           return lowestCommonAncestor(root->left,p,q);\\n        }\\n        else if(root->val<p->val && root->val<q->val)\\n        {\\n           return lowestCommonAncestor(root->right,p,q);\\n        }\\n        else \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699700,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code finds the lowest common ancestor (LCA) of two nodes p and q in a binary search tree (BST). The LCA is the deepest node in the BST that has both p and q as descendants (where we allow a node to be a descendant of itself).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code defines a recursive function lowestCommonAncestor() that takes three TreeNode pointers root, p, and q as arguments. Within this function, it performs the following steps:\\n\\nIf p->val and q->val are both less than the value of root->val, it means that both p and q are in the left subtree of root. Therefore, the function recursively calls itself with root->left, p, and q as arguments and returns the result.\\nIf p->val and q->val are both greater than the value of root->val, it means that both p and q are in the right subtree of root. Therefore, the function recursively calls itself with root->right, p, and q as arguments and returns the result.\\nIf neither of the above conditions is true, it means that p and q are on different sides of root, or one of them is equal to root. In this case, root is the lowest common ancestor, so it is returned.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code traverses the BST by recursively going left or right based on the values of p and q. In the worst case, the code visits every node in the BST, resulting in a time complexity of O(n), where n is the number of nodes in the BST.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) since the code uses only a constant amount of additional space, regardless of the input size.\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (p->val < root->val && q->val < root->val) {\\n            return lowestCommonAncestor(root->left, p, q);\\n        } else if (p->val > root->val && q->val > root->val) {\\n            return lowestCommonAncestor(root->right, p, q);\\n        } else {\\n            return root;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (p->val < root->val && q->val < root->val) {\\n            return lowestCommonAncestor(root->left, p, q);\\n        } else if (p->val > root->val && q->val > root->val) {\\n            return lowestCommonAncestor(root->right, p, q);\\n        } else {\\n            return root;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655741,
                "title": "c-simplest-and-crisp-solution-ever",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return NULL;\\n        if(root->val>p->val && root->val>q->val) return lowestCommonAncestor(root->left,p,q);\\n        else if(root->val<p->val && root->val<q->val) return lowestCommonAncestor(root->right,p,q);\\n        else return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return NULL;\\n        if(root->val>p->val && root->val>q->val) return lowestCommonAncestor(root->left,p,q);\\n        else if(root->val<p->val && root->val<q->val) return lowestCommonAncestor(root->right,p,q);\\n        else return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637628,
                "title": "simple-python-5-liner-recursive-approach-w-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thing to look out for is with most tree problems we know that there is most likely a recursive approch to solving the problem, which is generally easier to implement. Another thing is understanding why they chose to give a Binary Search Tree (BST) vs just a regular binary tree. When finding the lowest common ancestor (LCA) we can see that the LCA will always be bounded by the min and max of the two nodes. With just a normal tree this would not be the case making the solution more difficult.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor this approach we can see a lot of the normal base cases you would have to handle are not needed here. For example making sure that you have a valid root is not needed because we know there will always be a solution, so our base case just ends up being the answer. `if min(p.val,q.val) <= root.val <= max(q.val,p.val) ` This will check if the root is bounded between the min and max, and if it is we know we have founded the LCA. If this is not the case we continue, if the root is greater than the max, since this is a BST, we know the solution must be on the left side of the tree. Same logic for if the root is less than the min.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(h) - where h is the height of the tree, since we are cutting off half the tree each time we search farther\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) - No additional space is needed\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if min(p.val,q.val) <= root.val <= max(q.val,p.val): \\n            return root\\n        if root.val > max(q.val,p.val): \\n            return self.lowestCommonAncestor(root.left,p,q)\\n        return self.lowestCommonAncestor(root.right, p, q)\\n             \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if min(p.val,q.val) <= root.val <= max(q.val,p.val): \\n            return root\\n        if root.val > max(q.val,p.val): \\n            return self.lowestCommonAncestor(root.left,p,q)\\n        return self.lowestCommonAncestor(root.right, p, q)\\n             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510148,
                "title": "java-really-easy-to-understand-solution",
                "content": "# Intuition\\nFind path from foot to p and path from root to q and find last equal path segment.\\n\\n\\n# Complexity\\n- Time complexity:\\nI think, $$O(n)$$, please correct me if i\\'m wrong\\n\\n- Space complexity:\\nI think, $$O(n)$$, please correct me if i\\'m wrong\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        TreeNode[] pPath = path(root, p);\\n        TreeNode[] qPath = path(root, q);\\n\\n        TreeNode last = null;\\n\\n        for (int i = 0; i < pPath.length; i++) {\\n            if (pPath[i] != qPath[i]) {\\n                return last;\\n            } else {\\n                last = pPath[i];\\n            }\\n        }\\n\\n        return null;\\n    }\\n\\n    public TreeNode[] path(TreeNode root, TreeNode end) {\\n        TreeNode[] result = new TreeNode[100000];\\n        int counter = 0;\\n        TreeNode current = root;\\n        boolean found = false;\\n\\n        while (current.val != end.val) {\\n            if (current.val < end.val) {\\n                result[counter] = current;\\n                current = current.right;\\n                counter++;\\n            } else {\\n                result[counter] = current;\\n                current = current.left;\\n                counter++;\\n            }\\n        }\\n\\n        result[counter] = current;\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        TreeNode[] pPath = path(root, p);\\n        TreeNode[] qPath = path(root, q);\\n\\n        TreeNode last = null;\\n\\n        for (int i = 0; i < pPath.length; i++) {\\n            if (pPath[i] != qPath[i]) {\\n                return last;\\n            } else {\\n                last = pPath[i];\\n            }\\n        }\\n\\n        return null;\\n    }\\n\\n    public TreeNode[] path(TreeNode root, TreeNode end) {\\n        TreeNode[] result = new TreeNode[100000];\\n        int counter = 0;\\n        TreeNode current = root;\\n        boolean found = false;\\n\\n        while (current.val != end.val) {\\n            if (current.val < end.val) {\\n                result[counter] = current;\\n                current = current.right;\\n                counter++;\\n            } else {\\n                result[counter] = current;\\n                current = current.left;\\n                counter++;\\n            }\\n        }\\n\\n        result[counter] = current;\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449104,
                "title": "python3-easy-with-explanation",
                "content": "# Code\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        curr = root\\n        while curr:\\n            #if both values are greater than root then search in right part\\n            if p.val > curr.val and q.val > curr.val: curr = curr.right\\n\\n            #if both values are less than root then search in left part\\n            elif p.val < curr.val and q.val < curr.val: curr = curr.left\\n\\n            # else means one of them is in left subtree and \\n            # one of them is in right subtree\\n            # in this case lowest common ancestor is root or curr\\n            # so just return that\\n            else: return curr\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        curr = root\\n        while curr:\\n            #if both values are greater than root then search in right part\\n            if p.val > curr.val and q.val > curr.val: curr = curr.right\\n\\n            #if both values are less than root then search in left part\\n            elif p.val < curr.val and q.val < curr.val: curr = curr.left\\n\\n            # else means one of them is in left subtree and \\n            # one of them is in right subtree\\n            # in this case lowest common ancestor is root or curr\\n            # so just return that\\n            else: return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448238,
                "title": "simple-solution-in-two-way-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven a binary search tree (BST) and two nodes, we need to find the lowest common ancestor (LCA) node of both nodes in the BST. A LCA is the lowest node in the tree that has both nodes as its descendants.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can solve this problem using a recursive approach. We start at the root node and check if the values of both nodes lie on either side of the root. If they are, we continue our search in the respective left or right subtree of the root. If the values of the nodes are equal or one of them is the root itself, we return the root. This is because the root is an ancestor of both nodes and it is the lowest such ancestor as we are searching from top to bottom.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this approach is O(h), where h is the height of the BST. In the worst case, the height of the tree can be equal to the number of nodes in the tree, which makes the time complexity O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this approach is O(h) due to the recursion stack. In the worst case, the height of the tree can be equal to the number of nodes in the tree, which makes the space complexity O(n).\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\n        # Using recursion\\n        if p.val < root.val and q.val < root.val:\\n            return self.lowestCommonAncestor(root.left,p,q)\\n        elif p.val > root.val and q.val > root.val:\\n            return self.lowestCommonAncestor(root.right,p,q)\\n        else:\\n            return root\\n\\n        # while root:\\n        #     if p.val < root.val and q.val < root.val:\\n        #         root = root.left\\n        #     elif p.val > root.val and q.val > root.val:\\n        #         root = root.right\\n        #     else:\\n        #         return root\\n\\n\\n         \\n                \\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\n        # Using recursion\\n        if p.val < root.val and q.val < root.val:\\n            return self.lowestCommonAncestor(root.left,p,q)\\n        elif p.val > root.val and q.val > root.val:\\n            return self.lowestCommonAncestor(root.right,p,q)\\n        else:\\n            return root\\n\\n        # while root:\\n        #     if p.val < root.val and q.val < root.val:\\n        #         root = root.left\\n        #     elif p.val > root.val and q.val > root.val:\\n        #         root = root.right\\n        #     else:\\n        #         return root\\n\\n\\n         \\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431458,
                "title": "i-bet-1000-you-can-understand",
                "content": "# Intuition\\nTo solve this task you should only remember BST invariant: left child value < root value and root value > right child value. It means that if root value is between children values then it is LCA. Else you should continue your search in right or left subtree of current root\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLet $k$ = depth of tree, then time complexity will be $O(k)$ because level decreases each step\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nFunction stack will hold $O(k)$ memory\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == p || root == q){\\n            return root;\\n        }\\n        if (p->val < root->val && root->val < q->val || q->val < root->val && root->val < p->val){\\n            return root;\\n        } else if (p->val < root->val && q->val < root->val){\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n        return lowestCommonAncestor(root->right, p, q);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == p || root == q){\\n            return root;\\n        }\\n        if (p->val < root->val && root->val < q->val || q->val < root->val && root->val < p->val){\\n            return root;\\n        } else if (p->val < root->val && q->val < root->val){\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n        return lowestCommonAncestor(root->right, p, q);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384014,
                "title": "javascript-php-recursive-iterative-approaches",
                "content": "\\nThe Lowest Common Ancestor (LCA) of a Binary Search Tree (BST) is the deepest node in the tree which has both the given nodes as its descendants. Finding the LCA of a BST is a challenging task as the tree needs to be traversed in order to identify the LCA.\\n\\nThere are two approaches that can be used to solve the problem: the Recursive Approach and the Iterative Approach. \\n**The Recursive Approach** involves breaking down the problem into subproblems and solving them one by one until the LCA is found. \\n**The Iterative Approach** utilizes a loop structure to traverse the tree and identify the LCA. \\n\\nBoth approaches have their own pros and cons and are usually used depending on the requirement and the user\\'s preference.\\n\\n\\n\\n### Recursive Approach\\n\\nThis approach uses recursion to traverse the binary tree. The logic is that if the root node is greater than both the p and q nodes, then both p and q are in the left subtree and the function recursively calls itself on the left subtree. If the root node is less than both the p and q nodes, then both p and q are in the right subtree and the function recursively calls itself on the right subtree. If neither of these conditions is true, then the root node is the Lowest Common Ancestor.\\n\\n*Time Complexity:* $$O(log N)$$, where n is the total number of nodes in the tree.\\n*Space Complexity:* $$O(log N)$$ This approach has a space complexity of O(log N) as it requires the recursive stack to store the nodes of the binary tree when the function is called.\\n\\n```javascript []\\nvar lowestCommonAncestor = function (root, p, q) {\\n    // both p and q are in the left subtree\\n    if (root.val > p.val && root.val > q.val) {\\n        return lowestCommonAncestor(root.left, p, q);\\n    }\\n    // both p and q are in the right subtree\\n    if (root.val < p.val && root.val < q.val) {\\n        return lowestCommonAncestor(root.right, p, q);\\n    }\\n\\n    return root;\\n};\\n```\\n```php []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @param TreeNode $p\\n     * @param TreeNode $q\\n     * @return TreeNode\\n     */\\n    function lowestCommonAncestor($root, $p, $q) {\\n        if ($root->val > $p->val && $root->val > $q->val) return $this->lowestCommonAncestor($root->left, $p, $q);\\n        if ($root->val < $p->val && $root->val < $q->val) return $this->lowestCommonAncestor($root->right, $p, $q);\\n        return $root;\\n    }\\n}\\n```\\n\\n\\n### Iterative Approach\\nThis approach uses an iterative method to find the Lowest Common Ancestor (LCA) of two nodes in a Binary Tree. We start by initializing a variable (root) to the root of the Binary Tree and comparing its value to the values of the two nodes. If the root\\'s value is greater than the values of both nodes, we move the root to the left child of the root. If the root\\'s value is less than the values of both nodes, we move the root to the right child of the root. If neither condition is satisfied, the root is the LCA and is returned. If none of the nodes are found, null is returned. \\n\\n*Time complexity*: $$O(log N)$$ The time complexity of this algorithm is O(log n) because it is using a Binary Search Tree (BST). BSTs have a time complexity of log(n) for searching, so this algorithm has a time complexity of O(logn).\\n*Space complexity*: $$O(1)$$ The space complexity is constant since no additional space is required to solve the problem.\\n\\n```javascript []\\nvar lowestCommonAncestor = function (root, p, q) {\\n    while (root !== null) {\\n        if (root.val > p.val && root.val > q.val) {\\n            root = root.left\\n        } else if (root.val < p.val && root.val < q.val) {\\n            root = root.right\\n        } else {\\n            return root;\\n        }\\n    }\\n    return null\\n};\\n```\\n```php []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @param TreeNode $p\\n     * @param TreeNode $q\\n     * @return TreeNode\\n     */\\n    function lowestCommonAncestor(TreeNode $root, TreeNode $p, TreeNode $q): ?TreeNode {\\n        while ($root) {\\n            if ($root->val > $p->val && $root->val > $q->val) {\\n                $root = $root->left;\\n            } elseif ($root->val < $p->val && $root->val < $q->val) {\\n                $root = $root->right;\\n            } else {\\n                return $root;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\\n##### Thanks for reading! If you have any questions or suggestions, please leave a comment below. I would love to hear your thoughts! \\uD83D\\uDE0A\\n### **Please upvote if you found this post helpful! \\uD83D\\uDC4D**",
                "solutionTags": [
                    "JavaScript",
                    "PHP",
                    "Binary Tree"
                ],
                "code": "```javascript []\\nvar lowestCommonAncestor = function (root, p, q) {\\n    // both p and q are in the left subtree\\n    if (root.val > p.val && root.val > q.val) {\\n        return lowestCommonAncestor(root.left, p, q);\\n    }\\n    // both p and q are in the right subtree\\n    if (root.val < p.val && root.val < q.val) {\\n        return lowestCommonAncestor(root.right, p, q);\\n    }\\n\\n    return root;\\n};\\n```\n```php []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @param TreeNode $p\\n     * @param TreeNode $q\\n     * @return TreeNode\\n     */\\n    function lowestCommonAncestor($root, $p, $q) {\\n        if ($root->val > $p->val && $root->val > $q->val) return $this->lowestCommonAncestor($root->left, $p, $q);\\n        if ($root->val < $p->val && $root->val < $q->val) return $this->lowestCommonAncestor($root->right, $p, $q);\\n        return $root;\\n    }\\n}\\n```\n```javascript []\\nvar lowestCommonAncestor = function (root, p, q) {\\n    while (root !== null) {\\n        if (root.val > p.val && root.val > q.val) {\\n            root = root.left\\n        } else if (root.val < p.val && root.val < q.val) {\\n            root = root.right\\n        } else {\\n            return root;\\n        }\\n    }\\n    return null\\n};\\n```\n```php []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @param TreeNode $p\\n     * @param TreeNode $q\\n     * @return TreeNode\\n     */\\n    function lowestCommonAncestor(TreeNode $root, TreeNode $p, TreeNode $q): ?TreeNode {\\n        while ($root) {\\n            if ($root->val > $p->val && $root->val > $q->val) {\\n                $root = $root->left;\\n            } elseif ($root->val < $p->val && $root->val < $q->val) {\\n                $root = $root->right;\\n            } else {\\n                return $root;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204214,
                "title": "c-3line-code-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,TreeNode* p,TreeNode* q,TreeNode* &ans){\\n        if(root == NULL)return;\\n        if(root->val<p->val&&root->val<q->val){\\n            solve(root->right,p,q,ans);\\n        }else if(root->val>p->val&&root->val>q->val){\\n            solve(root->left,p,q,ans);\\n        }else{\\n            ans = root;\\n            return;\\n        }\\n    }\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* ans;\\n        solve(root,p,q,ans);\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,TreeNode* p,TreeNode* q,TreeNode* &ans){\\n        if(root == NULL)return;\\n        if(root->val<p->val&&root->val<q->val){\\n            solve(root->right,p,q,ans);\\n        }else if(root->val>p->val&&root->val>q->val){\\n            solve(root->left,p,q,ans);\\n        }else{\\n            ans = root;\\n            return;\\n        }\\n    }\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* ans;\\n        solve(root,p,q,ans);\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3142025,
                "title": "c-simple-iterative-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this problem, a BST is given. Every descendant on the right of the node is guaranteed to be greater than the node, and every descendant to the left of the node is lesser than it.\\n\\nTherefore, to find the lowest common ancestor, we only have to find the one, the value of which is in between the values of the given nodes.\\n\\nIf the node is not the lowest ancestor -> both of the descendants are located either to the left or to the right of it, therefore both of their values are strictly larger or smaller than its own\\n# Complexity\\n- Time complexity: $$O(h)$$ h - heigth of the tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while(root->val > max(p->val, q->val) or root->val < min(p->val, q->val)) {\\n            if (root->val < min (p->val, q->val)) root = root->right;\\n            else root = root->left;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while(root->val > max(p->val, q->val) or root->val < min(p->val, q->val)) {\\n            if (root->val < min (p->val, q->val)) root = root->right;\\n            else root = root->left;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919375,
                "title": "javascript-solution-beated-98-easy-solution",
                "content": "# Code\\n```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if(!root)\\n    return \\n    if((p.val<root.val && q.val<root.val)){\\n       return lowestCommonAncestor(root.left, p, q)\\n    }\\n    else if(p.val>root.val && q.val>root.val){\\n      return  lowestCommonAncestor(root.right, p, q)\\n    }\\nreturn root\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if(!root)\\n    return \\n    if((p.val<root.val && q.val<root.val)){\\n       return lowestCommonAncestor(root.left, p, q)\\n    }\\n    else if(p.val>root.val && q.val>root.val){\\n      return  lowestCommonAncestor(root.right, p, q)\\n    }\\nreturn root\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2725324,
                "title": "java-dfs-and-bfs-clean-and-simple",
                "content": "### **Please Upvote** :D\\n##### 1. DFS approach:\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null) return null;\\n        int curr = root.val;\\n        \\n        if (p.val > curr && q.val > curr) {\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        \\n        if (p.val < curr && q.val < curr) {\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        \\n        return root;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\\n##### 2. BFS approach:\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        Queue<TreeNode> queue  = new LinkedList<>();\\n        queue.offer(root);\\n        TreeNode result = null;\\n\\n        while (!queue.isEmpty()) {\\n            TreeNode curr = queue.poll();\\n\\n            if (p.val <= curr.val && q.val >= curr.val ||\\n                p.val >= curr.val && q.val <= curr.val) {\\n                return curr;\\n            }\\n\\n            if (p.val > curr.val && q.val > curr.val) {\\n                if (curr.left != null) queue.offer(curr.right);\\n            }\\n\\n            if (p.val < curr.val && q.val < curr.val) {\\n                if (curr.right != null) queue.offer(curr.left);\\n            }\\n        }\\n\\n        return null;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null) return null;\\n        int curr = root.val;\\n        \\n        if (p.val > curr && q.val > curr) {\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        \\n        if (p.val < curr && q.val < curr) {\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        \\n        return root;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        Queue<TreeNode> queue  = new LinkedList<>();\\n        queue.offer(root);\\n        TreeNode result = null;\\n\\n        while (!queue.isEmpty()) {\\n            TreeNode curr = queue.poll();\\n\\n            if (p.val <= curr.val && q.val >= curr.val ||\\n                p.val >= curr.val && q.val <= curr.val) {\\n                return curr;\\n            }\\n\\n            if (p.val > curr.val && q.val > curr.val) {\\n                if (curr.left != null) queue.offer(curr.right);\\n            }\\n\\n            if (p.val < curr.val && q.val < curr.val) {\\n                if (curr.right != null) queue.offer(curr.left);\\n            }\\n        }\\n\\n        return null;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670498,
                "title": "java-iterative-solution",
                "content": "```\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        \\n        while( root != null){\\n            if(root.val > p.val && root.val > q.val){\\n                root = root.left;\\n            }\\n            else if(root.val < p.val && root.val < q.val){\\n                root = root.right;\\n            }else{\\n                return root;\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        \\n        while( root != null){\\n            if(root.val > p.val && root.val > q.val){\\n                root = root.left;\\n            }\\n            else if(root.val < p.val && root.val < q.val){\\n                root = root.right;\\n            }else{\\n                return root;\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569055,
                "title": "java-100-fastest-easiest-o-height-of-tree",
                "content": "![image](https://assets.leetcode.com/users/images/48de1b6f-fa84-445b-a539-28cc2b0ce473_1663040098.4296865.png)\\n* T.C : O(logN)\\n* S.C : O(1)\\n```\\nWe will travel until we find a divergent point(use the fact that we\\'ve been given a BST). \\nJust draw a BST and simulate...everything will be clear!!\\n```\\n![image](https://assets.leetcode.com/users/images/21dee653-1cd5-49c4-b31e-71c143c79796_1663040329.2819753.png)\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==null)return root;\\n        if(root.val>p.val&&root.val>q.val)return lowestCommonAncestor(root.left,p,q);\\n        else if(root.val<p.val&&root.val<q.val)return lowestCommonAncestor(root.right,p,q);\\n        return root;\\n    }\\n}\\n```\\n```\\n---------------------------------------------------------PLEASE UPVOTE IF YOU LIKE!!----------------------------------------------------------\\u2014\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "```\\nWe will travel until we find a divergent point(use the fact that we\\'ve been given a BST). \\nJust draw a BST and simulate...everything will be clear!!\\n```\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==null)return root;\\n        if(root.val>p.val&&root.val>q.val)return lowestCommonAncestor(root.left,p,q);\\n        else if(root.val<p.val&&root.val<q.val)return lowestCommonAncestor(root.right,p,q);\\n        return root;\\n    }\\n}\\n```\n```\\n---------------------------------------------------------PLEASE UPVOTE IF YOU LIKE!!----------------------------------------------------------\\u2014\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508999,
                "title": "typescript-javascript-dfs-with-comments",
                "content": "```\\nfunction lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {\\n  return dfs(root, p, q);\\n};\\n\\nfunction dfs(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null) {\\n  // if any of the values are null, just return the value of root\\n  if([root, p, q].includes(null)) return root;\\n  \\n  // if both values are greater than root\\n  // the LCS is in right subtree\\n  if(p.val > root.val && q.val > root.val)\\n    return dfs(root.right, p, q)\\n  \\n  // if both values are less than root\\n  // then LCS is in left subtree\\n  if(p.val < root.val && q.val < root.val)\\n    return dfs(root.left, p, q);\\n  \\n  // if there\\'s a split\\n  // then we found our LCS\\n  return root;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Depth-First Search"
                ],
                "code": "```\\nfunction lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {\\n  return dfs(root, p, q);\\n};\\n\\nfunction dfs(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null) {\\n  // if any of the values are null, just return the value of root\\n  if([root, p, q].includes(null)) return root;\\n  \\n  // if both values are greater than root\\n  // the LCS is in right subtree\\n  if(p.val > root.val && q.val > root.val)\\n    return dfs(root.right, p, q)\\n  \\n  // if both values are less than root\\n  // then LCS is in left subtree\\n  if(p.val < root.val && q.val < root.val)\\n    return dfs(root.left, p, q);\\n  \\n  // if there\\'s a split\\n  // then we found our LCS\\n  return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2472344,
                "title": "c-3-line-soln-o-logn",
                "content": "```\\nif (root->val < min(p->val, q->val)) return lowestCommonAncestor(root->right, p, q);\\nelse if (root->val > max(p->val, q->val)) return lowestCommonAncestor(root->left, p, q);\\nreturn root;",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nif (root->val < min(p->val, q->val)) return lowestCommonAncestor(root->right, p, q);\\nelse if (root->val > max(p->val, q->val)) return lowestCommonAncestor(root->left, p, q);\\nreturn root;",
                "codeTag": "Unknown"
            },
            {
                "id": 2463135,
                "title": "c-iterative-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while(root){\\n            if(root->val < p->val && root->val < q->val) root = root->right;\\n            else if(root->val > p->val && root->val > q->val) root = root->left;\\n            else break;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while(root){\\n            if(root->val < p->val && root->val < q->val) root = root->right;\\n            else if(root->val > p->val && root->val > q->val) root = root->left;\\n            else break;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441026,
                "title": "python-easy-solution-faster-than-90",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        min_val, max_val = min(p.val,q.val), max(p.val,q.val)\\n        \\n        while True:\\n            if min_val<= root.val <= max_val:\\n                return root\\n            elif max_val<root.val:\\n                root = root.left\\n            else:\\n                root = root.right\\n                \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        min_val, max_val = min(p.val,q.val), max(p.val,q.val)\\n        \\n        while True:\\n            if min_val<= root.val <= max_val:\\n                return root\\n            elif max_val<root.val:\\n                root = root.left\\n            else:\\n                root = root.right\\n                \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425886,
                "title": "java-solution-easy-approach",
                "content": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(p.val<root.val && q.val<root.val)\\n        return lowestCommonAncestor(root.left,p,q);\\n        else if(p.val>root.val && q.val>root.val)\\n        return lowestCommonAncestor(root.right,p,q);\\n        else\\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(p.val<root.val && q.val<root.val)\\n        return lowestCommonAncestor(root.left,p,q);\\n        else if(p.val>root.val && q.val>root.val)\\n        return lowestCommonAncestor(root.right,p,q);\\n        else\\n        return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2415394,
                "title": "python-log-n-solution-explained",
                "content": "\\n# Time complexity correction:\\n`Log(n)` - for a balanced tree\\n`O(n)` - For imbalanced tree\\n\\n# Intuition\\n\\nThe LCA of a binary tree is the first node where the values of q and p branch in opposite directions, left and right.\\n\\nLet\\'s say given the following tree\\n\\n![image](https://assets.leetcode.com/users/images/1a7dc4e3-21bf-484c-9318-787184996ce6_1660305410.086411.png)\\n\\nIf we start at 6, to get to `0` and `4` we branch left for both.\\n\\nThen from 2 we must go opposite directions, this is the LCA node.\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        while True:\\n            if root.val > p.val and root.val > q.val: root = root.left\\n            elif root.val < p.val and root.val < q.val: root = root.right\\n\\t\\t\\t# Found LCA\\n            else: return root\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        while True:\\n            if root.val > p.val and root.val > q.val: root = root.left\\n            elif root.val < p.val and root.val < q.val: root = root.right\\n\\t\\t\\t# Found LCA\\n            else: return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414137,
                "title": "13-ms-runtime-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        if(root == NULL || root == p || root == q)\\n        {\\n            return root;\\n        }\\n        int less = min(p->val,q->val);\\n        int more = max(p->val,q->val);\\n        \\n        while(1)\\n        {\\n            if(root == p || root == q)\\n            {\\n                return root;\\n            }\\n            if(root->val > less && root-> val < more)\\n            {\\n                return root;\\n            }\\n            if(less > root->val)\\n            {\\n                root = root->right;\\n            }\\n            else\\n            {\\n                root = root->left;\\n            }\\n        }\\n        \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        if(root == NULL || root == p || root == q)\\n        {\\n            return root;\\n        }\\n        int less = min(p->val,q->val);\\n        int more = max(p->val,q->val);\\n        \\n        while(1)\\n        {\\n            if(root == p || root == q)\\n            {\\n                return root;\\n            }\\n            if(root->val > less && root-> val < more)\\n            {\\n                return root;\\n            }\\n            if(less > root->val)\\n            {\\n                root = root->right;\\n            }\\n            else\\n            {\\n                root = root->left;\\n            }\\n        }\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413997,
                "title": "recursion-simple",
                "content": "```\\n\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL || root == p || root == q) return root;\\n        \\n        TreeNode* l = lowestCommonAncestor(root->left ,p,q);\\n        TreeNode* r = lowestCommonAncestor(root->right,p,q);\\n        \\n        if(!l) return r;\\n        if(!r) return l;\\n        \\n        return root;\\n    }",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL || root == p || root == q) return root;\\n        \\n        TreeNode* l = lowestCommonAncestor(root->left ,p,q);\\n        TreeNode* r = lowestCommonAncestor(root->right,p,q);\\n        \\n        if(!l) return r;\\n        if(!r) return l;\\n        \\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2413252,
                "title": "python-binary-search-tree-technique-iterative",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        small, large = min(p.val, q.val), max(p.val, q.val)\\n        while root:\\n            if root.val < small:\\n                root = root.right\\n            elif root.val > large:\\n                root = root.left\\n            else:\\n                return root\\n        return None\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        small, large = min(p.val, q.val), max(p.val, q.val)\\n        while root:\\n            if root.val < small:\\n                root = root.right\\n            elif root.val > large:\\n                root = root.left\\n            else:\\n                return root\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413209,
                "title": "c-recursion-solution",
                "content": "\\'\\'\\'\\n# class Solution {\\n# public:\\n#     TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n#           if(root==NULL || root==p || root==q)\\n#             return root;\\n#         root->left=lowestCommonAncestor(root->left,p,q);\\n#         root->right=lowestCommonAncestor(root->right,p,q);\\n#         if(root->left==NULL)\\n#             return root->right;\\n#         else if(root->right==NULL)\\n#             return root->left;\\n#         else\\n#             return root;\\n#     }\\n# };\\n# \\'\\'\\'",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\n# public:\\n#     TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n#           if(root==NULL || root==p || root==q)\\n#             return root;\\n#         root->left=lowestCommonAncestor(root->left,p,q);\\n#         root->right=lowestCommonAncestor(root->right,p,q);\\n#         if(root->left==NULL)\\n#             return root->right;\\n#         else if(root->right==NULL)\\n#             return root->left;\\n#         else\\n#             return root;\\n#     }",
                "codeTag": "Java"
            },
            {
                "id": 2358788,
                "title": "easy-understanding-javascript-solution",
                "content": "Property of BTS is all right subtrees of root will have greater value than root and all left subtrees of root will have lesser value than root.\\n\\nCommon ancestor will justify this condition p.val < root.val > q.val\\n\\nSo if p.val < root.val and q.val < root.val,\\nmove root to its left i.e root=root.left\\n\\nSo if p.val > root.val and q.val > root.val,\\nmove root to its right i.e root=root.right\\n\\nelse we have our root ancestor\\n\\n\\n```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    while(root){\\n        if(p.val>root.val && q.val>root.val){\\n            root=root.right\\n        }else if(p.val<root.val && q.val<root.val){\\n            root=root.left\\n        }else{\\n            return root\\n        }\\n    }\\n}\\n```\\n\\nRuntime: 115 ms, faster than 65.24% of JavaScript online submissions for Lowest Common Ancestor of a Binary Search Tree.\\nMemory Usage: 51.9 MB, less than 88.07% of JavaScript online submissions for Lowest Common Ancestor of a Binary Search Tree.\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    while(root){\\n        if(p.val>root.val && q.val>root.val){\\n            root=root.right\\n        }else if(p.val<root.val && q.val<root.val){\\n            root=root.left\\n        }else{\\n            return root\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1691189,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1798606,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1705055,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1786219,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1731348,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1565278,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1737022,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1567231,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1572114,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1780013,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1691189,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1798606,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1705055,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1786219,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1731348,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1565278,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1737022,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1567231,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1572114,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1780013,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1571473,
                "content": [
                    {
                        "username": "doubledherin",
                        "content": "I'm looking at the Python version, which shows \"rtype: Treenode\", but since we need to return root.val, not root, that should be int, no?"
                    },
                    {
                        "username": "ahmedsidd45",
                        "content": "Exactly, the question is pretty confusing. The should have metioned something like \"return the root node object\" "
                    },
                    {
                        "username": "aweyiun",
                        "content": "The interface function is given two pointers and the returned value is pointer ,not value. If values of the is repeated,  say a extreme case: values are all the same. In general solution, root will be returned which considers only values of p, q not their positions in the BST.So I wonder if pointers should be considered."
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It should probably be an `easy` problem"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "its not easy you MERNcel"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "no no"
                    },
                    {
                        "username": "logancornforth",
                        "content": "What is this error?\\n\\nAttributeError: \\'int\\' object has no attribute \\'val\\'\\n    out = str(ret.val) if ret else \"null\"\\nLine 68 in _driver (Solution.py)\\n    _driver()\\nLine 77 in <module> (Solution.py)"
                    },
                    {
                        "username": "IvndjssG4",
                        "content": "The output is not as expected because the given input is not a binary search tree. In a BST, for every node, all elements in the left subtree should be less than the node\\'s value and all elements in the right subtree should be greater than the node\\'s value. But in this case, [6,2,8,0,4,7,9,null,null,3,5] is not a BST because\\n3 is in left subtree of 2 which is not less than 2, so the given tree is not a binary search tree, so the function will not work correctly on this input.\\n\\nYou can use other methods to find LCA in a binary tree, like storing the path from root to both nodes and then comparing the path to find the first different node.\\nOr, you can use a modified version of the above function that is not only comparing value but also does the comparison between p and q with the current node and it\\'s children."
                    },
                    {
                        "username": "kirany",
                        "content": "For the given example, the LCA of 3 & 5 is reported as 4. Shouldn't it be 2 as 4 itself is a descendant of 2"
                    },
                    {
                        "username": "upup1904",
                        "content": "I thought examples/wording pretty clear but maybe it should say \"deepest common ancestor\" in parents or something."
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "it is depth level, not lowest value of ancestor."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Remember the properties of a **BST** (Binary Search Tree) \n\n`Hint`"
                    },
                    {
                        "username": "throwawayHoppelhase",
                        "content": "It\\'s a BST, therefore there is an ordering on the tree :)! This should do the trick."
                    },
                    {
                        "username": "owengretzinger",
                        "content": "\"Lowest\" is very ambiguous. I (and many others as I can see) thought this meant the node with the least value. It would be helpful to include more clarity in the question! (For example, clarify that \"lowest\" means the node furthest from the root.)"
                    },
                    {
                        "username": "itsgauthamp",
                        "content": "class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\n        queue = [root]\\n\\n        def cans(queue):\\n            while queue:\\n                \\n                size = len(queue)\\n\\n                for i in range(size):\\n                    node = queue.pop(0)\\n                    preval = node.val\\n                    print(\"hi\")\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n                    if node.left:\\n                        print(preval,p.val,q.val,node.left.val)\\n                   \\n\\n                    if p == preval and q == node.left or q==node.right:  #condition 1\\n                        \\n                        return node\\n\\n                    elif (p == node.left or p==node.right) and (q == node.left or q==node.right):\\n                        print(p.val,node.left.val,node.right.val,q.val)\\n                        return node\\n                    elif q == preval and p == node.left or p==node.right:\\n                        return node\\n                        \\n\\n                 \\n        val =cans(queue)\\n        return val\\n\\n\\ncan anyone tell me why this code doesn\\'t work for [2,1] i expect it to pass condition 1"
                    }
                ]
            },
            {
                "id": 1569038,
                "content": [
                    {
                        "username": "doubledherin",
                        "content": "I'm looking at the Python version, which shows \"rtype: Treenode\", but since we need to return root.val, not root, that should be int, no?"
                    },
                    {
                        "username": "ahmedsidd45",
                        "content": "Exactly, the question is pretty confusing. The should have metioned something like \"return the root node object\" "
                    },
                    {
                        "username": "aweyiun",
                        "content": "The interface function is given two pointers and the returned value is pointer ,not value. If values of the is repeated,  say a extreme case: values are all the same. In general solution, root will be returned which considers only values of p, q not their positions in the BST.So I wonder if pointers should be considered."
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It should probably be an `easy` problem"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "its not easy you MERNcel"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "no no"
                    },
                    {
                        "username": "logancornforth",
                        "content": "What is this error?\\n\\nAttributeError: \\'int\\' object has no attribute \\'val\\'\\n    out = str(ret.val) if ret else \"null\"\\nLine 68 in _driver (Solution.py)\\n    _driver()\\nLine 77 in <module> (Solution.py)"
                    },
                    {
                        "username": "IvndjssG4",
                        "content": "The output is not as expected because the given input is not a binary search tree. In a BST, for every node, all elements in the left subtree should be less than the node\\'s value and all elements in the right subtree should be greater than the node\\'s value. But in this case, [6,2,8,0,4,7,9,null,null,3,5] is not a BST because\\n3 is in left subtree of 2 which is not less than 2, so the given tree is not a binary search tree, so the function will not work correctly on this input.\\n\\nYou can use other methods to find LCA in a binary tree, like storing the path from root to both nodes and then comparing the path to find the first different node.\\nOr, you can use a modified version of the above function that is not only comparing value but also does the comparison between p and q with the current node and it\\'s children."
                    },
                    {
                        "username": "kirany",
                        "content": "For the given example, the LCA of 3 & 5 is reported as 4. Shouldn't it be 2 as 4 itself is a descendant of 2"
                    },
                    {
                        "username": "upup1904",
                        "content": "I thought examples/wording pretty clear but maybe it should say \"deepest common ancestor\" in parents or something."
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "it is depth level, not lowest value of ancestor."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Remember the properties of a **BST** (Binary Search Tree) \n\n`Hint`"
                    },
                    {
                        "username": "throwawayHoppelhase",
                        "content": "It\\'s a BST, therefore there is an ordering on the tree :)! This should do the trick."
                    },
                    {
                        "username": "owengretzinger",
                        "content": "\"Lowest\" is very ambiguous. I (and many others as I can see) thought this meant the node with the least value. It would be helpful to include more clarity in the question! (For example, clarify that \"lowest\" means the node furthest from the root.)"
                    },
                    {
                        "username": "itsgauthamp",
                        "content": "class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\n        queue = [root]\\n\\n        def cans(queue):\\n            while queue:\\n                \\n                size = len(queue)\\n\\n                for i in range(size):\\n                    node = queue.pop(0)\\n                    preval = node.val\\n                    print(\"hi\")\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n                    if node.left:\\n                        print(preval,p.val,q.val,node.left.val)\\n                   \\n\\n                    if p == preval and q == node.left or q==node.right:  #condition 1\\n                        \\n                        return node\\n\\n                    elif (p == node.left or p==node.right) and (q == node.left or q==node.right):\\n                        print(p.val,node.left.val,node.right.val,q.val)\\n                        return node\\n                    elif q == preval and p == node.left or p==node.right:\\n                        return node\\n                        \\n\\n                 \\n        val =cans(queue)\\n        return val\\n\\n\\ncan anyone tell me why this code doesn\\'t work for [2,1] i expect it to pass condition 1"
                    }
                ]
            },
            {
                "id": 1922550,
                "content": [
                    {
                        "username": "doubledherin",
                        "content": "I'm looking at the Python version, which shows \"rtype: Treenode\", but since we need to return root.val, not root, that should be int, no?"
                    },
                    {
                        "username": "ahmedsidd45",
                        "content": "Exactly, the question is pretty confusing. The should have metioned something like \"return the root node object\" "
                    },
                    {
                        "username": "aweyiun",
                        "content": "The interface function is given two pointers and the returned value is pointer ,not value. If values of the is repeated,  say a extreme case: values are all the same. In general solution, root will be returned which considers only values of p, q not their positions in the BST.So I wonder if pointers should be considered."
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It should probably be an `easy` problem"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "its not easy you MERNcel"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "no no"
                    },
                    {
                        "username": "logancornforth",
                        "content": "What is this error?\\n\\nAttributeError: \\'int\\' object has no attribute \\'val\\'\\n    out = str(ret.val) if ret else \"null\"\\nLine 68 in _driver (Solution.py)\\n    _driver()\\nLine 77 in <module> (Solution.py)"
                    },
                    {
                        "username": "IvndjssG4",
                        "content": "The output is not as expected because the given input is not a binary search tree. In a BST, for every node, all elements in the left subtree should be less than the node\\'s value and all elements in the right subtree should be greater than the node\\'s value. But in this case, [6,2,8,0,4,7,9,null,null,3,5] is not a BST because\\n3 is in left subtree of 2 which is not less than 2, so the given tree is not a binary search tree, so the function will not work correctly on this input.\\n\\nYou can use other methods to find LCA in a binary tree, like storing the path from root to both nodes and then comparing the path to find the first different node.\\nOr, you can use a modified version of the above function that is not only comparing value but also does the comparison between p and q with the current node and it\\'s children."
                    },
                    {
                        "username": "kirany",
                        "content": "For the given example, the LCA of 3 & 5 is reported as 4. Shouldn't it be 2 as 4 itself is a descendant of 2"
                    },
                    {
                        "username": "upup1904",
                        "content": "I thought examples/wording pretty clear but maybe it should say \"deepest common ancestor\" in parents or something."
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "it is depth level, not lowest value of ancestor."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Remember the properties of a **BST** (Binary Search Tree) \n\n`Hint`"
                    },
                    {
                        "username": "throwawayHoppelhase",
                        "content": "It\\'s a BST, therefore there is an ordering on the tree :)! This should do the trick."
                    },
                    {
                        "username": "owengretzinger",
                        "content": "\"Lowest\" is very ambiguous. I (and many others as I can see) thought this meant the node with the least value. It would be helpful to include more clarity in the question! (For example, clarify that \"lowest\" means the node furthest from the root.)"
                    },
                    {
                        "username": "itsgauthamp",
                        "content": "class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\n        queue = [root]\\n\\n        def cans(queue):\\n            while queue:\\n                \\n                size = len(queue)\\n\\n                for i in range(size):\\n                    node = queue.pop(0)\\n                    preval = node.val\\n                    print(\"hi\")\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n                    if node.left:\\n                        print(preval,p.val,q.val,node.left.val)\\n                   \\n\\n                    if p == preval and q == node.left or q==node.right:  #condition 1\\n                        \\n                        return node\\n\\n                    elif (p == node.left or p==node.right) and (q == node.left or q==node.right):\\n                        print(p.val,node.left.val,node.right.val,q.val)\\n                        return node\\n                    elif q == preval and p == node.left or p==node.right:\\n                        return node\\n                        \\n\\n                 \\n        val =cans(queue)\\n        return val\\n\\n\\ncan anyone tell me why this code doesn\\'t work for [2,1] i expect it to pass condition 1"
                    }
                ]
            },
            {
                "id": 1823770,
                "content": [
                    {
                        "username": "doubledherin",
                        "content": "I'm looking at the Python version, which shows \"rtype: Treenode\", but since we need to return root.val, not root, that should be int, no?"
                    },
                    {
                        "username": "ahmedsidd45",
                        "content": "Exactly, the question is pretty confusing. The should have metioned something like \"return the root node object\" "
                    },
                    {
                        "username": "aweyiun",
                        "content": "The interface function is given two pointers and the returned value is pointer ,not value. If values of the is repeated,  say a extreme case: values are all the same. In general solution, root will be returned which considers only values of p, q not their positions in the BST.So I wonder if pointers should be considered."
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It should probably be an `easy` problem"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "its not easy you MERNcel"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "no no"
                    },
                    {
                        "username": "logancornforth",
                        "content": "What is this error?\\n\\nAttributeError: \\'int\\' object has no attribute \\'val\\'\\n    out = str(ret.val) if ret else \"null\"\\nLine 68 in _driver (Solution.py)\\n    _driver()\\nLine 77 in <module> (Solution.py)"
                    },
                    {
                        "username": "IvndjssG4",
                        "content": "The output is not as expected because the given input is not a binary search tree. In a BST, for every node, all elements in the left subtree should be less than the node\\'s value and all elements in the right subtree should be greater than the node\\'s value. But in this case, [6,2,8,0,4,7,9,null,null,3,5] is not a BST because\\n3 is in left subtree of 2 which is not less than 2, so the given tree is not a binary search tree, so the function will not work correctly on this input.\\n\\nYou can use other methods to find LCA in a binary tree, like storing the path from root to both nodes and then comparing the path to find the first different node.\\nOr, you can use a modified version of the above function that is not only comparing value but also does the comparison between p and q with the current node and it\\'s children."
                    },
                    {
                        "username": "kirany",
                        "content": "For the given example, the LCA of 3 & 5 is reported as 4. Shouldn't it be 2 as 4 itself is a descendant of 2"
                    },
                    {
                        "username": "upup1904",
                        "content": "I thought examples/wording pretty clear but maybe it should say \"deepest common ancestor\" in parents or something."
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "it is depth level, not lowest value of ancestor."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Remember the properties of a **BST** (Binary Search Tree) \n\n`Hint`"
                    },
                    {
                        "username": "throwawayHoppelhase",
                        "content": "It\\'s a BST, therefore there is an ordering on the tree :)! This should do the trick."
                    },
                    {
                        "username": "owengretzinger",
                        "content": "\"Lowest\" is very ambiguous. I (and many others as I can see) thought this meant the node with the least value. It would be helpful to include more clarity in the question! (For example, clarify that \"lowest\" means the node furthest from the root.)"
                    },
                    {
                        "username": "itsgauthamp",
                        "content": "class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\n        queue = [root]\\n\\n        def cans(queue):\\n            while queue:\\n                \\n                size = len(queue)\\n\\n                for i in range(size):\\n                    node = queue.pop(0)\\n                    preval = node.val\\n                    print(\"hi\")\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n                    if node.left:\\n                        print(preval,p.val,q.val,node.left.val)\\n                   \\n\\n                    if p == preval and q == node.left or q==node.right:  #condition 1\\n                        \\n                        return node\\n\\n                    elif (p == node.left or p==node.right) and (q == node.left or q==node.right):\\n                        print(p.val,node.left.val,node.right.val,q.val)\\n                        return node\\n                    elif q == preval and p == node.left or p==node.right:\\n                        return node\\n                        \\n\\n                 \\n        val =cans(queue)\\n        return val\\n\\n\\ncan anyone tell me why this code doesn\\'t work for [2,1] i expect it to pass condition 1"
                    }
                ]
            },
            {
                "id": 1771782,
                "content": [
                    {
                        "username": "doubledherin",
                        "content": "I'm looking at the Python version, which shows \"rtype: Treenode\", but since we need to return root.val, not root, that should be int, no?"
                    },
                    {
                        "username": "ahmedsidd45",
                        "content": "Exactly, the question is pretty confusing. The should have metioned something like \"return the root node object\" "
                    },
                    {
                        "username": "aweyiun",
                        "content": "The interface function is given two pointers and the returned value is pointer ,not value. If values of the is repeated,  say a extreme case: values are all the same. In general solution, root will be returned which considers only values of p, q not their positions in the BST.So I wonder if pointers should be considered."
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It should probably be an `easy` problem"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "its not easy you MERNcel"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "no no"
                    },
                    {
                        "username": "logancornforth",
                        "content": "What is this error?\\n\\nAttributeError: \\'int\\' object has no attribute \\'val\\'\\n    out = str(ret.val) if ret else \"null\"\\nLine 68 in _driver (Solution.py)\\n    _driver()\\nLine 77 in <module> (Solution.py)"
                    },
                    {
                        "username": "IvndjssG4",
                        "content": "The output is not as expected because the given input is not a binary search tree. In a BST, for every node, all elements in the left subtree should be less than the node\\'s value and all elements in the right subtree should be greater than the node\\'s value. But in this case, [6,2,8,0,4,7,9,null,null,3,5] is not a BST because\\n3 is in left subtree of 2 which is not less than 2, so the given tree is not a binary search tree, so the function will not work correctly on this input.\\n\\nYou can use other methods to find LCA in a binary tree, like storing the path from root to both nodes and then comparing the path to find the first different node.\\nOr, you can use a modified version of the above function that is not only comparing value but also does the comparison between p and q with the current node and it\\'s children."
                    },
                    {
                        "username": "kirany",
                        "content": "For the given example, the LCA of 3 & 5 is reported as 4. Shouldn't it be 2 as 4 itself is a descendant of 2"
                    },
                    {
                        "username": "upup1904",
                        "content": "I thought examples/wording pretty clear but maybe it should say \"deepest common ancestor\" in parents or something."
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "it is depth level, not lowest value of ancestor."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Remember the properties of a **BST** (Binary Search Tree) \n\n`Hint`"
                    },
                    {
                        "username": "throwawayHoppelhase",
                        "content": "It\\'s a BST, therefore there is an ordering on the tree :)! This should do the trick."
                    },
                    {
                        "username": "owengretzinger",
                        "content": "\"Lowest\" is very ambiguous. I (and many others as I can see) thought this meant the node with the least value. It would be helpful to include more clarity in the question! (For example, clarify that \"lowest\" means the node furthest from the root.)"
                    },
                    {
                        "username": "itsgauthamp",
                        "content": "class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\n        queue = [root]\\n\\n        def cans(queue):\\n            while queue:\\n                \\n                size = len(queue)\\n\\n                for i in range(size):\\n                    node = queue.pop(0)\\n                    preval = node.val\\n                    print(\"hi\")\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n                    if node.left:\\n                        print(preval,p.val,q.val,node.left.val)\\n                   \\n\\n                    if p == preval and q == node.left or q==node.right:  #condition 1\\n                        \\n                        return node\\n\\n                    elif (p == node.left or p==node.right) and (q == node.left or q==node.right):\\n                        print(p.val,node.left.val,node.right.val,q.val)\\n                        return node\\n                    elif q == preval and p == node.left or p==node.right:\\n                        return node\\n                        \\n\\n                 \\n        val =cans(queue)\\n        return val\\n\\n\\ncan anyone tell me why this code doesn\\'t work for [2,1] i expect it to pass condition 1"
                    }
                ]
            },
            {
                "id": 1571472,
                "content": [
                    {
                        "username": "doubledherin",
                        "content": "I'm looking at the Python version, which shows \"rtype: Treenode\", but since we need to return root.val, not root, that should be int, no?"
                    },
                    {
                        "username": "ahmedsidd45",
                        "content": "Exactly, the question is pretty confusing. The should have metioned something like \"return the root node object\" "
                    },
                    {
                        "username": "aweyiun",
                        "content": "The interface function is given two pointers and the returned value is pointer ,not value. If values of the is repeated,  say a extreme case: values are all the same. In general solution, root will be returned which considers only values of p, q not their positions in the BST.So I wonder if pointers should be considered."
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It should probably be an `easy` problem"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "its not easy you MERNcel"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "no no"
                    },
                    {
                        "username": "logancornforth",
                        "content": "What is this error?\\n\\nAttributeError: \\'int\\' object has no attribute \\'val\\'\\n    out = str(ret.val) if ret else \"null\"\\nLine 68 in _driver (Solution.py)\\n    _driver()\\nLine 77 in <module> (Solution.py)"
                    },
                    {
                        "username": "IvndjssG4",
                        "content": "The output is not as expected because the given input is not a binary search tree. In a BST, for every node, all elements in the left subtree should be less than the node\\'s value and all elements in the right subtree should be greater than the node\\'s value. But in this case, [6,2,8,0,4,7,9,null,null,3,5] is not a BST because\\n3 is in left subtree of 2 which is not less than 2, so the given tree is not a binary search tree, so the function will not work correctly on this input.\\n\\nYou can use other methods to find LCA in a binary tree, like storing the path from root to both nodes and then comparing the path to find the first different node.\\nOr, you can use a modified version of the above function that is not only comparing value but also does the comparison between p and q with the current node and it\\'s children."
                    },
                    {
                        "username": "kirany",
                        "content": "For the given example, the LCA of 3 & 5 is reported as 4. Shouldn't it be 2 as 4 itself is a descendant of 2"
                    },
                    {
                        "username": "upup1904",
                        "content": "I thought examples/wording pretty clear but maybe it should say \"deepest common ancestor\" in parents or something."
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "it is depth level, not lowest value of ancestor."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Remember the properties of a **BST** (Binary Search Tree) \n\n`Hint`"
                    },
                    {
                        "username": "throwawayHoppelhase",
                        "content": "It\\'s a BST, therefore there is an ordering on the tree :)! This should do the trick."
                    },
                    {
                        "username": "owengretzinger",
                        "content": "\"Lowest\" is very ambiguous. I (and many others as I can see) thought this meant the node with the least value. It would be helpful to include more clarity in the question! (For example, clarify that \"lowest\" means the node furthest from the root.)"
                    },
                    {
                        "username": "itsgauthamp",
                        "content": "class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\n        queue = [root]\\n\\n        def cans(queue):\\n            while queue:\\n                \\n                size = len(queue)\\n\\n                for i in range(size):\\n                    node = queue.pop(0)\\n                    preval = node.val\\n                    print(\"hi\")\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n                    if node.left:\\n                        print(preval,p.val,q.val,node.left.val)\\n                   \\n\\n                    if p == preval and q == node.left or q==node.right:  #condition 1\\n                        \\n                        return node\\n\\n                    elif (p == node.left or p==node.right) and (q == node.left or q==node.right):\\n                        print(p.val,node.left.val,node.right.val,q.val)\\n                        return node\\n                    elif q == preval and p == node.left or p==node.right:\\n                        return node\\n                        \\n\\n                 \\n        val =cans(queue)\\n        return val\\n\\n\\ncan anyone tell me why this code doesn\\'t work for [2,1] i expect it to pass condition 1"
                    }
                ]
            },
            {
                "id": 2061565,
                "content": [
                    {
                        "username": "doubledherin",
                        "content": "I'm looking at the Python version, which shows \"rtype: Treenode\", but since we need to return root.val, not root, that should be int, no?"
                    },
                    {
                        "username": "ahmedsidd45",
                        "content": "Exactly, the question is pretty confusing. The should have metioned something like \"return the root node object\" "
                    },
                    {
                        "username": "aweyiun",
                        "content": "The interface function is given two pointers and the returned value is pointer ,not value. If values of the is repeated,  say a extreme case: values are all the same. In general solution, root will be returned which considers only values of p, q not their positions in the BST.So I wonder if pointers should be considered."
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It should probably be an `easy` problem"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "its not easy you MERNcel"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "no no"
                    },
                    {
                        "username": "logancornforth",
                        "content": "What is this error?\\n\\nAttributeError: \\'int\\' object has no attribute \\'val\\'\\n    out = str(ret.val) if ret else \"null\"\\nLine 68 in _driver (Solution.py)\\n    _driver()\\nLine 77 in <module> (Solution.py)"
                    },
                    {
                        "username": "IvndjssG4",
                        "content": "The output is not as expected because the given input is not a binary search tree. In a BST, for every node, all elements in the left subtree should be less than the node\\'s value and all elements in the right subtree should be greater than the node\\'s value. But in this case, [6,2,8,0,4,7,9,null,null,3,5] is not a BST because\\n3 is in left subtree of 2 which is not less than 2, so the given tree is not a binary search tree, so the function will not work correctly on this input.\\n\\nYou can use other methods to find LCA in a binary tree, like storing the path from root to both nodes and then comparing the path to find the first different node.\\nOr, you can use a modified version of the above function that is not only comparing value but also does the comparison between p and q with the current node and it\\'s children."
                    },
                    {
                        "username": "kirany",
                        "content": "For the given example, the LCA of 3 & 5 is reported as 4. Shouldn't it be 2 as 4 itself is a descendant of 2"
                    },
                    {
                        "username": "upup1904",
                        "content": "I thought examples/wording pretty clear but maybe it should say \"deepest common ancestor\" in parents or something."
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "it is depth level, not lowest value of ancestor."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Remember the properties of a **BST** (Binary Search Tree) \n\n`Hint`"
                    },
                    {
                        "username": "throwawayHoppelhase",
                        "content": "It\\'s a BST, therefore there is an ordering on the tree :)! This should do the trick."
                    },
                    {
                        "username": "owengretzinger",
                        "content": "\"Lowest\" is very ambiguous. I (and many others as I can see) thought this meant the node with the least value. It would be helpful to include more clarity in the question! (For example, clarify that \"lowest\" means the node furthest from the root.)"
                    },
                    {
                        "username": "itsgauthamp",
                        "content": "class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\n        queue = [root]\\n\\n        def cans(queue):\\n            while queue:\\n                \\n                size = len(queue)\\n\\n                for i in range(size):\\n                    node = queue.pop(0)\\n                    preval = node.val\\n                    print(\"hi\")\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n                    if node.left:\\n                        print(preval,p.val,q.val,node.left.val)\\n                   \\n\\n                    if p == preval and q == node.left or q==node.right:  #condition 1\\n                        \\n                        return node\\n\\n                    elif (p == node.left or p==node.right) and (q == node.left or q==node.right):\\n                        print(p.val,node.left.val,node.right.val,q.val)\\n                        return node\\n                    elif q == preval and p == node.left or p==node.right:\\n                        return node\\n                        \\n\\n                 \\n        val =cans(queue)\\n        return val\\n\\n\\ncan anyone tell me why this code doesn\\'t work for [2,1] i expect it to pass condition 1"
                    }
                ]
            },
            {
                "id": 2055970,
                "content": [
                    {
                        "username": "doubledherin",
                        "content": "I'm looking at the Python version, which shows \"rtype: Treenode\", but since we need to return root.val, not root, that should be int, no?"
                    },
                    {
                        "username": "ahmedsidd45",
                        "content": "Exactly, the question is pretty confusing. The should have metioned something like \"return the root node object\" "
                    },
                    {
                        "username": "aweyiun",
                        "content": "The interface function is given two pointers and the returned value is pointer ,not value. If values of the is repeated,  say a extreme case: values are all the same. In general solution, root will be returned which considers only values of p, q not their positions in the BST.So I wonder if pointers should be considered."
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It should probably be an `easy` problem"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "its not easy you MERNcel"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "no no"
                    },
                    {
                        "username": "logancornforth",
                        "content": "What is this error?\\n\\nAttributeError: \\'int\\' object has no attribute \\'val\\'\\n    out = str(ret.val) if ret else \"null\"\\nLine 68 in _driver (Solution.py)\\n    _driver()\\nLine 77 in <module> (Solution.py)"
                    },
                    {
                        "username": "IvndjssG4",
                        "content": "The output is not as expected because the given input is not a binary search tree. In a BST, for every node, all elements in the left subtree should be less than the node\\'s value and all elements in the right subtree should be greater than the node\\'s value. But in this case, [6,2,8,0,4,7,9,null,null,3,5] is not a BST because\\n3 is in left subtree of 2 which is not less than 2, so the given tree is not a binary search tree, so the function will not work correctly on this input.\\n\\nYou can use other methods to find LCA in a binary tree, like storing the path from root to both nodes and then comparing the path to find the first different node.\\nOr, you can use a modified version of the above function that is not only comparing value but also does the comparison between p and q with the current node and it\\'s children."
                    },
                    {
                        "username": "kirany",
                        "content": "For the given example, the LCA of 3 & 5 is reported as 4. Shouldn't it be 2 as 4 itself is a descendant of 2"
                    },
                    {
                        "username": "upup1904",
                        "content": "I thought examples/wording pretty clear but maybe it should say \"deepest common ancestor\" in parents or something."
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "it is depth level, not lowest value of ancestor."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Remember the properties of a **BST** (Binary Search Tree) \n\n`Hint`"
                    },
                    {
                        "username": "throwawayHoppelhase",
                        "content": "It\\'s a BST, therefore there is an ordering on the tree :)! This should do the trick."
                    },
                    {
                        "username": "owengretzinger",
                        "content": "\"Lowest\" is very ambiguous. I (and many others as I can see) thought this meant the node with the least value. It would be helpful to include more clarity in the question! (For example, clarify that \"lowest\" means the node furthest from the root.)"
                    },
                    {
                        "username": "itsgauthamp",
                        "content": "class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\n        queue = [root]\\n\\n        def cans(queue):\\n            while queue:\\n                \\n                size = len(queue)\\n\\n                for i in range(size):\\n                    node = queue.pop(0)\\n                    preval = node.val\\n                    print(\"hi\")\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n                    if node.left:\\n                        print(preval,p.val,q.val,node.left.val)\\n                   \\n\\n                    if p == preval and q == node.left or q==node.right:  #condition 1\\n                        \\n                        return node\\n\\n                    elif (p == node.left or p==node.right) and (q == node.left or q==node.right):\\n                        print(p.val,node.left.val,node.right.val,q.val)\\n                        return node\\n                    elif q == preval and p == node.left or p==node.right:\\n                        return node\\n                        \\n\\n                 \\n        val =cans(queue)\\n        return val\\n\\n\\ncan anyone tell me why this code doesn\\'t work for [2,1] i expect it to pass condition 1"
                    }
                ]
            },
            {
                "id": 2055154,
                "content": [
                    {
                        "username": "doubledherin",
                        "content": "I'm looking at the Python version, which shows \"rtype: Treenode\", but since we need to return root.val, not root, that should be int, no?"
                    },
                    {
                        "username": "ahmedsidd45",
                        "content": "Exactly, the question is pretty confusing. The should have metioned something like \"return the root node object\" "
                    },
                    {
                        "username": "aweyiun",
                        "content": "The interface function is given two pointers and the returned value is pointer ,not value. If values of the is repeated,  say a extreme case: values are all the same. In general solution, root will be returned which considers only values of p, q not their positions in the BST.So I wonder if pointers should be considered."
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It should probably be an `easy` problem"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "its not easy you MERNcel"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "no no"
                    },
                    {
                        "username": "logancornforth",
                        "content": "What is this error?\\n\\nAttributeError: \\'int\\' object has no attribute \\'val\\'\\n    out = str(ret.val) if ret else \"null\"\\nLine 68 in _driver (Solution.py)\\n    _driver()\\nLine 77 in <module> (Solution.py)"
                    },
                    {
                        "username": "IvndjssG4",
                        "content": "The output is not as expected because the given input is not a binary search tree. In a BST, for every node, all elements in the left subtree should be less than the node\\'s value and all elements in the right subtree should be greater than the node\\'s value. But in this case, [6,2,8,0,4,7,9,null,null,3,5] is not a BST because\\n3 is in left subtree of 2 which is not less than 2, so the given tree is not a binary search tree, so the function will not work correctly on this input.\\n\\nYou can use other methods to find LCA in a binary tree, like storing the path from root to both nodes and then comparing the path to find the first different node.\\nOr, you can use a modified version of the above function that is not only comparing value but also does the comparison between p and q with the current node and it\\'s children."
                    },
                    {
                        "username": "kirany",
                        "content": "For the given example, the LCA of 3 & 5 is reported as 4. Shouldn't it be 2 as 4 itself is a descendant of 2"
                    },
                    {
                        "username": "upup1904",
                        "content": "I thought examples/wording pretty clear but maybe it should say \"deepest common ancestor\" in parents or something."
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "it is depth level, not lowest value of ancestor."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Remember the properties of a **BST** (Binary Search Tree) \n\n`Hint`"
                    },
                    {
                        "username": "throwawayHoppelhase",
                        "content": "It\\'s a BST, therefore there is an ordering on the tree :)! This should do the trick."
                    },
                    {
                        "username": "owengretzinger",
                        "content": "\"Lowest\" is very ambiguous. I (and many others as I can see) thought this meant the node with the least value. It would be helpful to include more clarity in the question! (For example, clarify that \"lowest\" means the node furthest from the root.)"
                    },
                    {
                        "username": "itsgauthamp",
                        "content": "class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\n        queue = [root]\\n\\n        def cans(queue):\\n            while queue:\\n                \\n                size = len(queue)\\n\\n                for i in range(size):\\n                    node = queue.pop(0)\\n                    preval = node.val\\n                    print(\"hi\")\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n                    if node.left:\\n                        print(preval,p.val,q.val,node.left.val)\\n                   \\n\\n                    if p == preval and q == node.left or q==node.right:  #condition 1\\n                        \\n                        return node\\n\\n                    elif (p == node.left or p==node.right) and (q == node.left or q==node.right):\\n                        print(p.val,node.left.val,node.right.val,q.val)\\n                        return node\\n                    elif q == preval and p == node.left or p==node.right:\\n                        return node\\n                        \\n\\n                 \\n        val =cans(queue)\\n        return val\\n\\n\\ncan anyone tell me why this code doesn\\'t work for [2,1] i expect it to pass condition 1"
                    }
                ]
            },
            {
                "id": 2024278,
                "content": [
                    {
                        "username": "doubledherin",
                        "content": "I'm looking at the Python version, which shows \"rtype: Treenode\", but since we need to return root.val, not root, that should be int, no?"
                    },
                    {
                        "username": "ahmedsidd45",
                        "content": "Exactly, the question is pretty confusing. The should have metioned something like \"return the root node object\" "
                    },
                    {
                        "username": "aweyiun",
                        "content": "The interface function is given two pointers and the returned value is pointer ,not value. If values of the is repeated,  say a extreme case: values are all the same. In general solution, root will be returned which considers only values of p, q not their positions in the BST.So I wonder if pointers should be considered."
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It should probably be an `easy` problem"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "its not easy you MERNcel"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "no no"
                    },
                    {
                        "username": "logancornforth",
                        "content": "What is this error?\\n\\nAttributeError: \\'int\\' object has no attribute \\'val\\'\\n    out = str(ret.val) if ret else \"null\"\\nLine 68 in _driver (Solution.py)\\n    _driver()\\nLine 77 in <module> (Solution.py)"
                    },
                    {
                        "username": "IvndjssG4",
                        "content": "The output is not as expected because the given input is not a binary search tree. In a BST, for every node, all elements in the left subtree should be less than the node\\'s value and all elements in the right subtree should be greater than the node\\'s value. But in this case, [6,2,8,0,4,7,9,null,null,3,5] is not a BST because\\n3 is in left subtree of 2 which is not less than 2, so the given tree is not a binary search tree, so the function will not work correctly on this input.\\n\\nYou can use other methods to find LCA in a binary tree, like storing the path from root to both nodes and then comparing the path to find the first different node.\\nOr, you can use a modified version of the above function that is not only comparing value but also does the comparison between p and q with the current node and it\\'s children."
                    },
                    {
                        "username": "kirany",
                        "content": "For the given example, the LCA of 3 & 5 is reported as 4. Shouldn't it be 2 as 4 itself is a descendant of 2"
                    },
                    {
                        "username": "upup1904",
                        "content": "I thought examples/wording pretty clear but maybe it should say \"deepest common ancestor\" in parents or something."
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "it is depth level, not lowest value of ancestor."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Remember the properties of a **BST** (Binary Search Tree) \n\n`Hint`"
                    },
                    {
                        "username": "throwawayHoppelhase",
                        "content": "It\\'s a BST, therefore there is an ordering on the tree :)! This should do the trick."
                    },
                    {
                        "username": "owengretzinger",
                        "content": "\"Lowest\" is very ambiguous. I (and many others as I can see) thought this meant the node with the least value. It would be helpful to include more clarity in the question! (For example, clarify that \"lowest\" means the node furthest from the root.)"
                    },
                    {
                        "username": "itsgauthamp",
                        "content": "class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\n        queue = [root]\\n\\n        def cans(queue):\\n            while queue:\\n                \\n                size = len(queue)\\n\\n                for i in range(size):\\n                    node = queue.pop(0)\\n                    preval = node.val\\n                    print(\"hi\")\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n                    if node.left:\\n                        print(preval,p.val,q.val,node.left.val)\\n                   \\n\\n                    if p == preval and q == node.left or q==node.right:  #condition 1\\n                        \\n                        return node\\n\\n                    elif (p == node.left or p==node.right) and (q == node.left or q==node.right):\\n                        print(p.val,node.left.val,node.right.val,q.val)\\n                        return node\\n                    elif q == preval and p == node.left or p==node.right:\\n                        return node\\n                        \\n\\n                 \\n        val =cans(queue)\\n        return val\\n\\n\\ncan anyone tell me why this code doesn\\'t work for [2,1] i expect it to pass condition 1"
                    }
                ]
            },
            {
                "id": 2008930,
                "content": [
                    {
                        "username": "yip1",
                        "content": "(HINT) Think of the properties of binary search! Look at the values of p and q and their placement in the tree.\\n(specifically how the placements affect our decision to traverse left or right)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit for best solution with best explanation :\\nhttps://leetcode.com/problems/make-array-strictly-increasing/solutions/3646825/c-dynamic-programming/[leetcode]\\n\\n [@Ashish Madhup](/ashish_madhup)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit my solutions"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have copy pasted my code from Question \\n**236. Lowest Common Ancestor of a Binary Tree**\\n and successfully submitted"
                    },
                    {
                        "username": "geekyshark",
                        "content": "you just unlocked clown outfit"
                    },
                    {
                        "username": "sspenst",
                        "content": "I guess it\\'s been a while since I\\'ve looked at trees, I forgot BST implies left and right are lower and greater respectively...\\n\\nMy first solution used DFS until I found both p and q while keeping track of the paths to each node, then compared the paths to see where they diverge. Obviously it becomes a lot easier if you know a BST is ordered \\uD83D\\uDE05"
                    },
                    {
                        "username": "jvpessoa10",
                        "content": "Can someone help me to understand why my solution only beats 5% of all submissions in terms of speed?\n\nI go down the tree until the nodes diverge. I assume it should be O (lg n ) Speed and O (1) Space\n\n  ```\nfun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n\n        var ancestor: TreeNode? = null\n\n        var pCurr = root\n        var qCurr = root\n\n        while(pCurr == qCurr) {\n            ancestor = pCurr\n\n            if (p!!.`val` > pCurr!!.`val`) {\n                pCurr = pCurr?.right\n            } else if (p!!.`val` < pCurr!!.`val`) {\n                pCurr = pCurr?.left\n            }\n\n            if (q!!.`val` > qCurr!!.`val`) {\n                qCurr = qCurr?.right\n            } else if (q!!.`val` < qCurr!!.`val`) {\n                qCurr = qCurr?.left\n            }\n        }\n\n        return ancestor\n    }\n\n```\n\n"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "toyeshingole",
                        "content": "this kinda does not make sense to me\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "Naveen_Singh__",
                        "content": "The lowest common ancestor will be the node from where p node and q node will situated at opposite side to each other.\\ni.e lets say p.val < q.val\\nin that case\\nif(root.val >= p.val && root.val <= q.val)return root\\n(root node will be your lowest Common Ancestor)\\n\\nif p.val > q.val\\nin that case\\nif(root.val <= p.val && root.val >= q.val)return root\\n(root node will be your lowest Common Ancestor)  "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "harshadrsharma",
                        "content": "This is an easy solution once you understand that it is a BST and that the nodes p and q are guaranteed to be present in the tree. Don\\'t understand why it\\'s tagged as a medium one."
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "What type are p and q exactly? In lowestCommonAncestor it\\'s defined as TreeNode and in the Testcases it\\'s int. Which one is the actual type?"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "[@IvanStebletsov](/IvanStebletsov) oh, the error was that output must have been a node not an int"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "TreeNode it\\'s an object, inside this object there is a property with its value named as \"val\", value is int."
                    }
                ]
            },
            {
                "id": 1932960,
                "content": [
                    {
                        "username": "yip1",
                        "content": "(HINT) Think of the properties of binary search! Look at the values of p and q and their placement in the tree.\\n(specifically how the placements affect our decision to traverse left or right)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit for best solution with best explanation :\\nhttps://leetcode.com/problems/make-array-strictly-increasing/solutions/3646825/c-dynamic-programming/[leetcode]\\n\\n [@Ashish Madhup](/ashish_madhup)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit my solutions"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have copy pasted my code from Question \\n**236. Lowest Common Ancestor of a Binary Tree**\\n and successfully submitted"
                    },
                    {
                        "username": "geekyshark",
                        "content": "you just unlocked clown outfit"
                    },
                    {
                        "username": "sspenst",
                        "content": "I guess it\\'s been a while since I\\'ve looked at trees, I forgot BST implies left and right are lower and greater respectively...\\n\\nMy first solution used DFS until I found both p and q while keeping track of the paths to each node, then compared the paths to see where they diverge. Obviously it becomes a lot easier if you know a BST is ordered \\uD83D\\uDE05"
                    },
                    {
                        "username": "jvpessoa10",
                        "content": "Can someone help me to understand why my solution only beats 5% of all submissions in terms of speed?\n\nI go down the tree until the nodes diverge. I assume it should be O (lg n ) Speed and O (1) Space\n\n  ```\nfun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n\n        var ancestor: TreeNode? = null\n\n        var pCurr = root\n        var qCurr = root\n\n        while(pCurr == qCurr) {\n            ancestor = pCurr\n\n            if (p!!.`val` > pCurr!!.`val`) {\n                pCurr = pCurr?.right\n            } else if (p!!.`val` < pCurr!!.`val`) {\n                pCurr = pCurr?.left\n            }\n\n            if (q!!.`val` > qCurr!!.`val`) {\n                qCurr = qCurr?.right\n            } else if (q!!.`val` < qCurr!!.`val`) {\n                qCurr = qCurr?.left\n            }\n        }\n\n        return ancestor\n    }\n\n```\n\n"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "toyeshingole",
                        "content": "this kinda does not make sense to me\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "Naveen_Singh__",
                        "content": "The lowest common ancestor will be the node from where p node and q node will situated at opposite side to each other.\\ni.e lets say p.val < q.val\\nin that case\\nif(root.val >= p.val && root.val <= q.val)return root\\n(root node will be your lowest Common Ancestor)\\n\\nif p.val > q.val\\nin that case\\nif(root.val <= p.val && root.val >= q.val)return root\\n(root node will be your lowest Common Ancestor)  "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "harshadrsharma",
                        "content": "This is an easy solution once you understand that it is a BST and that the nodes p and q are guaranteed to be present in the tree. Don\\'t understand why it\\'s tagged as a medium one."
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "What type are p and q exactly? In lowestCommonAncestor it\\'s defined as TreeNode and in the Testcases it\\'s int. Which one is the actual type?"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "[@IvanStebletsov](/IvanStebletsov) oh, the error was that output must have been a node not an int"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "TreeNode it\\'s an object, inside this object there is a property with its value named as \"val\", value is int."
                    }
                ]
            },
            {
                "id": 1932956,
                "content": [
                    {
                        "username": "yip1",
                        "content": "(HINT) Think of the properties of binary search! Look at the values of p and q and their placement in the tree.\\n(specifically how the placements affect our decision to traverse left or right)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit for best solution with best explanation :\\nhttps://leetcode.com/problems/make-array-strictly-increasing/solutions/3646825/c-dynamic-programming/[leetcode]\\n\\n [@Ashish Madhup](/ashish_madhup)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit my solutions"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have copy pasted my code from Question \\n**236. Lowest Common Ancestor of a Binary Tree**\\n and successfully submitted"
                    },
                    {
                        "username": "geekyshark",
                        "content": "you just unlocked clown outfit"
                    },
                    {
                        "username": "sspenst",
                        "content": "I guess it\\'s been a while since I\\'ve looked at trees, I forgot BST implies left and right are lower and greater respectively...\\n\\nMy first solution used DFS until I found both p and q while keeping track of the paths to each node, then compared the paths to see where they diverge. Obviously it becomes a lot easier if you know a BST is ordered \\uD83D\\uDE05"
                    },
                    {
                        "username": "jvpessoa10",
                        "content": "Can someone help me to understand why my solution only beats 5% of all submissions in terms of speed?\n\nI go down the tree until the nodes diverge. I assume it should be O (lg n ) Speed and O (1) Space\n\n  ```\nfun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n\n        var ancestor: TreeNode? = null\n\n        var pCurr = root\n        var qCurr = root\n\n        while(pCurr == qCurr) {\n            ancestor = pCurr\n\n            if (p!!.`val` > pCurr!!.`val`) {\n                pCurr = pCurr?.right\n            } else if (p!!.`val` < pCurr!!.`val`) {\n                pCurr = pCurr?.left\n            }\n\n            if (q!!.`val` > qCurr!!.`val`) {\n                qCurr = qCurr?.right\n            } else if (q!!.`val` < qCurr!!.`val`) {\n                qCurr = qCurr?.left\n            }\n        }\n\n        return ancestor\n    }\n\n```\n\n"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "toyeshingole",
                        "content": "this kinda does not make sense to me\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "Naveen_Singh__",
                        "content": "The lowest common ancestor will be the node from where p node and q node will situated at opposite side to each other.\\ni.e lets say p.val < q.val\\nin that case\\nif(root.val >= p.val && root.val <= q.val)return root\\n(root node will be your lowest Common Ancestor)\\n\\nif p.val > q.val\\nin that case\\nif(root.val <= p.val && root.val >= q.val)return root\\n(root node will be your lowest Common Ancestor)  "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "harshadrsharma",
                        "content": "This is an easy solution once you understand that it is a BST and that the nodes p and q are guaranteed to be present in the tree. Don\\'t understand why it\\'s tagged as a medium one."
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "What type are p and q exactly? In lowestCommonAncestor it\\'s defined as TreeNode and in the Testcases it\\'s int. Which one is the actual type?"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "[@IvanStebletsov](/IvanStebletsov) oh, the error was that output must have been a node not an int"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "TreeNode it\\'s an object, inside this object there is a property with its value named as \"val\", value is int."
                    }
                ]
            },
            {
                "id": 1932830,
                "content": [
                    {
                        "username": "yip1",
                        "content": "(HINT) Think of the properties of binary search! Look at the values of p and q and their placement in the tree.\\n(specifically how the placements affect our decision to traverse left or right)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit for best solution with best explanation :\\nhttps://leetcode.com/problems/make-array-strictly-increasing/solutions/3646825/c-dynamic-programming/[leetcode]\\n\\n [@Ashish Madhup](/ashish_madhup)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit my solutions"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have copy pasted my code from Question \\n**236. Lowest Common Ancestor of a Binary Tree**\\n and successfully submitted"
                    },
                    {
                        "username": "geekyshark",
                        "content": "you just unlocked clown outfit"
                    },
                    {
                        "username": "sspenst",
                        "content": "I guess it\\'s been a while since I\\'ve looked at trees, I forgot BST implies left and right are lower and greater respectively...\\n\\nMy first solution used DFS until I found both p and q while keeping track of the paths to each node, then compared the paths to see where they diverge. Obviously it becomes a lot easier if you know a BST is ordered \\uD83D\\uDE05"
                    },
                    {
                        "username": "jvpessoa10",
                        "content": "Can someone help me to understand why my solution only beats 5% of all submissions in terms of speed?\n\nI go down the tree until the nodes diverge. I assume it should be O (lg n ) Speed and O (1) Space\n\n  ```\nfun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n\n        var ancestor: TreeNode? = null\n\n        var pCurr = root\n        var qCurr = root\n\n        while(pCurr == qCurr) {\n            ancestor = pCurr\n\n            if (p!!.`val` > pCurr!!.`val`) {\n                pCurr = pCurr?.right\n            } else if (p!!.`val` < pCurr!!.`val`) {\n                pCurr = pCurr?.left\n            }\n\n            if (q!!.`val` > qCurr!!.`val`) {\n                qCurr = qCurr?.right\n            } else if (q!!.`val` < qCurr!!.`val`) {\n                qCurr = qCurr?.left\n            }\n        }\n\n        return ancestor\n    }\n\n```\n\n"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "toyeshingole",
                        "content": "this kinda does not make sense to me\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "Naveen_Singh__",
                        "content": "The lowest common ancestor will be the node from where p node and q node will situated at opposite side to each other.\\ni.e lets say p.val < q.val\\nin that case\\nif(root.val >= p.val && root.val <= q.val)return root\\n(root node will be your lowest Common Ancestor)\\n\\nif p.val > q.val\\nin that case\\nif(root.val <= p.val && root.val >= q.val)return root\\n(root node will be your lowest Common Ancestor)  "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "harshadrsharma",
                        "content": "This is an easy solution once you understand that it is a BST and that the nodes p and q are guaranteed to be present in the tree. Don\\'t understand why it\\'s tagged as a medium one."
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "What type are p and q exactly? In lowestCommonAncestor it\\'s defined as TreeNode and in the Testcases it\\'s int. Which one is the actual type?"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "[@IvanStebletsov](/IvanStebletsov) oh, the error was that output must have been a node not an int"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "TreeNode it\\'s an object, inside this object there is a property with its value named as \"val\", value is int."
                    }
                ]
            },
            {
                "id": 1902436,
                "content": [
                    {
                        "username": "yip1",
                        "content": "(HINT) Think of the properties of binary search! Look at the values of p and q and their placement in the tree.\\n(specifically how the placements affect our decision to traverse left or right)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit for best solution with best explanation :\\nhttps://leetcode.com/problems/make-array-strictly-increasing/solutions/3646825/c-dynamic-programming/[leetcode]\\n\\n [@Ashish Madhup](/ashish_madhup)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit my solutions"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have copy pasted my code from Question \\n**236. Lowest Common Ancestor of a Binary Tree**\\n and successfully submitted"
                    },
                    {
                        "username": "geekyshark",
                        "content": "you just unlocked clown outfit"
                    },
                    {
                        "username": "sspenst",
                        "content": "I guess it\\'s been a while since I\\'ve looked at trees, I forgot BST implies left and right are lower and greater respectively...\\n\\nMy first solution used DFS until I found both p and q while keeping track of the paths to each node, then compared the paths to see where they diverge. Obviously it becomes a lot easier if you know a BST is ordered \\uD83D\\uDE05"
                    },
                    {
                        "username": "jvpessoa10",
                        "content": "Can someone help me to understand why my solution only beats 5% of all submissions in terms of speed?\n\nI go down the tree until the nodes diverge. I assume it should be O (lg n ) Speed and O (1) Space\n\n  ```\nfun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n\n        var ancestor: TreeNode? = null\n\n        var pCurr = root\n        var qCurr = root\n\n        while(pCurr == qCurr) {\n            ancestor = pCurr\n\n            if (p!!.`val` > pCurr!!.`val`) {\n                pCurr = pCurr?.right\n            } else if (p!!.`val` < pCurr!!.`val`) {\n                pCurr = pCurr?.left\n            }\n\n            if (q!!.`val` > qCurr!!.`val`) {\n                qCurr = qCurr?.right\n            } else if (q!!.`val` < qCurr!!.`val`) {\n                qCurr = qCurr?.left\n            }\n        }\n\n        return ancestor\n    }\n\n```\n\n"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "toyeshingole",
                        "content": "this kinda does not make sense to me\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "Naveen_Singh__",
                        "content": "The lowest common ancestor will be the node from where p node and q node will situated at opposite side to each other.\\ni.e lets say p.val < q.val\\nin that case\\nif(root.val >= p.val && root.val <= q.val)return root\\n(root node will be your lowest Common Ancestor)\\n\\nif p.val > q.val\\nin that case\\nif(root.val <= p.val && root.val >= q.val)return root\\n(root node will be your lowest Common Ancestor)  "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "harshadrsharma",
                        "content": "This is an easy solution once you understand that it is a BST and that the nodes p and q are guaranteed to be present in the tree. Don\\'t understand why it\\'s tagged as a medium one."
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "What type are p and q exactly? In lowestCommonAncestor it\\'s defined as TreeNode and in the Testcases it\\'s int. Which one is the actual type?"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "[@IvanStebletsov](/IvanStebletsov) oh, the error was that output must have been a node not an int"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "TreeNode it\\'s an object, inside this object there is a property with its value named as \"val\", value is int."
                    }
                ]
            },
            {
                "id": 1893005,
                "content": [
                    {
                        "username": "yip1",
                        "content": "(HINT) Think of the properties of binary search! Look at the values of p and q and their placement in the tree.\\n(specifically how the placements affect our decision to traverse left or right)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit for best solution with best explanation :\\nhttps://leetcode.com/problems/make-array-strictly-increasing/solutions/3646825/c-dynamic-programming/[leetcode]\\n\\n [@Ashish Madhup](/ashish_madhup)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit my solutions"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have copy pasted my code from Question \\n**236. Lowest Common Ancestor of a Binary Tree**\\n and successfully submitted"
                    },
                    {
                        "username": "geekyshark",
                        "content": "you just unlocked clown outfit"
                    },
                    {
                        "username": "sspenst",
                        "content": "I guess it\\'s been a while since I\\'ve looked at trees, I forgot BST implies left and right are lower and greater respectively...\\n\\nMy first solution used DFS until I found both p and q while keeping track of the paths to each node, then compared the paths to see where they diverge. Obviously it becomes a lot easier if you know a BST is ordered \\uD83D\\uDE05"
                    },
                    {
                        "username": "jvpessoa10",
                        "content": "Can someone help me to understand why my solution only beats 5% of all submissions in terms of speed?\n\nI go down the tree until the nodes diverge. I assume it should be O (lg n ) Speed and O (1) Space\n\n  ```\nfun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n\n        var ancestor: TreeNode? = null\n\n        var pCurr = root\n        var qCurr = root\n\n        while(pCurr == qCurr) {\n            ancestor = pCurr\n\n            if (p!!.`val` > pCurr!!.`val`) {\n                pCurr = pCurr?.right\n            } else if (p!!.`val` < pCurr!!.`val`) {\n                pCurr = pCurr?.left\n            }\n\n            if (q!!.`val` > qCurr!!.`val`) {\n                qCurr = qCurr?.right\n            } else if (q!!.`val` < qCurr!!.`val`) {\n                qCurr = qCurr?.left\n            }\n        }\n\n        return ancestor\n    }\n\n```\n\n"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "toyeshingole",
                        "content": "this kinda does not make sense to me\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "Naveen_Singh__",
                        "content": "The lowest common ancestor will be the node from where p node and q node will situated at opposite side to each other.\\ni.e lets say p.val < q.val\\nin that case\\nif(root.val >= p.val && root.val <= q.val)return root\\n(root node will be your lowest Common Ancestor)\\n\\nif p.val > q.val\\nin that case\\nif(root.val <= p.val && root.val >= q.val)return root\\n(root node will be your lowest Common Ancestor)  "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "harshadrsharma",
                        "content": "This is an easy solution once you understand that it is a BST and that the nodes p and q are guaranteed to be present in the tree. Don\\'t understand why it\\'s tagged as a medium one."
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "What type are p and q exactly? In lowestCommonAncestor it\\'s defined as TreeNode and in the Testcases it\\'s int. Which one is the actual type?"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "[@IvanStebletsov](/IvanStebletsov) oh, the error was that output must have been a node not an int"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "TreeNode it\\'s an object, inside this object there is a property with its value named as \"val\", value is int."
                    }
                ]
            },
            {
                "id": 1871112,
                "content": [
                    {
                        "username": "yip1",
                        "content": "(HINT) Think of the properties of binary search! Look at the values of p and q and their placement in the tree.\\n(specifically how the placements affect our decision to traverse left or right)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit for best solution with best explanation :\\nhttps://leetcode.com/problems/make-array-strictly-increasing/solutions/3646825/c-dynamic-programming/[leetcode]\\n\\n [@Ashish Madhup](/ashish_madhup)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit my solutions"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have copy pasted my code from Question \\n**236. Lowest Common Ancestor of a Binary Tree**\\n and successfully submitted"
                    },
                    {
                        "username": "geekyshark",
                        "content": "you just unlocked clown outfit"
                    },
                    {
                        "username": "sspenst",
                        "content": "I guess it\\'s been a while since I\\'ve looked at trees, I forgot BST implies left and right are lower and greater respectively...\\n\\nMy first solution used DFS until I found both p and q while keeping track of the paths to each node, then compared the paths to see where they diverge. Obviously it becomes a lot easier if you know a BST is ordered \\uD83D\\uDE05"
                    },
                    {
                        "username": "jvpessoa10",
                        "content": "Can someone help me to understand why my solution only beats 5% of all submissions in terms of speed?\n\nI go down the tree until the nodes diverge. I assume it should be O (lg n ) Speed and O (1) Space\n\n  ```\nfun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n\n        var ancestor: TreeNode? = null\n\n        var pCurr = root\n        var qCurr = root\n\n        while(pCurr == qCurr) {\n            ancestor = pCurr\n\n            if (p!!.`val` > pCurr!!.`val`) {\n                pCurr = pCurr?.right\n            } else if (p!!.`val` < pCurr!!.`val`) {\n                pCurr = pCurr?.left\n            }\n\n            if (q!!.`val` > qCurr!!.`val`) {\n                qCurr = qCurr?.right\n            } else if (q!!.`val` < qCurr!!.`val`) {\n                qCurr = qCurr?.left\n            }\n        }\n\n        return ancestor\n    }\n\n```\n\n"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "toyeshingole",
                        "content": "this kinda does not make sense to me\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "Naveen_Singh__",
                        "content": "The lowest common ancestor will be the node from where p node and q node will situated at opposite side to each other.\\ni.e lets say p.val < q.val\\nin that case\\nif(root.val >= p.val && root.val <= q.val)return root\\n(root node will be your lowest Common Ancestor)\\n\\nif p.val > q.val\\nin that case\\nif(root.val <= p.val && root.val >= q.val)return root\\n(root node will be your lowest Common Ancestor)  "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "harshadrsharma",
                        "content": "This is an easy solution once you understand that it is a BST and that the nodes p and q are guaranteed to be present in the tree. Don\\'t understand why it\\'s tagged as a medium one."
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "What type are p and q exactly? In lowestCommonAncestor it\\'s defined as TreeNode and in the Testcases it\\'s int. Which one is the actual type?"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "[@IvanStebletsov](/IvanStebletsov) oh, the error was that output must have been a node not an int"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "TreeNode it\\'s an object, inside this object there is a property with its value named as \"val\", value is int."
                    }
                ]
            },
            {
                "id": 1844131,
                "content": [
                    {
                        "username": "yip1",
                        "content": "(HINT) Think of the properties of binary search! Look at the values of p and q and their placement in the tree.\\n(specifically how the placements affect our decision to traverse left or right)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit for best solution with best explanation :\\nhttps://leetcode.com/problems/make-array-strictly-increasing/solutions/3646825/c-dynamic-programming/[leetcode]\\n\\n [@Ashish Madhup](/ashish_madhup)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit my solutions"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have copy pasted my code from Question \\n**236. Lowest Common Ancestor of a Binary Tree**\\n and successfully submitted"
                    },
                    {
                        "username": "geekyshark",
                        "content": "you just unlocked clown outfit"
                    },
                    {
                        "username": "sspenst",
                        "content": "I guess it\\'s been a while since I\\'ve looked at trees, I forgot BST implies left and right are lower and greater respectively...\\n\\nMy first solution used DFS until I found both p and q while keeping track of the paths to each node, then compared the paths to see where they diverge. Obviously it becomes a lot easier if you know a BST is ordered \\uD83D\\uDE05"
                    },
                    {
                        "username": "jvpessoa10",
                        "content": "Can someone help me to understand why my solution only beats 5% of all submissions in terms of speed?\n\nI go down the tree until the nodes diverge. I assume it should be O (lg n ) Speed and O (1) Space\n\n  ```\nfun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n\n        var ancestor: TreeNode? = null\n\n        var pCurr = root\n        var qCurr = root\n\n        while(pCurr == qCurr) {\n            ancestor = pCurr\n\n            if (p!!.`val` > pCurr!!.`val`) {\n                pCurr = pCurr?.right\n            } else if (p!!.`val` < pCurr!!.`val`) {\n                pCurr = pCurr?.left\n            }\n\n            if (q!!.`val` > qCurr!!.`val`) {\n                qCurr = qCurr?.right\n            } else if (q!!.`val` < qCurr!!.`val`) {\n                qCurr = qCurr?.left\n            }\n        }\n\n        return ancestor\n    }\n\n```\n\n"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "toyeshingole",
                        "content": "this kinda does not make sense to me\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "Naveen_Singh__",
                        "content": "The lowest common ancestor will be the node from where p node and q node will situated at opposite side to each other.\\ni.e lets say p.val < q.val\\nin that case\\nif(root.val >= p.val && root.val <= q.val)return root\\n(root node will be your lowest Common Ancestor)\\n\\nif p.val > q.val\\nin that case\\nif(root.val <= p.val && root.val >= q.val)return root\\n(root node will be your lowest Common Ancestor)  "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "harshadrsharma",
                        "content": "This is an easy solution once you understand that it is a BST and that the nodes p and q are guaranteed to be present in the tree. Don\\'t understand why it\\'s tagged as a medium one."
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "What type are p and q exactly? In lowestCommonAncestor it\\'s defined as TreeNode and in the Testcases it\\'s int. Which one is the actual type?"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "[@IvanStebletsov](/IvanStebletsov) oh, the error was that output must have been a node not an int"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "TreeNode it\\'s an object, inside this object there is a property with its value named as \"val\", value is int."
                    }
                ]
            },
            {
                "id": 1837413,
                "content": [
                    {
                        "username": "yip1",
                        "content": "(HINT) Think of the properties of binary search! Look at the values of p and q and their placement in the tree.\\n(specifically how the placements affect our decision to traverse left or right)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit for best solution with best explanation :\\nhttps://leetcode.com/problems/make-array-strictly-increasing/solutions/3646825/c-dynamic-programming/[leetcode]\\n\\n [@Ashish Madhup](/ashish_madhup)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit my solutions"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have copy pasted my code from Question \\n**236. Lowest Common Ancestor of a Binary Tree**\\n and successfully submitted"
                    },
                    {
                        "username": "geekyshark",
                        "content": "you just unlocked clown outfit"
                    },
                    {
                        "username": "sspenst",
                        "content": "I guess it\\'s been a while since I\\'ve looked at trees, I forgot BST implies left and right are lower and greater respectively...\\n\\nMy first solution used DFS until I found both p and q while keeping track of the paths to each node, then compared the paths to see where they diverge. Obviously it becomes a lot easier if you know a BST is ordered \\uD83D\\uDE05"
                    },
                    {
                        "username": "jvpessoa10",
                        "content": "Can someone help me to understand why my solution only beats 5% of all submissions in terms of speed?\n\nI go down the tree until the nodes diverge. I assume it should be O (lg n ) Speed and O (1) Space\n\n  ```\nfun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n\n        var ancestor: TreeNode? = null\n\n        var pCurr = root\n        var qCurr = root\n\n        while(pCurr == qCurr) {\n            ancestor = pCurr\n\n            if (p!!.`val` > pCurr!!.`val`) {\n                pCurr = pCurr?.right\n            } else if (p!!.`val` < pCurr!!.`val`) {\n                pCurr = pCurr?.left\n            }\n\n            if (q!!.`val` > qCurr!!.`val`) {\n                qCurr = qCurr?.right\n            } else if (q!!.`val` < qCurr!!.`val`) {\n                qCurr = qCurr?.left\n            }\n        }\n\n        return ancestor\n    }\n\n```\n\n"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "toyeshingole",
                        "content": "this kinda does not make sense to me\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "Naveen_Singh__",
                        "content": "The lowest common ancestor will be the node from where p node and q node will situated at opposite side to each other.\\ni.e lets say p.val < q.val\\nin that case\\nif(root.val >= p.val && root.val <= q.val)return root\\n(root node will be your lowest Common Ancestor)\\n\\nif p.val > q.val\\nin that case\\nif(root.val <= p.val && root.val >= q.val)return root\\n(root node will be your lowest Common Ancestor)  "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "harshadrsharma",
                        "content": "This is an easy solution once you understand that it is a BST and that the nodes p and q are guaranteed to be present in the tree. Don\\'t understand why it\\'s tagged as a medium one."
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "What type are p and q exactly? In lowestCommonAncestor it\\'s defined as TreeNode and in the Testcases it\\'s int. Which one is the actual type?"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "[@IvanStebletsov](/IvanStebletsov) oh, the error was that output must have been a node not an int"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "TreeNode it\\'s an object, inside this object there is a property with its value named as \"val\", value is int."
                    }
                ]
            },
            {
                "id": 1799306,
                "content": [
                    {
                        "username": "yip1",
                        "content": "(HINT) Think of the properties of binary search! Look at the values of p and q and their placement in the tree.\\n(specifically how the placements affect our decision to traverse left or right)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit for best solution with best explanation :\\nhttps://leetcode.com/problems/make-array-strictly-increasing/solutions/3646825/c-dynamic-programming/[leetcode]\\n\\n [@Ashish Madhup](/ashish_madhup)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit my solutions"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have copy pasted my code from Question \\n**236. Lowest Common Ancestor of a Binary Tree**\\n and successfully submitted"
                    },
                    {
                        "username": "geekyshark",
                        "content": "you just unlocked clown outfit"
                    },
                    {
                        "username": "sspenst",
                        "content": "I guess it\\'s been a while since I\\'ve looked at trees, I forgot BST implies left and right are lower and greater respectively...\\n\\nMy first solution used DFS until I found both p and q while keeping track of the paths to each node, then compared the paths to see where they diverge. Obviously it becomes a lot easier if you know a BST is ordered \\uD83D\\uDE05"
                    },
                    {
                        "username": "jvpessoa10",
                        "content": "Can someone help me to understand why my solution only beats 5% of all submissions in terms of speed?\n\nI go down the tree until the nodes diverge. I assume it should be O (lg n ) Speed and O (1) Space\n\n  ```\nfun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n\n        var ancestor: TreeNode? = null\n\n        var pCurr = root\n        var qCurr = root\n\n        while(pCurr == qCurr) {\n            ancestor = pCurr\n\n            if (p!!.`val` > pCurr!!.`val`) {\n                pCurr = pCurr?.right\n            } else if (p!!.`val` < pCurr!!.`val`) {\n                pCurr = pCurr?.left\n            }\n\n            if (q!!.`val` > qCurr!!.`val`) {\n                qCurr = qCurr?.right\n            } else if (q!!.`val` < qCurr!!.`val`) {\n                qCurr = qCurr?.left\n            }\n        }\n\n        return ancestor\n    }\n\n```\n\n"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "toyeshingole",
                        "content": "this kinda does not make sense to me\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "Naveen_Singh__",
                        "content": "The lowest common ancestor will be the node from where p node and q node will situated at opposite side to each other.\\ni.e lets say p.val < q.val\\nin that case\\nif(root.val >= p.val && root.val <= q.val)return root\\n(root node will be your lowest Common Ancestor)\\n\\nif p.val > q.val\\nin that case\\nif(root.val <= p.val && root.val >= q.val)return root\\n(root node will be your lowest Common Ancestor)  "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "harshadrsharma",
                        "content": "This is an easy solution once you understand that it is a BST and that the nodes p and q are guaranteed to be present in the tree. Don\\'t understand why it\\'s tagged as a medium one."
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "What type are p and q exactly? In lowestCommonAncestor it\\'s defined as TreeNode and in the Testcases it\\'s int. Which one is the actual type?"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "[@IvanStebletsov](/IvanStebletsov) oh, the error was that output must have been a node not an int"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "TreeNode it\\'s an object, inside this object there is a property with its value named as \"val\", value is int."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum ASCII Delete Sum for Two Strings",
        "question_content": "<p>Given two strings <code>s1</code> and&nbsp;<code>s2</code>, return <em>the lowest <strong>ASCII</strong> sum of deleted characters to make two strings equal</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;sea&quot;, s2 = &quot;eat&quot;\n<strong>Output:</strong> 231\n<strong>Explanation:</strong> Deleting &quot;s&quot; from &quot;sea&quot; adds the ASCII value of &quot;s&quot; (115) to the sum.\nDeleting &quot;t&quot; from &quot;eat&quot; adds 116 to the sum.\nAt the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;delete&quot;, s2 = &quot;leet&quot;\n<strong>Output:</strong> 403\n<strong>Explanation:</strong> Deleting &quot;dee&quot; from &quot;delete&quot; to turn the string into &quot;let&quot;,\nadds 100[d] + 101[e] + 101[e] to the sum.\nDeleting &quot;e&quot; from &quot;leet&quot; adds 101[e] to the sum.\nAt the end, both strings are equal to &quot;let&quot;, and the answer is 100+101+101+101 = 403.\nIf instead we turned both strings into &quot;lee&quot; or &quot;eet&quot;, we would get answers of 433 or 417, which are higher.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 1000</code></li>\n\t<li><code>s1</code> and <code>s2</code> consist of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 642422,
                "title": "for-those-who-have-no-clue-step-by-step",
                "content": "before getting onto DP, One must master the art of recurssion\\nIn this post , WE will learn how to solve this/approach question\\'s on on Dynamic Programming Question\\n \\n**Step 1 : Understanding the problem** \\nIn this question we are given two strings , and asked to get the sum of ASCII values, to make string same,\\nRE-WORDING question : get the sum of all characters which do not form longest Common Subsequence.\\n\\n**Step 2 : Logic Building and Recurrance relation**\\n**sub step 1 : Analyzing different casses and Logic building** \\nthere can be only two cases\\n```\\ncase 1 : some ith and jth character matches in both string\\ncase 2 : it doesn\\'t matches\\n\\nso we have two casses , lets us analyze them one by one \\ncase 1 : if some ith and jth character matches then we can reduce the ASCII sum if we include both ith and jth character in sequence, so we dont add their\\'s ASCII values \\ncase 2 : ith and jth character doesn\\'t matches , so we have 2 option for these\\n\\toption 1 : skip ith character assuming jth character might be useful later on , so we add ASCII of ith and recurr for rest \\n\\toption 2 : skip jth character assuming ith matches somewhere late in string , same as option 1 for other string\\n```\\n**sub step 2 : gettign basecases and writing recurrence relation**\\nBase cases\\n```\\nif string_A or string_B is empty : then our ans is sum of all ASCII of non empty string\\nif we have finished strings : our ans is zero\\n```\\nRecurrance relation\\n```\\nif string_a[ ith ] EQUALS string_b [jth] // skip these as these will definately help in making string same , and help in reducing sum of ASCII\\n sum = get_sum_for( string_a ith+1 , string_b jth+1)\\n \\nif string_a[ ith ] NOT EQUALS string_b [jth] // then all minimum of all the three options \\noption 1 : sum = ASCII of string_a[ith] + get_sum_for( string_a ith+1, string_b jth)  // assuming jth to be useful\\noption 2 : sum = ASCII of string_b[jth] + get_sum_for( string_a ith, string_b jth +1) // assuming ith to be useful\\n\\nans = min of ( option 1 , option 2 )\\n```\\n\\n**step 3 : so now lets code pure Recurssive solution (TLE)** \\n```\\nint dead_end_sum(string &s , int i)\\n    {\\n        int sum = 0;\\n        for( ; i<s.length() ; i++)\\n            sum+=int(s[i]);\\n        return sum;\\n    }\\n    \\n    int sub(string &a, string &b, int i, int j)\\n    {\\n        int n = a.length();\\n        int m = b.length();\\n        int sum = 0;\\n        if(i==n || j==m)\\n        {\\n            if(i==n and j==m)   return 0;\\n            return (i==n) ? dead_end_sum(b,j) : dead_end_sum(a,i);   // on of the string is empty at this point , remember base case... \\n        }\\n    \\n        if(a[i] == b[j])    // 1s case , character matched\\n            sum = sub(a,b,i+1,j+1);\\n        else\\n        {   // characters didn\\'t matched ie Our\\'s second case\\n            sum = min({ sub(a,b,i+1,j) + int(a[i]) ,                // option 1\\n                        sub(a,b,i,j+1) + int(b[j]) });               // option 2\\n        }      \\n        return sum;\\n    }\\n    int minimumDeleteSum(string a, string b) {\\n        \\n        return sub(a,b,0,0);\\n        \\n        return 0;\\n    }\\n```\\n\\n**step 4 : Convert recurssion to Top-down Dymanic(ACCEPTED)** \\nso we know we are computing for same sub problems again and again, so what we can do is maintain a matrix to store answers for our subproblem , so if at any point we need to recompute it , we can avoid re-computation by using that value, ( optimizing recurssion )\\n```\\nvector<vector<int>> dp; // we will store all our answers here and then get values for all future references\\n    \\n    int dead_end_sum(string &s , int i) // one of the string id empty , so all ASCII sums from ith character till end of string\\n    {\\n        int sum = 0;\\n        for( ; i<s.length() ; i++)\\n            sum+=int(s[i]);\\n        return sum;\\n    }\\n    \\n    int sub(string &a, string &b, int i, int j) // sub problem\\n    {\\n        int n = a.length();\\n        int m = b.length();\\n        int sum = 0;\\n        if(i==n || j==m)\\n        {\\n            if(i==n and j==m)   return 0;\\n            return (i==n) ? dead_end_sum(b,j) : dead_end_sum(a,i);\\n        }\\n        \\n        if(dp[i][j] != -1)            return dp[i][j];      // we know the answer so no need to recompute , reture it as it is.\\n    \\n        if(a[i] == b[j])\\n            sum = sub(a,b,i+1,j+1);\\n        else\\n        {\\n            sum = min({ sub(a,b,i+1,j) + int(a[i]) ,                // option  1\\n                        sub(a,b,i,j+1) + int(b[j])});              // option 2\\n        }      \\n        dp[i][j] = sum;     // we store our answer at each step\\n        return sum;\\n    }\\n    int minimumDeleteSum(string a, string b) {\\n        \\n        // making of DP matrix to store result and initilizing it to -1\\n        dp = vector<vector<int>>(a.length()+1, vector<int>(b.length()+1 , -1));\\n        return sub(a,b,0,0);\\n        \\n        return 0;\\n    }\\n```\\n**step 5 : so now you know both the approaches , so try coming up with botto up DP yourself.**\\n`hint : strat from base case , go all the way to the top`\\nThis is how DP table will look like \\n![image](https://assets.leetcode.com/users/images/d69de35b-5eb8-4adf-b083-ac4120e5b4e7_1646886232.3158126.png)\\n\\n\\n```\\nint minimumDeleteSum(string a, string b) {\\n        \\n    int n = a.size();\\n    int m = b.size();\\n    vector<vector<int>> dp(n+1 , vector<int> (m+1));\\n\\n    for(int i=1 ; i<=n ; i++)                 // base case filling up\\n        dp[i][0] = dp[i-1][0] + a[i-1];\\n\\n    for(int j=1; j<=m ; j++)                 // base case filling up\\n        dp[0][j] = dp[0][j-1] + b[j-1];\\n\\n    for(int i=1 ; i<=n ; i++)\\n    {\\n        for(int j=1 ; j<=m ; j++)\\n        {\\n            if(a[i-1] == b[j-1])\\n                dp[i][j] = dp[i-1][j-1];\\n            else\\n                dp[i][j] = min( dp[i-1][j] + a[i-1] ,\\n                                dp[i][j-1] + b[j-1] );\\n        }\\n    }\\n    return dp[n][m];\\n    }\\n```\\n\\n**thanks for reading**\\n**previous tutorial on DP**  \\nhttps://leetcode.com/problems/minimum-cost-for-tickets/discuss/630868/explanation-from-someone-who-took-2-hours-to-solve\\nhttps://leetcode.com/problems/dungeon-game/discuss/745340/post-Dedicated-to-beginners-of-DP",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\ncase 1 : some ith and jth character matches in both string\\ncase 2 : it doesn\\'t matches\\n\\nso we have two casses , lets us analyze them one by one \\ncase 1 : if some ith and jth character matches then we can reduce the ASCII sum if we include both ith and jth character in sequence, so we dont add their\\'s ASCII values \\ncase 2 : ith and jth character doesn\\'t matches , so we have 2 option for these\\n\\toption 1 : skip ith character assuming jth character might be useful later on , so we add ASCII of ith and recurr for rest \\n\\toption 2 : skip jth character assuming ith matches somewhere late in string , same as option 1 for other string\\n```\n```\\nif string_A or string_B is empty : then our ans is sum of all ASCII of non empty string\\nif we have finished strings : our ans is zero\\n```\n```\\nif string_a[ ith ] EQUALS string_b [jth] // skip these as these will definately help in making string same , and help in reducing sum of ASCII\\n sum = get_sum_for( string_a ith+1 , string_b jth+1)\\n \\nif string_a[ ith ] NOT EQUALS string_b [jth] // then all minimum of all the three options \\noption 1 : sum = ASCII of string_a[ith] + get_sum_for( string_a ith+1, string_b jth)  // assuming jth to be useful\\noption 2 : sum = ASCII of string_b[jth] + get_sum_for( string_a ith, string_b jth +1) // assuming ith to be useful\\n\\nans = min of ( option 1 , option 2 )\\n```\n```\\nint dead_end_sum(string &s , int i)\\n    {\\n        int sum = 0;\\n        for( ; i<s.length() ; i++)\\n            sum+=int(s[i]);\\n        return sum;\\n    }\\n    \\n    int sub(string &a, string &b, int i, int j)\\n    {\\n        int n = a.length();\\n        int m = b.length();\\n        int sum = 0;\\n        if(i==n || j==m)\\n        {\\n            if(i==n and j==m)   return 0;\\n            return (i==n) ? dead_end_sum(b,j) : dead_end_sum(a,i);   // on of the string is empty at this point , remember base case... \\n        }\\n    \\n        if(a[i] == b[j])    // 1s case , character matched\\n            sum = sub(a,b,i+1,j+1);\\n        else\\n        {   // characters didn\\'t matched ie Our\\'s second case\\n            sum = min({ sub(a,b,i+1,j) + int(a[i]) ,                // option 1\\n                        sub(a,b,i,j+1) + int(b[j]) });               // option 2\\n        }      \\n        return sum;\\n    }\\n    int minimumDeleteSum(string a, string b) {\\n        \\n        return sub(a,b,0,0);\\n        \\n        return 0;\\n    }\\n```\n```\\nvector<vector<int>> dp; // we will store all our answers here and then get values for all future references\\n    \\n    int dead_end_sum(string &s , int i) // one of the string id empty , so all ASCII sums from ith character till end of string\\n    {\\n        int sum = 0;\\n        for( ; i<s.length() ; i++)\\n            sum+=int(s[i]);\\n        return sum;\\n    }\\n    \\n    int sub(string &a, string &b, int i, int j) // sub problem\\n    {\\n        int n = a.length();\\n        int m = b.length();\\n        int sum = 0;\\n        if(i==n || j==m)\\n        {\\n            if(i==n and j==m)   return 0;\\n            return (i==n) ? dead_end_sum(b,j) : dead_end_sum(a,i);\\n        }\\n        \\n        if(dp[i][j] != -1)            return dp[i][j];      // we know the answer so no need to recompute , reture it as it is.\\n    \\n        if(a[i] == b[j])\\n            sum = sub(a,b,i+1,j+1);\\n        else\\n        {\\n            sum = min({ sub(a,b,i+1,j) + int(a[i]) ,                // option  1\\n                        sub(a,b,i,j+1) + int(b[j])});              // option 2\\n        }      \\n        dp[i][j] = sum;     // we store our answer at each step\\n        return sum;\\n    }\\n    int minimumDeleteSum(string a, string b) {\\n        \\n        // making of DP matrix to store result and initilizing it to -1\\n        dp = vector<vector<int>>(a.length()+1, vector<int>(b.length()+1 , -1));\\n        return sub(a,b,0,0);\\n        \\n        return 0;\\n    }\\n```\n```\\nint minimumDeleteSum(string a, string b) {\\n        \\n    int n = a.size();\\n    int m = b.size();\\n    vector<vector<int>> dp(n+1 , vector<int> (m+1));\\n\\n    for(int i=1 ; i<=n ; i++)                 // base case filling up\\n        dp[i][0] = dp[i-1][0] + a[i-1];\\n\\n    for(int j=1; j<=m ; j++)                 // base case filling up\\n        dp[0][j] = dp[0][j-1] + b[j-1];\\n\\n    for(int i=1 ; i<=n ; i++)\\n    {\\n        for(int j=1 ; j<=m ; j++)\\n        {\\n            if(a[i-1] == b[j-1])\\n                dp[i][j] = dp[i-1][j-1];\\n            else\\n                dp[i][j] = min( dp[i-1][j] + a[i-1] ,\\n                                dp[i][j-1] + b[j-1] );\\n        }\\n    }\\n    return dp[n][m];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 108828,
                "title": "c-dp-with-explanation",
                "content": "This is clearly a DP problem.  \\n```\\ndp[i][j] is the cost for s1.substr(0,i) and s2.substr(0, j). Note s1[i], s2[j] not included in the substring.\\n\\nBase case: dp[0][0] = 0\\ntarget: dp[m][n]\\n\\nif s1[i-1] = s2[j-1]   // no deletion\\n    dp[i][j] = dp[i-1][j-1];\\nelse   // delete either s1[i-1] or s2[j-1]\\n    dp[i][j] = min(dp[i-1][j]+s1[i-1], dp[i][j-1]+s2[j-1]);\\n``` \\nWe can use a 2D vector, or an optimized O(n) extra space. See below. The run time is O(mn).\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        for (int j = 1; j <= n; j++)\\n            dp[0][j] = dp[0][j-1]+s2[j-1];\\n        for (int i = 1; i <= m; i++) {\\n            dp[i][0] = dp[i-1][0]+s1[i-1];\\n            for (int j = 1; j <= n; j++) {\\n                if (s1[i-1] == s2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else \\n                    dp[i][j] = min(dp[i-1][j]+s1[i-1], dp[i][j-1]+s2[j-1]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\nOptimized O(n) extra space\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<int> dp(n+1, 0);\\n        for (int j = 1; j <= n; j++)\\n            dp[j] = dp[j-1]+s2[j-1];\\n        for (int i = 1; i <= m; i++) {\\n            int t1 = dp[0];\\n            dp[0] += s1[i-1];\\n            for (int j = 1; j <= n; j++) {\\n                int t2 = dp[j];\\n                dp[j] = s1[i-1] == s2[j-1]? t1:min(dp[j]+s1[i-1], dp[j-1]+s2[j-1]);\\n                t1 = t2;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i][j] is the cost for s1.substr(0,i) and s2.substr(0, j). Note s1[i], s2[j] not included in the substring.\\n\\nBase case: dp[0][0] = 0\\ntarget: dp[m][n]\\n\\nif s1[i-1] = s2[j-1]   // no deletion\\n    dp[i][j] = dp[i-1][j-1];\\nelse   // delete either s1[i-1] or s2[j-1]\\n    dp[i][j] = min(dp[i-1][j]+s1[i-1], dp[i][j-1]+s2[j-1]);\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        for (int j = 1; j <= n; j++)\\n            dp[0][j] = dp[0][j-1]+s2[j-1];\\n        for (int i = 1; i <= m; i++) {\\n            dp[i][0] = dp[i-1][0]+s1[i-1];\\n            for (int j = 1; j <= n; j++) {\\n                if (s1[i-1] == s2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else \\n                    dp[i][j] = min(dp[i-1][j]+s1[i-1], dp[i][j-1]+s2[j-1]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<int> dp(n+1, 0);\\n        for (int j = 1; j <= n; j++)\\n            dp[j] = dp[j-1]+s2[j-1];\\n        for (int i = 1; i <= m; i++) {\\n            int t1 = dp[0];\\n            dp[0] += s1[i-1];\\n            for (int j = 1; j <= n; j++) {\\n                int t2 = dp[j];\\n                dp[j] = s1[i-1] == s2[j-1]? t1:min(dp[j]+s1[i-1], dp[j-1]+s2[j-1]);\\n                t1 = t2;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108811,
                "title": "java-dp-with-explanation",
                "content": "Very Similar to Longest Common Subsequence Problem.\\n\\nLet, s1 & s2 be the two strings with 1 based indexes.\\nNow assume, dp[i][j] = minimumDeleteSum( s1[0,i], s2[0,j])\\n\\n**Base case**:\\nWhen either of the strings is empty, then whole of the other string has to be deleted.\\nfor e.g. if s1 = \"\", s2 = \"abc\", then only way we could match these strings by deleting characters is by dropping 'a','b','c' of s2 to make it empty like s1.\\n\\nThus, whenever one of them is empty(i.e. i==0 or j==0) then answer is sum of ASCII code of the characters of the other string.\\n\\nHence the ***1st*** rule: **dp[i][j] =** \\n\\n* **sum_ascii(s2) -> if i==0**\\n* **sum_ascii(s1) -> if j==0**\\n\\n**Non-Base case**\\n\\nOf the two strings, if both of their last characters match then certainly the answer comes from skipping those characters. \\ni.e. Answer(\"zca\",\"bza\") = Answer(\"zc\",\"bz\")\\n\\nHence the ***2nd*** rule: **dp[i][j] =** \\n\\n* **dp[i-1][j-1] -> if s1[i]==s2[j]**\\n\\nFinally, if the last characters are different then its one of the three situations:\\n\\n* drop s1's last character (ASCII(s1's last) + dp[i-1][j])\\n* drop s2's last character (ASCII(s2's last) + dp[i][j-1])\\n* drop both last characters (ASCII(s1's last) + ASCII(s2's last) + dp[i-1[[j-1])\\n\\nHence the ***3rd*** rule: **dp[i][j] =** \\n\\n* **Min((ASCII(s1's last) + dp[i-1][j]),(ASCII(s2's last) + dp[i][j-1]),(ASCII(s1's last) + ASCII(s2's last) + dp[i-1[[j-1]))**\\n\\nCombining these 3 rules gives us an elegant solution.\\n```\\npublic int minimumDeleteSum(String s1, String s2) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        int[][] dp = new int[m+1][n+1];\\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0 || j==0){\\n                    int a = 0;\\n                    for(int z=1;z<=Math.max(j,i);z++){\\n                        a += (i==0?s2.charAt(z-1):s1.charAt(z-1));\\n                    }\\n                    dp[i][j] = a;\\n                }\\n                else if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j] = Math.min(s1.charAt(i-1)+dp[i-1][j],s2.charAt(j-1)+dp[i][j-1]);\\n                    dp[i][j] = Math.min(dp[i][j],s1.charAt(i-1)+s2.charAt(j-1)+dp[i-1][j-1]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minimumDeleteSum(String s1, String s2) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        int[][] dp = new int[m+1][n+1];\\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0 || j==0){\\n                    int a = 0;\\n                    for(int z=1;z<=Math.max(j,i);z++){\\n                        a += (i==0?s2.charAt(z-1):s1.charAt(z-1));\\n                    }\\n                    dp[i][j] = a;\\n                }\\n                else if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j] = Math.min(s1.charAt(i-1)+dp[i-1][j],s2.charAt(j-1)+dp[i][j-1]);\\n                    dp[i][j] = Math.min(dp[i][j],s1.charAt(i-1)+s2.charAt(j-1)+dp[i-1][j-1]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 108810,
                "title": "concise-dp-solution",
                "content": "The same idea as edit distance. Straightforward 19 lines.\\n\\n```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int[][] count = new int[s1.length() + 1][s2.length() + 1];\\n        for(int i = 1; i < count.length; i++){\\n            count[i][0] = count[i-1][0] + s1.charAt(i-1);\\n        }\\n        for(int i = 1; i < count[0].length; i++){\\n            count[0][i] = count[0][i-1] + s2.charAt(i-1);\\n        }\\n        for(int i = 1; i < count.length; i++){\\n            for(int j = 1; j < count[0].length; j++){\\n                int cost = (s1.charAt(i-1) == s2.charAt(j-1))? 0 : s1.charAt(i-1) + s2.charAt(j-1);\\n                count[i][j] = Math.min(count[i-1][j] + s1.charAt(i-1), count[i][j-1] + s2.charAt(j-1));\\n                count[i][j] = Math.min(count[i][j], count[i-1][j-1] + cost);\\n            }\\n        }\\n        return count[s1.length()][s2.length()];   \\n    }\\n}\\n``",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int[][] count = new int[s1.length() + 1][s2.length() + 1];\\n        for(int i = 1; i < count.length; i++){\\n            count[i][0] = count[i-1][0] + s1.charAt(i-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 108807,
                "title": "elegant-python-solution-using-dp",
                "content": "```\\n    def minimumDeleteSum(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: int\\n        \"\"\"\\n        l1, l2 = len(s1), len(s2)\\n        dp = [[0] * (l2 + 1) for _ in range(l1 + 1)]\\n        for i in range(l1):\\n            for j in range(l2):\\n                if s1[i] == s2[j]:\\n                    dp[i + 1][j + 1] = dp[i][j] + ord(s1[i])\\n                else:\\n                    dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j])\\n        result = sum(map(ord, s1 + s2)) - dp[l1][l2] * 2\\n        return result",
                "solutionTags": [],
                "code": "```\\n    def minimumDeleteSum(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: int\\n        \"\"\"\\n        l1, l2 = len(s1), len(s2)\\n        dp = [[0] * (l2 + 1) for _ in range(l1 + 1)]\\n        for i in range(l1):\\n            for j in range(l2):\\n                if s1[i] == s2[j]:\\n                    dp[i + 1][j + 1] = dp[i][j] + ord(s1[i])\\n                else:\\n                    dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j])\\n        result = sum(map(ord, s1 + s2)) - dp[l1][l2] * 2\\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 1303128,
                "title": "dp-approach-easy-explanation-with-diagram",
                "content": "Here we will use dynamic programming tabluation method to solve this problem.\\n\\nWe will create a 2D matrix with n+1 and m+1 size and will initialize first row and first column using s1 and s2.\\nSo this 0th row/column repesents an empty string(\"\"), let\\'s take an example.\\n\\ncase 1:\\ns1=\"\" and s2=\"e\", then we just have to delete e to make both string equal, so our result will be 101.\\ncase 2:\\ns1=\"\" and s2=\"ea\", then we\\'ll have to delete both \"e\" and \"a\" , so our result will be 101+97 => 198.\\nand in the similar way,\\nif s1=\"s\" and s2=\"\", then we will have to delete \"s\", so our output will be 115.\\n\\n\\n![image](https://assets.leetcode.com/users/images/653bfa8b-6f9f-4cf6-9abe-787fad82b636_1624896081.843548.png)\\n```\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        int[][] dp = new int[m+1][n+1];\\n\\t\\t//initialize first column with s1 values\\n        for(int i=1; i<=m; i++){\\n            dp[i][0] = dp[i-1][0] + s1.charAt(i-1);\\n        }\\n\\t\\t//initialize first row with s2 values\\n        for(int i=1; i<=n; i++){\\n            dp[0][i] = dp[0][i-1] + s2.charAt(i-1);\\n        }\\n        for(int i=1; i<=m; i++){\\n            for(int j=1; j<=n; j++){\\n\\t\\t\\t\\t// if both characters are equal then use previous diagonal value\\n                if(s1.charAt(i-1) == s2.charAt(j-1)){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = Math.min(\\n                        dp[i-1][j] + s1.charAt(i-1),\\n                        dp[i][j-1] + s2.charAt(j-1)\\n                    );\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        int[][] dp = new int[m+1][n+1];\\n\\t\\t//initialize first column with s1 values\\n        for(int i=1; i<=m; i++){\\n            dp[i][0] = dp[i-1][0] + s1.charAt(i-1);\\n        }\\n\\t\\t//initialize first row with s2 values\\n        for(int i=1; i<=n; i++){\\n            dp[0][i] = dp[0][i-1] + s2.charAt(i-1);\\n        }\\n        for(int i=1; i<=m; i++){\\n            for(int j=1; j<=n; j++){\\n\\t\\t\\t\\t// if both characters are equal then use previous diagonal value\\n                if(s1.charAt(i-1) == s2.charAt(j-1)){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = Math.min(\\n                        dp[i-1][j] + s1.charAt(i-1),\\n                        dp[i][j-1] + s2.charAt(j-1)\\n                    );\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1490438,
                "title": "python-dp-find-lcs-based-on-sum-ascii-as-score-clean-concise",
                "content": "**Idea**\\n- Same idea with classic problem **[1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)**.\\n- In this case, we define **Longest** Common Subsequence as **Maximum Ascii Sum** Common Subsequence between string `s1` and `s2`. \\n- Then the lowest ASCII sum of deleted characters = total ascii sum - Maximum Ascii Sum Common Subsequence * 2.\\n```python\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if s1[i - 1] == s2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1] + ord(s1[i - 1])  # Use ascii value as score\\n                else:\\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\\n\\n        totalAscii = 0\\n        for c in s1:\\n            totalAscii += ord(c)\\n        for c in s2:\\n            totalAscii += ord(c)\\n\\n        return totalAscii - dp[m][n] * 2\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 1000` is the length of string `s1`, `N <= 1000` is the length of string `s2`.\\n- Space: `O(M*N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if s1[i - 1] == s2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1] + ord(s1[i - 1])  # Use ascii value as score\\n                else:\\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\\n\\n        totalAscii = 0\\n        for c in s1:\\n            totalAscii += ord(c)\\n        for c in s2:\\n            totalAscii += ord(c)\\n\\n        return totalAscii - dp[m][n] * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840821,
                "title": "dp-very-easy-to-understand-video-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nExplore options take and not take according to the conditions.\\n\\nFor detailed explanation you can refer to my youtube channel (hindi Language)\\nhttps://youtu.be/BahZtrW6QTs\\n or link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. The solution utilizes dynamic programming to find the minimum ASCII delete sum of `s1` and `s2`. A 2D DP array `dp` is used to store the minimum delete sum for subproblems.\\n\\n2. The recursive function `solve` is defined, which takes four parameters: `i` and `j` are the current indices for `s1` and `s2`, respectively, and `s1` and `s2` are the input strings.\\n\\n3. In the `solve` function, the following steps are followed:\\n\\n   a. Check if the value for the current state `(i, j)` is already computed and stored in the `dp` array. If yes, return the value to avoid recomputation.\\n\\n   b. If `i` reaches the end of `s1`, it means all characters of `s1` have been processed. In this case, sum the ASCII values of the remaining characters in `s2` (from index `j` to the end) and return the sum. These characters need to be deleted to make `s1` and `s2` equal.\\n\\n   c. If `j` reaches the end of `s2`, it means all characters of `s2` have been processed. Similar to the previous case, sum the ASCII values of the remaining characters in `s1` (from index `i` to the end) and return the sum.\\n\\n   d. If neither `i` nor `j` has reached the end of their respective strings, then two options are possible:\\n\\n      - Calculate the sum of the ASCII value of the current character of `s1` with the minimum delete sum of the remaining characters of `s1` and `s2` (by calling the `solve` function recursively with `i+1` and `j`).\\n\\n      - Calculate the sum of the ASCII value of the current character of `s2` with the minimum delete sum of the remaining characters of `s1` and `s2` (by calling the `solve` function recursively with `i` and `j+1`).\\n\\n      - If the current characters of `s1` and `s2` are equal, an additional option is available:\\n\\n        - Calculate the minimum delete sum of the remaining characters of `s1` and `s2` (by calling the `solve` function recursively with `i+1` and `j+1`) without including the current characters in the sum since they are already equal.\\n\\n      e. Return the minimum of the above three options as the minimum delete sum for the current state `(i, j)` and store it in the `dp` array for future reference.\\n\\n# Complexity\\n- Time complexity:$$O(n1*n2)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n1*n2)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\nint dp[1002][1002];\\nint solve(string &s1,string &s2,int i,int j){\\n    if(dp[i][j]!=-1)\\n    return dp[i][j];\\n    if(i==s1.size()){\\n        int sum=0;\\n        for(int k=j;k<s2.size();k++){\\n         sum=sum+(int)s2[k];\\n        }\\n        return sum;\\n    }\\n    if(j==s2.size()){\\n        int sum=0;\\n        for(int k=i;k<s1.size();k++){\\n         sum=sum+(int)s1[k];\\n        }\\n        return sum;\\n    }\\n    int mx=1e9;\\n     int nt=min(s1[i]+solve(s1,s2,i+1,j),s2[j]+solve(s1,s2,i,j+1));\\n     int tk=1e9;\\n     if(s1[i]==s2[j]){\\n       tk=solve(s1,s2,i+1,j+1);\\n     }\\n     return dp[i][j]=min(nt,tk);\\n}\\n    int minimumDeleteSum(string s1, string s2) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s1,s2,0,0);\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    int[][] dp;\\n\\n    public int minimumDeleteSum(String s1, String s2) {\\n        dp = new int[s1.length() + 1][s2.length() + 1];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        return solve(s1, s2, 0, 0);\\n    }\\n\\n    private int solve(String s1, String s2, int i, int j) {\\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        if (i == s1.length()) {\\n            int sum = 0;\\n            for (int k = j; k < s2.length(); k++) {\\n                sum += s2.charAt(k);\\n            }\\n            return sum;\\n        }\\n        if (j == s2.length()) {\\n            int sum = 0;\\n            for (int k = i; k < s1.length(); k++) {\\n                sum += s1.charAt(k);\\n            }\\n            return sum;\\n        }\\n        int nt = Math.min(s1.charAt(i) + solve(s1, s2, i + 1, j), s2.charAt(j) + solve(s1, s2, i, j + 1));\\n        int tk = Integer.MAX_VALUE;\\n        if (s1.charAt(i) == s2.charAt(j)) {\\n            tk = solve(s1, s2, i + 1, j + 1);\\n        }\\n        return dp[i][j] = Math.min(nt, tk);\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        dp = [[-1] * (len(s2) + 1) for _ in range(len(s1) + 1)]\\n        return self.solve(s1, s2, 0, 0, dp)\\n\\n    def solve(self, s1: str, s2: str, i: int, j: int, dp: list[list[int]]) -> int:\\n        if dp[i][j] != -1:\\n            return dp[i][j]\\n        if i == len(s1):\\n            return sum(ord(ch) for ch in s2[j:])\\n        if j == len(s2):\\n            return sum(ord(ch) for ch in s1[i:])\\n        nt = min(ord(s1[i]) + self.solve(s1, s2, i + 1, j, dp), ord(s2[j]) + self.solve(s1, s2, i, j + 1, dp))\\n        tk = float(\\'inf\\')\\n        if s1[i] == s2[j]:\\n            tk = self.solve(s1, s2, i + 1, j + 1, dp)\\n        dp[i][j] = min(nt, tk)\\n        return dp[i][j]\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\nint dp[1002][1002];\\nint solve(string &s1,string &s2,int i,int j){\\n    if(dp[i][j]!=-1)\\n    return dp[i][j];\\n    if(i==s1.size()){\\n        int sum=0;\\n        for(int k=j;k<s2.size();k++){\\n         sum=sum+(int)s2[k];\\n        }\\n        return sum;\\n    }\\n    if(j==s2.size()){\\n        int sum=0;\\n        for(int k=i;k<s1.size();k++){\\n         sum=sum+(int)s1[k];\\n        }\\n        return sum;\\n    }\\n    int mx=1e9;\\n     int nt=min(s1[i]+solve(s1,s2,i+1,j),s2[j]+solve(s1,s2,i,j+1));\\n     int tk=1e9;\\n     if(s1[i]==s2[j]){\\n       tk=solve(s1,s2,i+1,j+1);\\n     }\\n     return dp[i][j]=min(nt,tk);\\n}\\n    int minimumDeleteSum(string s1, string s2) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s1,s2,0,0);\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    int[][] dp;\\n\\n    public int minimumDeleteSum(String s1, String s2) {\\n        dp = new int[s1.length() + 1][s2.length() + 1];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        return solve(s1, s2, 0, 0);\\n    }\\n\\n    private int solve(String s1, String s2, int i, int j) {\\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        if (i == s1.length()) {\\n            int sum = 0;\\n            for (int k = j; k < s2.length(); k++) {\\n                sum += s2.charAt(k);\\n            }\\n            return sum;\\n        }\\n        if (j == s2.length()) {\\n            int sum = 0;\\n            for (int k = i; k < s1.length(); k++) {\\n                sum += s1.charAt(k);\\n            }\\n            return sum;\\n        }\\n        int nt = Math.min(s1.charAt(i) + solve(s1, s2, i + 1, j), s2.charAt(j) + solve(s1, s2, i, j + 1));\\n        int tk = Integer.MAX_VALUE;\\n        if (s1.charAt(i) == s2.charAt(j)) {\\n            tk = solve(s1, s2, i + 1, j + 1);\\n        }\\n        return dp[i][j] = Math.min(nt, tk);\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        dp = [[-1] * (len(s2) + 1) for _ in range(len(s1) + 1)]\\n        return self.solve(s1, s2, 0, 0, dp)\\n\\n    def solve(self, s1: str, s2: str, i: int, j: int, dp: list[list[int]]) -> int:\\n        if dp[i][j] != -1:\\n            return dp[i][j]\\n        if i == len(s1):\\n            return sum(ord(ch) for ch in s2[j:])\\n        if j == len(s2):\\n            return sum(ord(ch) for ch in s1[i:])\\n        nt = min(ord(s1[i]) + self.solve(s1, s2, i + 1, j, dp), ord(s2[j]) + self.solve(s1, s2, i, j + 1, dp))\\n        tk = float(\\'inf\\')\\n        if s1[i] == s2[j]:\\n            tk = self.solve(s1, s2, i + 1, j + 1, dp)\\n        dp[i][j] = min(nt, tk)\\n        return dp[i][j]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840553,
                "title": "100-dp-video-decoding-approach-to-minimum-ascii-delete-sum",
                "content": "# Intuition\\nThe problem is asking us to make two strings equal by deleting characters, while also minimizing the sum of the ASCII values of the deleted characters. This immediately brings to mind dynamic programming, as we can leverage the overlapping subproblems inherent in this task - that is, making smaller substrings equal and expanding upon that. \\n\\nhttps://youtu.be/OT6zcEATv1c\\n\\n# Approach\\n\\nTo solve this problem, we use a dynamic programming approach. In dynamic programming, we break down a complex problem into simpler sub-problems and solve them, often iteratively. Our solutions to these sub-problems then feed into the solution for our overall problem. Here are the step by step details of our approach for this problem:\\n\\n1. **Initialization and Swap**: If the length of `s1` is greater than the length of `s2`, we swap `s1` and `s2`. This ensures we use less space in our solution. After ensuring `s1` is the shorter string, we initialize an array `prev_row` of length equal to the length of `s2` plus one. Each entry in this array, indexed by `j`, holds the cumulative ASCII sum of the first `j` characters of `s2`. This essentially means that if we were to make `s1` empty by deleting all its characters, the minimum ASCII sum of deleted characters to make `s1` and the first `j` characters of `s2` equal would be the ASCII sum of those `j` characters. We are effectively considering all possible substrings of `s2` paired with an empty string.\\n\\n2. **Iteration through `s1`**: We then iterate over each character of `s1`, indexed by `i`. For each `i`, we generate a new array `curr_row`. The first entry of `curr_row` is the cumulative ASCII sum of the first `i` characters of `s1` plus the last entry in `prev_row`. This effectively considers the case where we make `s2` empty by deleting all its characters. In that case, the minimum ASCII sum of deleted characters to make the first `i` characters of `s1` and `s2` equal would be the ASCII sum of those `i` characters.\\n\\n3. **Iteration within `s1` through `s2`**: Within this iteration through `s1`, we iterate through each character of `s2`, indexed by `j`. For each `j`, we compare the `i`-th character of `s1` and the `j`-th character of `s2`.\\n\\n    - If they are equal, we append the value of `prev_row[j - 1]` to `curr_row`. This is because we don\\'t need to delete any characters in this case, so the minimum ASCII sum of deleted characters to make the first `i` characters of `s1` and the first `j` characters of `s2` equal would be the same as that to make the first `i - 1` characters of `s1` and the first `j - 1` characters of `s2` equal.\\n    \\n    - If they are not equal, we calculate two quantities: `prev_row[j]` + the ASCII value of `s1[i - 1]`, and `curr_row[j - 1]` + the ASCII value of `s2[j - 1]`. The former represents the minimum ASCII sum if we delete the `i`-th character of `s1`, while the latter represents the minimum ASCII sum if we delete the `j`-th character of `s2`. We append the minimum of these two quantities to `curr_row`.\\n\\n4. **Completion of an iteration of `s1`**: After we have gone through all characters of `s2` for the current `i`, we set `prev_row` to `curr_row`, effectively storing our results for the current `i` and preparing to move to the next `i`.\\n\\n5. **Final Result**: After we have iterated through all characters of `s1`, `prev_row` will have been updated to hold the minimum ASCII sums for all possible substring pairings of `s1` and `s2`. The last entry in `prev_row` represents the minimum ASCII sum of deleted characters to make `s1` and `s2` equal, which is the final result we return.\\n\\nThe transitions of the dynamic programming table `prev_row` / `curr_row` essentially represent our evolving solutions to the sub-problems of making the first `i` characters of `s1` and the first `j` characters of `s2` equal. As we expand `i` and `j` to cover all possible substring pairings, we eventually obtain our solution for the overall problem.\\n\\n# Complexity\\n- Time complexity: O(n*m), where `n` and `m` are the lengths of `s1` and `s2`, respectively. This is because we need to iterate through all possible pairs of substrings from `s1` and `s2`.\\n\\n- Space complexity: O(m), where `m` is the length of `s2`. This is because we only need to store the current and the previous rows of the dynamic programming table at any given time, not the entire table.\\n\\nThis solution iterates through each possible substring pairing, and calculates the minimum ASCII sum for each pair. By only storing the current and previous rows, it efficiently uses space while still providing the correct result.\\n\\n# Code\\n``` Python []\\n#\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        if len(s1) > len(s2):\\n            s1, s2 = s2, s1\\n        prev_row = [0] * (len(s2) + 1) \\n        for j in range(1, len(s2) + 1): \\n            prev_row[j] = prev_row[j - 1] + ord(s2[j - 1]) \\n\\n        for i in range(1, len(s1) + 1): \\n            curr_row = [prev_row[0] + ord(s1[i - 1])] \\n            for j in range(1, len(s2) + 1): \\n                if s1[i - 1] == s2[j - 1]: \\n                    curr_row.append(prev_row[j - 1]) \\n                else: \\n                    curr_row.append(min(prev_row[j] + ord(s1[i - 1]), curr_row[j - 1] + ord(s2[j - 1]))) \\n            prev_row = curr_row \\n\\n        return prev_row[-1] \\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        vector<vector<int>> dp(s1.size() + 1, vector<int>(s2.size() + 1, 0));\\n\\n        for (int i = 1; i <= s1.size(); i++)\\n            dp[i][0] = dp[i - 1][0] + s1[i - 1];\\n\\n        for (int j = 1; j <= s2.size(); j++)\\n            dp[0][j] = dp[0][j - 1] + s2[j - 1];\\n\\n        for (int i = 1; i <= s1.size(); i++) {\\n            for (int j = 1; j <= s2.size(); j++) {\\n                if (s1[i - 1] == s2[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[s1.size()][s2.size()];\\n    }\\n};\\n```\\n``` JavaScript []\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @return {number}\\n */\\nvar minimumDeleteSum = function(s1, s2) {\\n    let prev_row = new Array(s2.length + 1).fill(0);\\n        for (let j = 1; j <= s2.length; j++)\\n            prev_row[j] = prev_row[j - 1] + s2.charCodeAt(j - 1);\\n        \\n        for (let i = 1; i <= s1.length; i++) {\\n            let curr_row = [prev_row[0] + s1.charCodeAt(i - 1)];\\n            for (let j = 1; j <= s2.length; j++) {\\n                if (s1[i - 1] === s2[j - 1])\\n                    curr_row.push(prev_row[j - 1]);\\n                else\\n                    curr_row.push(Math.min(prev_row[j] + s1.charCodeAt(i - 1), curr_row[curr_row.length - 1] + s2.charCodeAt(j - 1)));\\n            }\\n            prev_row = curr_row;\\n        }\\n        \\n        return prev_row[prev_row.length - 1];\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n\\n        for (int i = 1; i <= s1.length(); i++)\\n            dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1);\\n        \\n        for (int j = 1; j <= s2.length(); j++)\\n            dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1);\\n        \\n        for (int i = 1; i <= s1.length(); i++) {\\n            for (int j = 1; j <= s2.length(); j++) {\\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i - 1][j] + s1.charAt(i - 1), dp[i][j - 1] + s2.charAt(j - 1));\\n                }\\n            }\\n        }\\n        \\n        return dp[s1.length()][s2.length()];\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public int MinimumDeleteSum(string s1, string s2) {\\n        int[,] dp = new int[s1.Length + 1, s2.Length + 1];\\n\\n        for (int i = 1; i <= s1.Length; i++)\\n            dp[i, 0] = dp[i - 1, 0] + s1[i - 1];\\n\\n        for (int j = 1; j <= s2.Length; j++)\\n            dp[0, j] = dp[0, j - 1] + s2[j - 1];\\n        \\n        for (int i = 1; i <= s1.Length; i++) {\\n            for (int j = 1; j <= s2.Length; j++) {\\n                if (s1[i - 1] == s2[j - 1]) {\\n                    dp[i, j] = dp[i - 1, j - 1];\\n                } else {\\n                    dp[i, j] = Math.Min(dp[i - 1, j] + s1[i - 1], dp[i, j - 1] + s2[j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[s1.Length, s2.Length];\\n    }\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn minimum_delete_sum(s1: String, s2: String) -> i32 {\\n        let mut prev_row = vec![0; s2.len() + 1];\\n        let s1 = s1.chars().collect::<Vec<_>>();\\n        let s2 = s2.chars().collect::<Vec<_>>();\\n\\n        for j in 1..=s2.len() {\\n            prev_row[j] = prev_row[j - 1] + s2[j - 1] as i32;\\n        }\\n\\n        for i in 1..=s1.len() {\\n            let mut curr_row = vec![prev_row[0] + s1[i - 1] as i32];\\n            for j in 1..=s2.len() {\\n                if s1[i - 1] == s2[j - 1] {\\n                    curr_row.push(prev_row[j - 1]);\\n                } else {\\n                    curr_row.push(std::cmp::min(prev_row[j] + s1[i - 1] as i32, curr_row[j - 1] + s2[j - 1] as i32));\\n                }\\n            }\\n            prev_row = curr_row;\\n        }\\n\\n        *prev_row.last().unwrap()\\n    }\\n}\\n```\\n\\n# Performance\\n\\nHere\\'s the table sorted by Runtime in ascending order:\\n\\n| Language  | Runtime | Beats (Runtime) | Memory | Beats (Memory) |\\n|-----------|---------|-----------------|--------|----------------|\\n| Rust      | 6 ms    | 80%             | 2.1 MB | 86.67%         |\\n| Java      | 23 ms   | 84.93%          | 44.3 MB| 48.12%         |\\n| C++       | 38 ms   | 79.40%          | 15.3 MB| 41.16%         |\\n| C#        | 71 ms   | 90.63%          | 39.9 MB| 62.50%         |\\n| JavaScript| 88 ms   | 96.51%          | 49.5 MB| 60.46%         |\\n| Python3   | 440 ms  | 95.34%          | 16.5 MB| 91.25%         |\\n\\n\\nThis table provides a summary of the performance metrics (runtime and memory usage) for each programming language for the given LeetCode problem, sorted by runtime in ascending order (from fastest to slowest). The \"Beats\" columns indicate the percentage of other LeetCode users\\' submissions that the corresponding solution outperforms in terms of runtime or memory usage.\\n\\n# Video for JavaScript:\\nhttps://youtu.be/BSFWVKT-UNI\\n\\nI hope this step-by-step guide aids you in understanding this problem and the thought process behind its solution. I am eager to hear any questions, suggestions, or comments you might have!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "``` Python []\\n#\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        if len(s1) > len(s2):\\n            s1, s2 = s2, s1\\n        prev_row = [0] * (len(s2) + 1) \\n        for j in range(1, len(s2) + 1): \\n            prev_row[j] = prev_row[j - 1] + ord(s2[j - 1]) \\n\\n        for i in range(1, len(s1) + 1): \\n            curr_row = [prev_row[0] + ord(s1[i - 1])] \\n            for j in range(1, len(s2) + 1): \\n                if s1[i - 1] == s2[j - 1]: \\n                    curr_row.append(prev_row[j - 1]) \\n                else: \\n                    curr_row.append(min(prev_row[j] + ord(s1[i - 1]), curr_row[j - 1] + ord(s2[j - 1]))) \\n            prev_row = curr_row \\n\\n        return prev_row[-1] \\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        vector<vector<int>> dp(s1.size() + 1, vector<int>(s2.size() + 1, 0));\\n\\n        for (int i = 1; i <= s1.size(); i++)\\n            dp[i][0] = dp[i - 1][0] + s1[i - 1];\\n\\n        for (int j = 1; j <= s2.size(); j++)\\n            dp[0][j] = dp[0][j - 1] + s2[j - 1];\\n\\n        for (int i = 1; i <= s1.size(); i++) {\\n            for (int j = 1; j <= s2.size(); j++) {\\n                if (s1[i - 1] == s2[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[s1.size()][s2.size()];\\n    }\\n};\\n```\n``` JavaScript []\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @return {number}\\n */\\nvar minimumDeleteSum = function(s1, s2) {\\n    let prev_row = new Array(s2.length + 1).fill(0);\\n        for (let j = 1; j <= s2.length; j++)\\n            prev_row[j] = prev_row[j - 1] + s2.charCodeAt(j - 1);\\n        \\n        for (let i = 1; i <= s1.length; i++) {\\n            let curr_row = [prev_row[0] + s1.charCodeAt(i - 1)];\\n            for (let j = 1; j <= s2.length; j++) {\\n                if (s1[i - 1] === s2[j - 1])\\n                    curr_row.push(prev_row[j - 1]);\\n                else\\n                    curr_row.push(Math.min(prev_row[j] + s1.charCodeAt(i - 1), curr_row[curr_row.length - 1] + s2.charCodeAt(j - 1)));\\n            }\\n            prev_row = curr_row;\\n        }\\n        \\n        return prev_row[prev_row.length - 1];\\n};\\n```\n``` Java []\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n\\n        for (int i = 1; i <= s1.length(); i++)\\n            dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1);\\n        \\n        for (int j = 1; j <= s2.length(); j++)\\n            dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1);\\n        \\n        for (int i = 1; i <= s1.length(); i++) {\\n            for (int j = 1; j <= s2.length(); j++) {\\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i - 1][j] + s1.charAt(i - 1), dp[i][j - 1] + s2.charAt(j - 1));\\n                }\\n            }\\n        }\\n        \\n        return dp[s1.length()][s2.length()];\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public int MinimumDeleteSum(string s1, string s2) {\\n        int[,] dp = new int[s1.Length + 1, s2.Length + 1];\\n\\n        for (int i = 1; i <= s1.Length; i++)\\n            dp[i, 0] = dp[i - 1, 0] + s1[i - 1];\\n\\n        for (int j = 1; j <= s2.Length; j++)\\n            dp[0, j] = dp[0, j - 1] + s2[j - 1];\\n        \\n        for (int i = 1; i <= s1.Length; i++) {\\n            for (int j = 1; j <= s2.Length; j++) {\\n                if (s1[i - 1] == s2[j - 1]) {\\n                    dp[i, j] = dp[i - 1, j - 1];\\n                } else {\\n                    dp[i, j] = Math.Min(dp[i - 1, j] + s1[i - 1], dp[i, j - 1] + s2[j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[s1.Length, s2.Length];\\n    }\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn minimum_delete_sum(s1: String, s2: String) -> i32 {\\n        let mut prev_row = vec![0; s2.len() + 1];\\n        let s1 = s1.chars().collect::<Vec<_>>();\\n        let s2 = s2.chars().collect::<Vec<_>>();\\n\\n        for j in 1..=s2.len() {\\n            prev_row[j] = prev_row[j - 1] + s2[j - 1] as i32;\\n        }\\n\\n        for i in 1..=s1.len() {\\n            let mut curr_row = vec![prev_row[0] + s1[i - 1] as i32];\\n            for j in 1..=s2.len() {\\n                if s1[i - 1] == s2[j - 1] {\\n                    curr_row.push(prev_row[j - 1]);\\n                } else {\\n                    curr_row.push(std::cmp::min(prev_row[j] + s1[i - 1] as i32, curr_row[j - 1] + s2[j - 1] as i32));\\n                }\\n            }\\n            prev_row = curr_row;\\n        }\\n\\n        *prev_row.last().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395835,
                "title": "c-solution-using-lcs-explained-and-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\nLogic:This question is just a variation of lcs as there we need to find out the length,\\nhere we need to find out sum of their ascii values, just a slight change is there \\ni.e we need to add the ascii value of the character which is equal to that we can \\nmemorize its value and at last we have our ans which is basically the sum of ascii value\\nof the longest common subsequence. So we need to find lowest ASCII sum of deleted characters to make two strings equal so we will \\ncalculate the sum of both the string\\'s ascii values and substract our ans from it.\\n    */\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.size(),m=s2.size(),sum1=0,sum2=0;\\n        int dp[n+1][m+1];\\n        //calculate sum of ascii values of s1.\\n        for(int i=0;i<n;i++)\\n            sum1+=s1[i];\\n        //calculate sum of ascii values of s2.\\n        for(int i=0;i<m;i++)\\n            sum2+=s2[i];\\n        //apply lcs base condition.\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                if(i==0||j==0)\\n                    dp[i][j]=0;\\n            }\\n        }\\n        //apply lcs...\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s1[i-1]==s2[j-1])\\n                    dp[i][j]=s1[i-1]+dp[i-1][j-1];\\n                else\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        int ans=dp[n][m];\\n        //final_ans = sum1-ans+sum2-ans=>sum1+sum2-2*ans\\n        return sum1+sum2-2*ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\nLogic:This question is just a variation of lcs as there we need to find out the length,\\nhere we need to find out sum of their ascii values, just a slight change is there \\ni.e we need to add the ascii value of the character which is equal to that we can \\nmemorize its value and at last we have our ans which is basically the sum of ascii value\\nof the longest common subsequence. So we need to find lowest ASCII sum of deleted characters to make two strings equal so we will \\ncalculate the sum of both the string\\'s ascii values and substract our ans from it.\\n    */\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.size(),m=s2.size(),sum1=0,sum2=0;\\n        int dp[n+1][m+1];\\n        //calculate sum of ascii values of s1.\\n        for(int i=0;i<n;i++)\\n            sum1+=s1[i];\\n        //calculate sum of ascii values of s2.\\n        for(int i=0;i<m;i++)\\n            sum2+=s2[i];\\n        //apply lcs base condition.\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                if(i==0||j==0)\\n                    dp[i][j]=0;\\n            }\\n        }\\n        //apply lcs...\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s1[i-1]==s2[j-1])\\n                    dp[i][j]=s1[i-1]+dp[i-1][j-1];\\n                else\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        int ans=dp[n][m];\\n        //final_ans = sum1-ans+sum2-ans=>sum1+sum2-2*ans\\n        return sum1+sum2-2*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563704,
                "title": "c-lcs-recursion-memoization-tabulation-space-optimization",
                "content": "\\u27A1\\uFE0F Recursion\\n\\n```\\nint solveRec(string &s1,string &s2,int i,int j){\\n        if(i==s1.length() || j==s2.length()){\\n            return 0;\\n        }\\n        int ans=0;\\n        if(s1[i]==s2[j]){\\n            ans=s1[i]+solveRec(s1,s2,i+1,j+1);\\n        }else{\\n            ans=max(solveRec(s1,s2,i+1,j),solveRec(s1,s2,i,j+1));\\n        }\\n        return ans;\\n    }\\n\\tint minimumDeleteSum(string s1, string s2) {\\n        int n=s1.length();\\n        int m=s2.length();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=s1[i];\\n        }\\n        for(int i=0;i<m;i++){\\n            sum+=s2[i];\\n        }\\n        return sum-(2*(solveRec(s1,s2,0,0)));\\n    }\\n```\\n\\u27A1\\uFE0F Memoization \\n\\n```\\nint solveMemo(string &s1,string &s2,int i,int j,vector<vector<int>>&dp){\\n        if(i==s1.length() || j==s2.length()){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int ans=0;\\n        if(s1[i]==s2[j]){\\n            ans=s1[i]+solveMemo(s1,s2,i+1,j+1,dp);\\n        }else{\\n            ans=max(solveMemo(s1,s2,i+1,j,dp),solveMemo(s1,s2,i,j+1,dp));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n\\tint minimumDeleteSum(string s1, string s2) {\\n        int n=s1.length();\\n        int m=s2.length();\\n        int sum=0;\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int i=0;i<n;i++){\\n            sum+=s1[i];\\n        }\\n        for(int i=0;i<m;i++){\\n            sum+=s2[i];\\n        }\\n        return sum-(2*(solveMemo(s1,s2,0,0,dp)));\\n    }\\n```\\n\\u27A1\\uFE0F Tabulation\\n\\n```\\nint solveTab(string &s1,string &s2){\\n      int n=s1.length();\\n      int m=s2.length();\\n      vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n      for(int i=n-1;i>=0;i--){\\n          for(int j=m-1;j>=0;j--){\\n              int ans=0;\\n              if(s1[i]==s2[j]){\\n                  ans=s1[i]+dp[i+1][j+1];\\n              }else{\\n                  ans=max(dp[i+1][j],dp[i][j+1]);\\n              }\\n              dp[i][j]=ans;\\n          }\\n      }\\n      return dp[0][0];\\n    }\\n\\tint minimumDeleteSum(string s1, string s2) {\\n        int n=s1.length();\\n        int m=s2.length();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=s1[i];\\n        }\\n        for(int i=0;i<m;i++){\\n            sum+=s2[i];\\n        }\\n        return sum-(2*(solveTab(s1,s2)));\\n    }\\n```\\n \\u27A1\\uFE0F Space Optimization\\n \\n```\\nint solveOpt(string &s1,string &s2){\\n      int n=s1.length();\\n      int m=s2.length();\\n      vector<int>curr(m+1,0);\\n      vector<int> next(m+1,0);\\n      for(int i=n-1;i>=0;i--){\\n          for(int j=m-1;j>=0;j--){\\n              int ans=0;\\n              if(s1[i]==s2[j]){\\n                  ans=s1[i]+next[j+1];\\n              }else{\\n                  ans=max(next[j],curr[j+1]);\\n              }\\n              curr[j]=ans;\\n          }\\n          next=curr;\\n      }\\n      return next[0];\\n    }\\n\\tint minimumDeleteSum(string s1, string s2) {\\n        int n=s1.length();\\n        int m=s2.length();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=s1[i];\\n        }\\n        for(int i=0;i<m;i++){\\n            sum+=s2[i];\\n        }\\n        return sum-(2*(solveOpt(s1,s2)));\\n    }\\n```\\n**similar problems:-**\\n1. https://leetcode.com/problems/longest-common-subsequence/\\n2. https://leetcode.com/problems/delete-operation-for-two-strings/\\n3. https://leetcode.com/problems/edit-distance/\\n\\n**Don\\'t forget to upvote this post if it has helped you!!!**",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nint solveRec(string &s1,string &s2,int i,int j){\\n        if(i==s1.length() || j==s2.length()){\\n            return 0;\\n        }\\n        int ans=0;\\n        if(s1[i]==s2[j]){\\n            ans=s1[i]+solveRec(s1,s2,i+1,j+1);\\n        }else{\\n            ans=max(solveRec(s1,s2,i+1,j),solveRec(s1,s2,i,j+1));\\n        }\\n        return ans;\\n    }\\n\\tint minimumDeleteSum(string s1, string s2) {\\n        int n=s1.length();\\n        int m=s2.length();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=s1[i];\\n        }\\n        for(int i=0;i<m;i++){\\n            sum+=s2[i];\\n        }\\n        return sum-(2*(solveRec(s1,s2,0,0)));\\n    }\\n```\n```\\nint solveMemo(string &s1,string &s2,int i,int j,vector<vector<int>>&dp){\\n        if(i==s1.length() || j==s2.length()){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int ans=0;\\n        if(s1[i]==s2[j]){\\n            ans=s1[i]+solveMemo(s1,s2,i+1,j+1,dp);\\n        }else{\\n            ans=max(solveMemo(s1,s2,i+1,j,dp),solveMemo(s1,s2,i,j+1,dp));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n\\tint minimumDeleteSum(string s1, string s2) {\\n        int n=s1.length();\\n        int m=s2.length();\\n        int sum=0;\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int i=0;i<n;i++){\\n            sum+=s1[i];\\n        }\\n        for(int i=0;i<m;i++){\\n            sum+=s2[i];\\n        }\\n        return sum-(2*(solveMemo(s1,s2,0,0,dp)));\\n    }\\n```\n```\\nint solveTab(string &s1,string &s2){\\n      int n=s1.length();\\n      int m=s2.length();\\n      vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n      for(int i=n-1;i>=0;i--){\\n          for(int j=m-1;j>=0;j--){\\n              int ans=0;\\n              if(s1[i]==s2[j]){\\n                  ans=s1[i]+dp[i+1][j+1];\\n              }else{\\n                  ans=max(dp[i+1][j],dp[i][j+1]);\\n              }\\n              dp[i][j]=ans;\\n          }\\n      }\\n      return dp[0][0];\\n    }\\n\\tint minimumDeleteSum(string s1, string s2) {\\n        int n=s1.length();\\n        int m=s2.length();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=s1[i];\\n        }\\n        for(int i=0;i<m;i++){\\n            sum+=s2[i];\\n        }\\n        return sum-(2*(solveTab(s1,s2)));\\n    }\\n```\n```\\nint solveOpt(string &s1,string &s2){\\n      int n=s1.length();\\n      int m=s2.length();\\n      vector<int>curr(m+1,0);\\n      vector<int> next(m+1,0);\\n      for(int i=n-1;i>=0;i--){\\n          for(int j=m-1;j>=0;j--){\\n              int ans=0;\\n              if(s1[i]==s2[j]){\\n                  ans=s1[i]+next[j+1];\\n              }else{\\n                  ans=max(next[j],curr[j+1]);\\n              }\\n              curr[j]=ans;\\n          }\\n          next=curr;\\n      }\\n      return next[0];\\n    }\\n\\tint minimumDeleteSum(string s1, string s2) {\\n        int n=s1.length();\\n        int m=s2.length();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=s1[i];\\n        }\\n        for(int i=0;i<m;i++){\\n            sum+=s2[i];\\n        }\\n        return sum-(2*(solveOpt(s1,s2)));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3841777,
                "title": "c-dp-recursion-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long help(int i,int j,string& s1,string &s2,vector<vector<int>>&dp){\\n        if(i==s1.size() && j==s2.size())return 0;\\n        if(i==s1.size()){\\n            int d=0;\\n            for(int k=j;k<s2.size();k++){\\n                d += (int)s2[k];\\n            }\\n            return d;\\n        }\\n        if(j==s2.size()){\\n            int d=0;\\n            for(int k=i;k<s1.size();k++){\\n                d += (int)s1[k];\\n            }\\n            return d;\\n        }\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        long long ans = INT_MAX;\\n        if(s1[i]==s2[j])ans = help(i+1,j+1,s1,s2,dp);\\n        else {\\n            ans = min(ans, s1[i] + help(i+1,j,s1,s2,dp));\\n            ans = min(ans, s2[j] + help(i,j+1,s1,s2,dp));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        vector<vector<int>>dp(s1.size(),vector<int>(s2.size(),-1));\\n        return help(0,0,s1,s2,dp);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/a76ea028-e525-46d8-b313-221b4f030bbd_1690789377.2032986.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long help(int i,int j,string& s1,string &s2,vector<vector<int>>&dp){\\n        if(i==s1.size() && j==s2.size())return 0;\\n        if(i==s1.size()){\\n            int d=0;\\n            for(int k=j;k<s2.size();k++){\\n                d += (int)s2[k];\\n            }\\n            return d;\\n        }\\n        if(j==s2.size()){\\n            int d=0;\\n            for(int k=i;k<s1.size();k++){\\n                d += (int)s1[k];\\n            }\\n            return d;\\n        }\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        long long ans = INT_MAX;\\n        if(s1[i]==s2[j])ans = help(i+1,j+1,s1,s2,dp);\\n        else {\\n            ans = min(ans, s1[i] + help(i+1,j,s1,s2,dp));\\n            ans = min(ans, s2[j] + help(i,j+1,s1,s2,dp));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        vector<vector<int>>dp(s1.size(),vector<int>(s2.size(),-1));\\n        return help(0,0,s1,s2,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922517,
                "title": "python-dp-solution-with-explanation",
                "content": "### Solution1:\\nThis problem is a change of Leetcode 1143. Here is my explanation:\\n\\n- [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/discuss/922401/python-dp-solution-with-explanation)\\n\\nThe only thing different is that LC712 calculates the **Maximum ASCII Sum of Common Subsequence** while LC1143 needs to find out **the length of LCS**. The result will be `ASCII Sum of S1 - Max ASCII Sum of CS +  ASCII Sum of S2 - Max ASCII Sum of CS`. Here is the code:\\n\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if s1[i - 1] == s2[j - 1]:\\n                    dp[j][i] = dp[j - 1][i - 1] + ord(s1[i - 1])\\n                else:\\n                    dp[j][i] = max(dp[j - 1][i], dp[j][i - 1])\\n        \\n\\t\\t# ASCII Sum of S1 - Max ASCII Sum of CS +  ASCII Sum of S2 - Max ASCII Sum of CS\\n        return sum(map(ord, s1 + s2)) - dp[-1][-1] * 2\\n```\\n\\n<br />\\n\\n### Solution2:\\nIn this approach, dp stores the ASCII Delete Sum for Two Strings.\\n\\n#### Assume:\\n- `i` is the i-th char of s2\\n- `j` is the j-th char of s1 \\n- `dp` is a 2-dimension array `[(len(s1)+1)*(len(s2)+1)]`. `dp[i][j]` stores the  minimum ASCII Delete Sum for  `s1[:j]` and `s2[:i]`. \\n\\n#### Init `dp[i][j]`:\\n- dp[0][j]: dp[0][j] = dp[0][j-1] +  ord(s1[j - 1])\\n- dp[i][0]: dp[i][0] = dp[i-1][0] +  ord(s2[i - 1])\\n\\n#### Calculate `dp[i][j]`:\\n- `s1[j-1] == s2[i-1]`\\n**dp[i][j] = dp[i - 1][j - 1]**\\n- `s1[j-1] != s2[i-1]`\\n  - If (j-1)th char of s1 is not equal to (i-1)th char of s2, it will have the following 2 situations:\\n\\t  - Delete s1[j-1]: **s1[j - 1]) + dp[i][j - 1]**\\n\\t  - Delete s2[i-1]: **ord(s2[i - 1]) + dp[i - 1][j]**\\n  - So **dp[i][j] = min(ord(s1[j - 1]) + dp[i][j - 1], ord(s2[i - 1]) + dp[i - 1][j])**\\n\\n#### Graph:\\n![image](https://assets.leetcode.com/users/images/1e79a627-8d84-41aa-a890-59f8e0182d5f_1604727258.5387232.png)\\n\\nGreen: Initial value\\nYellow: Final Path\\n\\n#### Code:\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\\n\\n        for i in range(1, m + 1):\\n            dp[0][i] = dp[0][i - 1] + ord(s1[i - 1])\\n        for i in range(1, n + 1):\\n            dp[i][0] = dp[i - 1][0] + ord(s2[i - 1])\\n\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                if s1[j - 1] == s2[i - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                else:\\n                    dp[i][j] = min(ord(s1[j - 1]) + dp[i][j - 1], ord(s2[i - 1]) + dp[i - 1][j])\\n\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if s1[i - 1] == s2[j - 1]:\\n                    dp[j][i] = dp[j - 1][i - 1] + ord(s1[i - 1])\\n                else:\\n                    dp[j][i] = max(dp[j - 1][i], dp[j][i - 1])\\n        \\n\\t\\t# ASCII Sum of S1 - Max ASCII Sum of CS +  ASCII Sum of S2 - Max ASCII Sum of CS\\n        return sum(map(ord, s1 + s2)) - dp[-1][-1] * 2\\n```\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\\n\\n        for i in range(1, m + 1):\\n            dp[0][i] = dp[0][i - 1] + ord(s1[i - 1])\\n        for i in range(1, n + 1):\\n            dp[i][0] = dp[i - 1][0] + ord(s2[i - 1])\\n\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                if s1[j - 1] == s2[i - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                else:\\n                    dp[i][j] = min(ord(s1[j - 1]) + dp[i][j - 1], ord(s2[i - 1]) + dp[i - 1][j])\\n\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536559,
                "title": "c-recursion-memoization-tabulation-spaceoptimization",
                "content": "# Method - 1 [Recursion]\\n![image](https://assets.leetcode.com/users/images/4e95527b-251a-4d4a-8d8b-8b4170b15927_1662405583.862126.png)\\n\\n**T->O(2^(n+m)) && S->O(m+n) [Recursion Stack Space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t//     LCS string matching\\n\\t\\tint f(int i,int j,string& s1,string& s2){\\n\\t\\t\\tif(i<0 || j<0) return 0;\\n\\t\\t\\tif(s1[i]==s2[j]) return s1[i]+f(i-1,j-1,s1,s2);\\n\\t\\t\\treturn max(f(i-1,j,s1,s2),f(i,j-1,s1,s2));\\n\\t\\t}\\n\\n\\t\\tint minimumDeleteSum(string s1, string s2) {\\n\\t\\t\\tint n=s1.size();\\n\\t\\t\\tint m=s2.size();\\n\\t\\t\\tint sum1=0,sum2=0;\\n\\t\\t\\tfor(auto i:s1) sum1+=i;\\n\\t\\t\\tfor(auto i:s2) sum2+=i;\\n\\t\\t\\treturn (sum1+sum2)-2*f(n-1,m-1,s1,s2);\\n\\t\\t}\\n\\t};\\n\\t\\n# Method - 2 [Memoization]\\t\\n![image](https://assets.leetcode.com/users/images/c27280da-eaa5-4078-8799-56b773c3bc9a_1662405883.2097754.png)\\n\\n**T->O(mn) && S-> O(mn) +O(m+n) [Recursion Stack Space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t//     LCS string matching\\n\\t\\tint f(int i,int j,string& s1,string& s2,vector<vector<int>>& dp){\\n\\t\\t\\tif(i<0 || j<0) return 0;\\n\\t\\t\\tif(dp[i][j]!=-1) return dp[i][j];\\n\\t\\t\\tif(s1[i]==s2[j]) return dp[i][j]=s1[i]+f(i-1,j-1,s1,s2,dp);\\n\\t\\t\\treturn dp[i][j]=max(f(i-1,j,s1,s2,dp),f(i,j-1,s1,s2,dp));\\n\\t\\t}\\n\\n\\t\\tint minimumDeleteSum(string s1, string s2) {\\n\\t\\t\\tint n=s1.size();\\n\\t\\t\\tint m=s2.size();\\n\\t\\t\\tint sum1=0,sum2=0;\\n\\t\\t\\tfor(auto i:s1) sum1+=i;\\n\\t\\t\\tfor(auto i:s2) sum2+=i;\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(m,-1));\\n\\t\\t\\treturn (sum1+sum2)-2*f(n-1,m-1,s1,s2,dp);\\n\\t\\t}\\n\\t};\\n\\t\\n# Method -3 [Tabulation]\\t\\n![image](https://assets.leetcode.com/users/images/bc82ca69-1963-45b4-9e13-2f5fa544cca5_1662406582.4146223.png)\\n\\n**T->O(mn) && S-> O(mn)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumDeleteSum(string s1, string s2) {\\n\\t\\t\\tint n=s1.size();\\n\\t\\t\\tint m=s2.size();\\n\\t\\t\\tint sum1=0,sum2=0;\\n\\t\\t\\tfor(auto i:s1) sum1+=i;\\n\\t\\t\\tfor(auto i:s2) sum2+=i;\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\tif(s1[i-1]==s2[j-1]) dp[i][j]=s1[i-1]+dp[i-1][j-1];\\n\\t\\t\\t\\t\\telse dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n\\t\\t\\t\\t}   \\n\\t\\t\\t}\\n\\t\\t\\treturn (sum1+sum2)-2*dp[n][m];\\n\\t\\t}\\n\\t};\\n\\t\\n# Method -4 [Space Optimization]\\t\\n\\n![image](https://assets.leetcode.com/users/images/c3f704fa-819c-4811-aeb0-3c1e7b5b9205_1662406760.0214746.png)\\n\\n**T->O(mn) && S-> O(m)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumDeleteSum(string s1, string s2) {\\n\\t\\t\\tint n=s1.size();\\n\\t\\t\\tint m=s2.size();\\n\\t\\t\\tint sum1=0,sum2=0;\\n\\t\\t\\tfor(auto i:s1) sum1+=i;\\n\\t\\t\\tfor(auto i:s2) sum2+=i;\\n\\t\\t\\tvector<int> prev(m+1,0),curr(m+1,0);\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\tif(s1[i-1]==s2[j-1]) curr[j]=s1[i-1]+prev[j-1];\\n\\t\\t\\t\\t\\telse curr[j]=max(prev[j],curr[j-1]);\\n\\t\\t\\t\\t}   \\n\\t\\t\\t\\tprev=curr;\\n\\t\\t\\t}\\n\\t\\t\\treturn (sum1+sum2)-2*prev[m];\\n\\t\\t}\\n\\t};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t//     LCS string matching\\n\\t\\tint f(int i,int j,string& s1,string& s2){\\n\\t\\t\\tif(i<0 || j<0) return 0;\\n\\t\\t\\tif(s1[i]==s2[j]) return s1[i]+f(i-1,j-1,s1,s2);\\n\\t\\t\\treturn max(f(i-1,j,s1,s2),f(i,j-1,s1,s2));\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 136346,
                "title": "c-dp",
                "content": "\\u4E8C\\u7EF4\\u6570\\u7EC4dp[i][j]\\u4EE3\\u8868 s1\\u524Di\\u4E2A\\u5B57\\u7B26 \\u548C s2\\u524Dj\\u4E2A\\u5B57\\u7B26 \\u5B9E\\u73B0\\u76F8\\u540C\\uFF08s1==s2\\uFF09 \\u6240\\u9700\\u8981\\u5220\\u9664\\u7684ASCII value\\uFF1B\\n\\u76EE\\u6807\\uFF1Adp[s1\\u7684\\u957F\\u5EA6-1][s2\\u7684\\u957F\\u5EA6-1]\\n\\n\\u63A8\\u5BFC\\u72B6\\u6001\\u8F6C\\u79FB\\u516C\\u5F0F\\uFF1A\\nd[i][j]\\u53EF\\u80FD\\u7531\\u4EE5\\u4E0B\\u4E09\\u79CD\\u65B9\\u5F0F\\u8FBE\\u5230\\uFF1A\\n1\\u3001dp[i - 1][j] + s1[i]\\uFF1A\\u7531\\u4E8E\\u4ECEdp[i - 1][j]\\u5230dp[i][j]\\u662F\\u591A\\u8003\\u8651\\u4E86s1\\u7684\\u4E00\\u4E2A\\u5B57\\u7B26\\uFF0C\\u4F46\\u662Fs2\\u5B57\\u7B26\\u6570\\u6CA1\\u53D8\\uFF0C\\u6240\\u4EE5\\u8981\\u60F3\\u76F8\\u540C\\uFF0C\\u5FC5\\u987B\\u5220\\u9664s1[i],\\u8003\\u8651value\\u7684\\u8BDD\\u5C31\\u662F\\u52A0\\u4E0As1[i]\\uFF1B\\n2\\u3001dp[i][j - 1] + s2[j]\\uFF1A\\u7C7B\\u4F3C\\u5730\\uFF0C\\u8FD9\\u4E2A\\u662F\\u591A\\u8003\\u8651s2\\u7684\\u4E00\\u4E2A\\u5B57\\u7B26\\uFF0C\\u6240\\u4EE5\\u8981\\u5220\\u9664s2[j]\\uFF0C\\u8003\\u8651value\\u7684\\u8BDD\\u5C31\\u662F\\u52A0\\u4E0As2[j]\\n3\\u3001dp[i - 1][j - 1] + a\\uFF0C\\u8FD9\\u91CC\\u662F\\u8003\\u8651\\u4E24\\u4E2Astring\\u90FD\\u52A0\\u4E86\\u4E00\\u4E2A\\u5B57\\u7B26\\uFF0C\\u5F53s1[i] =s2[j]\\u65F6\\uFF0Ca=0\\uFF1B\\u5F53str1[i] \\uFF01= str2[j]\\u65F6\\uFF0C\\u4E24\\u4E2A\\u90FD\\u8981\\u5220\\u9664\\uFF0Ca=s1[i] +s2[j] \\n\\n\\u4EE5\\u4E0A\\u4E09\\u79CD\\u60C5\\u51B5\\u6BCF\\u6B21\\u6BD4\\u8F83\\u51FA\\u6700\\u5C0F\\u7684\\uFF0C\\u5373\\u4E3Ad[i][j]\\u3002\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        \\n        for (int i = 1; i <= m; i++)\\n            dp[i][0] = dp[i-1][0]+s1[i-1];\\n        for (int j = 1; j <= n; j++)\\n            dp[0][j] = dp[0][j-1]+s2[j-1];\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                int a;\\n                if (s1[i-1] == s2[j-1]) a=0;\\n                else  a=s1[i-1]+s2[j-1];\\n                dp[i][j] = min(dp[i-1][j-1]+a,min(dp[i-1][j]+s1[i-1], dp[i][j-1]+s2[j-1]));\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        \\n        for (int i = 1; i <= m; i++)\\n            dp[i][0] = dp[i-1][0]+s1[i-1];\\n        for (int j = 1; j <= n; j++)\\n            dp[0][j] = dp[0][j-1]+s2[j-1];\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                int a;\\n                if (s1[i-1] == s2[j-1]) a=0;\\n                else  a=s1[i-1]+s2[j-1];\\n                dp[i][j] = min(dp[i-1][j-1]+a,min(dp[i-1][j]+s1[i-1], dp[i][j-1]+s2[j-1]));\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108813,
                "title": "c-o-nm-based-on-longest-common-subsequence",
                "content": "We calculate the LCS of two strings, except that now each character as a weight. The algorithm is essentially the same. The delete sum is then the ASCII sum of the two strings minus the LCS value.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        int dp[n1+1][n2+1] = {};\\n        for (int i1 = 1; i1 <=n1; ++i1) for (int i2 = 1; i2 <=n2; ++i2)  {\\n            int ans = 0;\\n            ans = max(dp[i1][i2-1], dp[i1-1][i2]);\\n            if (s1[i1-1]==s2[i2-1]) ans = max(ans, (int)s1[i1-1] + dp[i1-1][i2-1]);\\n            dp[i1][i2] = ans;\\n        }\\n        int ret = 0;\\n        for (auto c:s1) ret +=c;\\n        for (auto c:s2) ret +=c;\\n        ret -= 2*dp[n1][n2];\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        int dp[n1+1][n2+1] = {};\\n        for (int i1 = 1; i1 <=n1; ++i1) for (int i2 = 1; i2 <=n2; ++i2)  {\\n            int ans = 0;\\n            ans = max(dp[i1][i2-1], dp[i1-1][i2]);\\n            if (s1[i1-1]==s2[i2-1]) ans = max(ans, (int)s1[i1-1] + dp[i1-1][i2-1]);\\n            dp[i1][i2] = ans;\\n        }\\n        int ret = 0;\\n        for (auto c:s1) ret +=c;\\n        for (auto c:s2) ret +=c;\\n        ret -= 2*dp[n1][n2];\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108821,
                "title": "lcs-variation-solution-python-c",
                "content": "to get the minimal cost, we need to find the common subsequences, and among all the common subsequences, we need to find the minimal cost.\\n\\nit is very like to find the longest common subsequence, but this time, we need to find the max ascii common subsequence, then the minimal cost is the two fixed ascii sum of two origin strings, minus the max ascii common subsequence we have found.\\n\\npython code:\\n```\\nclass Solution(object):\\n    def minimumDeleteSum(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: int\\n        \"\"\"\\n        l1 = len(s1)\\n        l2 = len(s2)\\n        dp = [[0] * (l2 + 1) for i in xrange(l1 + 1)]\\n        for i in xrange(l1):\\n            for j in xrange(l2):\\n                if s1[i] == s2[j]:\\n                    dp[i+1][j+1] = dp[i][j] + ord(s1[i]) * 2\\n                else:\\n                    dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1])\\n        n1 = sum(ord(c) for c in s1)\\n        n2 = sum(ord(c) for c in s2)\\n        return n1 + n2 - dp[l1][l2]\\n``` \\nc++ code:\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int dp[1001][1001] = {0};\\n        for ( int i = 0; i < s1.size(); ++i ) {\\n            for ( int j = 0; j < s2.size(); ++j ) {\\n                if ( s1[i] == s2[j] ) {\\n                    dp[i+1][j+1] = dp[i][j] + int(s1[i]) * 2;\\n                } else {\\n                    dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1]);\\n                }\\n            }\\n        }\\n        int n1 = accumulate(s1.begin(), s1.end(), 0);\\n        int n2 = accumulate(s2.begin(), s2.end(), 0);\\n        return n1 + n2 - dp[s1.size()][s2.size()];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minimumDeleteSum(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: int\\n        \"\"\"\\n        l1 = len(s1)\\n        l2 = len(s2)\\n        dp = [[0] * (l2 + 1) for i in xrange(l1 + 1)]\\n        for i in xrange(l1):\\n            for j in xrange(l2):\\n                if s1[i] == s2[j]:\\n                    dp[i+1][j+1] = dp[i][j] + ord(s1[i]) * 2\\n                else:\\n                    dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1])\\n        n1 = sum(ord(c) for c in s1)\\n        n2 = sum(ord(c) for c in s2)\\n        return n1 + n2 - dp[l1][l2]\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int dp[1001][1001] = {0};\\n        for ( int i = 0; i < s1.size(); ++i ) {\\n            for ( int j = 0; j < s2.size(); ++j ) {\\n                if ( s1[i] == s2[j] ) {\\n                    dp[i+1][j+1] = dp[i][j] + int(s1[i]) * 2;\\n                } else {\\n                    dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1]);\\n                }\\n            }\\n        }\\n        int n1 = accumulate(s1.begin(), s1.end(), 0);\\n        int n2 = accumulate(s2.begin(), s2.end(), 0);\\n        return n1 + n2 - dp[s1.size()][s2.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108814,
                "title": "java-c-clean-code",
                "content": "**DP Formula**\\n```\\n/**\\n * dp[i][j] = a[i] == b[j] ? dp[i + 1][j + 1] :\\n *            min(a[i] + dp[i + 1][j],  // delete a[i] + minimumDeleteSum(a.substr(i+1), b.substr(j))\\n *                b[j] + dp[i][j + 1])  // delete b[j] + minimumDeleteSum(a.substr(i), b.substr(j+1))\\n */\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int m = s1.length(), n = s2.length(), MAX = Integer.MAX_VALUE;\\n        char[] a = s1.toCharArray(), b = s2.toCharArray();\\n        int[][] dp = new int[m + 1][n + 1];\\n        for (int i = m; i >= 0; i--) {\\n            for (int j = n; j >= 0; j--) {\\n                if (i < m || j < n)\\n                    dp[i][j] = i < m && j < n && a[i] == b[j] ?\\n                        dp[i + 1][j + 1] : Math.min((i < m ? a[i] + dp[i + 1][j] : MAX), (j < n ? b[j] + dp[i][j + 1] : MAX));\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string a, string b) {\\n        int m = a.size(), n = b.size();\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\\n        for (int i = m; i >= 0; i--) {\\n            for (int j = n; j >= 0; j--) {\\n                if (i < m || j < n)\\n                    dp[i][j] = i < m && j < n && a[i] == b[j] ?\\n                        dp[i + 1][j + 1] : min((i < m ? a[i] + dp[i + 1][j] : INT_MAX), (j < n ? b[j] + dp[i][j + 1] : INT_MAX));\\n            }\\n        }\\n        return dp[0][0];        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * dp[i][j] = a[i] == b[j] ? dp[i + 1][j + 1] :\\n *            min(a[i] + dp[i + 1][j],  // delete a[i] + minimumDeleteSum(a.substr(i+1), b.substr(j))\\n *                b[j] + dp[i][j + 1])  // delete b[j] + minimumDeleteSum(a.substr(i), b.substr(j+1))\\n */\\n```\n```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int m = s1.length(), n = s2.length(), MAX = Integer.MAX_VALUE;\\n        char[] a = s1.toCharArray(), b = s2.toCharArray();\\n        int[][] dp = new int[m + 1][n + 1];\\n        for (int i = m; i >= 0; i--) {\\n            for (int j = n; j >= 0; j--) {\\n                if (i < m || j < n)\\n                    dp[i][j] = i < m && j < n && a[i] == b[j] ?\\n                        dp[i + 1][j + 1] : Math.min((i < m ? a[i] + dp[i + 1][j] : MAX), (j < n ? b[j] + dp[i][j + 1] : MAX));\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string a, string b) {\\n        int m = a.size(), n = b.size();\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\\n        for (int i = m; i >= 0; i--) {\\n            for (int j = n; j >= 0; j--) {\\n                if (i < m || j < n)\\n                    dp[i][j] = i < m && j < n && a[i] == b[j] ?\\n                        dp[i + 1][j + 1] : min((i < m ? a[i] + dp[i + 1][j] : INT_MAX), (j < n ? b[j] + dp[i][j + 1] : INT_MAX));\\n            }\\n        }\\n        return dp[0][0];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840982,
                "title": "c-java-python-easy-solution-with-explanation-recursive-and-memoized-code",
                "content": "# Intuition\\nThe reason why dynamic programming is used for this problem is based on the observation that there are three different cases that can occur during the operation. Each case presents specific choices at different points. Since the ultimate goal is to minimize the sum, this and choices points towards the idea of using dynamic programming to efficiently explore and find the optimal solution by breaking down the problem into smaller overlapping subproblems and avoiding redundant calculations.\\n\\n# Approach\\n**Explanation of the problem:**\\n\\nThe problem is to find the lowest ASCII sum of deleted characters from two given strings, s1 and s2, in order to make the two strings equal. You can delete characters from both strings, but you cannot change the order of the remaining characters.\\n\\n**Steps of Dynamic Programming :**\\n\\n1. **Define Subproblems:** The first step in using DP is to define the subproblems. In this case, the subproblem can be defined as finding the lowest ASCII sum of deleted characters to make two substrings, one from s1 and the other from s2, equal.\\n\\n2. **Identify Overlapping Subproblems:** After defining the subproblems, check if there are overlapping subproblems. In this problem, when finding the lowest ASCII sum for a particular pair of substrings from s1 and s2, it is possible that you may encounter the same substrings again in different recursive paths.\\n\\n3. **Recurrence Relation:** Once the subproblems are identified, establish a recurrence relation to relate the solution of larger subproblems to the solutions of smaller subproblems. In this problem, you can use a recursive function that calculates the lowest ASCII sum for a given pair of substrings from s1 and s2.\\n\\n4. **Memoization or Tabulation:** To avoid redundant calculations and improve efficiency, use memoization (top-down DP) or tabulation (bottom-up DP). Memoization involves storing the results of already solved subproblems in a data structure (like a dictionary or array) to avoid recalculating them when encountered again. Tabulation involves filling up a table iteratively to build solutions for larger subproblems based on the solutions of smaller subproblems.\\n\\n**How to solve the problem:**\\n\\n1. Implement a recursive function that takes the following parameters:\\n   - The current indices (i and j) for s1 and s2, indicating the substrings under consideration.\\n   - Two strings s1 and s2 themselves.\\n   - A memoization table (a dictionary) to store the results of already solved subproblems.\\n\\n2. In the recursive function, set the base case. When one or both strings have been fully processed (i.e., i or j is equal to the length of the respective string), return the sum of ASCII values of the remaining characters in the non-empty string.\\n\\n3. Check if the current pair of indices (i and j) and their respective characters are already present in the memoization table. If yes, return the precomputed result.\\n\\n4. If the characters at the current indices (i and j) are the same, there is no need to delete them, so recursively call the function with the updated indices (i+1 and j+1).\\n\\n5. If the characters at the current indices (i and j) are different, there are two options: delete either the character at i in s1 or the character at j in s2. Calculate the lowest ASCII sum by recursively calling the function twice: one with updated index i+1 (indicating deletion from s1) and the other with updated index j+1 (indicating deletion from s2). Choose the minimum of the two sums obtained from these recursive calls.\\n\\n6. Store the calculated lowest ASCII sum in the memoization table with the current indices (i and j) as the key.\\n\\n7. Finally, return the lowest ASCII sum obtained for the initial call of the recursive function with i=0 and j=0, representing the full strings s1 and s2.\\n\\n8. To improve efficiency, you can use tabulation (bottom-up DP) instead of recursion, where you build the DP table iteratively based on the results of smaller subproblems.\\n\\n# Complexity\\n- Time complexity:O(N1 * N2) where N1 is the s1 length and N2 is the length of string s2\\n\\n- Space complexity:O(N1 * N2) where N1 is the s1 length and N2 is the length of string s2\\n\\n# C++ Recursive Code\\n```\\nclass Solution {\\npublic:\\n    int remains(string s , int i){\\n        int sum = 0;\\n        for(int j = i ; j < s.size() ; j++){\\n            sum += s[j];\\n        }\\n        return sum;\\n    }\\n    int dfs(int i , int j , string& s1 , string& s2){\\n        if(i == s1.size() && j == s2.size()) return 0;\\n        if(i == s1.size() && j < s2.size()) return remains(s2 , j);\\n        if(j == s2.size() && i < s1.size()) return remains(s1 , i);\\n        if(s1[i] == s2[j]){\\n            return dfs(i + 1 , j + 1 , s1 , s2);\\n        }\\n        else{\\n            return min({s1[i]+ dfs(i + 1 , j , s1 , s2) ,s2[j] + dfs(i , j + 1 , s1 ,s2)});\\n        }\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n1 = s1.size() , n2 = s2.size();\\n        return dfs(0 , 0 , s1 , s2);\\n    }\\n};\\n```\\n\\n# C++ Memoized Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int remains(string s , int i){\\n        int sum = 0;\\n        for(int j = i ; j < s.size() ; j++){\\n            sum += s[j];\\n        }\\n        return sum;\\n    }\\n    int dfs(int i , int j , string& s1 , string& s2){\\n        if(i == s1.size() && j == s2.size()) return 0;\\n        if(i == s1.size() && j < s2.size()) return remains(s2 , j);\\n        if(j == s2.size() && i < s1.size()) return remains(s1 , i);\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s1[i] == s2[j]){\\n            return dp[i][j] = dfs(i + 1 , j + 1 , s1 , s2);\\n        }\\n        else{\\n            return dp[i][j] = min({s1[i]+ dfs(i + 1 , j , s1 , s2) ,\\n                                s2[j] + dfs(i , j + 1 , s1 ,s2) ,});\\n        }\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n1 = s1.size() , n2 = s2.size();\\n        dp.resize(n1 , vector<int>(n2 , -1));\\n        return dfs(0 , 0 , s1 , s2);\\n    }\\n};\\n```\\n# Python Code\\n```\\nclass Solution(object):\\n    def remains(self, s, i):\\n        sum_val = 0\\n        for j in range(i, len(s)):\\n            sum_val += ord(s[j])\\n        return sum_val\\n    \\n    def dfs(self, i, j, s1, s2, dp):\\n        if i == len(s1) and j == len(s2):\\n            return 0\\n        if i == len(s1) and j < len(s2):\\n            return self.remains(s2, j)\\n        if j == len(s2) and i < len(s1):\\n            return self.remains(s1, i)\\n        if dp[i][j] != -1:\\n            return dp[i][j]\\n        if s1[i] == s2[j]:\\n            dp[i][j] = self.dfs(i + 1, j + 1, s1, s2, dp)\\n        else:\\n            dp[i][j] = min(ord(s1[i]) + self.dfs(i + 1, j, s1, s2, dp),\\n                           ord(s2[j]) + self.dfs(i, j + 1, s1, s2, dp))\\n        return dp[i][j]\\n    def minimumDeleteSum(self, s1, s2):\\n        n1, n2 = len(s1), len(s2)\\n        dp = [[-1 for _ in range(n2)] for _ in range(n1)]\\n        return self.dfs(0, 0, s1, s2, dp)\\n        \\n```\\n# Java Code\\n```\\nclass Solution {\\n    private int[][] dp;\\n    \\n    private int remains(String s, int i) {\\n        int sum = 0;\\n        for (int j = i; j < s.length(); j++) {\\n            sum += s.charAt(j);\\n        }\\n        return sum;\\n    }\\n    \\n    private int dfs(int i, int j, String s1, String s2) {\\n        if (i == s1.length() && j == s2.length()) return 0;\\n        if (i == s1.length() && j < s2.length()) return remains(s2, j);\\n        if (j == s2.length() && i < s1.length()) return remains(s1, i);\\n        if (dp[i][j] != -1) return dp[i][j];\\n        if (s1.charAt(i) == s2.charAt(j)) {\\n            return dp[i][j] = dfs(i + 1, j + 1, s1, s2);\\n        } else {\\n            return dp[i][j] = Math.min(s1.charAt(i) + dfs(i + 1, j, s1, s2),\\n                                      s2.charAt(j) + dfs(i, j + 1, s1, s2));\\n        }\\n    }\\n    \\n    public int minimumDeleteSum(String s1, String s2) {\\n        int n1 = s1.length();\\n        int n2 = s2.length();\\n        dp = new int[n1][n2];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        return dfs(0, 0, s1, s2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int remains(string s , int i){\\n        int sum = 0;\\n        for(int j = i ; j < s.size() ; j++){\\n            sum += s[j];\\n        }\\n        return sum;\\n    }\\n    int dfs(int i , int j , string& s1 , string& s2){\\n        if(i == s1.size() && j == s2.size()) return 0;\\n        if(i == s1.size() && j < s2.size()) return remains(s2 , j);\\n        if(j == s2.size() && i < s1.size()) return remains(s1 , i);\\n        if(s1[i] == s2[j]){\\n            return dfs(i + 1 , j + 1 , s1 , s2);\\n        }\\n        else{\\n            return min({s1[i]+ dfs(i + 1 , j , s1 , s2) ,s2[j] + dfs(i , j + 1 , s1 ,s2)});\\n        }\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n1 = s1.size() , n2 = s2.size();\\n        return dfs(0 , 0 , s1 , s2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int remains(string s , int i){\\n        int sum = 0;\\n        for(int j = i ; j < s.size() ; j++){\\n            sum += s[j];\\n        }\\n        return sum;\\n    }\\n    int dfs(int i , int j , string& s1 , string& s2){\\n        if(i == s1.size() && j == s2.size()) return 0;\\n        if(i == s1.size() && j < s2.size()) return remains(s2 , j);\\n        if(j == s2.size() && i < s1.size()) return remains(s1 , i);\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s1[i] == s2[j]){\\n            return dp[i][j] = dfs(i + 1 , j + 1 , s1 , s2);\\n        }\\n        else{\\n            return dp[i][j] = min({s1[i]+ dfs(i + 1 , j , s1 , s2) ,\\n                                s2[j] + dfs(i , j + 1 , s1 ,s2) ,});\\n        }\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n1 = s1.size() , n2 = s2.size();\\n        dp.resize(n1 , vector<int>(n2 , -1));\\n        return dfs(0 , 0 , s1 , s2);\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def remains(self, s, i):\\n        sum_val = 0\\n        for j in range(i, len(s)):\\n            sum_val += ord(s[j])\\n        return sum_val\\n    \\n    def dfs(self, i, j, s1, s2, dp):\\n        if i == len(s1) and j == len(s2):\\n            return 0\\n        if i == len(s1) and j < len(s2):\\n            return self.remains(s2, j)\\n        if j == len(s2) and i < len(s1):\\n            return self.remains(s1, i)\\n        if dp[i][j] != -1:\\n            return dp[i][j]\\n        if s1[i] == s2[j]:\\n            dp[i][j] = self.dfs(i + 1, j + 1, s1, s2, dp)\\n        else:\\n            dp[i][j] = min(ord(s1[i]) + self.dfs(i + 1, j, s1, s2, dp),\\n                           ord(s2[j]) + self.dfs(i, j + 1, s1, s2, dp))\\n        return dp[i][j]\\n    def minimumDeleteSum(self, s1, s2):\\n        n1, n2 = len(s1), len(s2)\\n        dp = [[-1 for _ in range(n2)] for _ in range(n1)]\\n        return self.dfs(0, 0, s1, s2, dp)\\n        \\n```\n```\\nclass Solution {\\n    private int[][] dp;\\n    \\n    private int remains(String s, int i) {\\n        int sum = 0;\\n        for (int j = i; j < s.length(); j++) {\\n            sum += s.charAt(j);\\n        }\\n        return sum;\\n    }\\n    \\n    private int dfs(int i, int j, String s1, String s2) {\\n        if (i == s1.length() && j == s2.length()) return 0;\\n        if (i == s1.length() && j < s2.length()) return remains(s2, j);\\n        if (j == s2.length() && i < s1.length()) return remains(s1, i);\\n        if (dp[i][j] != -1) return dp[i][j];\\n        if (s1.charAt(i) == s2.charAt(j)) {\\n            return dp[i][j] = dfs(i + 1, j + 1, s1, s2);\\n        } else {\\n            return dp[i][j] = Math.min(s1.charAt(i) + dfs(i + 1, j, s1, s2),\\n                                      s2.charAt(j) + dfs(i, j + 1, s1, s2));\\n        }\\n    }\\n    \\n    public int minimumDeleteSum(String s1, String s2) {\\n        int n1 = s1.length();\\n        int n2 = s2.length();\\n        dp = new int[n1][n2];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        return dfs(0, 0, s1, s2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843961,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Intuition\\nUsing dynamic programming to keep minimum ascll numbers.\\nThis Python solution beats 89% and JavaScript beats 100%\\n\\n![Screen Shot 2023-08-01 at 0.16.37.png](https://assets.leetcode.com/users/images/ec767cbc-a77f-4ba9-90da-0e16cb4853d5_1690816649.0512292.png)\\n\\n---\\n\\n# Solution Video\\n## *** Please upvote for this article. *** \\n\\nhttps://youtu.be/l89MVMSnRwU\\n\\n# Subscribe to my channel from here. I have 236 videos as of July 31st\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python solution. Other might be different a bit.\\n\\n1. Initialize two variables `m` and `n` to store the lengths of `s1` and `s2`, respectively.\\n2. Create a list `dp` of size `(n + 1)` and initialize all elements to 0. This list will be used to store the minimum ASCII delete sums for various substrings of `s1` and `s2`.\\n3. Calculate the cumulative sum of ASCII values for the prefix of `s2` and store it in the `dp` list. Starting from `j = 1` to `n`, update `dp[j]` as `dp[j] = dp[j - 1] + ord(s2[j - 1])`. This step ensures that `dp[j]` will contain the cumulative sum of the ASCII values of characters in `s2` up to index `j`.\\n4. Iterate through each character in `s1` using a loop with index `i` from `1` to `m`.\\n5. Inside the loop for each `i`, store the previous value of `dp[0]` in a variable `prev`.\\n6. Update `dp[0]` with the cumulative sum of ASCII values of characters in `s1` up to index `i`. This step accounts for the case where `s1` is shorter than `s2`.\\n7. Now, iterate through each character in `s2` using a loop with index `j` from `1` to `n`.\\n8. Inside the inner loop for each `j`, store the current value of `dp[j]` in a variable `temp`.\\n9. Compare the `i`-th character of `s1` with the `j`-th character of `s2`.\\n10. If the characters match (`s1[i - 1] == s2[j - 1]`), update `dp[j]` with the value of `prev`. This means no deletion is required, and we copy the value from the diagonal cell `dp[i-1][j-1]`.\\n11. If the characters don\\'t match, update `dp[j]` with the minimum of the following two options:\\n    a. Delete `s1[i-1]` and find the minimum delete sum for the remaining substrings `s1[0:i-2]` and `s2[0:j-1]`.\\n    b. Delete `s2[j-1]` and find the minimum delete sum for the remaining substrings `s1[0:i-1]` and `s2[0:j-2]`.\\n12. After updating `dp[j]`, set `prev` back to `temp` to prepare for the next iteration of the inner loop.\\n13. Once both the loops are finished, the final result is stored in `dp[n]`, which represents the minimum ASCII delete sum for the entire strings `s1` and `s2`.\\n14. Return the value of `dp[n]` as the result of the function.\\n\\n# Complexity\\n- Time complexity: O(m * n)\\nm is the length of string s1 and n is the length of string s2. The two nested loops (for i in range(1, m + 1): and for j in range(1, n + 1):) iterate through the dp array, updating each element. Since each loop runs m and n times, respectively, the overall time complexity is O(m * n).\\n\\n- Space complexity: O(n)\\nThe dp array is a one-dimensional array with a length of n + 1. Apart from the dp array, there are no additional data structures being used, so the space complexity is O(n).\\n\\n```python []\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        dp = [0] * (n + 1)\\n\\n        for j in range(1, n + 1):\\n            dp[j] = dp[j - 1] + ord(s2[j - 1])\\n        \\n        for i in range(1, m + 1):\\n            prev = dp[0]\\n            dp[0] += ord(s1[i - 1])\\n\\n            for j in range(1, n + 1):\\n                temp = dp[j]\\n\\n                if s1[i - 1] == s2[j - 1]:\\n                    dp[j] = prev\\n                else:\\n                    dp[j] = min(dp[j] + ord(s1[i - 1]), dp[j - 1] + ord(s2[j - 1]))\\n                \\n                prev = temp\\n        \\n        return dp[n]\\n```\\n```javascript []\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @return {number}\\n */\\nvar minimumDeleteSum = function(s1, s2) {\\n    const m = s1.length;\\n    const n = s2.length;\\n    const dp = new Array(n + 1).fill(0);\\n\\n    for (let j = 1; j <= n; j++) {\\n        dp[j] = dp[j - 1] + s2.charCodeAt(j - 1);\\n    }\\n\\n    for (let i = 1; i <= m; i++) {\\n        let prev = dp[0];\\n        dp[0] += s1.charCodeAt(i - 1);\\n\\n        for (let j = 1; j <= n; j++) {\\n            const temp = dp[j];\\n\\n            if (s1[i - 1] === s2[j - 1]) {\\n                dp[j] = prev;\\n            } else {\\n                dp[j] = Math.min(dp[j] + s1.charCodeAt(i - 1), dp[j - 1] + s2.charCodeAt(j - 1));\\n            }\\n\\n            prev = temp;\\n        }\\n    }\\n\\n    return dp[n];    \\n};\\n```\\n```java []\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        int[] dp = new int[n + 1];\\n\\n        for (int j = 1; j <= n; j++) {\\n            dp[j] = dp[j - 1] + s2.charAt(j - 1);\\n        }\\n\\n        for (int i = 1; i <= m; i++) {\\n            int prev = dp[0];\\n            dp[0] += s1.charAt(i - 1);\\n\\n            for (int j = 1; j <= n; j++) {\\n                int temp = dp[j];\\n\\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n                    dp[j] = prev;\\n                } else {\\n                    dp[j] = Math.min(dp[j] + s1.charAt(i - 1), dp[j - 1] + s2.charAt(j - 1));\\n                }\\n\\n                prev = temp;\\n            }\\n        }\\n\\n        return dp[n];        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        vector<int> dp(n + 1, 0);\\n\\n        for (int j = 1; j <= n; j++) {\\n            dp[j] = dp[j - 1] + s2[j - 1];\\n        }\\n\\n        for (int i = 1; i <= m; i++) {\\n            int prev = dp[0];\\n            dp[0] += s1[i - 1];\\n\\n            for (int j = 1; j <= n; j++) {\\n                int temp = dp[j];\\n\\n                if (s1[i - 1] == s2[j - 1]) {\\n                    dp[j] = prev;\\n                } else {\\n                    dp[j] = min(dp[j] + s1[i - 1], dp[j - 1] + s2[j - 1]);\\n                }\\n\\n                prev = temp;\\n            }\\n        }\\n\\n        return dp[n];        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        dp = [0] * (n + 1)\\n\\n        for j in range(1, n + 1):\\n            dp[j] = dp[j - 1] + ord(s2[j - 1])\\n        \\n        for i in range(1, m + 1):\\n            prev = dp[0]\\n            dp[0] += ord(s1[i - 1])\\n\\n            for j in range(1, n + 1):\\n                temp = dp[j]\\n\\n                if s1[i - 1] == s2[j - 1]:\\n                    dp[j] = prev\\n                else:\\n                    dp[j] = min(dp[j] + ord(s1[i - 1]), dp[j - 1] + ord(s2[j - 1]))\\n                \\n                prev = temp\\n        \\n        return dp[n]\\n```\n```javascript []\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @return {number}\\n */\\nvar minimumDeleteSum = function(s1, s2) {\\n    const m = s1.length;\\n    const n = s2.length;\\n    const dp = new Array(n + 1).fill(0);\\n\\n    for (let j = 1; j <= n; j++) {\\n        dp[j] = dp[j - 1] + s2.charCodeAt(j - 1);\\n    }\\n\\n    for (let i = 1; i <= m; i++) {\\n        let prev = dp[0];\\n        dp[0] += s1.charCodeAt(i - 1);\\n\\n        for (let j = 1; j <= n; j++) {\\n            const temp = dp[j];\\n\\n            if (s1[i - 1] === s2[j - 1]) {\\n                dp[j] = prev;\\n            } else {\\n                dp[j] = Math.min(dp[j] + s1.charCodeAt(i - 1), dp[j - 1] + s2.charCodeAt(j - 1));\\n            }\\n\\n            prev = temp;\\n        }\\n    }\\n\\n    return dp[n];    \\n};\\n```\n```java []\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        int[] dp = new int[n + 1];\\n\\n        for (int j = 1; j <= n; j++) {\\n            dp[j] = dp[j - 1] + s2.charAt(j - 1);\\n        }\\n\\n        for (int i = 1; i <= m; i++) {\\n            int prev = dp[0];\\n            dp[0] += s1.charAt(i - 1);\\n\\n            for (int j = 1; j <= n; j++) {\\n                int temp = dp[j];\\n\\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n                    dp[j] = prev;\\n                } else {\\n                    dp[j] = Math.min(dp[j] + s1.charAt(i - 1), dp[j - 1] + s2.charAt(j - 1));\\n                }\\n\\n                prev = temp;\\n            }\\n        }\\n\\n        return dp[n];        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        vector<int> dp(n + 1, 0);\\n\\n        for (int j = 1; j <= n; j++) {\\n            dp[j] = dp[j - 1] + s2[j - 1];\\n        }\\n\\n        for (int i = 1; i <= m; i++) {\\n            int prev = dp[0];\\n            dp[0] += s1[i - 1];\\n\\n            for (int j = 1; j <= n; j++) {\\n                int temp = dp[j];\\n\\n                if (s1[i - 1] == s2[j - 1]) {\\n                    dp[j] = prev;\\n                } else {\\n                    dp[j] = min(dp[j] + s1[i - 1], dp[j - 1] + s2[j - 1]);\\n                }\\n\\n                prev = temp;\\n            }\\n        }\\n\\n        return dp[n];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 625571,
                "title": "c-top-down-memo-ization",
                "content": "The idea is to use two pointers `i` and `j` to track locations in each string. We walk them down until we hit a case where the letters are not equal. We must delete one, but we don\\'t know which one, so try both.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> memo;\\n    \\n    int dp(string & s1, string & s2, int i, int j) {\\n        \\n        int cost = 0;\\n        \\n        if (memo[i][j] != -1) return memo[i][j];\\n        \\n        if (i == s1.size() && j == s2.size()) {\\n            // done with both strings\\n            cost = 0;   \\n        }\\n    \\n        else if (i == s1.size()) {\\n            // must delete from second string\\n            cost += dp(s1, s2, i, j+1) + s2[j];\\n        }\\n        \\n        else if (j == s2.size()) {\\n            // must delete from first string\\n            cost += dp(s1, s2, i+1, j) + s1[i];\\n        }\\n        \\n        else if (s1[i] == s2[j]) {\\n            // no deletes\\n            cost += dp(s1, s2, i+1, j+1);\\n        }\\n\\n        else {\\n            // chars not equal, try deleting from both\\n            long a = dp(s1, s2, i+1, j) + s1[i];\\n            long b = dp(s1, s2, i, j+1) + s2[j];\\n            cost += min(a, b);\\n        }\\n        \\n        memo[i][j] = cost;\\n\\n        return cost;\\n\\n    }\\n    \\n    int minimumDeleteSum(string s1, string s2) {\\n        memo.resize(s1.size()+1, vector<int>(s2.size()+1, -1));\\n        return dp(s1, s2, 0, 0);       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> memo;\\n    \\n    int dp(string & s1, string & s2, int i, int j) {\\n        \\n        int cost = 0;\\n        \\n        if (memo[i][j] != -1) return memo[i][j];\\n        \\n        if (i == s1.size() && j == s2.size()) {\\n            // done with both strings\\n            cost = 0;   \\n        }\\n    \\n        else if (i == s1.size()) {\\n            // must delete from second string\\n            cost += dp(s1, s2, i, j+1) + s2[j];\\n        }\\n        \\n        else if (j == s2.size()) {\\n            // must delete from first string\\n            cost += dp(s1, s2, i+1, j) + s1[i];\\n        }\\n        \\n        else if (s1[i] == s2[j]) {\\n            // no deletes\\n            cost += dp(s1, s2, i+1, j+1);\\n        }\\n\\n        else {\\n            // chars not equal, try deleting from both\\n            long a = dp(s1, s2, i+1, j) + s1[i];\\n            long b = dp(s1, s2, i, j+1) + s2[j];\\n            cost += min(a, b);\\n        }\\n        \\n        memo[i][j] = cost;\\n\\n        return cost;\\n\\n    }\\n    \\n    int minimumDeleteSum(string s1, string s2) {\\n        memo.resize(s1.size()+1, vector<int>(s2.size()+1, -1));\\n        return dp(s1, s2, 0, 0);       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841733,
                "title": "same-code-as-lcs-with-slight-change",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- In Lcs, one count the length of lcs.\\n- In this ques , one have to count maximum acsii value of lcs(among all lcs) i.e. in normal lcs where one add 1 here add the ascii value of same character present in both the strings.\\n- By finding maximum ascii value of lcs, delete it from total sum of ascii value of both strings, one get minimum ascii value of deleted\\ncharacters.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.length();\\n\\t    int m=s2.length();\\n\\t    vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int i=0;i<n+1;i++)\\n        {\\n            for(int j=0;j<m+1;j++)\\n            {    \\n                if (i==0 || j==0);\\n                {\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        for (int i = 1;i<n+1;i++)\\n        {\\n            for (int j = 1;j<m+1;j++)\\n            {\\n                if (s1[i-1] == s2[j-1])\\n                {\\n                    dp[i][j] = dp[i-1][j-1]+s1[i-1];\\n                }\\n                else\\n                {\\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        cout<<dp[n][m]<<endl;\\n        int sum=0;\\n        for(int i=0;i<n;++i)\\n        {\\n            sum+=s1[i];\\n        }\\n        for(int i=0;i<m;++i)\\n        {\\n            sum+=s2[i];\\n        }\\n        return sum-2*dp[n][m];//twice because lcs will be present in both string\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.length();\\n\\t    int m=s2.length();\\n\\t    vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int i=0;i<n+1;i++)\\n        {\\n            for(int j=0;j<m+1;j++)\\n            {    \\n                if (i==0 || j==0);\\n                {\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        for (int i = 1;i<n+1;i++)\\n        {\\n            for (int j = 1;j<m+1;j++)\\n            {\\n                if (s1[i-1] == s2[j-1])\\n                {\\n                    dp[i][j] = dp[i-1][j-1]+s1[i-1];\\n                }\\n                else\\n                {\\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        cout<<dp[n][m]<<endl;\\n        int sum=0;\\n        for(int i=0;i<n;++i)\\n        {\\n            sum+=s1[i];\\n        }\\n        for(int i=0;i<m;++i)\\n        {\\n            sum+=s2[i];\\n        }\\n        return sum-2*dp[n][m];//twice because lcs will be present in both string\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3840664,
                "title": "easy-dp-minimum-ascii-delete-sum-for-two-strings",
                "content": "First of all, I would like to thank [vanAmsen](https://youtu.be/OT6zcEATv1c) for an excellent video explanation on how to solve this problem. That explanation has been instrumental in helping me understand the solution. For those who are interested in additional implementations, you can find solutions in Rust, Go, Ruby, TypeScript, and Swift in this post.\\n\\n# Intuition\\n\\nThe task at hand is to find the minimum ASCII sum of deleted characters that will make two given strings equal. My initial thought was to use dynamic programming (DP) to solve this. We essentially want to compare every character in one string with every character in the other. If they match, no deletion is required. But if they don\\'t match, we must decide which character to delete. The decision would be based on minimizing the ASCII sum of the deleted characters.\\n\\n# Approach\\n\\nThis problem was solved by using a dynamic programming approach where we initialize a vector `prev_row` with the cumulative ASCII sum of the characters in `s2`. Then for each character in `s1`, we create a new vector `curr_row` and fill it with the minimum ASCII sum obtained either by deleting the current character from `s1` or `s2`, or by not deleting anything if the current characters from both strings are equal. At the end of each iteration, we set `prev_row` to `curr_row` and continue with the next character in `s1`. The last entry in `prev_row` at the end of all iterations will give the minimum ASCII sum of the deleted characters to make `s1` and `s2` equal.\\n\\n# Complexity\\n\\n- Time complexity: The time complexity is O(n * m), where n and m are the lengths of `s1` and `s2`, respectively. This is because we iterate through all characters of both strings.\\n\\n- Space complexity: The space complexity is also O(n * m) as we store the minimum ASCII sum for all combinations of substrings of `s1` and `s2` in the DP table.\\n\\n# Code\\n\\n``` Rust []\\nimpl Solution {\\n    pub fn minimum_delete_sum(s1: String, s2: String) -> i32 {\\n        let mut prev_row = vec![0; s2.len() + 1];\\n        let s1 = s1.chars().collect::<Vec<_>>();\\n        let s2 = s2.chars().collect::<Vec<_>>();\\n\\n        for j in 1..=s2.len() {\\n            prev_row[j] = prev_row[j - 1] + s2[j - 1] as i32;\\n        }\\n\\n        for i in 1..=s1.len() {\\n            let mut curr_row = vec![prev_row[0] + s1[i - 1] as i32];\\n            for j in 1..=s2.len() {\\n                if s1[i - 1] == s2[j - 1] {\\n                    curr_row.push(prev_row[j - 1]);\\n                } else {\\n                    curr_row.push(std::cmp::min(prev_row[j] + s1[i - 1] as i32, curr_row[j - 1] + s2[j - 1] as i32));\\n                }\\n            }\\n            prev_row = curr_row;\\n        }\\n\\n        *prev_row.last().unwrap()\\n    }\\n}\\n```\\n``` Go []\\nfunc minimumDeleteSum(s1 string, s2 string) int {\\n    prev_row := make([]int, len(s2) + 1)\\n    for j := 1; j <= len(s2); j++ {\\n        prev_row[j] = prev_row[j - 1] + int(s2[j - 1])\\n    }\\n\\n    for i := 1; i <= len(s1); i++ {\\n        curr_row := []int{prev_row[0] + int(s1[i - 1])}\\n        for j := 1; j <= len(s2); j++ {\\n            if s1[i - 1] == s2[j - 1] {\\n                curr_row = append(curr_row, prev_row[j - 1])\\n            } else {\\n                curr_row = append(curr_row, min(prev_row[j] + int(s1[i - 1]), curr_row[j - 1] + int(s2[j - 1])))\\n            }\\n        }\\n        prev_row = curr_row\\n    }\\n\\n    return prev_row[len(prev_row) - 1]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```\\n``` Ruby []\\n# @param {String} s1\\n# @param {String} s2\\n# @return {Integer}\\ndef minimum_delete_sum(s1, s2)\\n    prev_row = Array.new(s2.length + 1, 0)\\n    (1..s2.length).each { |j| prev_row[j] = prev_row[j - 1] + s2[j - 1].ord }\\n\\n    (1..s1.length).each do |i|\\n        curr_row = [prev_row[0] + s1[i - 1].ord]\\n        (1..s2.length).each do |j|\\n            if s1[i - 1] == s2[j - 1]\\n                curr_row << prev_row[j - 1]\\n            else\\n                curr_row << [prev_row[j] + s1[i - 1].ord, curr_row[j - 1] + s2[j - 1].ord].min\\n            end\\n        end\\n        prev_row = curr_row\\n    end\\n\\n    prev_row[-1]\\nend\\n```\\n``` TypeScript []\\nfunction minimumDeleteSum(s1: string, s2: string): number {\\n    let prev_row: number[] = new Array(s2.length + 1).fill(0);\\n    for (let j = 1; j <= s2.length; j++) {\\n        prev_row[j] = prev_row[j - 1] + s2.charCodeAt(j - 1);\\n    }\\n\\n    for (let i = 1; i <= s1.length; i++) {\\n        let curr_row: number[] = [prev_row[0] + s1.charCodeAt(i - 1)];\\n        for (let j = 1; j <= s2.length; j++) {\\n            if (s1[i - 1] === s2[j - 1]) {\\n                curr_row.push(prev_row[j - 1]);\\n            } else {\\n                curr_row.push(Math.min(prev_row[j] + s1.charCodeAt(i - 1), curr_row[j - 1] + s2.charCodeAt(j - 1)));\\n            }\\n        }\\n        prev_row = curr_row;\\n    }\\n\\n    return prev_row[prev_row.length - 1];\\n}\\n```\\n``` Swift []\\nclass Solution {\\n    func minimumDeleteSum(_ s1: String, _ s2: String) -> Int {\\n        var prevRow = [Int](repeating: 0, count: s2.count + 1)\\n        let s1 = Array(s1.unicodeScalars)\\n        let s2 = Array(s2.unicodeScalars)\\n        \\n        for j in 1...s2.count {\\n            prevRow[j] = prevRow[j - 1] + Int(s2[j - 1].value)\\n        }\\n\\n        for i in 1...s1.count {\\n            var currRow = [prevRow[0] + Int(s1[i - 1].value)]\\n            for j in 1...s2.count {\\n                if s1[i - 1] == s2[j - 1] {\\n                    currRow.append(prevRow[j - 1])\\n                } else {\\n                    currRow.append(min(prevRow[j] + Int(s1[i - 1].value), currRow[j - 1] + Int(s2[j - 1].value)))\\n                }\\n            }\\n            prevRow = currRow\\n        }\\n        return prevRow.last!\\n    }\\n}\\n```\\nI hope this walkthrough helps you understand how to solve this problem. If you have any questions or comments, please feel free to share them!",
                "solutionTags": [
                    "Ruby",
                    "Swift",
                    "Go",
                    "Rust",
                    "TypeScript"
                ],
                "code": "``` Rust []\\nimpl Solution {\\n    pub fn minimum_delete_sum(s1: String, s2: String) -> i32 {\\n        let mut prev_row = vec![0; s2.len() + 1];\\n        let s1 = s1.chars().collect::<Vec<_>>();\\n        let s2 = s2.chars().collect::<Vec<_>>();\\n\\n        for j in 1..=s2.len() {\\n            prev_row[j] = prev_row[j - 1] + s2[j - 1] as i32;\\n        }\\n\\n        for i in 1..=s1.len() {\\n            let mut curr_row = vec![prev_row[0] + s1[i - 1] as i32];\\n            for j in 1..=s2.len() {\\n                if s1[i - 1] == s2[j - 1] {\\n                    curr_row.push(prev_row[j - 1]);\\n                } else {\\n                    curr_row.push(std::cmp::min(prev_row[j] + s1[i - 1] as i32, curr_row[j - 1] + s2[j - 1] as i32));\\n                }\\n            }\\n            prev_row = curr_row;\\n        }\\n\\n        *prev_row.last().unwrap()\\n    }\\n}\\n```\n``` Go []\\nfunc minimumDeleteSum(s1 string, s2 string) int {\\n    prev_row := make([]int, len(s2) + 1)\\n    for j := 1; j <= len(s2); j++ {\\n        prev_row[j] = prev_row[j - 1] + int(s2[j - 1])\\n    }\\n\\n    for i := 1; i <= len(s1); i++ {\\n        curr_row := []int{prev_row[0] + int(s1[i - 1])}\\n        for j := 1; j <= len(s2); j++ {\\n            if s1[i - 1] == s2[j - 1] {\\n                curr_row = append(curr_row, prev_row[j - 1])\\n            } else {\\n                curr_row = append(curr_row, min(prev_row[j] + int(s1[i - 1]), curr_row[j - 1] + int(s2[j - 1])))\\n            }\\n        }\\n        prev_row = curr_row\\n    }\\n\\n    return prev_row[len(prev_row) - 1]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```\n``` Ruby []\\n# @param {String} s1\\n# @param {String} s2\\n# @return {Integer}\\ndef minimum_delete_sum(s1, s2)\\n    prev_row = Array.new(s2.length + 1, 0)\\n    (1..s2.length).each { |j| prev_row[j] = prev_row[j - 1] + s2[j - 1].ord }\\n\\n    (1..s1.length).each do |i|\\n        curr_row = [prev_row[0] + s1[i - 1].ord]\\n        (1..s2.length).each do |j|\\n            if s1[i - 1] == s2[j - 1]\\n                curr_row << prev_row[j - 1]\\n            else\\n                curr_row << [prev_row[j] + s1[i - 1].ord, curr_row[j - 1] + s2[j - 1].ord].min\\n            end\\n        end\\n        prev_row = curr_row\\n    end\\n\\n    prev_row[-1]\\nend\\n```\n``` TypeScript []\\nfunction minimumDeleteSum(s1: string, s2: string): number {\\n    let prev_row: number[] = new Array(s2.length + 1).fill(0);\\n    for (let j = 1; j <= s2.length; j++) {\\n        prev_row[j] = prev_row[j - 1] + s2.charCodeAt(j - 1);\\n    }\\n\\n    for (let i = 1; i <= s1.length; i++) {\\n        let curr_row: number[] = [prev_row[0] + s1.charCodeAt(i - 1)];\\n        for (let j = 1; j <= s2.length; j++) {\\n            if (s1[i - 1] === s2[j - 1]) {\\n                curr_row.push(prev_row[j - 1]);\\n            } else {\\n                curr_row.push(Math.min(prev_row[j] + s1.charCodeAt(i - 1), curr_row[j - 1] + s2.charCodeAt(j - 1)));\\n            }\\n        }\\n        prev_row = curr_row;\\n    }\\n\\n    return prev_row[prev_row.length - 1];\\n}\\n```\n``` Swift []\\nclass Solution {\\n    func minimumDeleteSum(_ s1: String, _ s2: String) -> Int {\\n        var prevRow = [Int](repeating: 0, count: s2.count + 1)\\n        let s1 = Array(s1.unicodeScalars)\\n        let s2 = Array(s2.unicodeScalars)\\n        \\n        for j in 1...s2.count {\\n            prevRow[j] = prevRow[j - 1] + Int(s2[j - 1].value)\\n        }\\n\\n        for i in 1...s1.count {\\n            var currRow = [prevRow[0] + Int(s1[i - 1].value)]\\n            for j in 1...s2.count {\\n                if s1[i - 1] == s2[j - 1] {\\n                    currRow.append(prevRow[j - 1])\\n                } else {\\n                    currRow.append(min(prevRow[j] + Int(s1[i - 1].value), currRow[j - 1] + Int(s2[j - 1].value)))\\n                }\\n            }\\n            prevRow = currRow\\n        }\\n        return prevRow.last!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840645,
                "title": "c-several-recursive-iterative-dp-lcs-beats-94-62",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a question closed to find the longest common subsequence (LCS)!\\n[1143. Longest Common Subsequence\\n](https://leetcode.com/problems/longest-common-subsequence/solutions/3841276/c-recursive-iterative-dp-solutions/)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[Please Turn on English subtitles if neccessary]\\n[https://youtu.be/0jW2q0L8Fw4](https://youtu.be/0jW2q0L8Fw4)\\nIn 2nd approach, we used the usual process for LCS to compute the ascii sum for LCS. Use the following formula\\n$$\\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2\\\\times asciiSum(LCS)\\n$$\\nwhich is very similar to the bascic property for finite sets\\n$$\\n|difference \\\\ set|=|union|-|interesection|\\\\\\\\\\n=|s1|+|s2|-2|LCS|\\n$$\\nDue to fewer numbers of if-clauses, the speed is slight faster.\\n\\nThe 3rd solution is an iterative buttom up solution which beats 94.62%!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n1\\\\cdot n2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n1\\\\cdot n2)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string w1, w2;\\n    int n1, n2;\\n    vector<vector<int>> dp;\\n    \\n    int lcs(int x, int y){\\n        if (dp[x][y] != INT_MAX) return dp[x][y];\\n        if (x == n1 && y == n2) return dp[x][y] = 0;\\n        if (x == n1) return dp[x][y] = w2[y] + lcs(x, y+1);\\n        if (y == n2) return dp[x][y] = w1[x] + lcs(x+1, y);\\n        \\n        int sum;\\n        if (w1[x] == w2[y]) \\n            sum = lcs(x+1, y+1);\\n        else \\n            sum = min(lcs(x+1, y) + w1[x], lcs(x, y+1) + w2[y]);\\n        \\n        return dp[x][y] = sum;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        n1 = s1.size();\\n        n2 = s2.size();\\n        w1 = s1;\\n        w2 = s2;\\n        dp.assign(n1+1, vector<int>(n2+1, INT_MAX));\\n        \\n        return lcs(0, 0);\\n    }\\n};\\n\\n\\n```\\n# Code for 2nd Approach\\n```\\nclass Solution {\\npublic:\\n    string w1, w2;\\n    int n1, n2;\\n    vector<vector<int>> dp;\\n    \\n    int LCS(int x, int y){//Find the ASCII sum in LCS\\n        if (x == n1 || y == n2) return 0;\\n        if (dp[x][y] != INT_MAX) return dp[x][y];     \\n        int sum;\\n        if (w1[x] == w2[y]) \\n            sum = w1[x]+LCS(x+1, y+1);\\n        else \\n            sum = max(LCS(x+1, y), LCS(x, y+1));\\n        \\n        return dp[x][y] = sum;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        n1 = s1.size();\\n        n2 = s2.size();\\n        w1 = s1;\\n        w2 = s2;\\n        dp.assign(n1, vector<int>(n2, INT_MAX));\\n        int AsciiSum=0;\\n        for(char c: w1) AsciiSum+=c;\\n        for(char c: w2) AsciiSum+=c;\\n        return AsciiSum-2*LCS(0, 0);\\n    }\\n};\\n\\n```\\n# Code with Explanation in Comments for 2nd Approach\\n```\\nclass Solution {\\npublic:\\n    string w1, w2;\\n    int n1, n2;\\n    vector<vector<int>> dp;\\n\\n    // Function to find the ASCII sum in the Longest Common Subsequence (LCS) of two strings\\n    int LCS(int x, int y){\\n        // Base case: if either of the two strings has been fully processed, return 0 (no common characters)\\n        if (x == n1 || y == n2) return 0;\\n\\n        // Check if the LCS value for this position has been previously calculated\\n        if (dp[x][y] != INT_MAX) return dp[x][y];\\n\\n        int sum;\\n        if (w1[x] == w2[y]) {\\n            // If the characters match, include the ASCII value of this character in the LCS sum\\n            sum = w1[x] + LCS(x+1, y+1);\\n        } else {\\n            // If the characters do not match, try both possible options:\\n            // 1. Skip the current character in the first string (move to the next character in the first string)\\n            // 2. Skip the current character in the second string (move to the next character in the second string)\\n            // Choose the option that gives the maximum LCS sum.\\n            sum = max(LCS(x+1, y), LCS(x, y+1));\\n        }\\n\\n        // Store the LCS sum for this position to avoid recalculating it in the future.\\n        return dp[x][y] = sum;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        // Initialize variables and arrays\\n        n1 = s1.size();\\n        n2 = s2.size();\\n        w1 = s1;\\n        w2 = s2;\\n        dp.assign(n1, vector<int>(n2, INT_MAX));\\n\\n        // Calculate the ASCII sum of both strings\\n        int AsciiSum = 0;\\n        for(char c: w1) AsciiSum += c;\\n        for(char c: w2) AsciiSum += c;\\n\\n        // Calculate the ASCII sum of both strings minus twice the ASCII sum of the LCS.\\n        // The result will be the minimum ASCII deletion sum required to make the two strings equal.\\n        return AsciiSum - 2 * LCS(0, 0);\\n    }\\n};\\n\\n```\\n# Code for iterative solution with optimised TC=O(min(n1, n2))\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        if (n1<n2){\\n            swap(s1, s2);\\n            swap(n1, n2);\\n        }\\n        vector<int> dp(n2+1, 0), prev(n2+1, 0);\\n\\n        for (int x = n1-1; x >= 0; x--) {\\n            for (int y = n2-1; y >= 0; y--) {\\n                if (s1[x] == s2[y])\\n                    dp[y] = s1[x] + prev[y+1];\\n                else\\n                    dp[y] = max(prev[y], dp[y+1]);\\n            }\\n            prev=dp;\\n        }\\n\\n        int AsciiSum = 0;\\n        for (char c : s1) AsciiSum += c;\\n        for (char c : s2) AsciiSum += c;\\n\\n        return AsciiSum - 2*dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string w1, w2;\\n    int n1, n2;\\n    vector<vector<int>> dp;\\n    \\n    int lcs(int x, int y){\\n        if (dp[x][y] != INT_MAX) return dp[x][y];\\n        if (x == n1 && y == n2) return dp[x][y] = 0;\\n        if (x == n1) return dp[x][y] = w2[y] + lcs(x, y+1);\\n        if (y == n2) return dp[x][y] = w1[x] + lcs(x+1, y);\\n        \\n        int sum;\\n        if (w1[x] == w2[y]) \\n            sum = lcs(x+1, y+1);\\n        else \\n            sum = min(lcs(x+1, y) + w1[x], lcs(x, y+1) + w2[y]);\\n        \\n        return dp[x][y] = sum;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        n1 = s1.size();\\n        n2 = s2.size();\\n        w1 = s1;\\n        w2 = s2;\\n        dp.assign(n1+1, vector<int>(n2+1, INT_MAX));\\n        \\n        return lcs(0, 0);\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    string w1, w2;\\n    int n1, n2;\\n    vector<vector<int>> dp;\\n    \\n    int LCS(int x, int y){//Find the ASCII sum in LCS\\n        if (x == n1 || y == n2) return 0;\\n        if (dp[x][y] != INT_MAX) return dp[x][y];     \\n        int sum;\\n        if (w1[x] == w2[y]) \\n            sum = w1[x]+LCS(x+1, y+1);\\n        else \\n            sum = max(LCS(x+1, y), LCS(x, y+1));\\n        \\n        return dp[x][y] = sum;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        n1 = s1.size();\\n        n2 = s2.size();\\n        w1 = s1;\\n        w2 = s2;\\n        dp.assign(n1, vector<int>(n2, INT_MAX));\\n        int AsciiSum=0;\\n        for(char c: w1) AsciiSum+=c;\\n        for(char c: w2) AsciiSum+=c;\\n        return AsciiSum-2*LCS(0, 0);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    string w1, w2;\\n    int n1, n2;\\n    vector<vector<int>> dp;\\n\\n    // Function to find the ASCII sum in the Longest Common Subsequence (LCS) of two strings\\n    int LCS(int x, int y){\\n        // Base case: if either of the two strings has been fully processed, return 0 (no common characters)\\n        if (x == n1 || y == n2) return 0;\\n\\n        // Check if the LCS value for this position has been previously calculated\\n        if (dp[x][y] != INT_MAX) return dp[x][y];\\n\\n        int sum;\\n        if (w1[x] == w2[y]) {\\n            // If the characters match, include the ASCII value of this character in the LCS sum\\n            sum = w1[x] + LCS(x+1, y+1);\\n        } else {\\n            // If the characters do not match, try both possible options:\\n            // 1. Skip the current character in the first string (move to the next character in the first string)\\n            // 2. Skip the current character in the second string (move to the next character in the second string)\\n            // Choose the option that gives the maximum LCS sum.\\n            sum = max(LCS(x+1, y), LCS(x, y+1));\\n        }\\n\\n        // Store the LCS sum for this position to avoid recalculating it in the future.\\n        return dp[x][y] = sum;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        // Initialize variables and arrays\\n        n1 = s1.size();\\n        n2 = s2.size();\\n        w1 = s1;\\n        w2 = s2;\\n        dp.assign(n1, vector<int>(n2, INT_MAX));\\n\\n        // Calculate the ASCII sum of both strings\\n        int AsciiSum = 0;\\n        for(char c: w1) AsciiSum += c;\\n        for(char c: w2) AsciiSum += c;\\n\\n        // Calculate the ASCII sum of both strings minus twice the ASCII sum of the LCS.\\n        // The result will be the minimum ASCII deletion sum required to make the two strings equal.\\n        return AsciiSum - 2 * LCS(0, 0);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        if (n1<n2){\\n            swap(s1, s2);\\n            swap(n1, n2);\\n        }\\n        vector<int> dp(n2+1, 0), prev(n2+1, 0);\\n\\n        for (int x = n1-1; x >= 0; x--) {\\n            for (int y = n2-1; y >= 0; y--) {\\n                if (s1[x] == s2[y])\\n                    dp[y] = s1[x] + prev[y+1];\\n                else\\n                    dp[y] = max(prev[y], dp[y+1]);\\n            }\\n            prev=dp;\\n        }\\n\\n        int AsciiSum = 0;\\n        for (char c : s1) AsciiSum += c;\\n        for (char c : s2) AsciiSum += c;\\n\\n        return AsciiSum - 2*dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746352,
                "title": "recursive-topdown-bottomup-solution",
                "content": "```\\n// recursive\\nint minimum(string a, string b, int m, int n){\\n    if(m==0 && n==0){\\n        return 0;\\n    } \\n    else if(m<=0){\\n        return (int)b[n-1] + minimum(a, b, m, n-1);\\n    }\\n    else if(n<=0){\\n        return (int)a[m-1] + minimum(a, b, m-1, n);\\n    } \\n    else{\\n        if(a[m-1] == b[n-1]){\\n            return minimum(a, b, m-1, n-1);\\n        } else {\\n            return min(\\n                a[m-1]+minimum(a, b, m-1, n), \\n                b[n-1]+minimum(a, b, m, n-1)\\n            );\\n        }\\n    }\\n}\\n // top down\\n int minimumTopDown(string a, string b, int m, int n, vector<vector<int>>& res){\\n    if(res[m][n] != -1){\\n        return res[m][n];\\n    } else if(m==0 && n==0){\\n        return res[m][n] = 0;\\n    } else if(m==0){\\n        return res[m][n] = (int)b[n-1] + minimumTopDown(a, b, m, n-1, res);\\n    } else if(n==0){\\n        return res[m][n] = (int)a[m-1] + minimumTopDown(a, b, m-1, n, res);\\n    } else {\\n        if(a[m-1]==b[n-1]){\\n            return res[m][n] = minimumTopDown(a, b, m-1, n-1, res);\\n        } else {\\n            return res[m][n] = min(\\n                a[m-1]+minimumTopDown(a, b, m-1, n, res),\\n                b[n-1]+minimumTopDown(a, b, m, n-1, res)    \\n            );\\n        }\\n    }\\n }\\n\\n// botttom up\\nint minimumBottomUp(string a, string b, int m, int n){\\n    int res[m+1][n+1];\\n    for(int i=0; i<=m; i++){\\n        for(int j=0; j<=n; j++){\\n            if(i==0 && j==0){\\n                res[i][j] = 0;\\n            } else if(i<=0 && j>=0){\\n                res[i][j] = (int)b[j-1] + res[i][j-1];\\n            } else if(j<=0 && i>0) {\\n                res[i][j] = (int)a[i-1] + res[i-1][j];\\n            } else {\\n                if(a[i-1]==b[j-1]){\\n                    res[i][j] = res[i-1][j-1];\\n                } else {\\n                    res[i][j] = min(a[i-1]+res[i-1][j], b[j-1]+res[i][j-1]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res[m][n];\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// recursive\\nint minimum(string a, string b, int m, int n){\\n    if(m==0 && n==0){\\n        return 0;\\n    } \\n    else if(m<=0){\\n        return (int)b[n-1] + minimum(a, b, m, n-1);\\n    }\\n    else if(n<=0){\\n        return (int)a[m-1] + minimum(a, b, m-1, n);\\n    } \\n    else{\\n        if(a[m-1] == b[n-1]){\\n            return minimum(a, b, m-1, n-1);\\n        } else {\\n            return min(\\n                a[m-1]+minimum(a, b, m-1, n), \\n                b[n-1]+minimum(a, b, m, n-1)\\n            );\\n        }\\n    }\\n}\\n // top down\\n int minimumTopDown(string a, string b, int m, int n, vector<vector<int>>& res){\\n    if(res[m][n] != -1){\\n        return res[m][n];\\n    } else if(m==0 && n==0){\\n        return res[m][n] = 0;\\n    } else if(m==0){\\n        return res[m][n] = (int)b[n-1] + minimumTopDown(a, b, m, n-1, res);\\n    } else if(n==0){\\n        return res[m][n] = (int)a[m-1] + minimumTopDown(a, b, m-1, n, res);\\n    } else {\\n        if(a[m-1]==b[n-1]){\\n            return res[m][n] = minimumTopDown(a, b, m-1, n-1, res);\\n        } else {\\n            return res[m][n] = min(\\n                a[m-1]+minimumTopDown(a, b, m-1, n, res),\\n                b[n-1]+minimumTopDown(a, b, m, n-1, res)    \\n            );\\n        }\\n    }\\n }\\n\\n// botttom up\\nint minimumBottomUp(string a, string b, int m, int n){\\n    int res[m+1][n+1];\\n    for(int i=0; i<=m; i++){\\n        for(int j=0; j<=n; j++){\\n            if(i==0 && j==0){\\n                res[i][j] = 0;\\n            } else if(i<=0 && j>=0){\\n                res[i][j] = (int)b[j-1] + res[i][j-1];\\n            } else if(j<=0 && i>0) {\\n                res[i][j] = (int)a[i-1] + res[i-1][j];\\n            } else {\\n                if(a[i-1]==b[j-1]){\\n                    res[i][j] = res[i-1][j-1];\\n                } else {\\n                    res[i][j] = min(a[i-1]+res[i-1][j], b[j-1]+res[i][j-1]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res[m][n];\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3841131,
                "title": "easy-c-recursion-memoization-tabulation",
                "content": "# Intuition\\nI tried applying LCS by reading the given test cases.\\n\\n# Approach\\nWe try to find the max ascii value of the LCS and then subtract that from the total ascii values of the two strings which gives us the minimum required value.\\n\\n# Complexity\\n- Time complexity:\\nRecursion: O(2 ^ min(m, n))\\nMemoization: O(n * m);\\nTabulation: O(n * m);\\n\\n# Recursion(TLE!!!!)\\n```\\nclass Solution {\\npublic:\\n    int f(int m, int n, string s1, string s2) {\\n        if(m == 0 || n == 0) return 0;\\n\\n        if(s1[m-1] == s2[n-1]) return 2 * int(s1[m-1]) + f(m-1, n-1, s1, s2);\\n\\n        return max(f(m-1, n, s1, s2), f(m, n-1, s1, s2));\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        int k = 0;\\n        \\n        for(int i=0; i<m; i++){\\n            k += int(s1[i]);\\n        }\\n        for(int i=0; i<n; i++){\\n            k += int(s2[i]);\\n        }\\n        return k - f(m, n, s1, s2);\\n    }\\n};\\n```\\n# Memoization(MLE!!!)\\n```\\nclass Solution {\\npublic:\\n    int f(int m, int n, string s1, string s2, vector<vector<int>>& dp) {\\n        if(m == 0 || n == 0) return 0;\\n        if(dp[m][n] != -1) return dp[m][n];\\n        if(s1[m-1] == s2[n-1]) return dp[m][n] = 2 * int(s1[m-1]) + f(m-1, n-1, s1, s2, dp);\\n\\n        return dp[m][n] = max(f(m-1, n, s1, s2, dp), f(m, n-1, s1, s2, dp));\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        int k = 0;\\n\\n        for(int i=0; i<m; i++){\\n            k += int(s1[i]);\\n        }\\n        for(int i=0; i<n; i++){\\n            k += int(s2[i]);\\n        }\\n        return k - f(m, n, s1, s2, dp);\\n    }\\n};\\n```\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1,0));\\n        int k = 0;\\n\\n        for(int i=0; i<m; i++){\\n            k += int(s1[i]);\\n        }\\n        for(int i=0; i<n; i++){\\n            k += int(s2[i]);\\n        }\\n\\n        for(int i=1; i<=m; i++){\\n            for(int j=1; j<=n; j++){\\n                if(s1[i-1] == s2[j-1]) dp[i][j] = 2 * int(s1[i-1]) + dp[i-1][j-1];\\n                else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        return k - dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int m, int n, string s1, string s2) {\\n        if(m == 0 || n == 0) return 0;\\n\\n        if(s1[m-1] == s2[n-1]) return 2 * int(s1[m-1]) + f(m-1, n-1, s1, s2);\\n\\n        return max(f(m-1, n, s1, s2), f(m, n-1, s1, s2));\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        int k = 0;\\n        \\n        for(int i=0; i<m; i++){\\n            k += int(s1[i]);\\n        }\\n        for(int i=0; i<n; i++){\\n            k += int(s2[i]);\\n        }\\n        return k - f(m, n, s1, s2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int m, int n, string s1, string s2, vector<vector<int>>& dp) {\\n        if(m == 0 || n == 0) return 0;\\n        if(dp[m][n] != -1) return dp[m][n];\\n        if(s1[m-1] == s2[n-1]) return dp[m][n] = 2 * int(s1[m-1]) + f(m-1, n-1, s1, s2, dp);\\n\\n        return dp[m][n] = max(f(m-1, n, s1, s2, dp), f(m, n-1, s1, s2, dp));\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        int k = 0;\\n\\n        for(int i=0; i<m; i++){\\n            k += int(s1[i]);\\n        }\\n        for(int i=0; i<n; i++){\\n            k += int(s2[i]);\\n        }\\n        return k - f(m, n, s1, s2, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1,0));\\n        int k = 0;\\n\\n        for(int i=0; i<m; i++){\\n            k += int(s1[i]);\\n        }\\n        for(int i=0; i<n; i++){\\n            k += int(s2[i]);\\n        }\\n\\n        for(int i=1; i<=m; i++){\\n            for(int j=1; j<=n; j++){\\n                if(s1[i-1] == s2[j-1]) dp[i][j] = 2 * int(s1[i-1]) + dp[i-1][j-1];\\n                else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        return k - dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840867,
                "title": "c-lcs-2-subapproach-credits-to-aditya-verma",
                "content": "**Approach 1**:\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s, string t) \\n    {\\n        vector<vector<int>>  dp(s.size()+1,vector<int>(t.size()+1,INT_MAX));\\n        dp[0][0]=0;\\n        for(int i=1;i<t.size()+1;i++)\\n            dp[0][i]=dp[0][i-1]+t[i-1];\\n        for(int i=1;i<s.size()+1;i++)\\n            dp[i][0]=dp[i-1][0]+s[i-1];\\n        for(int i=1;i<s.size()+1;i++)\\n        {\\n            for(int j=1;j<t.size()+1;j++)\\n            {\\n                if(s[i-1]==t[j-1])\\n                {\\n                    dp[i][j]=dp[i-1][j-1];\\n                }\\n                else\\n                {\\n                        dp[i][j]=min({dp[i][j-1]+t[j-1],dp[i-1][j]+s[i-1]}); \\n                }\\n            }\\n        }\\n        return dp.back().back();\\n    }\\n};\\n```\\n**Approach 2**\\n```\\n// removal of LCS two times from combination of two strings leads to left only uncommon subsequence of s1 and s2;\\n// total weight of string 1+ total weight of string 2 - 2* total weight of  longest common subsequence(lcs) of both the strings\\n//now just we have to calculate weights of s1 and s2 and LCS\\n\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int dp[s1.size()+1][s2.size()+1];\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<s1.size();i++)\\n        {\\n            sum1+=s1[i];\\n        }\\n        for(int j=0;j<s2.size();j++)\\n        {\\n            sum2+=s2[j];\\n        }\\n\\t\\tfor(int i=0;i<s1.size()+1;i++)\\n        {\\n\\t\\t    dp[i][0]=0;\\n\\t\\t}\\n         for(int j=0;j<s2.size()+1;j++)\\n          {\\n\\t\\t\\tdp[0][i]=0;\\n\\t\\t\\t}\\n        for(int i=1;i<s1.size()+1;i++)\\n        {\\n            for(int j=1;j<s2.size()+1;j++)\\n            {\\n                    if(s1[i-1]==s2[j-1])\\n                    {\\n                        dp[i][j]=s1[i-1]+dp[i-1][j-1];\\n                    }else\\n                    {\\n                        dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                    }\\n            }\\n        }\\n        return sum1+sum2-2*dp[s1.size()][s2.size()];\\n        \\n    }\\n};\\n```\\ncredits:) to Aditya Verma\\nThanks for UPVOTING",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s, string t) \\n    {\\n        vector<vector<int>>  dp(s.size()+1,vector<int>(t.size()+1,INT_MAX));\\n        dp[0][0]=0;\\n        for(int i=1;i<t.size()+1;i++)\\n            dp[0][i]=dp[0][i-1]+t[i-1];\\n        for(int i=1;i<s.size()+1;i++)\\n            dp[i][0]=dp[i-1][0]+s[i-1];\\n        for(int i=1;i<s.size()+1;i++)\\n        {\\n            for(int j=1;j<t.size()+1;j++)\\n            {\\n                if(s[i-1]==t[j-1])\\n                {\\n                    dp[i][j]=dp[i-1][j-1];\\n                }\\n                else\\n                {\\n                        dp[i][j]=min({dp[i][j-1]+t[j-1],dp[i-1][j]+s[i-1]}); \\n                }\\n            }\\n        }\\n        return dp.back().back();\\n    }\\n};\\n```\n```\\n// removal of LCS two times from combination of two strings leads to left only uncommon subsequence of s1 and s2;\\n// total weight of string 1+ total weight of string 2 - 2* total weight of  longest common subsequence(lcs) of both the strings\\n//now just we have to calculate weights of s1 and s2 and LCS\\n\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int dp[s1.size()+1][s2.size()+1];\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<s1.size();i++)\\n        {\\n            sum1+=s1[i];\\n        }\\n        for(int j=0;j<s2.size();j++)\\n        {\\n            sum2+=s2[j];\\n        }\\n\\t\\tfor(int i=0;i<s1.size()+1;i++)\\n        {\\n\\t\\t    dp[i][0]=0;\\n\\t\\t}\\n         for(int j=0;j<s2.size()+1;j++)\\n          {\\n\\t\\t\\tdp[0][i]=0;\\n\\t\\t\\t}\\n        for(int i=1;i<s1.size()+1;i++)\\n        {\\n            for(int j=1;j<s2.size()+1;j++)\\n            {\\n                    if(s1[i-1]==s2[j-1])\\n                    {\\n                        dp[i][j]=s1[i-1]+dp[i-1][j-1];\\n                    }else\\n                    {\\n                        dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                    }\\n            }\\n        }\\n        return sum1+sum2-2*dp[s1.size()][s2.size()];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840812,
                "title": "c-tabulation-similar-to-longest-common-subsequence",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.length(), m=s2.length();\\n        \\n        vector<vector<int>> dp(n+1,vector<int>(m+1,INT_MAX/2));\\n        \\n        dp[0][0]=0;\\n        \\n        // cost when s2 = \"\"\\n        for(int i=1;i<n+1;i++){\\n            dp[i][0]=dp[i-1][0]+s1[i-1]-\\'a\\'+97;\\n        }\\n        \\n        // cost when s1 = \"\"\\n        for(int j=1;j<m+1;j++){\\n            dp[0][j]=dp[0][j-1]+s2[j-1]-\\'a\\'+97;\\n        }\\n        \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(s1[i-1] == s2[j-1]){\\n                    dp[i][j]=dp[i-1][j-1]; // cost of subsequence [i,j] = [i-1,j-1]\\n                }else{\\n                    int delete_s1 = s1[i-1]-\\'a\\'+97 + dp[i-1][j]; // cost of subsequence [i,j] = ASCII(ith char) + [i-1,j]\\n                    int delete_s2 = s2[j-1]-\\'a\\'+97 + dp[i][j-1]; // cost of subsequence [i,j] = ASCII(jth char) + [i,j-1]\\n                    \\n                    dp[i][j]=min(delete_s1, delete_s2);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.length(), m=s2.length();\\n        \\n        vector<vector<int>> dp(n+1,vector<int>(m+1,INT_MAX/2));\\n        \\n        dp[0][0]=0;\\n        \\n        // cost when s2 = \"\"\\n        for(int i=1;i<n+1;i++){\\n            dp[i][0]=dp[i-1][0]+s1[i-1]-\\'a\\'+97;\\n        }\\n        \\n        // cost when s1 = \"\"\\n        for(int j=1;j<m+1;j++){\\n            dp[0][j]=dp[0][j-1]+s2[j-1]-\\'a\\'+97;\\n        }\\n        \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(s1[i-1] == s2[j-1]){\\n                    dp[i][j]=dp[i-1][j-1]; // cost of subsequence [i,j] = [i-1,j-1]\\n                }else{\\n                    int delete_s1 = s1[i-1]-\\'a\\'+97 + dp[i-1][j]; // cost of subsequence [i,j] = ASCII(ith char) + [i-1,j]\\n                    int delete_s2 = s2[j-1]-\\'a\\'+97 + dp[i][j-1]; // cost of subsequence [i,j] = ASCII(jth char) + [i,j-1]\\n                    \\n                    dp[i][j]=min(delete_s1, delete_s2);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840763,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        n=len(s1)\\n        m=len(s2)\\n        dp=[[0 for x in range(m+1)] for x in range(n+1)]\\n        for i in range(1,n+1):\\n            dp[i][0]=dp[i-1][0]+ord(s1[i-1])\\n\\n        for i in range(1,m+1):\\n            dp[0][i]=dp[0][i-1]+ord(s2[i-1])\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if s1[i-1]==s2[j-1]:\\n                    dp[i][j]=dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=min(dp[i-1][j]+ord(s1[i-1]),dp[i][j-1]+ord(s2[j-1]))\\n\\n        return dp[n][m]                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        n=len(s1)\\n        m=len(s2)\\n        dp=[[0 for x in range(m+1)] for x in range(n+1)]\\n        for i in range(1,n+1):\\n            dp[i][0]=dp[i-1][0]+ord(s1[i-1])\\n\\n        for i in range(1,m+1):\\n            dp[0][i]=dp[0][i-1]+ord(s2[i-1])\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if s1[i-1]==s2[j-1]:\\n                    dp[i][j]=dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=min(dp[i-1][j]+ord(s1[i-1]),dp[i][j-1]+ord(s2[j-1]))\\n\\n        return dp[n][m]                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691062,
                "title": "just-changed-1-line-in-lcs-code-to-get-this-code-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        // insted of finding LCS find Subsequence with max ASKII sum.\\n        int maxASCIIsum = LongestCommonSubSeqTebu(s1, s2);\\n        // just find the cost of deleting all other chars then in maxASCIIsum\\n        int ASCIIs1 = 0;\\n        int ASCIIs2 = 0;\\n        for(auto i : s1)\\n            ASCIIs1 += (int)i;\\n        for(auto i : s2)\\n            ASCIIs2 += (int)i;\\n        \\n        return ASCIIs1 + ASCIIs2 - (2 * maxASCIIsum);\\n    }\\n    \\n    int LongestCommonSubSeqTebu(string a, string b) {\\n        vector<vector<int>> dp(a.size()+1, vector<int>(b.size()+1));\\n\\n        // inn\\n        for(int i = 0; i < dp.size(); i++)  \\n            dp[i][0] = 0; \\n        for(int i = 0; i <= b.size(); i++)      \\n            dp[0][i] = 0;\\n\\n\\n        // other table\\n        for(int i = 1; i <= a.size() ; i++){\\n            for(int j = 1; j <= b.size(); j++) {\\n                if(a[i - 1] == b[j - 1])\\n                    dp[i][j] = (int)a[i-1] + dp[i-1][j-1];    // only modification is in this line, in LCS code we have 1 + dp[i-1][j-1];;\\n                else    \\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n\\n        return dp.back().back();\\n\\n    }   \\n    \\n    \\n    \\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        // insted of finding LCS find Subsequence with max ASKII sum.\\n        int maxASCIIsum = LongestCommonSubSeqTebu(s1, s2);\\n        // just find the cost of deleting all other chars then in maxASCIIsum\\n        int ASCIIs1 = 0;\\n        int ASCIIs2 = 0;\\n        for(auto i : s1)\\n            ASCIIs1 += (int)i;\\n        for(auto i : s2)\\n            ASCIIs2 += (int)i;\\n        \\n        return ASCIIs1 + ASCIIs2 - (2 * maxASCIIsum);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1313847,
                "title": "c-lcs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.length() , n = s2.length();\\n        int c1 = 0, c2=0;\\n        for(char c:s1)\\n            c1+=c;\\n        for(char c:s2)\\n            c2+=c;\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s1[i-1]==s2[j-1])\\n                    dp[i][j] = s1[i-1]+dp[i-1][j-1];\\n                else \\n                    dp[i][j] = max(dp[i-1][j] , dp[i][j-1]);\\n            }\\n        }\\n        int lcs = dp[m][n];\\n        return c1-lcs+c2-lcs; //remove the letters in both s1 and s2 which are not a part of lcs\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.length() , n = s2.length();\\n        int c1 = 0, c2=0;\\n        for(char c:s1)\\n            c1+=c;\\n        for(char c:s2)\\n            c2+=c;\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s1[i-1]==s2[j-1])\\n                    dp[i][j] = s1[i-1]+dp[i-1][j-1];\\n                else \\n                    dp[i][j] = max(dp[i-1][j] , dp[i][j-1]);\\n            }\\n        }\\n        int lcs = dp[m][n];\\n        return c1-lcs+c2-lcs; //remove the letters in both s1 and s2 which are not a part of lcs\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840905,
                "title": "step-by-step-video-solution-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/WhrdW1R3AQ0\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int n = s1.length();int m = s2.length();\\n        int[][] dp = new int[n+1][m+1];\\n\\n        for (int i = 1; i <= n; i++)\\n            dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1);\\n        \\n        for (int j = 1; j <= m; j++)\\n            dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1);\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i - 1][j] + s1.charAt(i - 1), dp[i][j - 1] + s2.charAt(j - 1));\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.length();\\n        int m = s2.length();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\\n\\n        for (int i = 1; i <= n; i++)\\n            dp[i][0] = dp[i - 1][0] + s1[i - 1];\\n        \\n        for (int j = 1; j <= m; j++)\\n            dp[0][j] = dp[0][j - 1] + s2[j - 1];\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (s1[i - 1] == s2[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        n = len(s1)\\n        m = len(s2)\\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\\n\\n        for i in range(1, n + 1):\\n            dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])\\n        \\n        for j in range(1, m + 1):\\n            dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])\\n        \\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                if s1[i - 1] == s2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                else:\\n                    dp[i][j] = min(dp[i - 1][j] + ord(s1[i - 1]), dp[i][j - 1] + ord(s2[j - 1]))\\n        \\n        return dp[n][m]\\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int n = s1.length();int m = s2.length();\\n        int[][] dp = new int[n+1][m+1];\\n\\n        for (int i = 1; i <= n; i++)\\n            dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1);\\n        \\n        for (int j = 1; j <= m; j++)\\n            dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1);\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i - 1][j] + s1.charAt(i - 1), dp[i][j - 1] + s2.charAt(j - 1));\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.length();\\n        int m = s2.length();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\\n\\n        for (int i = 1; i <= n; i++)\\n            dp[i][0] = dp[i - 1][0] + s1[i - 1];\\n        \\n        for (int j = 1; j <= m; j++)\\n            dp[0][j] = dp[0][j - 1] + s2[j - 1];\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (s1[i - 1] == s2[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        n = len(s1)\\n        m = len(s2)\\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\\n\\n        for i in range(1, n + 1):\\n            dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])\\n        \\n        for j in range(1, m + 1):\\n            dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])\\n        \\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                if s1[i - 1] == s2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                else:\\n                    dp[i][j] = min(dp[i - 1][j] + ord(s1[i - 1]), dp[i][j - 1] + ord(s2[j - 1]))\\n        \\n        return dp[n][m]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738822,
                "title": "c-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) \\n    {\\n        int m = s1.length(),n = s2.length();\\n        vector<vector<int>> ans(m+1,vector<int>(n+1));\\n        for(int i=0;i<=m;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                if(i == 0 && j == 0) ans[i][j] = 0;\\n                else if(i == 0) ans[i][j] = ans[i][j-1]+int(s2[j-1]);\\n                else if(j == 0) ans[i][j] = ans[i-1][j] + int(s1[i-1]);\\n                else if(s1[i-1] == s2[j-1]) ans[i][j] = ans[i-1][j-1];\\n                else\\n                {\\n                    ans[i][j] = min(ans[i-1][j] + int(s1[i-1]),ans[i][j-1] + int(s2[j-1]));\\n                }\\n            }\\n        }\\n        return ans[m][n];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) \\n    {\\n        int m = s1.length(),n = s2.length();\\n        vector<vector<int>> ans(m+1,vector<int>(n+1));\\n        for(int i=0;i<=m;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                if(i == 0 && j == 0) ans[i][j] = 0;\\n                else if(i == 0) ans[i][j] = ans[i][j-1]+int(s2[j-1]);\\n                else if(j == 0) ans[i][j] = ans[i-1][j] + int(s1[i-1]);\\n                else if(s1[i-1] == s2[j-1]) ans[i][j] = ans[i-1][j-1];\\n                else\\n                {\\n                    ans[i][j] = min(ans[i-1][j] + int(s1[i-1]),ans[i][j-1] + int(s2[j-1]));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1516574,
                "title": "greedy-dp-same-as-lcs",
                "content": "## IDEA :\\nSame as Longest common Subsequece problem.\\n\\n**Code :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        \\n        def lcs(s,p):\\n            m,n = len(s),len(p)\\n            dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\\n            for i in range(m):\\n                for j in range(n):\\n                    if s[i]==p[j]:\\n                        dp[i+1][j+1] = dp[i][j]+ord(s[i])\\n                    else:\\n                        dp[i+1][j+1] = max(dp[i+1][j],dp[i][j+1])\\n                        \\n            return dp[-1][-1]\\n        \\n        common = lcs(s1,s2)\\n        total,res = 0,0\\n        for c in s1:\\n            total+=ord(c)\\n        for c in s2:\\n            total+=ord(c)\\n        \\n        res = total - common*2\\n        return res\\n\\n### Thanks & Upvote if you like the idea !!\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "## IDEA :\\nSame as Longest common Subsequece problem.\\n\\n**Code :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        \\n        def lcs(s,p):\\n            m,n = len(s),len(p)\\n            dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\\n            for i in range(m):\\n                for j in range(n):\\n                    if s[i]==p[j]:\\n                        dp[i+1][j+1] = dp[i][j]+ord(s[i])\\n                    else:\\n                        dp[i+1][j+1] = max(dp[i+1][j],dp[i][j+1])\\n                        \\n            return dp[-1][-1]\\n        \\n        common = lcs(s1,s2)\\n        total,res = 0,0\\n        for c in s1:\\n            total+=ord(c)\\n        for c in s2:\\n            total+=ord(c)\\n        \\n        res = total - common*2\\n        return res\\n\\n### Thanks & Upvote if you like the idea !!\\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 262391,
                "title": "c-dp-solution-with-quite-detailed-explaination",
                "content": "DP problem 3 steps:\\n1. Definition\\nActually,this is the most important step I think.Define your dp matrix correctly enables you to go further instead of a dead end.\\nIn this problem, we define dp[i][j] as the min sum to make s1[0:i] and s2[0:j] the same.\\n1. Initialize\\nset i=0 and j=0 individually.\\nFor i=0, we have to make s1(which is empty string ->\"\") the same as s2[0:j] , the only way to do this is to delete all chars in s2[0:j]\\nFor j=0,we have to make s1[0:i] the same as s2(which is empty string ->\"\")  ,  the only way to do this is to delete all chars in s1[0:i]\\n1. Genearlize\\nConsider i>=1 & j>=1\\nIf s1[i-1] = s2[j-1] , no deletion needed , so dp[i][j] = dp[i-1][j-1]\\nelse : there are two ways to make s1[0:i] the same as s2[0:j]\\n\\t\\tOne is to delete s1[i-1] ,based on the condition that s1[0:i-1] and s2[0:j] is already the same.\\n\\t\\tThe other is to delete s2[j-1],based on the condition that s1[0:i] and s2[0:j-1] is already the same.\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        vector<vector<int>> dp(s1.size()+1,vector<int>(s2.size()+1,0));\\n        dp[0][0] = 0;\\n        for(int i=1;i<=s1.size();i++)\\n            dp[i][0] = dp[i-1][0] +(int)s1[i-1];\\n        for(int j=1;j<=s2.size();j++)\\n            dp[0][j] = dp[0][j-1] + (int)s2[j-1];\\n        for(int i=1;i<=s1.size();i++){\\n            for(int j=1;j<=s2.size();j++){\\n                if(s1[i-1]==s2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = min(dp[i-1][j]+(int)s1[i-1],dp[i][j-1]+(int)s2[j-1]);\\n            }\\n        }\\n        return dp[s1.size()][s2.size()];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        vector<vector<int>> dp(s1.size()+1,vector<int>(s2.size()+1,0));\\n        dp[0][0] = 0;\\n        for(int i=1;i<=s1.size();i++)\\n            dp[i][0] = dp[i-1][0] +(int)s1[i-1];\\n        for(int j=1;j<=s2.size();j++)\\n            dp[0][j] = dp[0][j-1] + (int)s2[j-1];\\n        for(int i=1;i<=s1.size();i++){\\n            for(int j=1;j<=s2.size();j++){\\n                if(s1[i-1]==s2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = min(dp[i-1][j]+(int)s1[i-1],dp[i][j-1]+(int)s2[j-1]);\\n            }\\n        }\\n        return dp[s1.size()][s2.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128017,
                "title": "python",
                "content": "```\\n# https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/description/\\nclass Solution(object):\\n    def minimumDeleteSum(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: int\\n        \"\"\"\\n        # DP\\n        # dp[i][j] is the lowest ASCII cost for s1[:i] (last one is s1[i -1]) and s2[:j] (last one is s2[j - 1])\\n        # if s1[i] == s2[j]: dp[i + 1][j + 1] = dp[i][j]\\n        # if s1[i] != s2[j]: dp[i + 1][j + 1] =\\n        #     min(dp[i + 1][j] + s2[j] /*keep s1[i], delete s2[j]*/,\\n        #         dp[i][j + 1] + s1[i] /*keep s2[j], delete s1[i]*/)\\n        dp = [[0 for _ in xrange(len(s2) + 1)] for _ in xrange(len(s1) + 1)]\\n        for j in xrange(1, len(s2) + 1):\\n            dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])\\n\\n        for i in xrange(1, len(s1) + 1):\\n            dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])\\n            for j in xrange(1, len(s2) + 1):\\n                if s1[i - 1] == s2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                else:\\n                    dp[i][j] = min(dp[i][j - 1] + ord(s2[j - 1]), dp[i - 1][j] + ord(s1[i - 1]))\\n\\n        return dp[-1][-1]\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/description/\\nclass Solution(object):\\n    def minimumDeleteSum(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: int\\n        \"\"\"\\n        # DP\\n        # dp[i][j] is the lowest ASCII cost for s1[:i] (last one is s1[i -1]) and s2[:j] (last one is s2[j - 1])\\n        # if s1[i] == s2[j]: dp[i + 1][j + 1] = dp[i][j]\\n        # if s1[i] != s2[j]: dp[i + 1][j + 1] =\\n        #     min(dp[i + 1][j] + s2[j] /*keep s1[i], delete s2[j]*/,\\n        #         dp[i][j + 1] + s1[i] /*keep s2[j], delete s1[i]*/)\\n        dp = [[0 for _ in xrange(len(s2) + 1)] for _ in xrange(len(s1) + 1)]\\n        for j in xrange(1, len(s2) + 1):\\n            dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])\\n\\n        for i in xrange(1, len(s1) + 1):\\n            dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])\\n            for j in xrange(1, len(s2) + 1):\\n                if s1[i - 1] == s2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                else:\\n                    dp[i][j] = min(dp[i][j - 1] + ord(s2[j - 1]), dp[i - 1][j] + ord(s1[i - 1]))\\n\\n        return dp[-1][-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843967,
                "title": "memoization-easy-clean-code",
                "content": "**Please upvote :)**\\n# Intuition\\nWe can solve this using Classic pick and not pick.\\n# Approach\\nAt any stage, if the characters are equal, do not delete them.\\nIf the characters are not equal, try deleting one at a time.\\n# Complexity\\n- Time complexity:\\n- O(n*m)\\n\\n- Space complexity:\\n- O(n*m) + O(n) for recursion call stack.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>>dp;\\n    int memo(string &s1, string &s2, int i, int j){\\n        if(i >= n && j>= m)return 0;\\n        if(i >= n)return (s2[j]) + memo(s1,s2,i,j+1);\\n        if(j >= m)return (s1[i]) + memo(s1,s2,i+1,j);\\n\\n        if(dp[i][j] != -1)return dp[i][j];\\n\\n        if(s1[i] == s2[j])return dp[i][j] = memo(s1,s2,i+1,j+1);\\n    \\n        int deletingS1 = s1[i] + memo(s1,s2,i+1,j);\\n        int deletingS2 = s2[j] + memo(s1,s2,i,j+1);\\n\\n        return dp[i][j] = min(deletingS1,deletingS2);        \\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        n = s1.size(), m = s2.size();\\n        dp.resize(n+1,vector<int>(m+1,-1));\\n        return memo(s1,s2,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>>dp;\\n    int memo(string &s1, string &s2, int i, int j){\\n        if(i >= n && j>= m)return 0;\\n        if(i >= n)return (s2[j]) + memo(s1,s2,i,j+1);\\n        if(j >= m)return (s1[i]) + memo(s1,s2,i+1,j);\\n\\n        if(dp[i][j] != -1)return dp[i][j];\\n\\n        if(s1[i] == s2[j])return dp[i][j] = memo(s1,s2,i+1,j+1);\\n    \\n        int deletingS1 = s1[i] + memo(s1,s2,i+1,j);\\n        int deletingS2 = s2[j] + memo(s1,s2,i,j+1);\\n\\n        return dp[i][j] = min(deletingS1,deletingS2);        \\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        n = s1.size(), m = s2.size();\\n        dp.resize(n+1,vector<int>(m+1,-1));\\n        return memo(s1,s2,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841644,
                "title": "c-dynamic-programming-from-top-down-to-bottom-up-with-the-optimal-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n## Normal Case(s)\\nFor each pair of `s1[i1]` and `s2[i2]`, there are the following cases:\\n- if `s1[i1] == s2[i2]`: keep both characters, go to `s1[i1 + 1], s2[i2 + 1]`\\n- if `s1[i1] != s2[i2]`\\n    - delete `s1[i1]`: add `s1[i1]` to the sum, go to `s1[i1 + 1], s2[i2]`\\n    - delete `s2[i2]`: add `s2[i2]` to the sum, go to `s1[i1], s2[i2 + 1]`\\n\\n## Base Case(s)\\nWhen one (or both) of the string is ended (`i1 == len1` or `i2 == len2`), all the rest characters must be deleted, so return the sum of the rest characters. \\n- if `(i1 == len1) && (i2 == len2)` return `0`\\n- if `(i1 == len1) && (i2 != len2)` return `sum(s2[i2], s2[i2 + 1], ..., s2[len2 - 1])`\\n- if `(i1 != len1) && (i2 == len2)` return `sum(s1[i1], s1[i1 + 1], ..., s1[len1 - 1])`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Top-Down (Recursion)\\n2. Bottom-Up (2D-array DP)\\n3. Bottom-Up with the optimal space (1D-array DP)\\n\\n# Complexity\\n- Time complexity: $$O(len1 * len2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(len1 * len2)$$ -> $$O(min(len1, len2))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## 1. Top-Down (Recursion)\\n```C++ []\\nclass Solution {\\npublic:\\n    // time/space: O(len1 * len2)/O(len1 * len2)\\n    int minimumDeleteSum(string s1, string s2) {\\n        const int len1 = s1.size(), len2 = s2.size();\\n        vector<vector<int>> dp(len1, vector(len2, -1));\\n        return helper(s1, s2, 0, 0, dp);\\n    }\\nprivate:\\n    int helper(const string& s1, const string& s2, int i1, int i2, vector<vector<int>>& dp) {\\n        // terminate\\n        const int len1 = s1.size(), len2 = s2.size();\\n        if ((i1 == len1) && (i2 == len2)) return 0;\\n        if (i1 == len1) return helper(s1, s2, i1, i2 + 1, dp) + s2[i2];\\n        if (i2 == len2) return helper(s1, s2, i1 + 1, i2, dp) + s1[i1];\\n        if (dp[i1][i2] != -1) return dp[i1][i2];\\n\\n        // enumerate\\n        if (s1[i1] == s2[i2]) return dp[i1][i2] = helper(s1, s2, i1 + 1, i2 + 1, dp);\\n        return dp[i1][i2] = min(\\n            s1[i1] + helper(s1, s2, i1 + 1, i2, dp),\\n            s2[i2] + helper(s1, s2, i1, i2 + 1, dp)\\n        );\\n    }\\n};\\n```\\n\\n## 2. Bottom-Up (2D-array DP)\\n```C++ []\\nclass Solution {\\npublic:\\n    // time/space: O(len1 * len2)/O(len1 * len2)\\n    int minimumDeleteSum(string s1, string s2) {\\n        const int len1 = s1.size(), len2 = s2.size();\\n        vector<vector<int>> dp(len1 + 1, vector<int>(len2 + 1));\\n\\n        // base case\\n        dp[len1][len2] = 0;\\n        for (int i1 = len1 - 1; i1 >= 0; i1--) dp[i1][len2] = dp[i1 + 1][len2] + s1[i1];\\n        for (int i2 = len2 - 1; i2 >= 0; i2--) dp[len1][i2] = dp[len1][i2 + 1] + s2[i2];\\n\\n        // dynamic programming\\n        for (int i1 = len1 -1; i1 >= 0; i1--) {\\n            for (int i2 = len2 - 1; i2 >= 0; i2--) {\\n                if (s1[i1] == s2[i2]) dp[i1][i2] = dp[i1 + 1][i2 + 1];\\n                else dp[i1][i2] = min(s1[i1] + dp[i1 + 1][i2], s2[i2] + dp[i1][i2 + 1]);\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n};\\n```\\n\\n## 3. Bottom-Up with the optimal space (1D-array DP)\\n```C++[]\\nclass Solution {\\npublic:\\n    // time/space: O(len1 * len2)/O(min(len1, len2))\\n    int minimumDeleteSum(string s1, string s2) {\\n        const int len1 = s1.size(), len2 = s2.size();\\n        if (len1 < len2) return minimumDeleteSum(s2, s1);\\n        vector<int> dp0(len2 + 1), dp1(len2 + 1);\\n\\n        // base case\\n        dp1[len2] = 0;\\n        for (int i2 = len2 - 1; i2 >= 0; i2--) dp1[i2] = dp1[i2 + 1] + s2[i2];\\n\\n        // dynamic programming\\n        for (int i1 = len1 - 1; i1 >= 0; i1--) {\\n            dp0[len2] = dp1[len2] + s1[i1];\\n            for (int i2 = len2 - 1; i2 >= 0; i2--) {\\n                if (s1[i1] == s2[i2]) dp0[i2] = dp1[i2 + 1];\\n                else dp0[i2] = min(s1[i1] + dp1[i2], s2[i2] + dp0[i2 + 1]);\\n            }\\n            swap(dp0, dp1);\\n        }\\n\\n        return dp1[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    // time/space: O(len1 * len2)/O(len1 * len2)\\n    int minimumDeleteSum(string s1, string s2) {\\n        const int len1 = s1.size(), len2 = s2.size();\\n        vector<vector<int>> dp(len1, vector(len2, -1));\\n        return helper(s1, s2, 0, 0, dp);\\n    }\\nprivate:\\n    int helper(const string& s1, const string& s2, int i1, int i2, vector<vector<int>>& dp) {\\n        // terminate\\n        const int len1 = s1.size(), len2 = s2.size();\\n        if ((i1 == len1) && (i2 == len2)) return 0;\\n        if (i1 == len1) return helper(s1, s2, i1, i2 + 1, dp) + s2[i2];\\n        if (i2 == len2) return helper(s1, s2, i1 + 1, i2, dp) + s1[i1];\\n        if (dp[i1][i2] != -1) return dp[i1][i2];\\n\\n        // enumerate\\n        if (s1[i1] == s2[i2]) return dp[i1][i2] = helper(s1, s2, i1 + 1, i2 + 1, dp);\\n        return dp[i1][i2] = min(\\n            s1[i1] + helper(s1, s2, i1 + 1, i2, dp),\\n            s2[i2] + helper(s1, s2, i1, i2 + 1, dp)\\n        );\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    // time/space: O(len1 * len2)/O(len1 * len2)\\n    int minimumDeleteSum(string s1, string s2) {\\n        const int len1 = s1.size(), len2 = s2.size();\\n        vector<vector<int>> dp(len1 + 1, vector<int>(len2 + 1));\\n\\n        // base case\\n        dp[len1][len2] = 0;\\n        for (int i1 = len1 - 1; i1 >= 0; i1--) dp[i1][len2] = dp[i1 + 1][len2] + s1[i1];\\n        for (int i2 = len2 - 1; i2 >= 0; i2--) dp[len1][i2] = dp[len1][i2 + 1] + s2[i2];\\n\\n        // dynamic programming\\n        for (int i1 = len1 -1; i1 >= 0; i1--) {\\n            for (int i2 = len2 - 1; i2 >= 0; i2--) {\\n                if (s1[i1] == s2[i2]) dp[i1][i2] = dp[i1 + 1][i2 + 1];\\n                else dp[i1][i2] = min(s1[i1] + dp[i1 + 1][i2], s2[i2] + dp[i1][i2 + 1]);\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n};\\n```\n```C++[]\\nclass Solution {\\npublic:\\n    // time/space: O(len1 * len2)/O(min(len1, len2))\\n    int minimumDeleteSum(string s1, string s2) {\\n        const int len1 = s1.size(), len2 = s2.size();\\n        if (len1 < len2) return minimumDeleteSum(s2, s1);\\n        vector<int> dp0(len2 + 1), dp1(len2 + 1);\\n\\n        // base case\\n        dp1[len2] = 0;\\n        for (int i2 = len2 - 1; i2 >= 0; i2--) dp1[i2] = dp1[i2 + 1] + s2[i2];\\n\\n        // dynamic programming\\n        for (int i1 = len1 - 1; i1 >= 0; i1--) {\\n            dp0[len2] = dp1[len2] + s1[i1];\\n            for (int i2 = len2 - 1; i2 >= 0; i2--) {\\n                if (s1[i1] == s2[i2]) dp0[i2] = dp1[i2 + 1];\\n                else dp0[i2] = min(s1[i1] + dp1[i2], s2[i2] + dp0[i2 + 1]);\\n            }\\n            swap(dp0, dp1);\\n        }\\n\\n        return dp1[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841502,
                "title": "c-dp-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLCS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLook for LCS and subtract its double from the total sum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tint f(int i,int j,string& s1,string& s2,vector<vector<int>>& dp){\\n\\t\\tif(i<0 || j<0) return 0;\\n\\t\\tif(dp[i][j]!=-1) return dp[i][j];\\n\\t\\tif(s1[i]==s2[j]) return dp[i][j]=s1[i]+f(i-1,j-1,s1,s2,dp);\\n\\t\\treturn dp[i][j]=max(f(i-1,j,s1,s2,dp),f(i,j-1,s1,s2,dp));\\n\\t}\\n\\n\\tint minimumDeleteSum(string s1, string s2) {\\n\\t\\tint n=s1.size();\\n\\t\\tint m=s2.size();\\n\\t\\tint sum1=0,sum2=0;\\n\\t\\tfor(auto i:s1) sum1+=i;\\n\\t\\tfor(auto i:s2) sum2+=i;\\n\\t\\tvector<vector<int>> dp(n,vector<int>(m,-1));\\n\\t\\treturn (sum1+sum2)-2*f(n-1,m-1,s1,s2,dp);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint f(int i,int j,string& s1,string& s2,vector<vector<int>>& dp){\\n\\t\\tif(i<0 || j<0) return 0;\\n\\t\\tif(dp[i][j]!=-1) return dp[i][j];\\n\\t\\tif(s1[i]==s2[j]) return dp[i][j]=s1[i]+f(i-1,j-1,s1,s2,dp);\\n\\t\\treturn dp[i][j]=max(f(i-1,j,s1,s2,dp),f(i,j-1,s1,s2,dp));\\n\\t}\\n\\n\\tint minimumDeleteSum(string s1, string s2) {\\n\\t\\tint n=s1.size();\\n\\t\\tint m=s2.size();\\n\\t\\tint sum1=0,sum2=0;\\n\\t\\tfor(auto i:s1) sum1+=i;\\n\\t\\tfor(auto i:s2) sum2+=i;\\n\\t\\tvector<vector<int>> dp(n,vector<int>(m,-1));\\n\\t\\treturn (sum1+sum2)-2*f(n-1,m-1,s1,s2,dp);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841234,
                "title": "memoization-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int minimumDeleteSum(string s1, string s2) {\\n        dp.resize(s1.size()+1,vector<int>(s2.size()+1,-1));\\n        return rucc(s1,s2,0,0);    \\n    }\\n    int rucc(string& s1, string& s2, int i, int j){\\n        if(i >= s1.size()){\\n            int sum = 0;\\n            for(int k = j; k <= s2.size(); ++k){\\n                sum += (int)s2[k];\\n            }\\n            return sum;\\n        }\\n        if(j >= s2.size()){\\n            int sum = 0;\\n            for(int k = i; k <= s1.size(); ++k){\\n                sum += (int)s1[k];\\n            }\\n            return sum;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s1[i] == s2[j]){\\n            return dp[i][j] = rucc(s1,s2,i+1,j+1);\\n        }\\n        return dp[i][j] = min((int)s1[i] + rucc(s1,s2,i+1,j),(int)s2[j] + rucc(s1,s2,i,j+1));\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int minimumDeleteSum(string s1, string s2) {\\n        dp.resize(s1.size()+1,vector<int>(s2.size()+1,-1));\\n        return rucc(s1,s2,0,0);    \\n    }\\n    int rucc(string& s1, string& s2, int i, int j){\\n        if(i >= s1.size()){\\n            int sum = 0;\\n            for(int k = j; k <= s2.size(); ++k){\\n                sum += (int)s2[k];\\n            }\\n            return sum;\\n        }\\n        if(j >= s2.size()){\\n            int sum = 0;\\n            for(int k = i; k <= s1.size(); ++k){\\n                sum += (int)s1[k];\\n            }\\n            return sum;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s1[i] == s2[j]){\\n            return dp[i][j] = rucc(s1,s2,i+1,j+1);\\n        }\\n        return dp[i][j] = min((int)s1[i] + rucc(s1,s2,i+1,j),(int)s2[j] + rucc(s1,s2,i,j+1));\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1196499,
                "title": "python-3-explanations-suitable-for-novice-users-dp-and-space-optimized-dp",
                "content": "This question is a combination of [1143 Longest Increasing Subsequence](https://leetcode.com/problems/longest-common-subsequence/) and [583 Delete Operation for two strings](https://leetcode.com/problems/delete-operation-for-two-strings/). \\nIt makes sense to solve them first.\\n\\n**Idea**:\\nWe will find a longest common subsequence, calcluate its ```ord``` value and subtract 2 times this value from the sum of ```ord``` of both given strings ```s1``` and ```s2```.\\nWhy do we subtact twice?\\nImagine that we found the longest common subsequence for ```sea``` and ```eat```. This is ```ea```.\\nWe need to remove it from ```sea``` and then from ```eat```, and we do it exactly twice! Thus, we\\'re left with ```s``` and ```t```. As a result, we need to return ```ord(s) + ord(t)```.\\n\\nWe can copy-paste a dp solution from 1143. The only difference is when two letters are the same:\\n```\\nif s2[c - 1] == s1[r - 1]:\\n\\tdp[r][c] = dp[r - 1][c - 1] + ord(s1[r - 1])\\n```\\ninstead of 1, we add ```ord(s1[r - 1])```.\\n\\nFor space optimization, we need to maintain only two rows in ```dp``` instead of having a large matrix ```len(s1) * len(s2)```.\\n\\n```\\ndef minimumDeleteSum(s1, s2):  # O(mn) both, where m and n are lengths \\n    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\\n    for r in range(1, len(s1) + 1):\\n        for c in range(1, len(s2) + 1):\\n            if s2[c - 1] == s1[r - 1]:\\n                dp[r][c] = dp[r - 1][c - 1] + ord(s1[r - 1])\\n            else:\\n                dp[r][c] = max(dp[r - 1][c], dp[r][c - 1])\\n    return sum(ord(ch) for ch in s1) + sum(ord(ch) for ch in s2) - 2 * dp[-1][-1]\\n\\n\\ndef minimumDeleteSum_space_efficient(s1, s2):  # O(mn) and O(2n)\\n    dp = [[0 for _ in range(len(s2) + 1)] for _ in range(2)]\\n    res = 0\\n    for row in range(1, len(s1) + 1):\\n        for col in range(1, len(s2) + 1):\\n            if s1[row - 1] == s2[col - 1]:\\n                dp[row % 2][col] = ord(s1[row - 1]) + dp[(row - 1) % 2][col - 1]\\n            else:\\n                dp[row % 2][col] = max(dp[(row - 1) % 2][col], dp[row % 2][col - 1])\\n            res = max(res, dp[row % 2][col])\\n    return sum(ord(ch) for ch in s1) + sum(ord(ch) for ch in s2) - 2 * res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```ord```\n```ord```\n```s1```\n```s2```\n```sea```\n```eat```\n```ea```\n```sea```\n```eat```\n```s```\n```t```\n```ord(s) + ord(t)```\n```\\nif s2[c - 1] == s1[r - 1]:\\n\\tdp[r][c] = dp[r - 1][c - 1] + ord(s1[r - 1])\\n```\n```ord(s1[r - 1])```\n```dp```\n```len(s1) * len(s2)```\n```\\ndef minimumDeleteSum(s1, s2):  # O(mn) both, where m and n are lengths \\n    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\\n    for r in range(1, len(s1) + 1):\\n        for c in range(1, len(s2) + 1):\\n            if s2[c - 1] == s1[r - 1]:\\n                dp[r][c] = dp[r - 1][c - 1] + ord(s1[r - 1])\\n            else:\\n                dp[r][c] = max(dp[r - 1][c], dp[r][c - 1])\\n    return sum(ord(ch) for ch in s1) + sum(ord(ch) for ch in s2) - 2 * dp[-1][-1]\\n\\n\\ndef minimumDeleteSum_space_efficient(s1, s2):  # O(mn) and O(2n)\\n    dp = [[0 for _ in range(len(s2) + 1)] for _ in range(2)]\\n    res = 0\\n    for row in range(1, len(s1) + 1):\\n        for col in range(1, len(s2) + 1):\\n            if s1[row - 1] == s2[col - 1]:\\n                dp[row % 2][col] = ord(s1[row - 1]) + dp[(row - 1) % 2][col - 1]\\n            else:\\n                dp[row % 2][col] = max(dp[(row - 1) % 2][col], dp[row % 2][col - 1])\\n            res = max(res, dp[row % 2][col])\\n    return sum(ord(ch) for ch in s1) + sum(ord(ch) for ch in s2) - 2 * res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1174247,
                "title": "java-dp-memoization-recursion",
                "content": "```\\n public int minimumDeleteSum(String s1, String s2) {\\n        int dp[][]=new int[s1.length()+1][s2.length()+1];\\n        for(int arr[]:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(s1,s2,0,0,dp);     \\n        \\n    }   \\n    \\n    private int helper(String s1,String s2,int start1,int start2,int dp[][]){\\n      \\n        if(start1==s1.length() && start2==s2.length()){\\n            return 0;\\n        }\\n        \\n        else if(start1==s1.length() && start2!=s2.length()){\\n            int sum=0;\\n            for(int i=start2;i<s2.length();i++){\\n                sum=sum+(int)(s2.charAt(i));\\n            }\\n            return sum;\\n        }\\n        \\n         else if(start1!=s1.length() && start2==s2.length()){\\n            int sum=0;\\n            for(int i=start1;i<s1.length();i++){\\n                sum=sum+(int)(s1.charAt(i));\\n            }\\n             return sum;\\n        }\\n        \\n        if(dp[start1][start2]!=-1){\\n            return dp[start1][start2];\\n        }\\n        /*if characters are same do nothing*/\\n        else if(s1.charAt(start1)==s2.charAt(start2)){\\n           return  dp[start1][start2]= helper(s1,s2,start1+1,start2+1,dp);\\n        }\\n\\t\\t/*if characters are not same try deleting from s1 and s2 and return the minimum value*/\\n        else{\\n            int deleteFrom1= (int)(s1.charAt(start1))+helper(s1,s2,start1+1,start2,dp);\\n            int deleteFrom2=(int)(s2.charAt(start2))+helper(s1,s2,start1,start2+1,dp);\\n            return dp[start1][start2]= Math.min(deleteFrom1,deleteFrom2);\\n        }\\n    \\n    \\n    \\n    \\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n public int minimumDeleteSum(String s1, String s2) {\\n        int dp[][]=new int[s1.length()+1][s2.length()+1];\\n        for(int arr[]:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(s1,s2,0,0,dp);     \\n        \\n    }   \\n    \\n    private int helper(String s1,String s2,int start1,int start2,int dp[][]){\\n      \\n        if(start1==s1.length() && start2==s2.length()){\\n            return 0;\\n        }\\n        \\n        else if(start1==s1.length() && start2!=s2.length()){\\n            int sum=0;\\n            for(int i=start2;i<s2.length();i++){\\n                sum=sum+(int)(s2.charAt(i));\\n            }\\n            return sum;\\n        }\\n        \\n         else if(start1!=s1.length() && start2==s2.length()){\\n            int sum=0;\\n            for(int i=start1;i<s1.length();i++){\\n                sum=sum+(int)(s1.charAt(i));\\n            }\\n             return sum;\\n        }\\n        \\n        if(dp[start1][start2]!=-1){\\n            return dp[start1][start2];\\n        }\\n        /*if characters are same do nothing*/\\n        else if(s1.charAt(start1)==s2.charAt(start2)){\\n           return  dp[start1][start2]= helper(s1,s2,start1+1,start2+1,dp);\\n        }\\n\\t\\t/*if characters are not same try deleting from s1 and s2 and return the minimum value*/\\n        else{\\n            int deleteFrom1= (int)(s1.charAt(start1))+helper(s1,s2,start1+1,start2,dp);\\n            int deleteFrom2=(int)(s2.charAt(start2))+helper(s1,s2,start1,start2+1,dp);\\n            return dp[start1][start2]= Math.min(deleteFrom1,deleteFrom2);\\n        }\\n    \\n    \\n    \\n    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 874167,
                "title": "c-reursive-dp-lcs-solution",
                "content": "Runtime: 60 ms, faster than 38.35% of C++ online submissions for Minimum ASCII Delete Sum for Two Strings.\\nMemory Usage: 11.3 MB, less than 64.43% of C++ online submissions for Minimum ASCII Delete Sum for Two Strings.\\n\\n**LCS Solution:**\\n\\nWe can find the sum of all character which are in LCS of two string. Then result would be the sum of all character in both string - LCS character sum \\nwhich would be the minimum ASCII delete sum.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // dp vector stores the LCS character sum\\n    int dp[1001][1001];\\n    \\n    // LCS recursive function returns LCS character sum\\n    int LCS(string &s1, string &s2, int id1, int id2)\\n    {\\n        // If range reached then return 0 as no LCS possible\\n        if(id1>=s1.length() || id2>=s2.length()) return 0;\\n        \\n        // return precalculated value if available\\n        if(dp[id1][id2]!=-1) return dp[id1][id2];\\n        \\n        // If character are same then we compare next character of both string\\n        if(s1[id1]==s2[id2])\\n            dp[id1][id2] = s1[id1] + LCS(s1,s2,id1+1,id2+1);\\n        \\n        // otherwise ignore current character of one string and take another and call recursion\\n        // Also take the maximum value among them\\n        else\\n            dp[id1][id2] = max(LCS(s1,s2,id1,id2+1),LCS(s1,s2,id1+1,id2));\\n        \\n        return dp[id1][id2];\\n    }\\n    \\n    int minimumDeleteSum(string s1, string s2) {\\n    \\n        memset(dp,-1,sizeof(dp));\\n        \\n        // sum of all characters in both string \\n        int charSum = 0;\\n        for(int i=0;i<s1.length();i++)charSum+=s1[i];\\n        for(int i=0;i<s2.length();i++)charSum+=s2[i];\\n        \\n        // return sum of all character - 2 * LCS character sum\\n        return charSum - (2 * LCS(s1,s2,0,0));\\n    }\\n};\\n```\\n\\n**Direct DP Solution:**\\n\\nWe can directly calculate minimum ASCII delete sum from recursion.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    \\n    int LCS(string &s1, string &s2, int id1, int id2)\\n    {\\n        \\n        if(dp[id1][id2]!=-1) return dp[id1][id2];\\n        \\n        if(id1>=s1.length() && id2>=s2.length()) \\n        {\\n           return 0;\\n        }\\n        else if(id1>=s1.length())\\n        {\\n            dp[id1][id2] = LCS(s1,s2,id1,id2+1)+ s2[id2];\\n        }\\n        else if(id2>=s2.length())\\n        {\\n            dp[id1][id2] = LCS(s1,s2,id1+1,id2)+s1[id1];            \\n        } \\n        else\\n        {\\n            if(s1[id1]==s2[id2])\\n                dp[id1][id2] =  LCS(s1,s2,id1+1,id2+1);         \\n\\n            else\\n                dp[id1][id2] =  min(LCS(s1,s2,id1+1,id2)+s1[id1] , LCS(s1,s2,id1,id2+1)+s2[id2]);\\n    \\n        }\\n         \\n        return dp[id1][id2];\\n    }\\n    \\n    int minimumDeleteSum(string s1, string s2) {\\n    \\n        memset(dp,-1,sizeof(dp));\\n        \\n        return LCS(s1,s2,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // dp vector stores the LCS character sum\\n    int dp[1001][1001];\\n    \\n    // LCS recursive function returns LCS character sum\\n    int LCS(string &s1, string &s2, int id1, int id2)\\n    {\\n        // If range reached then return 0 as no LCS possible\\n        if(id1>=s1.length() || id2>=s2.length()) return 0;\\n        \\n        // return precalculated value if available\\n        if(dp[id1][id2]!=-1) return dp[id1][id2];\\n        \\n        // If character are same then we compare next character of both string\\n        if(s1[id1]==s2[id2])\\n            dp[id1][id2] = s1[id1] + LCS(s1,s2,id1+1,id2+1);\\n        \\n        // otherwise ignore current character of one string and take another and call recursion\\n        // Also take the maximum value among them\\n        else\\n            dp[id1][id2] = max(LCS(s1,s2,id1,id2+1),LCS(s1,s2,id1+1,id2));\\n        \\n        return dp[id1][id2];\\n    }\\n    \\n    int minimumDeleteSum(string s1, string s2) {\\n    \\n        memset(dp,-1,sizeof(dp));\\n        \\n        // sum of all characters in both string \\n        int charSum = 0;\\n        for(int i=0;i<s1.length();i++)charSum+=s1[i];\\n        for(int i=0;i<s2.length();i++)charSum+=s2[i];\\n        \\n        // return sum of all character - 2 * LCS character sum\\n        return charSum - (2 * LCS(s1,s2,0,0));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    \\n    int LCS(string &s1, string &s2, int id1, int id2)\\n    {\\n        \\n        if(dp[id1][id2]!=-1) return dp[id1][id2];\\n        \\n        if(id1>=s1.length() && id2>=s2.length()) \\n        {\\n           return 0;\\n        }\\n        else if(id1>=s1.length())\\n        {\\n            dp[id1][id2] = LCS(s1,s2,id1,id2+1)+ s2[id2];\\n        }\\n        else if(id2>=s2.length())\\n        {\\n            dp[id1][id2] = LCS(s1,s2,id1+1,id2)+s1[id1];            \\n        } \\n        else\\n        {\\n            if(s1[id1]==s2[id2])\\n                dp[id1][id2] =  LCS(s1,s2,id1+1,id2+1);         \\n\\n            else\\n                dp[id1][id2] =  min(LCS(s1,s2,id1+1,id2)+s1[id1] , LCS(s1,s2,id1,id2+1)+s2[id2]);\\n    \\n        }\\n         \\n        return dp[id1][id2];\\n    }\\n    \\n    int minimumDeleteSum(string s1, string s2) {\\n    \\n        memset(dp,-1,sizeof(dp));\\n        \\n        return LCS(s1,s2,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844765,
                "title": "c-lcs-variant",
                "content": "```\\nint LCS(string s1, int n, string s2, int m){\\n        int t[n+1][m+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                if(i==0||j==0) t[i][j] = 0;\\n                else if(s1[i-1]==s2[j-1]) t[i][j] = t[i-1][j-1]+s1[i-1];   \\n\\t\\t/*only this line is changing from original LCS instead of adding\\n\\t\\t1 to increase string size I am adding ASCII value of common character*/\\n                else t[i][j] = max(t[i][j-1],t[i-1][j]);\\n            }\\n        }\\n        return t[n][m];\\n    }\\n    \\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.size();\\n        int m = s2.size();\\n        int diff = LCS(s1,n,s2,m);\\n        int sum=0;\\n        for(int i=0;i<s1.length();i++){\\n            sum+=s1[i];\\n        }\\n        for(int i=0;i<s2.length();i++){\\n            sum+=s2[i];\\n        }\\n        return sum-(2*diff);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint LCS(string s1, int n, string s2, int m){\\n        int t[n+1][m+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                if(i==0||j==0) t[i][j] = 0;\\n                else if(s1[i-1]==s2[j-1]) t[i][j] = t[i-1][j-1]+s1[i-1];   \\n\\t\\t/*only this line is changing from original LCS instead of adding\\n\\t\\t1 to increase string size I am adding ASCII value of common character*/\\n                else t[i][j] = max(t[i][j-1],t[i-1][j]);\\n            }\\n        }\\n        return t[n][m];\\n    }\\n    \\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.size();\\n        int m = s2.size();\\n        int diff = LCS(s1,n,s2,m);\\n        int sum=0;\\n        for(int i=0;i<s1.length();i++){\\n            sum+=s1[i];\\n        }\\n        for(int i=0;i<s2.length();i++){\\n            sum+=s2[i];\\n        }\\n        return sum-(2*diff);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 684507,
                "title": "python-dp-with-explanation",
                "content": "\"\"\"\\n\\n\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        # dp definition\\n\\t\\t# dp[i][j] = lowest ASCII sum of deleted char to make s[0...i] and t[0...j] equal.    \\n        \\n        # base case\\n        \\n        # dp[0][j] = \\'\\' to make empty string and t[0...j] equal --> sum of ASCII in t[0...j]\\n        # dp[i][0] = similarly, sum of ASCII in s[0...i]\\n        \\n        \\n        # case 1: s[i-1] == t[j-1]\\n        \\n        # The last characters are identical, so no need to delete anything, and the ASCII sum is same as dp[i-1][j-1]\\n        # Thus, dp[i][j] = dp[i-1][j-1]\\n        \\n        # case 2: s[i-1] != t[j-1]\\n        \\n        # The last characters are different. We have 3 sub cases, and we choose the minimum value of these three:\\n        # subcase 1: delete s[i-1] --> dp[i][j] = dp[i-1][j] + ASCII(s[i-1])\\n        # subcase 2: delete t[j-1] --> dp[i][j] = dp[i][j-1] + ASCII(t[j-1])\\n        # subcase 3: delete both s[i-1] and t[j-1] --> dp[i][j] = dp[i-1][j-1] + ASCII(s[i-1]) + ASCII(t[i-1])\\n\\n\\n\\n        # Code:\\n        \\n        \\n        l1 = len(s1) + 1\\n        l2 = len(s2) + 1\\n        \\n        dp = [[0 for _ in range(l2)] for _ in range(l1)]\\n        \\n        for i in range(1, l1):\\n            dp[i][0] = dp[i-1][0] + ord(s1[i-1])\\n        \\n        for j in range(1, l2):\\n            dp[0][j] = dp[0][j-1] + ord(s2[j-1])\\n        \\n        for i in range(1, l1):\\n            for j in range(1, l2):\\n                if s1[i-1] == s2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j] + ord(s1[i-1]), dp[i][j-1] + ord(s2[j-1]), dp[i-1][j-1] + ord(s1[i-1]) + ord(s2[j-1]))\\n        \\n        return dp[-1][-1]\\n\"\"\"",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\"\"\"\\n\\n\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        # dp definition\\n\\t\\t# dp[i][j] = lowest ASCII sum of deleted char to make s[0...i] and t[0...j] equal.    \\n        \\n        # base case\\n        \\n        # dp[0][j] = \\'\\' to make empty string and t[0...j] equal --> sum of ASCII in t[0...j]\\n        # dp[i][0] = similarly, sum of ASCII in s[0...i]\\n        \\n        \\n        # case 1: s[i-1] == t[j-1]\\n        \\n        # The last characters are identical, so no need to delete anything, and the ASCII sum is same as dp[i-1][j-1]\\n        # Thus, dp[i][j] = dp[i-1][j-1]\\n        \\n        # case 2: s[i-1] != t[j-1]\\n        \\n        # The last characters are different. We have 3 sub cases, and we choose the minimum value of these three:\\n        # subcase 1: delete s[i-1] --> dp[i][j] = dp[i-1][j] + ASCII(s[i-1])\\n        # subcase 2: delete t[j-1] --> dp[i][j] = dp[i][j-1] + ASCII(t[j-1])\\n        # subcase 3: delete both s[i-1] and t[j-1] --> dp[i][j] = dp[i-1][j-1] + ASCII(s[i-1]) + ASCII(t[i-1])\\n\\n\\n\\n        # Code:\\n        \\n        \\n        l1 = len(s1) + 1\\n        l2 = len(s2) + 1\\n        \\n        dp = [[0 for _ in range(l2)] for _ in range(l1)]\\n        \\n        for i in range(1, l1):\\n            dp[i][0] = dp[i-1][0] + ord(s1[i-1])\\n        \\n        for j in range(1, l2):\\n            dp[0][j] = dp[0][j-1] + ord(s2[j-1])\\n        \\n        for i in range(1, l1):\\n            for j in range(1, l2):\\n                if s1[i-1] == s2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j] + ord(s1[i-1]), dp[i][j-1] + ord(s2[j-1]), dp[i-1][j-1] + ord(s1[i-1]) + ord(s2[j-1]))\\n        \\n        return dp[-1][-1]\\n\"\"\"",
                "codeTag": "Python3"
            },
            {
                "id": 134998,
                "title": "c-12ms",
                "content": "### Idea\\n \\u50CF01\\u80CC\\u5305\\u90A3\\u6837\\u7406\\u89E3\\u5373\\uFF1A\\n `s1[0:i]` `s2[0:j]` \\u4E2D\\u4E00\\u5171\\u6709`i + j`\\u4E2A\\u5B57\\u7B26\\uFF0C\\u4ECE`s1`\\u4E2D\\u4ECE\\u5DE6\\u81F3\\u53F3\\u9009\\u53D6\\u82E5\\u5E72\\u5B57\\u7B26\\uFF0C`s2`\\u4E2D\\u4ECE\\u5DE6\\u81F3\\u53F3\\u9009\\u53D6\\u82E5\\u5E72\\u76F8\\u540C\\u5B57\\u7B26\\u3002\\u90A3\\u4E48\\uFF0C\\u90A3\\u4E9B\\u672A\\u88AB\\u9009\\u4E2D\\u7684\\u5C31\\u662F\\u8981\\u5220\\u9664\\u7684\\u3002\\u518D\\u6362\\u4E2A\\u89D2\\u5EA6\\u601D\\u8003\\u5373\\uFF1A\\u9009\\u53D6\\u8981\\u5220\\u9664\\u7684\\u5B57\\u7B26\\u3002\\n\\n`DP[i][j]` \\u8868\\u793A\\u4ECE`s1 0-i, s2 0-j` \\u4E2D\\u5220\\u9664\\u82E5\\u5E72\\u5B57\\u7B26\\u540E\\uFF0C\\u4E24\\u4E2A\\u5B57\\u7B26\\u4E32\\u76F8\\u7B49\\u65F6\\uFF0C\\u5220\\u9664\\u7684\\u5B57\\u7B26\\u4E32\\u7684ASCII\\u503C\\u7684\\u548C\\u7684\\u6700\\u5C0F\\u503C\\u3002\\n\\n\\u90A3\\u4E48\\u4E00\\u4E2A`O(mn)`\\u7684\\u5FAA\\u73AF\\u626B\\u63CF\\u4E2D\\uFF0C\\u5047\\u8BBE\\u6211\\u4EEC\\u5DF2\\u77E5\\u4E86`DP[i-1][j-1] = a; DP[i-1][j] = b; DP[i][j-1] = c`\\uFF1A\\n- \\u5F53`s1[i] == s2[j] `\\u65F6\\uFF1A\\n`DP[i][j] = DP[i-1][j-1]` \\u56E0\\u4E3A\\u4E0D\\u9700\\u8981\\u518D\\u5220\\u9664\\u5B57\\u7B26\\uFF0C\\u4FDD\\u7559`s1[i],s2[j]`\\u5373\\u53EF\\u3002\\n- \\u5F53`s1[i] != s2[j]`\\u65F6\\uFF1A\\n\\u6B64\\u65F6\\uFF0C\\u9700\\u8981\\u5220\\u9664\\u5B57\\u7B26\\u624D\\u80FD\\u6EE1\\u8DB3\\u76F8\\u7B49\\u3002\\n1\\uFF09\\u5220\\u9664`s1[i]`\\n`DP[i][j] = DP[i-1][j] + s1[i]`\\n2\\uFF09\\u5220\\u9664`s2[j]`\\n`DP[i][j] = DP[i][j-1] + s2[j]`\\n3\\uFF09\\u5220\\u9664`s1[i]`\\u548C`s2[j]`\\n`DP[i][j] = DP[i-1][j-1] + s1[i] + s2[j]` \\u5B9E\\u9645\\u4E0A\\u5982\\u679C\\u4E24\\u4E2A\\u90FD\\u8981\\u5220\\u9664\\uFF0C\\u8BF4\\u660E`s1[0:i] s2[0:j]`\\u8FD9\\u4E9B\\u5B57\\u7B26\\u4E2D\\u90FD\\u627E\\u4E0D\\u5230`s1[i],s2[j]`\\uFF0C\\u90A3\\u4E48`DP[i-1][j]`\\u4E2D\\u4E00\\u5B9A\\u9009\\u4E2D\\u4E86`s2[j]`\\u8FDB\\u884C\\u5220\\u9664\\uFF0C`DP[i][j-1]`\\u4E2D\\u4E00\\u5B9A\\u9009\\u4E2D\\u4E86`s1[i]`\\u5220\\u9664\\u3002\\u90A3\\u4E48\\uFF0C\\u8FD9\\u79CD\\u60C5\\u51B5\\u5C31\\u548C1\\uFF092\\uFF09\\u91CD\\u5408\\u4E86\\uFF0C\\u53EF\\u4EE5\\u4E0D\\u5FC5\\u91CD\\u590D\\u8003\\u8651\\u3002\\n\\u56E0\\u6B64`DP[i][j] = min{DP[i-1][j] + s1[i],  DP[i][j-1] + s2[j]}`\\n\\n### Initialization\\n\\u5728\\u4E0A\\u8FF0\\u7B97\\u6CD5\\u4E2D\\uFF0C\\u5047\\u8BBE\\u7684\\u5DF2\\u77E5\\u6761\\u4EF6\\u4F5C\\u4E3A\\u8D77\\u70B9\\u624D\\u80FD\\u9A71\\u52A8\\u6574\\u4E2A\\u5FAA\\u73AF\\u3002\\n\\u9996\\u5148`DP[0][0] =s1[0] == s2[0] ? 0: s1[0] + s2[0]; `\\n- \\u521D\\u59CB\\u5316`DP[0][0-n]`\\n\\u5373\\u770B\\u505A`s1`\\u53EA\\u6709\\u4E00\\u4E2A\\u5B57\\u7B26\\uFF0C`s2[0-n)`\\u3002\\u5047\\u8BBE`s2`\\u4E2D\\u7B2C`i`\\u4E2A\\u5B57\\u7B26\\u4E0E`s1[0]` \\u7B2C\\u4E00\\u6B21\\u76F8\\u7B49\\uFF08\\u5982\\u4E0D\\u5B58\\u5728i = n\\uFF09\\uFF0C\\u90A3\\u4E48\\u5BF9\\u4E8E`0 < j < n and j != i` \\u90FD\\u6709`DP[0][j] = DP[0][j-1] + s2[j]`  \\u5F53`j == i`\\u65F6`DP[0][j] = DP[0][j-1] -s1[0]`\\uFF08`s1[0]`\\u4E0D\\u9700\\u8981\\u518D\\u5220\\u9664\\uFF09\\n- \\u521D\\u59CB\\u5316`DP[0-n][0]`\\n\\u540C\\u4E0A\\n\\n### Example\\n`s1 = se, s2 = ea `, \\u6C42`DP[1][1] = ?`\\n```c++\\n//i = 0, j = 0\\nDP[0][0] = s + e; //216\\n\\n//i = 0, j = 1\\nDP[0][1] = DP[0][0] + a  //s1[0] = s  s2\\u4E2D\\u6CA1\\u6709s\\u5B57\\u7B26DP[0][j] = DP[0][j-1] + s2[j] \\n313\\n\\n//i = 1, j = 0\\nDP[1][0] = DP[0][0] - s2[0]//s2[0] = e, s1\\u4E2D\\u7B2C\\u4E00\\u4E2A\\u4E3Ae\\u7684\\u5B57\\u7B26index = 1 DP[i][0] = DP[i-1][j] - s2[0]\\n115\\n\\n//i = 1, j = 1\\nDP[1][1] = min{DP[0][1] + e,  DP[1][0] + a} //s1[i] != s2[j] , min{\\u5220\\u9664e, \\u5220\\u9664a}\\nmin{414, 212} = 212\\n\\n```\\n### solution\\n```c++\\nclass Solution {\\npublic:\\n    \\n    int minimumDeleteSum(string s1, string s2) {\\n        /*\\n            F[i][j] \\u5728s1\\u524Di\\u4E2A\\u5B57\\u7B26\\uFF0Cs2\\u524Dj\\u4E2A\\u5B57\\u7B26\\uFF0C\\u4E2D\\u9009\\u53D6\\u82E5\\u5E72\\u4E2A\\u5B57\\u7B26\\u5220\\u9664\\u540E\\u76F8\\u540C\\u3002\\u4F7F\\u5F97\\u76EE\\u6807\\u6700\\u5927\\n        */\\n        int m = s1.size(), n = s2.size();\\n        int dp[m][n], a, b, c;\\n        for(int i = 0; i < m; i++){\\n            memset(dp[i], 0, sizeof(int)*n);\\n        }\\n        dp[0][0] = s1[0] == s2[0] ? 0: s1[0] + s2[0];\\n        bool flag = dp[0][0] == 0 ? true:false;\\n        \\n        for(int i = 1; i < m; i++){\\n            if(s1[i] == s2[0] and !flag){\\n                dp[i][0] = dp[i-1][0] - s2[0];//\\u7B2C\\u4E00\\u6B21\\u76F8\\u7B49\\n                flag = true;\\n            }else{\\n                dp[i][0] = dp[i-1][0] + s1[i];\\n            }\\n        }\\n        flag = dp[0][0] == 0 ? true:false;\\n        for(int i = 1; i < n; i++){\\n            if(s1[0] == s2[i] and !flag){\\n                dp[0][i] = dp[0][i-1] - s1[0];\\n                flag = true;\\n            }else{\\n                dp[0][i] = dp[0][i-1] + s2[i];\\n            }\\n        }\\n        for(int i = 1; i < m; i++){\\n            for(int j = 1; j < n; j++){\\n                if(s1[i] == s2[j])dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    /*\\n                    s1[i] != s2[j], \\u90A3\\u4E48\\u8FD9\\u4E24\\u4E2A\\u5B57\\u7B26\\u4E00\\u5B9A\\u8981\\u5220\\u9664\\u5176\\u4E2D\\u4E00\\u4E2A\\n                    \\u5220\\u9664s1[i]: F[i][j] = F[i-1][j] + s1[i]\\n                    \\u5220\\u9664s2[j]: F[i][j] = F[i][j-1] + s2[j]\\n                    */\\n                    a = dp[i-1][j] + s1[i];\\n                    b = dp[i][j-1] + s2[j];\\n                    dp[i][j] = a < b ? a:b;\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```c++\\n//i = 0, j = 0\\nDP[0][0] = s + e; //216\\n\\n//i = 0, j = 1\\nDP[0][1] = DP[0][0] + a  //s1[0] = s  s2\\u4E2D\\u6CA1\\u6709s\\u5B57\\u7B26DP[0][j] = DP[0][j-1] + s2[j] \\n313\\n\\n//i = 1, j = 0\\nDP[1][0] = DP[0][0] - s2[0]//s2[0] = e, s1\\u4E2D\\u7B2C\\u4E00\\u4E2A\\u4E3Ae\\u7684\\u5B57\\u7B26index = 1 DP[i][0] = DP[i-1][j] - s2[0]\\n115\\n\\n//i = 1, j = 1\\nDP[1][1] = min{DP[0][1] + e,  DP[1][0] + a} //s1[i] != s2[j] , min{\\u5220\\u9664e, \\u5220\\u9664a}\\nmin{414, 212} = 212\\n\\n```\n```c++\\nclass Solution {\\npublic:\\n    \\n    int minimumDeleteSum(string s1, string s2) {\\n        /*\\n            F[i][j] \\u5728s1\\u524Di\\u4E2A\\u5B57\\u7B26\\uFF0Cs2\\u524Dj\\u4E2A\\u5B57\\u7B26\\uFF0C\\u4E2D\\u9009\\u53D6\\u82E5\\u5E72\\u4E2A\\u5B57\\u7B26\\u5220\\u9664\\u540E\\u76F8\\u540C\\u3002\\u4F7F\\u5F97\\u76EE\\u6807\\u6700\\u5927\\n        */\\n        int m = s1.size(), n = s2.size();\\n        int dp[m][n], a, b, c;\\n        for(int i = 0; i < m; i++){\\n            memset(dp[i], 0, sizeof(int)*n);\\n        }\\n        dp[0][0] = s1[0] == s2[0] ? 0: s1[0] + s2[0];\\n        bool flag = dp[0][0] == 0 ? true:false;\\n        \\n        for(int i = 1; i < m; i++){\\n            if(s1[i] == s2[0] and !flag){\\n                dp[i][0] = dp[i-1][0] - s2[0];//\\u7B2C\\u4E00\\u6B21\\u76F8\\u7B49\\n                flag = true;\\n            }else{\\n                dp[i][0] = dp[i-1][0] + s1[i];\\n            }\\n        }\\n        flag = dp[0][0] == 0 ? true:false;\\n        for(int i = 1; i < n; i++){\\n            if(s1[0] == s2[i] and !flag){\\n                dp[0][i] = dp[0][i-1] - s1[0];\\n                flag = true;\\n            }else{\\n                dp[0][i] = dp[0][i-1] + s2[i];\\n            }\\n        }\\n        for(int i = 1; i < m; i++){\\n            for(int j = 1; j < n; j++){\\n                if(s1[i] == s2[j])dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    /*\\n                    s1[i] != s2[j], \\u90A3\\u4E48\\u8FD9\\u4E24\\u4E2A\\u5B57\\u7B26\\u4E00\\u5B9A\\u8981\\u5220\\u9664\\u5176\\u4E2D\\u4E00\\u4E2A\\n                    \\u5220\\u9664s1[i]: F[i][j] = F[i-1][j] + s1[i]\\n                    \\u5220\\u9664s2[j]: F[i][j] = F[i][j-1] + s2[j]\\n                    */\\n                    a = dp[i-1][j] + s1[i];\\n                    b = dp[i][j-1] + s2[j];\\n                    dp[i][j] = a < b ? a:b;\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842132,
                "title": "c-top-down-dp-easy-approach",
                "content": "# Approach\\n-> This is similar to longest common subsequence\\n-> Only here if length of two subsequences are same, the deciding factor is sum of ASCII of all characters in the common subsequence.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int sum =0;\\n        for(auto&i:s1)sum+=i;\\n        for(auto&i:s2)sum+=i;\\n        vector<vector<int>>dp(s1.length()+1,vector<int>(s2.length()+1,0));\\n        for(int i = s1.length()-1; i>=0; i--){\\n            for(int j = s2.length()-1; j>=0; j--){\\n                if(s2[j]==s1[i])dp[i][j]=s2[j]+dp[i+1][j+1];\\n                else dp[i][j]=max(dp[i+1][j],dp[i][j+1]);\\n            }\\n        }\\n        return sum-2*dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int sum =0;\\n        for(auto&i:s1)sum+=i;\\n        for(auto&i:s2)sum+=i;\\n        vector<vector<int>>dp(s1.length()+1,vector<int>(s2.length()+1,0));\\n        for(int i = s1.length()-1; i>=0; i--){\\n            for(int j = s2.length()-1; j>=0; j--){\\n                if(s2[j]==s1[i])dp[i][j]=s2[j]+dp[i+1][j+1];\\n                else dp[i][j]=max(dp[i+1][j],dp[i][j+1]);\\n            }\\n        }\\n        return sum-2*dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841842,
                "title": "variation-of-the-1143-longest-common-subsequence-problem",
                "content": "# Similar Problem:\\nVery popular problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/description/)\\n\\n# Intuition\\nBasic recursion + memoization problem.\\n\\n- Start from `i=0, j=0`\\n- Each time compare `s1.charAt(i)` with `s2.charAt(j)`.\\n- If they are equal, move to `recurse(i+1, j+1)`\\n- If they are not, we have two options:\\n    - delete `i` so, `ascii(s1.charAt(i)) + recurse(i+1, j)`\\n    - delete `j` so, `ascii(s2.charAt(j)) + recurse(i, j+1)`\\n    - return minimum of those two.\\n- It will give TLE. So, make sure to memoize it. `Memo[i][j]` will be helpful.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` java []\\nclass Solution {\\n    int[][] memo;\\n    int n, m;\\n    public int minimumDeleteSum(String s1, String s2) {\\n        n = s1.length();\\n        m = s2.length();\\n        memo = new int[n][m];\\n        for(int i=0; i<n; i++){\\n            Arrays.fill(memo[i], -1);\\n        }\\n        return recurse(s1,s2, 0, 0);\\n    }\\n\\n    int recurse(String s1, String s2, int i, int j) {\\n        if(i==n && j==m) {\\n            return 0;\\n        }\\n        if(i == n){\\n            int sum = 0;\\n            for(int k=j; k<m; k++){\\n                sum+=(int)s2.charAt(k);\\n            }\\n            return sum;\\n        }\\n        if(j==m){\\n            int sum = 0;\\n            for(int k=i; k<n; k++){\\n                sum+=(int)s1.charAt(k);\\n            }\\n            return sum;\\n        }\\n        \\n        if(memo[i][j]!=-1) {\\n            return memo[i][j];\\n        }\\n\\n        if(s1.charAt(i)==s2.charAt(j)){\\n            return memo[i][j] = recurse(s1, s2, i+1, j+1);\\n        }\\n        return memo[i][j] = Math.min((int)s1.charAt(i)+recurse(s1, s2, i+1, j), (int)s2.charAt(j)+recurse(s1,s2, i, j+1));\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` java []\\nclass Solution {\\n    int[][] memo;\\n    int n, m;\\n    public int minimumDeleteSum(String s1, String s2) {\\n        n = s1.length();\\n        m = s2.length();\\n        memo = new int[n][m];\\n        for(int i=0; i<n; i++){\\n            Arrays.fill(memo[i], -1);\\n        }\\n        return recurse(s1,s2, 0, 0);\\n    }\\n\\n    int recurse(String s1, String s2, int i, int j) {\\n        if(i==n && j==m) {\\n            return 0;\\n        }\\n        if(i == n){\\n            int sum = 0;\\n            for(int k=j; k<m; k++){\\n                sum+=(int)s2.charAt(k);\\n            }\\n            return sum;\\n        }\\n        if(j==m){\\n            int sum = 0;\\n            for(int k=i; k<n; k++){\\n                sum+=(int)s1.charAt(k);\\n            }\\n            return sum;\\n        }\\n        \\n        if(memo[i][j]!=-1) {\\n            return memo[i][j];\\n        }\\n\\n        if(s1.charAt(i)==s2.charAt(j)){\\n            return memo[i][j] = recurse(s1, s2, i+1, j+1);\\n        }\\n        return memo[i][j] = Math.min((int)s1.charAt(i)+recurse(s1, s2, i+1, j), (int)s2.charAt(j)+recurse(s1,s2, i, j+1));\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841638,
                "title": "java-dp-memoization-lcs-variation-easy",
                "content": "# Intuition\\nThsi problem is slight variation of LCS (Longest Common Subsequence)\\n\\n# Approach\\n- LCS b/w two Strings\\n- Memoization\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n\\n- Space complexity: O(m*n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        Integer[][] dp = new Integer[m][n];\\n\\n        return f(m - 1, n - 1, s1, s2, dp);\\n    }\\n\\n    private int f(int i, int j, String s1, String s2, Integer[][] dp){\\n        if (i < 0 && j < 0)\\n            return 0;\\n        if (i < 0)\\n            return removeAll(s2, j);\\n        if (j < 0)\\n            return removeAll(s1, i);\\n        if (dp[i][j] != null)\\n            return dp[i][j];\\n        if (s1.charAt(i) == s2.charAt(j))\\n            return f(i-1, j-1, s1, s2, dp);\\n\\n        int removeFromS1 = f(i-1, j, s1, s2, dp) + s1.charAt(i);\\n        int removeFromS2 = f(i, j-1, s1, s2, dp) + s2.charAt(j);\\n        return dp[i][j] = Math.min(removeFromS1, removeFromS2);\\n    }\\n\\n    private int removeAll(String s1, int ind){\\n        int ascii = 0;\\n        for (int i = 0; i <= ind; i++){\\n            ascii += s1.charAt(i);\\n        }\\n        return ascii;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        Integer[][] dp = new Integer[m][n];\\n\\n        return f(m - 1, n - 1, s1, s2, dp);\\n    }\\n\\n    private int f(int i, int j, String s1, String s2, Integer[][] dp){\\n        if (i < 0 && j < 0)\\n            return 0;\\n        if (i < 0)\\n            return removeAll(s2, j);\\n        if (j < 0)\\n            return removeAll(s1, i);\\n        if (dp[i][j] != null)\\n            return dp[i][j];\\n        if (s1.charAt(i) == s2.charAt(j))\\n            return f(i-1, j-1, s1, s2, dp);\\n\\n        int removeFromS1 = f(i-1, j, s1, s2, dp) + s1.charAt(i);\\n        int removeFromS2 = f(i, j-1, s1, s2, dp) + s2.charAt(j);\\n        return dp[i][j] = Math.min(removeFromS1, removeFromS2);\\n    }\\n\\n    private int removeAll(String s1, int ind){\\n        int ascii = 0;\\n        for (int i = 0; i <= ind; i++){\\n            ascii += s1.charAt(i);\\n        }\\n        return ascii;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841580,
                "title": "dp-c-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int &a,int &b,string &s1,string &s2,vector<vector<int>> &dp){\\n        if(i==a){\\n            int ans = 0;\\n            while(j<b){\\n                ans += s2[j];\\n                j++;\\n            }\\n            return ans;\\n        }if(j==b){\\n            int ans = 0;\\n            while(i<a){\\n                ans += s1[i];\\n                i++;\\n            }\\n            return ans;\\n        }\\n        if(dp[i][j] != -1)return dp[i][j];\\n        int ans1 = solve(i+1,j,a,b,s1,s2,dp)+s1[i];\\n        int ans2 = solve(i,j+1,a,b,s1,s2,dp)+s2[j];\\n        int ans3 = INT_MAX;\\n        if(s1[i]==s2[j]){\\n            ans3 = solve(i+1,j+1,a,b,s1,s2,dp);\\n        }\\n        return dp[i][j] = min({ans1,ans2,ans3});\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int a = s1.length(),b = s2.length();\\n        vector<vector<int>> dp(a+1,vector<int>(b+1,-1));\\n        return solve(0,0,a,b,s1,s2,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int &a,int &b,string &s1,string &s2,vector<vector<int>> &dp){\\n        if(i==a){\\n            int ans = 0;\\n            while(j<b){\\n                ans += s2[j];\\n                j++;\\n            }\\n            return ans;\\n        }if(j==b){\\n            int ans = 0;\\n            while(i<a){\\n                ans += s1[i];\\n                i++;\\n            }\\n            return ans;\\n        }\\n        if(dp[i][j] != -1)return dp[i][j];\\n        int ans1 = solve(i+1,j,a,b,s1,s2,dp)+s1[i];\\n        int ans2 = solve(i,j+1,a,b,s1,s2,dp)+s2[j];\\n        int ans3 = INT_MAX;\\n        if(s1[i]==s2[j]){\\n            ans3 = solve(i+1,j+1,a,b,s1,s2,dp);\\n        }\\n        return dp[i][j] = min({ans1,ans2,ans3});\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int a = s1.length(),b = s2.length();\\n        vector<vector<int>> dp(a+1,vector<int>(b+1,-1));\\n        return solve(0,0,a,b,s1,s2,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841420,
                "title": "python-dp-712-minimum-ascii-delete-sum-for-two-strings",
                "content": "# Python | DP | 712. Minimum ASCII Delete Sum for Two Strings\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if s1[i - 1] == s2[j - 1]:\\n                    dp[j][i] = dp[j - 1][i - 1] + ord(s1[i - 1])\\n                else:\\n                    dp[j][i] = max(dp[j - 1][i], dp[j][i - 1]) \\n        return sum(map(ord, s1 + s2)) - dp[-1][-1] * 2\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if s1[i - 1] == s2[j - 1]:\\n                    dp[j][i] = dp[j - 1][i - 1] + ord(s1[i - 1])\\n                else:\\n                    dp[j][i] = max(dp[j - 1][i], dp[j][i - 1]) \\n        return sum(map(ord, s1 + s2)) - dp[-1][-1] * 2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840874,
                "title": "simple-c-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,string &a,string &b,vector<vector<int>> &dp)\\n    {\\n        if(dp[i+1][j+1]!=-1) return dp[i+1][j+1];\\n        if(i<0)\\n        {\\n            int t=j;\\n            int ans=0;\\n            while(t>=0)\\n            {\\n                ans+=(int)b[t--];\\n            }\\n            return dp[i+1][j+1]=ans;\\n        }\\n        if(j<0)\\n        {\\n\\n            int t=i;\\n            int ans=0;\\n            while(t>=0)\\n            {\\n                ans+=(int)a[t--];\\n            }\\n            return dp[i+1][j+1]=ans;\\n        }\\n        if(a[i]==b[j])\\n        {\\n            return dp[i+1][j+1]=solve(i-1,j-1,a,b,dp);\\n        }\\n        return dp[i+1][j+1]=min((int)a[i]+solve(i-1,j,a,b,dp),(int)b[j]+solve(i,j-1,a,b,dp));\\n    }\\n    int minimumDeleteSum(string &s1, string &s2) {\\n    int n=s1.size();\\n    int m=s2.size();\\n    vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(s1.size()-1,s2.size()-1,s1,s2,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,string &a,string &b,vector<vector<int>> &dp)\\n    {\\n        if(dp[i+1][j+1]!=-1) return dp[i+1][j+1];\\n        if(i<0)\\n        {\\n            int t=j;\\n            int ans=0;\\n            while(t>=0)\\n            {\\n                ans+=(int)b[t--];\\n            }\\n            return dp[i+1][j+1]=ans;\\n        }\\n        if(j<0)\\n        {\\n\\n            int t=i;\\n            int ans=0;\\n            while(t>=0)\\n            {\\n                ans+=(int)a[t--];\\n            }\\n            return dp[i+1][j+1]=ans;\\n        }\\n        if(a[i]==b[j])\\n        {\\n            return dp[i+1][j+1]=solve(i-1,j-1,a,b,dp);\\n        }\\n        return dp[i+1][j+1]=min((int)a[i]+solve(i-1,j,a,b,dp),(int)b[j]+solve(i,j-1,a,b,dp));\\n    }\\n    int minimumDeleteSum(string &s1, string &s2) {\\n    int n=s1.size();\\n    int m=s2.size();\\n    vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(s1.size()-1,s2.size()-1,s1,s2,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840819,
                "title": "c-solution-for-minimum-ascii-delete-sum-for-two-strings-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to find the lowest ASCII sum of deleted characters to make two strings equal. To achieve this, we can use dynamic programming. The idea is to build a 2D array where each cell represents the minimum ASCII sum of deleted characters needed to make substrings of s1 and s2 equal. By iteratively filling up the array based on the characters\\' matches and mismatches, we can find the minimum sum efficiently.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe dynamic programming approach uses a 2D array dp, where dp[i, j] stores the minimum ASCII sum of deleted characters to make s1.Substring(0, i) and s2.Substring(0, j) equal. The base cases are when one or both strings are empty (i=0 or j=0), where the sum will be equal to the ASCII value of the remaining characters.\\n\\nFor each cell dp[i, j], we have two options:\\n\\nIf the characters at the current positions i and j are equal, no characters need to be deleted, so dp[i, j] will be equal to dp[i-1, j-1].\\nIf the characters are different, we have two choices:\\na. Delete the character at position i from s1, resulting in dp[i, j] = dp[i-1, j] + s1[i].\\nb. Delete the character at position j from s2, resulting in dp[i, j] = dp[i, j-1] + s2[j].\\nWe choose the minimum of these two options as the value of dp[i, j].\\nBy iterating through the characters of both strings and filling up the dp array accordingly, we can find the final answer in dp[s1.Length, s2.Length].\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the dynamic programming approach is O(m * n), where \\'m\\' is the length of s1 and \\'n\\' is the length of s2. We need to fill the entire dp array, and each cell can be computed in constant time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the dynamic programming approach is O(m * n) as well. We use a 2D array dp of dimensions (m + 1) x (n + 1) to store the minimum ASCII sums for the substrings of s1 and s2. The extra \"+1\" is for the base cases when one or both strings are empty. Therefore, the space required is proportional to the product of the lengths of the input strings.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimumDeleteSum(string s1, string s2) {\\n        int m = s1.Length;\\n        int n = s2.Length;\\n\\n        int[,] dp = new int[m + 1, n + 1];\\n\\n        // Initialize base cases\\n        for (int i = 1; i <= m; i++) {\\n            dp[i, 0] = dp[i - 1, 0] + s1[i - 1];\\n        }\\n\\n        for (int j = 1; j <= n; j++) {\\n            dp[0, j] = dp[0, j - 1] + s2[j - 1];\\n        }\\n\\n        // Fill the dp array\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (s1[i - 1] == s2[j - 1]) {\\n                    dp[i, j] = dp[i - 1, j - 1];\\n                } else {\\n                    dp[i, j] = Math.Min(dp[i - 1, j] + s1[i - 1], dp[i, j - 1] + s2[j - 1]);\\n                }\\n            }\\n        }\\n\\n        return dp[m, n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumDeleteSum(string s1, string s2) {\\n        int m = s1.Length;\\n        int n = s2.Length;\\n\\n        int[,] dp = new int[m + 1, n + 1];\\n\\n        // Initialize base cases\\n        for (int i = 1; i <= m; i++) {\\n            dp[i, 0] = dp[i - 1, 0] + s1[i - 1];\\n        }\\n\\n        for (int j = 1; j <= n; j++) {\\n            dp[0, j] = dp[0, j - 1] + s2[j - 1];\\n        }\\n\\n        // Fill the dp array\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (s1[i - 1] == s2[j - 1]) {\\n                    dp[i, j] = dp[i - 1, j - 1];\\n                } else {\\n                    dp[i, j] = Math.Min(dp[i - 1, j] + s1[i - 1], dp[i, j - 1] + s2[j - 1]);\\n                }\\n            }\\n        }\\n\\n        return dp[m, n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673598,
                "title": "longest-common-subsequence-with-ascii-values-as-weights-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumDeleteSum(string s1, string s2) {\\n\\t\\t\\tint m = s1.length();\\n\\t\\t\\tint n = s2.length();\\n\\n\\t\\t\\tvector<vector<int>> dp(m + 1, vector<int>(n + 1));\\n\\n\\t\\t\\t// Initialize the first row and column as 0.\\n\\t\\t\\tfor (int i = 0; i < m + 1; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < n + 1; j++) {\\n\\t\\t\\t\\t\\tif (i == 0 || j == 0) {\\n\\t\\t\\t\\t\\t\\tdp[i][j] = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = 1; i < m + 1; i++) {\\n\\t\\t\\t\\tfor (int j = 1; j < n + 1; j++) {\\n\\t\\t\\t\\t\\tif (s1[i - 1] == s2[j - 1]) {\\n\\t\\t\\t\\t\\t\\t// Use ASCII value of character as weight. So, that we get longest common subsequence with least\\n\\t\\t\\t\\t\\t\\t// ASCII weight.\\n\\t\\t\\t\\t\\t\\tdp[i][j] = s1[i - 1] + dp[i - 1][j - 1];\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// ASCII values to be deleted = ASCII values of all characters - ASCII values of common weighted subsequence.\\n\\t\\t\\tint result = 0;\\n\\n\\t\\t\\tint i = m, j = n;\\n\\n\\t\\t\\twhile (i > 0 && j > 0) {\\n\\t\\t\\t\\tif (s1[i - 1] == s2[j - 1]) {\\n\\t\\t\\t\\t\\t// To a string into a common substring, we need to delete the characters which are not common.\\n\\t\\t\\t\\t\\tresult -= 2 * s1[i - 1];\\n\\t\\t\\t\\t\\tcout << s1[i - 1];\\n\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t\\t} else if (dp[i - 1][j] > dp[i][j - 1]) {\\n\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (char ch: s1)\\n\\t\\t\\t\\tresult += ch;\\n\\t\\t\\tfor (char ch: s2)\\n\\t\\t\\t\\tresult += ch;\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minimumDeleteSum(string s1, string s2) {\\n\\t\\t\\tint m = s1.length();\\n\\t\\t\\tint n = s2.length();\\n\\n\\t\\t\\tvector<vector<int>> dp(m + 1, vector<int>(n + 1));\\n\\n\\t\\t\\t// Initialize the first row and column as 0.\\n\\t\\t\\tfor (int i = 0; i < m + 1; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < n + 1; j++) {\\n\\t\\t\\t\\t\\tif (i == 0 || j == 0) {\\n\\t\\t\\t\\t\\t\\tdp[i][j] = 0;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1892268,
                "title": "lcs-variation-c-approach-explained",
                "content": "Approach\\n1. This question is just a variation of lcs as there we need to find out the length,here we need to find out sum of their ascii values, just a slight change is there i.e we need to add the ascii value of the character to dp[i][j] when s1[i-1]==s2[j-1]\\n2. At last we have our ans which is basically the sum of ascii value of the longest common subsequence. \\n3. Hence the result will be sum1(of chars of string s1) + sum2(of chars of string s2) - 2*dp[n][m] which stores the sum of the LCS between 2 strings\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.size();\\n        int m = s2.size();\\n        int sum1 = 0,sum2 = 0;\\n        for(auto x : s1)\\n            sum1+=x;\\n        for(auto x : s2)\\n            sum2+=x;\\n        int dp[n+1][m+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++){\\n                if(i==0 or j==0)\\n                    dp[i][j]= 0 ;\\n                else if(s1[i-1]==s2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+s1[i-1];\\n                else\\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return sum1 + sum2 - 2*dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.size();\\n        int m = s2.size();\\n        int sum1 = 0,sum2 = 0;\\n        for(auto x : s1)\\n            sum1+=x;\\n        for(auto x : s2)\\n            sum2+=x;\\n        int dp[n+1][m+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++){\\n                if(i==0 or j==0)\\n                    dp[i][j]= 0 ;\\n                else if(s1[i-1]==s2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+s1[i-1];\\n                else\\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return sum1 + sum2 - 2*dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534351,
                "title": "c-recursive-memoization-t-c-o-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int solve(string &s1, string &s2, int x, int y){\\n        if(x==s1.size() or y==s2.size()){\\n            int sum = 0;\\n            for(int i=x;i<s1.size();++i) sum+=int(s1[i]);\\n            for(int i=y;i<s2.size();++i) sum+=int(s2[i]);\\n            return sum;\\n        }\\n        \\n        if(dp[x][y]!=-1) return dp[x][y];\\n        //if both charater are same\\n        if(s1[x]==s2[y]) return solve(s1,s2,x+1,y+1);\\n        //if both charater are not same\\n        int asc1 = int(s1[x]) + solve(s1,s2,x+1,y);\\n        int asc2 = int(s2[y]) + solve(s1,s2,x,y+1);\\n        return dp[x][y] = min(asc1,asc2);\\n    }\\n    \\n    int minimumDeleteSum(string s1, string s2) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s1,s2,0,0);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int solve(string &s1, string &s2, int x, int y){\\n        if(x==s1.size() or y==s2.size()){\\n            int sum = 0;\\n            for(int i=x;i<s1.size();++i) sum+=int(s1[i]);\\n            for(int i=y;i<s2.size();++i) sum+=int(s2[i]);\\n            return sum;\\n        }\\n        \\n        if(dp[x][y]!=-1) return dp[x][y];\\n        //if both charater are same\\n        if(s1[x]==s2[y]) return solve(s1,s2,x+1,y+1);\\n        //if both charater are not same\\n        int asc1 = int(s1[x]) + solve(s1,s2,x+1,y);\\n        int asc2 = int(s2[y]) + solve(s1,s2,x,y+1);\\n        return dp[x][y] = min(asc1,asc2);\\n    }\\n    \\n    int minimumDeleteSum(string s1, string s2) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s1,s2,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407816,
                "title": "c-lcs-variation-iterative-dp",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int minimumDeleteSum(string s1, string s2)\\n    {\\n        int n = s1.size(), m = s2.size(), sum1 = 0, sum2 = 0;\\n        int dp[n+1][m+1];\\n        memset(dp,0,sizeof(dp));\\n\\n        sum1 = accumulate(s1.begin(), s1.end(), 0);\\n        sum2 = accumulate(s2.begin(), s2.end(), 0);\\n\\n        for (int i = 1; i <= n; i++)\\n        {\\n            for (int j = 1; j <= m; j++)\\n            {\\n                if (s1[i - 1] == s2[j - 1])\\n                    dp[i][j] = s1[i - 1] + dp[i - 1][j - 1];\\n                else\\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n        int ans = dp[n][m];\\n        return sum1 + sum2 - 2 * ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minimumDeleteSum(string s1, string s2)\\n    {\\n        int n = s1.size(), m = s2.size(), sum1 = 0, sum2 = 0;\\n        int dp[n+1][m+1];\\n        memset(dp,0,sizeof(dp));\\n\\n        sum1 = accumulate(s1.begin(), s1.end(), 0);\\n        sum2 = accumulate(s2.begin(), s2.end(), 0);\\n\\n        for (int i = 1; i <= n; i++)\\n        {\\n            for (int j = 1; j <= m; j++)\\n            {\\n                if (s1[i - 1] == s2[j - 1])\\n                    dp[i][j] = s1[i - 1] + dp[i - 1][j - 1];\\n                else\\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n        int ans = dp[n][m];\\n        return sum1 + sum2 - 2 * ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283210,
                "title": "explained-dp",
                "content": "we will use the concept of **longest subsequence problem**, if you carefully analyze the examples you will find that the string remaining after deleting words is the longest common subsequence of the two strings,\\nFirst we will find the total ascii values of the two strings, the LCS ascii values is added twice and if we delete the ascii values of this LCS from the total ascii then we will get the ascii value of the characters needs to be deleted,\\n\\nTo make sure that this ascii value is minimum, **make sure to choose longest common subsequence in context of ascii value and not in context of length.**\\n\\nThis is possible by including ascii value in this elseif statement.\\n```\\n else if(s1[i-1]==s2[j-1])\\n         t[i][j]=int(s1[i-1]) + t[i-1][j-1];\\n```\\n\\n**please upvote it if you find helpful ,it will motivate me**\\n\\n```\\n   int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.length();\\n        int m=s2.length();\\n        \\n        int t[n+1][m+1];\\n        memset(t,-1,sizeof(t));\\n        \\n        int total=0;int subtotal=0;\\n        \\n        for(int i=0;i<n;++i)\\n            total+=int(s1[i]);\\n        for(int i=0;i<m;++i)\\n            total+=int(s2[i]);        // find total ascii values of all words of both strings\\n        \\n        for(int i=0;i<=n;++i)\\n        {\\n            for(int j=0;j<=m;++j)\\n            {\\n                if(i==0 or j==0)\\n                    t[i][j]=0;\\n                else if(s1[i-1]==s2[j-1]){\\n                    t[i][j]=int(s1[i-1]) + t[i-1][j-1];\\n                }\\n                else\\n                    t[i][j]=max(t[i][j-1] , t[i-1][j]);\\n            }\\n        }       \\n        return total - 2*t[n][m];   // t[n][m] denotes the max ascii subsequence\\n\\t\\t\\n    }\\n```\\t\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n else if(s1[i-1]==s2[j-1])\\n         t[i][j]=int(s1[i-1]) + t[i-1][j-1];\\n```\n```\\n   int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.length();\\n        int m=s2.length();\\n        \\n        int t[n+1][m+1];\\n        memset(t,-1,sizeof(t));\\n        \\n        int total=0;int subtotal=0;\\n        \\n        for(int i=0;i<n;++i)\\n            total+=int(s1[i]);\\n        for(int i=0;i<m;++i)\\n            total+=int(s2[i]);        // find total ascii values of all words of both strings\\n        \\n        for(int i=0;i<=n;++i)\\n        {\\n            for(int j=0;j<=m;++j)\\n            {\\n                if(i==0 or j==0)\\n                    t[i][j]=0;\\n                else if(s1[i-1]==s2[j-1]){\\n                    t[i][j]=int(s1[i-1]) + t[i-1][j-1];\\n                }\\n                else\\n                    t[i][j]=max(t[i][j-1] , t[i-1][j]);\\n            }\\n        }       \\n        return total - 2*t[n][m];   // t[n][m] denotes the max ascii subsequence\\n\\t\\t\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 920977,
                "title": "simple-c-dp-solution-99-99-faster",
                "content": "A bit modification in longest common subsequence approach.\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.length(), m = s2.length();\\n        int L[n+1][m+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                if(i==0 || j==0) L[i][j] =0;\\n                else\\n                    if(s1[i-1]==s2[j-1])\\n                        L[i][j] = L[i-1][j-1] + s1[i-1];\\n                else\\n                    L[i][j] = max(L[i-1][j], L[i][j-1]);\\n            }\\n        }\\n        int sum =0;\\n        for(int i=0;i<n;i++)\\n            sum += s1[i];\\n        for(int j =0;j<m;j++)\\n            sum +=s2[j];\\n      \\n        return sum-2*L[n][m];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.length(), m = s2.length();\\n        int L[n+1][m+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                if(i==0 || j==0) L[i][j] =0;\\n                else\\n                    if(s1[i-1]==s2[j-1])\\n                        L[i][j] = L[i-1][j-1] + s1[i-1];\\n                else\\n                    L[i][j] = max(L[i-1][j], L[i][j-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 860493,
                "title": "java-optimized-solution-similar-to-lcs",
                "content": "Intution : \\n```\\nAlmost all dp problem revolve around few standard dp problem . if you have grasp of standard dp problem then you can easily solve most the dp Question.\\n\\nStandard Dynammic Problems :\\n   1. Knapsack Problem (0/1)\\n   2. Longest Commom Subsequences\\n   3. Longest Palindrome.\\n   4. Subset Problem.\\n   5. Coin Change Problem\\n   6. Longest Inncreasing Subsequnces\\n\\n\\nThis problem is almost similar to LCS problem. The only difference b/w is that you have to deal with ASCII numbers\\n```\\nJava :\\n```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int n = s1.length(), m = s2.length();\\n        int[][] dp = new int[n+1][m+1];\\n        \\n        for(int i = 1;i < m+1;i++) dp[0][i] += (dp[0][i-1] + (int)s2.charAt(i-1));\\n        for(int i = 1;i < n+1;i++) dp[i][0] += (dp[i-1][0] + (int)s1.charAt(i-1));\\n        \\n        for(int i =1;i < n+1;i++) {\\n            for(int j = 1;j < m+1;j++) {\\n                if(s1.charAt(i-1) == s2.charAt(j-1)) dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    dp[i][j] = Math.min(dp[i][j-1]+(int)s2.charAt(j-1), dp[i-1][j]+(int)s1.charAt(i-1));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nAlmost all dp problem revolve around few standard dp problem . if you have grasp of standard dp problem then you can easily solve most the dp Question.\\n\\nStandard Dynammic Problems :\\n   1. Knapsack Problem (0/1)\\n   2. Longest Commom Subsequences\\n   3. Longest Palindrome.\\n   4. Subset Problem.\\n   5. Coin Change Problem\\n   6. Longest Inncreasing Subsequnces\\n\\n\\nThis problem is almost similar to LCS problem. The only difference b/w is that you have to deal with ASCII numbers\\n```\n```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int n = s1.length(), m = s2.length();\\n        int[][] dp = new int[n+1][m+1];\\n        \\n        for(int i = 1;i < m+1;i++) dp[0][i] += (dp[0][i-1] + (int)s2.charAt(i-1));\\n        for(int i = 1;i < n+1;i++) dp[i][0] += (dp[i-1][0] + (int)s1.charAt(i-1));\\n        \\n        for(int i =1;i < n+1;i++) {\\n            for(int j = 1;j < m+1;j++) {\\n                if(s1.charAt(i-1) == s2.charAt(j-1)) dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    dp[i][j] = Math.min(dp[i][j-1]+(int)s2.charAt(j-1), dp[i-1][j]+(int)s1.charAt(i-1));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812707,
                "title": "c-solution-based-on-lcs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.size();\\n        int m = s2.size();\\n        vector<vector<int>>dp(n+1, vector<int>(m+1,0));\\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j <= m; j++){\\n                if(s1[i-1] == s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1] + s1[i-1];\\n                }\\n                else{\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(auto i : s1) ans += i;\\n        for(auto i : s2) ans += i;\\n        return ans - 2*dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.size();\\n        int m = s2.size();\\n        vector<vector<int>>dp(n+1, vector<int>(m+1,0));\\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j <= m; j++){\\n                if(s1[i-1] == s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1] + s1[i-1];\\n                }\\n                else{\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(auto i : s1) ans += i;\\n        for(auto i : s2) ans += i;\\n        return ans - 2*dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478945,
                "title": "c-99-fast-dp-lcs-base-simple",
                "content": "```\\nint minimumDeleteSum(string s1, string s2) {\\n        int sum=0;\\n        int n = s1.length();\\n        int m = s2.length();\\n        for(int i=0;i<n;i++){\\n            sum+=int(s1[i]);\\n        }\\n        for(int i=0;i<m;i++){\\n            sum+=int(s2[i]);\\n        }\\n        int dp[n+10][m+10];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s1[i-1]==s2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+int(s1[i-1])+int(s2[j-1]);\\n                else\\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return sum-dp[n][m];\\n    \\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint minimumDeleteSum(string s1, string s2) {\\n        int sum=0;\\n        int n = s1.length();\\n        int m = s2.length();\\n        for(int i=0;i<n;i++){\\n            sum+=int(s1[i]);\\n        }\\n        for(int i=0;i<m;i++){\\n            sum+=int(s2[i]);\\n        }\\n        int dp[n+10][m+10];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s1[i-1]==s2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+int(s1[i-1])+int(s2[j-1]);\\n                else\\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return sum-dp[n][m];\\n    \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 108823,
                "title": "java-o-n-similar-idea-of-edit-distance-and-lc-524",
                "content": "LC 72 Edit Distance and  LC 524 Longest Word through Deleting share the same idea as this one. The difference lies in the \"cost\" definition, this question defines \"cost\" as the ASCII sum while the other two as the distance. We just need to simply apply the definition in the program.\\n```\\nclass Solution {\\n    public int minimumDeleteSum(String word1, String word2) {\\n\\t        int m = word1.length();\\n\\t        int n = word2.length();\\n\\t        int[][] dp = new int[m+1][n+1];\\n\\t        for(int i = 0;i <= m;i++){\\n\\t            for(int j = 0;j <= n;j++){\\n\\t                if(i == 0&&j == 0){\\n\\t                    dp[i][j] = 0;\\n\\t                }\\n\\t                else if(i == 0){\\n\\t                    dp[0][j] = dp[0][j-1] + (int)word2.charAt(j-1);\\n\\t                }\\n\\t                else if(j == 0){\\n\\t                    dp[i][0] = dp[i-1][0] + (int)word1.charAt(i-1);\\n\\t                }\\n\\t                else{\\n\\t                    int last = dp[i-1][j-1];\\n\\t                    if(word1.charAt(i-1) != word2.charAt(j-1)){\\n\\t                        last += (int)word1.charAt(i-1) + (int)word2.charAt(j-1);\\n\\t                    }\\n\\t                    dp[i][j] = Math.min(last,Math.min(dp[i-1][j]+(int)word1.charAt(i-1),dp[i][j-1]+(int)word2.charAt(j-1)));\\n\\t                }\\n\\t            }\\n\\t        }\\n\\t        return dp[m][n];\\n\\t    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeleteSum(String word1, String word2) {\\n\\t        int m = word1.length();\\n\\t        int n = word2.length();\\n\\t        int[][] dp = new int[m+1][n+1];\\n\\t        for(int i = 0;i <= m;i++){\\n\\t            for(int j = 0;j <= n;j++){\\n\\t                if(i == 0&&j == 0){\\n\\t                    dp[i][j] = 0;\\n\\t                }\\n\\t                else if(i == 0){\\n\\t                    dp[0][j] = dp[0][j-1] + (int)word2.charAt(j-1);\\n\\t                }\\n\\t                else if(j == 0){\\n\\t                    dp[i][0] = dp[i-1][0] + (int)word1.charAt(i-1);\\n\\t                }\\n\\t                else{\\n\\t                    int last = dp[i-1][j-1];\\n\\t                    if(word1.charAt(i-1) != word2.charAt(j-1)){\\n\\t                        last += (int)word1.charAt(i-1) + (int)word2.charAt(j-1);\\n\\t                    }\\n\\t                    dp[i][j] = Math.min(last,Math.min(dp[i-1][j]+(int)word1.charAt(i-1),dp[i][j-1]+(int)word2.charAt(j-1)));\\n\\t                }\\n\\t            }\\n\\t        }\\n\\t        return dp[m][n];\\n\\t    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868772,
                "title": "space-optimized-dp-solution-c-simple",
                "content": "##### This solution uses the same logic of longest common subsequence. In the DP array, instead of storing length of the longest subsequence, we instead, store the sum of the ascii of the longest common subsequence.\\n\\n```\\n    int solve(string s1, string s2){\\n        const int m = s1.size();\\n        const int n = s2.size();\\n        \\n        vector<vector<int>> dp(2,vector<int> (n+1,0));\\n        for(int i=1;i<=m;++i){\\n            for(int j=1;j<=n;++j){\\n                if(s1[i-1]==s2[j-1]){dp[i&1][j]=(int)s1[(i-1)]+dp[(i-1)&1][j-1];}\\n                else{dp[i&1][j] = max(dp[(i-1)&1][j],dp[i&1][j-1]);}\\n            }\\n        }\\n        return dp[m&1][n];\\n    }\\n    \\n    \\n    int minimumDeleteSum(string s1, string s2) {\\n        const int m = s1.size();\\n        const int n = s2.size();\\n        int common = solve(s1,s2);\\n        int s1ascii = 0, s2ascii = 0;\\n        for(int i=0;i<m;++i){\\n            s1ascii += (int)s1[i];\\n        }\\n        for(int i=0;i<n;++i){\\n            s2ascii += (int)s2[i];\\n        }\\n        return s1ascii+s2ascii-2*common;\\n    }\\n```\\n\\n#### Please upvote if you liked it. Feel free to submit improvement in this code. It will really help me!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int solve(string s1, string s2){\\n        const int m = s1.size();\\n        const int n = s2.size();\\n        \\n        vector<vector<int>> dp(2,vector<int> (n+1,0));\\n        for(int i=1;i<=m;++i){\\n            for(int j=1;j<=n;++j){\\n                if(s1[i-1]==s2[j-1]){dp[i&1][j]=(int)s1[(i-1)]+dp[(i-1)&1][j-1];}\\n                else{dp[i&1][j] = max(dp[(i-1)&1][j],dp[i&1][j-1]);}\\n            }\\n        }\\n        return dp[m&1][n];\\n    }\\n    \\n    \\n    int minimumDeleteSum(string s1, string s2) {\\n        const int m = s1.size();\\n        const int n = s2.size();\\n        int common = solve(s1,s2);\\n        int s1ascii = 0, s2ascii = 0;\\n        for(int i=0;i<m;++i){\\n            s1ascii += (int)s1[i];\\n        }\\n        for(int i=0;i<n;++i){\\n            s2ascii += (int)s2[i];\\n        }\\n        return s1ascii+s2ascii-2*common;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3843707,
                "title": "simple-solution-explained-in-detail-with-examples",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn such questions, when they have already given you to find the least value....you need to understand that we need to try out all the cases...\\n\\nI will be answering this questions\\n\\n**1) How to start thinking when you know that you have to try out all the cases**\\n\\n**2) How do we form the cases....**\\n\\n# **Answer 1)** \\n\\nJust break the string..to the **smallest case possible** ..For eg...If the strings would be **s1 = \"abcd\" s2 = \"dbef\"**...Now what could be the **smallest case possible..**\\n\\nS1 has a size of **1** and S2 has a size of **1**\\n\\nSo , let us just consider the first charcter only...\\n\\ns1 = \"a\" and s2 = \"d\"\\n\\nThis is how you approach...\\n\\n# **Answer 2) **\\n\\nNow s1 = \"a\"  and s2 = \"d\"\\n\\nWe know **they are unequal**, so it is for sure that we need to **delete**..but **what to delete**..we can delete **\"a\"** also, we can delete **\"d\"** also and we can delete **\"a\" and \"d\"** both....\\n\\nSee...this is **how you framed** the cases..yourself\\n\\nIf we delete **\"a\" from s1** , the rest string left will be from **i+1 to s1.size()** (i is the index where \"a\" was there)\\n\\nIf we delete **\"d\" from s2** , then rest string left will be from **j+1 to s2.size()**(j is the index where \"d\" was there)\\n\\nIf we delete both of them , **then both the strings will be left from i+1 to s1.size() and j+1 to s2.size()**...\\n\\nAnd you need to return the min of all three cases..\\n\\nHow do we write this in code \\n\\n```\\n    int x = s1[i];\\n    int y = s2[j];\\n    \\n     int p = x+solve(i+1,j,s1,s2,dp);\\n     int o = y+solve(i,j+1,s1,s2,dp);\\n    int m = x+y+solve(i+1,j+1,s1,s2,dp);\\n \\n    return min(p,min(o,m)); \\n```\\n\\nNow, how do we think of the base cases...\\n\\nLet us say...both the strings **reach their max length possible** \\n\\n1) If **i==s1.size() && j==s2.size()**, can you do something after that...The ans is no, **so just return a 0**\\n\\nCode\\n\\n```\\n    if(i==s1.size() && j==s2.size())\\n    {\\n        return 0;\\n    }\\n```\\n\\nNow, let us say that your string s1 has reached it\\'s end but s2 has still some charcters left...Now, **can you compare the remaining chacrters of s2** with anything..The ans is no, **so just delete all the remianing characters in string s2**\\n\\nCode \\n\\n```\\n    if(i==s1.size())\\n    {\\n        int sum = 0;\\n        for(int k=j; k<s2.size(); k++)\\n        {\\n            sum+=(s2[k]);\\n        }\\n        return sum;\\n    }\\n```\\n\\nNow, apply the same logic **when s2 has reach** it\\'s end **but s1 has come charcters left...**\\n\\n\\nThis is how you do it recursively...\\n\\nNow, how do we memoize..Two parameters are changing\\n\\n**1) Index i of string s1**\\n**2) Index j of string s2**\\n\\nJust make a **2-d dp array** and store the minimum value in this...\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe will be just iterating both the strings and for each character of string 1 we will traverse all charcters of string s2...so **O(S1.SIZE() * S2.SIZE() )**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are making a 2-d dp array of size s1.size() * s2.size()..so \\n**O(s1.size() * s2.size())**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(int i,int j,string &s1, string &s2,vector<vector<int>>&dp)\\n    {\\n\\n        if(i==s1.size() && j==s2.size())\\n        {\\n            return 0;\\n        }\\n\\n        if(i==s1.size())\\n        {\\n            int sum = 0;\\n            for(int k=j; k<s2.size(); k++)\\n            {\\n                sum+=(s2[k]);\\n            }\\n            return sum;\\n        }\\n\\n        if(j==s2.size())\\n        {\\n\\n            int sum = 0;\\n            for(int k=i; k<s1.size(); k++)\\n            {\\n                sum+=(s1[k]);\\n            }\\n            return sum;\\n        }\\n\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        if(s1[i]==s2[j])\\n        {\\n           long long  int a = solve(i+1,j+1,s1,s2,dp);\\n            dp[i][j]=a;\\n            return a;\\n        }\\n\\n        int x = s1[i];\\n        int y = s2[j];\\n        \\n        int p = x+solve(i+1,j,s1,s2,dp);\\n        int o = y+solve(i,j+1,s1,s2,dp);\\n        int m = x+y+solve(i+1,j+1,s1,s2,dp);\\n\\n        dp[i][j] = min(p,min(o,m)); \\n\\n        return min(p,min(o,m)); \\n\\n    }\\n\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        \\n\\n        vector<vector<int>>dp(s1.size()+100,vector<int>(s2.size()+100,-1));\\n        int ans  = solve(0,0,s1,s2,dp);\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n**TIME FOR A MEME NOW**\\n![WhatsApp Image 2023-07-31 at 21.30.48.jpeg](https://assets.leetcode.com/users/images/796f4a3a-b677-4980-8738-c6d46fcf4ee1_1690819280.8432202.jpeg)\\n\\n# **IF YOU LIKE MY SOLUTION, PLEASE UPVOTE..**\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n    int x = s1[i];\\n    int y = s2[j];\\n    \\n     int p = x+solve(i+1,j,s1,s2,dp);\\n     int o = y+solve(i,j+1,s1,s2,dp);\\n    int m = x+y+solve(i+1,j+1,s1,s2,dp);\\n \\n    return min(p,min(o,m)); \\n```\n```\\n    if(i==s1.size() && j==s2.size())\\n    {\\n        return 0;\\n    }\\n```\n```\\n    if(i==s1.size())\\n    {\\n        int sum = 0;\\n        for(int k=j; k<s2.size(); k++)\\n        {\\n            sum+=(s2[k]);\\n        }\\n        return sum;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int solve(int i,int j,string &s1, string &s2,vector<vector<int>>&dp)\\n    {\\n\\n        if(i==s1.size() && j==s2.size())\\n        {\\n            return 0;\\n        }\\n\\n        if(i==s1.size())\\n        {\\n            int sum = 0;\\n            for(int k=j; k<s2.size(); k++)\\n            {\\n                sum+=(s2[k]);\\n            }\\n            return sum;\\n        }\\n\\n        if(j==s2.size())\\n        {\\n\\n            int sum = 0;\\n            for(int k=i; k<s1.size(); k++)\\n            {\\n                sum+=(s1[k]);\\n            }\\n            return sum;\\n        }\\n\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        if(s1[i]==s2[j])\\n        {\\n           long long  int a = solve(i+1,j+1,s1,s2,dp);\\n            dp[i][j]=a;\\n            return a;\\n        }\\n\\n        int x = s1[i];\\n        int y = s2[j];\\n        \\n        int p = x+solve(i+1,j,s1,s2,dp);\\n        int o = y+solve(i,j+1,s1,s2,dp);\\n        int m = x+y+solve(i+1,j+1,s1,s2,dp);\\n\\n        dp[i][j] = min(p,min(o,m)); \\n\\n        return min(p,min(o,m)); \\n\\n    }\\n\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        \\n\\n        vector<vector<int>>dp(s1.size()+100,vector<int>(s2.size()+100,-1));\\n        int ans  = solve(0,0,s1,s2,dp);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842299,
                "title": "c-dp-easy-to-understand-memoization-and-tabulation-both-space-optimized",
                "content": "# Intuition\\nThis problem asks us to make two strings equal by deleting characters and storing the ASCII value of deleted characters and since we have to minimize the answer we have to use Dynamic Programming.\\n\\n# Approach\\n\\nWe will use the basic approach of longest common subsequence to iterate and if we get the same element on both the strings we skip that element and check next on both otherwise we go two ways : first is we will reduce an element from string 1 and add its ASCII to answer and Second would be string 1 remains unchanged and we will decrease an element from string 2 and after both we will store min of both the results in our dp 2 vector at i,j.\\n\\n\\n\\n# Memoized Approach\\n```cpp []\\nclass Solution {\\npublic:\\n\\n    int f(int i, int j, string &s1, string &s2 , vector<vector<int>> &dp)\\n    {\\n        if (i < 0 || j < 0)\\n        {\\n            if (i < 0)\\n            {\\n                int ans = 0;\\n                for (int a = j; a >= 0; a--)\\n                {\\n                    ans += s2[a];\\n                }\\n                return ans;\\n            }\\n\\n            if (j < 0)\\n            {\\n                int ans = 0;\\n                for (int a = i; a >= 0; a--)\\n                {\\n                    ans += s1[a];\\n                }\\n                return ans;\\n            }\\n        }\\n\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        int take=1e9;\\n\\n        if (s1[i] == s2[j])\\n        {\\n            take= f(i - 1, j - 1, s1, s2 ,dp);\\n        }\\n\\n        int nottake = min(int(s1[i]) + f(i - 1, j, s1, s2,dp), int(s2[j]) + f(i, j - 1, s1, s2,dp));\\n\\n        return dp[i][j]= min(take,nottake);\\n\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2)\\n    {\\n        int n=s1.size();\\n        int m=s2.size();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n\\n        return f(n-1, m-1, s1, s2 , dp);\\n    }\\n};\\n```\\n\\n- Time complexity: O( n <sup>2</sup> )\\n\\n- Space complexity: O( n <sup>2</sup> ) + Recursion stack space\\n\\n\\n# Memoization with index shifted to +1\\n```cpp []\\nclass Solution {\\npublic:\\n\\n    int f(int i, int j, string &s1, string &s2, vector<vector<int>> &dp)\\n    {\\n        if (i == 0 || j == 0)\\n        {\\n            if (i == 0)\\n            {\\n                int ans = 0;\\n                for (int a = j - 1; a >= 0; a--)\\n                {\\n                    ans += s2[a];\\n                }\\n                return ans;\\n            }\\n            if (j == 0)\\n            {\\n                int ans = 0;\\n                for (int a = i - 1; a >= 0; a--)\\n                {\\n                    ans += s1[a];\\n                }\\n                return ans;\\n            }\\n        }\\n\\n        if (dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        int take = 1e9;\\n        if (s1[i - 1] == s2[j - 1])\\n        {\\n            take = f(i - 1, j - 1, s1, s2, dp);\\n        }\\n        int nottake = min(int(s1[i - 1]) + f(i - 1, j, s1, s2, dp), int(s2[j - 1]) + f(i, j - 1, s1, s2, dp));\\n\\n        return dp[i][j] = min(take, nottake);\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2)\\n    {\\n        int n = s1.size();\\n        int m = s2.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));\\n\\n        return f(n, m, s1, s2, dp);\\n    }\\n};\\n```\\n- Time complexity: O( n <sup>2</sup> )\\n\\n- Space complexity: O( n <sup>2</sup> ) + Recursion stack space\\n\\n# Tabulation or Bottom-Up Approach\\n### Space Optimized\\n```cpp []\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2)\\n    {\\n        int n = s1.size();\\n        int m = s2.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\\n\\n        for (int i = 1; i <= n; i++)\\n        {\\n            dp[i][0] = dp[i - 1][0] + s1[i-1];\\n        }\\n\\n        for (int i = 1; i <= m; i++)\\n        {\\n            dp[0][i] = dp[0][i - 1] + s2[i-1];\\n        }\\n\\n        for (int i = 1; i <= n; i++)\\n        {\\n            for (int j = 1; j <= m; j++)\\n            {\\n                int take = 1e9;\\n                if (s1[i - 1] == s2[j - 1])\\n                {\\n                    take = dp[i - 1][j - 1];\\n                }\\n                int nottake = min(int(s1[i - 1]) + dp[i - 1][j], int(s2[j - 1]) + dp[i][j - 1]);\\n\\n                dp[i][j] = min(take, nottake);\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```\\n- Time complexity: O( n <sup>2</sup> )\\n\\n- Space complexity: O( n <sup>2</sup> )",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n\\n    int f(int i, int j, string &s1, string &s2 , vector<vector<int>> &dp)\\n    {\\n        if (i < 0 || j < 0)\\n        {\\n            if (i < 0)\\n            {\\n                int ans = 0;\\n                for (int a = j; a >= 0; a--)\\n                {\\n                    ans += s2[a];\\n                }\\n                return ans;\\n            }\\n\\n            if (j < 0)\\n            {\\n                int ans = 0;\\n                for (int a = i; a >= 0; a--)\\n                {\\n                    ans += s1[a];\\n                }\\n                return ans;\\n            }\\n        }\\n\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        int take=1e9;\\n\\n        if (s1[i] == s2[j])\\n        {\\n            take= f(i - 1, j - 1, s1, s2 ,dp);\\n        }\\n\\n        int nottake = min(int(s1[i]) + f(i - 1, j, s1, s2,dp), int(s2[j]) + f(i, j - 1, s1, s2,dp));\\n\\n        return dp[i][j]= min(take,nottake);\\n\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2)\\n    {\\n        int n=s1.size();\\n        int m=s2.size();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n\\n        return f(n-1, m-1, s1, s2 , dp);\\n    }\\n};\\n```\n```cpp []\\nclass Solution {\\npublic:\\n\\n    int f(int i, int j, string &s1, string &s2, vector<vector<int>> &dp)\\n    {\\n        if (i == 0 || j == 0)\\n        {\\n            if (i == 0)\\n            {\\n                int ans = 0;\\n                for (int a = j - 1; a >= 0; a--)\\n                {\\n                    ans += s2[a];\\n                }\\n                return ans;\\n            }\\n            if (j == 0)\\n            {\\n                int ans = 0;\\n                for (int a = i - 1; a >= 0; a--)\\n                {\\n                    ans += s1[a];\\n                }\\n                return ans;\\n            }\\n        }\\n\\n        if (dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        int take = 1e9;\\n        if (s1[i - 1] == s2[j - 1])\\n        {\\n            take = f(i - 1, j - 1, s1, s2, dp);\\n        }\\n        int nottake = min(int(s1[i - 1]) + f(i - 1, j, s1, s2, dp), int(s2[j - 1]) + f(i, j - 1, s1, s2, dp));\\n\\n        return dp[i][j] = min(take, nottake);\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2)\\n    {\\n        int n = s1.size();\\n        int m = s2.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));\\n\\n        return f(n, m, s1, s2, dp);\\n    }\\n};\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2)\\n    {\\n        int n = s1.size();\\n        int m = s2.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\\n\\n        for (int i = 1; i <= n; i++)\\n        {\\n            dp[i][0] = dp[i - 1][0] + s1[i-1];\\n        }\\n\\n        for (int i = 1; i <= m; i++)\\n        {\\n            dp[0][i] = dp[0][i - 1] + s2[i-1];\\n        }\\n\\n        for (int i = 1; i <= n; i++)\\n        {\\n            for (int j = 1; j <= m; j++)\\n            {\\n                int take = 1e9;\\n                if (s1[i - 1] == s2[j - 1])\\n                {\\n                    take = dp[i - 1][j - 1];\\n                }\\n                int nottake = min(int(s1[i - 1]) + dp[i - 1][j], int(s2[j - 1]) + dp[i][j - 1]);\\n\\n                dp[i][j] = min(take, nottake);\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842018,
                "title": "beats-with-runtime-96-with-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n $$O(m*n)$$ \\n\\n- Space complexity:\\n$$O(n)$$ \\n```javascript []\\nvar minimumDeleteSum = function(s1, s2) {\\n  const m = s1.length;\\n  const n = s2.length;\\n  const dp = Array(n + 1).fill(0);\\n\\n  for (let j = 1; j <= n; j++) {\\n    dp[j] = dp[j - 1] + s2.charCodeAt(j - 1);\\n  }\\n\\n  for (let i = 1; i <= m; i++) {\\n    let prev = dp[0];\\n    dp[0] += s1.charCodeAt(i - 1);\\n\\n    for (let j = 1; j <= n; j++) {\\n      const temp = dp[j];\\n      if (s1.charAt(i - 1) === s2.charAt(j - 1)) {\\n        dp[j] = prev;\\n      } else {\\n        dp[j] = Math.min(dp[j] + s1.charCodeAt(i - 1), dp[j - 1] + s2.charCodeAt(j - 1));\\n      }\\n      prev = temp;\\n    }\\n  }\\n\\n  return dp[n];\\n};\\n```\\n```TypeScript []\\nfunction minimumDeleteSum(s1: string, s2: string): number {\\n    const m = s1.length;\\n    const n = s2.length;\\n    const dp = Array(n + 1).fill(0);\\n\\n    for (let j = 1; j <= n; j++) {\\n        dp[j] = dp[j - 1] + s2.charCodeAt(j - 1);\\n    }\\n\\n    for (let i = 1; i <= m; i++) {\\n        let prev = dp[0];\\n        dp[0] += s1.charCodeAt(i - 1);\\n\\n        for (let j = 1; j <= n; j++) {\\n            const temp = dp[j];\\n            if (s1.charAt(i - 1) === s2.charAt(j - 1)) {\\n                dp[j] = prev;\\n            } else {\\n                dp[j] = Math.min(dp[j] + s1.charCodeAt(i - 1), dp[j - 1] + s2.charCodeAt(j - 1));\\n            }\\n            prev = temp;\\n        }\\n    }\\n\\n    return dp[n];\\n}\\n\\n```\\n```Python []\\ndef minimumDeleteSum(s1: str, s2: str) -> int:\\n    m, n = len(s1), len(s2)\\n    dp = [0] * (n + 1)\\n\\n    for j in range(1, n + 1):\\n        dp[j] = dp[j - 1] + ord(s2[j - 1])\\n\\n    for i in range(1, m + 1):\\n        prev = dp[0]\\n        dp[0] += ord(s1[i - 1])\\n\\n        for j in range(1, n + 1):\\n            temp = dp[j]\\n            if s1[i - 1] == s2[j - 1]:\\n                dp[j] = prev\\n            else:\\n                dp[j] = min(dp[j] + ord(s1[i - 1]), dp[j - 1] + ord(s2[j - 1]))\\n            prev = temp\\n\\n    return dp[n]\\n\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "TypeScript",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```javascript []\\nvar minimumDeleteSum = function(s1, s2) {\\n  const m = s1.length;\\n  const n = s2.length;\\n  const dp = Array(n + 1).fill(0);\\n\\n  for (let j = 1; j <= n; j++) {\\n    dp[j] = dp[j - 1] + s2.charCodeAt(j - 1);\\n  }\\n\\n  for (let i = 1; i <= m; i++) {\\n    let prev = dp[0];\\n    dp[0] += s1.charCodeAt(i - 1);\\n\\n    for (let j = 1; j <= n; j++) {\\n      const temp = dp[j];\\n      if (s1.charAt(i - 1) === s2.charAt(j - 1)) {\\n        dp[j] = prev;\\n      } else {\\n        dp[j] = Math.min(dp[j] + s1.charCodeAt(i - 1), dp[j - 1] + s2.charCodeAt(j - 1));\\n      }\\n      prev = temp;\\n    }\\n  }\\n\\n  return dp[n];\\n};\\n```\n```TypeScript []\\nfunction minimumDeleteSum(s1: string, s2: string): number {\\n    const m = s1.length;\\n    const n = s2.length;\\n    const dp = Array(n + 1).fill(0);\\n\\n    for (let j = 1; j <= n; j++) {\\n        dp[j] = dp[j - 1] + s2.charCodeAt(j - 1);\\n    }\\n\\n    for (let i = 1; i <= m; i++) {\\n        let prev = dp[0];\\n        dp[0] += s1.charCodeAt(i - 1);\\n\\n        for (let j = 1; j <= n; j++) {\\n            const temp = dp[j];\\n            if (s1.charAt(i - 1) === s2.charAt(j - 1)) {\\n                dp[j] = prev;\\n            } else {\\n                dp[j] = Math.min(dp[j] + s1.charCodeAt(i - 1), dp[j - 1] + s2.charCodeAt(j - 1));\\n            }\\n            prev = temp;\\n        }\\n    }\\n\\n    return dp[n];\\n}\\n\\n```\n```Python []\\ndef minimumDeleteSum(s1: str, s2: str) -> int:\\n    m, n = len(s1), len(s2)\\n    dp = [0] * (n + 1)\\n\\n    for j in range(1, n + 1):\\n        dp[j] = dp[j - 1] + ord(s2[j - 1])\\n\\n    for i in range(1, m + 1):\\n        prev = dp[0]\\n        dp[0] += ord(s1[i - 1])\\n\\n        for j in range(1, n + 1):\\n            temp = dp[j]\\n            if s1[i - 1] == s2[j - 1]:\\n                dp[j] = prev\\n            else:\\n                dp[j] = min(dp[j] + ord(s1[i - 1]), dp[j - 1] + ord(s2[j - 1]))\\n            prev = temp\\n\\n    return dp[n]\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3841408,
                "title": "c-o-n-fastest-23ms-optimal-712-minimum-ascii-delete-sum-for-two-strings",
                "content": "# C++ | O(n) | Fastest | <23ms | Optimal | 712. Minimum ASCII Delete Sum for Two Strings\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<int> dp(n+1, 0);\\n        for (int j = 1; j <= n; j++)\\n            dp[j] = dp[j-1]+s2[j-1];\\n        for (int i = 1; i <= m; i++) {\\n            int t1 = dp[0];\\n            dp[0] += s1[i-1];\\n            for (int j = 1; j <= n; j++) {\\n                int t2 = dp[j];\\n                dp[j] = s1[i-1] == s2[j-1]? t1:min(dp[j]+s1[i-1], dp[j-1]+s2[j-1]);\\n                t1 = t2;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<int> dp(n+1, 0);\\n        for (int j = 1; j <= n; j++)\\n            dp[j] = dp[j-1]+s2[j-1];\\n        for (int i = 1; i <= m; i++) {\\n            int t1 = dp[0];\\n            dp[0] += s1[i-1];\\n            for (int j = 1; j <= n; j++) {\\n                int t2 = dp[j];\\n                dp[j] = s1[i-1] == s2[j-1]? t1:min(dp[j]+s1[i-1], dp[j-1]+s2[j-1]);\\n                t1 = t2;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841332,
                "title": "video-solution-java-c",
                "content": "# Intuition, approach and time complexity dicussed in detail in video explanation\\nhttps://youtu.be/rgvfvLfqdtM\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string str1, string str2) {\\n        int sz1 = str1.size(), sz2 = str2.size();\\n        vector<vector<int>> indxChoice(sz1+1, vector<int>(sz2+1, 0));\\n        int asciSum = 0;\\n        for(auto c : str1){\\n           asciSum += c - \\'a\\' + 97;\\n        }\\n        for(auto c : str2){\\n           asciSum += c - \\'a\\' + 97;\\n        }\\n        for(int indx1 = 1; indx1 <= sz1; indx1++){\\n            for(int indx2 = 1; indx2 <= sz2; indx2++){\\n                if(str1[indx1-1] == str2[indx2-1]){\\n                    indxChoice[indx1][indx2] = str1[indx1-1]-\\'a\\' + 97 + indxChoice[indx1-1][indx2-1];\\n                }else{\\n                     indxChoice[indx1][indx2] = max(indxChoice[indx1-1][indx2], indxChoice[indx1][indx2-1]); \\n                }\\n            }\\n        }\\n        return asciSum - 2 * indxChoice[sz1][sz2];\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int sz1 = s1.length(), sz2 = s2.length();\\n        int indxChoice[][] = new int[sz1+1][sz2+1];\\n        char str1[] = s1.toCharArray();\\n        char str2[] = s2.toCharArray();\\n        int asciSum = 0;\\n        for(var c : str1){\\n           asciSum += c - \\'a\\' + 97;\\n        }\\n        for(var c : str2){\\n           asciSum += c - \\'a\\' + 97;\\n        }\\n        for(int indx1 = 1; indx1 <= sz1; indx1++){\\n            for(int indx2 = 1; indx2 <= sz2; indx2++){\\n                if(str1[indx1-1] == str2[indx2-1]){\\n                    indxChoice[indx1][indx2] = str1[indx1-1]-\\'a\\' + 97 + indxChoice[indx1-1][indx2-1];\\n                }else{\\n                     indxChoice[indx1][indx2] = Math.max(indxChoice[indx1-1][indx2], indxChoice[indx1][indx2-1]); \\n                }\\n            }\\n        }\\n        return asciSum - 2 * indxChoice[sz1][sz2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string str1, string str2) {\\n        int sz1 = str1.size(), sz2 = str2.size();\\n        vector<vector<int>> indxChoice(sz1+1, vector<int>(sz2+1, 0));\\n        int asciSum = 0;\\n        for(auto c : str1){\\n           asciSum += c - \\'a\\' + 97;\\n        }\\n        for(auto c : str2){\\n           asciSum += c - \\'a\\' + 97;\\n        }\\n        for(int indx1 = 1; indx1 <= sz1; indx1++){\\n            for(int indx2 = 1; indx2 <= sz2; indx2++){\\n                if(str1[indx1-1] == str2[indx2-1]){\\n                    indxChoice[indx1][indx2] = str1[indx1-1]-\\'a\\' + 97 + indxChoice[indx1-1][indx2-1];\\n                }else{\\n                     indxChoice[indx1][indx2] = max(indxChoice[indx1-1][indx2], indxChoice[indx1][indx2-1]); \\n                }\\n            }\\n        }\\n        return asciSum - 2 * indxChoice[sz1][sz2];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int sz1 = s1.length(), sz2 = s2.length();\\n        int indxChoice[][] = new int[sz1+1][sz2+1];\\n        char str1[] = s1.toCharArray();\\n        char str2[] = s2.toCharArray();\\n        int asciSum = 0;\\n        for(var c : str1){\\n           asciSum += c - \\'a\\' + 97;\\n        }\\n        for(var c : str2){\\n           asciSum += c - \\'a\\' + 97;\\n        }\\n        for(int indx1 = 1; indx1 <= sz1; indx1++){\\n            for(int indx2 = 1; indx2 <= sz2; indx2++){\\n                if(str1[indx1-1] == str2[indx2-1]){\\n                    indxChoice[indx1][indx2] = str1[indx1-1]-\\'a\\' + 97 + indxChoice[indx1-1][indx2-1];\\n                }else{\\n                     indxChoice[indx1][indx2] = Math.max(indxChoice[indx1-1][indx2], indxChoice[indx1][indx2-1]); \\n                }\\n            }\\n        }\\n        return asciSum - 2 * indxChoice[sz1][sz2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841252,
                "title": "c-dynamic-programming-similar-to-edit-distance",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = (int)s1.size(), m = (int)s2.size();\\n        vector<vector<int>> dp(n + 1, vector<int> (m + 1, 0));\\n\\n        for (int i = 1; i <= n; i++) {\\n            dp[i][0] = dp[i - 1][0] + s1[i - 1];\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            dp[0][i] = dp[0][i - 1] + s2[i - 1];\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (s1[i - 1] == s2[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n                else {\\n                    dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);\\n                }\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = (int)s1.size(), m = (int)s2.size();\\n        vector<vector<int>> dp(n + 1, vector<int> (m + 1, 0));\\n\\n        for (int i = 1; i <= n; i++) {\\n            dp[i][0] = dp[i - 1][0] + s1[i - 1];\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            dp[0][i] = dp[0][i - 1] + s2[i - 1];\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (s1[i - 1] == s2[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n                else {\\n                    dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);\\n                }\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841179,
                "title": "easiest-explanation-using-lcs-beginner-friendly-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n[Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the sum of ascii values of the characters which are part of the LCS. (**sum**)\\n2. Find the sum of all ASCII value of both the strings. (**sum1** and **sum2** repectively)\\n3. The required ans is **sum1 + sum2 - 2*sum**.\\n\\n\\n#### Explanation of LCS:\\n1. Traverse both the strings simultaneously.\\n2. If **s1[i] == s2[j]**, this means this particular character (s1[i]) is part of our LCS, so in the recursive call increment both the pointers simulatneously.\\n**( **ans = s1[i] + solveMem(s1, s2, i + 1, j + 1, dp);** )**\\n3. If s**1[i] != s2[j]** take the max value by incrementing \\'i\\' pointer once and then \\'j\\' pointer. \\n**( **ans = max(solveMem(s1, s2, i + 1, j, dp), solveMem(s1, s2, i, j + 1, dp));** )**\\n4. Use top-down approach and store the ans in dp vector **( **dp[i][j] = ans;** )** and also check for the pre-computed an **( **if(dp[i][j] != -1) return dp[i][j];** )**.\\n\\n\\n### Feel free to post your doubts in the comment section.\\n\\n# Complexity\\n- Time complexity: **O(s1.size() * s2.size())**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(s1.size() * s2.size())**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solveMem(string &s1, string &s2, int i, int j, vector<vector<int>> &dp) {\\n        if(i >= s1.size() || j >= s2.size()) return 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int ans = 0;\\n\\n        if(s1[i] == s2[j]) {\\n            ans = s1[i] + solveMem(s1, s2, i + 1, j + 1, dp);\\n        }\\n        else {\\n            ans = max(solveMem(s1, s2, i + 1, j, dp), solveMem(s1, s2, i, j + 1, dp));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        vector<vector<int>> dp(s1.size(), vector<int>(s2.size(), -1));\\n\\n        int totals1 = 0, totals2 = 0;\\n\\n        for(int i = 0; i < s1.size(); i++) {\\n            totals1 += s1[i];\\n        }\\n        for(int j = 0; j < s2.size(); j++) {\\n            totals2 += s2[j];\\n        }\\n        return totals1 + totals2 - 2*solveMem(s1, s2, 0, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solveMem(string &s1, string &s2, int i, int j, vector<vector<int>> &dp) {\\n        if(i >= s1.size() || j >= s2.size()) return 0;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int ans = 0;\\n\\n        if(s1[i] == s2[j]) {\\n            ans = s1[i] + solveMem(s1, s2, i + 1, j + 1, dp);\\n        }\\n        else {\\n            ans = max(solveMem(s1, s2, i + 1, j, dp), solveMem(s1, s2, i, j + 1, dp));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        vector<vector<int>> dp(s1.size(), vector<int>(s2.size(), -1));\\n\\n        int totals1 = 0, totals2 = 0;\\n\\n        for(int i = 0; i < s1.size(); i++) {\\n            totals1 += s1[i];\\n        }\\n        for(int j = 0; j < s2.size(); j++) {\\n            totals2 += s2[j];\\n        }\\n        return totals1 + totals2 - 2*solveMem(s1, s2, 0, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841141,
                "title": "java-solution-tabulation-beats-94-properly-explained-like-or-upvote-also-comment-if-it-helps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used here is to build a 2D array `dp` of size `(m+1) x (n+1)`, where `m` is the length of `s1` and `n` is the length of `s2`. Each cell `dp[i][j]` of the array represents the minimum ASCII delete sum for the substrings `s1[0:i]` and `s2[0:j]`. The goal is to find `dp[m][n]`, which will represent the minimum ASCII delete sum for the entire strings `s1` and `s2`.\\n\\n**Explanation of the Formula:**\\n\\nThe formula `dp[i][j] = dp[i - 1][j - 1] + s1.charAt(i - 1)` is used when the characters at the current positions (`i-1` and `j-1`) in both `s1` and `s2` are the same. In this case, no deletions are needed, so we can safely add the ASCII value of the current character to the `dp` value of the previous positions (`i-1` and `j-1`) in the array.\\n\\n**Explanation of the Else Part:**\\n\\nThe `else` part of the code (`dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])`) is used when the characters at the current positions in `s1` and `s2` are different. In this case, we need to decide which character to delete to minimize the ASCII sum.\\n\\n- If we delete the character at position `i-1` in `s1`, then the minimum ASCII delete sum for the current position is equal to `dp[i-1][j]` (i.e., we delete the character in `s1` and consider the substring `s1[0:i-1]` and `s2[0:j]`).\\n- If we delete the character at position `j-1` in `s2`, then the minimum ASCII delete sum for the current position is equal to `dp[i][j-1]` (i.e., we delete the character in `s2` and consider the substring `s1[0:i]` and `s2[0:j-1]`).\\n\\nSo, the final `dp[i][j]` is the maximum of these two values since we want to minimize the ASCII delete sum.\\n\\n**Overall Algorithm:**\\n\\n1. Create a 2D array `dp` of size `(m+1) x (n+1)` and initialize its first row and first column to 0 since empty substrings have a minimum ASCII delete sum of 0.\\n2. Use nested loops to iterate through the characters of `s1` and `s2`.\\n3. At each position, apply the formula explained above (`dp[i][j] = dp[i - 1][j - 1] + s1.charAt(i - 1)`) when characters are equal, or use the `else` part to decide which character to delete and minimize the ASCII delete sum.\\n4. The final result is obtained from `dp[m][n]`, which represents the minimum ASCII delete sum for the entire strings `s1` and `s2`.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this dynamic programming approach is O(m * n), where `m` is the length of `s1` and `n` is the length of `s2`. This is because we fill the entire `dp` array of size `(m+1) x (n+1)` using nested loops.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(m * n) as well, due to the use of the `dp` array.\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        int[][] dp = new int[m + 1][n + 1];\\n\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n                    dp[i][j] = dp[i - 1][j - 1] + s1.charAt(i - 1);\\n                } else {\\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\\n                }\\n            }\\n        }\\n\\n        int p = 0;\\n        int q = 0;\\n        for (int i = 0; i < m; i++) {\\n            p += s1.charAt(i);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            q += s2.charAt(i);\\n        }\\n\\n        return p + q - 2 * dp[m][n];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        int[][] dp = new int[m + 1][n + 1];\\n\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n                    dp[i][j] = dp[i - 1][j - 1] + s1.charAt(i - 1);\\n                } else {\\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\\n                }\\n            }\\n        }\\n\\n        int p = 0;\\n        int q = 0;\\n        for (int i = 0; i < m; i++) {\\n            p += s1.charAt(i);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            q += s2.charAt(i);\\n        }\\n\\n        return p + q - 2 * dp[m][n];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840746,
                "title": "python-simple-6-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis solution aims to find the longest common subsequence of two strings while considering the ASCII values of the characters as their associated costs.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach involves transforming both input strings into lists of ASCII numbers. Then, dynamic programming (DP) is used to find the longest common subsequence while considering the ASCII costs of characters. The code simplifies the conditional branches by embedding them within the max function.\\n\\n# Complexity\\n- Time complexity: $$O(NM)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $$O(NM)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwhere M is the length of s1 and N is the length of s2.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        s1, s2 = list(map(ord, s1)), list(map(ord, s2))\\n        m, n = len(s1), len(s2)\\n        dp = [[0 for _ in range(m)] for _ in range(n)]   \\n        for j, i in product(range(m), range(n)):\\n            dp[i][j] = max((j>0) * dp[i][j-1], \\n                           (i>0) * dp[i-1][j], \\n                           (s1[j] == s2[i]) * ((i>0 and j >0) * dp[i-1][j-1] + s1[j]))\\n        return sum(s1) + sum(s2) - 2 * dp[-1][-1]\\n```\\n\\n# Example\\nDP Table with ASCII Costs for s1 = \"delete\" and s2 = \"leet\"\\n\\n<table>\\n    <tr>\\n        <th></th>\\n        <th>d (100)</th>\\n        <th>e (101)</th>\\n        <th>l (108)</th>\\n        <th>e (101)</th>\\n        <th>t (116)</th>\\n        <th>e (101)</th>\\n    </tr>\\n    <tr>\\n        <th>l (108)</th>\\n        <td>0</td>\\n        <td>0</td>\\n        <td>108</td>\\n        <td>108</td>\\n        <td>108</td>\\n        <td>108</td>\\n    </tr>\\n    <tr>\\n        <th>e (101)</th>\\n        <td>0</td>\\n        <td>101</td>\\n        <td>108</td>\\n        <td>209</td>\\n        <td>209</td>\\n        <td>209</td>\\n    </tr>\\n    <tr>\\n        <th>e (101)</th>\\n        <td>0</td>\\n        <td>101</td>\\n        <td>209</td>\\n        <td>209</td>\\n        <td>317</td>\\n        <td>317</td>\\n    </tr>\\n    <tr>\\n        <th>t (116)</th>\\n        <td>0</td>\\n        <td>101</td>\\n        <td>209</td>\\n        <td>209</td>\\n        <td>317</td>\\n        <td>433</td>\\n    </tr>\\n</table>\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        s1, s2 = list(map(ord, s1)), list(map(ord, s2))\\n        m, n = len(s1), len(s2)\\n        dp = [[0 for _ in range(m)] for _ in range(n)]   \\n        for j, i in product(range(m), range(n)):\\n            dp[i][j] = max((j>0) * dp[i][j-1], \\n                           (i>0) * dp[i-1][j], \\n                           (s1[j] == s2[i]) * ((i>0 and j >0) * dp[i-1][j-1] + s1[j]))\\n        return sum(s1) + sum(s2) - 2 * dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840707,
                "title": "java-solution-dynamic-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        int[][] dp = new int[m+1][n+1];\\n\\t\\t//initialize first column with s1 values\\n        for(int i=1; i<=m; i++){\\n            dp[i][0] = dp[i-1][0] + s1.charAt(i-1);\\n        }\\n\\t\\t//initialize first row with s2 values\\n        for(int i=1; i<=n; i++){\\n            dp[0][i] = dp[0][i-1] + s2.charAt(i-1);\\n        }\\n        for(int i=1; i<=m; i++){\\n            for(int j=1; j<=n; j++){\\n\\t\\t\\t\\t// if both characters are equal then use previous diagonal value\\n                if(s1.charAt(i-1) == s2.charAt(j-1)){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = Math.min(\\n                        dp[i-1][j] + s1.charAt(i-1),\\n                        dp[i][j-1] + s2.charAt(j-1)\\n                    );\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```\\n\\n![1271c6fe-345b-4f3d-959e-d13e791111d7_1677726484.8832572.jpeg](https://assets.leetcode.com/users/images/a0c4b959-7a81-4baa-a79e-fabb20808bf4_1690768432.6453123.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        int[][] dp = new int[m+1][n+1];\\n\\t\\t//initialize first column with s1 values\\n        for(int i=1; i<=m; i++){\\n            dp[i][0] = dp[i-1][0] + s1.charAt(i-1);\\n        }\\n\\t\\t//initialize first row with s2 values\\n        for(int i=1; i<=n; i++){\\n            dp[0][i] = dp[0][i-1] + s2.charAt(i-1);\\n        }\\n        for(int i=1; i<=m; i++){\\n            for(int j=1; j<=n; j++){\\n\\t\\t\\t\\t// if both characters are equal then use previous diagonal value\\n                if(s1.charAt(i-1) == s2.charAt(j-1)){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = Math.min(\\n                        dp[i-1][j] + s1.charAt(i-1),\\n                        dp[i][j-1] + s2.charAt(j-1)\\n                    );\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840691,
                "title": "easy-c-solution-simple-dp-approach-beats-100-in-both",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<int> dp(n+1, 0);\\n        for (int j = 1; j <= n; j++)\\n            dp[j] = dp[j-1]+s2[j-1];\\n        for (int i = 1; i <= m; i++) {\\n            int t1 = dp[0];\\n            dp[0] += s1[i-1];\\n            for (int j = 1; j <= n; j++) {\\n                int t2 = dp[j];\\n                dp[j] = s1[i-1] == s2[j-1]? t1:min(dp[j]+s1[i-1], dp[j-1]+s2[j-1]);\\n                t1 = t2;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<int> dp(n+1, 0);\\n        for (int j = 1; j <= n; j++)\\n            dp[j] = dp[j-1]+s2[j-1];\\n        for (int i = 1; i <= m; i++) {\\n            int t1 = dp[0];\\n            dp[0] += s1[i-1];\\n            for (int j = 1; j <= n; j++) {\\n                int t2 = dp[j];\\n                dp[j] = s1[i-1] == s2[j-1]? t1:min(dp[j]+s1[i-1], dp[j-1]+s2[j-1]);\\n                t1 = t2;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840657,
                "title": "ruby-iterative-dp-solution",
                "content": "```\\ndef minimum_delete_sum(s1, s2)\\n  dp = Array.new(s1.size+1) { Array.new(s2.size+1, 0) }\\n  s2.size.times {|j|\\n    dp[0][j+1] = dp[0][j] + s2[j].ord\\n  }\\n  s1.size.times {|i|\\n    dp[i+1][0] = dp[i][0] + s1[i].ord\\n    s2.size.times {|j|\\n      if s1[i] == s2[j]\\n        dp[i+1][j+1] = dp[i][j]\\n      else  \\n        dp[i+1][j+1] = [\\n          dp[i][j+1] + s1[i].ord,\\n          dp[i+1][j] + s2[j].ord,\\n        ].min \\n      end\\n    }\\n  }\\n  dp.last.last\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef minimum_delete_sum(s1, s2)\\n  dp = Array.new(s1.size+1) { Array.new(s2.size+1, 0) }\\n  s2.size.times {|j|\\n    dp[0][j+1] = dp[0][j] + s2[j].ord\\n  }\\n  s1.size.times {|i|\\n    dp[i+1][0] = dp[i][0] + s1[i].ord\\n    s2.size.times {|j|\\n      if s1[i] == s2[j]\\n        dp[i+1][j+1] = dp[i][j]\\n      else  \\n        dp[i+1][j+1] = [\\n          dp[i][j+1] + s1[i].ord,\\n          dp[i+1][j] + s2[j].ord,\\n        ].min \\n      end\\n    }\\n  }\\n  dp.last.last\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3840521,
                "title": "daily-leetcoding-challenge-july-day-31",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Top-down Dynamic Programming\n\n  \n**Approach 3:** Bottom-up Dynamic Programming\n\n  \n**Approach 4:** Space-Optimized Bottom-up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3756315,
                "title": "dp-cpp-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int get_min(string&s1, string&s2,int i ,int j , vector<int>&Sufix1, vector<int>&Sufix2,vector<vector<int>>&dp){\\n        if(i >= s1.size()  && j >= s2.size()) return 0;\\n        if(i >= s1.size()  && j < s2.size()) return Sufix2[j];\\n        if(i < s1.size()  && j >= s2.size()) return Sufix1[i];\\n\\n        if(dp[i][j] != -1 ) return dp[i][j];\\n        int sum = 0;\\n\\n        if(s1[i] == s2[j])\\n            sum += get_min(s1,s2,i+1,j+1,Sufix1,Sufix2,dp);\\n        else \\n            sum += min( s1[i] + get_min(s1,s2,i+1,j,Sufix1,Sufix2,dp),s2[j] + get_min(s1,s2,i,j+1,Sufix1,Sufix2,dp));\\n\\n        return dp[i][j] = sum;\\n        }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.size();\\n        int n2 = s2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n2+1,-1));\\n        vector<int>Sufix1(n);\\n        vector<int>Sufix2(n2);\\n\\n        Sufix1[n-1] = s1[n-1];\\n        Sufix2[n2-1] = s2[n2-1];\\n\\n        for(int i = n-2;i>=0;i--) Sufix1[i] = Sufix1[i+1] + s1[i];\\n        for(int i = n2-2;i>=0;i--) Sufix2[i] = Sufix2[i+1] + s2[i];\\n\\n        return get_min(s1,s2,0,0,Sufix1,Sufix2,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int get_min(string&s1, string&s2,int i ,int j , vector<int>&Sufix1, vector<int>&Sufix2,vector<vector<int>>&dp){\\n        if(i >= s1.size()  && j >= s2.size()) return 0;\\n        if(i >= s1.size()  && j < s2.size()) return Sufix2[j];\\n        if(i < s1.size()  && j >= s2.size()) return Sufix1[i];\\n\\n        if(dp[i][j] != -1 ) return dp[i][j];\\n        int sum = 0;\\n\\n        if(s1[i] == s2[j])\\n            sum += get_min(s1,s2,i+1,j+1,Sufix1,Sufix2,dp);\\n        else \\n            sum += min( s1[i] + get_min(s1,s2,i+1,j,Sufix1,Sufix2,dp),s2[j] + get_min(s1,s2,i,j+1,Sufix1,Sufix2,dp));\\n\\n        return dp[i][j] = sum;\\n        }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.size();\\n        int n2 = s2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n2+1,-1));\\n        vector<int>Sufix1(n);\\n        vector<int>Sufix2(n2);\\n\\n        Sufix1[n-1] = s1[n-1];\\n        Sufix2[n2-1] = s2[n2-1];\\n\\n        for(int i = n-2;i>=0;i--) Sufix1[i] = Sufix1[i+1] + s1[i];\\n        for(int i = n2-2;i>=0;i--) Sufix2[i] = Sufix2[i+1] + s2[i];\\n\\n        return get_min(s1,s2,0,0,Sufix1,Sufix2,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551638,
                "title": "c-top-down-memoisation-50ms-10-8mb",
                "content": "This problem has a degree of complexity that can quickly spiral out of control, unless we play a bit smart and store intermediate results as we go, in a classic Dynamic Programming (DP) fashion.\\n\\nOur general scenario when comparing two characters can be split into two sub-cases:\\n* if both characters we are comparing are the same, no cost is associated with the removal;\\n* if they differ, we will take the minimum between what it would cost to remove the current character from the first string and proceed with it, versus doing the same with the current character of the second string.\\n\\nVisually, displaying only the indexes of each character:\\n\\n```cpp\\n01234567 // s1\\n012345   // s2\\n```\\n\\nIf the characters at `0` for `s1` and `0` for `s2` match, we are fine and dandy, no costs associated and we proceed to check the cost of having the two strings match as if they both started from position `1`. Visually again, it equates to computing the result to this problem:\\n\\n```cpp\\n1234567  // s1\\n12345    // s2\\n```\\n\\nIf the characters at `0` for `s1` and `0` for `s2` did not match, we need to compute the minimum between the ASCII code of the character at `0` for `s1` plus matching the strings from position `1` for `s1` and `0` for `s2` match versus the ASCII code of the character at `0` for `s2` plus matching the strings from position `0` for `s1` and `1` for `s2`. The two options, visually:\\n\\n```cpp\\n// we will have to take the minimum cost between\\n// parsing these two options:\\n\\n// ASCII code of s1[0] + the cost of solving the problem for\\n1234567  // s1\\n012345   // s2\\n\\n- OR -\\n\\n// ASCII code of s2[0] + the cost of solving the problem for\\n01234567 // s1\\n12345    // s2\\n```\\n\\nNow, similarly to what we would do with a Fibonacci problem, we can solve this one with a top down approach, starting from the the first two characters and working our way down to the last ones; we will also employ memoisation to avoid re-computing the same results over and over again.\\n\\nTo do so, we will start with a few instance variables:\\n* `s1` and `s2` will store a copy of our riginal input strings;\\n* `memo` will be a 2D array and the base for our memoisation effort;\\n* `l1` and `l2` will store the lengths of the input strings.\\n\\nIn our main function, we will make sure that the first input string is not larger (in order to optimise later for prefilling `memo`) and then populate all the instance variables as expected (with every useful cell in `memo` going to be set to `-1` as a mark of not explored before) and then `return` the result of calling `dfs`.\\n\\nThis helper function will take two indexes `i1` and `i2`, initially defaulted to both be `0` (ie: pointing to the first character) and it will:\\n* `return` `0` when both indexes are out of boundaries (ie: `i1 == l1 && i2 == l2`, meaning we are done parsing both strings, so no more costs to consider);\\n* `return` a precomputed value when we have one (ie: `memo[i1][i2] != -1`);\\n* `return` the sum of all the ASCII codes of the remaining characters in `s2` when `i1` has reached the end of `s1` (ie: `i1 == l1`);\\n* `return` the sum of all the ASCII codes of the remaining characters in `s1` when `i2` has reached the end of `s2` (ie: `i2 == l2`);\\n* store the current characters in `c1` and `c2`, respectively;\\n* compute the current result by checking if `c1 == c2` and:\\n    * if so, proceed with the value of calling `dfs` with both indexes increased;\\n    * if not, compute the mininum between the cost of removing `c1` and calling `dfs` advancing only `i1` versus the cost of removing `c2` and calling `dfs` advancing only `i2`;\\n* store this result in `memo[i1][i2]`;\\n* `return` it.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\n    string s1, s2;\\n    int memo[1000][1000], l1, l2;\\n    int dfs(int i1 = 0, int i2 = 0) {\\n        // base case: end of the run for both\\n        if (i1 == l1 && i2 == l2) return 0;\\n        // base case: already computed result\\n        if (memo[i1][i2] != -1) return memo[i1][i2];\\n        // base case: end of the run for one\\n        if (i1 == l1) return memo[i1][i2] = accumulate(begin(s2) + i2, end(s2), 0);\\n        if (i2 == l2) return memo[i1][i2] = accumulate(begin(s1) + i1, end(s1), 0);\\n        // general case\\n        int c1 = s1[i1], c2 = s2[i2];\\n        return memo[i1][i2] = c1 == c2 ? dfs(i1 + 1, i2 + 1) : min(\\n            c1 + dfs(i1 + 1, i2),\\n            c2 + dfs(i1, i2 + 1)\\n        );\\n    }\\npublic:\\n    int minimumDeleteSum(string t1, string t2) {\\n        // making sure that t1 is not bigger\\n        if (t1.size() > t2.size()) swap(t1, t2);\\n        // populating instance variables\\n        swap(s1, t1);\\n        swap(s2, t2);\\n        l1 = s1.size(), l2 = s2.size();\\n        memset(memo, -1, (l1 + 1) * 1000 * sizeof(int));\\n        return dfs();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```cpp\\n01234567 // s1\\n012345   // s2\\n```\n```cpp\\n1234567  // s1\\n12345    // s2\\n```\n```cpp\\n// we will have to take the minimum cost between\\n// parsing these two options:\\n\\n// ASCII code of s1[0] + the cost of solving the problem for\\n1234567  // s1\\n012345   // s2\\n\\n- OR -\\n\\n// ASCII code of s2[0] + the cost of solving the problem for\\n01234567 // s1\\n12345    // s2\\n```\n```cpp\\nclass Solution {\\n    string s1, s2;\\n    int memo[1000][1000], l1, l2;\\n    int dfs(int i1 = 0, int i2 = 0) {\\n        // base case: end of the run for both\\n        if (i1 == l1 && i2 == l2) return 0;\\n        // base case: already computed result\\n        if (memo[i1][i2] != -1) return memo[i1][i2];\\n        // base case: end of the run for one\\n        if (i1 == l1) return memo[i1][i2] = accumulate(begin(s2) + i2, end(s2), 0);\\n        if (i2 == l2) return memo[i1][i2] = accumulate(begin(s1) + i1, end(s1), 0);\\n        // general case\\n        int c1 = s1[i1], c2 = s2[i2];\\n        return memo[i1][i2] = c1 == c2 ? dfs(i1 + 1, i2 + 1) : min(\\n            c1 + dfs(i1 + 1, i2),\\n            c2 + dfs(i1, i2 + 1)\\n        );\\n    }\\npublic:\\n    int minimumDeleteSum(string t1, string t2) {\\n        // making sure that t1 is not bigger\\n        if (t1.size() > t2.size()) swap(t1, t2);\\n        // populating instance variables\\n        swap(s1, t1);\\n        swap(s2, t2);\\n        l1 = s1.size(), l2 = s2.size();\\n        memset(memo, -1, (l1 + 1) * 1000 * sizeof(int));\\n        return dfs();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149856,
                "title": "python-dp-top-down-approach-simple-and-easy",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt is basically a dynamic programming question but we need to initialize with different parameters. \\n# Complexity\\n- Time complexity: O(len(s1) * len(s2))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(len(s1) * len(s2))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        m = len(s1)\\n        n = len(s2)\\n        \\n        dp = [[0 for i in range(len(s1) + 1)] for j in range(len(s2) + 1)]\\n\\n        for i in range(len(s2) + 1):\\n            for j in range(len(s1) + 1):\\n                if i == 0 and j == 0: \\n                    continue\\n                elif i == 0:\\n                    dp[i][j] += dp[i][j-1] + ord(s1[j-1])\\n                elif j  == 0:\\n                    dp[i][j] += dp[i-1][j] + ord(s2[i-1])\\n                elif s1[j-1] == s2[i-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(ord(s1[j-1]) + dp[i][j-1], ord(s2[i-1]) + dp[i-1][j])\\n        \\n        return dp[n][m]\\n\\n\\nPlease Upvote and Support.\\nThank You.\\n\\nSee Again Next Question.\\uD83D\\uDE0E\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt is basically a dynamic programming question but we need to initialize with different parameters. \\n# Complexity\\n- Time complexity: O(len(s1) * len(s2))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(len(s1) * len(s2))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        m = len(s1)\\n        n = len(s2)\\n        \\n        dp = [[0 for i in range(len(s1) + 1)] for j in range(len(s2) + 1)]\\n\\n        for i in range(len(s2) + 1):\\n            for j in range(len(s1) + 1):\\n                if i == 0 and j == 0: \\n                    continue\\n                elif i == 0:\\n                    dp[i][j] += dp[i][j-1] + ord(s1[j-1])\\n                elif j  == 0:\\n                    dp[i][j] += dp[i-1][j] + ord(s2[i-1])\\n                elif s1[j-1] == s2[i-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(ord(s1[j-1]) + dp[i][j-1], ord(s2[i-1]) + dp[i-1][j])\\n        \\n        return dp[n][m]\\n\\n\\nPlease Upvote and Support.\\nThank You.\\n\\nSee Again Next Question.\\uD83D\\uDE0E\\n",
                "codeTag": "Java"
            },
            {
                "id": 2913740,
                "title": "beats-98-codedominar-solution-solved-using-lcs-dp-b-u-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        dp = [[0 for j in range(len(s2)+1)] for i in range(len(s1)+1)]\\n        for i in range(len(s1)-1,-1,-1):\\n            for j in range(len(s2)-1,-1,-1):\\n                if s1[i] == s2[j]:\\n                    dp[i][j] = ord(s1[i]) + dp[i+1][j+1]\\n                else:\\n                    dp[i][j] = max(dp[i+1][j],dp[i][j+1])                    \\n        total = 0\\n        for c in s1:\\n            total += ord(c)\\n        for c in s2:\\n            total += ord(c)\\n        return total - dp[0][0]*2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        dp = [[0 for j in range(len(s2)+1)] for i in range(len(s1)+1)]\\n        for i in range(len(s1)-1,-1,-1):\\n            for j in range(len(s2)-1,-1,-1):\\n                if s1[i] == s2[j]:\\n                    dp[i][j] = ord(s1[i]) + dp[i+1][j+1]\\n                else:\\n                    dp[i][j] = max(dp[i+1][j],dp[i][j+1])                    \\n        total = 0\\n        for c in s1:\\n            total += ord(c)\\n        for c in s2:\\n            total += ord(c)\\n        return total - dp[0][0]*2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756084,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        for (int j = 1; j <= n; j++)\\n            dp[0][j] = dp[0][j-1]+s2[j-1];\\n        for (int i = 1; i <= m; i++) {\\n            dp[i][0] = dp[i-1][0]+s1[i-1];\\n            for (int j = 1; j <= n; j++) {\\n                if (s1[i-1] == s2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else \\n                    dp[i][j] = min(dp[i-1][j]+s1[i-1], dp[i][j-1]+s2[j-1]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        for (int j = 1; j <= n; j++)\\n            dp[0][j] = dp[0][j-1]+s2[j-1];\\n        for (int i = 1; i <= m; i++) {\\n            dp[i][0] = dp[i-1][0]+s1[i-1];\\n            for (int j = 1; j <= n; j++) {\\n                if (s1[i-1] == s2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else \\n                    dp[i][j] = min(dp[i-1][j]+s1[i-1], dp[i][j-1]+s2[j-1]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247949,
                "title": "minimum-ascii-delete-sum-for-two-strings-java-clean-dynamic-programming-memoization",
                "content": "```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int m=s1.length();\\n        int n=s2.length();\\n        \\n        Integer [][]dp=new Integer[m][n];\\n        \\n        return helper(s1,s2,m,n,0,0,dp);\\n    }\\n    \\n    public int helper(String s1, String s2, int m, int n,int i1, int i2, Integer [][]dp){\\n        if(i1==m){\\n            \\n            int sum=0;\\n            for(int j=i2;j<n;j++){\\n                sum+=(int)s2.charAt(j);\\n            }\\n            \\n            return sum;\\n            \\n        }else if(i2==n){\\n            \\n            int sum=0;\\n            for(int j=i1;j<m;j++){\\n                sum+=(int)s1.charAt(j);\\n            }\\n            \\n            return sum;\\n            \\n        }else if(s1.charAt(i1)==s2.charAt(i2)){\\n            return helper(s1,s2,m,n,i1+1,i2+1,dp);\\n        }else if(dp[i1][i2]!=null){\\n            return dp[i1][i2];\\n        }else{\\n            int val1=(int)s1.charAt(i1);\\n            int val2=(int)s2.charAt(i2);\\n            \\n            int res1=val1+helper(s1,s2,m,n,i1+1,i2,dp);\\n            int res2=val2+helper(s1,s2,m,n,i1,i2+1,dp);\\n            int res3=val1+val2+helper(s1,s2,m,n,i1+1,i2+1,dp);\\n            \\n            dp[i1][i2]=Math.min(res1,Math.min(res2,res2));\\n            return dp[i1][i2];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int m=s1.length();\\n        int n=s2.length();\\n        \\n        Integer [][]dp=new Integer[m][n];\\n        \\n        return helper(s1,s2,m,n,0,0,dp);\\n    }\\n    \\n    public int helper(String s1, String s2, int m, int n,int i1, int i2, Integer [][]dp){\\n        if(i1==m){\\n            \\n            int sum=0;\\n            for(int j=i2;j<n;j++){\\n                sum+=(int)s2.charAt(j);\\n            }\\n            \\n            return sum;\\n            \\n        }else if(i2==n){\\n            \\n            int sum=0;\\n            for(int j=i1;j<m;j++){\\n                sum+=(int)s1.charAt(j);\\n            }\\n            \\n            return sum;\\n            \\n        }else if(s1.charAt(i1)==s2.charAt(i2)){\\n            return helper(s1,s2,m,n,i1+1,i2+1,dp);\\n        }else if(dp[i1][i2]!=null){\\n            return dp[i1][i2];\\n        }else{\\n            int val1=(int)s1.charAt(i1);\\n            int val2=(int)s2.charAt(i2);\\n            \\n            int res1=val1+helper(s1,s2,m,n,i1+1,i2,dp);\\n            int res2=val2+helper(s1,s2,m,n,i1,i2+1,dp);\\n            int res3=val1+val2+helper(s1,s2,m,n,i1+1,i2+1,dp);\\n            \\n            dp[i1][i2]=Math.min(res1,Math.min(res2,res2));\\n            return dp[i1][i2];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898185,
                "title": "easy-understanding-memoization-dp",
                "content": "```\\nclass Solution {\\npublic: \\n    int subSeq(int ind1,int ind2,string &s1,string &s2,vector<vector<int>>&dp)\\n    {\\n       if(ind1>=s1.size()||ind2>=s2.size()) //if one of string ended then we have to delete all remaning element of \\n       {                                                        //other string\\n          int x=0,i;\\n           for(i=ind1;i<s1.size();i++)\\n               x=x+s1[i];\\n           \\n           for(i=ind2;i<s2.size();i++)\\n               x=x+s2[i];\\n           \\n           return x;\\n                      \\n       }\\n        \\n        if(dp[ind1][ind2]!=-1)\\n            return dp[ind1][ind2];\\n        \\n        if(s1[ind1]==s2[ind2]) //in this case we dont need to delete anything \\n        {\\n            int sum=0+subSeq(ind1+1,ind2+1,s1,s2,dp);\\n            return dp[ind1][ind2]=sum;\\n        }\\n        else {\\n            int sum1=s1[ind1]+subSeq(ind1+1,ind2,s1,s2,dp);   //because we incremented s1\\n            int sum2=s2[ind2]+subSeq(ind1,ind2+1,s1,s2,dp);    //because we incremented s2\\n            \\n            return  dp[ind1][ind2]=min(sum1,sum2);\\n        }\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n      int n1=s1.size(),n2=s2.size();\\n        vector<vector<int>>dp(n1+1,vector<int>(n2+1,-1));\\n        \\n        return subSeq(0,0,s1,s2,dp);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int subSeq(int ind1,int ind2,string &s1,string &s2,vector<vector<int>>&dp)\\n    {\\n       if(ind1>=s1.size()||ind2>=s2.size()) //if one of string ended then we have to delete all remaning element of \\n       {                                                        //other string\\n          int x=0,i;\\n           for(i=ind1;i<s1.size();i++)\\n               x=x+s1[i];\\n           \\n           for(i=ind2;i<s2.size();i++)\\n               x=x+s2[i];\\n           \\n           return x;\\n                      \\n       }\\n        \\n        if(dp[ind1][ind2]!=-1)\\n            return dp[ind1][ind2];\\n        \\n        if(s1[ind1]==s2[ind2]) //in this case we dont need to delete anything \\n        {\\n            int sum=0+subSeq(ind1+1,ind2+1,s1,s2,dp);\\n            return dp[ind1][ind2]=sum;\\n        }\\n        else {\\n            int sum1=s1[ind1]+subSeq(ind1+1,ind2,s1,s2,dp);   //because we incremented s1\\n            int sum2=s2[ind2]+subSeq(ind1,ind2+1,s1,s2,dp);    //because we incremented s2\\n            \\n            return  dp[ind1][ind2]=min(sum1,sum2);\\n        }\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n      int n1=s1.size(),n2=s2.size();\\n        vector<vector<int>>dp(n1+1,vector<int>(n2+1,-1));\\n        \\n        return subSeq(0,0,s1,s2,dp);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862840,
                "title": "c-dp-o-n-space-simple-solution-with-explanation",
                "content": "This problem is similar as [Edit Distance](https://opaque-ixora-403.notion.site/LeetCode-0072-7f01a69d5a68446ba3664a2656a6159e), the only difference is that we don\\u2019t have to replace or insert character, only delete.\\n\\n# Solution 1 (R)\\n\\nConsider `cost[i][j]` is minimum cost from `s1[0...i-1]` and `s2[0...j-1]` that make them equal.\\n\\nSo we can divide into two cases\\n\\n- `s1[i-1]` == `s2[j-1]`\\n    - no need to delete, `cost[i][j]` = `cost[i-1][j-1]`\\n- `s1[i-1]` != `s2[j-1]`\\n    - we can choose to delete `s1[i-1]` or `s2[j-1]`\\n        - delete `s1[i-1]`\\n            - `cost[i-1][j]` + `(int)s1[i-1]`\\n        - delete `s2[j-1]`\\n            - `cost[i][j-1]` + `(int)s2[j-1]`\\n    - choose the minimum value to `cost[i][j]`\\n\\nAlso, we need to pre-define `cost[0][j]` and `cost[i][0]` .\\n\\n- `cost[0][j]` : # of cost to delete `s2[0...j-1]` to make it empty\\n- `cost[i][0]` : # of cost to delete `s1[0...i-1]` to make it empty\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.size(), m = s2.size();\\n        vector<vector<int>> cost(n+1, vector<int>(m+1, 0));\\n        for (int i = 1; i <= n; ++i) {\\n            cost[i][0] = cost[i-1][0] + (int)s1[i-1];\\n        }\\n        for (int j = 1; j <= m; ++j) {\\n            cost[0][j] = cost[0][j-1] + (int)s2[j-1];\\n        }\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j <= m; ++j) {\\n                if (s1[i-1] == s2[j-1]) {\\n                    cost[i][j] = cost[i-1][j-1];\\n                } else {\\n                    int top = cost[i-1][j]+(int)s1[i-1];\\n                    int bottom = cost[i][j-1]+(int)s2[j-1];\\n                    cost[i][j] = top > bottom ? bottom : top;\\n                }\\n            }\\n        }\\n        return cost[n][m];\\n    }\\n};\\n```\\n\\n**Time:** `O(mn)`   \\n**Space:** `O(mn)`    \\n\\n# Solution 2 (R)\\n\\nSince `cost[i][j]` is related to its previous index, we can reduce space complexity from `O(mn)` to `O(n)` . `cost[i][0]` and `cost[0][j]` can be simplified as `cost[0]` and `cost[j]` as initial pre-calculation.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.size(), m = s2.size();\\n        vector<int> cost(m+1, 0);\\n        for (int j = 1; j <= m; ++j) {\\n            cost[j] = cost[j-1] + (int)s2[j-1];\\n        }\\n        for (int i = 1; i <= n; ++i) {\\n            int pre = cost[0], now;\\n            cost[0] += (int)s1[i-1];\\n            for (int j = 1; j <= m; ++j) {\\n                now = cost[j];\\n                if (s1[i-1] == s2[j-1]) {\\n                    cost[j] = pre;\\n                } else {\\n                    int top = cost[j]+(int)s1[i-1];\\n                    int bottom = cost[j-1]+(int)s2[j-1];\\n                    cost[j] = top > bottom ? bottom : top;\\n                }\\n                pre = now;\\n            }\\n        }\\n        return cost[m];\\n    }\\n};\\n```\\n\\n**Time:** `O(mn)`   \\n**Space:** `O(m)`",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.size(), m = s2.size();\\n        vector<vector<int>> cost(n+1, vector<int>(m+1, 0));\\n        for (int i = 1; i <= n; ++i) {\\n            cost[i][0] = cost[i-1][0] + (int)s1[i-1];\\n        }\\n        for (int j = 1; j <= m; ++j) {\\n            cost[0][j] = cost[0][j-1] + (int)s2[j-1];\\n        }\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j <= m; ++j) {\\n                if (s1[i-1] == s2[j-1]) {\\n                    cost[i][j] = cost[i-1][j-1];\\n                } else {\\n                    int top = cost[i-1][j]+(int)s1[i-1];\\n                    int bottom = cost[i][j-1]+(int)s2[j-1];\\n                    cost[i][j] = top > bottom ? bottom : top;\\n                }\\n            }\\n        }\\n        return cost[n][m];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.size(), m = s2.size();\\n        vector<int> cost(m+1, 0);\\n        for (int j = 1; j <= m; ++j) {\\n            cost[j] = cost[j-1] + (int)s2[j-1];\\n        }\\n        for (int i = 1; i <= n; ++i) {\\n            int pre = cost[0], now;\\n            cost[0] += (int)s1[i-1];\\n            for (int j = 1; j <= m; ++j) {\\n                now = cost[j];\\n                if (s1[i-1] == s2[j-1]) {\\n                    cost[j] = pre;\\n                } else {\\n                    int top = cost[j]+(int)s1[i-1];\\n                    int bottom = cost[j-1]+(int)s2[j-1];\\n                    cost[j] = top > bottom ? bottom : top;\\n                }\\n                pre = now;\\n            }\\n        }\\n        return cost[m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758705,
                "title": "python-top-down-dp-with-explanations",
                "content": "712. Minimum ASCII Delete Sum for Two Strings\\n\\n\\nLCS Variant.\\n\\nSame as 583 - deletion operation in two strings: https://leetcode.com/problems/delete-operation-for-two-strings/\\n\\nIn that problem, we sum up character differences, paying 1 whenever there is a mismatch.\\n\\nHere we pay the value of the ascii character using ord.\\n\\n\\nthe general idea is to figure out how to shift one over the other with min moves:\\n\\n   sea \\n    eat\\n\\nleetcode\\n  etco\\n  \\n\\ndp(i,j) where i denotes a position in word1, j denotes a position in word2\\n\\nwe can shift letter by letter, see if there is a cost in a mismatch, and recurse into subproblems:\\n\\ncases:\\n\\n1) the character is the same:\\npay no cost\\nshift both i and j, try next subproblem\\n\\n2) the character is different\\ngenerate two subproblems, the total cost is the minimum of the accumulated sum shifting the first word or shifting the last word plus the ascii cost associated with each character\\n\\n\\nbase cases:\\nneither strings has any characters left - we must have accumulated any deletions upwards in the callstack, so return 0\\n\\none of the strings has characters left, the others doesn\\'t - sum up the ascii cost of the rest of the characters in the longer string and early return\\n\\n\\n\\nComplexity:\\n\\nO(m*n) - time/space\\n\\n\\n\\n```\\n\\nclass Solution:\\n    def minimumDeleteSum(self, word1: str, word2: str) -> int:\\n        m = len(word1)\\n        n = len(word2)\\n        \\n        @cache\\n        def dfs(i, j):\\n            # if we have run out of characters in both strings\\n            # return 0\\n            if i == m and j == n:\\n                return 0\\n            \\n            if i == m or j == n:\\n                return sum([ord(c) for c in word1[i:]]) or sum([ord(c) for c in word2[j:]])\\n            \\n            if word1[i] == word2[j]:\\n                # identical characters, pay no cost since no deletion\\n                return dfs(i + 1, j + 1)\\n            else:\\n                # letters are different, try shifting both and see which \\n                # one is better and pay a cost of 1 for one deletion\\n                return min(dfs(i+1, j) + ord(word1[i]), dfs(i, j+1)+ ord(word2[j])) \\n            \\n        return dfs(0, 0)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution:\\n    def minimumDeleteSum(self, word1: str, word2: str) -> int:\\n        m = len(word1)\\n        n = len(word2)\\n        \\n        @cache\\n        def dfs(i, j):\\n            # if we have run out of characters in both strings\\n            # return 0\\n            if i == m and j == n:\\n                return 0\\n            \\n            if i == m or j == n:\\n                return sum([ord(c) for c in word1[i:]]) or sum([ord(c) for c in word2[j:]])\\n            \\n            if word1[i] == word2[j]:\\n                # identical characters, pay no cost since no deletion\\n                return dfs(i + 1, j + 1)\\n            else:\\n                # letters are different, try shifting both and see which \\n                # one is better and pay a cost of 1 for one deletion\\n                return min(dfs(i+1, j) + ord(word1[i]), dfs(i, j+1)+ ord(word2[j])) \\n            \\n        return dfs(0, 0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748294,
                "title": "java-dp-my-thinking-process",
                "content": "1. for an empty string \"\" and \"eat\", what\\'s the answer?\\n-> it should be \\'e\\'+\\'a\\'+\\'t\\'\\n\\n2. for two strings with the same ending charater, what\\'s the answer?\\n->  taking \"abc\" and \"bac\" as an example, the answer is the same as the answer for \"ab\" and \"ba\"\\n\\n3. for two strings with different ending character, what\\'s the answer?\\n-> taking \"sea\" and \"eat\" as an example, the answer should be one of the following two:\\n\\'a\\' + answer for \"se\" and \"eat\" \\n\\'t\\' + answer for \"sea\" and \"ea\"\\nsince we need to find minimum sum, so we choose the minimum between these two answers\\n\\n\\n\\n```\\npublic int minimumDeleteSum(String s1, String s2) {\\n        /**\\n         *    0      e      a        t\\n         * 0  0      e      e+a      e+a+t\\n         * s  s      s+e    s+e+a    s+e+a+t\\n         * e  s+e    s      s+a      s+a+t\\n         * a  s+e+a  s+a    s        s+t\\n         *\\n         * -> dp[i][j]= min(dp[i][j-1]+colStr[j-1], dp[i-1][j]+rowStr[i-1])\\n         *\\n         */\\n        int m = s1.length();\\n        int n = s2.length();\\n        char[] s1s = s1.toCharArray();\\n        char[] s2s = s2.toCharArray();\\n\\n        int[][] dp = new int[m+1][n+1];\\n\\n        for(int i = 0; i<=m; i++){\\n            for(int j = 0; j<=n; j++){\\n\\n                if(i==0 && j==0){\\n                    continue;\\n                }\\n                if(i==0 && j>0){\\n                    //first row\\n                    dp[i][j] = dp[i][j-1] + s2s[j-1];\\n                    continue;\\n                }\\n                if (j==0 && i>0){\\n                    //first column\\n                    dp[i][j] = dp[i-1][j] + s1s[i-1];\\n                    continue;\\n                }\\n\\n                if(s1s[i-1]==s2s[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    int top = dp[i-1][j] + s1s[i-1];\\n                    int left = dp[i][j-1] + s2s[j-1];\\n                    dp[i][j] = Math.min(top, left);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```\\n\\nSimilar questions:\\n[https://leetcode.com/problems/edit-distance/discuss/1749422/JavaDPMy-Thinking-Process](http://)",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int minimumDeleteSum(String s1, String s2) {\\n        /**\\n         *    0      e      a        t\\n         * 0  0      e      e+a      e+a+t\\n         * s  s      s+e    s+e+a    s+e+a+t\\n         * e  s+e    s      s+a      s+a+t\\n         * a  s+e+a  s+a    s        s+t\\n         *\\n         * -> dp[i][j]= min(dp[i][j-1]+colStr[j-1], dp[i-1][j]+rowStr[i-1])\\n         *\\n         */\\n        int m = s1.length();\\n        int n = s2.length();\\n        char[] s1s = s1.toCharArray();\\n        char[] s2s = s2.toCharArray();\\n\\n        int[][] dp = new int[m+1][n+1];\\n\\n        for(int i = 0; i<=m; i++){\\n            for(int j = 0; j<=n; j++){\\n\\n                if(i==0 && j==0){\\n                    continue;\\n                }\\n                if(i==0 && j>0){\\n                    //first row\\n                    dp[i][j] = dp[i][j-1] + s2s[j-1];\\n                    continue;\\n                }\\n                if (j==0 && i>0){\\n                    //first column\\n                    dp[i][j] = dp[i-1][j] + s1s[i-1];\\n                    continue;\\n                }\\n\\n                if(s1s[i-1]==s2s[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    int top = dp[i-1][j] + s1s[i-1];\\n                    int left = dp[i][j-1] + s2s[j-1];\\n                    dp[i][j] = Math.min(top, left);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1606340,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution (starting at top-left with base cases at index 0)\\n4. **T**urn the top-down solution upside-down to create the bottom-up solution (starting at bottom-right with base cases at index M,N)\\n\\n---\\n\\n**Top-Down:** There are 3 choices to consider during a linear scan of each `i`<sup>th</sup>, `j`<sup>th</sup> characters of the input strings `A` and `B` correspondingly:\\n\\n1. with `A[i]` and `B[j]` at a cost of `0` if `A[i] == B[j]` else `ord(A[i]) + ord(B[j])`\\n2. without `A[i]` at a cost of `ord(A[i])`\\n3. without `B[j]` at a cost of `ord(B[j])`\\n\\n**Base Cases:**\\n\\nThe top-down dfs exhausts the characters of `A` when `i == M`, thus we pay the cost of the remainder of the accumulated ordinal value sum of `B[j..N - 1]`.  Likewise the top-down dfs exhausts the characters of `B` when `j == N`, then we pay the cost of the remainder of the accumulated ordinal value sum of `A[i..M - 1]`.\\n\\nNote: an astute observer will notice the top-down base case optimization via precomputed prefix ordinal sums.  This is a trivial optimization which was purposefully excluded in favor of simplicity.\\n\\n**Bottom-Up:** We can iteratively build upon previous optimal solutions from either direction:\\n\\n1. starting from the top-left and iteratively building to the bottom-right\\n\\t* this is the *opposite* direction of the top-down solution\\'s recursive stack unwinding\\n2. starting from the bottom-right and iteratively building to the top-left\\n\\t* this is the *same* direction of the top-down solution\\'s recursive stack unwinding\\n\\n**Base Cases:**\\n\\n* if we build solutions starting from the top-left, then we offset the `dp` matrix by `1` index to make room for the explicit base cases at index `0`, ie. `dp[i][j]` refers to `A[i - 1]` and `B[j - 1]`.\\n* if we build solutions starting from the bottom-right, then we can append the base cases at index `M` and `N` correspondingly.  This is convenient, since we don\\'t need to offset `dp` the matrix by `1` as we relatively refer to each `i`<sup>th</sup> and `j`<sup>th</sup> index of the input strings `A` and `B` correspondingly, ie. `dp[i][j]` refers to `A[i]` and `B[j]`\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun minimumDeleteSum(A: String, B: String): Int {\\n        var (M, N) = listOf(A.length, B.length)\\n        var ord = { x: Char -> x.toByte().toInt() }\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M) return B.slice(j until N).map{ ord(it) }.sum()!!\\n            if (j == N) return A.slice(i until M).map{ ord(it) }.sum()!!\\n            var a = go(i + 1, j + 1) + if (A[i] == B[j]) 0 else ord(A[i]) + ord(B[j])\\n            var b = go(i + 1, j) + ord(A[i])\\n            var c = go(i, j + 1) + ord(B[j])\\n            return listOf(a, b, c).min()!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun minimumDeleteSum(A: String, B: String): Int {\\n        var (M, N) = listOf(A.length, B.length)\\n        var m = mutableMapOf<String, Int>()\\n        var ord = { x: Char -> x.toByte().toInt() }\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M) return B.slice(j until N).map{ ord(it) }.sum()!!\\n            if (j == N) return A.slice(i until M).map{ ord(it) }.sum()!!\\n            var k = \"$i,$j\"\\n            if (!m.contains(k)) {\\n                var a = go(i + 1, j + 1) + if (A[i] == B[j]) 0 else ord(A[i]) + ord(B[j])\\n                var b = go(i + 1, j) + ord(A[i])\\n                var c = go(i, j + 1) + ord(B[j])\\n                m[k] = listOf(a, b, c).min()!!\\n            }\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution (starting at top-left with base cases at index 0)\\n```\\nclass Solution {\\n    fun minimumDeleteSum(A: String, B: String): Int {\\n        var (M, N) = listOf(A.length, B.length)\\n        var ord = { x: Char -> x.toByte().toInt() }\\n        var dp = Array(M + 1) { IntArray(N + 1) { 0 } }\\n        for (i in 1..M) dp[i][0] = dp[i - 1][0] + ord(A[i - 1])\\n        for (j in 1..N) dp[0][j] = dp[0][j - 1] + ord(B[j - 1])\\n        for (i in 1..M) {\\n            for (j in 1..N) {\\n                var a = dp[i - 1][j - 1] + if (A[i - 1] == B[j - 1]) 0 else ord(A[i - 1]) + ord(B[j - 1])\\n                var b = dp[i - 1][j] + ord(A[i - 1])\\n                var c = dp[i][j - 1] + ord(B[j - 1])\\n                dp[i][j] = listOf(a, b, c).min()!!\\n            }\\n        }\\n        return dp[M][N]\\n    }\\n}\\n```\\n\\n4. **T**urn the top-down solution upside-down to create the bottom-up solution (starting at bottom-right with base cases at index M,N)\\n```\\nclass Solution {\\n    fun minimumDeleteSum(A: String, B: String): Int {\\n        var (M, N) = listOf(A.length, B.length)\\n        var ord = { x: Char -> x.toByte().toInt() }\\n        var dp = Array(M + 1) { IntArray(N + 1) { 0 } }\\n        for (i in M - 1 downTo 0) dp[i][N] = dp[i + 1][N] + ord(A[i])\\n        for (j in N - 1 downTo 0) dp[M][j] = dp[M][j + 1] + ord(B[j])\\n        for (i in M - 1 downTo 0) {\\n            for (j in N - 1 downTo 0) {\\n                var a = dp[i + 1][j + 1] + if (A[i] == B[j]) 0 else ord(A[i]) + ord(B[j])\\n                var b = dp[i + 1][j] + ord(A[i])\\n                var c = dp[i][j + 1] + ord(B[j])\\n                dp[i][j] = listOf(a, b, c).min()!!\\n            }\\n        }\\n        return dp[0][0]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet minimumDeleteSum = (A, B) => {\\n    let [M, N] = [A.length, B.length];\\n    let ord = x => x.charCodeAt(0);\\n    let go = (i = 0, j = 0) => {\\n        if (i == M) return _.sum([...B.slice(j)].map(x => ord(x)));\\n        if (j == N) return _.sum([...A.slice(i)].map(x => ord(x)));\\n        let a = go(i + 1, j + 1) + (A[i] == B[j] ? 0 : ord(A[i]) + ord(B[j])),\\n            b = go(i + 1, j) + ord(A[i]),\\n            c = go(i, j + 1) + ord(B[j]);\\n        return Math.min(a, b, c);\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet minimumDeleteSum = (A, B, m = new Map()) => {\\n    let [M, N] = [A.length, B.length];\\n    let ord = x => x.charCodeAt(0);\\n    let go = (i = 0, j = 0) => {\\n        if (i == M) return _.sum([...B.slice(j)].map(x => ord(x)));\\n        if (j == N) return _.sum([...A.slice(i)].map(x => ord(x)));\\n        let k = `${i},${j}`;\\n        if (!m.has(k)) {\\n            let a = go(i + 1, j + 1) + (A[i] == B[j] ? 0 : ord(A[i]) + ord(B[j])),\\n                b = go(i + 1, j) + ord(A[i]),\\n                c = go(i, j + 1) + ord(B[j]);\\n            m.set(k, Math.min(a, b, c));\\n        }\\n        return m.get(k);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution (starting at top-left with base cases at index 0)\\n```\\nlet minimumDeleteSum = (A, B, m = new Map()) => {\\n    let [M, N] = [A.length, B.length];\\n    let ord = x => x.charCodeAt(0);\\n    let dp = [...Array(M + 1)].map(_ => Array(N + 1).fill(0));\\n    for (let i = 1; i <= M; ++i) dp[i][0] = dp[i - 1][0] + ord(A[i - 1]);\\n    for (let j = 1; j <= N; ++j) dp[0][j] = dp[0][j - 1] + ord(B[j - 1]);\\n    for (let i = 1; i <= M; ++i) {\\n        for (let j = 1; j <= N; ++j) {\\n            let a = dp[i - 1][j - 1] + (A[i - 1] == B[j - 1] ? 0 : ord(A[i - 1]) + ord(B[j - 1])),\\n                b = dp[i - 1][j] + ord(A[i - 1]),\\n                c = dp[i][j - 1] + ord(B[j - 1]);\\n            dp[i][j] = Math.min(a, b, c);\\n        }\\n    }\\n    return dp[M][N];\\n};\\n```\\n\\n4. **T**urn the top-down solution upside-down to create the bottom-up solution (starting at bottom-right with base cases at index M,N)\\n```\\nlet minimumDeleteSum = (A, B, m = new Map()) => {\\n    let [M, N] = [A.length, B.length];\\n    let ord = x => x.charCodeAt(0);\\n    let dp = [...Array(M + 1)].map(_ => Array(N + 1).fill(0));\\n    for (let i = M - 1; 0 <= i; --i) dp[i][N] = dp[i + 1][N] + ord(A[i]);\\n    for (let j = N - 1; 0 <= j; --j) dp[M][j] = dp[M][j + 1] + ord(B[j]);\\n    for (let i = M - 1; 0 <= i; --i) {\\n        for (let j = N - 1; 0 <= j; --j) {\\n            let a = dp[i + 1][j + 1] + (A[i] == B[j] ? 0 : ord(A[i]) + ord(B[j])),\\n                b = dp[i + 1][j] + ord(A[i]),\\n                c = dp[i][j + 1] + ord(B[j]);\\n            dp[i][j] = Math.min(a, b, c);\\n        }\\n    }\\n    return dp[0][0];\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, A: str, B: str) -> int:\\n        M, N = len(A), len(B)\\n        S = Sums(A, B)        \\n        def go(i = 0, j = 0):\\n            if i == M: return sum(ord(x) for x in B[j:])\\n            if j == N: return sum(ord(x) for x in A[i:])\\n            a = go(i + 1, j + 1) + (0 if A[i] == B[j] else ord(A[i]) + ord(B[j]))\\n            b = go(i + 1, j) + ord(A[i])\\n            c = go(i, j + 1) + ord(B[j])\\n            return min(a, b, c)\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, A: str, B: str) -> int:\\n        M, N = len(A), len(B)\\n        @cache\\n        def go(i = 0, j = 0):\\n            if i == M: return sum(ord(x) for x in B[j:])\\n            if j == N: return sum(ord(x) for x in A[i:])\\n            a = go(i + 1, j + 1) + (0 if A[i] == B[j] else ord(A[i]) + ord(B[j]))\\n            b = go(i + 1, j) + ord(A[i])\\n            c = go(i, j + 1) + ord(B[j])\\n            return min(a, b, c)\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution (starting at top-left with base cases at index 0)\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, A: str, B: str) -> int:\\n        M, N = len(A), len(B)\\n        dp = [[0] * (N + 1) for _ in range(M + 1)]\\n        for i in range(1, M + 1): dp[i][0] = dp[i - 1][0] + ord(A[i - 1])\\n        for j in range(1, N + 1): dp[0][j] = dp[0][j - 1] + ord(B[j - 1])\\n        for i in range(1, M + 1):\\n            for j in range(1, N + 1):\\n                a = dp[i - 1][j - 1] + (0 if A[i - 1] == B[j - 1] else ord(A[i - 1]) + ord(B[j - 1]))\\n                b = dp[i - 1][j] + ord(A[i - 1])\\n                c = dp[i][j - 1] + ord(B[j - 1])\\n                dp[i][j] = min(a, b, c)\\n        return dp[M][N]\\n```\\n\\n4. **T**urn the top-down solution upside-down to create the bottom-up solution (starting at bottom-right with base cases at index M,N)\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, A: str, B: str) -> int:\\n        M, N = len(A), len(B)\\n        dp = [[0] * (N + 1) for _ in range(M + 1)]\\n        for i in range(M - 1, -1, -1): dp[i][N] = dp[i + 1][N] + ord(A[i])\\n        for j in range(N - 1, -1, -1): dp[M][j] = dp[M][j + 1] + ord(B[j])\\n        for i in range(M - 1, -1, -1):\\n            for j in range(N - 1, -1, -1):\\n                a = dp[i + 1][j + 1] + (0 if A[i] == B[j] else ord(A[i]) + ord(B[j]))\\n                b = dp[i + 1][j] + ord(A[i])\\n                c = dp[i][j + 1] + ord(B[j])\\n                dp[i][j] = min(a, b, c)\\n        return dp[0][0]\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    int minimumDeleteSum(string A, string B) {\\n        int M = A.size(),\\n            N = B.size();\\n        fun go = [&](auto i, auto j) {\\n            if (i == M) return accumulate(B.begin() + j, B.end(), 0);\\n            if (j == N) return accumulate(A.begin() + i, A.end(), 0);\\n            auto a = go(i + 1, j + 1) + (A[i] == B[j] ? 0 : A[i] + B[j]),\\n                 b = go(i + 1, j) + A[i],\\n                 c = go(i, j + 1) + B[j];\\n            return min({ a, b, c });\\n            \\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minimumDeleteSum(string A, string B, Map m = {}) {\\n        int M = A.size(),\\n            N = B.size();\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j) {\\n            if (i == M) return accumulate(B.begin() + j, B.end(), 0);\\n            if (j == N) return accumulate(A.begin() + i, A.end(), 0);\\n            auto k = key(i, j);\\n            if (m.find(k) == m.end()) {\\n                auto a = go(i + 1, j + 1) + (A[i] == B[j] ? 0 : A[i] + B[j]),\\n                     b = go(i + 1, j) + A[i],\\n                     c = go(i, j + 1) + B[j];\\n                m[k] = min({ a, b, c });\\n            }\\n            return m[k];\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution (starting at top-left with base cases at index 0)\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minimumDeleteSum(string A, string B) {\\n        int M = A.size(),\\n            N = B.size();\\n        VVI dp(M + 1, VI(N + 1));\\n        for (auto i{ 1 }; i <= M; ++i) dp[i][0] += dp[i - 1][0] + A[i - 1];\\n        for (auto j{ 1 }; j <= N; ++j) dp[0][j] += dp[0][j - 1] + B[j - 1];\\n        for (auto i{ 1 }; i <= M; ++i) {\\n            for (auto j{ 1 }; j <= N; ++j) {\\n                auto a = dp[i - 1][j - 1] + (A[i - 1] == B[j - 1] ? 0 : A[i - 1] + B[j - 1]),\\n                     b = dp[i - 1][j] + A[i - 1],\\n                     c = dp[i][j - 1] + B[j - 1];\\n                dp[i][j] = min({ a, b, c });\\n            }\\n        }\\n        return dp[M][N];\\n    }\\n};\\n```\\n\\n4. **T**urn the top-down solution upside-down to create the bottom-up solution (starting at bottom-right with base cases at index M,N)\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minimumDeleteSum(string A, string B) {\\n        int M = A.size(),\\n            N = B.size();\\n        VVI dp(M + 1, VI(N + 1));\\n        for (auto i{ M - 1 }; 0 <= i; --i) dp[i][N] += dp[i + 1][N] + A[i];\\n        for (auto j{ N - 1 }; 0 <= j; --j) dp[M][j] += dp[M][j + 1] + B[j];\\n        for (auto i{ M - 1 }; 0 <= i; --i) {\\n            for (auto j{ N - 1 }; 0 <= j; --j) {\\n                auto a = dp[i + 1][j + 1] + (A[i] == B[j] ? 0 : A[i] + B[j]),\\n                     b = dp[i + 1][j] + A[i],\\n                     c = dp[i][j + 1] + B[j];\\n                dp[i][j] = min({ a, b, c });\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minimumDeleteSum(A: String, B: String): Int {\\n        var (M, N) = listOf(A.length, B.length)\\n        var ord = { x: Char -> x.toByte().toInt() }\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M) return B.slice(j until N).map{ ord(it) }.sum()!!\\n            if (j == N) return A.slice(i until M).map{ ord(it) }.sum()!!\\n            var a = go(i + 1, j + 1) + if (A[i] == B[j]) 0 else ord(A[i]) + ord(B[j])\\n            var b = go(i + 1, j) + ord(A[i])\\n            var c = go(i, j + 1) + ord(B[j])\\n            return listOf(a, b, c).min()!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minimumDeleteSum(A: String, B: String): Int {\\n        var (M, N) = listOf(A.length, B.length)\\n        var m = mutableMapOf<String, Int>()\\n        var ord = { x: Char -> x.toByte().toInt() }\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M) return B.slice(j until N).map{ ord(it) }.sum()!!\\n            if (j == N) return A.slice(i until M).map{ ord(it) }.sum()!!\\n            var k = \"$i,$j\"\\n            if (!m.contains(k)) {\\n                var a = go(i + 1, j + 1) + if (A[i] == B[j]) 0 else ord(A[i]) + ord(B[j])\\n                var b = go(i + 1, j) + ord(A[i])\\n                var c = go(i, j + 1) + ord(B[j])\\n                m[k] = listOf(a, b, c).min()!!\\n            }\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minimumDeleteSum(A: String, B: String): Int {\\n        var (M, N) = listOf(A.length, B.length)\\n        var ord = { x: Char -> x.toByte().toInt() }\\n        var dp = Array(M + 1) { IntArray(N + 1) { 0 } }\\n        for (i in 1..M) dp[i][0] = dp[i - 1][0] + ord(A[i - 1])\\n        for (j in 1..N) dp[0][j] = dp[0][j - 1] + ord(B[j - 1])\\n        for (i in 1..M) {\\n            for (j in 1..N) {\\n                var a = dp[i - 1][j - 1] + if (A[i - 1] == B[j - 1]) 0 else ord(A[i - 1]) + ord(B[j - 1])\\n                var b = dp[i - 1][j] + ord(A[i - 1])\\n                var c = dp[i][j - 1] + ord(B[j - 1])\\n                dp[i][j] = listOf(a, b, c).min()!!\\n            }\\n        }\\n        return dp[M][N]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minimumDeleteSum(A: String, B: String): Int {\\n        var (M, N) = listOf(A.length, B.length)\\n        var ord = { x: Char -> x.toByte().toInt() }\\n        var dp = Array(M + 1) { IntArray(N + 1) { 0 } }\\n        for (i in M - 1 downTo 0) dp[i][N] = dp[i + 1][N] + ord(A[i])\\n        for (j in N - 1 downTo 0) dp[M][j] = dp[M][j + 1] + ord(B[j])\\n        for (i in M - 1 downTo 0) {\\n            for (j in N - 1 downTo 0) {\\n                var a = dp[i + 1][j + 1] + if (A[i] == B[j]) 0 else ord(A[i]) + ord(B[j])\\n                var b = dp[i + 1][j] + ord(A[i])\\n                var c = dp[i][j + 1] + ord(B[j])\\n                dp[i][j] = listOf(a, b, c).min()!!\\n            }\\n        }\\n        return dp[0][0]\\n    }\\n}\\n```\n```\\nlet minimumDeleteSum = (A, B) => {\\n    let [M, N] = [A.length, B.length];\\n    let ord = x => x.charCodeAt(0);\\n    let go = (i = 0, j = 0) => {\\n        if (i == M) return _.sum([...B.slice(j)].map(x => ord(x)));\\n        if (j == N) return _.sum([...A.slice(i)].map(x => ord(x)));\\n        let a = go(i + 1, j + 1) + (A[i] == B[j] ? 0 : ord(A[i]) + ord(B[j])),\\n            b = go(i + 1, j) + ord(A[i]),\\n            c = go(i, j + 1) + ord(B[j]);\\n        return Math.min(a, b, c);\\n    };\\n    return go();\\n};\\n```\n```\\nlet minimumDeleteSum = (A, B, m = new Map()) => {\\n    let [M, N] = [A.length, B.length];\\n    let ord = x => x.charCodeAt(0);\\n    let go = (i = 0, j = 0) => {\\n        if (i == M) return _.sum([...B.slice(j)].map(x => ord(x)));\\n        if (j == N) return _.sum([...A.slice(i)].map(x => ord(x)));\\n        let k = `${i},${j}`;\\n        if (!m.has(k)) {\\n            let a = go(i + 1, j + 1) + (A[i] == B[j] ? 0 : ord(A[i]) + ord(B[j])),\\n                b = go(i + 1, j) + ord(A[i]),\\n                c = go(i, j + 1) + ord(B[j]);\\n            m.set(k, Math.min(a, b, c));\\n        }\\n        return m.get(k);\\n    };\\n    return go();\\n};\\n```\n```\\nlet minimumDeleteSum = (A, B, m = new Map()) => {\\n    let [M, N] = [A.length, B.length];\\n    let ord = x => x.charCodeAt(0);\\n    let dp = [...Array(M + 1)].map(_ => Array(N + 1).fill(0));\\n    for (let i = 1; i <= M; ++i) dp[i][0] = dp[i - 1][0] + ord(A[i - 1]);\\n    for (let j = 1; j <= N; ++j) dp[0][j] = dp[0][j - 1] + ord(B[j - 1]);\\n    for (let i = 1; i <= M; ++i) {\\n        for (let j = 1; j <= N; ++j) {\\n            let a = dp[i - 1][j - 1] + (A[i - 1] == B[j - 1] ? 0 : ord(A[i - 1]) + ord(B[j - 1])),\\n                b = dp[i - 1][j] + ord(A[i - 1]),\\n                c = dp[i][j - 1] + ord(B[j - 1]);\\n            dp[i][j] = Math.min(a, b, c);\\n        }\\n    }\\n    return dp[M][N];\\n};\\n```\n```\\nlet minimumDeleteSum = (A, B, m = new Map()) => {\\n    let [M, N] = [A.length, B.length];\\n    let ord = x => x.charCodeAt(0);\\n    let dp = [...Array(M + 1)].map(_ => Array(N + 1).fill(0));\\n    for (let i = M - 1; 0 <= i; --i) dp[i][N] = dp[i + 1][N] + ord(A[i]);\\n    for (let j = N - 1; 0 <= j; --j) dp[M][j] = dp[M][j + 1] + ord(B[j]);\\n    for (let i = M - 1; 0 <= i; --i) {\\n        for (let j = N - 1; 0 <= j; --j) {\\n            let a = dp[i + 1][j + 1] + (A[i] == B[j] ? 0 : ord(A[i]) + ord(B[j])),\\n                b = dp[i + 1][j] + ord(A[i]),\\n                c = dp[i][j + 1] + ord(B[j]);\\n            dp[i][j] = Math.min(a, b, c);\\n        }\\n    }\\n    return dp[0][0];\\n};\\n```\n```\\nclass Solution:\\n    def minimumDeleteSum(self, A: str, B: str) -> int:\\n        M, N = len(A), len(B)\\n        S = Sums(A, B)        \\n        def go(i = 0, j = 0):\\n            if i == M: return sum(ord(x) for x in B[j:])\\n            if j == N: return sum(ord(x) for x in A[i:])\\n            a = go(i + 1, j + 1) + (0 if A[i] == B[j] else ord(A[i]) + ord(B[j]))\\n            b = go(i + 1, j) + ord(A[i])\\n            c = go(i, j + 1) + ord(B[j])\\n            return min(a, b, c)\\n        return go()\\n```\n```\\nclass Solution:\\n    def minimumDeleteSum(self, A: str, B: str) -> int:\\n        M, N = len(A), len(B)\\n        @cache\\n        def go(i = 0, j = 0):\\n            if i == M: return sum(ord(x) for x in B[j:])\\n            if j == N: return sum(ord(x) for x in A[i:])\\n            a = go(i + 1, j + 1) + (0 if A[i] == B[j] else ord(A[i]) + ord(B[j]))\\n            b = go(i + 1, j) + ord(A[i])\\n            c = go(i, j + 1) + ord(B[j])\\n            return min(a, b, c)\\n        return go()\\n```\n```\\nclass Solution:\\n    def minimumDeleteSum(self, A: str, B: str) -> int:\\n        M, N = len(A), len(B)\\n        dp = [[0] * (N + 1) for _ in range(M + 1)]\\n        for i in range(1, M + 1): dp[i][0] = dp[i - 1][0] + ord(A[i - 1])\\n        for j in range(1, N + 1): dp[0][j] = dp[0][j - 1] + ord(B[j - 1])\\n        for i in range(1, M + 1):\\n            for j in range(1, N + 1):\\n                a = dp[i - 1][j - 1] + (0 if A[i - 1] == B[j - 1] else ord(A[i - 1]) + ord(B[j - 1]))\\n                b = dp[i - 1][j] + ord(A[i - 1])\\n                c = dp[i][j - 1] + ord(B[j - 1])\\n                dp[i][j] = min(a, b, c)\\n        return dp[M][N]\\n```\n```\\nclass Solution:\\n    def minimumDeleteSum(self, A: str, B: str) -> int:\\n        M, N = len(A), len(B)\\n        dp = [[0] * (N + 1) for _ in range(M + 1)]\\n        for i in range(M - 1, -1, -1): dp[i][N] = dp[i + 1][N] + ord(A[i])\\n        for j in range(N - 1, -1, -1): dp[M][j] = dp[M][j + 1] + ord(B[j])\\n        for i in range(M - 1, -1, -1):\\n            for j in range(N - 1, -1, -1):\\n                a = dp[i + 1][j + 1] + (0 if A[i] == B[j] else ord(A[i]) + ord(B[j]))\\n                b = dp[i + 1][j] + ord(A[i])\\n                c = dp[i][j + 1] + ord(B[j])\\n                dp[i][j] = min(a, b, c)\\n        return dp[0][0]\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    int minimumDeleteSum(string A, string B) {\\n        int M = A.size(),\\n            N = B.size();\\n        fun go = [&](auto i, auto j) {\\n            if (i == M) return accumulate(B.begin() + j, B.end(), 0);\\n            if (j == N) return accumulate(A.begin() + i, A.end(), 0);\\n            auto a = go(i + 1, j + 1) + (A[i] == B[j] ? 0 : A[i] + B[j]),\\n                 b = go(i + 1, j) + A[i],\\n                 c = go(i, j + 1) + B[j];\\n            return min({ a, b, c });\\n            \\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minimumDeleteSum(string A, string B, Map m = {}) {\\n        int M = A.size(),\\n            N = B.size();\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j) {\\n            if (i == M) return accumulate(B.begin() + j, B.end(), 0);\\n            if (j == N) return accumulate(A.begin() + i, A.end(), 0);\\n            auto k = key(i, j);\\n            if (m.find(k) == m.end()) {\\n                auto a = go(i + 1, j + 1) + (A[i] == B[j] ? 0 : A[i] + B[j]),\\n                     b = go(i + 1, j) + A[i],\\n                     c = go(i, j + 1) + B[j];\\n                m[k] = min({ a, b, c });\\n            }\\n            return m[k];\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minimumDeleteSum(string A, string B) {\\n        int M = A.size(),\\n            N = B.size();\\n        VVI dp(M + 1, VI(N + 1));\\n        for (auto i{ 1 }; i <= M; ++i) dp[i][0] += dp[i - 1][0] + A[i - 1];\\n        for (auto j{ 1 }; j <= N; ++j) dp[0][j] += dp[0][j - 1] + B[j - 1];\\n        for (auto i{ 1 }; i <= M; ++i) {\\n            for (auto j{ 1 }; j <= N; ++j) {\\n                auto a = dp[i - 1][j - 1] + (A[i - 1] == B[j - 1] ? 0 : A[i - 1] + B[j - 1]),\\n                     b = dp[i - 1][j] + A[i - 1],\\n                     c = dp[i][j - 1] + B[j - 1];\\n                dp[i][j] = min({ a, b, c });\\n            }\\n        }\\n        return dp[M][N];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minimumDeleteSum(string A, string B) {\\n        int M = A.size(),\\n            N = B.size();\\n        VVI dp(M + 1, VI(N + 1));\\n        for (auto i{ M - 1 }; 0 <= i; --i) dp[i][N] += dp[i + 1][N] + A[i];\\n        for (auto j{ N - 1 }; 0 <= j; --j) dp[M][j] += dp[M][j + 1] + B[j];\\n        for (auto i{ M - 1 }; 0 <= i; --i) {\\n            for (auto j{ N - 1 }; 0 <= j; --j) {\\n                auto a = dp[i + 1][j + 1] + (A[i] == B[j] ? 0 : A[i] + B[j]),\\n                     b = dp[i + 1][j] + A[i],\\n                     c = dp[i][j + 1] + B[j];\\n                dp[i][j] = min({ a, b, c });\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382419,
                "title": "c-solution-for-712-minimum-ascii-delete-sum-for-two-strings-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestCommonSubsequence(string text1, string text2) \\n    {\\n        int s1 = text1.size(); int s2 = text2.size();\\n        int dp[s1+1][s2+1]; \\n        \\n        for(int i=0; i<=s1; i++)\\n        {\\n            for(int j=0; j<=s2; j++)\\n            {\\n                if(i==0 || j==0)\\n                { dp[i][j] = 0; }\\n            }\\n        }\\n        for(int i=1; i<=s1; i++)\\n        {\\n            for(int j=1; j<=s2; j++)\\n            {\\n                if(text1[i-1] == text2[j-1])\\n                {\\n                    dp[i][j] = text1[i-1] + dp[i-1][j-1]; // slight variation in lcs(replaced 1 with text1[i-1] here)\\n                }\\n                else{\\n                    dp[i][j] = max(dp[i][j-1],dp[i-1][j]);\\n                }\\n            }\\n        }\\n\\n        return dp[s1][s2] ;\\n    }\\n    int minimumDeleteSum(string s1, string s2) \\n    {  \\n        int sum_s1 = 0, sum_s2 = 0;\\n        \\n        for(char c : s1){ sum_s1 += c;}\\n        for(char c : s2){ sum_s2 += c;}\\n        \\n        int lcs_ascii_val = longestCommonSubsequence(s1, s2);\\n        \\n        int min_s1 = sum_s1 - lcs_ascii_val;\\n        int min_s2 = sum_s2 - lcs_ascii_val; \\n        \\n        int min_ascii_del_sum = min_s1 + min_s2 ;\\n        \\n        return min_ascii_del_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestCommonSubsequence(string text1, string text2) \\n    {\\n        int s1 = text1.size(); int s2 = text2.size();\\n        int dp[s1+1][s2+1]; \\n        \\n        for(int i=0; i<=s1; i++)\\n        {\\n            for(int j=0; j<=s2; j++)\\n            {\\n                if(i==0 || j==0)\\n                { dp[i][j] = 0; }\\n            }\\n        }\\n        for(int i=1; i<=s1; i++)\\n        {\\n            for(int j=1; j<=s2; j++)\\n            {\\n                if(text1[i-1] == text2[j-1])\\n                {\\n                    dp[i][j] = text1[i-1] + dp[i-1][j-1]; // slight variation in lcs(replaced 1 with text1[i-1] here)\\n                }\\n                else{\\n                    dp[i][j] = max(dp[i][j-1],dp[i-1][j]);\\n                }\\n            }\\n        }\\n\\n        return dp[s1][s2] ;\\n    }\\n    int minimumDeleteSum(string s1, string s2) \\n    {  \\n        int sum_s1 = 0, sum_s2 = 0;\\n        \\n        for(char c : s1){ sum_s1 += c;}\\n        for(char c : s2){ sum_s2 += c;}\\n        \\n        int lcs_ascii_val = longestCommonSubsequence(s1, s2);\\n        \\n        int min_s1 = sum_s1 - lcs_ascii_val;\\n        int min_s2 = sum_s2 - lcs_ascii_val; \\n        \\n        int min_ascii_del_sum = min_s1 + min_s2 ;\\n        \\n        return min_ascii_del_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379190,
                "title": "1d-dynamic-programming-o-n-m-time-o-m-space",
                "content": "My approach to this question is the same as that of [Lowest Common Subsequence question (LC 1143)](https://leetcode.com/problems/longest-common-subsequence/). \\nInstead of incrementing 1, we can increment the ASCII value of the character in the for loops. At the end, we will return *sum-2xdp[l2]* where \\n\\t*sum = sum of ASCII values of characters of s1 and s2*\\n```\\nint minimumDeleteSum(string s1, string s2) {\\n        int i,j,sum=0,l1=s1.length(),l2=s2.length(),prev,temp;\\n        vector<int> dp(l2+1,0);\\n        for(i=0;i<l1;i++)\\n            sum+=s1[i];\\n        for(i=0;i<l2;i++)\\n            sum+=s2[i];\\n        for(i=1;i<=l1;i++)\\n        {\\n            prev=dp[0];\\n            for(j=1;j<=l2;j++)\\n            {\\n                temp=dp[j];\\n                if(s1[i-1]==s2[j-1])\\n                    dp[j]=max(dp[j],prev+s1[i-1]);\\n                else\\n                    dp[j]=max(dp[j],dp[j-1]);\\n                prev=temp;\\n            }\\n        }\\n        return sum-2*dp[l2];\\n    }\\n```\\n\\nTime Complexity: O(n*m)\\nSpace Complexity: O(m)\\n\\nHope this helps!",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint minimumDeleteSum(string s1, string s2) {\\n        int i,j,sum=0,l1=s1.length(),l2=s2.length(),prev,temp;\\n        vector<int> dp(l2+1,0);\\n        for(i=0;i<l1;i++)\\n            sum+=s1[i];\\n        for(i=0;i<l2;i++)\\n            sum+=s2[i];\\n        for(i=1;i<=l1;i++)\\n        {\\n            prev=dp[0];\\n            for(j=1;j<=l2;j++)\\n            {\\n                temp=dp[j];\\n                if(s1[i-1]==s2[j-1])\\n                    dp[j]=max(dp[j],prev+s1[i-1]);\\n                else\\n                    dp[j]=max(dp[j],dp[j-1]);\\n                prev=temp;\\n            }\\n        }\\n        return sum-2*dp[l2];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1362616,
                "title": "3-types-of-dp-python",
                "content": "Top down recursive, Bottom up dp from end of the string, Bottom up dp from start of the string.\\n\\n```\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        \\n        #Top down recursive\\n        @cache\\n        def f(i,j):\\n            if i >= len(s1) and j >= len(s2):\\n                return 0\\n            if i < len(s1) and j >= len(s2):\\n                return sum(ord(c) for c in s1[i:])\\n            if i >= len(s1) and j < len(s2):\\n                return sum(ord(c) for c in s2[j:])\\n            if s1[i] == s2[j]:\\n                return f(i+1,j+1)\\n            return min([ord(s1[i]) + f(i+1,j), ord(s2[j]) + f(i,j+1), ord(s1[i]) + ord(s2[j]) + f(i+1,j+1)])\\n        \\n        ## Bottom up DP from end of the strings \\n        \\n        def bottomUpDpFromEnd():\\n            dp = [[0]*(len(s2)+1) for _ in range(len(s1)+1)]\\n            dp[len(s1)][len(s2)] = 0\\n            for j in range(len(s2)-1,-1,-1):\\n                dp[len(s1)][j] = dp[len(s1)][j+1] + ord(s2[j])\\n            for i in range(len(s1)-1,-1,-1):\\n                dp[i][len(s2)] = dp[i+1][len(s2)] + ord(s1[i])\\n            for i in range(len(s1)-1,-1,-1):\\n                for j in range(len(s2)-1,-1,-1):\\n                    if s1[i] == s2[j]:\\n                        dp[i][j] = dp[i+1][j+1]\\n                    else:\\n                        dp[i][j] = min(ord(s1[i])+dp[i+1][j],ord(s2[j])+dp[i][j+1])\\n            return dp[0][0]\\n        \\n        ## Bottom up DP from start of the strings\\n        # Let dp[i+1][j+1] have the answer for s1[:i+1],s2[:j+1]\\n        \\n        def bottomUpDpFromBeginning()\\n            dp = [[0]*(len(s2)+1) for _ in range(len(s1)+1)]\\n            dp[0][0] = 0\\n            for j in range(0,len(s2)):\\n                dp[0][j+1] = dp[0][j]+ord(s2[j])\\n            for i in range(0,len(s1)):\\n                dp[i+1][0] = dp[i][0] + ord(s1[i])\\n            for i in range(1,len(s1)+1):\\n                for j in range(1,len(s2)+1):\\n                    if s1[i-1] == s2[j-1]:\\n                        dp[i][j]= dp[i-1][j-1]\\n                    else:\\n                        dp[i][j] = min(dp[i-1][j]+ord(s1[i-1]), dp[i][j-1]+ord(s2[j-1]))\\n            return dp[len(s1)][len(s2)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        \\n        #Top down recursive\\n        @cache\\n        def f(i,j):\\n            if i >= len(s1) and j >= len(s2):\\n                return 0\\n            if i < len(s1) and j >= len(s2):\\n                return sum(ord(c) for c in s1[i:])\\n            if i >= len(s1) and j < len(s2):\\n                return sum(ord(c) for c in s2[j:])\\n            if s1[i] == s2[j]:\\n                return f(i+1,j+1)\\n            return min([ord(s1[i]) + f(i+1,j), ord(s2[j]) + f(i,j+1), ord(s1[i]) + ord(s2[j]) + f(i+1,j+1)])\\n        \\n        ## Bottom up DP from end of the strings \\n        \\n        def bottomUpDpFromEnd():\\n            dp = [[0]*(len(s2)+1) for _ in range(len(s1)+1)]\\n            dp[len(s1)][len(s2)] = 0\\n            for j in range(len(s2)-1,-1,-1):\\n                dp[len(s1)][j] = dp[len(s1)][j+1] + ord(s2[j])\\n            for i in range(len(s1)-1,-1,-1):\\n                dp[i][len(s2)] = dp[i+1][len(s2)] + ord(s1[i])\\n            for i in range(len(s1)-1,-1,-1):\\n                for j in range(len(s2)-1,-1,-1):\\n                    if s1[i] == s2[j]:\\n                        dp[i][j] = dp[i+1][j+1]\\n                    else:\\n                        dp[i][j] = min(ord(s1[i])+dp[i+1][j],ord(s2[j])+dp[i][j+1])\\n            return dp[0][0]\\n        \\n        ## Bottom up DP from start of the strings\\n        # Let dp[i+1][j+1] have the answer for s1[:i+1],s2[:j+1]\\n        \\n        def bottomUpDpFromBeginning()\\n            dp = [[0]*(len(s2)+1) for _ in range(len(s1)+1)]\\n            dp[0][0] = 0\\n            for j in range(0,len(s2)):\\n                dp[0][j+1] = dp[0][j]+ord(s2[j])\\n            for i in range(0,len(s1)):\\n                dp[i+1][0] = dp[i][0] + ord(s1[i])\\n            for i in range(1,len(s1)+1):\\n                for j in range(1,len(s2)+1):\\n                    if s1[i-1] == s2[j-1]:\\n                        dp[i][j]= dp[i-1][j-1]\\n                    else:\\n                        dp[i][j] = min(dp[i-1][j]+ord(s1[i-1]), dp[i][j-1]+ord(s2[j-1]))\\n            return dp[len(s1)][len(s2)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1334832,
                "title": "c-easy-explanation-with-diagram-variation-of-longest-common-subsequence-space-efficient",
                "content": "**Explanation**: In question, we have asked to find out minimum ascii sum of deleted character to make string s1 equal to s2 and the main purpose is to make this sum minimum. \\n\\nBy deleting this character you will get subsequence and we need to find minimum sum. Thus, we need to to find longest subsequence which will be not deleted in this process. Thus, we will come to know that it\\'s varient of longest common subsequence.\\n\\nNow, our main goal is to make ascii sum minimum, thus if we have more than 1 longest subsequnce with equal length then we will basically take maxium among them to make ascii sum minimum.\\n\\nExample:\\n\\n![image](https://assets.leetcode.com/users/images/7ff05919-740d-4538-9eac-a73d3d0e8170_1626175276.8534467.png)\\n\\n\\nIn this image, you can see that we have 2 longest subsequnce like \\'lee\\' and \\'tle\\' , but we will take maximum ascii sequence (\\'tle\\') from them.\\n\\n**Note:** We can optimize space complexity becuase we use only two rows in every iteration.\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    int lcs(string s,string t,int n,int m)\\n    {\\n        int dp[2][m+1];\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                if(i==0 ||j==0)\\n                    dp[(i%2)][j]=0;\\n                else if(s[i-1]==t[j-1])\\n                {\\n                  dp[(i%2)][j]=s[i-1]+dp[((i-1)%2)][j-1];\\n                    \\n                }\\n                else{\\n                    dp[(i%2)][j]=max(dp[((i-1)%2)][j],dp[(i%2)][j-1]);\\n                }\\n            }\\n        }\\n        return dp[(n%2)][m];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n     int ans=0;\\n        for(char nj:s1)\\n            ans+=nj;\\n        for(char nj:s2)\\n            ans+=nj;\\n        int ans2=lcs(s1,s2,s1.size(),s2.size());\\n        return ans-2*ans2;\\n    }\\n};\\n```\\n\\n```\\nTime Complexity:  O(n*m)\\nSpace Complexity: O(m)\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lcs(string s,string t,int n,int m)\\n    {\\n        int dp[2][m+1];\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                if(i==0 ||j==0)\\n                    dp[(i%2)][j]=0;\\n                else if(s[i-1]==t[j-1])\\n                {\\n                  dp[(i%2)][j]=s[i-1]+dp[((i-1)%2)][j-1];\\n                    \\n                }\\n                else{\\n                    dp[(i%2)][j]=max(dp[((i-1)%2)][j],dp[(i%2)][j-1]);\\n                }\\n            }\\n        }\\n        return dp[(n%2)][m];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n     int ans=0;\\n        for(char nj:s1)\\n            ans+=nj;\\n        for(char nj:s2)\\n            ans+=nj;\\n        int ans2=lcs(s1,s2,s1.size(),s2.size());\\n        return ans-2*ans2;\\n    }\\n};\\n```\n```\\nTime Complexity:  O(n*m)\\nSpace Complexity: O(m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243676,
                "title": "dp-o-mn-solution-with-o-min-m-n-space-python",
                "content": "The question looks eerily similar to the longest common subsequence, however in case there are multiple LCS possible, *which one should you choose?*\\n\\nThe question clearly asks us to retain the LCS and delete the remaining characters. The deletion should be such that ASCII sum of deleted characters is minimum. We know that ASCII sum of characters of strings s1 and s2 are constant.\\n**Hence, we need to ensure that ASCII sum of LCS chosen should be maximum so that the ASCII sum of deleted characters is minimum.**\\n\\nIn our dp array, instead of storing the LCS length, it makes more sense to store the ASCII sum of LCS.\\n\\nSo, the recursive equation is :\\n\\n\\tdp[i][j] = dp[i - 1][j - 1] + ASCII value of s1[i -1] , when s1[i - 1] == s2[j - 1]\\n\\n\\t\\t\\t = max(dp[i][j - 1] , dp[i - 1][j]) , elsewhere.\\n\\t\\t   \\nTime complexity is O(MN)\\nSpace taken by dp array is O(MN) which can be optimized to O(min(M,N)) since we are only using the values in the previous row.\\n\\nFinal answer would be ASCII sum of (s1 + s2) - twice the ASCII sum of LCS, \\n(twice because we are deleting the non-LCS characters from both the strings)\\n\\nThe space optimized code is:\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        \\n        l1 , l2 = len(s1) , len(s2)\\n        if l1 > l2 :\\n            self.minimumDeleteSum(s2,s1)\\n            \\n        dp2 = [0] * (l1 + 1)\\n        count2 = 0\\n        count1 = 0\\n        for i in range(1 , l2 + 1) :\\n            pre = dp2[0]\\n            count2 = count2 + ord(s2[i - 1]) #calculating ASCII sum for s2\\n                \\n            for j in range(1 , l1 + 1) :\\n                if i == 1:\\n                    count1 = count1 + ord(s1[j - 1]) #calculating ASCII sum for s1\\n                    \\n                cur = dp2[j] #cur takes the role of dp[i - 1][j]\\n                \\n                if s2[i - 1] == s1[j - 1] :\\n                    dp2[j] = pre + ord(s2[i - 1])\\n                \\n                else:\\n                    dp2[j] = max(dp2[j - 1] , cur) #dp[j - 1] takes the role of dp[i][j - 1]\\n                    \\n                pre = cur #pre takes the role of dp[i - 1][j - 1]\\n                \\n        LCS_sum = max(dp2)\\n        return count1 + count2 - 2 * LCS_sum\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        \\n        l1 , l2 = len(s1) , len(s2)\\n        if l1 > l2 :\\n            self.minimumDeleteSum(s2,s1)\\n            \\n        dp2 = [0] * (l1 + 1)\\n        count2 = 0\\n        count1 = 0\\n        for i in range(1 , l2 + 1) :\\n            pre = dp2[0]\\n            count2 = count2 + ord(s2[i - 1]) #calculating ASCII sum for s2\\n                \\n            for j in range(1 , l1 + 1) :\\n                if i == 1:\\n                    count1 = count1 + ord(s1[j - 1]) #calculating ASCII sum for s1\\n                    \\n                cur = dp2[j] #cur takes the role of dp[i - 1][j]\\n                \\n                if s2[i - 1] == s1[j - 1] :\\n                    dp2[j] = pre + ord(s2[i - 1])\\n                \\n                else:\\n                    dp2[j] = max(dp2[j - 1] , cur) #dp[j - 1] takes the role of dp[i][j - 1]\\n                    \\n                pre = cur #pre takes the role of dp[i - 1][j - 1]\\n                \\n        LCS_sum = max(dp2)\\n        return count1 + count2 - 2 * LCS_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132250,
                "title": "c-solution-top-down-dp-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n\\n// this function fills up the 2D vector, that is memoization \\n\\n    int solve (string &a, string &b, int n, int m, vector<vector<int>> &dp ) {\\n      if (dp[n][m] != -1) \\n\\t\\t  return dp[n][m];\\n      if (n == 0 or m == 0) \\n\\t\\t  return 0;\\n      if (a[n-1] == b[m-1]) \\n        return dp[n][m] = a[n-1] + solve(a, b, n-1, m-1, dp);\\n      else \\n        return dp[n][m] = max(solve(a, b, n-1, m, dp), solve(a, b, n, m-1, dp));      \\n    }\\n    \\n    int findSize(vector<vector<int>> &dp, string &a, string &b) {\\n      int i = a.size(), j = b.size();\\n      string found = \"\";\\n\\t  \\n      while (i > 0 and j > 0) {\\n        if (a[i-1] == b[j-1]) {\\n          found.push_back(a[i-1]);\\n          i--; j--;\\n        }\\n        else {\\n          if (dp[i-1][j] < dp[i][j-1])\\n              j--;\\n            else \\n              i--;\\n          }\\n      }\\n\\n// here we calculate the sum of ASCII values of all the characters in our subsequence\\n      int ans = 0;\\n      for (auto i : found)\\n        ans += i;\\n\\t\\t\\n      return ans;\\n    }\\n\\n\\n    int minimumDeleteSum(string a, string b) {\\n      vector<vector<int>> dp (a.size()+1, vector<int>(b.size()+1, -1));\\n      solve(a, b, a.size(), b.size(), dp);\\n      int subseq = findSize(dp, a, b);\\n\\t  \\n\\t  // total stores the sum of ASCII values of all the characters in both the strings\\n      int total = 0;\\n      for (auto i : a+b) \\n        total += i; \\n\\t  // subseq is subtracted twice because it occurs twice in the combined string a+b, once in a and again in b\\t\\n      return total - 2*subseq;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// this function fills up the 2D vector, that is memoization \\n\\n    int solve (string &a, string &b, int n, int m, vector<vector<int>> &dp ) {\\n      if (dp[n][m] != -1) \\n\\t\\t  return dp[n][m];\\n      if (n == 0 or m == 0) \\n\\t\\t  return 0;\\n      if (a[n-1] == b[m-1]) \\n        return dp[n][m] = a[n-1] + solve(a, b, n-1, m-1, dp);\\n      else \\n        return dp[n][m] = max(solve(a, b, n-1, m, dp), solve(a, b, n, m-1, dp));      \\n    }\\n    \\n    int findSize(vector<vector<int>> &dp, string &a, string &b) {\\n      int i = a.size(), j = b.size();\\n      string found = \"\";\\n\\t  \\n      while (i > 0 and j > 0) {\\n        if (a[i-1] == b[j-1]) {\\n          found.push_back(a[i-1]);\\n          i--; j--;\\n        }\\n        else {\\n          if (dp[i-1][j] < dp[i][j-1])\\n              j--;\\n            else \\n              i--;\\n          }\\n      }\\n\\n// here we calculate the sum of ASCII values of all the characters in our subsequence\\n      int ans = 0;\\n      for (auto i : found)\\n        ans += i;\\n\\t\\t\\n      return ans;\\n    }\\n\\n\\n    int minimumDeleteSum(string a, string b) {\\n      vector<vector<int>> dp (a.size()+1, vector<int>(b.size()+1, -1));\\n      solve(a, b, a.size(), b.size(), dp);\\n      int subseq = findSize(dp, a, b);\\n\\t  \\n\\t  // total stores the sum of ASCII values of all the characters in both the strings\\n      int total = 0;\\n      for (auto i : a+b) \\n        total += i; \\n\\t  // subseq is subtracted twice because it occurs twice in the combined string a+b, once in a and again in b\\t\\n      return total - 2*subseq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839640,
                "title": "c-easy-to-understand-dp-solution",
                "content": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2)\\n    {\\n        ll t=0;\\n        int n=s1.size();\\n        int m=s2.size();\\n        for(int i=0;i<n;i++)\\n            t+=(int)s1[i];\\n        for(int j=0;j<m;j++)\\n            t+=(int)s2[j];\\n        vector<vector<ll>>V(n+1,vector<ll>(m+1,0));\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s1[i-1]==s2[j-1])\\n                    V[i][j]=V[i-1][j-1]+(int)s1[i-1];\\n                else\\n                    V[i][j]=max(V[i][j-1],V[i-1][j]);\\n            }\\n        }\\n        return t-2*(V[n][m]);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2)\\n    {\\n        ll t=0;\\n        int n=s1.size();\\n        int m=s2.size();\\n        for(int i=0;i<n;i++)\\n            t+=(int)s1[i];\\n        for(int j=0;j<m;j++)\\n            t+=(int)s2[j];\\n        vector<vector<ll>>V(n+1,vector<ll>(m+1,0));\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s1[i-1]==s2[j-1])\\n                    V[i][j]=V[i-1][j-1]+(int)s1[i-1];\\n                else\\n                    V[i][j]=max(V[i][j-1],V[i-1][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 751847,
                "title": "java-solution-using-lcs-with-a-little-modification",
                "content": "```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int l1 = s1.length(), l2 = s2.length();\\n        int[][] dp = new int[l1+1][l2+1];\\n        int totalAscii = 0;\\n        \\n        for(int i=1; i<=l1; i++) {\\n            int ch1 = s1.charAt(i-1);\\n            totalAscii += ch1;\\n            \\n            for(int j=1; j<=l2; j++) {\\n                int ch2 = s2.charAt(j-1);\\n                if (i == 1) totalAscii += ch2;\\n                \\n                if (ch1 == ch2) {\\n                    // Add the ascii value of character instead of +1.\\n                    dp[i][j] = dp[i-1][j-1] + ch1;\\n                }\\n                else  dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        return totalAscii - dp[l1][l2] * 2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int l1 = s1.length(), l2 = s2.length();\\n        int[][] dp = new int[l1+1][l2+1];\\n        int totalAscii = 0;\\n        \\n        for(int i=1; i<=l1; i++) {\\n            int ch1 = s1.charAt(i-1);\\n            totalAscii += ch1;\\n            \\n            for(int j=1; j<=l2; j++) {\\n                int ch2 = s2.charAt(j-1);\\n                if (i == 1) totalAscii += ch2;\\n                \\n                if (ch1 == ch2) {\\n                    // Add the ascii value of character instead of +1.\\n                    dp[i][j] = dp[i-1][j-1] + ch1;\\n                }\\n                else  dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        return totalAscii - dp[l1][l2] * 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683066,
                "title": "simple-c-solution-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.length(),m=s2.length(); \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n        for(int i=1 ; i<=n ; i++) dp[i][0]=dp[i-1][0]+s1[i-1];\\n        for(int j=1 ; j<=m ; j++) dp[0][j]=dp[0][j-1]+s2[j-1];\\n        for(int i=1 ; i<=n ; i++)\\n            for(int j=1 ; j<=m ; j++)\\n            {\\n                if(s1[i-1]==s2[j-1]) dp[i][j]=dp[i-1][j-1];\\n                else dp[i][j]=min(dp[i-1][j]+s1[i-1],dp[i][j-1]+s2[j-1]);\\n            }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.length(),m=s2.length(); \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n        for(int i=1 ; i<=n ; i++) dp[i][0]=dp[i-1][0]+s1[i-1];\\n        for(int j=1 ; j<=m ; j++) dp[0][j]=dp[0][j-1]+s2[j-1];\\n        for(int i=1 ; i<=n ; i++)\\n            for(int j=1 ; j<=m ; j++)\\n            {\\n                if(s1[i-1]==s2[j-1]) dp[i][j]=dp[i-1][j-1];\\n                else dp[i][j]=min(dp[i-1][j]+s1[i-1],dp[i][j-1]+s2[j-1]);\\n            }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362702,
                "title": "giving-memory-limit-exceed",
                "content": "class Solution {\\npublic:\\n    int helper(string s1, string s2,int i1,int i2,vector<vector<int>> &dp){\\n        if(i1==s1.size()&&i2==s2.size()){\\n            return 0;\\n        }\\n        if(dp[i1][i2]!=0){\\n            return dp[i1][i2];\\n        }\\n        if(i1==s1.size()){\\n            int sum=0;\\n            for(;i2<s2.size();i2++){\\n                sum+=int(s2[i2]);\\n            }\\n            return sum;\\n        }\\n        \\n        if(i2==s2.size()){\\n            int sum=0;\\n            for(;i1<s1.size();i1++){\\n                sum+=int(s1[i1]);\\n            }\\n            return sum;\\n        }\\n        \\n        if(s1[i1]==s2[i2]){\\n            return dp[i1][i2]=helper(s1,s2,i1+1,i2+1,dp);\\n        }\\n        else{\\n            int res1=int(s1[i1]) + helper(s1,s2,i1+1,i2,dp);\\n            int res2=int(s2[i2]) + helper(s1,s2,i1,i2+1,dp);\\n            dp[i1][i2]=min(res1,res2);\\n            return min(res1,res2);\\n        }\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        vector<vector<int>> dp(s1.size()+1,vector<int>(s2.size()+1,0));\\n        return helper(s1,s2,0,0,dp);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int helper(string s1, string s2,int i1,int i2,vector<vector<int>> &dp){\\n        if(i1==s1.size()&&i2==s2.size()){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 310673,
                "title": "python-easy-clean-code-extreme-fast-204-ms-faster-than-100-00",
                "content": "```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        if m * n == 0:\\n            return m + n\\n        dp = [0] * n\\n        for i in range(m):\\n            prev = 0\\n            for j in range(n):\\n                last = dp[j]\\n                if s1[i] == s2[j]:\\n                    dp[j] = prev + ord(s1[i])\\n                if prev <= last:\\n                    prev = last\\n        return sum([ord(s) for s in s1+s2]) - max(dp) * 2 \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        if m * n == 0:\\n            return m + n\\n        dp = [0] * n\\n        for i in range(m):\\n            prev = 0\\n            for j in range(n):\\n                last = dp[j]\\n                if s1[i] == s2[j]:\\n                    dp[j] = prev + ord(s1[i])\\n                if prev <= last:\\n                    prev = last\\n        return sum([ord(s) for s in s1+s2]) - max(dp) * 2 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 247947,
                "title": "my-python-solution",
                "content": "```\\nclass Solution(object):\\n    def minimumDeleteSum(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: int\\n        \"\"\"\\n        n = len(s1)\\n        m = len(s2)\\n        dp = [[0 for i in range(m+1)] for j in range(n+1)]\\n        for i in range(n):\\n            for j in range(m):\\n                if s1[i] == s2[j]:\\n                    dp[i+1][j+1] = dp[i][j] + ord(s1[i])\\n                else:\\n                    dp[i+1][j+1] = max(dp[i][j+1],dp[i+1][j])\\n                    \\n        n1 = sum([ord(s) for s in s1])\\n        n2 = sum([ord(s) for s in s2])     \\n        return (n1-dp[n][m])+(n2-dp[n][m])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minimumDeleteSum(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: int\\n        \"\"\"\\n        n = len(s1)\\n        m = len(s2)\\n        dp = [[0 for i in range(m+1)] for j in range(n+1)]\\n        for i in range(n):\\n            for j in range(m):\\n                if s1[i] == s2[j]:\\n                    dp[i+1][j+1] = dp[i][j] + ord(s1[i])\\n                else:\\n                    dp[i+1][j+1] = max(dp[i][j+1],dp[i+1][j])\\n                    \\n        n1 = sum([ord(s) for s in s1])\\n        n2 = sum([ord(s) for s in s2])     \\n        return (n1-dp[n][m])+(n2-dp[n][m])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 182203,
                "title": "c-recursion-memoization",
                "content": "Obvious solution. Slower, than buttom-up dp solution, but still O(N^2) space and time complexity.\n\n```\nclass Solution {\npublic:\n    \n    int recursive(const string &s1, const string &s2, int l1, int l2, vector<vector<int>> &cache) {\n        if (cache[l1][l2] != -1) return cache[l1][l2];\n        \n        int result = 0;\n        if (l1 >= s1.size() && l2 >= s2.size()) {\n            return 0;\n        } else if (l1 >= s1.size()) {\n            result = s2[l2] + recursive(s1,s2, l1, l2 + 1, cache);\n        } else if (l2 >= s2.size()) {\n            result = s1[l1] + recursive(s1, s2, l1 + 1, l2, cache);\n        } else {\n            result = (s1[l1] == s2[l2]) \n                    ? recursive(s1, s2, l1 + 1, l2 + 1, cache)\n                    : min(s1[l1] + recursive(s1, s2, l1 + 1, l2, cache), s2[l2] + recursive(s1,s2, l1, l2 + 1, cache));\n        }\n        cache[l1][l2] = result;\n        return result;\n    }\n    \n    int minimumDeleteSum(string s1, string s2) {\n        vector<vector<int>> cache(s1.size()+1, vector<int>(s2.size()+1, -1));\n        return recursive(s1,s2,0,0,cache);\n    }\n};",
                "solutionTags": [],
                "code": "class Solution {\npublic:\n    \n    int recursive(const string &s1, const string &s2, int l1, int l2, vector<vector<int>> &cache) {\n        if (cache[l1][l2] != -1) return cache[l1][l2];\n        \n        int result = 0;\n        if (l1 >= s1.size() && l2 >= s2.size()) {\n            return 0;\n        }",
                "codeTag": "Java"
            },
            {
                "id": 170891,
                "title": "java-solution-similar-to-edit-distance",
                "content": "**Idea**\\nSimilar to edit distance, explanation @\\nhttps://leetcode.com/problems/edit-distance/discuss/170442/Java-DP-with-clear-explanation\\n\\n`dp[i][j]` indicates min-ascii-delete-sum between `s1[0..i]` and `s2[0..j]`.\\n\\n```\\npublic int minimumDeleteSum(String s1, String s2) {\\n        int m = s1.length(), n = s2.length();\\n        int[][] dp = new int[m+1][n+1];\\n        for(int j=1; j <= n; j++)\\n            dp[0][j] = dp[0][j-1] + s2.charAt(j-1);\\n        for(int i=1; i <= m; i++)\\n            dp[i][0] = dp[i-1][0] + s1.charAt(i-1);\\n        for(int i=1; i <= m; i++){\\n            for(int j=1; j <= n; j++){\\n                if(s1.charAt(i-1) == s2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = Math.min(s1.charAt(i-1)+dp[i-1][j], s2.charAt(j-1)+dp[i][j-1]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minimumDeleteSum(String s1, String s2) {\\n        int m = s1.length(), n = s2.length();\\n        int[][] dp = new int[m+1][n+1];\\n        for(int j=1; j <= n; j++)\\n            dp[0][j] = dp[0][j-1] + s2.charAt(j-1);\\n        for(int i=1; i <= m; i++)\\n            dp[i][0] = dp[i-1][0] + s1.charAt(i-1);\\n        for(int i=1; i <= m; i++){\\n            for(int j=1; j <= n; j++){\\n                if(s1.charAt(i-1) == s2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = Math.min(s1.charAt(i-1)+dp[i-1][j], s2.charAt(j-1)+dp[i][j-1]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 161054,
                "title": "java-o-nm-time-and-o-n-space-solution",
                "content": "Matrix update relation :\\ndp[i][j] = min(s1.charAt(i-1) + dp[i-1][j] , s2.charAt(j-1) + dp[i][j-1] , s1.charAt(i) + s2.charAt(j) + dp[i-1][j-1]) \\n\\nIdea is to maintain only two rows (i-1)th and (i)th row as only these are needed to update matrix. This can be easily done by swapping the reference variables of array as shown in following code.\\n```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int n=s1.length(),m=s2.length();\\n        int[] a=new int[m+1],b=new int[m+1],temp;\\n        for(int i=1;i<=m;i++)\\n            a[i]=a[i-1]+s2.charAt(i-1);\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            b[0]=a[0]+s1.charAt(i-1);\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s1.charAt(i-1)==s2.charAt(j-1))\\n                    b[j]=a[j-1];\\n                else\\n                    b[j]=Math.min(s1.charAt(i-1)+a[j],Math.min(s2.charAt(j-1)+b[j-1],s1.charAt(i-1)+s2.charAt(j-1)+a[j-1]));\\n            }\\n\\t\\t\\t\\t\\t\\t// swapping both arrays\\n            temp=b;\\n            b=a;\\n            a=temp;\\n        }\\n        return a[m];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int n=s1.length(),m=s2.length();\\n        int[] a=new int[m+1],b=new int[m+1],temp;\\n        for(int i=1;i<=m;i++)\\n            a[i]=a[i-1]+s2.charAt(i-1);\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            b[0]=a[0]+s1.charAt(i-1);\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s1.charAt(i-1)==s2.charAt(j-1))\\n                    b[j]=a[j-1];\\n                else\\n                    b[j]=Math.min(s1.charAt(i-1)+a[j],Math.min(s2.charAt(j-1)+b[j-1],s1.charAt(i-1)+s2.charAt(j-1)+a[j-1]));\\n            }\\n\\t\\t\\t\\t\\t\\t// swapping both arrays\\n            temp=b;\\n            b=a;\\n            a=temp;\\n        }\\n        return a[m];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155516,
                "title": "simple-c-solution-with-explanation",
                "content": " NOTE:\\n - `dp[i][j]` indicates the minimum delete sum for `s1[0 : i - 1]` and `s2[0 : j - 1]`.\\n - Initiation:\\n   - When `i = 0`, `dp[0][j] = dp[0][j - 1] + s2[j - 1]`, the only choice is to delete `s2` cause `s1` is empty.\\n   - When `j = 0`, same as the `i = 0` situation, `dp[i][0] = dp[i  - 1][0] + s1[i - 1]`.\\n - DP formula:\\n   - When `s1[i - 1] = s2[j - 1]`, we don\\'t need to delete either character, we just refer to the result of `dp[i - 1][j - 1]`.\\n   - When `s1[i - 1] != s2[j - 1]`, we get the minimun delete sum by `min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1])`, which indicates get the minimum one between `ASCII value of s1[i  -1] + the result of s1[i - 1] and s2[j]` and `ASCII value of s2[j  -1] + the result of s2[j - 1] and s1[i]`.\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        int dp[m + 1][n + 1] = {};\\n        \\n        for (int i = 1; i <= n; i++) dp[0][i] = dp[0][i - 1] + s2[i - 1];\\n        for (int i = 1; i <= m; i++) dp[i][0] = dp[i - 1][0] + s1[i - 1];\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (s1[i - 1] == s2[j - 1]) dp[i][j] = dp[i - 1][j - 1];\\n                else dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);\\n            }\\n        }\\n\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        int dp[m + 1][n + 1] = {};\\n        \\n        for (int i = 1; i <= n; i++) dp[0][i] = dp[0][i - 1] + s2[i - 1];\\n        for (int i = 1; i <= m; i++) dp[i][0] = dp[i - 1][0] + s1[i - 1];\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (s1[i - 1] == s2[j - 1]) dp[i][j] = dp[i - 1][j - 1];\\n                else dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);\\n            }\\n        }\\n\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128409,
                "title": "one-c-dp-solution-for-all-712-583-72-115-97",
                "content": "**Steps:**\\n1. Define dp[i][j] :=f(s1[0..i-1], s2[0..j-1])  \\n2.  Set up border condtion dp[0][:] and dp[:][0]. \\n3. Iteration and apply dp rules.\\n4.  return dp[n1][n2]\\n\\n### 712. Minimum ASCII Delete Sum for Two Strings\\n```\\n    int minimumDeleteSum(string s1, string s2) {\\n          int n1 = s1.size(), n2 = s2.size();\\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1,0));\\n        for(int i=1; i<=n1;++i) dp[i][0] = s1[i-1]+dp[i-1][0];\\n        for(int i=1; i<=n2;++i) dp[0][i] = s2[i-1]+dp[0][i-1];\\n        for(int i=1; i<=n1; ++i){\\n            for(int j=1; j<=n2; ++j){\\n                if(s1[i-1]==s2[j-1]) dp[i][j] = dp[i-1][j-1];\\n                else dp[i][j]=  min(dp[i][j-1 ]+s2[j-1],dp[i - 1][j]+s1[i-1]);\\n            }\\n        }\\n        return dp[n1][n2]; \\n    }\\n```\\n#### 583. Delete Operation for Two Strings\\n```\\n    int minDistance(string s1, string s2) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1,0));\\n        for(int i=1; i<=n1;++i) dp[i][0] = i;\\n        for(int i=1; i<=n2;++i) dp[0][i] = i;\\n        for(int i=1; i<=n1; ++i){\\n            for(int j=1; j<=n2; ++j){\\n                if(s1[i-1]==s2[j-1]) dp[i][j] = dp[i-1][j-1];\\n                else dp[i][j]=  min(dp[i][j-1 ],dp[i - 1][j])+1;\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n```\\n### 72. Edit Distance\\n```\\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size(), n2 = word2.size();\\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1,0));\\n        for(int i=0; i<=n1;++i) dp[i][0] = i;\\n        for(int i=0; i<=n2;++i) dp[0][i] = i;\\n        for(int i=1; i<=n1; ++i){\\n            for(int j=1; j<=n2; ++j){\\n                if(word1[i-1]==word2[j-1]) dp[i][j] = dp[i-1][j-1];\\n                else dp[i][j]=  min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n```\\n\\n#### 115. Distinct Subsequences\\n\\n```\\n    int numDistinct(string s2, string s1) {\\n         int n1 = s1.size(), n2 = s2.size();\\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1,0));\\n        for(int i=0; i<=n2;++i) dp[0][i] = 1;\\n        for(int i=1; i<=n1; ++i){\\n            for(int j=1; j<=n2; ++j){ \\n                if(s1[i-1]==s2[j-1]) dp[i][j] =dp[i][j-1 ]+dp[i - 1][j - 1];\\n                else dp[i][j]= dp[i][j - 1]; \\n            }\\n        }\\n        return dp[n1][n2];        \\n    }\\n```\\n#### 97. Interleaving String \\n```\\n   bool isInterleave(string s1, string s2, string s3) {\\n        int n1 = s1.size(), n2 = s2.size(), n3 = s3.size();\\n        if(n3 != n1+n2) return false;\\n        vector<vector<bool>> dp(n1+1, vector<bool>(n2+1,true));      \\n        for(int i=1; i<=n1;++i) dp[i][0] = dp[i-1][0]&&s1[i-1]==s3[i-1];\\n        for(int i=1; i<=n2;++i) dp[0][i] = dp[0][i-1]&&s2[i-1]==s3[i-1];  \\n        for(int i=1; i<=n1; ++i){\\n            for(int j=1; j<=n2; ++j){\\n                dp[i][j]= dp[i-1][j]&&s1[i-1] == s3[i+j-1] ||dp[i][j-1]&&s2[j-1] == s3[i+j-1];\\n            }\\n        }\\n        return dp[n1][n2];  \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int minimumDeleteSum(string s1, string s2) {\\n          int n1 = s1.size(), n2 = s2.size();\\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1,0));\\n        for(int i=1; i<=n1;++i) dp[i][0] = s1[i-1]+dp[i-1][0];\\n        for(int i=1; i<=n2;++i) dp[0][i] = s2[i-1]+dp[0][i-1];\\n        for(int i=1; i<=n1; ++i){\\n            for(int j=1; j<=n2; ++j){\\n                if(s1[i-1]==s2[j-1]) dp[i][j] = dp[i-1][j-1];\\n                else dp[i][j]=  min(dp[i][j-1 ]+s2[j-1],dp[i - 1][j]+s1[i-1]);\\n            }\\n        }\\n        return dp[n1][n2]; \\n    }\\n```\n```\\n    int minDistance(string s1, string s2) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1,0));\\n        for(int i=1; i<=n1;++i) dp[i][0] = i;\\n        for(int i=1; i<=n2;++i) dp[0][i] = i;\\n        for(int i=1; i<=n1; ++i){\\n            for(int j=1; j<=n2; ++j){\\n                if(s1[i-1]==s2[j-1]) dp[i][j] = dp[i-1][j-1];\\n                else dp[i][j]=  min(dp[i][j-1 ],dp[i - 1][j])+1;\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n```\n```\\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size(), n2 = word2.size();\\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1,0));\\n        for(int i=0; i<=n1;++i) dp[i][0] = i;\\n        for(int i=0; i<=n2;++i) dp[0][i] = i;\\n        for(int i=1; i<=n1; ++i){\\n            for(int j=1; j<=n2; ++j){\\n                if(word1[i-1]==word2[j-1]) dp[i][j] = dp[i-1][j-1];\\n                else dp[i][j]=  min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n```\n```\\n    int numDistinct(string s2, string s1) {\\n         int n1 = s1.size(), n2 = s2.size();\\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1,0));\\n        for(int i=0; i<=n2;++i) dp[0][i] = 1;\\n        for(int i=1; i<=n1; ++i){\\n            for(int j=1; j<=n2; ++j){ \\n                if(s1[i-1]==s2[j-1]) dp[i][j] =dp[i][j-1 ]+dp[i - 1][j - 1];\\n                else dp[i][j]= dp[i][j - 1]; \\n            }\\n        }\\n        return dp[n1][n2];        \\n    }\\n```\n```\\n   bool isInterleave(string s1, string s2, string s3) {\\n        int n1 = s1.size(), n2 = s2.size(), n3 = s3.size();\\n        if(n3 != n1+n2) return false;\\n        vector<vector<bool>> dp(n1+1, vector<bool>(n2+1,true));      \\n        for(int i=1; i<=n1;++i) dp[i][0] = dp[i-1][0]&&s1[i-1]==s3[i-1];\\n        for(int i=1; i<=n2;++i) dp[0][i] = dp[0][i-1]&&s2[i-1]==s3[i-1];  \\n        for(int i=1; i<=n1; ++i){\\n            for(int j=1; j<=n2; ++j){\\n                dp[i][j]= dp[i-1][j]&&s1[i-1] == s3[i+j-1] ||dp[i][j-1]&&s2[j-1] == s3[i+j-1];\\n            }\\n        }\\n        return dp[n1][n2];  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3845515,
                "title": "based-on-edit-distance-and-lcs-short-summarization",
                "content": "based on two simple choices,\\n\\n1-> if the srart charcater of both the Strings match,just skip these two characters and move forward\\n\\n2-> if the starting characters are not same, either delete the start chyaracter from the first String , or the second string , and take the min of both the options.\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        return util2(s1,s2);\\n    }\\n    public int util2(String s1, String s2) {\\n        int dp[][] = new int[s1.length() + 1][s2.length() + 1];\\n        dp[0][0] = 0;\\n        for (int i = 1, j = 0; i <= s1.length(); i++) {\\n            dp[i][j] = dp[i - 1][j] + ((int) s1.charAt(i - 1));\\n        }\\n        for (int j = 1, i = 0; j <= s2.length(); j++) {\\n            dp[i][j] = dp[i][j - 1] + ((int) s2.charAt(j - 1));\\n        }\\n        for (int i = 1; i < dp.length; i++) {\\n            for (int j = 1; j < dp[0].length; j++) {\\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    int ans1 = dp[i - 1][j] + ((int) s1.charAt(i - 1));\\n                    int ans2 = dp[i][j - 1] + ((int) s2.charAt(j - 1));\\n                    dp[i][j] = Math.min(ans1, ans2);\\n                }\\n            }\\n        }\\n        return dp[s1.length()][s2.length()];\\n    }\\n}\\n```\\n\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        return util2(s1,s2);\\n    }\\n    public int util2(String s1, String s2) {\\n        int dp[][] = new int[s1.length() + 1][s2.length() + 1];\\n        dp[0][0] = 0;\\n        for (int i = 1, j = 0; i <= s1.length(); i++) {\\n            dp[i][j] = dp[i - 1][j] + ((int) s1.charAt(i - 1));\\n        }\\n        for (int j = 1, i = 0; j <= s2.length(); j++) {\\n            dp[i][j] = dp[i][j - 1] + ((int) s2.charAt(j - 1));\\n        }\\n        for (int i = 1; i < dp.length; i++) {\\n            for (int j = 1; j < dp[0].length; j++) {\\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    int ans1 = dp[i - 1][j] + ((int) s1.charAt(i - 1));\\n                    int ans2 = dp[i][j - 1] + ((int) s2.charAt(j - 1));\\n                    dp[i][j] = Math.min(ans1, ans2);\\n                }\\n            }\\n        }\\n        return dp[s1.length()][s2.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844685,
                "title": "very-easy-dp-solution-for-beginners-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is similar to longest common subsequence\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmemoization\\n# Complexity\\n- Time complexity:\\n- O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N*M) + O(N+M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int f(string &s1, string &s2, int i , int j, int n, int m, vector<vector<int>> &dp) {\\n        if(i == n && j < m){\\n            int t = 0;\\n            for(int k = j ; k < m ; k++){\\n                t+=int(s2[k]);\\n            }\\n            return t;\\n        }\\n        if(j == m && i < n){\\n            int t = 0;\\n            for(int k = i ; k < n ; k++){\\n                t+=int(s1[k]);\\n            }\\n            return t;\\n        }\\n        if(i == n && j == m) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s1[i] == s2[j]) {\\n            return dp[i][j] = 0 + f(s1, s2, i+1, j+1, n, m, dp);\\n        }\\n        int x = int(s1[i]) + f(s1, s2, i+1, j, n , m, dp);\\n        int y = int(s2[j]) + f(s1, s2, i, j+1, n , m, dp);\\n        // int z = int(s1[i]) + int(s2[j]) + f(s1, s2, i+1, j+1, n , m);\\n        return dp[i][j] = min(x, y);\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.length();\\n        int m = s2.length();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        return f(s1, s2, 0, 0, n, m, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int f(string &s1, string &s2, int i , int j, int n, int m, vector<vector<int>> &dp) {\\n        if(i == n && j < m){\\n            int t = 0;\\n            for(int k = j ; k < m ; k++){\\n                t+=int(s2[k]);\\n            }\\n            return t;\\n        }\\n        if(j == m && i < n){\\n            int t = 0;\\n            for(int k = i ; k < n ; k++){\\n                t+=int(s1[k]);\\n            }\\n            return t;\\n        }\\n        if(i == n && j == m) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s1[i] == s2[j]) {\\n            return dp[i][j] = 0 + f(s1, s2, i+1, j+1, n, m, dp);\\n        }\\n        int x = int(s1[i]) + f(s1, s2, i+1, j, n , m, dp);\\n        int y = int(s2[j]) + f(s1, s2, i, j+1, n , m, dp);\\n        // int z = int(s1[i]) + int(s2[j]) + f(s1, s2, i+1, j+1, n , m);\\n        return dp[i][j] = min(x, y);\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.length();\\n        int m = s2.length();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        return f(s1, s2, 0, 0, n, m, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844264,
                "title": "dp-solution-using-memoization-prefix-sum",
                "content": "# Complexity\\n- Time complexity: $$O(M*N)$$\\n\\n- Space complexity: $$O(M*N)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> ps1,ps2;\\n    int f(int i,int j,string &s1, string &s2,vector<vector<int>>& dp){\\n        if(i<0 && j<0) return 0;\\n        if(i<0) return ps2[j];\\n        if(j<0) return ps1[i];\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int cost=0;\\n        if(s1[i]==s2[j]){\\n            cost = f(i-1,j-1,s1,s2,dp);\\n        }\\n        else{\\n            int d1 = s1[i]+f(i-1,j,s1,s2,dp);\\n            int d2 = s2[j]+f(i,j-1,s1,s2,dp);\\n            int d12 = s1[i]+s2[j]+f(i-1,j-1,s1,s2,dp);\\n            cost = min(d12,min(d1,d2));\\n        }\\n        return dp[i][j]=cost;\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m=s1.size(), n=s2.size();\\n        ps1.resize(m,0);\\n        ps2.resize(n,0);\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<m;i++){\\n            sum1 += s1[i];\\n            ps1[i]=sum1;\\n        }\\n        for(int i=0;i<n;i++){\\n            sum2 += s2[i];\\n            ps2[i]=sum2;\\n        }\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(m-1,n-1,s1,s2,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ps1,ps2;\\n    int f(int i,int j,string &s1, string &s2,vector<vector<int>>& dp){\\n        if(i<0 && j<0) return 0;\\n        if(i<0) return ps2[j];\\n        if(j<0) return ps1[i];\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int cost=0;\\n        if(s1[i]==s2[j]){\\n            cost = f(i-1,j-1,s1,s2,dp);\\n        }\\n        else{\\n            int d1 = s1[i]+f(i-1,j,s1,s2,dp);\\n            int d2 = s2[j]+f(i,j-1,s1,s2,dp);\\n            int d12 = s1[i]+s2[j]+f(i-1,j-1,s1,s2,dp);\\n            cost = min(d12,min(d1,d2));\\n        }\\n        return dp[i][j]=cost;\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m=s1.size(), n=s2.size();\\n        ps1.resize(m,0);\\n        ps2.resize(n,0);\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<m;i++){\\n            sum1 += s1[i];\\n            ps1[i]=sum1;\\n        }\\n        for(int i=0;i<n;i++){\\n            sum2 += s2[i];\\n            ps2[i]=sum2;\\n        }\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(m-1,n-1,s1,s2,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843909,
                "title": "lcs-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(string &s1,string &s2, int f, int s,vector<vector<int >> &v)\\n    {\\n        int n = s1.size();\\n        int m = s2.size();\\n        int ans = INT_MAX;\\n        \\n        if(v[f][s]!=-1)\\n            return v[f][s];\\n        \\n        if(f>=n && s>=m)\\n            return 0;\\n        \\n         if(f>=n)\\n         {\\n            return int(s2[s]) + solve(s1,s2,f,s+1,v); \\n         }\\n        \\n        if(s>=m)\\n         {\\n            return int(s1[f]) + solve(s1,s2,f+1,s,v);\\n         }\\n        \\n        if(s1[f] == s2[s])\\n        {\\n            return   v[f][s] = solve(s1,s2,f+1,s+1,v);\\n        }\\n        ans = min({ans, solve(s1,s2,f+1,s,v)+int(s1[f]) ,solve(s1,s2,f,s+1,v)+int(s2[s])} );\\n        \\n        return  v[f][s] = ans;\\n    }\\n    \\n    \\n    int minimumDeleteSum(string s1, string s2) {\\n        \\n        int n,m;\\n        n = s1.size();\\n        m = s2.size();\\n        vector<vector<int >> v(n+1,vector<int>(m+1,-1));\\n        int ans  = solve(s1,s2,0,0,v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string &s1,string &s2, int f, int s,vector<vector<int >> &v)\\n    {\\n        int n = s1.size();\\n        int m = s2.size();\\n        int ans = INT_MAX;\\n        \\n        if(v[f][s]!=-1)\\n            return v[f][s];\\n        \\n        if(f>=n && s>=m)\\n            return 0;\\n        \\n         if(f>=n)\\n         {\\n            return int(s2[s]) + solve(s1,s2,f,s+1,v); \\n         }\\n        \\n        if(s>=m)\\n         {\\n            return int(s1[f]) + solve(s1,s2,f+1,s,v);\\n         }\\n        \\n        if(s1[f] == s2[s])\\n        {\\n            return   v[f][s] = solve(s1,s2,f+1,s+1,v);\\n        }\\n        ans = min({ans, solve(s1,s2,f+1,s,v)+int(s1[f]) ,solve(s1,s2,f,s+1,v)+int(s2[s])} );\\n        \\n        return  v[f][s] = ans;\\n    }\\n    \\n    \\n    int minimumDeleteSum(string s1, string s2) {\\n        \\n        int n,m;\\n        n = s1.size();\\n        m = s2.size();\\n        vector<vector<int >> v(n+1,vector<int>(m+1,-1));\\n        int ans  = solve(s1,s2,0,0,v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843860,
                "title": "c-easy-memorization",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(string& s1, string& s2, int start1, int start2, vector<vector<int>> &t){\\n        if(t[start1][start2]!=-1){\\n            return t[start1][start2];\\n        }\\n        if(start1==s1.length()){\\n            int val=0;\\n            for(int i=start2; i<s2.length(); i++){\\n                val+=int(s2[i]);\\n            }\\n            return t[start1][start2]=val;\\n        }\\n         if(start2==s2.length()){\\n            int val=0;\\n            for(int i=start1; i<s1.length(); i++){\\n                val+=int(s1[i]);\\n            }\\n            return t[start1][start2]=val;\\n        }\\n        if(s1[start1]==s2[start2]){\\n            return t[start1][start2]=solve(s1, s2, start1+1, start2+1, t);\\n        }\\n        return t[start1][start2]=min({int(s1[start1])+solve(s1, s2, start1+1, start2, t),int(s2[start2])+solve(s1, s2, start1, start2+1, t)});\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n         vector<vector<int>> t(s1.size()+1, vector<int>(s2.size()+1, -1));\\n        return solve(s1, s2, 0 ,0, t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string& s1, string& s2, int start1, int start2, vector<vector<int>> &t){\\n        if(t[start1][start2]!=-1){\\n            return t[start1][start2];\\n        }\\n        if(start1==s1.length()){\\n            int val=0;\\n            for(int i=start2; i<s2.length(); i++){\\n                val+=int(s2[i]);\\n            }\\n            return t[start1][start2]=val;\\n        }\\n         if(start2==s2.length()){\\n            int val=0;\\n            for(int i=start1; i<s1.length(); i++){\\n                val+=int(s1[i]);\\n            }\\n            return t[start1][start2]=val;\\n        }\\n        if(s1[start1]==s2[start2]){\\n            return t[start1][start2]=solve(s1, s2, start1+1, start2+1, t);\\n        }\\n        return t[start1][start2]=min({int(s1[start1])+solve(s1, s2, start1+1, start2, t),int(s2[start2])+solve(s1, s2, start1, start2+1, t)});\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n         vector<vector<int>> t(s1.size()+1, vector<int>(s2.size()+1, -1));\\n        return solve(s1, s2, 0 ,0, t);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843754,
                "title": "bottom-up-simple-approach-easy-to-understand",
                "content": "# \\uD83D\\uDCAD Intuition\\nOkay this one is straightforward DP question. Because the solution is the **LOWEST** sum of removed characters. So we have to remove minimum letters possible from both of the strings, so remaining strings are equal. If thought in reverse, we will be solving to *maximize the length of remaining string, which would be a subsequence of both strings*.\\nHmm, does that ring a bell? Ah yes,the classic **LCS** DP problem.\\n1. Find the Longest Common Substring of `s1` and `s2`.\\n    1. First priority is length of the string. $longer\\\\ the\\\\ better\\\\ [\\xAC\\u203F\\xAC]$\\n    2. Take characters with higher ASCII value. That is second priority.\\n3. Calculate `total` ASCII sum of both `s1` and `s2`.\\n4. Since the LCS appears in both strings, we will have to deduct it twice from `total`.  And that is the desired answer.\\n \\n<hr/>\\n\\n# \\uD83D\\uDCDDApproach\\nWe will be using a 2D array `dp` as a table to store the subproblems. \\nIt will have `n` rows and `m` columns, all cells are initially 0.\\n- $E.g:$ `dp[i][j]` = answer to the subproblem where,\\n    - first string is `i+1` length prefix of `s1` \\n    - second string is `j+1` length prefix of `s2`.\\n    \\nNext step is to fill the table `dp`:\\n- There are total 3 choices that we have.\\n    - If currently both characters match `s1[i] == s2[j]`, then we can take that ASCII value and add it to previous best answer `dp[i-1][j-1]`.\\n    - If we don\\'t take then also we have two options\\n        - take one less character from `s1`. `dp[i-1][j]`\\n        - take one less character from `s2`. `dp[i][j-1]`\\n\\nNow that we have the maximum sum of ASCII values of the Longest Common Subsequence of `s1` and `s2`, we can easily find the sum of characters that are being omitted.\\n    We can do so by adding up ASCII values of all characters in both strings, then deduct `dp[n-1][m-1]` twice, because they appear in both strings.\\n$\\\\therefore$ The answer is `total`- 2 *`dp[n-1][m-1]`.\\n\\n<hr/>\\n\\n# \\uD83D\\uDCCA Complexity\\n- \\u23F3 Time complexity: $O(N^2)$\\n\\n- \\uD83D\\uDCE6 Space complexity: $O(N^2)$\\n \\n<hr/>\\n\\n# \\u2328\\uFE0F Code\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.size(), m = s2.size();\\n        int dp[n][m]; memset(dp, 0, sizeof(dp));\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                int ans = 0;\\n                if(s1[i] == s2[j]) {\\n                    ans = s1[i]; \\n                    if(i && j) // boundary check to avoid runtime errors\\n                        ans += dp[i-1][j-1]; \\n                }\\n                // previous answers :\\n                if(i) ans = max(ans, dp[i-1][j]); \\n                if(j) ans = max(ans, dp[i][j-1]); \\n                dp[i][j] = ans;\\n            }\\n        }\\n        int total = 0;\\n        for(const auto& c : s1) total += c;\\n        for(const auto& c : s2) total += c;\\n        return total - 2*dp[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.size(), m = s2.size();\\n        int dp[n][m]; memset(dp, 0, sizeof(dp));\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                int ans = 0;\\n                if(s1[i] == s2[j]) {\\n                    ans = s1[i]; \\n                    if(i && j) // boundary check to avoid runtime errors\\n                        ans += dp[i-1][j-1]; \\n                }\\n                // previous answers :\\n                if(i) ans = max(ans, dp[i-1][j]); \\n                if(j) ans = max(ans, dp[i][j-1]); \\n                dp[i][j] = ans;\\n            }\\n        }\\n        int total = 0;\\n        for(const auto& c : s1) total += c;\\n        for(const auto& c : s2) total += c;\\n        return total - 2*dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843531,
                "title": "712-minimum-ascii-delete-sum-for-two-strings-java",
                "content": "```\\nclass Solution {\\n    public int solve(String s1, String s2,int n,int m,int [][]dp)\\n    {\\n        if(n==0)\\n            return dp[n][m]=get(s2,m);\\n        else if(m==0)\\n            return dp[n][m]=get(s1,n);\\n        \\n        if(dp[n][m]!=0)\\n            return dp[n][m];\\n        if(s1.charAt(n-1)==s2.charAt(m-1))\\n            return dp[n][m]=solve(s1,s2,n-1,m-1,dp);\\n        else\\n        {\\n             int ans1=s1.charAt(n-1)+solve(s1,s2,n-1,m,dp);\\n             int ans2=s2.charAt(m-1)+solve(s1,s2,n,m-1,dp);\\n            return dp[n][m]=Math.min(ans1,ans2);\\n        }\\n    }\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int n=s1.length(),m=s2.length();\\n        int dp[][]=new int[n+1][m+1];\\n       return  solve(s1,s2,n,m,dp);\\n    }\\n    public int get(String s,int l)\\n    {\\n        int ans=0;\\n        for(int i=0;i<l;i++)\\n            ans+=s.charAt(i);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int solve(String s1, String s2,int n,int m,int [][]dp)\\n    {\\n        if(n==0)\\n            return dp[n][m]=get(s2,m);\\n        else if(m==0)\\n            return dp[n][m]=get(s1,n);\\n        \\n        if(dp[n][m]!=0)\\n            return dp[n][m];\\n        if(s1.charAt(n-1)==s2.charAt(m-1))\\n            return dp[n][m]=solve(s1,s2,n-1,m-1,dp);\\n        else\\n        {\\n             int ans1=s1.charAt(n-1)+solve(s1,s2,n-1,m,dp);\\n             int ans2=s2.charAt(m-1)+solve(s1,s2,n,m-1,dp);\\n            return dp[n][m]=Math.min(ans1,ans2);\\n        }\\n    }\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int n=s1.length(),m=s2.length();\\n        int dp[][]=new int[n+1][m+1];\\n       return  solve(s1,s2,n,m,dp);\\n    }\\n    public int get(String s,int l)\\n    {\\n        int ans=0;\\n        for(int i=0;i<l;i++)\\n            ans+=s.charAt(i);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843509,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,string &s1,string &s2,vector<vector<int>> &dp)\\n    {\\n        if(i<0)\\n        {\\n            int sum=0;\\n            for(int k=0; k<=j; k++) \\n                sum+=int(s2[k]);\\n            return sum;\\n        }\\n        if(j<0)\\n        {\\n            int sum=0;\\n            for(int k=0; k<=i; k++) \\n                sum+=int(s1[k]);\\n            return sum;\\n        }\\n        if(dp[i][j]!=-1) \\n            return dp[i][j];\\n\\n        if(s1[i]==s2[j])\\n            return dp[i][j]=solve(i-1,j-1,s1,s2,dp);\\n return dp[i][j]=min(int(s1[i])+solve(i-1,j,s1,s2,dp),int(s2[j])+solve(i,j-1,s1,s2,dp));\\n    \\n }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.size(), m=s2.size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n\\n        return solve(n-1,m-1,s1,s2,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,string &s1,string &s2,vector<vector<int>> &dp)\\n    {\\n        if(i<0)\\n        {\\n            int sum=0;\\n            for(int k=0; k<=j; k++) \\n                sum+=int(s2[k]);\\n            return sum;\\n        }\\n        if(j<0)\\n        {\\n            int sum=0;\\n            for(int k=0; k<=i; k++) \\n                sum+=int(s1[k]);\\n            return sum;\\n        }\\n        if(dp[i][j]!=-1) \\n            return dp[i][j];\\n\\n        if(s1[i]==s2[j])\\n            return dp[i][j]=solve(i-1,j-1,s1,s2,dp);\\n return dp[i][j]=min(int(s1[i])+solve(i-1,j,s1,s2,dp),int(s2[j])+solve(i,j-1,s1,s2,dp));\\n    \\n }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.size(), m=s2.size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n\\n        return solve(n-1,m-1,s1,s2,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843472,
                "title": "c-super-easy-clean-code-2d-dp-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int n,m;\\n\\n    int solver(int i, int j, string& s1, string& s2, int dp[][1001]){\\n\\n        if(i == n && j == m) return 0;\\n\\n        if(i == n){\\n            int cost = 0;\\n            while(j<m) cost += s2[j++];\\n            return cost;\\n        }\\n\\n        if(j == m){\\n            int cost = 0;\\n            while(i < n) cost += s1[i++];\\n            return cost;\\n        }\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(s1[i] == s2[j]) return dp[i][j] = solver(i+1,j+1,s1,s2,dp);\\n\\n        int deli = s1[i] + solver(i+1,j,s1,s2,dp);\\n        int delj = s2[j] + solver(i,j+1,s1,s2,dp);\\n\\n        return dp[i][j] = min(deli,delj);\\n    }\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        n = s1.size();\\n        m = s2.size();\\n        int dp[1001][1001];\\n        memset(dp,-1,sizeof(dp));\\n        return solver(0,0,s1,s2,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int n,m;\\n\\n    int solver(int i, int j, string& s1, string& s2, int dp[][1001]){\\n\\n        if(i == n && j == m) return 0;\\n\\n        if(i == n){\\n            int cost = 0;\\n            while(j<m) cost += s2[j++];\\n            return cost;\\n        }\\n\\n        if(j == m){\\n            int cost = 0;\\n            while(i < n) cost += s1[i++];\\n            return cost;\\n        }\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(s1[i] == s2[j]) return dp[i][j] = solver(i+1,j+1,s1,s2,dp);\\n\\n        int deli = s1[i] + solver(i+1,j,s1,s2,dp);\\n        int delj = s2[j] + solver(i,j+1,s1,s2,dp);\\n\\n        return dp[i][j] = min(deli,delj);\\n    }\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        n = s1.size();\\n        m = s2.size();\\n        int dp[1001][1001];\\n        memset(dp,-1,sizeof(dp));\\n        return solver(0,0,s1,s2,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843357,
                "title": "python-beats-100",
                "content": "# Intuition\\nFinding the longest common subsequence (LCS) and then deleting the rest is a valid approach to solve this problem, and it can be an optimal solution as well.\\n# Approach\\nIn this implementation, the `longest_common_subsequence` function uses dynamic programming to find the length of the LCS. The main function then calculates the ASCII sums of the characters in both strings, finds the LCS sum, and returns the minimum sum of deleted characters to make the two strings equal.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimumDeleteSum(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: int\\n        \"\"\"\\n      \\n        def longest_common_subsequence(s1, s2):\\n            m, n = len(s1), len(s2)\\n            dp = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n            for i in range(1, m + 1):\\n                for j in range(1, n + 1):\\n                    if s1[i - 1] == s2[j - 1]:\\n                        dp[i][j] = dp[i - 1][j - 1] + ord(s1[i - 1])\\n                    else:\\n                        dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\\n\\n            return dp[m][n]\\n\\n        # Calculate the ASCII sum of characters in s1 and s2\\n        sum_s1 = sum(ord(c) for c in s1)\\n        sum_s2 = sum(ord(c) for c in s2)\\n\\n        # Find the LCS sum\\n        lcs_sum = longest_common_subsequence(s1, s2)\\n\\n        # Calculate the minimum sum of deleted characters\\n        return sum_s1 + sum_s2 - 2 * lcs_sum\\n\\n\\n\\n\\n```\\n# **PLEASE DO UPVOTE!!!\\uD83E\\uDD79**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumDeleteSum(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: int\\n        \"\"\"\\n      \\n        def longest_common_subsequence(s1, s2):\\n            m, n = len(s1), len(s2)\\n            dp = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n            for i in range(1, m + 1):\\n                for j in range(1, n + 1):\\n                    if s1[i - 1] == s2[j - 1]:\\n                        dp[i][j] = dp[i - 1][j - 1] + ord(s1[i - 1])\\n                    else:\\n                        dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\\n\\n            return dp[m][n]\\n\\n        # Calculate the ASCII sum of characters in s1 and s2\\n        sum_s1 = sum(ord(c) for c in s1)\\n        sum_s2 = sum(ord(c) for c in s2)\\n\\n        # Find the LCS sum\\n        lcs_sum = longest_common_subsequence(s1, s2)\\n\\n        # Calculate the minimum sum of deleted characters\\n        return sum_s1 + sum_s2 - 2 * lcs_sum\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843165,
                "title": "easy-to-understand-recursion-memoization-tabulation-space-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple LCS problem, where we have to sum up the unwanted ASCII.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the letters of both the strings match, move forward ignoring both of them, but if not add the minimum of both the possibilities:\\n1. ith letter of s1 + recursion(i+1,j,s1,s2)\\n2. jth letter of s2 + recursion(i,j+1,s1,s2)\\n\\nRemember, if one of the string end first, so the remaining letters in the other string are extra and should be added to the answer, hence accumulate() is used.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*m)\\nwhere, n=size of s1 &\\nm=size of s2\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\n//Recursion-TLE\\nclass Solution {\\npublic:\\n    int solve(int i,int j,string s1,string s2){\\n        if(i<0 && j<0)      return 0;\\n        if(i<0)     return accumulate(s2.begin(),s2.begin()+j+1,0);\\n        if(j<0)     return accumulate(s1.begin(),s1.begin()+i+1,0);\\n        int ans=0;\\n        if(i>=0 && j>=0 && s1[i]==s2[j])    ans=solve(i-1,j-1,s1,s2);\\n        else    ans+=min(s1[i]+solve(i-1,j,s1,s2),s2[j]+solve(i,j-1,s1,s2));\\n        return ans;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n        int sz1=s1.size(),sz2=s2.size();\\n        return solve(sz1-1,sz2-1,s1,s2);\\n    }\\n};\\n```\\n\\n```\\n//Memoization- MLE\\nclass Solution {\\npublic:\\n    int mem(int i,int j,string s1,string s2,vector<vector<int>> &dp){\\n        if(i<0 && j<0)      return 0;\\n        if(i<0)     return accumulate(s2.begin(),s2.begin()+j+1,0);\\n        if(j<0)     return accumulate(s1.begin(),s1.begin()+i+1,0);\\n        if(dp[i][j]!=-1)    return dp[i][j];\\n        int ans=0;\\n        if(i>=0 && j>=0 && s1[i]==s2[j])    ans=mem(i-1,j-1,s1,s2,dp);\\n        else    ans+=min(s1[i]+mem(i-1,j,s1,s2,dp),s2[j]+mem(i,j-1,s1,s2,dp));\\n        return dp[i][j]=ans;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n        int sz1=s1.size(),sz2=s2.size();\\n        vector<vector<int>>dp(sz1,vector<int>(sz2,-1));\\n        return mem(sz1-1,sz2-1,s1,s2,dp);\\n    }\\n};\\n```\\n\\n```\\n//Tabulation-Accepted\\nclass Solution {\\npublic:\\n    int tab(int sz1,int sz2,string s1,string s2){\\n        vector<vector<int>>dp(sz1+1,vector<int>(sz2+1,0));\\n        for(int i=0;i<=sz1;i++){\\n            for(int j=0;j<=sz2;j++){\\n                if(i==0 && j==0)    dp[i][j]=0;\\n                else if(i==0)    dp[i][j]=accumulate(s2.begin(),s2.begin()+j,0);\\n                else if(j==0)    dp[i][j]=accumulate(s1.begin(),s1.begin()+i,0);\\n                else{\\n                    if(s1[i-1]==s2[j-1])    dp[i][j]=dp[i-1][j-1];\\n                    else    dp[i][j]+=min(s1[i-1]+dp[i-1][j],s2[j-1]+dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return dp[sz1][sz2];\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n        int sz1=s1.size(),sz2=s2.size();\\n        return tab(sz1,sz2,s1,s2);\\n    }\\n};\\n```\\n\\n```\\n//Space-Optimization -Accepted\\nclass Solution {\\npublic:\\n    int space_optimal(int sz1,int sz2,string s1,string s2){\\n        vector<int>prev(sz2+1,0);\\n        for(int i=0;i<=sz1;i++){\\n            vector<int>curr(sz2+1,0);\\n            for(int j=0;j<=sz2;j++){\\n                if(i==0 && j==0)    curr[j]=0;\\n                else if(i==0)    curr[j]=accumulate(s2.begin(),s2.begin()+j,0);\\n                else if(j==0)    curr[j]=accumulate(s1.begin(),s1.begin()+i,0);\\n                else{\\n                    if(s1[i-1]==s2[j-1])    curr[j]=prev[j-1];\\n                    else    curr[j]+=min(s1[i-1]+prev[j],s2[j-1]+curr[j-1]);\\n                }\\n            }\\n            prev=curr;\\n        }\\n        return prev[sz2];\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n        int sz1=s1.size(),sz2=s2.size();\\n        return space_optimal(sz1,sz2,s1,s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//Recursion-TLE\\nclass Solution {\\npublic:\\n    int solve(int i,int j,string s1,string s2){\\n        if(i<0 && j<0)      return 0;\\n        if(i<0)     return accumulate(s2.begin(),s2.begin()+j+1,0);\\n        if(j<0)     return accumulate(s1.begin(),s1.begin()+i+1,0);\\n        int ans=0;\\n        if(i>=0 && j>=0 && s1[i]==s2[j])    ans=solve(i-1,j-1,s1,s2);\\n        else    ans+=min(s1[i]+solve(i-1,j,s1,s2),s2[j]+solve(i,j-1,s1,s2));\\n        return ans;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n        int sz1=s1.size(),sz2=s2.size();\\n        return solve(sz1-1,sz2-1,s1,s2);\\n    }\\n};\\n```\n```\\n//Memoization- MLE\\nclass Solution {\\npublic:\\n    int mem(int i,int j,string s1,string s2,vector<vector<int>> &dp){\\n        if(i<0 && j<0)      return 0;\\n        if(i<0)     return accumulate(s2.begin(),s2.begin()+j+1,0);\\n        if(j<0)     return accumulate(s1.begin(),s1.begin()+i+1,0);\\n        if(dp[i][j]!=-1)    return dp[i][j];\\n        int ans=0;\\n        if(i>=0 && j>=0 && s1[i]==s2[j])    ans=mem(i-1,j-1,s1,s2,dp);\\n        else    ans+=min(s1[i]+mem(i-1,j,s1,s2,dp),s2[j]+mem(i,j-1,s1,s2,dp));\\n        return dp[i][j]=ans;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n        int sz1=s1.size(),sz2=s2.size();\\n        vector<vector<int>>dp(sz1,vector<int>(sz2,-1));\\n        return mem(sz1-1,sz2-1,s1,s2,dp);\\n    }\\n};\\n```\n```\\n//Tabulation-Accepted\\nclass Solution {\\npublic:\\n    int tab(int sz1,int sz2,string s1,string s2){\\n        vector<vector<int>>dp(sz1+1,vector<int>(sz2+1,0));\\n        for(int i=0;i<=sz1;i++){\\n            for(int j=0;j<=sz2;j++){\\n                if(i==0 && j==0)    dp[i][j]=0;\\n                else if(i==0)    dp[i][j]=accumulate(s2.begin(),s2.begin()+j,0);\\n                else if(j==0)    dp[i][j]=accumulate(s1.begin(),s1.begin()+i,0);\\n                else{\\n                    if(s1[i-1]==s2[j-1])    dp[i][j]=dp[i-1][j-1];\\n                    else    dp[i][j]+=min(s1[i-1]+dp[i-1][j],s2[j-1]+dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return dp[sz1][sz2];\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n        int sz1=s1.size(),sz2=s2.size();\\n        return tab(sz1,sz2,s1,s2);\\n    }\\n};\\n```\n```\\n//Space-Optimization -Accepted\\nclass Solution {\\npublic:\\n    int space_optimal(int sz1,int sz2,string s1,string s2){\\n        vector<int>prev(sz2+1,0);\\n        for(int i=0;i<=sz1;i++){\\n            vector<int>curr(sz2+1,0);\\n            for(int j=0;j<=sz2;j++){\\n                if(i==0 && j==0)    curr[j]=0;\\n                else if(i==0)    curr[j]=accumulate(s2.begin(),s2.begin()+j,0);\\n                else if(j==0)    curr[j]=accumulate(s1.begin(),s1.begin()+i,0);\\n                else{\\n                    if(s1[i-1]==s2[j-1])    curr[j]=prev[j-1];\\n                    else    curr[j]+=min(s1[i-1]+prev[j],s2[j-1]+curr[j-1]);\\n                }\\n            }\\n            prev=curr;\\n        }\\n        return prev[sz2];\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n        int sz1=s1.size(),sz2=s2.size();\\n        return space_optimal(sz1,sz2,s1,s2);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3843004,
                "title": "golang-dp-topdown-and-bottomup-approach",
                "content": "# Code\\n```\\n/* DP - TopDown Approach */\\n\\nfunc minimumDeleteSum(s1 string, s2 string) int {\\n    cache := make(map[string]int)\\n    return findMin(0, 0, s1, s2, cache)\\n}\\n\\nfunc findMin(i, j int, s1, s2 string, cache map[string]int) int {\\n    if i >= len(s1) && j >= len(s2) {\\n        return 0\\n    }\\n\\n    key := strconv.Itoa(i) + \"-\" + strconv.Itoa(j)\\n    if value, ok := cache[key]; ok {\\n        return value\\n    }\\n\\n    res := 0\\n    if i == len(s1) {\\n         res = int(s2[j]) + findMin(i, j+1, s1, s2, cache)\\n    } else if j == len(s2) {\\n        res = int(s1[i]) + findMin(i+1, j, s1, s2, cache)\\n    } else if s1[i] == s2[j] {\\n        res = findMin(i+1, j+1, s1, s2, cache)\\n    } else {\\n        res = min(int(s1[i] + s2[j]) + findMin(i+1, j+1, s1, s2, cache), \\n        min(int(s2[j]) + findMin(i, j+1, s1, s2, cache), int(s1[i]) + findMin(i+1, j, s1, s2, cache)))\\n    }\\n    cache[key] = res\\n    return res\\n}\\n\\n/* DP - BottomUp Approach */\\n\\nfunc minimumDeleteSum(s1 string, s2 string) int {\\n    m := len(s1)\\n    n := len(s2)\\n    dp := make([][]int, m+1)\\n    for r := 0; r <= m; r++ {\\n        dp[r] = make([]int, n+1)\\n    }\\n\\n    for r := 1; r <= m; r++ {\\n        dp[r][0] = dp[r-1][0] + int(s1[r-1])\\n    }\\n\\n    for c := 1; c <= n; c++ {\\n        dp[0][c] = dp[0][c-1] + int(s2[c-1])\\n    }\\n\\n    for r := 1; r <= m; r++ {\\n        for c:= 1; c <= n; c++ {\\n            if s1[r-1] == s2[c-1] {\\n                dp[r][c] = dp[r-1][c-1]\\n            } else {\\n                dp[r][c] = min(int(s1[r-1] + s2[c-1]) + dp[r-1][c-1], min(int(s1[r-1]) + dp[r-1][c], int(s2[c-1]) + dp[r][c-1]))\\n            }\\n        }\\n    }\\n\\n    return dp[m][n]\\n}\\n\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/* DP - TopDown Approach */\\n\\nfunc minimumDeleteSum(s1 string, s2 string) int {\\n    cache := make(map[string]int)\\n    return findMin(0, 0, s1, s2, cache)\\n}\\n\\nfunc findMin(i, j int, s1, s2 string, cache map[string]int) int {\\n    if i >= len(s1) && j >= len(s2) {\\n        return 0\\n    }\\n\\n    key := strconv.Itoa(i) + \"-\" + strconv.Itoa(j)\\n    if value, ok := cache[key]; ok {\\n        return value\\n    }\\n\\n    res := 0\\n    if i == len(s1) {\\n         res = int(s2[j]) + findMin(i, j+1, s1, s2, cache)\\n    } else if j == len(s2) {\\n        res = int(s1[i]) + findMin(i+1, j, s1, s2, cache)\\n    } else if s1[i] == s2[j] {\\n        res = findMin(i+1, j+1, s1, s2, cache)\\n    } else {\\n        res = min(int(s1[i] + s2[j]) + findMin(i+1, j+1, s1, s2, cache), \\n        min(int(s2[j]) + findMin(i, j+1, s1, s2, cache), int(s1[i]) + findMin(i+1, j, s1, s2, cache)))\\n    }\\n    cache[key] = res\\n    return res\\n}\\n\\n/* DP - BottomUp Approach */\\n\\nfunc minimumDeleteSum(s1 string, s2 string) int {\\n    m := len(s1)\\n    n := len(s2)\\n    dp := make([][]int, m+1)\\n    for r := 0; r <= m; r++ {\\n        dp[r] = make([]int, n+1)\\n    }\\n\\n    for r := 1; r <= m; r++ {\\n        dp[r][0] = dp[r-1][0] + int(s1[r-1])\\n    }\\n\\n    for c := 1; c <= n; c++ {\\n        dp[0][c] = dp[0][c-1] + int(s2[c-1])\\n    }\\n\\n    for r := 1; r <= m; r++ {\\n        for c:= 1; c <= n; c++ {\\n            if s1[r-1] == s2[c-1] {\\n                dp[r][c] = dp[r-1][c-1]\\n            } else {\\n                dp[r][c] = min(int(s1[r-1] + s2[c-1]) + dp[r-1][c-1], min(int(s1[r-1]) + dp[r-1][c], int(s2[c-1]) + dp[r][c-1]))\\n            }\\n        }\\n    }\\n\\n    return dp[m][n]\\n}\\n\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3842772,
                "title": "daily-challenge-c-easy-tabulation-approach-longest-increasing-subsequence-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n1*n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n1*n2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    \\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.length();\\n        int m=s2.length();\\n        dp.resize(n+1,vector<int>(m+1,0));\\n        for(int i=1;i<=m;i++){\\n            dp[0][i]=dp[0][i-1]+s2[i-1];\\n        }\\n        for(int i=1;i<=n;i++){\\n            dp[i][0]=dp[i-1][0]+s1[i-1];\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s1[i-1]==s2[j-1]){\\n                    dp[i][j]=dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j]=min(s1[i-1]+dp[i-1][j],s2[j-1]+dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    \\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.length();\\n        int m=s2.length();\\n        dp.resize(n+1,vector<int>(m+1,0));\\n        for(int i=1;i<=m;i++){\\n            dp[0][i]=dp[0][i-1]+s2[i-1];\\n        }\\n        for(int i=1;i<=n;i++){\\n            dp[i][0]=dp[i-1][0]+s1[i-1];\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s1[i-1]==s2[j-1]){\\n                    dp[i][j]=dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j]=min(s1[i-1]+dp[i-1][j],s2[j-1]+dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842731,
                "title": "c-easy-and-clean-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int n,int m,string &s1,string &s2,vector<vector<int>> &dp){\\n        if(i>=n && j>=m) return 0;\\n        if(i==n){\\n            int sum=0;\\n            while(j<m){\\n                sum+=s2[j];\\n                j++;\\n            }\\n            return sum;\\n        }\\n        if(j==m){\\n            int sum=0;\\n            while(i<n){\\n                sum+=s1[i];\\n                i++;\\n            }\\n            return sum;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(s1[i]==s2[j]) dp[i][j]= 0 + solve(i+1,j+1,n,m,s1,s2,dp);\\n        else dp[i][j]= min(s1[i]+solve(i+1,j,n,m,s1,s2,dp),s2[j]+solve(i,j+1,n,m,s1,s2,dp));\\n        return dp[i][j];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.size(),m=s2.size();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        return solve(0,0,n,m,s1,s2,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int n,int m,string &s1,string &s2,vector<vector<int>> &dp){\\n        if(i>=n && j>=m) return 0;\\n        if(i==n){\\n            int sum=0;\\n            while(j<m){\\n                sum+=s2[j];\\n                j++;\\n            }\\n            return sum;\\n        }\\n        if(j==m){\\n            int sum=0;\\n            while(i<n){\\n                sum+=s1[i];\\n                i++;\\n            }\\n            return sum;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(s1[i]==s2[j]) dp[i][j]= 0 + solve(i+1,j+1,n,m,s1,s2,dp);\\n        else dp[i][j]= min(s1[i]+solve(i+1,j,n,m,s1,s2,dp),s2[j]+solve(i,j+1,n,m,s1,s2,dp));\\n        return dp[i][j];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.size(),m=s2.size();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        return solve(0,0,n,m,s1,s2,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842681,
                "title": "simplest-solution-with-full-explanation-memo-tabu",
                "content": "# Intuition\\nWell this problem is very much identical to a **LCS** problem, where we do string matching to get our answer.\\n# Tree\\n                                \\n![WhatsApp Image 2023-07-31 at 16.26.06.jpg](https://assets.leetcode.com/users/images/e805ed11-3a01-444a-87fe-0f22df5ca94d_1690801086.3455226.jpeg)\\n\\n\\n# Approach\\nLets take an example to fully understand the solution. Suppose we have **s1=abc**  and **s2= ac**. we take an **i** ponter and a **j** pointer at the end of each string and we explore all of our options. lets see what options do we have.\\n\\n***if a character matches then we dont need to delete it, so we will just move our pointers one step forward.***\\n\\n***if a character does not match then choices we have. we can either say\\nhey move i forward and let the j pointer stay as it is or move j pointer one step ahead and let i pointer stay where it is.***\\n\\nsince we have to add our ascii value so when we move **i** pointer we take ascii value of **s[i]** because we are assuming that we are deleting **s1[i]**, since it doesnot match. same goes for **s2[j]**.\\n\\nlastly we are taking ***minimum*** of both our moves to get the minimum ascii value to be deleted.\\n\\n***i have discussed how i got the base case in the image above.\\nif you still struggling to understand feel free to comment down below***.\\n\\n# PLZ UPVOTE (\\u25CF\\'\\u25E1\\'\\u25CF)\\n\\n# Complexity\\n- Time complexity:\\n    $O(n^2)$\\n\\n- Space complexity:\\n    $O(n^2)$\\n\\n# Code\\n- MEMOIZATION\\n```\\nclass Solution:\\n    def f(self,i,j,s1,s2,dp):\\n        # BASE CASE\\n        if j<0:\\n            ans=0\\n            for _ in range(i,-1,-1):\\n                 ans+=ord(s1[_])\\n            return ans\\n        if i<0:\\n            ans=0\\n            for _ in range(j,-1,-1):\\n                ans+=ord(s2[_])\\n            return ans\\n        if i<0 and j<0:\\n            return 0\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n\\n        # RECURENCE RELATION\\n        if s1[i]==s2[j]:\\n            dp[i][j]= self.f(i-1,j-1,s1,s2,dp)\\n        else:\\n            dp[i][j]= min(ord(s1[i])+self.f(i-1,j,s1,s2,dp),ord(s2[j])+self.f(i,j-1,s1,s2,dp))\\n        return dp[i][j]\\n\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        n=len(s1)\\n        m=len(s2)\\n        dp=[[-1]*(m+1) for _ in range(n+1)]\\n        return self.f(n-1,m-1,s1,s2,dp) # UPVOTE MY SOLUTION PLZ\\n\\n```\\n- TABULATION :\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        n=len(s1)\\n        m=len(s2)\\n        dp=[[-1]*(m+1) for _ in range(n+1)]\\n        dp[0][0]=0\\n        sum1=0\\n        for i in range(1,n+1):\\n            dp[i][0]=sum(map(ord, s1[0:i]))\\n        \\n        for j in range(1,m+1):\\n            dp[0][j]=sum(map(ord, s2[0:j]))\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if s1[i-1]==s2[j-1]:\\n                    dp[i][j]= dp[i-1][j-1]\\n                    else:\\n                    dp[i][j]= min(ord(s1[i-1])+dp[i-1][j],ord(s2[j-1])+dp[i][j-1])\\n        return dp[n][m]  # UPVOTE MY SOLUTION PLZ\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def f(self,i,j,s1,s2,dp):\\n        # BASE CASE\\n        if j<0:\\n            ans=0\\n            for _ in range(i,-1,-1):\\n                 ans+=ord(s1[_])\\n            return ans\\n        if i<0:\\n            ans=0\\n            for _ in range(j,-1,-1):\\n                ans+=ord(s2[_])\\n            return ans\\n        if i<0 and j<0:\\n            return 0\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n\\n        # RECURENCE RELATION\\n        if s1[i]==s2[j]:\\n            dp[i][j]= self.f(i-1,j-1,s1,s2,dp)\\n        else:\\n            dp[i][j]= min(ord(s1[i])+self.f(i-1,j,s1,s2,dp),ord(s2[j])+self.f(i,j-1,s1,s2,dp))\\n        return dp[i][j]\\n\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        n=len(s1)\\n        m=len(s2)\\n        dp=[[-1]*(m+1) for _ in range(n+1)]\\n        return self.f(n-1,m-1,s1,s2,dp) # UPVOTE MY SOLUTION PLZ\\n\\n```\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        n=len(s1)\\n        m=len(s2)\\n        dp=[[-1]*(m+1) for _ in range(n+1)]\\n        dp[0][0]=0\\n        sum1=0\\n        for i in range(1,n+1):\\n            dp[i][0]=sum(map(ord, s1[0:i]))\\n        \\n        for j in range(1,m+1):\\n            dp[0][j]=sum(map(ord, s2[0:j]))\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if s1[i-1]==s2[j-1]:\\n                    dp[i][j]= dp[i-1][j-1]\\n                    else:\\n                    dp[i][j]= min(ord(s1[i-1])+dp[i-1][j],ord(s2[j-1])+dp[i][j-1])\\n        return dp[n][m]  # UPVOTE MY SOLUTION PLZ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842668,
                "title": "very-easy-java-code-memo-to-tabulation",
                "content": "```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int[][] dp = new int[s1.length()][s2.length()];\\n        return findMinimum(s1.toCharArray(), s2.toCharArray(), dp, s1.length() - 1, s2.length() - 1);\\n    }\\n\\n    public int findMinimum(char[] s1, char[] s2, int[][] dp, int i, int j) {\\n        if (i == -1) return calculateSum(s2, j);\\n        if (j == -1) return calculateSum(s1, i);\\n        if (dp[i][j] != 0) return dp[i][j];\\n        int deleteSecond = findMinimum(s1, s2, dp, i, j - 1) + s2[j];\\n        int deleteFirst = findMinimum(s1, s2, dp, i - 1, j) + s1[i];\\n        if (s1[i] == s2[j]) {\\n            int deleteNone = findMinimum(s1, s2, dp, i - 1, j - 1);\\n            return dp[i][j] =deleteNone;\\n        }\\n        return dp[i][j] = Math.min(deleteFirst, deleteSecond);\\n    }\\n\\n    public int calculateSum(char[] arr, int index) {\\n        int sum = 0;\\n        for (int j = 0; j <= index; j++) sum += arr[j];\\n        return sum;\\n    }\\n}\\n\\n\\n\\n//tabulation\\n\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n        for (int i = 0; i <= s1.length(); i++) {\\n            for (int j = 0; j <= s2.length(); j++) {\\n                if (i == 0) dp[i][j] = calculateSum(s2, j);\\n                if (j == 0) dp[i][j] = calculateSum(s1, i);\\n                else if (i != 0) {\\n                    int deleteSecond = dp[i][j - 1] + s2.charAt(j - 1);\\n                    int deleteFirst = dp[i - 1][j] + s1.charAt(i - 1);\\n                    if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n                        int deleteNone = dp[i - 1][j - 1];\\n                        dp[i][j] =deleteNone;\\n                    } else {\\n                        dp[i][j] = Math.min(deleteFirst, deleteSecond);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[s1.length()][s2.length()];\\n    }\\n\\n    public int calculateSum(String arr, int index) {\\n        int sum = 0;\\n        for (int j = 0; j < index; j++) sum += arr.charAt(j);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int[][] dp = new int[s1.length()][s2.length()];\\n        return findMinimum(s1.toCharArray(), s2.toCharArray(), dp, s1.length() - 1, s2.length() - 1);\\n    }\\n\\n    public int findMinimum(char[] s1, char[] s2, int[][] dp, int i, int j) {\\n        if (i == -1) return calculateSum(s2, j);\\n        if (j == -1) return calculateSum(s1, i);\\n        if (dp[i][j] != 0) return dp[i][j];\\n        int deleteSecond = findMinimum(s1, s2, dp, i, j - 1) + s2[j];\\n        int deleteFirst = findMinimum(s1, s2, dp, i - 1, j) + s1[i];\\n        if (s1[i] == s2[j]) {\\n            int deleteNone = findMinimum(s1, s2, dp, i - 1, j - 1);\\n            return dp[i][j] =deleteNone;\\n        }\\n        return dp[i][j] = Math.min(deleteFirst, deleteSecond);\\n    }\\n\\n    public int calculateSum(char[] arr, int index) {\\n        int sum = 0;\\n        for (int j = 0; j <= index; j++) sum += arr[j];\\n        return sum;\\n    }\\n}\\n\\n\\n\\n//tabulation\\n\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n        for (int i = 0; i <= s1.length(); i++) {\\n            for (int j = 0; j <= s2.length(); j++) {\\n                if (i == 0) dp[i][j] = calculateSum(s2, j);\\n                if (j == 0) dp[i][j] = calculateSum(s1, i);\\n                else if (i != 0) {\\n                    int deleteSecond = dp[i][j - 1] + s2.charAt(j - 1);\\n                    int deleteFirst = dp[i - 1][j] + s1.charAt(i - 1);\\n                    if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n                        int deleteNone = dp[i - 1][j - 1];\\n                        dp[i][j] =deleteNone;\\n                    } else {\\n                        dp[i][j] = Math.min(deleteFirst, deleteSecond);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[s1.length()][s2.length()];\\n    }\\n\\n    public int calculateSum(String arr, int index) {\\n        int sum = 0;\\n        for (int j = 0; j < index; j++) sum += arr.charAt(j);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842650,
                "title": "tool-kit-to-solve-dp-problem",
                "content": "\\n# Step 1 : Define State \\n**  dp[i][j] = minimum Ascii Sum to make s1[0:i] and s2[0:j] equal **\\n\\n# Step 2 : Transition\\n 1.if s[i]==s[j] do nothing dp[i][j] = dp[i+1][j+1], move both pointer \\n    \\n2.else  dp[i][j] = min(ascii(s[i])+dp[i+1][j], ascii(s[j]) +dp[i][j+1])\\n *Either Delete from S1 or deleted from S2 and choose minimum among them*\\n \\n   # Step 2 : Base Case \\n1. if (i==n) so sum of all remaining ascii value in [j:m] as we need to delete all  remaning character from s2 \\n2. if(j==m)so sum  of all remaining ascii value in [i:n] as we need to delete all remaning character from s1\\n3. if( i==n && j ==m) so both strings matches so ascii sum would be 0 \\n\\n   # Step 4 : Final Subproblem\\n     dp[0][0]  will be the Final SubProblem so we will return dp[0][0]*\\n   \\n  # Step 5 : Time & Space Complexity \\n   **  Time Complexity - >  Number of States  X Transition Time -> n*m*1\\n\\t Space Complexity - > Number of States -> n*m**\\n   \\n \\n```\\nclass Solution {\\nprivate : \\n    int miniAsciiSum(string &s1 ,string &s2,int i ,int j,vector<vector<int>>&dp ){\\n      \\n\\t  if(i==s1.size() && j==s2.size())return 0 ;\\n\\t  \\n        if(i == s1.size()){\\n            int rem = 0 ;\\n            for(int k = j ; k < s2.size();k++)rem += s2[k];\\n            return rem;\\n        }\\n\\t\\t\\n         if(j == s2.size()){\\n            int rem = 0 ;\\n            for(int k = i ; k < s1.size();k++)rem += s1[k];\\n             return rem;\\n        }\\n        if(dp[i][j]!=-1)return dp[i][j];\\n\\t\\t\\n        int miniSum = 1e9;\\n\\t\\t\\n        if(s1[i]==s2[j])return miniAsciiSum(s1,s2,i+1,j+1,dp);\\n        \\n        else {\\n\\t\\t\\t\\tminiSum = min((int)s1[i] +miniAsciiSum(s1,s2,i+1,j,dp),  \\n\\t\\t\\t\\t(int)s2[j]+miniAsciiSum(s1,s2,i,j+1,dp));\\n        }   \\n        return dp[i][j] =miniSum;\\n        \\n    }\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        vector<vector<int>>dp(s1.size()+1,vector<int>(s2.size()+1,-1));\\n        return miniAsciiSum(s1,s2,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate : \\n    int miniAsciiSum(string &s1 ,string &s2,int i ,int j,vector<vector<int>>&dp ){\\n      \\n\\t  if(i==s1.size() && j==s2.size())return 0 ;\\n\\t  \\n        if(i == s1.size()){\\n            int rem = 0 ;\\n            for(int k = j ; k < s2.size();k++)rem += s2[k];\\n            return rem;\\n        }\\n\\t\\t\\n         if(j == s2.size()){\\n            int rem = 0 ;\\n            for(int k = i ; k < s1.size();k++)rem += s1[k];\\n             return rem;\\n        }\\n        if(dp[i][j]!=-1)return dp[i][j];\\n\\t\\t\\n        int miniSum = 1e9;\\n\\t\\t\\n        if(s1[i]==s2[j])return miniAsciiSum(s1,s2,i+1,j+1,dp);\\n        \\n        else {\\n\\t\\t\\t\\tminiSum = min((int)s1[i] +miniAsciiSum(s1,s2,i+1,j,dp),  \\n\\t\\t\\t\\t(int)s2[j]+miniAsciiSum(s1,s2,i,j+1,dp));\\n        }   \\n        return dp[i][j] =miniSum;\\n        \\n    }\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        vector<vector<int>>dp(s1.size()+1,vector<int>(s2.size()+1,-1));\\n        return miniAsciiSum(s1,s2,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842577,
                "title": "python-easy-solutions-time-memory-efficient",
                "content": "# Intuition\\nThe problem is asking us to find the lowest ASCII sum of deleted characters required to make two strings equal. To solve this, we can use dynamic programming to find the longest common subsequence (LCS) between the two strings. The LCS represents the common characters between the two strings, and the characters that are not part of the LCS need to be deleted to make the strings equal.\\n\\n# Approach\\nThe approach involves using dynamic programming to calculate the LCS lengths between the two strings s1 and s2. We use a 1D DP array to store the LCS lengths to optimize space complexity. The DP array will have one row for each character in s2.\\n\\nWe initialize the DP array with zeros and then iterate through each character in s1 and s2. If the characters are equal, we update the DP array by adding the ASCII value of the current character to the previous diagonal element (representing the previous LCS length). Otherwise, we update the DP array with the maximum value between the current row\\'s previous element and the previous column\\'s element (representing the maximum LCS length so far).\\n\\nAfter filling up the DP array, we calculate the sum of ASCII values of all characters in both s1 and s2. Finally, we subtract twice the LCS length (found in the last element of the DP array) from the sum of ASCII values to get the lowest ASCII sum of deleted characters required to make the strings equal.\\n\\n# Complexity\\n- Time complexity:\\nO(m * n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        \\n        # Create a 1D DP array to store the LCS lengths\\n        dp = [0] * (n + 1)\\n        \\n        # Calculate the LCS lengths\\n        for i in range(1, m + 1):\\n            prev = dp[0]  # store the value of the previous row\\'s first element\\n            for j in range(1, n + 1):\\n                temp = dp[j]  # store the current value of dp[j]\\n                if s1[i - 1] == s2[j - 1]:\\n                    dp[j] = prev + ord(s1[i - 1])\\n                else:\\n                    dp[j] = max(dp[j], dp[j - 1])\\n                prev = temp  # update prev to store the value of dp[j]\\n        \\n        # Calculate the sum of ASCII values of characters not part of LCS\\n        sum_ascii = 0\\n        for c in s1:\\n            sum_ascii += ord(c)\\n        for c in s2:\\n            sum_ascii += ord(c)\\n        \\n        return sum_ascii - 2 * dp[n]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        \\n        # Create a 1D DP array to store the LCS lengths\\n        dp = [0] * (n + 1)\\n        \\n        # Calculate the LCS lengths\\n        for i in range(1, m + 1):\\n            prev = dp[0]  # store the value of the previous row\\'s first element\\n            for j in range(1, n + 1):\\n                temp = dp[j]  # store the current value of dp[j]\\n                if s1[i - 1] == s2[j - 1]:\\n                    dp[j] = prev + ord(s1[i - 1])\\n                else:\\n                    dp[j] = max(dp[j], dp[j - 1])\\n                prev = temp  # update prev to store the value of dp[j]\\n        \\n        # Calculate the sum of ASCII values of characters not part of LCS\\n        sum_ascii = 0\\n        for c in s1:\\n            sum_ascii += ord(c)\\n        for c in s2:\\n            sum_ascii += ord(c)\\n        \\n        return sum_ascii - 2 * dp[n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842536,
                "title": "dp-tabulation-java-best-approach-lcs-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int n = s1.length();\\n        int m = s2.length();\\n        int dp[][]=new int [n+1][m+1];\\n        //base case\\n        dp[0][0]=0;\\n        for(int i=1;i<n+1;i++){//when s2 string is empty \\n            dp[i][0]=dp[i-1][0]+s1.charAt(i-1);\\n        }\\n\\n        for(int i=1;i<m+1;i++){//when s1 string is empty\\n            dp[0][i]=dp[0][i-1]+s2.charAt(i-1);\\n        }\\n        //bottom up approach\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                    dp[i][j]=dp[i-1][j-1];\\n                }else{\\n                    int ans1=s1.charAt(i-1)+ dp[i-1][j];\\n                    int ans2=s2.charAt(j-1)+ dp[i][j-1];\\n                    dp[i][j]=Math.min(ans1,ans2);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int n = s1.length();\\n        int m = s2.length();\\n        int dp[][]=new int [n+1][m+1];\\n        //base case\\n        dp[0][0]=0;\\n        for(int i=1;i<n+1;i++){//when s2 string is empty \\n            dp[i][0]=dp[i-1][0]+s1.charAt(i-1);\\n        }\\n\\n        for(int i=1;i<m+1;i++){//when s1 string is empty\\n            dp[0][i]=dp[0][i-1]+s2.charAt(i-1);\\n        }\\n        //bottom up approach\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                    dp[i][j]=dp[i-1][j-1];\\n                }else{\\n                    int ans1=s1.charAt(i-1)+ dp[i-1][j];\\n                    int ans2=s2.charAt(j-1)+ dp[i][j-1];\\n                    dp[i][j]=Math.min(ans1,ans2);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842526,
                "title": "c-solution-explained-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   /* int helper(string s1, string s2, int i, int j, vector<vector<int>>& memo){\\n        int ASCII = 0;\\n        int n = s1.size();\\n        int m = s2.size();\\n        if(i==n && j==m){\\n            ASCII = 0; // checking if we have traversed both the strings, means no deletion->reaching to the end\\n        }else if(i == n){//here is the case considered when s1 length is less than s2(means s1 is traversed),and now the deletion would be done in s2,further addind ASCII values of deleted ones;\\n            ASCII += helper(s1,s2,i,j+1,memo) + s2[j];\\n        }else if(j ==m){//here is the case considered when s2 length is less than s1(means s2 is traversed),and now the deletion would be done in s2,further addind ASCII values of deleted ones;\\n            ASCII += helper(s1,s2,i+1,j,memo) + s1[i];\\n        }else if(s1[i] == s2[j]){\\n            ASCII += helper(s1,s2,i+1,j+1,memo);// here is the case when both the strings are same , then we move ahead for further checking by doing i+1 and j+1;\\n        }else{\\n            int first = helper(s1,s2,i+1,j,memo) + s1[i];\\n            int second = helper(s1,s2,i,j+1,memo) + s2[j];\\n            ASCII = min(first,second);//taking minimum value as per question;\\n        }\\n        memo[i][j] = ASCII;//storing result in the memo table;\\n        return ASCII;\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n          int n = s1.size();\\n          int m = s2.size();\\n          vector<vector<int>> memo(n + 1, vector<int>(m + 1, -1));//initializing the values with -1 in the memo table; \\n        return helper(s1,s2,0,0,memo); //calling function recursively;\\n        (THIS SOLUTION IS CORRECT BUT NOT OPTIMIZED ONE)*/\\n   //HERE OPTIMIZED SOLUTION USING DP:\\n    int minimumDeleteSum(string s1, string s2) {\\n    int n = s1.size();\\n    int m = s2.size();\\n\\n    // Create a 2D DP table to store the minimum ASCII sum for substrings of s1 and s2.\\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\\n\\n    // Fill the DP table bottom-up.\\n    for (int i = n - 1; i >= 0; --i) {\\n        dp[i][m] = dp[i + 1][m] + s1[i]; // Calculate the ASCII sum for deletions in s1.\\n    }\\n\\n    for (int j = m - 1; j >= 0; --j) {\\n        dp[n][j] = dp[n][j + 1] + s2[j]; // Calculate the ASCII sum for deletions in s2.\\n    }\\n\\n    for (int i = n - 1; i >= 0; --i) {\\n        for (int j = m - 1; j >= 0; --j) {\\n            if (s1[i] == s2[j]) {\\n                dp[i][j] = dp[i + 1][j + 1]; // Characters match, no deletion needed.\\n            } else {\\n                dp[i][j] = min(dp[i + 1][j] + s1[i], dp[i][j + 1] + s2[j]); // Take the minimum of two options: delete from s1 or delete from s2.\\n            }\\n        }\\n    }\\n\\n    return dp[0][0]; // The minimum ASCII sum for deletions in both strings.\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   /* int helper(string s1, string s2, int i, int j, vector<vector<int>>& memo){\\n        int ASCII = 0;\\n        int n = s1.size();\\n        int m = s2.size();\\n        if(i==n && j==m){\\n            ASCII = 0; // checking if we have traversed both the strings, means no deletion->reaching to the end\\n        }else if(i == n){//here is the case considered when s1 length is less than s2(means s1 is traversed),and now the deletion would be done in s2,further addind ASCII values of deleted ones;\\n            ASCII += helper(s1,s2,i,j+1,memo) + s2[j];\\n        }else if(j ==m){//here is the case considered when s2 length is less than s1(means s2 is traversed),and now the deletion would be done in s2,further addind ASCII values of deleted ones;\\n            ASCII += helper(s1,s2,i+1,j,memo) + s1[i];\\n        }else if(s1[i] == s2[j]){\\n            ASCII += helper(s1,s2,i+1,j+1,memo);// here is the case when both the strings are same , then we move ahead for further checking by doing i+1 and j+1;\\n        }else{\\n            int first = helper(s1,s2,i+1,j,memo) + s1[i];\\n            int second = helper(s1,s2,i,j+1,memo) + s2[j];\\n            ASCII = min(first,second);//taking minimum value as per question;\\n        }\\n        memo[i][j] = ASCII;//storing result in the memo table;\\n        return ASCII;\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n          int n = s1.size();\\n          int m = s2.size();\\n          vector<vector<int>> memo(n + 1, vector<int>(m + 1, -1));//initializing the values with -1 in the memo table; \\n        return helper(s1,s2,0,0,memo); //calling function recursively;\\n        (THIS SOLUTION IS CORRECT BUT NOT OPTIMIZED ONE)*/\\n   //HERE OPTIMIZED SOLUTION USING DP:\\n    int minimumDeleteSum(string s1, string s2) {\\n    int n = s1.size();\\n    int m = s2.size();\\n\\n    // Create a 2D DP table to store the minimum ASCII sum for substrings of s1 and s2.\\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\\n\\n    // Fill the DP table bottom-up.\\n    for (int i = n - 1; i >= 0; --i) {\\n        dp[i][m] = dp[i + 1][m] + s1[i]; // Calculate the ASCII sum for deletions in s1.\\n    }\\n\\n    for (int j = m - 1; j >= 0; --j) {\\n        dp[n][j] = dp[n][j + 1] + s2[j]; // Calculate the ASCII sum for deletions in s2.\\n    }\\n\\n    for (int i = n - 1; i >= 0; --i) {\\n        for (int j = m - 1; j >= 0; --j) {\\n            if (s1[i] == s2[j]) {\\n                dp[i][j] = dp[i + 1][j + 1]; // Characters match, no deletion needed.\\n            } else {\\n                dp[i][j] = min(dp[i + 1][j] + s1[i], dp[i][j + 1] + s2[j]); // Take the minimum of two options: delete from s1 or delete from s2.\\n            }\\n        }\\n    }\\n\\n    return dp[0][0]; // The minimum ASCII sum for deletions in both strings.\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842317,
                "title": "recursion-memoization-tabulation",
                "content": "**Up Vote if Helps**![image.png](https://assets.leetcode.com/users/images/23d8443e-ac59-49d5-99f0-9273a2147be2_1687635435.0337658.png)\\n\\n___________________________________________________________\\n\\n# Recursion\\n```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        if(s1.length()==0 && s2.length()==0){\\n            return 0;\\n        }\\n        if(s1.length()==0){\\n            int sum=0;\\n            for(int i=0; i<s2.length() ; i++){\\n                sum+=(int)s2.charAt(i);\\n            }\\n            return sum;\\n        }\\n        if(s2.length()==0){\\n            int sum=0;\\n            for(int i=0; i<s1.length() ; i++){\\n                sum+=(int)s1.charAt(i);\\n            }\\n            return sum;\\n        }\\n        if(s1.equals(s2)){\\n            return 0;\\n        }\\n        if(s1.charAt(0)==s2.charAt(0)){\\n            return minimumDeleteSum(s1.substring(1),s2.substring(1));\\n        }else{\\n           int val1=(int)s1.charAt(0);\\n           int a=val1 + minimumDeleteSum(s1.substring(1),s2);\\n           int val2=(int)s2.charAt(0);\\n           int b=val2 + minimumDeleteSum(s1,s2.substring(1));\\n           return Math.min(a,b);   \\n        }\\n    }\\n}\\n```\\n___________________________________________________________\\n\\n# Memoization\\n```\\nclass Solution {\\n    Integer[][] memo;\\n    public int minimumDeleteSum(String s1, String s2) {\\n          memo=new Integer[s1.length()][s2.length()];\\n          return minimumDeleteSumHelper(s1,s2);\\n    }\\n    public int minimumDeleteSumHelper(String s1, String s2) {\\n        if(s1.length()==0 && s2.length()==0){\\n            return 0;\\n        }\\n        if(s1.length()==0){\\n            int sum=0;\\n            for(int i=0; i<s2.length() ; i++){\\n                sum+=(int)s2.charAt(i);\\n            }\\n            return sum;\\n        }\\n\\n        if(s2.length()==0){\\n            int sum=0;\\n            for(int i=0; i<s1.length() ; i++){\\n                sum+=(int)s1.charAt(i);\\n            }\\n            return sum;\\n        }\\n\\n        if(memo[s1.length()-1][s2.length()-1]!=null){\\n            return memo[s1.length()-1][s2.length()-1];\\n        }\\n\\n        if(s1.equals(s2)){\\n            return 0;\\n        }\\n\\n        if(s1.charAt(0)==s2.charAt(0)){\\n            return memo[s1.length()-1][s2.length()-1] = minimumDeleteSumHelper(s1.substring(1),s2.substring(1));\\n        }else{\\n           int val1=(int)s1.charAt(0);\\n           int a=val1 + minimumDeleteSumHelper(s1.substring(1),s2);\\n           int val2=(int)s2.charAt(0);\\n           int b=val2 + minimumDeleteSumHelper(s1,s2.substring(1));\\n           return memo[s1.length()-1][s2.length()-1] = Math.min(a,b);   \\n        }\\n    }\\n}\\n\\n```\\n___________________________________________________________\\n\\n# Tabulation\\n```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int[][] dp=new int[s1.length()+1][s2.length()+1];\\n        for(int i=0; i<dp.length ; i++){\\n            for(int j=0; j<dp[0].length ; j++){\\n                if(i==0 && j==0){\\n                  dp[i][j]=0;\\n                }else if(i==0){\\n                    dp[i][j]=dp[i][j-1]+(int)(s2.charAt(j-1));\\n                }else if(j==0){\\n                    dp[i][j]=dp[i-1][j]+(int)(s1.charAt(i-1));\\n                }else{\\n                    if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                        dp[i][j]=dp[i-1][j-1];\\n                    }else{\\n                        dp[i][j]=Math.min(s1.charAt(i-1)+dp[i-1][j],s2.charAt(j-1)+dp[i][j-1]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[dp.length-1][dp[0].length-1];\\n    }\\n}\\n```\\n________________________________\\n\\n**Upvote if helps**\\n![image.png](https://assets.leetcode.com/users/images/f18ccf7b-bb7d-4a8e-8622-2f0acbd705cc_1683886081.2272806.png)\\n\\n________________________________",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        if(s1.length()==0 && s2.length()==0){\\n            return 0;\\n        }\\n        if(s1.length()==0){\\n            int sum=0;\\n            for(int i=0; i<s2.length() ; i++){\\n                sum+=(int)s2.charAt(i);\\n            }\\n            return sum;\\n        }\\n        if(s2.length()==0){\\n            int sum=0;\\n            for(int i=0; i<s1.length() ; i++){\\n                sum+=(int)s1.charAt(i);\\n            }\\n            return sum;\\n        }\\n        if(s1.equals(s2)){\\n            return 0;\\n        }\\n        if(s1.charAt(0)==s2.charAt(0)){\\n            return minimumDeleteSum(s1.substring(1),s2.substring(1));\\n        }else{\\n           int val1=(int)s1.charAt(0);\\n           int a=val1 + minimumDeleteSum(s1.substring(1),s2);\\n           int val2=(int)s2.charAt(0);\\n           int b=val2 + minimumDeleteSum(s1,s2.substring(1));\\n           return Math.min(a,b);   \\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Integer[][] memo;\\n    public int minimumDeleteSum(String s1, String s2) {\\n          memo=new Integer[s1.length()][s2.length()];\\n          return minimumDeleteSumHelper(s1,s2);\\n    }\\n    public int minimumDeleteSumHelper(String s1, String s2) {\\n        if(s1.length()==0 && s2.length()==0){\\n            return 0;\\n        }\\n        if(s1.length()==0){\\n            int sum=0;\\n            for(int i=0; i<s2.length() ; i++){\\n                sum+=(int)s2.charAt(i);\\n            }\\n            return sum;\\n        }\\n\\n        if(s2.length()==0){\\n            int sum=0;\\n            for(int i=0; i<s1.length() ; i++){\\n                sum+=(int)s1.charAt(i);\\n            }\\n            return sum;\\n        }\\n\\n        if(memo[s1.length()-1][s2.length()-1]!=null){\\n            return memo[s1.length()-1][s2.length()-1];\\n        }\\n\\n        if(s1.equals(s2)){\\n            return 0;\\n        }\\n\\n        if(s1.charAt(0)==s2.charAt(0)){\\n            return memo[s1.length()-1][s2.length()-1] = minimumDeleteSumHelper(s1.substring(1),s2.substring(1));\\n        }else{\\n           int val1=(int)s1.charAt(0);\\n           int a=val1 + minimumDeleteSumHelper(s1.substring(1),s2);\\n           int val2=(int)s2.charAt(0);\\n           int b=val2 + minimumDeleteSumHelper(s1,s2.substring(1));\\n           return memo[s1.length()-1][s2.length()-1] = Math.min(a,b);   \\n        }\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int[][] dp=new int[s1.length()+1][s2.length()+1];\\n        for(int i=0; i<dp.length ; i++){\\n            for(int j=0; j<dp[0].length ; j++){\\n                if(i==0 && j==0){\\n                  dp[i][j]=0;\\n                }else if(i==0){\\n                    dp[i][j]=dp[i][j-1]+(int)(s2.charAt(j-1));\\n                }else if(j==0){\\n                    dp[i][j]=dp[i-1][j]+(int)(s1.charAt(i-1));\\n                }else{\\n                    if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                        dp[i][j]=dp[i-1][j-1];\\n                    }else{\\n                        dp[i][j]=Math.min(s1.charAt(i-1)+dp[i-1][j],s2.charAt(j-1)+dp[i][j-1]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[dp.length-1][dp[0].length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842300,
                "title": "easy-to-understand-dp",
                "content": "# Intuition\\nThis problem is similar to Edit distance, with minor change that we can only delete characters in this problem.\\n\\n# Approach\\nIf the characters at i and j are same in s1 & s2, then we can just leave them as it is and move forward.\\nIf characters aren\\'t a match then we\\'ll either delete character in s1 or s2 and move index of that particular string.\\n\\n# Complexity\\n- Time complexity:\\nO(M*N)\\n\\n- Space complexity:\\nO(M*N)\\n\\n# Recursive Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        return f(0,0,s1,s2);\\n    }\\n\\n    int f(int i, int j, string &s1, string &s2) {\\n        if(i>=s1.size()) return value(s2,j);\\n        if(j>=s2.size()) return value(s1,i);\\n\\n        if(s1[i]==s2[j]) return f(i+1,j+1,s1,s2);\\n\\n        int cut1 = f(i+1,j,s1,s2) + (s1[i]-\\'a\\') + 97;\\n        int cut2 = f(i,j+1,s1,s2) + (s2[j]-\\'a\\') + 97;\\n\\n        return min(cut1,cut2);\\n    } \\n\\n    int value(string &s, int i) {\\n        int ans = 0;\\n        while(i<s.size()) {\\n            ans += (s[i]-\\'a\\') + 97;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Memoization Code\\n```\\nclass Solution {\\n    int dp[1001][1001];\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,0,s1,s2);\\n    }\\n\\n    int f(int i, int j, string &s1, string &s2) {\\n        if(i>=s1.size()) return value(s2,j);\\n        if(j>=s2.size()) return value(s1,i);\\n\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(s1[i]==s2[j]) return dp[i][j] = f(i+1,j+1,s1,s2);\\n\\n        int cut1 = f(i+1,j,s1,s2) + (s1[i]-\\'a\\') + 97;\\n        int cut2 = f(i,j+1,s1,s2) + (s2[j]-\\'a\\') + 97;\\n\\n        return dp[i][j] = min(cut1,cut2);\\n    } \\n\\n    int value(string &s, int i) {\\n        int ans = 0;\\n        while(i<s.size()) {\\n            ans += (s[i]-\\'a\\') + 97;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        return f(0,0,s1,s2);\\n    }\\n\\n    int f(int i, int j, string &s1, string &s2) {\\n        if(i>=s1.size()) return value(s2,j);\\n        if(j>=s2.size()) return value(s1,i);\\n\\n        if(s1[i]==s2[j]) return f(i+1,j+1,s1,s2);\\n\\n        int cut1 = f(i+1,j,s1,s2) + (s1[i]-\\'a\\') + 97;\\n        int cut2 = f(i,j+1,s1,s2) + (s2[j]-\\'a\\') + 97;\\n\\n        return min(cut1,cut2);\\n    } \\n\\n    int value(string &s, int i) {\\n        int ans = 0;\\n        while(i<s.size()) {\\n            ans += (s[i]-\\'a\\') + 97;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int dp[1001][1001];\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,0,s1,s2);\\n    }\\n\\n    int f(int i, int j, string &s1, string &s2) {\\n        if(i>=s1.size()) return value(s2,j);\\n        if(j>=s2.size()) return value(s1,i);\\n\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(s1[i]==s2[j]) return dp[i][j] = f(i+1,j+1,s1,s2);\\n\\n        int cut1 = f(i+1,j,s1,s2) + (s1[i]-\\'a\\') + 97;\\n        int cut2 = f(i,j+1,s1,s2) + (s2[j]-\\'a\\') + 97;\\n\\n        return dp[i][j] = min(cut1,cut2);\\n    } \\n\\n    int value(string &s, int i) {\\n        int ans = 0;\\n        while(i<s.size()) {\\n            ans += (s[i]-\\'a\\') + 97;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842289,
                "title": "c-soluiton-recursive-iterative-space-optimized-iterative-dp-solution",
                "content": "\\n# Code\\n\\n\\uD83D\\uDD25 Recursive Memoized solution\\n```\\nclass Solution {\\npublic:\\n    int lcsAsciiSum(string &s1,string& s2,int i,int j,vector<vector<int>>&dp){\\n        if(i<0 || j<0) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int take = 0;\\n        if(s1[i] == s2[j]){\\n            take = s1[i] + lcsAsciiSum(s1,s2,i-1,j-1,dp);\\n        }\\n\\n        int notTake = max(lcsAsciiSum(s1,s2,i-1,j,dp),lcsAsciiSum(s1,s2,i,j-1,dp));\\n        return dp[i][j] = max(take,notTake);\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n1 = s1.size(),n2=s2.size();\\n        vector<vector<int>> dp(n1,vector<int>(n2,-1));\\n        int lcs = lcsAsciiSum(s1,s2,s1.size()-1,s2.size()-1,dp);\\n\\n        int totalSum = 0;\\n        for(char ch : s1) totalSum += ch;\\n        for(char ch : s2) totalSum += ch;\\n\\n        return totalSum - (2 * lcs);\\n    }\\n};\\n```\\n\\n\\uD83D\\uDD25 Iterative DP solution\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n1 = s1.size(),n2=s2.size();\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        for(int i=1;i<=n1;i++){\\n            for(int j=1;j<=n2;j++){\\n                int take = 0;\\n                if(s1[i-1] == s2[j-1]){\\n                    take = s1[i-1] + dp[i-1][j-1];\\n                }\\n\\n                int notTake = max(dp[i-1][j],dp[i][j-1]);\\n                dp[i][j] = max(take,notTake);\\n            }\\n        }\\n\\n        int lcs = dp[n1][n2];\\n\\n        int totalSum = 0;\\n        for(char ch : s1) totalSum += ch;\\n        for(char ch : s2) totalSum += ch;\\n\\n        return totalSum - (2 * lcs);\\n    }\\n};\\n```\\n\\n\\uD83D\\uDD25 Space Optimized solution || O(n) space complexity\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n1 = s1.size(),n2=s2.size();\\n        vector<int> curr(n2+1,0),prev(n2+1,0);\\n        \\n        for(int i=1;i<=n1;i++){\\n            for(int j=1;j<=n2;j++){\\n                int take = 0;\\n                if(s1[i-1] == s2[j-1]){\\n                    take = s1[i-1] + prev[j-1];\\n                }\\n\\n                int notTake = max(prev[j],curr[j-1]);\\n                curr[j] = max(take,notTake);\\n            }\\n            prev = curr;\\n        }\\n\\n        int lcs = curr[n2];\\n\\n        int totalSum = 0;\\n        for(char ch : s1) totalSum += ch;\\n        for(char ch : s2) totalSum += ch;\\n\\n        return totalSum - (2 * lcs);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lcsAsciiSum(string &s1,string& s2,int i,int j,vector<vector<int>>&dp){\\n        if(i<0 || j<0) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int take = 0;\\n        if(s1[i] == s2[j]){\\n            take = s1[i] + lcsAsciiSum(s1,s2,i-1,j-1,dp);\\n        }\\n\\n        int notTake = max(lcsAsciiSum(s1,s2,i-1,j,dp),lcsAsciiSum(s1,s2,i,j-1,dp));\\n        return dp[i][j] = max(take,notTake);\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n1 = s1.size(),n2=s2.size();\\n        vector<vector<int>> dp(n1,vector<int>(n2,-1));\\n        int lcs = lcsAsciiSum(s1,s2,s1.size()-1,s2.size()-1,dp);\\n\\n        int totalSum = 0;\\n        for(char ch : s1) totalSum += ch;\\n        for(char ch : s2) totalSum += ch;\\n\\n        return totalSum - (2 * lcs);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n1 = s1.size(),n2=s2.size();\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        for(int i=1;i<=n1;i++){\\n            for(int j=1;j<=n2;j++){\\n                int take = 0;\\n                if(s1[i-1] == s2[j-1]){\\n                    take = s1[i-1] + dp[i-1][j-1];\\n                }\\n\\n                int notTake = max(dp[i-1][j],dp[i][j-1]);\\n                dp[i][j] = max(take,notTake);\\n            }\\n        }\\n\\n        int lcs = dp[n1][n2];\\n\\n        int totalSum = 0;\\n        for(char ch : s1) totalSum += ch;\\n        for(char ch : s2) totalSum += ch;\\n\\n        return totalSum - (2 * lcs);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n1 = s1.size(),n2=s2.size();\\n        vector<int> curr(n2+1,0),prev(n2+1,0);\\n        \\n        for(int i=1;i<=n1;i++){\\n            for(int j=1;j<=n2;j++){\\n                int take = 0;\\n                if(s1[i-1] == s2[j-1]){\\n                    take = s1[i-1] + prev[j-1];\\n                }\\n\\n                int notTake = max(prev[j],curr[j-1]);\\n                curr[j] = max(take,notTake);\\n            }\\n            prev = curr;\\n        }\\n\\n        int lcs = curr[n2];\\n\\n        int totalSum = 0;\\n        for(char ch : s1) totalSum += ch;\\n        for(char ch : s2) totalSum += ch;\\n\\n        return totalSum - (2 * lcs);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842216,
                "title": "dp-py",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        def solve(i,j):\\n            if i<0 and j<0:return 0\\n            if i<0:\\n                ans=0\\n                for i in range(j,-1,-1):\\n                    ans+=ord(s2[i])\\n                return ans\\n            if j<0:\\n                ans=0\\n                for j in range(i,-1,-1):\\n                    ans+=ord(s1[j])\\n                return ans\\n            if dp[i][j]!=-1:return dp[i][j]\\n            if s1[i]==s2[j]:\\n                dp[i][j]=solve(i-1,j-1)\\n                return dp[i][j]\\n            dp[i][j]=min(ord(s1[i])+solve(i-1,j),ord(s2[j])+solve(i,j-1))\\n            return dp[i][j]\\n\\n\\n        # dp=[[-1]*(len(s2)+1)]*(len(s1)+1)\\n        dp = [[-1 for _ in range(len(s2)+1)] for _ in range(len(s1)+1)]\\n        print(dp)\\n        return solve(len(s1)-1,len(s2)-1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        def solve(i,j):\\n            if i<0 and j<0:return 0\\n            if i<0:\\n                ans=0\\n                for i in range(j,-1,-1):\\n                    ans+=ord(s2[i])\\n                return ans\\n            if j<0:\\n                ans=0\\n                for j in range(i,-1,-1):\\n                    ans+=ord(s1[j])\\n                return ans\\n            if dp[i][j]!=-1:return dp[i][j]\\n            if s1[i]==s2[j]:\\n                dp[i][j]=solve(i-1,j-1)\\n                return dp[i][j]\\n            dp[i][j]=min(ord(s1[i])+solve(i-1,j),ord(s2[j])+solve(i,j-1))\\n            return dp[i][j]\\n\\n\\n        # dp=[[-1]*(len(s2)+1)]*(len(s1)+1)\\n        dp = [[-1 for _ in range(len(s2)+1)] for _ in range(len(s1)+1)]\\n        print(dp)\\n        return solve(len(s1)-1,len(s2)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842063,
                "title": "c-dp-very-easy-to-understand",
                "content": "# Intuition\\nLongest commom subsequence\\n\\n# Approach\\nWith the LCS we just also store the sum of common subsequence ascii values and then minus it from the sum to ascii value of two strings\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.size(),m=s2.size(),maxi=0,ans=0;\\n        vector<pair<int,int>> cur(m+1,{0,0}),pre(m+1,{0,0});\\n\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                int val=s1[i-1];\\n                if(s1[i-1]==s2[j-1]){\\n                    cur[j].first = pre[j-1].first+1;\\n                    cur[j].second = pre[j-1].second+val;\\n                } else {\\n                    cur[j].first = max(pre[j].first,cur[j-1].first);\\n                    cur[j].second = max(pre[j].second,cur[j-1].second);\\n                }\\n                maxi = max(maxi,cur[j].second);\\n            }\\n            pre=cur;\\n        }\\n\\n        for(auto val:s1){\\n            ans += val;\\n        }\\n        for(auto val:s2){\\n            ans += val;\\n        }\\n\\n        return ans-2*maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.size(),m=s2.size(),maxi=0,ans=0;\\n        vector<pair<int,int>> cur(m+1,{0,0}),pre(m+1,{0,0});\\n\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                int val=s1[i-1];\\n                if(s1[i-1]==s2[j-1]){\\n                    cur[j].first = pre[j-1].first+1;\\n                    cur[j].second = pre[j-1].second+val;\\n                } else {\\n                    cur[j].first = max(pre[j].first,cur[j-1].first);\\n                    cur[j].second = max(pre[j].second,cur[j-1].second);\\n                }\\n                maxi = max(maxi,cur[j].second);\\n            }\\n            pre=cur;\\n        }\\n\\n        for(auto val:s1){\\n            ans += val;\\n        }\\n        for(auto val:s2){\\n            ans += val;\\n        }\\n\\n        return ans-2*maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842017,
                "title": "c-optimised-o-n-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) \\n    {\\n        int m = s1.size(), n = s2.size();\\n        vector<int> dp(n+1, 0);\\n        for (int j = 1; j <= n; j++)\\n            dp[j] = dp[j-1]+s2[j-1];\\n        for (int i = 1; i <= m; i++) \\n        {\\n            int t1 = dp[0];\\n            dp[0] += s1[i-1];\\n            for (int j = 1; j <= n; j++) \\n            {\\n                int t2 = dp[j];\\n            dp[j] = s1[i-1] == s2[j-1]? t1:min(dp[j]+s1[i-1], dp[j-1]+s2[j-1]);\\n                t1 = t2;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) \\n    {\\n        int m = s1.size(), n = s2.size();\\n        vector<int> dp(n+1, 0);\\n        for (int j = 1; j <= n; j++)\\n            dp[j] = dp[j-1]+s2[j-1];\\n        for (int i = 1; i <= m; i++) \\n        {\\n            int t1 = dp[0];\\n            dp[0] += s1[i-1];\\n            for (int j = 1; j <= n; j++) \\n            {\\n                int t2 = dp[j];\\n            dp[j] = s1[i-1] == s2[j-1]? t1:min(dp[j]+s1[i-1], dp[j-1]+s2[j-1]);\\n                t1 = t2;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842005,
                "title": "accepted-c-recursive-memoized-solution",
                "content": "# Intuition\\nThe problem is entirely reltaed with LCS(Longest Common Subsequence)!!\\n\\n# Approach\\nWe have 3 cases:\\n- If any of the indices reaches the end, delete all th characters of the other string(i.e. calculate the ascii values of the deleted characters).\\n- if the characters matches, increase the indices by 1 as we don\\'t need to calculate the value of same character.\\n- In last case, we calculate all the possiblities of the mismatching characters.\\n\\nThe code is self explainatory with proper comments.\\nI\\'ve provided bith the recursive and memoized apporach.\\n\\nHope you find it useful!\\n\\n## Happy coding!!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int RecursiveSoln(int i, int j, string &s1, string &s2){\\n        int n = s1.length(), m = s2.length(), ans = INT_MAX;\\n        // Base Case:\\n        // If any of the string indices reaches the end:\\n        if(i >= n || j >= m){\\n            int x = 0;\\n            if(i>=n)\\n                for(int k = j; k<=m; k++)\\n                    x += (int)s2[k];\\n            else\\n                for(int k = i; k<=n; k++)\\n                    x += (int)s1[k];\\n            return x;\\n        }\\n        // If the character at the indices matches:\\n        if(s1[i] == s2[j])\\n            ans = min(ans, RecursiveSoln(i+1, j+1, s1, s2));\\n        \\n        else{\\n            ans = min((int)s1[i] + RecursiveSoln(i+1, j, s1, s2), (int)s2[j] + RecursiveSoln(i, j+1, s1, s2));\\n        }\\n        return ans;\\n    }\\n    int Memoized(int i, int j, vector<vector<int>> &dp, string &s1, string &s2){\\n        int n = s1.length(), m = s2.length(), ans = INT_MAX;\\n        // Base Case:\\n        // If any of the string indices reaches the end:\\n        if(i >= n || j >= m){\\n            int x = 0;\\n            if(i>=n)\\n                for(int k = j; k<=m; k++)\\n                    x += (int)s2[k];\\n            else\\n                for(int k = i; k<=n; k++)\\n                    x += (int)s1[k];\\n            return x;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        // If the character at the indices matches:\\n        if(s1[i] == s2[j])\\n            ans = min(ans, Memoized(i+1, j+1, dp, s1, s2));\\n        \\n        else{\\n            ans = min((int)s1[i] + Memoized(i+1, j, dp, s1, s2), (int)s2[j] + Memoized(i, j+1, dp, s1, s2));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        // return RecursiveSoln(0, 0, s1, s2);\\n        int n = s1.length(), m = s2.length();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        return Memoized(0, 0, dp, s1, s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int RecursiveSoln(int i, int j, string &s1, string &s2){\\n        int n = s1.length(), m = s2.length(), ans = INT_MAX;\\n        // Base Case:\\n        // If any of the string indices reaches the end:\\n        if(i >= n || j >= m){\\n            int x = 0;\\n            if(i>=n)\\n                for(int k = j; k<=m; k++)\\n                    x += (int)s2[k];\\n            else\\n                for(int k = i; k<=n; k++)\\n                    x += (int)s1[k];\\n            return x;\\n        }\\n        // If the character at the indices matches:\\n        if(s1[i] == s2[j])\\n            ans = min(ans, RecursiveSoln(i+1, j+1, s1, s2));\\n        \\n        else{\\n            ans = min((int)s1[i] + RecursiveSoln(i+1, j, s1, s2), (int)s2[j] + RecursiveSoln(i, j+1, s1, s2));\\n        }\\n        return ans;\\n    }\\n    int Memoized(int i, int j, vector<vector<int>> &dp, string &s1, string &s2){\\n        int n = s1.length(), m = s2.length(), ans = INT_MAX;\\n        // Base Case:\\n        // If any of the string indices reaches the end:\\n        if(i >= n || j >= m){\\n            int x = 0;\\n            if(i>=n)\\n                for(int k = j; k<=m; k++)\\n                    x += (int)s2[k];\\n            else\\n                for(int k = i; k<=n; k++)\\n                    x += (int)s1[k];\\n            return x;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        // If the character at the indices matches:\\n        if(s1[i] == s2[j])\\n            ans = min(ans, Memoized(i+1, j+1, dp, s1, s2));\\n        \\n        else{\\n            ans = min((int)s1[i] + Memoized(i+1, j, dp, s1, s2), (int)s2[j] + Memoized(i, j+1, dp, s1, s2));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        // return RecursiveSoln(0, 0, s1, s2);\\n        int n = s1.length(), m = s2.length();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        return Memoized(0, 0, dp, s1, s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841962,
                "title": "simple-recursion-memoization-dp-space-optimized-dp",
                "content": "# Intuition\\nSIMPLE!!! *Just do as stated in problem,* **Just try to delete a character with it\\'s respective cost at each state.** \\n\\n# Approach\\nHere we will use **Recursion** to try out all possible ways and bring out the minimum cost for deletion.\\n\\nI observed we need to have ASCII Values of lowercase letters as cost, So why not convert them to their respective integer values through **typecasting**, i.e., \\n\\n```\\ncost += (int)s[i];\\n```\\n\\n**Recursive Function:**\\n\\n- At each we just need to check if both characters if two strings are same, i.e., \\n```\\nif(s1[i] == s2[j])\\n{\\n    return solve(s1, s2, i+1, j+1);     // No Need of deletion so skip those characters \\n}\\n```\\n\\n- And if both are not same we have 2 options to either delete one of the two characters and take minimum of them\\n```\\nint delete1 = (int)s1[i] + solve(s1, s2, i+1, j);\\nint delete2 = (int)s2[j] + solve(s1, s2, i, j+1);\\nreturn  min(delete1, delete2);\\n```\\n\\n- If either of them go out of bound we need to delete the remaining characters.\\n```\\nif(i >= n) // s1 goes out of bound, take remaining characters of s2 as cost\\n{\\n    int cost = 0;\\n    for(int k=j; k<m; k++)\\n    {\\n        cost += (int)s2[k];\\n    }\\n    return cost;\\n}\\nif(j >= m) // s2 goes out of bound, take remaining characters of s1 as cost\\n{\\n    int cost = 0;\\n    for(int k=i; k<n; k++)\\n    {\\n        cost += (int)s1[k];\\n    }\\n    return cost;\\n}\\n```\\n\\n# Code: Recursion (Obvious TLE)\\n```\\nclass Recursion {\\nprivate:\\n    int n, m;\\n    int solve(string& s1, string& s2, int i, int j)\\n    {\\n        if(i >= n && j >= m)\\n        {\\n            return 0;\\n        }\\n        if(i >= n)\\n        {\\n            int cost = 0;\\n            for(int k=j; k<m; k++)\\n            {\\n                cost += (int)s2[k];\\n            }\\n            return cost;\\n        }\\n        if(j >= m)\\n        {\\n            int cost = 0;\\n            for(int k=i; k<n; k++)\\n            {\\n                cost += (int)s1[k];\\n            }\\n            return cost;\\n        }\\n        if(s1[i] == s2[j])\\n        {\\n            return solve(s1, s2, i+1, j+1);\\n        }\\n        int delete1 = (int)s1[i] + solve(s1, s2, i+1, j);\\n        int delete2 = (int)s2[j] + solve(s1, s2, i, j+1);\\n        return min(delete1, delete2);\\n    }\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        n = s1.size(), m = s2.size();\\n        return solve(s1, s2, 0, 0);\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(2^N)$$, as for each state there are two changing variables.\\n\\n- Space complexity: $$O(N)$$, Recursion Stack Space.\\n\\n**Now we to store Overlapping subproblems values to reduce the time complexity using Memoization or Top-Down Dynamic Programming**\\n\\n# Code: Top-Down Dynamic Programming (Memoization)\\n```\\nclass RecMemo {\\nprivate:\\n    int n, m;\\n    int memo[1000][1000];\\n    int solve(string& s1, string& s2, int i, int j)\\n    {\\n        if(i >= n && j >= m)\\n        {\\n            return 0;\\n        }\\n        if(i >= n)\\n        {\\n            int cost = 0;\\n            for(int k=j; k<m; k++)\\n            {\\n                cost += (int)s2[k];\\n            }\\n            return cost;\\n        }\\n        if(j >= m)\\n        {\\n            int cost = 0;\\n            for(int k=i; k<n; k++)\\n            {\\n                cost += (int)s1[k];\\n            }\\n            return cost;\\n        }\\n        if(memo[i][j] != -1)\\n        {\\n            return memo[i][j];\\n        }\\n\\t\\tif(s1[i] == s2[j])\\n        {\\n            return memo[i][j] = solve(s1, s2, i+1, j+1);\\n        }\\n        int delete1 = (int)s1[i] + solve(s1, s2, i+1, j);\\n        int delete2 = (int)s2[j] + solve(s1, s2, i, j+1);\\n        return memo[i][j] = min(delete1, delete2);\\n    }\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        n = s1.size(), m = s2.size();\\n        memset(memo, -1, sizeof(memo));\\n        return solve(s1, s2, 0, 0);\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(N^2)$$, as for each state there are two changing variables.\\n\\n- Space complexity: $$O(N^2)$$ + $$O(N)$$ , Memo Array + Recursion Stack Space.\\n\\n\\n# Code: Bottom-up Dynamic Programming\\n``` \\nclass DP {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.size(), m = s2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1));\\n        dp[n][m] = 0;\\n        for(int j=0; j<m; j++)\\n        {\\n            dp[n][j] = 0;\\n            for(int k=j; k<m; k++)\\n            {\\n                dp[n][j] += (int)s2[k];\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            dp[i][m] = 0;\\n            for(int k=i; k<n; k++)\\n            {\\n                dp[i][m] += (int)s1[k];\\n            }\\n        }\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            for(int j=m-1; j>=0; j--)\\n            {\\n                if(s1[i] == s2[j])\\n                {\\n                    dp[i][j] = dp[i+1][j+1];\\n                }\\n                else\\n                {\\n                    int delete1 = (int)s1[i] + dp[i+1][j];\\n                    int delete2 = (int)s2[j] + dp[i][j+1];\\n                    dp[i][j] = min(delete1, delete2);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$, as for each state there are two changing variables.\\n\\n- Space complexity: $$O(N^2)$$ , DP Array.\\n\\n# Code: Bottom-up Dynamic Programming (Space-Optimized)\\n\\n```\\nclass SpaceOptimized {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.size(), m = s2.size();\\n        vector<int> prev(m+1), curr(m+1);\\n        prev[m] = 0;\\n        for(int j=0; j<m; j++)\\n        {\\n            prev[j] = 0;\\n            for(int k=j; k<m; k++)\\n            {\\n                prev[j] += (int)s2[k];\\n            }\\n        }\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            curr[m] = 0;\\n            for(int k=i; k<n; k++)\\n            {\\n                curr[m] += (int)s1[k];\\n            }\\n            for(int j=m-1; j>=0; j--)\\n            {\\n                if(s1[i] == s2[j])\\n                {\\n                    curr[j] = prev[j+1];\\n                }\\n                else\\n                {\\n                    int delete1 = (int)s1[i] + prev[j];\\n                    int delete2 = (int)s2[j] + curr[j+1];\\n                    curr[j] = min(delete1, delete2);\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return prev[0];\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(N^2)$$, as for each state there are two changing variables.\\n\\n- Space complexity: $$O(N)$$ , DP Array.\\n\\n![naruto.gif](https://assets.leetcode.com/users/images/107541cf-e34e-43d9-a4a6-74d81405390b_1690722278.793266.gif)\\n\\n\\nHope you understood this Solution, Just in case you understod please Upvote and share this Awesome question with your fellow coders.\\nWith this I\\'m Signing off.\\n\\n![minato.gif](https://assets.leetcode.com/users/images/cf401779-a908-41c5-a1b7-b9a22a3eb3a3_1690722295.4293869.gif)",
                "solutionTags": [
                    "C",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ncost += (int)s[i];\\n```\n```\\nif(s1[i] == s2[j])\\n{\\n    return solve(s1, s2, i+1, j+1);     // No Need of deletion so skip those characters \\n}\\n```\n```\\nint delete1 = (int)s1[i] + solve(s1, s2, i+1, j);\\nint delete2 = (int)s2[j] + solve(s1, s2, i, j+1);\\nreturn  min(delete1, delete2);\\n```\n```\\nif(i >= n) // s1 goes out of bound, take remaining characters of s2 as cost\\n{\\n    int cost = 0;\\n    for(int k=j; k<m; k++)\\n    {\\n        cost += (int)s2[k];\\n    }\\n    return cost;\\n}\\nif(j >= m) // s2 goes out of bound, take remaining characters of s1 as cost\\n{\\n    int cost = 0;\\n    for(int k=i; k<n; k++)\\n    {\\n        cost += (int)s1[k];\\n    }\\n    return cost;\\n}\\n```\n```\\nclass Recursion {\\nprivate:\\n    int n, m;\\n    int solve(string& s1, string& s2, int i, int j)\\n    {\\n        if(i >= n && j >= m)\\n        {\\n            return 0;\\n        }\\n        if(i >= n)\\n        {\\n            int cost = 0;\\n            for(int k=j; k<m; k++)\\n            {\\n                cost += (int)s2[k];\\n            }\\n            return cost;\\n        }\\n        if(j >= m)\\n        {\\n            int cost = 0;\\n            for(int k=i; k<n; k++)\\n            {\\n                cost += (int)s1[k];\\n            }\\n            return cost;\\n        }\\n        if(s1[i] == s2[j])\\n        {\\n            return solve(s1, s2, i+1, j+1);\\n        }\\n        int delete1 = (int)s1[i] + solve(s1, s2, i+1, j);\\n        int delete2 = (int)s2[j] + solve(s1, s2, i, j+1);\\n        return min(delete1, delete2);\\n    }\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        n = s1.size(), m = s2.size();\\n        return solve(s1, s2, 0, 0);\\n    }\\n};\\n```\n```\\nclass RecMemo {\\nprivate:\\n    int n, m;\\n    int memo[1000][1000];\\n    int solve(string& s1, string& s2, int i, int j)\\n    {\\n        if(i >= n && j >= m)\\n        {\\n            return 0;\\n        }\\n        if(i >= n)\\n        {\\n            int cost = 0;\\n            for(int k=j; k<m; k++)\\n            {\\n                cost += (int)s2[k];\\n            }\\n            return cost;\\n        }\\n        if(j >= m)\\n        {\\n            int cost = 0;\\n            for(int k=i; k<n; k++)\\n            {\\n                cost += (int)s1[k];\\n            }\\n            return cost;\\n        }\\n        if(memo[i][j] != -1)\\n        {\\n            return memo[i][j];\\n        }\\n\\t\\tif(s1[i] == s2[j])\\n        {\\n            return memo[i][j] = solve(s1, s2, i+1, j+1);\\n        }\\n        int delete1 = (int)s1[i] + solve(s1, s2, i+1, j);\\n        int delete2 = (int)s2[j] + solve(s1, s2, i, j+1);\\n        return memo[i][j] = min(delete1, delete2);\\n    }\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        n = s1.size(), m = s2.size();\\n        memset(memo, -1, sizeof(memo));\\n        return solve(s1, s2, 0, 0);\\n    }\\n};\\n```\n``` \\nclass DP {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.size(), m = s2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1));\\n        dp[n][m] = 0;\\n        for(int j=0; j<m; j++)\\n        {\\n            dp[n][j] = 0;\\n            for(int k=j; k<m; k++)\\n            {\\n                dp[n][j] += (int)s2[k];\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            dp[i][m] = 0;\\n            for(int k=i; k<n; k++)\\n            {\\n                dp[i][m] += (int)s1[k];\\n            }\\n        }\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            for(int j=m-1; j>=0; j--)\\n            {\\n                if(s1[i] == s2[j])\\n                {\\n                    dp[i][j] = dp[i+1][j+1];\\n                }\\n                else\\n                {\\n                    int delete1 = (int)s1[i] + dp[i+1][j];\\n                    int delete2 = (int)s2[j] + dp[i][j+1];\\n                    dp[i][j] = min(delete1, delete2);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\n```\\nclass SpaceOptimized {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.size(), m = s2.size();\\n        vector<int> prev(m+1), curr(m+1);\\n        prev[m] = 0;\\n        for(int j=0; j<m; j++)\\n        {\\n            prev[j] = 0;\\n            for(int k=j; k<m; k++)\\n            {\\n                prev[j] += (int)s2[k];\\n            }\\n        }\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            curr[m] = 0;\\n            for(int k=i; k<n; k++)\\n            {\\n                curr[m] += (int)s1[k];\\n            }\\n            for(int j=m-1; j>=0; j--)\\n            {\\n                if(s1[i] == s2[j])\\n                {\\n                    curr[j] = prev[j+1];\\n                }\\n                else\\n                {\\n                    int delete1 = (int)s1[i] + prev[j];\\n                    int delete2 = (int)s2[j] + curr[j+1];\\n                    curr[j] = min(delete1, delete2);\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return prev[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841957,
                "title": "c-bottom-up-dp-iterative-beats-98-6",
                "content": "# Complexity\\n- Time complexity:  $$O(nm)$$, where $$n$$ and $$m$$ denote the lengths of s1 and s2 respectively.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(nm)$$, where $$n$$ and $$m$$ denote the lengths of s1 and s2 respectively.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.length(), m = s2.length();\\n        int dp[1001][1001] = {{0}};\\n        dp[0][0] = 0;\\n        for(int i=1;i<=n;i++)\\n            dp[i][0] = s1[i-1] + dp[i-1][0];\\n        for(int i=1;i<=m;i++)\\n            dp[0][i] = s2[i-1] + dp[0][i-1];\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                dp[i][j] = min(s1[i-1]+dp[i-1][j], s2[j-1]+dp[i][j-1]);\\n                if(s1[i-1] == s2[j-1])\\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-1]);\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.length(), m = s2.length();\\n        int dp[1001][1001] = {{0}};\\n        dp[0][0] = 0;\\n        for(int i=1;i<=n;i++)\\n            dp[i][0] = s1[i-1] + dp[i-1][0];\\n        for(int i=1;i<=m;i++)\\n            dp[0][i] = s2[i-1] + dp[0][i-1];\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                dp[i][j] = min(s1[i-1]+dp[i-1][j], s2[j-1]+dp[i][j-1]);\\n                if(s1[i-1] == s2[j-1])\\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-1]);\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841662,
                "title": "dp-c-easy-memoized-solution",
                "content": "```\\nclass Solution {\\n    int m,n;\\n    int mv=0;\\n    int fun(int i, int j, string &s1, string &s2,vector<vector<int>>&dp)\\n    {\\n\\t   //simple largerst common sum subsequence analogous to lcs \\n        if(i==n || j==m)return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int take=0;\\n        if(s1[i]==s2[j])\\n        {\\n            take +=s1[i]+fun(i+1,j+1,s1,s2,dp);\\n        }\\n        else  take+=max(0+fun(i+1,j,s1,s2,dp),0+fun(i,j+1,s1,s2,dp));\\n        return dp[i][j]=take;\\n    }\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        n=s1.size();\\n        m=s2.size();\\n        int sm1=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sm1+=s1[i];\\n            \\n        }\\n        int sm2=0;\\n        for(int j=0;j<m;j++)\\n        {\\n           sm2+=s2[j];\\n        }\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        int lcss= fun(0,0,s1,s2,dp);// lcss will be the max sum value\\n        int ans = sm1-lcss + sm2 - lcss;//what we delete from each string will be give by total sum - lcss\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int m,n;\\n    int mv=0;\\n    int fun(int i, int j, string &s1, string &s2,vector<vector<int>>&dp)\\n    {\\n\\t   //simple largerst common sum subsequence analogous to lcs \\n        if(i==n || j==m)return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int take=0;\\n        if(s1[i]==s2[j])\\n        {\\n            take +=s1[i]+fun(i+1,j+1,s1,s2,dp);\\n        }\\n        else  take+=max(0+fun(i+1,j,s1,s2,dp),0+fun(i,j+1,s1,s2,dp));\\n        return dp[i][j]=take;\\n    }\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        n=s1.size();\\n        m=s2.size();\\n        int sm1=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sm1+=s1[i];\\n            \\n        }\\n        int sm2=0;\\n        for(int j=0;j<m;j++)\\n        {\\n           sm2+=s2[j];\\n        }\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        int lcss= fun(0,0,s1,s2,dp);// lcss will be the max sum value\\n        int ans = sm1-lcss + sm2 - lcss;//what we delete from each string will be give by total sum - lcss\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841611,
                "title": "c-recursion-and-memoization-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:   O(n*m)\\nn = length of string 1\\nm = length of string 2\\n\\n- Space complexity: O(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solveRec(int i, int j, string& s1, string& s2)\\n    {\\n        if(i == s1.length())\\n        {\\n            int ans = 0;\\n            for(int k=j; k<s2.length(); k++)\\n            {\\n                ans += s2[k];\\n            }\\n            return ans;\\n        }\\n        if(j == s2.length())\\n        {\\n            int ans = 0;\\n            for(int k=i; k<s1.length(); k++)\\n            {\\n                ans += s1[k];\\n            }\\n            return ans;\\n        }\\n\\n        if(s1[i] == s2[j])\\n            return solveRec(i+1,j+1,s1,s2);\\n        else\\n            return min(s1[i]+solveRec(i+1,j,s1,s2), s2[j]+solveRec(i,j+1,s1,s2));    \\n    }   \\n\\n    int solveMem(int i, int j, string& s1, string& s2, vector<vector<int>>& dp)\\n    {\\n        if(i == s1.length())\\n        {\\n            int ans = 0;\\n            for(int k=j; k<s2.length(); k++)\\n            {\\n                ans += s2[k];\\n            }\\n            return ans;\\n        }\\n        if(j == s2.length())\\n        {\\n            int ans = 0;\\n            for(int k=i; k<s1.length(); k++)\\n            {\\n                ans += s1[k];\\n            }\\n            return ans;\\n        }\\n\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n\\n        if(s1[i] == s2[j])\\n            return dp[i][j] = solveMem(i+1,j+1,s1,s2,dp);\\n        else\\n            return dp[i][j] = min(s1[i]+solveMem(i+1,j,s1,s2,dp), s2[j]+solveMem(i,j+1,s1,s2,dp));    \\n    }  \\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        //return solveRec(0,0,s1,s2);\\n        int n = s1.length(), m = s2.length();\\n        vector<vector<int>> dp(n, vector<int>(m,-1));\\n        return solveMem(0,0,s1,s2,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solveRec(int i, int j, string& s1, string& s2)\\n    {\\n        if(i == s1.length())\\n        {\\n            int ans = 0;\\n            for(int k=j; k<s2.length(); k++)\\n            {\\n                ans += s2[k];\\n            }\\n            return ans;\\n        }\\n        if(j == s2.length())\\n        {\\n            int ans = 0;\\n            for(int k=i; k<s1.length(); k++)\\n            {\\n                ans += s1[k];\\n            }\\n            return ans;\\n        }\\n\\n        if(s1[i] == s2[j])\\n            return solveRec(i+1,j+1,s1,s2);\\n        else\\n            return min(s1[i]+solveRec(i+1,j,s1,s2), s2[j]+solveRec(i,j+1,s1,s2));    \\n    }   \\n\\n    int solveMem(int i, int j, string& s1, string& s2, vector<vector<int>>& dp)\\n    {\\n        if(i == s1.length())\\n        {\\n            int ans = 0;\\n            for(int k=j; k<s2.length(); k++)\\n            {\\n                ans += s2[k];\\n            }\\n            return ans;\\n        }\\n        if(j == s2.length())\\n        {\\n            int ans = 0;\\n            for(int k=i; k<s1.length(); k++)\\n            {\\n                ans += s1[k];\\n            }\\n            return ans;\\n        }\\n\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n\\n        if(s1[i] == s2[j])\\n            return dp[i][j] = solveMem(i+1,j+1,s1,s2,dp);\\n        else\\n            return dp[i][j] = min(s1[i]+solveMem(i+1,j,s1,s2,dp), s2[j]+solveMem(i,j+1,s1,s2,dp));    \\n    }  \\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        //return solveRec(0,0,s1,s2);\\n        int n = s1.length(), m = s2.length();\\n        vector<vector<int>> dp(n, vector<int>(m,-1));\\n        return solveMem(0,0,s1,s2,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841552,
                "title": "java-solution",
                "content": "````Java []\\nclass Solution {\\n    int [][]dp;\\n    public int minimumDeleteSum(String s1, String s2) {\\n      \\n       dp=new int[s1.length()+1][s2.length()+1];\\n       for(int[] i : dp)\\n       {\\n           Arrays.fill(i,-1);\\n       }\\n       return rec(s1,s2,0,0);\\n    }\\n        // ArrayList<int> = new ArrayList<>();\\n        public int rec(String s1,String s2,int i,int j)\\n        {       \\n            int sum=0;\\n            int AM = Integer.MAX_VALUE;\\n            if(dp[i][j] != -1)\\n            {\\n                return dp[i][j];\\n            }\\n            if(i == s1.length())\\n            {\\n                for(int k=j;k<s2.length();k++)\\n                {\\n                    sum+=s2.charAt(k);\\n                }\\n                return sum;\\n            }\\n            if(j == s2.length())\\n            {\\n                for(j=i;j<s1.length();j++)\\n                {\\n                    sum += s1.charAt(j);\\n                }\\n                return sum;\\n            }\\n            int m = Math.min(s1.charAt(i)+rec(s1,s2,i+1,j),s2.charAt(j)+rec(s1,s2,i,j+1));\\n            \\n            if(s1.charAt(i) == s2.charAt(j))\\n            {\\n                return AM =rec(s1, s2, i + 1, j + 1);\\n\\n            }\\n            return dp[i][j]=Math.min(AM,m);\\n\\n        }\\n\\n}\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    int [][]dp;\\n    public int minimumDeleteSum(String s1, String s2) {\\n      \\n       dp=new int[s1.length()+1][s2.length()+1];\\n       for(int[] i : dp)\\n       {\\n           Arrays.fill(i,-1);\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 3841326,
                "title": "easy-recursion-lcs-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thing came to my mind after reading the problem is LCS.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsed the similar approach as used for lcs with a little tweaking.\\nInstead of calculating the matched character here we are calculating the deleted character.\\n\\n**Base Cases**\\nwhenever we reach to the end of a string we just delete(if any) all the characters of the other string.\\n\\n**ith and jth chars have matched**\\nWhen the i-th char of s1 matched with the j-th char of s2.just increment both i and j.\\n\\n**Mismatched chars**\\nWhen the chars are different we just delete all the possible cases and return the minimum:\\n1. delete the ith char of s1\\n2. delete the jth char of s2\\n3. delete both the ith and jth char from s1 and s2\\n\\nWe just memoized this recurssion call.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nm)\\nwhere n is s1.length() and m is s2.length()\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(nm)\\n\\n# Code\\n**JAVA**\\n```\\nclass Solution {\\n\\n    public int lcs(String s1, String s2, int i, int j,int [][] memo)\\n    {\\n        if(i>=s1.length())\\n        {\\n            int del=0;\\n            while(j<s2.length())\\n                del+=s2.charAt(j++);\\n\\n            return del;\\n        }\\n\\n        if(j>=s2.length())\\n        {\\n            int del=0;\\n            while(i<s1.length())\\n                del+=s1.charAt(i++);\\n\\n            return del;\\n        }\\n\\n        if(memo[i][j]!=-1)\\n            return memo[i][j];\\n\\n        int ans=0;\\n        \\n        if(s1.charAt(i)==s2.charAt(j))\\n        {\\n            ans= lcs(s1,s2,i+1,j+1,memo);\\n        }\\n        else\\n        {\\n            ans= s1.charAt(i)+lcs(s1,s2,i+1,j,memo);\\n\\n            ans=Math.min(ans,s2.charAt(j)+lcs(s1,s2,i,j+1,memo));\\n            ans= Math.min(ans,s1.charAt(i)+s2.charAt(j)+lcs(s1,s2,i+1,j+1,memo));\\n        }\\n\\n        memo[i][j]=ans;\\n        return ans;\\n\\n    }\\n    \\n    public int minimumDeleteSum(String s1, String s2) {\\n        \\n        int [][] memo= new int[s1.length()+1][s2.length()+1];\\n\\n        for(int i=0;i<=s1.length();i++)\\n        {\\n            for(int j=0;j<=s2.length();j++)\\n            {\\n                memo[i][j]=-1;\\n            }\\n        }\\n\\n        return lcs(s1,s2,0,0,memo);\\n    }\\n}\\n```\\nSame c++ solution but its **failing** to pass when submitting but passing the same test case when being run from the console.:)\\n\\nCan someone help whats the problem with this c++ solution as it happens many times when I use memoization.\\n```\\nclass Solution {\\npublic:\\n\\n    int lcs(string s1,string s2, int i, int j,vector<vector<int>> &memo)\\n    {\\n        if(i>=s1.size())\\n        {\\n            int del=0;\\n            while(j<s2.size())\\n                del+=s2[j++];\\n\\n            return del;\\n        }\\n\\n        if(j>=s2.size())\\n        {\\n            int del=0;\\n            while(i<s1.size())\\n                del+=s1[i++];\\n\\n            return del;\\n        }\\n\\n        if(memo[i][j]!=-1)\\n            return memo[i][j];\\n        int ans=0;\\n\\n        if(s1[i]==s2[j])\\n            ans= lcs(s1,s2,i+1,j+1,memo);\\n        else\\n        {\\n            ans= s1[i] +lcs(s1,s2,i+1,j,memo);\\n            ans= min(ans, s2[j]+lcs(s1,s2,i,j+1,memo));\\n            ans= min(ans,s1[i] +s2[j] +lcs(s1,s2,i+1,j+1,memo));\\n        }\\n\\n        memo[i][j]=ans;\\n        return ans;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        \\n        vector<vector<int>> memo(s1.size()+1,vector<int>(s2.size()+1,-1));\\n        return lcs(s1,s2,0,0,memo);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int lcs(String s1, String s2, int i, int j,int [][] memo)\\n    {\\n        if(i>=s1.length())\\n        {\\n            int del=0;\\n            while(j<s2.length())\\n                del+=s2.charAt(j++);\\n\\n            return del;\\n        }\\n\\n        if(j>=s2.length())\\n        {\\n            int del=0;\\n            while(i<s1.length())\\n                del+=s1.charAt(i++);\\n\\n            return del;\\n        }\\n\\n        if(memo[i][j]!=-1)\\n            return memo[i][j];\\n\\n        int ans=0;\\n        \\n        if(s1.charAt(i)==s2.charAt(j))\\n        {\\n            ans= lcs(s1,s2,i+1,j+1,memo);\\n        }\\n        else\\n        {\\n            ans= s1.charAt(i)+lcs(s1,s2,i+1,j,memo);\\n\\n            ans=Math.min(ans,s2.charAt(j)+lcs(s1,s2,i,j+1,memo));\\n            ans= Math.min(ans,s1.charAt(i)+s2.charAt(j)+lcs(s1,s2,i+1,j+1,memo));\\n        }\\n\\n        memo[i][j]=ans;\\n        return ans;\\n\\n    }\\n    \\n    public int minimumDeleteSum(String s1, String s2) {\\n        \\n        int [][] memo= new int[s1.length()+1][s2.length()+1];\\n\\n        for(int i=0;i<=s1.length();i++)\\n        {\\n            for(int j=0;j<=s2.length();j++)\\n            {\\n                memo[i][j]=-1;\\n            }\\n        }\\n\\n        return lcs(s1,s2,0,0,memo);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int lcs(string s1,string s2, int i, int j,vector<vector<int>> &memo)\\n    {\\n        if(i>=s1.size())\\n        {\\n            int del=0;\\n            while(j<s2.size())\\n                del+=s2[j++];\\n\\n            return del;\\n        }\\n\\n        if(j>=s2.size())\\n        {\\n            int del=0;\\n            while(i<s1.size())\\n                del+=s1[i++];\\n\\n            return del;\\n        }\\n\\n        if(memo[i][j]!=-1)\\n            return memo[i][j];\\n        int ans=0;\\n\\n        if(s1[i]==s2[j])\\n            ans= lcs(s1,s2,i+1,j+1,memo);\\n        else\\n        {\\n            ans= s1[i] +lcs(s1,s2,i+1,j,memo);\\n            ans= min(ans, s2[j]+lcs(s1,s2,i,j+1,memo));\\n            ans= min(ans,s1[i] +s2[j] +lcs(s1,s2,i+1,j+1,memo));\\n        }\\n\\n        memo[i][j]=ans;\\n        return ans;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        \\n        vector<vector<int>> memo(s1.size()+1,vector<int>(s2.size()+1,-1));\\n        return lcs(s1,s2,0,0,memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841247,
                "title": "c-memoization-easy-to-understand-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen we try to alter the problem statement, we get to know that we have to find a common subsequence for these two strings with minimum cost.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt each step we have 3 possibilites:\\n-> If the current position at string 1 and current position at string 2 are equal. Then we can take this index a part of our subsequence. This might not always give us the best answer so, we will find all possible combinations by once Skipping/Deleting the current index at string 1 and repeat the same for string 2 in another step.\\n--> If they are not equal then we have 2 possibilities which is to either skip the current index of string 1 or skip the current index of string 2.\\n\\n--> Our base case would be, whenever our index reaches end of the string we will end our recursion. \\n--> Don\\'t forget that once we have ended our recursion, we have to delete all the unused elements which will be at the end of unfinished string. This value will be returned.\\n\\n--> We will use a 2D DP array to memoize our solution.\\n\\n--> Also pass your strings by reference to avoid MLE.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nM: length of string1 \\nN: Length of string2\\n$$O(M*N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nM: length of string1 \\nN: Length of string2\\nEffective Space complexity: $$O(M*N)$$\\n--> As we are making a DP array of size $$(M*N)$$\\n--> We will also be using recursive call stack of $$O(M+N)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(string &s1, string &s2, int idx1, int idx2, vector<vector<int>> &dp){\\n        if(idx1 >= s1.size() || idx2 >= s2.size()){\\n            int x=0;\\n            while(idx1 < s1.size()){\\n                x += ((int)s1[idx1++]);\\n            }\\n            while(idx2 < s2.size()){\\n                x += ((int)s2[idx2++]);\\n            }\\n            return x;\\n        }\\n        if(dp[idx1][idx2] != -1){\\n            return dp[idx1][idx2];\\n        }\\n        int ans = INT_MAX;\\n        if(s1[idx1] == s2[idx2]){\\n            ans = min(ans, func(s1, s2, idx1+1, idx2+1, dp));\\n        }\\n        ans = min(ans, ((int)(s1[idx1])) + func(s1, s2, idx1+1, idx2, dp));\\n        ans = min(ans, ((int)(s2[idx2])) + func(s1, s2, idx1, idx2+1, dp));\\n        return dp[idx1][idx2]=ans;\\n        // return ans;\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.size(), m = s2.size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        return func(s1, s2, 0, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(string &s1, string &s2, int idx1, int idx2, vector<vector<int>> &dp){\\n        if(idx1 >= s1.size() || idx2 >= s2.size()){\\n            int x=0;\\n            while(idx1 < s1.size()){\\n                x += ((int)s1[idx1++]);\\n            }\\n            while(idx2 < s2.size()){\\n                x += ((int)s2[idx2++]);\\n            }\\n            return x;\\n        }\\n        if(dp[idx1][idx2] != -1){\\n            return dp[idx1][idx2];\\n        }\\n        int ans = INT_MAX;\\n        if(s1[idx1] == s2[idx2]){\\n            ans = min(ans, func(s1, s2, idx1+1, idx2+1, dp));\\n        }\\n        ans = min(ans, ((int)(s1[idx1])) + func(s1, s2, idx1+1, idx2, dp));\\n        ans = min(ans, ((int)(s2[idx2])) + func(s1, s2, idx1, idx2+1, dp));\\n        return dp[idx1][idx2]=ans;\\n        // return ans;\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.size(), m = s2.size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        return func(s1, s2, 0, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841238,
                "title": "memoization-beginner-friendly-well-commented",
                "content": "# Code\\n```\\nclass Solution {\\n    Integer memo[][],m,n;\\n    int ss1[], ss2[]; \\n    public int minimumDeleteSum(String s1, String s2) {\\n        memo=new Integer[1+(m=s1.length())][1+(n=s2.length())];\\n        ss1=new int[m+1]; ss2=new int[n+1];\\n//Preprocessing the cummulative sum of ascii values.\\n        for(int i=m-1;i>=0;--i) ss1[i]+=s1.charAt(i)+ss1[i+1];\\n        for(int i=n-1;i>=0;--i) ss2[i]+=s2.charAt(i)+ss2[i+1];\\n        return f(s1.toCharArray(), s2.toCharArray(), 0, 0);\\n    }\\n    private int f(char[] s1, char[] s2, int i, int j){\\n//If there is no string left to calculate in one of the strings,\\n//we must add all the character asciis in the other strings which\\n//are left.\\n        if(i>=m) return ss2[j];\\n        if(j>=n) return ss1[i];\\n        if(memo[i][j]!=null) return memo[i][j];\\n//If they ith and jth characters are same, no need to add the ascii\\n        if(s1[i]==s2[j]) return memo[i][j]=f(s1,s2,i+1,j+1);\\n//Finding the minimum result after deleting any one of the characters\\n        return memo[i][j]=Math.min(s1[i]+f(s1,s2,i+1,j), s2[j]+f(s1,s2,i,j+1));\\n    }\\n}\\n```\\n# Complexities:\\n> SC :- $$O(m*n)$$\\nTC :- $$O(m*n)$$",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Integer memo[][],m,n;\\n    int ss1[], ss2[]; \\n    public int minimumDeleteSum(String s1, String s2) {\\n        memo=new Integer[1+(m=s1.length())][1+(n=s2.length())];\\n        ss1=new int[m+1]; ss2=new int[n+1];\\n//Preprocessing the cummulative sum of ascii values.\\n        for(int i=m-1;i>=0;--i) ss1[i]+=s1.charAt(i)+ss1[i+1];\\n        for(int i=n-1;i>=0;--i) ss2[i]+=s2.charAt(i)+ss2[i+1];\\n        return f(s1.toCharArray(), s2.toCharArray(), 0, 0);\\n    }\\n    private int f(char[] s1, char[] s2, int i, int j){\\n//If there is no string left to calculate in one of the strings,\\n//we must add all the character asciis in the other strings which\\n//are left.\\n        if(i>=m) return ss2[j];\\n        if(j>=n) return ss1[i];\\n        if(memo[i][j]!=null) return memo[i][j];\\n//If they ith and jth characters are same, no need to add the ascii\\n        if(s1[i]==s2[j]) return memo[i][j]=f(s1,s2,i+1,j+1);\\n//Finding the minimum result after deleting any one of the characters\\n        return memo[i][j]=Math.min(s1[i]+f(s1,s2,i+1,j), s2[j]+f(s1,s2,i,j+1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841116,
                "title": "c-memoization-dp-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Memoization \\n    // memory limit exceeded\\n    int helper(int i,int j,string s1,string s2,vector<vector<int>> &dp){\\n        int n=s1.length();\\n        int m=s2.length();\\n        if(i>=n){\\n            int sum2=0;\\n            for(int k=j;k<m;k++){\\n                sum2+= (s2[k]-\\'a\\'+97);\\n            }\\n\\n            return sum2;\\n        }\\n\\n        if(j>=m){\\n            int sum1=0;\\n            for(int k=i;k<n;k++){\\n                sum1+= (s1[k]-\\'a\\'+97);\\n            }\\n\\n            return sum1;\\n        }\\n        int ans=0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        if(s1[i]==s2[j]){\\n            ans = 0+ helper(i+1,j+1,s1,s2,dp);\\n        }\\n        else{\\n            ans=min((s1[i]-\\'a\\'+97)+helper(i+1,j,s1,s2,dp),(s2[j]-\\'a\\'+97)+helper(i,j+1,s1,s2,dp));\\n        }\\n\\n        return dp[i][j]=ans;\\n    }\\n\\n\\n\\n    //Tabulation \\n    //Accepted\\n    int minimumDeleteSum(string s1, string s2) \\n      int n=s1.length();\\n      int m=s2.length();\\n      //vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n      vector<vector<int>> dp(n+1,vector<int> (m+1,0));\\n       int sum2=0;\\n       for(int k=0;k<m;k++){\\n        sum2+= (s2[k]-\\'a\\'+97);\\n       }\\n\\n       int sum1=0;\\n       for(int k=0;k<n;k++){\\n           sum1+=(s1[k]-\\'a\\'+97);\\n       }\\n\\n      dp[n][0]=sum2;\\n      for(int j=1;j<=m;j++){\\n        dp[n][j]= sum2 - (s2[j-1]-\\'a\\'+97);\\n        sum2-= (s2[j-1]-\\'a\\'+97);\\n      }\\n\\n      dp[0][m]=sum1;\\n      for(int i=1;i<=n;i++){\\n          dp[i][m]=sum1-(s1[i-1]-\\'a\\'+97);\\n          sum1-= (s1[i-1]-\\'a\\'+97);\\n      }\\n\\n      int ans=0;\\n      for(int i=n-1;i>=0;i--){\\n        for(int j=m-1;j>=0;j--){\\n            if(s1[i]==s2[j]){\\n                ans = dp[i+1][j+1];\\n            }\\n            else{\\n                ans=min((s1[i]-\\'a\\'+97)+dp[i+1][j],(s2[j]-\\'a\\'+97)+dp[i][j+1]);\\n            }\\n\\n            dp[i][j]=ans;\\n        }\\n      }\\n\\n      return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Memoization \\n    // memory limit exceeded\\n    int helper(int i,int j,string s1,string s2,vector<vector<int>> &dp){\\n        int n=s1.length();\\n        int m=s2.length();\\n        if(i>=n){\\n            int sum2=0;\\n            for(int k=j;k<m;k++){\\n                sum2+= (s2[k]-\\'a\\'+97);\\n            }\\n\\n            return sum2;\\n        }\\n\\n        if(j>=m){\\n            int sum1=0;\\n            for(int k=i;k<n;k++){\\n                sum1+= (s1[k]-\\'a\\'+97);\\n            }\\n\\n            return sum1;\\n        }\\n        int ans=0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        if(s1[i]==s2[j]){\\n            ans = 0+ helper(i+1,j+1,s1,s2,dp);\\n        }\\n        else{\\n            ans=min((s1[i]-\\'a\\'+97)+helper(i+1,j,s1,s2,dp),(s2[j]-\\'a\\'+97)+helper(i,j+1,s1,s2,dp));\\n        }\\n\\n        return dp[i][j]=ans;\\n    }\\n\\n\\n\\n    //Tabulation \\n    //Accepted\\n    int minimumDeleteSum(string s1, string s2) \\n      int n=s1.length();\\n      int m=s2.length();\\n      //vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n      vector<vector<int>> dp(n+1,vector<int> (m+1,0));\\n       int sum2=0;\\n       for(int k=0;k<m;k++){\\n        sum2+= (s2[k]-\\'a\\'+97);\\n       }\\n\\n       int sum1=0;\\n       for(int k=0;k<n;k++){\\n           sum1+=(s1[k]-\\'a\\'+97);\\n       }\\n\\n      dp[n][0]=sum2;\\n      for(int j=1;j<=m;j++){\\n        dp[n][j]= sum2 - (s2[j-1]-\\'a\\'+97);\\n        sum2-= (s2[j-1]-\\'a\\'+97);\\n      }\\n\\n      dp[0][m]=sum1;\\n      for(int i=1;i<=n;i++){\\n          dp[i][m]=sum1-(s1[i-1]-\\'a\\'+97);\\n          sum1-= (s1[i-1]-\\'a\\'+97);\\n      }\\n\\n      int ans=0;\\n      for(int i=n-1;i>=0;i--){\\n        for(int j=m-1;j>=0;j--){\\n            if(s1[i]==s2[j]){\\n                ans = dp[i+1][j+1];\\n            }\\n            else{\\n                ans=min((s1[i]-\\'a\\'+97)+dp[i+1][j],(s2[j]-\\'a\\'+97)+dp[i][j+1]);\\n            }\\n\\n            dp[i][j]=ans;\\n        }\\n      }\\n\\n      return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840923,
                "title": "tabulation-with-space-optimisation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        if(s1.size()>s2.size())swap(s1,s2);\\n        int n=s1.size();\\n        int m=s2.size();\\n        vector<int>dp(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            dp[i]=dp[i-1]+s1[i-1];\\n        }\\n        for(int i=0;i<m;i++){\\n            vector<int>temp(n+1,dp[0]+s2[i]);\\n            for(int j=0;j<n;j++){\\n                if(s2[i]==s1[j]){\\n                    temp[j+1]=dp[j];\\n                }\\n                else{\\n                    temp[j+1]=min(\\n                        dp[j]+s2[i]+s1[j],\\n                        min(\\n                            temp[j]+s1[j],\\n                            dp[j+1]+s2[i]\\n                        )\\n                    );\\n                    \\n                }\\n\\n            }\\n                dp=temp;\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        if(s1.size()>s2.size())swap(s1,s2);\\n        int n=s1.size();\\n        int m=s2.size();\\n        vector<int>dp(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            dp[i]=dp[i-1]+s1[i-1];\\n        }\\n        for(int i=0;i<m;i++){\\n            vector<int>temp(n+1,dp[0]+s2[i]);\\n            for(int j=0;j<n;j++){\\n                if(s2[i]==s1[j]){\\n                    temp[j+1]=dp[j];\\n                }\\n                else{\\n                    temp[j+1]=min(\\n                        dp[j]+s2[i]+s1[j],\\n                        min(\\n                            temp[j]+s1[j],\\n                            dp[j+1]+s2[i]\\n                        )\\n                    );\\n                    \\n                }\\n\\n            }\\n                dp=temp;\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840876,
                "title": "simple-4-lines-code-using-dp-memoization",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind `LCS (Longest Common Subsequence)`, while finding it instead calculating the length, calculate its ASCII value of each character.\\nFinally find the ASCII value of `s1` & `s2` sum add both & subtract `2 * total ASCII value of longest common subsequence.`\\n# Complexity\\n- Time complexity:$$O(nm)$$\\n    - where `n` and `m` are the lengths of strings s1 and s2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(nm)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  private:\\n  int helper(int n , int m ,string &s1 ,string &s2, vector<vector<int>>&dp ){\\n    if(n < 0 || m < 0) return 0;\\n    // returning the ASCII value of Characters part of LCS\\n    if(s1[n] == s2[m]) return int(s1[n]) + helper(n-1 , m-1 , s1, s2,dp);\\n\\n    if(dp[n][m] != -1) return dp[n][m];\\n    else return dp[n][m] = max(helper(n-1 , m , s1 ,s2,dp) , helper(n , m-1  , s1 ,s2,dp));\\n}\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.length();\\n        int m = s2.length();\\n        vector<vector<int>>dp(n , vector<int>(m , -1));\\n        int s1_ascii = 0, s2_ascii = 0;\\n        for(auto c : s1) s1_ascii += c;\\n        for(auto c : s2) s2_ascii += c;\\n\\n        return s1_ascii + s2_ascii - (2* helper(n-1 , m-1 , s1 , s2,dp));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n  private:\\n  int helper(int n , int m ,string &s1 ,string &s2, vector<vector<int>>&dp ){\\n    if(n < 0 || m < 0) return 0;\\n    // returning the ASCII value of Characters part of LCS\\n    if(s1[n] == s2[m]) return int(s1[n]) + helper(n-1 , m-1 , s1, s2,dp);\\n\\n    if(dp[n][m] != -1) return dp[n][m];\\n    else return dp[n][m] = max(helper(n-1 , m , s1 ,s2,dp) , helper(n , m-1  , s1 ,s2,dp));\\n}\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n = s1.length();\\n        int m = s2.length();\\n        vector<vector<int>>dp(n , vector<int>(m , -1));\\n        int s1_ascii = 0, s2_ascii = 0;\\n        for(auto c : s1) s1_ascii += c;\\n        for(auto c : s2) s2_ascii += c;\\n\\n        return s1_ascii + s2_ascii - (2* helper(n-1 , m-1 , s1 , s2,dp));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840775,
                "title": "easy-java-solution-dp-string-tabulation",
                "content": "# Intuition\\n\\nThe solution uses a bottom-up dynamic programming approach to find the answer iteratively. It fills the dp array from the base cases (initializing the first row and first column) and gradually builds the solution for the entire strings s1 and s2.\\n\\n# Approach\\nThe problem is solved using dynamic programming. We create a 2D array dp, where dp[i][j] represents the minimum ASCII sum of deleted characters to make substrings s1[i:] and s2[j:] equal. The dp array is filled iteratively, considering characters\\' equality or deletion. We initialize dp with cumulative ASCII sums and find the minimum of two options: deleting a character from s1 or s2. The result is stored in dp[n1][n2], where n1 and n2 are the lengths of s1 and s2 respectively, giving us the lowest ASCII sum of deleted characters.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the given solution is O(n1 * n2)\\n\\n- Space complexity:\\nThe space complexity of the given solution is also O(n1 * n2)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int n1 = s1.length();\\n        int n2 = s2.length();\\n        int[][] dp = new int[n1+1][n2+1];\\n        for (int i = 1; i <= n1; i++)\\n            dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1);\\n        for (int j = 1; j <= n2; j++)\\n            dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1);\\n        for(int i=1; i<=n1; i++){\\n            for(int j=1; j<=n2; j++){\\n                if(s1.charAt(i-1)==s2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = Math.min(dp[i-1][j]+s1.charAt(i-1),dp[i][j-1]+s2.charAt(j-1));\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n}\\n\\n\\n```\\n![download.jpg](https://assets.leetcode.com/users/images/31f145a3-f07b-4c5a-adc7-9cb42f4727c8_1690782055.6418989.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int n1 = s1.length();\\n        int n2 = s2.length();\\n        int[][] dp = new int[n1+1][n2+1];\\n        for (int i = 1; i <= n1; i++)\\n            dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1);\\n        for (int j = 1; j <= n2; j++)\\n            dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1);\\n        for(int i=1; i<=n1; i++){\\n            for(int j=1; j<=n2; j++){\\n                if(s1.charAt(i-1)==s2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = Math.min(dp[i-1][j]+s1.charAt(i-1),dp[i][j-1]+s2.charAt(j-1));\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840770,
                "title": "easy-java-dp-memoization",
                "content": "# Code\\n```\\nclass Solution {\\n    int m, n;\\n    int[][] dp;\\n    public int minimumDeleteSum(String s1, String s2) {\\n        m = s1.length();\\n        n = s2.length();\\n        dp = new int[m+1][n+1];\\n        return dfs(s1, s2, 0, 0);\\n    }\\n\\n    public int dfs(String s1, String s2, int i1, int i2){\\n        if (i1 == m && i2 == n){\\n            return 0;\\n        }\\n        if (dp[i1][i2] != 0){\\n            return dp[i1][i2];\\n        }\\n        int a, b, c;\\n        a = b = c = Integer.MAX_VALUE;\\n        // condition 1: delete current element from s1\\n        if (i1 < m){\\n            a = s1.charAt(i1)+dfs(s1, s2, i1+1, i2);\\n        }\\n        // condition 2: delete current element from s2\\n        if (i2 < n){\\n            b = s2.charAt(i2)+dfs(s1, s2, i1, i2+1);\\n        }\\n        // condition 3: no delete\\n        if (i1 < m && i2 < n){\\n            if (s1.charAt(i1) == s2.charAt(i2)){\\n                c = dfs(s1, s2, i1+1, i2+1);\\n            }\\n        }\\n        // compare 3 conditions and return the smallest sum\\n        return dp[i1][i2] = Math.min(Math.min(a,b), c);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int m, n;\\n    int[][] dp;\\n    public int minimumDeleteSum(String s1, String s2) {\\n        m = s1.length();\\n        n = s2.length();\\n        dp = new int[m+1][n+1];\\n        return dfs(s1, s2, 0, 0);\\n    }\\n\\n    public int dfs(String s1, String s2, int i1, int i2){\\n        if (i1 == m && i2 == n){\\n            return 0;\\n        }\\n        if (dp[i1][i2] != 0){\\n            return dp[i1][i2];\\n        }\\n        int a, b, c;\\n        a = b = c = Integer.MAX_VALUE;\\n        // condition 1: delete current element from s1\\n        if (i1 < m){\\n            a = s1.charAt(i1)+dfs(s1, s2, i1+1, i2);\\n        }\\n        // condition 2: delete current element from s2\\n        if (i2 < n){\\n            b = s2.charAt(i2)+dfs(s1, s2, i1, i2+1);\\n        }\\n        // condition 3: no delete\\n        if (i1 < m && i2 < n){\\n            if (s1.charAt(i1) == s2.charAt(i2)){\\n                c = dfs(s1, s2, i1+1, i2+1);\\n            }\\n        }\\n        // compare 3 conditions and return the smallest sum\\n        return dp[i1][i2] = Math.min(Math.min(a,b), c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840722,
                "title": "easy-to-understand-lcs-variation-with-explanation-memoization",
                "content": "## Connect with me on LinkedIn : https://www.linkedin.com/in/aditya-jhunjhunwala-51b586195/\\n# Intuition\\n### Its similar to LCS(Longest Common Subsequence) i.e here if two characters at their respective i & j positions r same them we have to 100% pick them but when its different then the value of unpicked one is taken & the same subproblem process continues until **BOTH** the i & j pointers reach their respective ends(this difference from LCS is to be kept in mind as we have to only return i.e our base case only hits when we reach the end of both of the strings otherwise the unpicked/deleted value will not be added into the answer completely) \\n\\n# Complexity\\n- Time complexity:\\nO(n ^ 2)\\n\\n- Space complexity:\\nO(n ^ 2)\\n\\n# Code\\n## Please Upvote if u found my Solution Useful\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int helper(int i, int j, string& s1, string& s2, int size1, int size2){\\n        if(i == size1 && j == size2)\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int ans = INT_MAX;\\n        if(i == size1)\\n            ans = min(ans,s2[j] + helper(i, j + 1, s1, s2, size1, size2));\\n        else if(j == size2)\\n            ans = min(ans,s1[i] + helper(i + 1, j, s1, s2, size1, size2));\\n        else if(s1[i] == s2[j])\\n            ans = min(ans,helper(i + 1, j + 1, s1, s2, size1, size2));\\n        else{\\n            ans = min(ans,s1[i] + helper(i + 1, j, s1, s2, size1, size2));\\n            ans = min(ans,s2[j] + helper(i, j + 1, s1, s2, size1, size2));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int size1 = s1.size(), size2 = s2.size();\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,0,s1,s2,size1,size2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int helper(int i, int j, string& s1, string& s2, int size1, int size2){\\n        if(i == size1 && j == size2)\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int ans = INT_MAX;\\n        if(i == size1)\\n            ans = min(ans,s2[j] + helper(i, j + 1, s1, s2, size1, size2));\\n        else if(j == size2)\\n            ans = min(ans,s1[i] + helper(i + 1, j, s1, s2, size1, size2));\\n        else if(s1[i] == s2[j])\\n            ans = min(ans,helper(i + 1, j + 1, s1, s2, size1, size2));\\n        else{\\n            ans = min(ans,s1[i] + helper(i + 1, j, s1, s2, size1, size2));\\n            ans = min(ans,s2[j] + helper(i, j + 1, s1, s2, size1, size2));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int size1 = s1.size(), size2 = s2.size();\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,0,s1,s2,size1,size2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840684,
                "title": "clean-neat-code-c-tabulation-tc-o-mn-sc-o-mn",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m=s1.length();\\n        int n=s2.length();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n\\n        for(int i=1;i<=n;i++)\\n        dp[0][i]=dp[0][i-1]+s2[i-1]; \\n\\n        for(int i=1;i<=m;i++)\\n        dp[i][0]=dp[i-1][0]+s1[i-1];\\n\\n\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(s1[i-1]==s2[j-1])\\n                dp[i][j]=dp[i-1][j-1];\\n                else\\n                dp[i][j]=min(s1[i-1]+dp[i-1][j],s2[j-1]+dp[i][j-1]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int m=s1.length();\\n        int n=s2.length();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n\\n        for(int i=1;i<=n;i++)\\n        dp[0][i]=dp[0][i-1]+s2[i-1]; \\n\\n        for(int i=1;i<=m;i++)\\n        dp[i][0]=dp[i-1][0]+s1[i-1];\\n\\n\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(s1[i-1]==s2[j-1])\\n                dp[i][j]=dp[i-1][j-1];\\n                else\\n                dp[i][j]=min(s1[i-1]+dp[i-1][j],s2[j-1]+dp[i][j-1]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840680,
                "title": "lcs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the LCS of the two strings and compute its ascii value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nReduce the ASCII value of the longest common subsequence from both s1 and s2\\'s ascii sum. We will get the reqd. answer\\n\\nanswer = asciiSum(s1) + asciiSum(s2) - 2*asciiSum(LCS);\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### **PLEASE UPVOTE IF IT HELPED**\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        //ascii of the longest common subsequence\\n        int[][] t = new int[s1.length()+1][s2.length()+1];\\n        for(int i = 1; i < s1.length()+1; i++){\\n            for(int j = 1; j < s2.length()+1; j++){\\n                if(s1.charAt(i-1) == s2.charAt(j-1)){\\n                    t[i][j] = (int)s1.charAt(i-1) + t[i-1][j-1];\\n                }else{\\n                    t[i][j] = Math.max(t[i-1][j],t[i][j-1]);\\n                }\\n            }\\n        }\\n        int asciilcs = t[s1.length()][s2.length()];\\n        int asci1 = 0; \\n        for(int i = 0; i < s1.length(); i++){\\n            asci1 += (int)s1.charAt(i);\\n        }\\n        int asci2 = 0;\\n        for(int i = 0; i < s2.length(); i++){\\n            asci2 += (int)s2.charAt(i);\\n        }\\n        System.out.println(asciilcs);\\n\\n        return asci1+asci2-2*asciilcs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        //ascii of the longest common subsequence\\n        int[][] t = new int[s1.length()+1][s2.length()+1];\\n        for(int i = 1; i < s1.length()+1; i++){\\n            for(int j = 1; j < s2.length()+1; j++){\\n                if(s1.charAt(i-1) == s2.charAt(j-1)){\\n                    t[i][j] = (int)s1.charAt(i-1) + t[i-1][j-1];\\n                }else{\\n                    t[i][j] = Math.max(t[i-1][j],t[i][j-1]);\\n                }\\n            }\\n        }\\n        int asciilcs = t[s1.length()][s2.length()];\\n        int asci1 = 0; \\n        for(int i = 0; i < s1.length(); i++){\\n            asci1 += (int)s1.charAt(i);\\n        }\\n        int asci2 = 0;\\n        for(int i = 0; i < s2.length(); i++){\\n            asci2 += (int)s2.charAt(i);\\n        }\\n        System.out.println(asciilcs);\\n\\n        return asci1+asci2-2*asciilcs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840642,
                "title": "modified-edit-distance-solution",
                "content": "B# Code\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        v=[]\\n        for i in range(len(s1)+1):\\n            l=[]\\n            for j in range(len(s2)+1):\\n                l.append(0)\\n            v.append(l)\\n        s=0\\n        for i in range(len(s1)):\\n            s+=ord(s1[i])\\n            v[i+1][0]=s\\n        s=0\\n        for j in range(len(s2)):\\n            s+=ord(s2[j])\\n            v[0][j+1]=s\\n        for i in range(len(s1)):\\n            for j in range(len(s2)):\\n                if s1[i]==s2[j]:\\n                    v[i+1][j+1]=v[i][j]\\n                else:\\n                    v[i+1][j+1]=min(v[i][j+1]+ord(s1[i]),v[i+1][j]+ord(s2[j]))\\n        print(v)\\n        return v[len(s1)][len(s2)]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        v=[]\\n        for i in range(len(s1)+1):\\n            l=[]\\n            for j in range(len(s2)+1):\\n                l.append(0)\\n            v.append(l)\\n        s=0\\n        for i in range(len(s1)):\\n            s+=ord(s1[i])\\n            v[i+1][0]=s\\n        s=0\\n        for j in range(len(s2)):\\n            s+=ord(s2[j])\\n            v[0][j+1]=s\\n        for i in range(len(s1)):\\n            for j in range(len(s2)):\\n                if s1[i]==s2[j]:\\n                    v[i+1][j+1]=v[i][j]\\n                else:\\n                    v[i+1][j+1]=min(v[i][j+1]+ord(s1[i]),v[i+1][j]+ord(s2[j]))\\n        print(v)\\n        return v[len(s1)][len(s2)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840628,
                "title": "dp-memoization-python3-o-mn",
                "content": "# Complexity\\n- Time complexity:\\nO(M.N)\\n\\n- Space complexity:\\nO(M.N)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n\\n        def dfs(i, j):\\n            # suppose we reach the end of one string, the we have to delete the chars from other string\\n            if i == len(s1): \\n                return sum([ord(c) for c in s2[j:]])\\n                \\n            if j == len(s2):\\n                return sum([ord(c) for c in s1[i:]])\\n    \\n            if (i, j) in dp:\\n                return dp[(i, j)]\\n\\n            res = float(\\'inf\\')\\n            if s1[i] == s2[j]: # if both char same nothing to add just increment the pointers\\n                res = min(res, dfs(i + 1, j + 1))\\n            else: # else try both ways, del the char from s1 and del the char from s2\\n                res = min(res, ord(s1[i]) + dfs(i + 1, j))\\n                res = min(res, ord(s2[j]) + dfs(i, j + 1))\\n            dp[(i, j)] = res\\n            return res\\n\\n        dp = {}\\n        return dfs(0, 0)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n\\n        def dfs(i, j):\\n            # suppose we reach the end of one string, the we have to delete the chars from other string\\n            if i == len(s1): \\n                return sum([ord(c) for c in s2[j:]])\\n                \\n            if j == len(s2):\\n                return sum([ord(c) for c in s1[i:]])\\n    \\n            if (i, j) in dp:\\n                return dp[(i, j)]\\n\\n            res = float(\\'inf\\')\\n            if s1[i] == s2[j]: # if both char same nothing to add just increment the pointers\\n                res = min(res, dfs(i + 1, j + 1))\\n            else: # else try both ways, del the char from s1 and del the char from s2\\n                res = min(res, ord(s1[i]) + dfs(i + 1, j))\\n                res = min(res, ord(s2[j]) + dfs(i, j + 1))\\n            dp[(i, j)] = res\\n            return res\\n\\n        dp = {}\\n        return dfs(0, 0)\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1993704,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem, but much easier than the one on yesterday! Like the longest common subsequence problem! A substring must be a subsequence, but a subsequence may be not a substring! One more hint: Use the following formula\n$$\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2* asciiSum(LCS)\n$$\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840645/c-several-recursiveiterative-dplcs-beats-9462/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) You can simplify your program by replacing  the line ```if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)``` in lcs(i, j) by ``` if s[i-1] == t[j-1]: dp[i][j] = ord(s[i-1])+lcs(i-1,j-1)```. At final, ``` return res-2*lcs(n, m)``` Everything goes OK!"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@_aka5h](/_aka5h) Now got the point thanks [@Akash Rai](/_aka5h)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) In your case, you can consider \"oo\" to be the LCS with maximum ASCII value. But In general, there is something even more important, that can be overlooked if we use the term LCS, here in this problem we are using LCS pattern and not exactly finding LCS. The idea is to find a subsequence with maximum ASCII value which is common to both given strings and that subsequence doesn't necessarily have to be the LCS of the 2 strings. There might be a case where a subsequence (which is common to both strings and is not LCS) have higher ASSCII sum than the actual LCS of the 2 strings."
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) \n```\nclass Solution:\n    def minimumDeleteSum(self, s: str, t: str) -> int:\n        # finding the lcs\n        def lcs(i,j):\n            if i == 0 or j == 0: return 0\n            if dp[i][j] != -1: return dp[i][j]\n            if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)\n            else: dp[i][j] = max(lcs(i-1,j), lcs(i,j-1))\n            return dp[i][j]\n        n,m = len(s),len(t)\n        dp = [[-1]*(m+1) for _ in range(n+1)]\n        lcs(n,m)\n        res = 0\n        # getting the actual string\n        i,j = n,m\n        string = ''\n        while i>0 and j>0:\n            if s[i-1] == t[j-1]: \n                string = s[i-1]+string\n                i,j = i-1,j-1\n            else:\n                if dp[i-1][j] > dp[i][j-1]: i -= 1\n                elif dp[i-1][j] < dp[i][j-1]: j -= 1\n                else:\n                    if ord(s[i-1]) > ord(t[j-1]): j -= 1\n                    else: i -= 1\n        for i in s: res += ord(i)\n        for i in t: res += ord(i)\n        for i in string: res -= ord(i)*2\n        return res\n```"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) Could you check the below code once..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) I\\'ve tried my 3 solutions. All outputs are 2255"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can you explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. asciiSum(s1) = 1620 asciiSum(s2) = 1079 and asciiSum(lcs) = 217 and according to your formula also it should be 2265 but expected output is 2255"
                    },
                    {
                        "username": "Yaswanth017",
                        "content": "The problem statement never mentioned anything about subsequence. Who else finds this misleading? Leetcode expects us to figure it out by looking at example 2🤷‍♂️🤦‍♂️"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "[@gadmo](/gadmo) Yeah but I\\'m new and when trying to come up with a solution I was confused why you couldn\\'t just delete \"de\" from delete to get lete and leet which are both equal ascvii wise. It never mentions sub sequence just sum which is the same no matter which order they are in. "
                    },
                    {
                        "username": "Princesah999",
                        "content": "I was doing this \\n\\n// delete => deeelt\\n// leet   => eelt"
                    },
                    {
                        "username": "betaev",
                        "content": "[@gadmo](/gadmo) it\\'s longest common subsequence inversed"
                    },
                    {
                        "username": "gadmo",
                        "content": "you don\\'t need to think about subsequence at all to solve this, its almost textbook edit distance."
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Consider this problem as a variation of LCS.\\n"
                    },
                    {
                        "username": "ido.shamir.ido",
                        "content": "I might be missing something here but isn\\'t Example 2 wrong?\\nInput: s1 = \"delete\", s2 = \"leet\"\\nWe can delete \"de\" from s1 and nothing from s2. The strings will be equal (unordered) leet = lete and the sum will be smaller."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@Ido Shamir](/ido.shamir.ido)  This is because the order of the string can\\'t be changed we can only delete elements to make two string equal."
                    },
                    {
                        "username": "prathmesh-jagtap",
                        "content": "[@BlackMamba97](/BlackMamba97)  \\nYes the subsequences are always in contiguous."
                    },
                    {
                        "username": "BlackMamba97",
                        "content": "This is for ordered sequence.\\nRead the definition of subsequence. you will get the answer to your question."
                    },
                    {
                        "username": "paradoxtown",
                        "content": "All of us will become DP masters one day."
                    },
                    {
                        "username": "yurek16II",
                        "content": "Nice example, delete leet == forbidden ;)"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Output 403\\nExpected 403"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Nowadays its seems like DP day😂...everywhere it is present take it whether daily challenge or contest🙂"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "looks like a variation of LCS"
                    },
                    {
                        "username": "panieldark",
                        "content": "Second! Longest Common Subsequence for the win lol"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "# CAN ANYONE TELL ME WHAT AM I DOING WRONG? \\n\\n```\\nclass Solution {\\npublic:\\n    string lcs(string s1, string s2, vector<vector<int>> &dp, int lcslen){\\n        string lcsstring = \"\";\\n        int index = lcslen-1;\\n        for(int i =0; i < lcslen; ++i) lcsstring += \\'#\\';\\n        int i = s1.size(), j = s2.size();\\n        while(i > 0 && j > 0){\\n            if(s1[i-1] == s2[j-1]){\\n                lcsstring[index] = s1[i-1];\\n                index--;\\n                i--;\\n                j--;\\n            }else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    i--;\\n                }else if(dp[i-1][j] < dp[i][j-1]){\\n                    j--;\\n                }else{\\n                    if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return lcsstring;\\n    }\\n    int populatedp(string s1, string s2, vector<vector<int>> &dp) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        for(int i = 0; i <= n1; ++i) dp[i][0] = 0;\\n        for(int i = 0; i <= n2; ++i) dp[0][i] = 0;\\n        for(int ind1 = 1; ind1 <= n1; ++ind1){\\n            for(int ind2 = 1; ind2 <= n2; ++ind2){\\n                if(s1[ind1-1] == s2[ind2-1]){\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                }else if(s1[ind1-1] != s2[ind2-1]){\\n                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int ret = 0, n1 = s1.size(), n2 = s2.size();\\n        for(auto& x: s1) ret += x;\\n        for(auto &x: s2 ) ret += x;\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        int lcslen = populatedp(s1,s2,dp);\\n        for(int i = 0; i <= n1; ++i){\\n            for(int j = 0; j <= n2; ++j){\\n                cout << dp[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        string s = lcs(s1,s2,dp,lcslen);\\n        for(int i = 0; i < 2; ++i) for(auto &x: s) ret -= x;\\n        return ret;\\n    }\\n};\\n\\n```\\nInput\\ns1 =\\n\"delete\"\\ns2 =\\n\"leet\"\\nStdout\\n0 0 0 0 0 \\n0 0 0 0 0 \\n0 0 1 1 1 \\n0 1 1 1 1 \\n0 1 2 2 2 \\n0 1 2 2 3 \\n0 1 2 3 3 \\nOutput\\n433\\nExpected\\n403"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Finding out the LCS having the maximum ASCII sum should be the task , but while backtracking and forming LCS , getting maximum ASCII sum one requires us to check for all LCS strings and then compare from it.\\n\\nAnd also in case of else {\\n      s1[i-1] < s2[j-1]\\n     Should be compared not s1[i] and s2[j].\\n}"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "[@shreejaraj026](/shreejaraj026) if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }But I used this snippet in lcs function.. as per the logic it should pick let instead of lee"
                    },
                    {
                        "username": "shreejaraj026",
                        "content": "In this testcase it\\'s picking up the \"lee\" as subsequence that\\'s why we getting result value as 433, if it would have picked up \"let\" as substring then we get 403."
                    }
                ]
            },
            {
                "id": 1763602,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem, but much easier than the one on yesterday! Like the longest common subsequence problem! A substring must be a subsequence, but a subsequence may be not a substring! One more hint: Use the following formula\n$$\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2* asciiSum(LCS)\n$$\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840645/c-several-recursiveiterative-dplcs-beats-9462/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) You can simplify your program by replacing  the line ```if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)``` in lcs(i, j) by ``` if s[i-1] == t[j-1]: dp[i][j] = ord(s[i-1])+lcs(i-1,j-1)```. At final, ``` return res-2*lcs(n, m)``` Everything goes OK!"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@_aka5h](/_aka5h) Now got the point thanks [@Akash Rai](/_aka5h)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) In your case, you can consider \"oo\" to be the LCS with maximum ASCII value. But In general, there is something even more important, that can be overlooked if we use the term LCS, here in this problem we are using LCS pattern and not exactly finding LCS. The idea is to find a subsequence with maximum ASCII value which is common to both given strings and that subsequence doesn't necessarily have to be the LCS of the 2 strings. There might be a case where a subsequence (which is common to both strings and is not LCS) have higher ASSCII sum than the actual LCS of the 2 strings."
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) \n```\nclass Solution:\n    def minimumDeleteSum(self, s: str, t: str) -> int:\n        # finding the lcs\n        def lcs(i,j):\n            if i == 0 or j == 0: return 0\n            if dp[i][j] != -1: return dp[i][j]\n            if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)\n            else: dp[i][j] = max(lcs(i-1,j), lcs(i,j-1))\n            return dp[i][j]\n        n,m = len(s),len(t)\n        dp = [[-1]*(m+1) for _ in range(n+1)]\n        lcs(n,m)\n        res = 0\n        # getting the actual string\n        i,j = n,m\n        string = ''\n        while i>0 and j>0:\n            if s[i-1] == t[j-1]: \n                string = s[i-1]+string\n                i,j = i-1,j-1\n            else:\n                if dp[i-1][j] > dp[i][j-1]: i -= 1\n                elif dp[i-1][j] < dp[i][j-1]: j -= 1\n                else:\n                    if ord(s[i-1]) > ord(t[j-1]): j -= 1\n                    else: i -= 1\n        for i in s: res += ord(i)\n        for i in t: res += ord(i)\n        for i in string: res -= ord(i)*2\n        return res\n```"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) Could you check the below code once..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) I\\'ve tried my 3 solutions. All outputs are 2255"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can you explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. asciiSum(s1) = 1620 asciiSum(s2) = 1079 and asciiSum(lcs) = 217 and according to your formula also it should be 2265 but expected output is 2255"
                    },
                    {
                        "username": "Yaswanth017",
                        "content": "The problem statement never mentioned anything about subsequence. Who else finds this misleading? Leetcode expects us to figure it out by looking at example 2🤷‍♂️🤦‍♂️"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "[@gadmo](/gadmo) Yeah but I\\'m new and when trying to come up with a solution I was confused why you couldn\\'t just delete \"de\" from delete to get lete and leet which are both equal ascvii wise. It never mentions sub sequence just sum which is the same no matter which order they are in. "
                    },
                    {
                        "username": "Princesah999",
                        "content": "I was doing this \\n\\n// delete => deeelt\\n// leet   => eelt"
                    },
                    {
                        "username": "betaev",
                        "content": "[@gadmo](/gadmo) it\\'s longest common subsequence inversed"
                    },
                    {
                        "username": "gadmo",
                        "content": "you don\\'t need to think about subsequence at all to solve this, its almost textbook edit distance."
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Consider this problem as a variation of LCS.\\n"
                    },
                    {
                        "username": "ido.shamir.ido",
                        "content": "I might be missing something here but isn\\'t Example 2 wrong?\\nInput: s1 = \"delete\", s2 = \"leet\"\\nWe can delete \"de\" from s1 and nothing from s2. The strings will be equal (unordered) leet = lete and the sum will be smaller."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@Ido Shamir](/ido.shamir.ido)  This is because the order of the string can\\'t be changed we can only delete elements to make two string equal."
                    },
                    {
                        "username": "prathmesh-jagtap",
                        "content": "[@BlackMamba97](/BlackMamba97)  \\nYes the subsequences are always in contiguous."
                    },
                    {
                        "username": "BlackMamba97",
                        "content": "This is for ordered sequence.\\nRead the definition of subsequence. you will get the answer to your question."
                    },
                    {
                        "username": "paradoxtown",
                        "content": "All of us will become DP masters one day."
                    },
                    {
                        "username": "yurek16II",
                        "content": "Nice example, delete leet == forbidden ;)"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Output 403\\nExpected 403"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Nowadays its seems like DP day😂...everywhere it is present take it whether daily challenge or contest🙂"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "looks like a variation of LCS"
                    },
                    {
                        "username": "panieldark",
                        "content": "Second! Longest Common Subsequence for the win lol"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "# CAN ANYONE TELL ME WHAT AM I DOING WRONG? \\n\\n```\\nclass Solution {\\npublic:\\n    string lcs(string s1, string s2, vector<vector<int>> &dp, int lcslen){\\n        string lcsstring = \"\";\\n        int index = lcslen-1;\\n        for(int i =0; i < lcslen; ++i) lcsstring += \\'#\\';\\n        int i = s1.size(), j = s2.size();\\n        while(i > 0 && j > 0){\\n            if(s1[i-1] == s2[j-1]){\\n                lcsstring[index] = s1[i-1];\\n                index--;\\n                i--;\\n                j--;\\n            }else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    i--;\\n                }else if(dp[i-1][j] < dp[i][j-1]){\\n                    j--;\\n                }else{\\n                    if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return lcsstring;\\n    }\\n    int populatedp(string s1, string s2, vector<vector<int>> &dp) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        for(int i = 0; i <= n1; ++i) dp[i][0] = 0;\\n        for(int i = 0; i <= n2; ++i) dp[0][i] = 0;\\n        for(int ind1 = 1; ind1 <= n1; ++ind1){\\n            for(int ind2 = 1; ind2 <= n2; ++ind2){\\n                if(s1[ind1-1] == s2[ind2-1]){\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                }else if(s1[ind1-1] != s2[ind2-1]){\\n                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int ret = 0, n1 = s1.size(), n2 = s2.size();\\n        for(auto& x: s1) ret += x;\\n        for(auto &x: s2 ) ret += x;\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        int lcslen = populatedp(s1,s2,dp);\\n        for(int i = 0; i <= n1; ++i){\\n            for(int j = 0; j <= n2; ++j){\\n                cout << dp[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        string s = lcs(s1,s2,dp,lcslen);\\n        for(int i = 0; i < 2; ++i) for(auto &x: s) ret -= x;\\n        return ret;\\n    }\\n};\\n\\n```\\nInput\\ns1 =\\n\"delete\"\\ns2 =\\n\"leet\"\\nStdout\\n0 0 0 0 0 \\n0 0 0 0 0 \\n0 0 1 1 1 \\n0 1 1 1 1 \\n0 1 2 2 2 \\n0 1 2 2 3 \\n0 1 2 3 3 \\nOutput\\n433\\nExpected\\n403"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Finding out the LCS having the maximum ASCII sum should be the task , but while backtracking and forming LCS , getting maximum ASCII sum one requires us to check for all LCS strings and then compare from it.\\n\\nAnd also in case of else {\\n      s1[i-1] < s2[j-1]\\n     Should be compared not s1[i] and s2[j].\\n}"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "[@shreejaraj026](/shreejaraj026) if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }But I used this snippet in lcs function.. as per the logic it should pick let instead of lee"
                    },
                    {
                        "username": "shreejaraj026",
                        "content": "In this testcase it\\'s picking up the \"lee\" as subsequence that\\'s why we getting result value as 433, if it would have picked up \"let\" as substring then we get 403."
                    }
                ]
            },
            {
                "id": 1985199,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem, but much easier than the one on yesterday! Like the longest common subsequence problem! A substring must be a subsequence, but a subsequence may be not a substring! One more hint: Use the following formula\n$$\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2* asciiSum(LCS)\n$$\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840645/c-several-recursiveiterative-dplcs-beats-9462/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) You can simplify your program by replacing  the line ```if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)``` in lcs(i, j) by ``` if s[i-1] == t[j-1]: dp[i][j] = ord(s[i-1])+lcs(i-1,j-1)```. At final, ``` return res-2*lcs(n, m)``` Everything goes OK!"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@_aka5h](/_aka5h) Now got the point thanks [@Akash Rai](/_aka5h)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) In your case, you can consider \"oo\" to be the LCS with maximum ASCII value. But In general, there is something even more important, that can be overlooked if we use the term LCS, here in this problem we are using LCS pattern and not exactly finding LCS. The idea is to find a subsequence with maximum ASCII value which is common to both given strings and that subsequence doesn't necessarily have to be the LCS of the 2 strings. There might be a case where a subsequence (which is common to both strings and is not LCS) have higher ASSCII sum than the actual LCS of the 2 strings."
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) \n```\nclass Solution:\n    def minimumDeleteSum(self, s: str, t: str) -> int:\n        # finding the lcs\n        def lcs(i,j):\n            if i == 0 or j == 0: return 0\n            if dp[i][j] != -1: return dp[i][j]\n            if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)\n            else: dp[i][j] = max(lcs(i-1,j), lcs(i,j-1))\n            return dp[i][j]\n        n,m = len(s),len(t)\n        dp = [[-1]*(m+1) for _ in range(n+1)]\n        lcs(n,m)\n        res = 0\n        # getting the actual string\n        i,j = n,m\n        string = ''\n        while i>0 and j>0:\n            if s[i-1] == t[j-1]: \n                string = s[i-1]+string\n                i,j = i-1,j-1\n            else:\n                if dp[i-1][j] > dp[i][j-1]: i -= 1\n                elif dp[i-1][j] < dp[i][j-1]: j -= 1\n                else:\n                    if ord(s[i-1]) > ord(t[j-1]): j -= 1\n                    else: i -= 1\n        for i in s: res += ord(i)\n        for i in t: res += ord(i)\n        for i in string: res -= ord(i)*2\n        return res\n```"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) Could you check the below code once..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) I\\'ve tried my 3 solutions. All outputs are 2255"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can you explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. asciiSum(s1) = 1620 asciiSum(s2) = 1079 and asciiSum(lcs) = 217 and according to your formula also it should be 2265 but expected output is 2255"
                    },
                    {
                        "username": "Yaswanth017",
                        "content": "The problem statement never mentioned anything about subsequence. Who else finds this misleading? Leetcode expects us to figure it out by looking at example 2🤷‍♂️🤦‍♂️"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "[@gadmo](/gadmo) Yeah but I\\'m new and when trying to come up with a solution I was confused why you couldn\\'t just delete \"de\" from delete to get lete and leet which are both equal ascvii wise. It never mentions sub sequence just sum which is the same no matter which order they are in. "
                    },
                    {
                        "username": "Princesah999",
                        "content": "I was doing this \\n\\n// delete => deeelt\\n// leet   => eelt"
                    },
                    {
                        "username": "betaev",
                        "content": "[@gadmo](/gadmo) it\\'s longest common subsequence inversed"
                    },
                    {
                        "username": "gadmo",
                        "content": "you don\\'t need to think about subsequence at all to solve this, its almost textbook edit distance."
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Consider this problem as a variation of LCS.\\n"
                    },
                    {
                        "username": "ido.shamir.ido",
                        "content": "I might be missing something here but isn\\'t Example 2 wrong?\\nInput: s1 = \"delete\", s2 = \"leet\"\\nWe can delete \"de\" from s1 and nothing from s2. The strings will be equal (unordered) leet = lete and the sum will be smaller."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@Ido Shamir](/ido.shamir.ido)  This is because the order of the string can\\'t be changed we can only delete elements to make two string equal."
                    },
                    {
                        "username": "prathmesh-jagtap",
                        "content": "[@BlackMamba97](/BlackMamba97)  \\nYes the subsequences are always in contiguous."
                    },
                    {
                        "username": "BlackMamba97",
                        "content": "This is for ordered sequence.\\nRead the definition of subsequence. you will get the answer to your question."
                    },
                    {
                        "username": "paradoxtown",
                        "content": "All of us will become DP masters one day."
                    },
                    {
                        "username": "yurek16II",
                        "content": "Nice example, delete leet == forbidden ;)"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Output 403\\nExpected 403"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Nowadays its seems like DP day😂...everywhere it is present take it whether daily challenge or contest🙂"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "looks like a variation of LCS"
                    },
                    {
                        "username": "panieldark",
                        "content": "Second! Longest Common Subsequence for the win lol"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "# CAN ANYONE TELL ME WHAT AM I DOING WRONG? \\n\\n```\\nclass Solution {\\npublic:\\n    string lcs(string s1, string s2, vector<vector<int>> &dp, int lcslen){\\n        string lcsstring = \"\";\\n        int index = lcslen-1;\\n        for(int i =0; i < lcslen; ++i) lcsstring += \\'#\\';\\n        int i = s1.size(), j = s2.size();\\n        while(i > 0 && j > 0){\\n            if(s1[i-1] == s2[j-1]){\\n                lcsstring[index] = s1[i-1];\\n                index--;\\n                i--;\\n                j--;\\n            }else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    i--;\\n                }else if(dp[i-1][j] < dp[i][j-1]){\\n                    j--;\\n                }else{\\n                    if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return lcsstring;\\n    }\\n    int populatedp(string s1, string s2, vector<vector<int>> &dp) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        for(int i = 0; i <= n1; ++i) dp[i][0] = 0;\\n        for(int i = 0; i <= n2; ++i) dp[0][i] = 0;\\n        for(int ind1 = 1; ind1 <= n1; ++ind1){\\n            for(int ind2 = 1; ind2 <= n2; ++ind2){\\n                if(s1[ind1-1] == s2[ind2-1]){\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                }else if(s1[ind1-1] != s2[ind2-1]){\\n                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int ret = 0, n1 = s1.size(), n2 = s2.size();\\n        for(auto& x: s1) ret += x;\\n        for(auto &x: s2 ) ret += x;\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        int lcslen = populatedp(s1,s2,dp);\\n        for(int i = 0; i <= n1; ++i){\\n            for(int j = 0; j <= n2; ++j){\\n                cout << dp[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        string s = lcs(s1,s2,dp,lcslen);\\n        for(int i = 0; i < 2; ++i) for(auto &x: s) ret -= x;\\n        return ret;\\n    }\\n};\\n\\n```\\nInput\\ns1 =\\n\"delete\"\\ns2 =\\n\"leet\"\\nStdout\\n0 0 0 0 0 \\n0 0 0 0 0 \\n0 0 1 1 1 \\n0 1 1 1 1 \\n0 1 2 2 2 \\n0 1 2 2 3 \\n0 1 2 3 3 \\nOutput\\n433\\nExpected\\n403"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Finding out the LCS having the maximum ASCII sum should be the task , but while backtracking and forming LCS , getting maximum ASCII sum one requires us to check for all LCS strings and then compare from it.\\n\\nAnd also in case of else {\\n      s1[i-1] < s2[j-1]\\n     Should be compared not s1[i] and s2[j].\\n}"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "[@shreejaraj026](/shreejaraj026) if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }But I used this snippet in lcs function.. as per the logic it should pick let instead of lee"
                    },
                    {
                        "username": "shreejaraj026",
                        "content": "In this testcase it\\'s picking up the \"lee\" as subsequence that\\'s why we getting result value as 433, if it would have picked up \"let\" as substring then we get 403."
                    }
                ]
            },
            {
                "id": 1572097,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem, but much easier than the one on yesterday! Like the longest common subsequence problem! A substring must be a subsequence, but a subsequence may be not a substring! One more hint: Use the following formula\n$$\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2* asciiSum(LCS)\n$$\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840645/c-several-recursiveiterative-dplcs-beats-9462/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) You can simplify your program by replacing  the line ```if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)``` in lcs(i, j) by ``` if s[i-1] == t[j-1]: dp[i][j] = ord(s[i-1])+lcs(i-1,j-1)```. At final, ``` return res-2*lcs(n, m)``` Everything goes OK!"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@_aka5h](/_aka5h) Now got the point thanks [@Akash Rai](/_aka5h)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) In your case, you can consider \"oo\" to be the LCS with maximum ASCII value. But In general, there is something even more important, that can be overlooked if we use the term LCS, here in this problem we are using LCS pattern and not exactly finding LCS. The idea is to find a subsequence with maximum ASCII value which is common to both given strings and that subsequence doesn't necessarily have to be the LCS of the 2 strings. There might be a case where a subsequence (which is common to both strings and is not LCS) have higher ASSCII sum than the actual LCS of the 2 strings."
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) \n```\nclass Solution:\n    def minimumDeleteSum(self, s: str, t: str) -> int:\n        # finding the lcs\n        def lcs(i,j):\n            if i == 0 or j == 0: return 0\n            if dp[i][j] != -1: return dp[i][j]\n            if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)\n            else: dp[i][j] = max(lcs(i-1,j), lcs(i,j-1))\n            return dp[i][j]\n        n,m = len(s),len(t)\n        dp = [[-1]*(m+1) for _ in range(n+1)]\n        lcs(n,m)\n        res = 0\n        # getting the actual string\n        i,j = n,m\n        string = ''\n        while i>0 and j>0:\n            if s[i-1] == t[j-1]: \n                string = s[i-1]+string\n                i,j = i-1,j-1\n            else:\n                if dp[i-1][j] > dp[i][j-1]: i -= 1\n                elif dp[i-1][j] < dp[i][j-1]: j -= 1\n                else:\n                    if ord(s[i-1]) > ord(t[j-1]): j -= 1\n                    else: i -= 1\n        for i in s: res += ord(i)\n        for i in t: res += ord(i)\n        for i in string: res -= ord(i)*2\n        return res\n```"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) Could you check the below code once..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) I\\'ve tried my 3 solutions. All outputs are 2255"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can you explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. asciiSum(s1) = 1620 asciiSum(s2) = 1079 and asciiSum(lcs) = 217 and according to your formula also it should be 2265 but expected output is 2255"
                    },
                    {
                        "username": "Yaswanth017",
                        "content": "The problem statement never mentioned anything about subsequence. Who else finds this misleading? Leetcode expects us to figure it out by looking at example 2🤷‍♂️🤦‍♂️"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "[@gadmo](/gadmo) Yeah but I\\'m new and when trying to come up with a solution I was confused why you couldn\\'t just delete \"de\" from delete to get lete and leet which are both equal ascvii wise. It never mentions sub sequence just sum which is the same no matter which order they are in. "
                    },
                    {
                        "username": "Princesah999",
                        "content": "I was doing this \\n\\n// delete => deeelt\\n// leet   => eelt"
                    },
                    {
                        "username": "betaev",
                        "content": "[@gadmo](/gadmo) it\\'s longest common subsequence inversed"
                    },
                    {
                        "username": "gadmo",
                        "content": "you don\\'t need to think about subsequence at all to solve this, its almost textbook edit distance."
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Consider this problem as a variation of LCS.\\n"
                    },
                    {
                        "username": "ido.shamir.ido",
                        "content": "I might be missing something here but isn\\'t Example 2 wrong?\\nInput: s1 = \"delete\", s2 = \"leet\"\\nWe can delete \"de\" from s1 and nothing from s2. The strings will be equal (unordered) leet = lete and the sum will be smaller."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@Ido Shamir](/ido.shamir.ido)  This is because the order of the string can\\'t be changed we can only delete elements to make two string equal."
                    },
                    {
                        "username": "prathmesh-jagtap",
                        "content": "[@BlackMamba97](/BlackMamba97)  \\nYes the subsequences are always in contiguous."
                    },
                    {
                        "username": "BlackMamba97",
                        "content": "This is for ordered sequence.\\nRead the definition of subsequence. you will get the answer to your question."
                    },
                    {
                        "username": "paradoxtown",
                        "content": "All of us will become DP masters one day."
                    },
                    {
                        "username": "yurek16II",
                        "content": "Nice example, delete leet == forbidden ;)"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Output 403\\nExpected 403"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Nowadays its seems like DP day😂...everywhere it is present take it whether daily challenge or contest🙂"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "looks like a variation of LCS"
                    },
                    {
                        "username": "panieldark",
                        "content": "Second! Longest Common Subsequence for the win lol"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "# CAN ANYONE TELL ME WHAT AM I DOING WRONG? \\n\\n```\\nclass Solution {\\npublic:\\n    string lcs(string s1, string s2, vector<vector<int>> &dp, int lcslen){\\n        string lcsstring = \"\";\\n        int index = lcslen-1;\\n        for(int i =0; i < lcslen; ++i) lcsstring += \\'#\\';\\n        int i = s1.size(), j = s2.size();\\n        while(i > 0 && j > 0){\\n            if(s1[i-1] == s2[j-1]){\\n                lcsstring[index] = s1[i-1];\\n                index--;\\n                i--;\\n                j--;\\n            }else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    i--;\\n                }else if(dp[i-1][j] < dp[i][j-1]){\\n                    j--;\\n                }else{\\n                    if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return lcsstring;\\n    }\\n    int populatedp(string s1, string s2, vector<vector<int>> &dp) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        for(int i = 0; i <= n1; ++i) dp[i][0] = 0;\\n        for(int i = 0; i <= n2; ++i) dp[0][i] = 0;\\n        for(int ind1 = 1; ind1 <= n1; ++ind1){\\n            for(int ind2 = 1; ind2 <= n2; ++ind2){\\n                if(s1[ind1-1] == s2[ind2-1]){\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                }else if(s1[ind1-1] != s2[ind2-1]){\\n                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int ret = 0, n1 = s1.size(), n2 = s2.size();\\n        for(auto& x: s1) ret += x;\\n        for(auto &x: s2 ) ret += x;\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        int lcslen = populatedp(s1,s2,dp);\\n        for(int i = 0; i <= n1; ++i){\\n            for(int j = 0; j <= n2; ++j){\\n                cout << dp[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        string s = lcs(s1,s2,dp,lcslen);\\n        for(int i = 0; i < 2; ++i) for(auto &x: s) ret -= x;\\n        return ret;\\n    }\\n};\\n\\n```\\nInput\\ns1 =\\n\"delete\"\\ns2 =\\n\"leet\"\\nStdout\\n0 0 0 0 0 \\n0 0 0 0 0 \\n0 0 1 1 1 \\n0 1 1 1 1 \\n0 1 2 2 2 \\n0 1 2 2 3 \\n0 1 2 3 3 \\nOutput\\n433\\nExpected\\n403"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Finding out the LCS having the maximum ASCII sum should be the task , but while backtracking and forming LCS , getting maximum ASCII sum one requires us to check for all LCS strings and then compare from it.\\n\\nAnd also in case of else {\\n      s1[i-1] < s2[j-1]\\n     Should be compared not s1[i] and s2[j].\\n}"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "[@shreejaraj026](/shreejaraj026) if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }But I used this snippet in lcs function.. as per the logic it should pick let instead of lee"
                    },
                    {
                        "username": "shreejaraj026",
                        "content": "In this testcase it\\'s picking up the \"lee\" as subsequence that\\'s why we getting result value as 433, if it would have picked up \"let\" as substring then we get 403."
                    }
                ]
            },
            {
                "id": 1994213,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem, but much easier than the one on yesterday! Like the longest common subsequence problem! A substring must be a subsequence, but a subsequence may be not a substring! One more hint: Use the following formula\n$$\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2* asciiSum(LCS)\n$$\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840645/c-several-recursiveiterative-dplcs-beats-9462/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) You can simplify your program by replacing  the line ```if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)``` in lcs(i, j) by ``` if s[i-1] == t[j-1]: dp[i][j] = ord(s[i-1])+lcs(i-1,j-1)```. At final, ``` return res-2*lcs(n, m)``` Everything goes OK!"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@_aka5h](/_aka5h) Now got the point thanks [@Akash Rai](/_aka5h)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) In your case, you can consider \"oo\" to be the LCS with maximum ASCII value. But In general, there is something even more important, that can be overlooked if we use the term LCS, here in this problem we are using LCS pattern and not exactly finding LCS. The idea is to find a subsequence with maximum ASCII value which is common to both given strings and that subsequence doesn't necessarily have to be the LCS of the 2 strings. There might be a case where a subsequence (which is common to both strings and is not LCS) have higher ASSCII sum than the actual LCS of the 2 strings."
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) \n```\nclass Solution:\n    def minimumDeleteSum(self, s: str, t: str) -> int:\n        # finding the lcs\n        def lcs(i,j):\n            if i == 0 or j == 0: return 0\n            if dp[i][j] != -1: return dp[i][j]\n            if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)\n            else: dp[i][j] = max(lcs(i-1,j), lcs(i,j-1))\n            return dp[i][j]\n        n,m = len(s),len(t)\n        dp = [[-1]*(m+1) for _ in range(n+1)]\n        lcs(n,m)\n        res = 0\n        # getting the actual string\n        i,j = n,m\n        string = ''\n        while i>0 and j>0:\n            if s[i-1] == t[j-1]: \n                string = s[i-1]+string\n                i,j = i-1,j-1\n            else:\n                if dp[i-1][j] > dp[i][j-1]: i -= 1\n                elif dp[i-1][j] < dp[i][j-1]: j -= 1\n                else:\n                    if ord(s[i-1]) > ord(t[j-1]): j -= 1\n                    else: i -= 1\n        for i in s: res += ord(i)\n        for i in t: res += ord(i)\n        for i in string: res -= ord(i)*2\n        return res\n```"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) Could you check the below code once..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) I\\'ve tried my 3 solutions. All outputs are 2255"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can you explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. asciiSum(s1) = 1620 asciiSum(s2) = 1079 and asciiSum(lcs) = 217 and according to your formula also it should be 2265 but expected output is 2255"
                    },
                    {
                        "username": "Yaswanth017",
                        "content": "The problem statement never mentioned anything about subsequence. Who else finds this misleading? Leetcode expects us to figure it out by looking at example 2🤷‍♂️🤦‍♂️"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "[@gadmo](/gadmo) Yeah but I\\'m new and when trying to come up with a solution I was confused why you couldn\\'t just delete \"de\" from delete to get lete and leet which are both equal ascvii wise. It never mentions sub sequence just sum which is the same no matter which order they are in. "
                    },
                    {
                        "username": "Princesah999",
                        "content": "I was doing this \\n\\n// delete => deeelt\\n// leet   => eelt"
                    },
                    {
                        "username": "betaev",
                        "content": "[@gadmo](/gadmo) it\\'s longest common subsequence inversed"
                    },
                    {
                        "username": "gadmo",
                        "content": "you don\\'t need to think about subsequence at all to solve this, its almost textbook edit distance."
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Consider this problem as a variation of LCS.\\n"
                    },
                    {
                        "username": "ido.shamir.ido",
                        "content": "I might be missing something here but isn\\'t Example 2 wrong?\\nInput: s1 = \"delete\", s2 = \"leet\"\\nWe can delete \"de\" from s1 and nothing from s2. The strings will be equal (unordered) leet = lete and the sum will be smaller."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@Ido Shamir](/ido.shamir.ido)  This is because the order of the string can\\'t be changed we can only delete elements to make two string equal."
                    },
                    {
                        "username": "prathmesh-jagtap",
                        "content": "[@BlackMamba97](/BlackMamba97)  \\nYes the subsequences are always in contiguous."
                    },
                    {
                        "username": "BlackMamba97",
                        "content": "This is for ordered sequence.\\nRead the definition of subsequence. you will get the answer to your question."
                    },
                    {
                        "username": "paradoxtown",
                        "content": "All of us will become DP masters one day."
                    },
                    {
                        "username": "yurek16II",
                        "content": "Nice example, delete leet == forbidden ;)"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Output 403\\nExpected 403"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Nowadays its seems like DP day😂...everywhere it is present take it whether daily challenge or contest🙂"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "looks like a variation of LCS"
                    },
                    {
                        "username": "panieldark",
                        "content": "Second! Longest Common Subsequence for the win lol"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "# CAN ANYONE TELL ME WHAT AM I DOING WRONG? \\n\\n```\\nclass Solution {\\npublic:\\n    string lcs(string s1, string s2, vector<vector<int>> &dp, int lcslen){\\n        string lcsstring = \"\";\\n        int index = lcslen-1;\\n        for(int i =0; i < lcslen; ++i) lcsstring += \\'#\\';\\n        int i = s1.size(), j = s2.size();\\n        while(i > 0 && j > 0){\\n            if(s1[i-1] == s2[j-1]){\\n                lcsstring[index] = s1[i-1];\\n                index--;\\n                i--;\\n                j--;\\n            }else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    i--;\\n                }else if(dp[i-1][j] < dp[i][j-1]){\\n                    j--;\\n                }else{\\n                    if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return lcsstring;\\n    }\\n    int populatedp(string s1, string s2, vector<vector<int>> &dp) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        for(int i = 0; i <= n1; ++i) dp[i][0] = 0;\\n        for(int i = 0; i <= n2; ++i) dp[0][i] = 0;\\n        for(int ind1 = 1; ind1 <= n1; ++ind1){\\n            for(int ind2 = 1; ind2 <= n2; ++ind2){\\n                if(s1[ind1-1] == s2[ind2-1]){\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                }else if(s1[ind1-1] != s2[ind2-1]){\\n                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int ret = 0, n1 = s1.size(), n2 = s2.size();\\n        for(auto& x: s1) ret += x;\\n        for(auto &x: s2 ) ret += x;\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        int lcslen = populatedp(s1,s2,dp);\\n        for(int i = 0; i <= n1; ++i){\\n            for(int j = 0; j <= n2; ++j){\\n                cout << dp[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        string s = lcs(s1,s2,dp,lcslen);\\n        for(int i = 0; i < 2; ++i) for(auto &x: s) ret -= x;\\n        return ret;\\n    }\\n};\\n\\n```\\nInput\\ns1 =\\n\"delete\"\\ns2 =\\n\"leet\"\\nStdout\\n0 0 0 0 0 \\n0 0 0 0 0 \\n0 0 1 1 1 \\n0 1 1 1 1 \\n0 1 2 2 2 \\n0 1 2 2 3 \\n0 1 2 3 3 \\nOutput\\n433\\nExpected\\n403"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Finding out the LCS having the maximum ASCII sum should be the task , but while backtracking and forming LCS , getting maximum ASCII sum one requires us to check for all LCS strings and then compare from it.\\n\\nAnd also in case of else {\\n      s1[i-1] < s2[j-1]\\n     Should be compared not s1[i] and s2[j].\\n}"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "[@shreejaraj026](/shreejaraj026) if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }But I used this snippet in lcs function.. as per the logic it should pick let instead of lee"
                    },
                    {
                        "username": "shreejaraj026",
                        "content": "In this testcase it\\'s picking up the \"lee\" as subsequence that\\'s why we getting result value as 433, if it would have picked up \"let\" as substring then we get 403."
                    }
                ]
            },
            {
                "id": 1994104,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem, but much easier than the one on yesterday! Like the longest common subsequence problem! A substring must be a subsequence, but a subsequence may be not a substring! One more hint: Use the following formula\n$$\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2* asciiSum(LCS)\n$$\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840645/c-several-recursiveiterative-dplcs-beats-9462/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) You can simplify your program by replacing  the line ```if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)``` in lcs(i, j) by ``` if s[i-1] == t[j-1]: dp[i][j] = ord(s[i-1])+lcs(i-1,j-1)```. At final, ``` return res-2*lcs(n, m)``` Everything goes OK!"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@_aka5h](/_aka5h) Now got the point thanks [@Akash Rai](/_aka5h)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) In your case, you can consider \"oo\" to be the LCS with maximum ASCII value. But In general, there is something even more important, that can be overlooked if we use the term LCS, here in this problem we are using LCS pattern and not exactly finding LCS. The idea is to find a subsequence with maximum ASCII value which is common to both given strings and that subsequence doesn't necessarily have to be the LCS of the 2 strings. There might be a case where a subsequence (which is common to both strings and is not LCS) have higher ASSCII sum than the actual LCS of the 2 strings."
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) \n```\nclass Solution:\n    def minimumDeleteSum(self, s: str, t: str) -> int:\n        # finding the lcs\n        def lcs(i,j):\n            if i == 0 or j == 0: return 0\n            if dp[i][j] != -1: return dp[i][j]\n            if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)\n            else: dp[i][j] = max(lcs(i-1,j), lcs(i,j-1))\n            return dp[i][j]\n        n,m = len(s),len(t)\n        dp = [[-1]*(m+1) for _ in range(n+1)]\n        lcs(n,m)\n        res = 0\n        # getting the actual string\n        i,j = n,m\n        string = ''\n        while i>0 and j>0:\n            if s[i-1] == t[j-1]: \n                string = s[i-1]+string\n                i,j = i-1,j-1\n            else:\n                if dp[i-1][j] > dp[i][j-1]: i -= 1\n                elif dp[i-1][j] < dp[i][j-1]: j -= 1\n                else:\n                    if ord(s[i-1]) > ord(t[j-1]): j -= 1\n                    else: i -= 1\n        for i in s: res += ord(i)\n        for i in t: res += ord(i)\n        for i in string: res -= ord(i)*2\n        return res\n```"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) Could you check the below code once..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) I\\'ve tried my 3 solutions. All outputs are 2255"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can you explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. asciiSum(s1) = 1620 asciiSum(s2) = 1079 and asciiSum(lcs) = 217 and according to your formula also it should be 2265 but expected output is 2255"
                    },
                    {
                        "username": "Yaswanth017",
                        "content": "The problem statement never mentioned anything about subsequence. Who else finds this misleading? Leetcode expects us to figure it out by looking at example 2🤷‍♂️🤦‍♂️"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "[@gadmo](/gadmo) Yeah but I\\'m new and when trying to come up with a solution I was confused why you couldn\\'t just delete \"de\" from delete to get lete and leet which are both equal ascvii wise. It never mentions sub sequence just sum which is the same no matter which order they are in. "
                    },
                    {
                        "username": "Princesah999",
                        "content": "I was doing this \\n\\n// delete => deeelt\\n// leet   => eelt"
                    },
                    {
                        "username": "betaev",
                        "content": "[@gadmo](/gadmo) it\\'s longest common subsequence inversed"
                    },
                    {
                        "username": "gadmo",
                        "content": "you don\\'t need to think about subsequence at all to solve this, its almost textbook edit distance."
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Consider this problem as a variation of LCS.\\n"
                    },
                    {
                        "username": "ido.shamir.ido",
                        "content": "I might be missing something here but isn\\'t Example 2 wrong?\\nInput: s1 = \"delete\", s2 = \"leet\"\\nWe can delete \"de\" from s1 and nothing from s2. The strings will be equal (unordered) leet = lete and the sum will be smaller."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@Ido Shamir](/ido.shamir.ido)  This is because the order of the string can\\'t be changed we can only delete elements to make two string equal."
                    },
                    {
                        "username": "prathmesh-jagtap",
                        "content": "[@BlackMamba97](/BlackMamba97)  \\nYes the subsequences are always in contiguous."
                    },
                    {
                        "username": "BlackMamba97",
                        "content": "This is for ordered sequence.\\nRead the definition of subsequence. you will get the answer to your question."
                    },
                    {
                        "username": "paradoxtown",
                        "content": "All of us will become DP masters one day."
                    },
                    {
                        "username": "yurek16II",
                        "content": "Nice example, delete leet == forbidden ;)"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Output 403\\nExpected 403"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Nowadays its seems like DP day😂...everywhere it is present take it whether daily challenge or contest🙂"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "looks like a variation of LCS"
                    },
                    {
                        "username": "panieldark",
                        "content": "Second! Longest Common Subsequence for the win lol"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "# CAN ANYONE TELL ME WHAT AM I DOING WRONG? \\n\\n```\\nclass Solution {\\npublic:\\n    string lcs(string s1, string s2, vector<vector<int>> &dp, int lcslen){\\n        string lcsstring = \"\";\\n        int index = lcslen-1;\\n        for(int i =0; i < lcslen; ++i) lcsstring += \\'#\\';\\n        int i = s1.size(), j = s2.size();\\n        while(i > 0 && j > 0){\\n            if(s1[i-1] == s2[j-1]){\\n                lcsstring[index] = s1[i-1];\\n                index--;\\n                i--;\\n                j--;\\n            }else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    i--;\\n                }else if(dp[i-1][j] < dp[i][j-1]){\\n                    j--;\\n                }else{\\n                    if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return lcsstring;\\n    }\\n    int populatedp(string s1, string s2, vector<vector<int>> &dp) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        for(int i = 0; i <= n1; ++i) dp[i][0] = 0;\\n        for(int i = 0; i <= n2; ++i) dp[0][i] = 0;\\n        for(int ind1 = 1; ind1 <= n1; ++ind1){\\n            for(int ind2 = 1; ind2 <= n2; ++ind2){\\n                if(s1[ind1-1] == s2[ind2-1]){\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                }else if(s1[ind1-1] != s2[ind2-1]){\\n                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int ret = 0, n1 = s1.size(), n2 = s2.size();\\n        for(auto& x: s1) ret += x;\\n        for(auto &x: s2 ) ret += x;\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        int lcslen = populatedp(s1,s2,dp);\\n        for(int i = 0; i <= n1; ++i){\\n            for(int j = 0; j <= n2; ++j){\\n                cout << dp[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        string s = lcs(s1,s2,dp,lcslen);\\n        for(int i = 0; i < 2; ++i) for(auto &x: s) ret -= x;\\n        return ret;\\n    }\\n};\\n\\n```\\nInput\\ns1 =\\n\"delete\"\\ns2 =\\n\"leet\"\\nStdout\\n0 0 0 0 0 \\n0 0 0 0 0 \\n0 0 1 1 1 \\n0 1 1 1 1 \\n0 1 2 2 2 \\n0 1 2 2 3 \\n0 1 2 3 3 \\nOutput\\n433\\nExpected\\n403"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Finding out the LCS having the maximum ASCII sum should be the task , but while backtracking and forming LCS , getting maximum ASCII sum one requires us to check for all LCS strings and then compare from it.\\n\\nAnd also in case of else {\\n      s1[i-1] < s2[j-1]\\n     Should be compared not s1[i] and s2[j].\\n}"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "[@shreejaraj026](/shreejaraj026) if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }But I used this snippet in lcs function.. as per the logic it should pick let instead of lee"
                    },
                    {
                        "username": "shreejaraj026",
                        "content": "In this testcase it\\'s picking up the \"lee\" as subsequence that\\'s why we getting result value as 433, if it would have picked up \"let\" as substring then we get 403."
                    }
                ]
            },
            {
                "id": 1993732,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem, but much easier than the one on yesterday! Like the longest common subsequence problem! A substring must be a subsequence, but a subsequence may be not a substring! One more hint: Use the following formula\n$$\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2* asciiSum(LCS)\n$$\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840645/c-several-recursiveiterative-dplcs-beats-9462/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) You can simplify your program by replacing  the line ```if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)``` in lcs(i, j) by ``` if s[i-1] == t[j-1]: dp[i][j] = ord(s[i-1])+lcs(i-1,j-1)```. At final, ``` return res-2*lcs(n, m)``` Everything goes OK!"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@_aka5h](/_aka5h) Now got the point thanks [@Akash Rai](/_aka5h)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) In your case, you can consider \"oo\" to be the LCS with maximum ASCII value. But In general, there is something even more important, that can be overlooked if we use the term LCS, here in this problem we are using LCS pattern and not exactly finding LCS. The idea is to find a subsequence with maximum ASCII value which is common to both given strings and that subsequence doesn't necessarily have to be the LCS of the 2 strings. There might be a case where a subsequence (which is common to both strings and is not LCS) have higher ASSCII sum than the actual LCS of the 2 strings."
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) \n```\nclass Solution:\n    def minimumDeleteSum(self, s: str, t: str) -> int:\n        # finding the lcs\n        def lcs(i,j):\n            if i == 0 or j == 0: return 0\n            if dp[i][j] != -1: return dp[i][j]\n            if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)\n            else: dp[i][j] = max(lcs(i-1,j), lcs(i,j-1))\n            return dp[i][j]\n        n,m = len(s),len(t)\n        dp = [[-1]*(m+1) for _ in range(n+1)]\n        lcs(n,m)\n        res = 0\n        # getting the actual string\n        i,j = n,m\n        string = ''\n        while i>0 and j>0:\n            if s[i-1] == t[j-1]: \n                string = s[i-1]+string\n                i,j = i-1,j-1\n            else:\n                if dp[i-1][j] > dp[i][j-1]: i -= 1\n                elif dp[i-1][j] < dp[i][j-1]: j -= 1\n                else:\n                    if ord(s[i-1]) > ord(t[j-1]): j -= 1\n                    else: i -= 1\n        for i in s: res += ord(i)\n        for i in t: res += ord(i)\n        for i in string: res -= ord(i)*2\n        return res\n```"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) Could you check the below code once..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) I\\'ve tried my 3 solutions. All outputs are 2255"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can you explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. asciiSum(s1) = 1620 asciiSum(s2) = 1079 and asciiSum(lcs) = 217 and according to your formula also it should be 2265 but expected output is 2255"
                    },
                    {
                        "username": "Yaswanth017",
                        "content": "The problem statement never mentioned anything about subsequence. Who else finds this misleading? Leetcode expects us to figure it out by looking at example 2🤷‍♂️🤦‍♂️"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "[@gadmo](/gadmo) Yeah but I\\'m new and when trying to come up with a solution I was confused why you couldn\\'t just delete \"de\" from delete to get lete and leet which are both equal ascvii wise. It never mentions sub sequence just sum which is the same no matter which order they are in. "
                    },
                    {
                        "username": "Princesah999",
                        "content": "I was doing this \\n\\n// delete => deeelt\\n// leet   => eelt"
                    },
                    {
                        "username": "betaev",
                        "content": "[@gadmo](/gadmo) it\\'s longest common subsequence inversed"
                    },
                    {
                        "username": "gadmo",
                        "content": "you don\\'t need to think about subsequence at all to solve this, its almost textbook edit distance."
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Consider this problem as a variation of LCS.\\n"
                    },
                    {
                        "username": "ido.shamir.ido",
                        "content": "I might be missing something here but isn\\'t Example 2 wrong?\\nInput: s1 = \"delete\", s2 = \"leet\"\\nWe can delete \"de\" from s1 and nothing from s2. The strings will be equal (unordered) leet = lete and the sum will be smaller."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@Ido Shamir](/ido.shamir.ido)  This is because the order of the string can\\'t be changed we can only delete elements to make two string equal."
                    },
                    {
                        "username": "prathmesh-jagtap",
                        "content": "[@BlackMamba97](/BlackMamba97)  \\nYes the subsequences are always in contiguous."
                    },
                    {
                        "username": "BlackMamba97",
                        "content": "This is for ordered sequence.\\nRead the definition of subsequence. you will get the answer to your question."
                    },
                    {
                        "username": "paradoxtown",
                        "content": "All of us will become DP masters one day."
                    },
                    {
                        "username": "yurek16II",
                        "content": "Nice example, delete leet == forbidden ;)"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Output 403\\nExpected 403"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Nowadays its seems like DP day😂...everywhere it is present take it whether daily challenge or contest🙂"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "looks like a variation of LCS"
                    },
                    {
                        "username": "panieldark",
                        "content": "Second! Longest Common Subsequence for the win lol"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "# CAN ANYONE TELL ME WHAT AM I DOING WRONG? \\n\\n```\\nclass Solution {\\npublic:\\n    string lcs(string s1, string s2, vector<vector<int>> &dp, int lcslen){\\n        string lcsstring = \"\";\\n        int index = lcslen-1;\\n        for(int i =0; i < lcslen; ++i) lcsstring += \\'#\\';\\n        int i = s1.size(), j = s2.size();\\n        while(i > 0 && j > 0){\\n            if(s1[i-1] == s2[j-1]){\\n                lcsstring[index] = s1[i-1];\\n                index--;\\n                i--;\\n                j--;\\n            }else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    i--;\\n                }else if(dp[i-1][j] < dp[i][j-1]){\\n                    j--;\\n                }else{\\n                    if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return lcsstring;\\n    }\\n    int populatedp(string s1, string s2, vector<vector<int>> &dp) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        for(int i = 0; i <= n1; ++i) dp[i][0] = 0;\\n        for(int i = 0; i <= n2; ++i) dp[0][i] = 0;\\n        for(int ind1 = 1; ind1 <= n1; ++ind1){\\n            for(int ind2 = 1; ind2 <= n2; ++ind2){\\n                if(s1[ind1-1] == s2[ind2-1]){\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                }else if(s1[ind1-1] != s2[ind2-1]){\\n                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int ret = 0, n1 = s1.size(), n2 = s2.size();\\n        for(auto& x: s1) ret += x;\\n        for(auto &x: s2 ) ret += x;\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        int lcslen = populatedp(s1,s2,dp);\\n        for(int i = 0; i <= n1; ++i){\\n            for(int j = 0; j <= n2; ++j){\\n                cout << dp[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        string s = lcs(s1,s2,dp,lcslen);\\n        for(int i = 0; i < 2; ++i) for(auto &x: s) ret -= x;\\n        return ret;\\n    }\\n};\\n\\n```\\nInput\\ns1 =\\n\"delete\"\\ns2 =\\n\"leet\"\\nStdout\\n0 0 0 0 0 \\n0 0 0 0 0 \\n0 0 1 1 1 \\n0 1 1 1 1 \\n0 1 2 2 2 \\n0 1 2 2 3 \\n0 1 2 3 3 \\nOutput\\n433\\nExpected\\n403"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Finding out the LCS having the maximum ASCII sum should be the task , but while backtracking and forming LCS , getting maximum ASCII sum one requires us to check for all LCS strings and then compare from it.\\n\\nAnd also in case of else {\\n      s1[i-1] < s2[j-1]\\n     Should be compared not s1[i] and s2[j].\\n}"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "[@shreejaraj026](/shreejaraj026) if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }But I used this snippet in lcs function.. as per the logic it should pick let instead of lee"
                    },
                    {
                        "username": "shreejaraj026",
                        "content": "In this testcase it\\'s picking up the \"lee\" as subsequence that\\'s why we getting result value as 433, if it would have picked up \"let\" as substring then we get 403."
                    }
                ]
            },
            {
                "id": 1993768,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem, but much easier than the one on yesterday! Like the longest common subsequence problem! A substring must be a subsequence, but a subsequence may be not a substring! One more hint: Use the following formula\n$$\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2* asciiSum(LCS)\n$$\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840645/c-several-recursiveiterative-dplcs-beats-9462/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) You can simplify your program by replacing  the line ```if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)``` in lcs(i, j) by ``` if s[i-1] == t[j-1]: dp[i][j] = ord(s[i-1])+lcs(i-1,j-1)```. At final, ``` return res-2*lcs(n, m)``` Everything goes OK!"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@_aka5h](/_aka5h) Now got the point thanks [@Akash Rai](/_aka5h)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) In your case, you can consider \"oo\" to be the LCS with maximum ASCII value. But In general, there is something even more important, that can be overlooked if we use the term LCS, here in this problem we are using LCS pattern and not exactly finding LCS. The idea is to find a subsequence with maximum ASCII value which is common to both given strings and that subsequence doesn't necessarily have to be the LCS of the 2 strings. There might be a case where a subsequence (which is common to both strings and is not LCS) have higher ASSCII sum than the actual LCS of the 2 strings."
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) \n```\nclass Solution:\n    def minimumDeleteSum(self, s: str, t: str) -> int:\n        # finding the lcs\n        def lcs(i,j):\n            if i == 0 or j == 0: return 0\n            if dp[i][j] != -1: return dp[i][j]\n            if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)\n            else: dp[i][j] = max(lcs(i-1,j), lcs(i,j-1))\n            return dp[i][j]\n        n,m = len(s),len(t)\n        dp = [[-1]*(m+1) for _ in range(n+1)]\n        lcs(n,m)\n        res = 0\n        # getting the actual string\n        i,j = n,m\n        string = ''\n        while i>0 and j>0:\n            if s[i-1] == t[j-1]: \n                string = s[i-1]+string\n                i,j = i-1,j-1\n            else:\n                if dp[i-1][j] > dp[i][j-1]: i -= 1\n                elif dp[i-1][j] < dp[i][j-1]: j -= 1\n                else:\n                    if ord(s[i-1]) > ord(t[j-1]): j -= 1\n                    else: i -= 1\n        for i in s: res += ord(i)\n        for i in t: res += ord(i)\n        for i in string: res -= ord(i)*2\n        return res\n```"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) Could you check the below code once..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) I\\'ve tried my 3 solutions. All outputs are 2255"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can you explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. asciiSum(s1) = 1620 asciiSum(s2) = 1079 and asciiSum(lcs) = 217 and according to your formula also it should be 2265 but expected output is 2255"
                    },
                    {
                        "username": "Yaswanth017",
                        "content": "The problem statement never mentioned anything about subsequence. Who else finds this misleading? Leetcode expects us to figure it out by looking at example 2🤷‍♂️🤦‍♂️"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "[@gadmo](/gadmo) Yeah but I\\'m new and when trying to come up with a solution I was confused why you couldn\\'t just delete \"de\" from delete to get lete and leet which are both equal ascvii wise. It never mentions sub sequence just sum which is the same no matter which order they are in. "
                    },
                    {
                        "username": "Princesah999",
                        "content": "I was doing this \\n\\n// delete => deeelt\\n// leet   => eelt"
                    },
                    {
                        "username": "betaev",
                        "content": "[@gadmo](/gadmo) it\\'s longest common subsequence inversed"
                    },
                    {
                        "username": "gadmo",
                        "content": "you don\\'t need to think about subsequence at all to solve this, its almost textbook edit distance."
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Consider this problem as a variation of LCS.\\n"
                    },
                    {
                        "username": "ido.shamir.ido",
                        "content": "I might be missing something here but isn\\'t Example 2 wrong?\\nInput: s1 = \"delete\", s2 = \"leet\"\\nWe can delete \"de\" from s1 and nothing from s2. The strings will be equal (unordered) leet = lete and the sum will be smaller."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@Ido Shamir](/ido.shamir.ido)  This is because the order of the string can\\'t be changed we can only delete elements to make two string equal."
                    },
                    {
                        "username": "prathmesh-jagtap",
                        "content": "[@BlackMamba97](/BlackMamba97)  \\nYes the subsequences are always in contiguous."
                    },
                    {
                        "username": "BlackMamba97",
                        "content": "This is for ordered sequence.\\nRead the definition of subsequence. you will get the answer to your question."
                    },
                    {
                        "username": "paradoxtown",
                        "content": "All of us will become DP masters one day."
                    },
                    {
                        "username": "yurek16II",
                        "content": "Nice example, delete leet == forbidden ;)"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Output 403\\nExpected 403"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Nowadays its seems like DP day😂...everywhere it is present take it whether daily challenge or contest🙂"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "looks like a variation of LCS"
                    },
                    {
                        "username": "panieldark",
                        "content": "Second! Longest Common Subsequence for the win lol"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "# CAN ANYONE TELL ME WHAT AM I DOING WRONG? \\n\\n```\\nclass Solution {\\npublic:\\n    string lcs(string s1, string s2, vector<vector<int>> &dp, int lcslen){\\n        string lcsstring = \"\";\\n        int index = lcslen-1;\\n        for(int i =0; i < lcslen; ++i) lcsstring += \\'#\\';\\n        int i = s1.size(), j = s2.size();\\n        while(i > 0 && j > 0){\\n            if(s1[i-1] == s2[j-1]){\\n                lcsstring[index] = s1[i-1];\\n                index--;\\n                i--;\\n                j--;\\n            }else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    i--;\\n                }else if(dp[i-1][j] < dp[i][j-1]){\\n                    j--;\\n                }else{\\n                    if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return lcsstring;\\n    }\\n    int populatedp(string s1, string s2, vector<vector<int>> &dp) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        for(int i = 0; i <= n1; ++i) dp[i][0] = 0;\\n        for(int i = 0; i <= n2; ++i) dp[0][i] = 0;\\n        for(int ind1 = 1; ind1 <= n1; ++ind1){\\n            for(int ind2 = 1; ind2 <= n2; ++ind2){\\n                if(s1[ind1-1] == s2[ind2-1]){\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                }else if(s1[ind1-1] != s2[ind2-1]){\\n                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int ret = 0, n1 = s1.size(), n2 = s2.size();\\n        for(auto& x: s1) ret += x;\\n        for(auto &x: s2 ) ret += x;\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        int lcslen = populatedp(s1,s2,dp);\\n        for(int i = 0; i <= n1; ++i){\\n            for(int j = 0; j <= n2; ++j){\\n                cout << dp[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        string s = lcs(s1,s2,dp,lcslen);\\n        for(int i = 0; i < 2; ++i) for(auto &x: s) ret -= x;\\n        return ret;\\n    }\\n};\\n\\n```\\nInput\\ns1 =\\n\"delete\"\\ns2 =\\n\"leet\"\\nStdout\\n0 0 0 0 0 \\n0 0 0 0 0 \\n0 0 1 1 1 \\n0 1 1 1 1 \\n0 1 2 2 2 \\n0 1 2 2 3 \\n0 1 2 3 3 \\nOutput\\n433\\nExpected\\n403"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Finding out the LCS having the maximum ASCII sum should be the task , but while backtracking and forming LCS , getting maximum ASCII sum one requires us to check for all LCS strings and then compare from it.\\n\\nAnd also in case of else {\\n      s1[i-1] < s2[j-1]\\n     Should be compared not s1[i] and s2[j].\\n}"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "[@shreejaraj026](/shreejaraj026) if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }But I used this snippet in lcs function.. as per the logic it should pick let instead of lee"
                    },
                    {
                        "username": "shreejaraj026",
                        "content": "In this testcase it\\'s picking up the \"lee\" as subsequence that\\'s why we getting result value as 433, if it would have picked up \"let\" as substring then we get 403."
                    }
                ]
            },
            {
                "id": 1712535,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem, but much easier than the one on yesterday! Like the longest common subsequence problem! A substring must be a subsequence, but a subsequence may be not a substring! One more hint: Use the following formula\n$$\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2* asciiSum(LCS)\n$$\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840645/c-several-recursiveiterative-dplcs-beats-9462/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) You can simplify your program by replacing  the line ```if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)``` in lcs(i, j) by ``` if s[i-1] == t[j-1]: dp[i][j] = ord(s[i-1])+lcs(i-1,j-1)```. At final, ``` return res-2*lcs(n, m)``` Everything goes OK!"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@_aka5h](/_aka5h) Now got the point thanks [@Akash Rai](/_aka5h)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) In your case, you can consider \"oo\" to be the LCS with maximum ASCII value. But In general, there is something even more important, that can be overlooked if we use the term LCS, here in this problem we are using LCS pattern and not exactly finding LCS. The idea is to find a subsequence with maximum ASCII value which is common to both given strings and that subsequence doesn't necessarily have to be the LCS of the 2 strings. There might be a case where a subsequence (which is common to both strings and is not LCS) have higher ASSCII sum than the actual LCS of the 2 strings."
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) \n```\nclass Solution:\n    def minimumDeleteSum(self, s: str, t: str) -> int:\n        # finding the lcs\n        def lcs(i,j):\n            if i == 0 or j == 0: return 0\n            if dp[i][j] != -1: return dp[i][j]\n            if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)\n            else: dp[i][j] = max(lcs(i-1,j), lcs(i,j-1))\n            return dp[i][j]\n        n,m = len(s),len(t)\n        dp = [[-1]*(m+1) for _ in range(n+1)]\n        lcs(n,m)\n        res = 0\n        # getting the actual string\n        i,j = n,m\n        string = ''\n        while i>0 and j>0:\n            if s[i-1] == t[j-1]: \n                string = s[i-1]+string\n                i,j = i-1,j-1\n            else:\n                if dp[i-1][j] > dp[i][j-1]: i -= 1\n                elif dp[i-1][j] < dp[i][j-1]: j -= 1\n                else:\n                    if ord(s[i-1]) > ord(t[j-1]): j -= 1\n                    else: i -= 1\n        for i in s: res += ord(i)\n        for i in t: res += ord(i)\n        for i in string: res -= ord(i)*2\n        return res\n```"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) Could you check the below code once..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) I\\'ve tried my 3 solutions. All outputs are 2255"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can you explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. asciiSum(s1) = 1620 asciiSum(s2) = 1079 and asciiSum(lcs) = 217 and according to your formula also it should be 2265 but expected output is 2255"
                    },
                    {
                        "username": "Yaswanth017",
                        "content": "The problem statement never mentioned anything about subsequence. Who else finds this misleading? Leetcode expects us to figure it out by looking at example 2🤷‍♂️🤦‍♂️"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "[@gadmo](/gadmo) Yeah but I\\'m new and when trying to come up with a solution I was confused why you couldn\\'t just delete \"de\" from delete to get lete and leet which are both equal ascvii wise. It never mentions sub sequence just sum which is the same no matter which order they are in. "
                    },
                    {
                        "username": "Princesah999",
                        "content": "I was doing this \\n\\n// delete => deeelt\\n// leet   => eelt"
                    },
                    {
                        "username": "betaev",
                        "content": "[@gadmo](/gadmo) it\\'s longest common subsequence inversed"
                    },
                    {
                        "username": "gadmo",
                        "content": "you don\\'t need to think about subsequence at all to solve this, its almost textbook edit distance."
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Consider this problem as a variation of LCS.\\n"
                    },
                    {
                        "username": "ido.shamir.ido",
                        "content": "I might be missing something here but isn\\'t Example 2 wrong?\\nInput: s1 = \"delete\", s2 = \"leet\"\\nWe can delete \"de\" from s1 and nothing from s2. The strings will be equal (unordered) leet = lete and the sum will be smaller."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@Ido Shamir](/ido.shamir.ido)  This is because the order of the string can\\'t be changed we can only delete elements to make two string equal."
                    },
                    {
                        "username": "prathmesh-jagtap",
                        "content": "[@BlackMamba97](/BlackMamba97)  \\nYes the subsequences are always in contiguous."
                    },
                    {
                        "username": "BlackMamba97",
                        "content": "This is for ordered sequence.\\nRead the definition of subsequence. you will get the answer to your question."
                    },
                    {
                        "username": "paradoxtown",
                        "content": "All of us will become DP masters one day."
                    },
                    {
                        "username": "yurek16II",
                        "content": "Nice example, delete leet == forbidden ;)"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Output 403\\nExpected 403"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Nowadays its seems like DP day😂...everywhere it is present take it whether daily challenge or contest🙂"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "looks like a variation of LCS"
                    },
                    {
                        "username": "panieldark",
                        "content": "Second! Longest Common Subsequence for the win lol"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "# CAN ANYONE TELL ME WHAT AM I DOING WRONG? \\n\\n```\\nclass Solution {\\npublic:\\n    string lcs(string s1, string s2, vector<vector<int>> &dp, int lcslen){\\n        string lcsstring = \"\";\\n        int index = lcslen-1;\\n        for(int i =0; i < lcslen; ++i) lcsstring += \\'#\\';\\n        int i = s1.size(), j = s2.size();\\n        while(i > 0 && j > 0){\\n            if(s1[i-1] == s2[j-1]){\\n                lcsstring[index] = s1[i-1];\\n                index--;\\n                i--;\\n                j--;\\n            }else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    i--;\\n                }else if(dp[i-1][j] < dp[i][j-1]){\\n                    j--;\\n                }else{\\n                    if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return lcsstring;\\n    }\\n    int populatedp(string s1, string s2, vector<vector<int>> &dp) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        for(int i = 0; i <= n1; ++i) dp[i][0] = 0;\\n        for(int i = 0; i <= n2; ++i) dp[0][i] = 0;\\n        for(int ind1 = 1; ind1 <= n1; ++ind1){\\n            for(int ind2 = 1; ind2 <= n2; ++ind2){\\n                if(s1[ind1-1] == s2[ind2-1]){\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                }else if(s1[ind1-1] != s2[ind2-1]){\\n                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int ret = 0, n1 = s1.size(), n2 = s2.size();\\n        for(auto& x: s1) ret += x;\\n        for(auto &x: s2 ) ret += x;\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        int lcslen = populatedp(s1,s2,dp);\\n        for(int i = 0; i <= n1; ++i){\\n            for(int j = 0; j <= n2; ++j){\\n                cout << dp[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        string s = lcs(s1,s2,dp,lcslen);\\n        for(int i = 0; i < 2; ++i) for(auto &x: s) ret -= x;\\n        return ret;\\n    }\\n};\\n\\n```\\nInput\\ns1 =\\n\"delete\"\\ns2 =\\n\"leet\"\\nStdout\\n0 0 0 0 0 \\n0 0 0 0 0 \\n0 0 1 1 1 \\n0 1 1 1 1 \\n0 1 2 2 2 \\n0 1 2 2 3 \\n0 1 2 3 3 \\nOutput\\n433\\nExpected\\n403"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Finding out the LCS having the maximum ASCII sum should be the task , but while backtracking and forming LCS , getting maximum ASCII sum one requires us to check for all LCS strings and then compare from it.\\n\\nAnd also in case of else {\\n      s1[i-1] < s2[j-1]\\n     Should be compared not s1[i] and s2[j].\\n}"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "[@shreejaraj026](/shreejaraj026) if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }But I used this snippet in lcs function.. as per the logic it should pick let instead of lee"
                    },
                    {
                        "username": "shreejaraj026",
                        "content": "In this testcase it\\'s picking up the \"lee\" as subsequence that\\'s why we getting result value as 433, if it would have picked up \"let\" as substring then we get 403."
                    }
                ]
            },
            {
                "id": 1994265,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem, but much easier than the one on yesterday! Like the longest common subsequence problem! A substring must be a subsequence, but a subsequence may be not a substring! One more hint: Use the following formula\n$$\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2* asciiSum(LCS)\n$$\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840645/c-several-recursiveiterative-dplcs-beats-9462/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) You can simplify your program by replacing  the line ```if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)``` in lcs(i, j) by ``` if s[i-1] == t[j-1]: dp[i][j] = ord(s[i-1])+lcs(i-1,j-1)```. At final, ``` return res-2*lcs(n, m)``` Everything goes OK!"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@_aka5h](/_aka5h) Now got the point thanks [@Akash Rai](/_aka5h)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) In your case, you can consider \"oo\" to be the LCS with maximum ASCII value. But In general, there is something even more important, that can be overlooked if we use the term LCS, here in this problem we are using LCS pattern and not exactly finding LCS. The idea is to find a subsequence with maximum ASCII value which is common to both given strings and that subsequence doesn't necessarily have to be the LCS of the 2 strings. There might be a case where a subsequence (which is common to both strings and is not LCS) have higher ASSCII sum than the actual LCS of the 2 strings."
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) \n```\nclass Solution:\n    def minimumDeleteSum(self, s: str, t: str) -> int:\n        # finding the lcs\n        def lcs(i,j):\n            if i == 0 or j == 0: return 0\n            if dp[i][j] != -1: return dp[i][j]\n            if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)\n            else: dp[i][j] = max(lcs(i-1,j), lcs(i,j-1))\n            return dp[i][j]\n        n,m = len(s),len(t)\n        dp = [[-1]*(m+1) for _ in range(n+1)]\n        lcs(n,m)\n        res = 0\n        # getting the actual string\n        i,j = n,m\n        string = ''\n        while i>0 and j>0:\n            if s[i-1] == t[j-1]: \n                string = s[i-1]+string\n                i,j = i-1,j-1\n            else:\n                if dp[i-1][j] > dp[i][j-1]: i -= 1\n                elif dp[i-1][j] < dp[i][j-1]: j -= 1\n                else:\n                    if ord(s[i-1]) > ord(t[j-1]): j -= 1\n                    else: i -= 1\n        for i in s: res += ord(i)\n        for i in t: res += ord(i)\n        for i in string: res -= ord(i)*2\n        return res\n```"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) Could you check the below code once..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) I\\'ve tried my 3 solutions. All outputs are 2255"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can you explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. asciiSum(s1) = 1620 asciiSum(s2) = 1079 and asciiSum(lcs) = 217 and according to your formula also it should be 2265 but expected output is 2255"
                    },
                    {
                        "username": "Yaswanth017",
                        "content": "The problem statement never mentioned anything about subsequence. Who else finds this misleading? Leetcode expects us to figure it out by looking at example 2🤷‍♂️🤦‍♂️"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "[@gadmo](/gadmo) Yeah but I\\'m new and when trying to come up with a solution I was confused why you couldn\\'t just delete \"de\" from delete to get lete and leet which are both equal ascvii wise. It never mentions sub sequence just sum which is the same no matter which order they are in. "
                    },
                    {
                        "username": "Princesah999",
                        "content": "I was doing this \\n\\n// delete => deeelt\\n// leet   => eelt"
                    },
                    {
                        "username": "betaev",
                        "content": "[@gadmo](/gadmo) it\\'s longest common subsequence inversed"
                    },
                    {
                        "username": "gadmo",
                        "content": "you don\\'t need to think about subsequence at all to solve this, its almost textbook edit distance."
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Consider this problem as a variation of LCS.\\n"
                    },
                    {
                        "username": "ido.shamir.ido",
                        "content": "I might be missing something here but isn\\'t Example 2 wrong?\\nInput: s1 = \"delete\", s2 = \"leet\"\\nWe can delete \"de\" from s1 and nothing from s2. The strings will be equal (unordered) leet = lete and the sum will be smaller."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@Ido Shamir](/ido.shamir.ido)  This is because the order of the string can\\'t be changed we can only delete elements to make two string equal."
                    },
                    {
                        "username": "prathmesh-jagtap",
                        "content": "[@BlackMamba97](/BlackMamba97)  \\nYes the subsequences are always in contiguous."
                    },
                    {
                        "username": "BlackMamba97",
                        "content": "This is for ordered sequence.\\nRead the definition of subsequence. you will get the answer to your question."
                    },
                    {
                        "username": "paradoxtown",
                        "content": "All of us will become DP masters one day."
                    },
                    {
                        "username": "yurek16II",
                        "content": "Nice example, delete leet == forbidden ;)"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Output 403\\nExpected 403"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Nowadays its seems like DP day😂...everywhere it is present take it whether daily challenge or contest🙂"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "looks like a variation of LCS"
                    },
                    {
                        "username": "panieldark",
                        "content": "Second! Longest Common Subsequence for the win lol"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "# CAN ANYONE TELL ME WHAT AM I DOING WRONG? \\n\\n```\\nclass Solution {\\npublic:\\n    string lcs(string s1, string s2, vector<vector<int>> &dp, int lcslen){\\n        string lcsstring = \"\";\\n        int index = lcslen-1;\\n        for(int i =0; i < lcslen; ++i) lcsstring += \\'#\\';\\n        int i = s1.size(), j = s2.size();\\n        while(i > 0 && j > 0){\\n            if(s1[i-1] == s2[j-1]){\\n                lcsstring[index] = s1[i-1];\\n                index--;\\n                i--;\\n                j--;\\n            }else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    i--;\\n                }else if(dp[i-1][j] < dp[i][j-1]){\\n                    j--;\\n                }else{\\n                    if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return lcsstring;\\n    }\\n    int populatedp(string s1, string s2, vector<vector<int>> &dp) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        for(int i = 0; i <= n1; ++i) dp[i][0] = 0;\\n        for(int i = 0; i <= n2; ++i) dp[0][i] = 0;\\n        for(int ind1 = 1; ind1 <= n1; ++ind1){\\n            for(int ind2 = 1; ind2 <= n2; ++ind2){\\n                if(s1[ind1-1] == s2[ind2-1]){\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                }else if(s1[ind1-1] != s2[ind2-1]){\\n                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int ret = 0, n1 = s1.size(), n2 = s2.size();\\n        for(auto& x: s1) ret += x;\\n        for(auto &x: s2 ) ret += x;\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        int lcslen = populatedp(s1,s2,dp);\\n        for(int i = 0; i <= n1; ++i){\\n            for(int j = 0; j <= n2; ++j){\\n                cout << dp[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        string s = lcs(s1,s2,dp,lcslen);\\n        for(int i = 0; i < 2; ++i) for(auto &x: s) ret -= x;\\n        return ret;\\n    }\\n};\\n\\n```\\nInput\\ns1 =\\n\"delete\"\\ns2 =\\n\"leet\"\\nStdout\\n0 0 0 0 0 \\n0 0 0 0 0 \\n0 0 1 1 1 \\n0 1 1 1 1 \\n0 1 2 2 2 \\n0 1 2 2 3 \\n0 1 2 3 3 \\nOutput\\n433\\nExpected\\n403"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Finding out the LCS having the maximum ASCII sum should be the task , but while backtracking and forming LCS , getting maximum ASCII sum one requires us to check for all LCS strings and then compare from it.\\n\\nAnd also in case of else {\\n      s1[i-1] < s2[j-1]\\n     Should be compared not s1[i] and s2[j].\\n}"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "[@shreejaraj026](/shreejaraj026) if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }But I used this snippet in lcs function.. as per the logic it should pick let instead of lee"
                    },
                    {
                        "username": "shreejaraj026",
                        "content": "In this testcase it\\'s picking up the \"lee\" as subsequence that\\'s why we getting result value as 433, if it would have picked up \"let\" as substring then we get 403."
                    }
                ]
            },
            {
                "id": 1993704,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem, but much easier than the one on yesterday! Like the longest common subsequence problem! A substring must be a subsequence, but a subsequence may be not a substring! One more hint: Use the following formula\n$$\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2* asciiSum(LCS)\n$$\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840645/c-several-recursiveiterative-dplcs-beats-9462/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) You can simplify your program by replacing  the line ```if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)``` in lcs(i, j) by ``` if s[i-1] == t[j-1]: dp[i][j] = ord(s[i-1])+lcs(i-1,j-1)```. At final, ``` return res-2*lcs(n, m)``` Everything goes OK!"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@_aka5h](/_aka5h) Now got the point thanks [@Akash Rai](/_aka5h)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) In your case, you can consider \"oo\" to be the LCS with maximum ASCII value. But In general, there is something even more important, that can be overlooked if we use the term LCS, here in this problem we are using LCS pattern and not exactly finding LCS. The idea is to find a subsequence with maximum ASCII value which is common to both given strings and that subsequence doesn't necessarily have to be the LCS of the 2 strings. There might be a case where a subsequence (which is common to both strings and is not LCS) have higher ASSCII sum than the actual LCS of the 2 strings."
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) \n```\nclass Solution:\n    def minimumDeleteSum(self, s: str, t: str) -> int:\n        # finding the lcs\n        def lcs(i,j):\n            if i == 0 or j == 0: return 0\n            if dp[i][j] != -1: return dp[i][j]\n            if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)\n            else: dp[i][j] = max(lcs(i-1,j), lcs(i,j-1))\n            return dp[i][j]\n        n,m = len(s),len(t)\n        dp = [[-1]*(m+1) for _ in range(n+1)]\n        lcs(n,m)\n        res = 0\n        # getting the actual string\n        i,j = n,m\n        string = ''\n        while i>0 and j>0:\n            if s[i-1] == t[j-1]: \n                string = s[i-1]+string\n                i,j = i-1,j-1\n            else:\n                if dp[i-1][j] > dp[i][j-1]: i -= 1\n                elif dp[i-1][j] < dp[i][j-1]: j -= 1\n                else:\n                    if ord(s[i-1]) > ord(t[j-1]): j -= 1\n                    else: i -= 1\n        for i in s: res += ord(i)\n        for i in t: res += ord(i)\n        for i in string: res -= ord(i)*2\n        return res\n```"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) Could you check the below code once..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) I\\'ve tried my 3 solutions. All outputs are 2255"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can you explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. asciiSum(s1) = 1620 asciiSum(s2) = 1079 and asciiSum(lcs) = 217 and according to your formula also it should be 2265 but expected output is 2255"
                    },
                    {
                        "username": "Yaswanth017",
                        "content": "The problem statement never mentioned anything about subsequence. Who else finds this misleading? Leetcode expects us to figure it out by looking at example 2🤷‍♂️🤦‍♂️"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "[@gadmo](/gadmo) Yeah but I\\'m new and when trying to come up with a solution I was confused why you couldn\\'t just delete \"de\" from delete to get lete and leet which are both equal ascvii wise. It never mentions sub sequence just sum which is the same no matter which order they are in. "
                    },
                    {
                        "username": "Princesah999",
                        "content": "I was doing this \\n\\n// delete => deeelt\\n// leet   => eelt"
                    },
                    {
                        "username": "betaev",
                        "content": "[@gadmo](/gadmo) it\\'s longest common subsequence inversed"
                    },
                    {
                        "username": "gadmo",
                        "content": "you don\\'t need to think about subsequence at all to solve this, its almost textbook edit distance."
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Consider this problem as a variation of LCS.\\n"
                    },
                    {
                        "username": "ido.shamir.ido",
                        "content": "I might be missing something here but isn\\'t Example 2 wrong?\\nInput: s1 = \"delete\", s2 = \"leet\"\\nWe can delete \"de\" from s1 and nothing from s2. The strings will be equal (unordered) leet = lete and the sum will be smaller."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@Ido Shamir](/ido.shamir.ido)  This is because the order of the string can\\'t be changed we can only delete elements to make two string equal."
                    },
                    {
                        "username": "prathmesh-jagtap",
                        "content": "[@BlackMamba97](/BlackMamba97)  \\nYes the subsequences are always in contiguous."
                    },
                    {
                        "username": "BlackMamba97",
                        "content": "This is for ordered sequence.\\nRead the definition of subsequence. you will get the answer to your question."
                    },
                    {
                        "username": "paradoxtown",
                        "content": "All of us will become DP masters one day."
                    },
                    {
                        "username": "yurek16II",
                        "content": "Nice example, delete leet == forbidden ;)"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Output 403\\nExpected 403"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Nowadays its seems like DP day😂...everywhere it is present take it whether daily challenge or contest🙂"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "looks like a variation of LCS"
                    },
                    {
                        "username": "panieldark",
                        "content": "Second! Longest Common Subsequence for the win lol"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "# CAN ANYONE TELL ME WHAT AM I DOING WRONG? \\n\\n```\\nclass Solution {\\npublic:\\n    string lcs(string s1, string s2, vector<vector<int>> &dp, int lcslen){\\n        string lcsstring = \"\";\\n        int index = lcslen-1;\\n        for(int i =0; i < lcslen; ++i) lcsstring += \\'#\\';\\n        int i = s1.size(), j = s2.size();\\n        while(i > 0 && j > 0){\\n            if(s1[i-1] == s2[j-1]){\\n                lcsstring[index] = s1[i-1];\\n                index--;\\n                i--;\\n                j--;\\n            }else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    i--;\\n                }else if(dp[i-1][j] < dp[i][j-1]){\\n                    j--;\\n                }else{\\n                    if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return lcsstring;\\n    }\\n    int populatedp(string s1, string s2, vector<vector<int>> &dp) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        for(int i = 0; i <= n1; ++i) dp[i][0] = 0;\\n        for(int i = 0; i <= n2; ++i) dp[0][i] = 0;\\n        for(int ind1 = 1; ind1 <= n1; ++ind1){\\n            for(int ind2 = 1; ind2 <= n2; ++ind2){\\n                if(s1[ind1-1] == s2[ind2-1]){\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                }else if(s1[ind1-1] != s2[ind2-1]){\\n                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int ret = 0, n1 = s1.size(), n2 = s2.size();\\n        for(auto& x: s1) ret += x;\\n        for(auto &x: s2 ) ret += x;\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        int lcslen = populatedp(s1,s2,dp);\\n        for(int i = 0; i <= n1; ++i){\\n            for(int j = 0; j <= n2; ++j){\\n                cout << dp[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        string s = lcs(s1,s2,dp,lcslen);\\n        for(int i = 0; i < 2; ++i) for(auto &x: s) ret -= x;\\n        return ret;\\n    }\\n};\\n\\n```\\nInput\\ns1 =\\n\"delete\"\\ns2 =\\n\"leet\"\\nStdout\\n0 0 0 0 0 \\n0 0 0 0 0 \\n0 0 1 1 1 \\n0 1 1 1 1 \\n0 1 2 2 2 \\n0 1 2 2 3 \\n0 1 2 3 3 \\nOutput\\n433\\nExpected\\n403"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Finding out the LCS having the maximum ASCII sum should be the task , but while backtracking and forming LCS , getting maximum ASCII sum one requires us to check for all LCS strings and then compare from it.\\n\\nAnd also in case of else {\\n      s1[i-1] < s2[j-1]\\n     Should be compared not s1[i] and s2[j].\\n}"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "[@shreejaraj026](/shreejaraj026) if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }But I used this snippet in lcs function.. as per the logic it should pick let instead of lee"
                    },
                    {
                        "username": "shreejaraj026",
                        "content": "In this testcase it\\'s picking up the \"lee\" as subsequence that\\'s why we getting result value as 433, if it would have picked up \"let\" as substring then we get 403."
                    }
                ]
            },
            {
                "id": 1763602,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem, but much easier than the one on yesterday! Like the longest common subsequence problem! A substring must be a subsequence, but a subsequence may be not a substring! One more hint: Use the following formula\n$$\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2* asciiSum(LCS)\n$$\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840645/c-several-recursiveiterative-dplcs-beats-9462/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) You can simplify your program by replacing  the line ```if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)``` in lcs(i, j) by ``` if s[i-1] == t[j-1]: dp[i][j] = ord(s[i-1])+lcs(i-1,j-1)```. At final, ``` return res-2*lcs(n, m)``` Everything goes OK!"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@_aka5h](/_aka5h) Now got the point thanks [@Akash Rai](/_aka5h)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) In your case, you can consider \"oo\" to be the LCS with maximum ASCII value. But In general, there is something even more important, that can be overlooked if we use the term LCS, here in this problem we are using LCS pattern and not exactly finding LCS. The idea is to find a subsequence with maximum ASCII value which is common to both given strings and that subsequence doesn't necessarily have to be the LCS of the 2 strings. There might be a case where a subsequence (which is common to both strings and is not LCS) have higher ASSCII sum than the actual LCS of the 2 strings."
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) \n```\nclass Solution:\n    def minimumDeleteSum(self, s: str, t: str) -> int:\n        # finding the lcs\n        def lcs(i,j):\n            if i == 0 or j == 0: return 0\n            if dp[i][j] != -1: return dp[i][j]\n            if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)\n            else: dp[i][j] = max(lcs(i-1,j), lcs(i,j-1))\n            return dp[i][j]\n        n,m = len(s),len(t)\n        dp = [[-1]*(m+1) for _ in range(n+1)]\n        lcs(n,m)\n        res = 0\n        # getting the actual string\n        i,j = n,m\n        string = ''\n        while i>0 and j>0:\n            if s[i-1] == t[j-1]: \n                string = s[i-1]+string\n                i,j = i-1,j-1\n            else:\n                if dp[i-1][j] > dp[i][j-1]: i -= 1\n                elif dp[i-1][j] < dp[i][j-1]: j -= 1\n                else:\n                    if ord(s[i-1]) > ord(t[j-1]): j -= 1\n                    else: i -= 1\n        for i in s: res += ord(i)\n        for i in t: res += ord(i)\n        for i in string: res -= ord(i)*2\n        return res\n```"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) Could you check the below code once..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) I\\'ve tried my 3 solutions. All outputs are 2255"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can you explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. asciiSum(s1) = 1620 asciiSum(s2) = 1079 and asciiSum(lcs) = 217 and according to your formula also it should be 2265 but expected output is 2255"
                    },
                    {
                        "username": "Yaswanth017",
                        "content": "The problem statement never mentioned anything about subsequence. Who else finds this misleading? Leetcode expects us to figure it out by looking at example 2🤷‍♂️🤦‍♂️"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "[@gadmo](/gadmo) Yeah but I\\'m new and when trying to come up with a solution I was confused why you couldn\\'t just delete \"de\" from delete to get lete and leet which are both equal ascvii wise. It never mentions sub sequence just sum which is the same no matter which order they are in. "
                    },
                    {
                        "username": "Princesah999",
                        "content": "I was doing this \\n\\n// delete => deeelt\\n// leet   => eelt"
                    },
                    {
                        "username": "betaev",
                        "content": "[@gadmo](/gadmo) it\\'s longest common subsequence inversed"
                    },
                    {
                        "username": "gadmo",
                        "content": "you don\\'t need to think about subsequence at all to solve this, its almost textbook edit distance."
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Consider this problem as a variation of LCS.\\n"
                    },
                    {
                        "username": "ido.shamir.ido",
                        "content": "I might be missing something here but isn\\'t Example 2 wrong?\\nInput: s1 = \"delete\", s2 = \"leet\"\\nWe can delete \"de\" from s1 and nothing from s2. The strings will be equal (unordered) leet = lete and the sum will be smaller."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@Ido Shamir](/ido.shamir.ido)  This is because the order of the string can\\'t be changed we can only delete elements to make two string equal."
                    },
                    {
                        "username": "prathmesh-jagtap",
                        "content": "[@BlackMamba97](/BlackMamba97)  \\nYes the subsequences are always in contiguous."
                    },
                    {
                        "username": "BlackMamba97",
                        "content": "This is for ordered sequence.\\nRead the definition of subsequence. you will get the answer to your question."
                    },
                    {
                        "username": "paradoxtown",
                        "content": "All of us will become DP masters one day."
                    },
                    {
                        "username": "yurek16II",
                        "content": "Nice example, delete leet == forbidden ;)"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Output 403\\nExpected 403"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Nowadays its seems like DP day😂...everywhere it is present take it whether daily challenge or contest🙂"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "looks like a variation of LCS"
                    },
                    {
                        "username": "panieldark",
                        "content": "Second! Longest Common Subsequence for the win lol"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "# CAN ANYONE TELL ME WHAT AM I DOING WRONG? \\n\\n```\\nclass Solution {\\npublic:\\n    string lcs(string s1, string s2, vector<vector<int>> &dp, int lcslen){\\n        string lcsstring = \"\";\\n        int index = lcslen-1;\\n        for(int i =0; i < lcslen; ++i) lcsstring += \\'#\\';\\n        int i = s1.size(), j = s2.size();\\n        while(i > 0 && j > 0){\\n            if(s1[i-1] == s2[j-1]){\\n                lcsstring[index] = s1[i-1];\\n                index--;\\n                i--;\\n                j--;\\n            }else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    i--;\\n                }else if(dp[i-1][j] < dp[i][j-1]){\\n                    j--;\\n                }else{\\n                    if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return lcsstring;\\n    }\\n    int populatedp(string s1, string s2, vector<vector<int>> &dp) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        for(int i = 0; i <= n1; ++i) dp[i][0] = 0;\\n        for(int i = 0; i <= n2; ++i) dp[0][i] = 0;\\n        for(int ind1 = 1; ind1 <= n1; ++ind1){\\n            for(int ind2 = 1; ind2 <= n2; ++ind2){\\n                if(s1[ind1-1] == s2[ind2-1]){\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                }else if(s1[ind1-1] != s2[ind2-1]){\\n                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int ret = 0, n1 = s1.size(), n2 = s2.size();\\n        for(auto& x: s1) ret += x;\\n        for(auto &x: s2 ) ret += x;\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        int lcslen = populatedp(s1,s2,dp);\\n        for(int i = 0; i <= n1; ++i){\\n            for(int j = 0; j <= n2; ++j){\\n                cout << dp[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        string s = lcs(s1,s2,dp,lcslen);\\n        for(int i = 0; i < 2; ++i) for(auto &x: s) ret -= x;\\n        return ret;\\n    }\\n};\\n\\n```\\nInput\\ns1 =\\n\"delete\"\\ns2 =\\n\"leet\"\\nStdout\\n0 0 0 0 0 \\n0 0 0 0 0 \\n0 0 1 1 1 \\n0 1 1 1 1 \\n0 1 2 2 2 \\n0 1 2 2 3 \\n0 1 2 3 3 \\nOutput\\n433\\nExpected\\n403"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Finding out the LCS having the maximum ASCII sum should be the task , but while backtracking and forming LCS , getting maximum ASCII sum one requires us to check for all LCS strings and then compare from it.\\n\\nAnd also in case of else {\\n      s1[i-1] < s2[j-1]\\n     Should be compared not s1[i] and s2[j].\\n}"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "[@shreejaraj026](/shreejaraj026) if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }But I used this snippet in lcs function.. as per the logic it should pick let instead of lee"
                    },
                    {
                        "username": "shreejaraj026",
                        "content": "In this testcase it\\'s picking up the \"lee\" as subsequence that\\'s why we getting result value as 433, if it would have picked up \"let\" as substring then we get 403."
                    }
                ]
            },
            {
                "id": 1985199,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem, but much easier than the one on yesterday! Like the longest common subsequence problem! A substring must be a subsequence, but a subsequence may be not a substring! One more hint: Use the following formula\n$$\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2* asciiSum(LCS)\n$$\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840645/c-several-recursiveiterative-dplcs-beats-9462/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) You can simplify your program by replacing  the line ```if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)``` in lcs(i, j) by ``` if s[i-1] == t[j-1]: dp[i][j] = ord(s[i-1])+lcs(i-1,j-1)```. At final, ``` return res-2*lcs(n, m)``` Everything goes OK!"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@_aka5h](/_aka5h) Now got the point thanks [@Akash Rai](/_aka5h)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) In your case, you can consider \"oo\" to be the LCS with maximum ASCII value. But In general, there is something even more important, that can be overlooked if we use the term LCS, here in this problem we are using LCS pattern and not exactly finding LCS. The idea is to find a subsequence with maximum ASCII value which is common to both given strings and that subsequence doesn't necessarily have to be the LCS of the 2 strings. There might be a case where a subsequence (which is common to both strings and is not LCS) have higher ASSCII sum than the actual LCS of the 2 strings."
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) \n```\nclass Solution:\n    def minimumDeleteSum(self, s: str, t: str) -> int:\n        # finding the lcs\n        def lcs(i,j):\n            if i == 0 or j == 0: return 0\n            if dp[i][j] != -1: return dp[i][j]\n            if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)\n            else: dp[i][j] = max(lcs(i-1,j), lcs(i,j-1))\n            return dp[i][j]\n        n,m = len(s),len(t)\n        dp = [[-1]*(m+1) for _ in range(n+1)]\n        lcs(n,m)\n        res = 0\n        # getting the actual string\n        i,j = n,m\n        string = ''\n        while i>0 and j>0:\n            if s[i-1] == t[j-1]: \n                string = s[i-1]+string\n                i,j = i-1,j-1\n            else:\n                if dp[i-1][j] > dp[i][j-1]: i -= 1\n                elif dp[i-1][j] < dp[i][j-1]: j -= 1\n                else:\n                    if ord(s[i-1]) > ord(t[j-1]): j -= 1\n                    else: i -= 1\n        for i in s: res += ord(i)\n        for i in t: res += ord(i)\n        for i in string: res -= ord(i)*2\n        return res\n```"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) Could you check the below code once..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) I\\'ve tried my 3 solutions. All outputs are 2255"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can you explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. asciiSum(s1) = 1620 asciiSum(s2) = 1079 and asciiSum(lcs) = 217 and according to your formula also it should be 2265 but expected output is 2255"
                    },
                    {
                        "username": "Yaswanth017",
                        "content": "The problem statement never mentioned anything about subsequence. Who else finds this misleading? Leetcode expects us to figure it out by looking at example 2🤷‍♂️🤦‍♂️"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "[@gadmo](/gadmo) Yeah but I\\'m new and when trying to come up with a solution I was confused why you couldn\\'t just delete \"de\" from delete to get lete and leet which are both equal ascvii wise. It never mentions sub sequence just sum which is the same no matter which order they are in. "
                    },
                    {
                        "username": "Princesah999",
                        "content": "I was doing this \\n\\n// delete => deeelt\\n// leet   => eelt"
                    },
                    {
                        "username": "betaev",
                        "content": "[@gadmo](/gadmo) it\\'s longest common subsequence inversed"
                    },
                    {
                        "username": "gadmo",
                        "content": "you don\\'t need to think about subsequence at all to solve this, its almost textbook edit distance."
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Consider this problem as a variation of LCS.\\n"
                    },
                    {
                        "username": "ido.shamir.ido",
                        "content": "I might be missing something here but isn\\'t Example 2 wrong?\\nInput: s1 = \"delete\", s2 = \"leet\"\\nWe can delete \"de\" from s1 and nothing from s2. The strings will be equal (unordered) leet = lete and the sum will be smaller."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@Ido Shamir](/ido.shamir.ido)  This is because the order of the string can\\'t be changed we can only delete elements to make two string equal."
                    },
                    {
                        "username": "prathmesh-jagtap",
                        "content": "[@BlackMamba97](/BlackMamba97)  \\nYes the subsequences are always in contiguous."
                    },
                    {
                        "username": "BlackMamba97",
                        "content": "This is for ordered sequence.\\nRead the definition of subsequence. you will get the answer to your question."
                    },
                    {
                        "username": "paradoxtown",
                        "content": "All of us will become DP masters one day."
                    },
                    {
                        "username": "yurek16II",
                        "content": "Nice example, delete leet == forbidden ;)"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Output 403\\nExpected 403"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Nowadays its seems like DP day😂...everywhere it is present take it whether daily challenge or contest🙂"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "looks like a variation of LCS"
                    },
                    {
                        "username": "panieldark",
                        "content": "Second! Longest Common Subsequence for the win lol"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "# CAN ANYONE TELL ME WHAT AM I DOING WRONG? \\n\\n```\\nclass Solution {\\npublic:\\n    string lcs(string s1, string s2, vector<vector<int>> &dp, int lcslen){\\n        string lcsstring = \"\";\\n        int index = lcslen-1;\\n        for(int i =0; i < lcslen; ++i) lcsstring += \\'#\\';\\n        int i = s1.size(), j = s2.size();\\n        while(i > 0 && j > 0){\\n            if(s1[i-1] == s2[j-1]){\\n                lcsstring[index] = s1[i-1];\\n                index--;\\n                i--;\\n                j--;\\n            }else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    i--;\\n                }else if(dp[i-1][j] < dp[i][j-1]){\\n                    j--;\\n                }else{\\n                    if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return lcsstring;\\n    }\\n    int populatedp(string s1, string s2, vector<vector<int>> &dp) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        for(int i = 0; i <= n1; ++i) dp[i][0] = 0;\\n        for(int i = 0; i <= n2; ++i) dp[0][i] = 0;\\n        for(int ind1 = 1; ind1 <= n1; ++ind1){\\n            for(int ind2 = 1; ind2 <= n2; ++ind2){\\n                if(s1[ind1-1] == s2[ind2-1]){\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                }else if(s1[ind1-1] != s2[ind2-1]){\\n                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int ret = 0, n1 = s1.size(), n2 = s2.size();\\n        for(auto& x: s1) ret += x;\\n        for(auto &x: s2 ) ret += x;\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        int lcslen = populatedp(s1,s2,dp);\\n        for(int i = 0; i <= n1; ++i){\\n            for(int j = 0; j <= n2; ++j){\\n                cout << dp[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        string s = lcs(s1,s2,dp,lcslen);\\n        for(int i = 0; i < 2; ++i) for(auto &x: s) ret -= x;\\n        return ret;\\n    }\\n};\\n\\n```\\nInput\\ns1 =\\n\"delete\"\\ns2 =\\n\"leet\"\\nStdout\\n0 0 0 0 0 \\n0 0 0 0 0 \\n0 0 1 1 1 \\n0 1 1 1 1 \\n0 1 2 2 2 \\n0 1 2 2 3 \\n0 1 2 3 3 \\nOutput\\n433\\nExpected\\n403"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Finding out the LCS having the maximum ASCII sum should be the task , but while backtracking and forming LCS , getting maximum ASCII sum one requires us to check for all LCS strings and then compare from it.\\n\\nAnd also in case of else {\\n      s1[i-1] < s2[j-1]\\n     Should be compared not s1[i] and s2[j].\\n}"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "[@shreejaraj026](/shreejaraj026) if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }But I used this snippet in lcs function.. as per the logic it should pick let instead of lee"
                    },
                    {
                        "username": "shreejaraj026",
                        "content": "In this testcase it\\'s picking up the \"lee\" as subsequence that\\'s why we getting result value as 433, if it would have picked up \"let\" as substring then we get 403."
                    }
                ]
            },
            {
                "id": 1572097,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem, but much easier than the one on yesterday! Like the longest common subsequence problem! A substring must be a subsequence, but a subsequence may be not a substring! One more hint: Use the following formula\n$$\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2* asciiSum(LCS)\n$$\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840645/c-several-recursiveiterative-dplcs-beats-9462/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) You can simplify your program by replacing  the line ```if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)``` in lcs(i, j) by ``` if s[i-1] == t[j-1]: dp[i][j] = ord(s[i-1])+lcs(i-1,j-1)```. At final, ``` return res-2*lcs(n, m)``` Everything goes OK!"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@_aka5h](/_aka5h) Now got the point thanks [@Akash Rai](/_aka5h)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) In your case, you can consider \"oo\" to be the LCS with maximum ASCII value. But In general, there is something even more important, that can be overlooked if we use the term LCS, here in this problem we are using LCS pattern and not exactly finding LCS. The idea is to find a subsequence with maximum ASCII value which is common to both given strings and that subsequence doesn't necessarily have to be the LCS of the 2 strings. There might be a case where a subsequence (which is common to both strings and is not LCS) have higher ASSCII sum than the actual LCS of the 2 strings."
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) \n```\nclass Solution:\n    def minimumDeleteSum(self, s: str, t: str) -> int:\n        # finding the lcs\n        def lcs(i,j):\n            if i == 0 or j == 0: return 0\n            if dp[i][j] != -1: return dp[i][j]\n            if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)\n            else: dp[i][j] = max(lcs(i-1,j), lcs(i,j-1))\n            return dp[i][j]\n        n,m = len(s),len(t)\n        dp = [[-1]*(m+1) for _ in range(n+1)]\n        lcs(n,m)\n        res = 0\n        # getting the actual string\n        i,j = n,m\n        string = ''\n        while i>0 and j>0:\n            if s[i-1] == t[j-1]: \n                string = s[i-1]+string\n                i,j = i-1,j-1\n            else:\n                if dp[i-1][j] > dp[i][j-1]: i -= 1\n                elif dp[i-1][j] < dp[i][j-1]: j -= 1\n                else:\n                    if ord(s[i-1]) > ord(t[j-1]): j -= 1\n                    else: i -= 1\n        for i in s: res += ord(i)\n        for i in t: res += ord(i)\n        for i in string: res -= ord(i)*2\n        return res\n```"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) Could you check the below code once..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) I\\'ve tried my 3 solutions. All outputs are 2255"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can you explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. asciiSum(s1) = 1620 asciiSum(s2) = 1079 and asciiSum(lcs) = 217 and according to your formula also it should be 2265 but expected output is 2255"
                    },
                    {
                        "username": "Yaswanth017",
                        "content": "The problem statement never mentioned anything about subsequence. Who else finds this misleading? Leetcode expects us to figure it out by looking at example 2🤷‍♂️🤦‍♂️"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "[@gadmo](/gadmo) Yeah but I\\'m new and when trying to come up with a solution I was confused why you couldn\\'t just delete \"de\" from delete to get lete and leet which are both equal ascvii wise. It never mentions sub sequence just sum which is the same no matter which order they are in. "
                    },
                    {
                        "username": "Princesah999",
                        "content": "I was doing this \\n\\n// delete => deeelt\\n// leet   => eelt"
                    },
                    {
                        "username": "betaev",
                        "content": "[@gadmo](/gadmo) it\\'s longest common subsequence inversed"
                    },
                    {
                        "username": "gadmo",
                        "content": "you don\\'t need to think about subsequence at all to solve this, its almost textbook edit distance."
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Consider this problem as a variation of LCS.\\n"
                    },
                    {
                        "username": "ido.shamir.ido",
                        "content": "I might be missing something here but isn\\'t Example 2 wrong?\\nInput: s1 = \"delete\", s2 = \"leet\"\\nWe can delete \"de\" from s1 and nothing from s2. The strings will be equal (unordered) leet = lete and the sum will be smaller."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@Ido Shamir](/ido.shamir.ido)  This is because the order of the string can\\'t be changed we can only delete elements to make two string equal."
                    },
                    {
                        "username": "prathmesh-jagtap",
                        "content": "[@BlackMamba97](/BlackMamba97)  \\nYes the subsequences are always in contiguous."
                    },
                    {
                        "username": "BlackMamba97",
                        "content": "This is for ordered sequence.\\nRead the definition of subsequence. you will get the answer to your question."
                    },
                    {
                        "username": "paradoxtown",
                        "content": "All of us will become DP masters one day."
                    },
                    {
                        "username": "yurek16II",
                        "content": "Nice example, delete leet == forbidden ;)"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Output 403\\nExpected 403"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Nowadays its seems like DP day😂...everywhere it is present take it whether daily challenge or contest🙂"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "looks like a variation of LCS"
                    },
                    {
                        "username": "panieldark",
                        "content": "Second! Longest Common Subsequence for the win lol"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "# CAN ANYONE TELL ME WHAT AM I DOING WRONG? \\n\\n```\\nclass Solution {\\npublic:\\n    string lcs(string s1, string s2, vector<vector<int>> &dp, int lcslen){\\n        string lcsstring = \"\";\\n        int index = lcslen-1;\\n        for(int i =0; i < lcslen; ++i) lcsstring += \\'#\\';\\n        int i = s1.size(), j = s2.size();\\n        while(i > 0 && j > 0){\\n            if(s1[i-1] == s2[j-1]){\\n                lcsstring[index] = s1[i-1];\\n                index--;\\n                i--;\\n                j--;\\n            }else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    i--;\\n                }else if(dp[i-1][j] < dp[i][j-1]){\\n                    j--;\\n                }else{\\n                    if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return lcsstring;\\n    }\\n    int populatedp(string s1, string s2, vector<vector<int>> &dp) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        for(int i = 0; i <= n1; ++i) dp[i][0] = 0;\\n        for(int i = 0; i <= n2; ++i) dp[0][i] = 0;\\n        for(int ind1 = 1; ind1 <= n1; ++ind1){\\n            for(int ind2 = 1; ind2 <= n2; ++ind2){\\n                if(s1[ind1-1] == s2[ind2-1]){\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                }else if(s1[ind1-1] != s2[ind2-1]){\\n                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int ret = 0, n1 = s1.size(), n2 = s2.size();\\n        for(auto& x: s1) ret += x;\\n        for(auto &x: s2 ) ret += x;\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        int lcslen = populatedp(s1,s2,dp);\\n        for(int i = 0; i <= n1; ++i){\\n            for(int j = 0; j <= n2; ++j){\\n                cout << dp[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        string s = lcs(s1,s2,dp,lcslen);\\n        for(int i = 0; i < 2; ++i) for(auto &x: s) ret -= x;\\n        return ret;\\n    }\\n};\\n\\n```\\nInput\\ns1 =\\n\"delete\"\\ns2 =\\n\"leet\"\\nStdout\\n0 0 0 0 0 \\n0 0 0 0 0 \\n0 0 1 1 1 \\n0 1 1 1 1 \\n0 1 2 2 2 \\n0 1 2 2 3 \\n0 1 2 3 3 \\nOutput\\n433\\nExpected\\n403"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Finding out the LCS having the maximum ASCII sum should be the task , but while backtracking and forming LCS , getting maximum ASCII sum one requires us to check for all LCS strings and then compare from it.\\n\\nAnd also in case of else {\\n      s1[i-1] < s2[j-1]\\n     Should be compared not s1[i] and s2[j].\\n}"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "[@shreejaraj026](/shreejaraj026) if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }But I used this snippet in lcs function.. as per the logic it should pick let instead of lee"
                    },
                    {
                        "username": "shreejaraj026",
                        "content": "In this testcase it\\'s picking up the \"lee\" as subsequence that\\'s why we getting result value as 433, if it would have picked up \"let\" as substring then we get 403."
                    }
                ]
            },
            {
                "id": 1994213,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem, but much easier than the one on yesterday! Like the longest common subsequence problem! A substring must be a subsequence, but a subsequence may be not a substring! One more hint: Use the following formula\n$$\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2* asciiSum(LCS)\n$$\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840645/c-several-recursiveiterative-dplcs-beats-9462/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) You can simplify your program by replacing  the line ```if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)``` in lcs(i, j) by ``` if s[i-1] == t[j-1]: dp[i][j] = ord(s[i-1])+lcs(i-1,j-1)```. At final, ``` return res-2*lcs(n, m)``` Everything goes OK!"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@_aka5h](/_aka5h) Now got the point thanks [@Akash Rai](/_aka5h)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) In your case, you can consider \"oo\" to be the LCS with maximum ASCII value. But In general, there is something even more important, that can be overlooked if we use the term LCS, here in this problem we are using LCS pattern and not exactly finding LCS. The idea is to find a subsequence with maximum ASCII value which is common to both given strings and that subsequence doesn't necessarily have to be the LCS of the 2 strings. There might be a case where a subsequence (which is common to both strings and is not LCS) have higher ASSCII sum than the actual LCS of the 2 strings."
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) \n```\nclass Solution:\n    def minimumDeleteSum(self, s: str, t: str) -> int:\n        # finding the lcs\n        def lcs(i,j):\n            if i == 0 or j == 0: return 0\n            if dp[i][j] != -1: return dp[i][j]\n            if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)\n            else: dp[i][j] = max(lcs(i-1,j), lcs(i,j-1))\n            return dp[i][j]\n        n,m = len(s),len(t)\n        dp = [[-1]*(m+1) for _ in range(n+1)]\n        lcs(n,m)\n        res = 0\n        # getting the actual string\n        i,j = n,m\n        string = ''\n        while i>0 and j>0:\n            if s[i-1] == t[j-1]: \n                string = s[i-1]+string\n                i,j = i-1,j-1\n            else:\n                if dp[i-1][j] > dp[i][j-1]: i -= 1\n                elif dp[i-1][j] < dp[i][j-1]: j -= 1\n                else:\n                    if ord(s[i-1]) > ord(t[j-1]): j -= 1\n                    else: i -= 1\n        for i in s: res += ord(i)\n        for i in t: res += ord(i)\n        for i in string: res -= ord(i)*2\n        return res\n```"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) Could you check the below code once..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) I\\'ve tried my 3 solutions. All outputs are 2255"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can you explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. asciiSum(s1) = 1620 asciiSum(s2) = 1079 and asciiSum(lcs) = 217 and according to your formula also it should be 2265 but expected output is 2255"
                    },
                    {
                        "username": "Yaswanth017",
                        "content": "The problem statement never mentioned anything about subsequence. Who else finds this misleading? Leetcode expects us to figure it out by looking at example 2🤷‍♂️🤦‍♂️"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "[@gadmo](/gadmo) Yeah but I\\'m new and when trying to come up with a solution I was confused why you couldn\\'t just delete \"de\" from delete to get lete and leet which are both equal ascvii wise. It never mentions sub sequence just sum which is the same no matter which order they are in. "
                    },
                    {
                        "username": "Princesah999",
                        "content": "I was doing this \\n\\n// delete => deeelt\\n// leet   => eelt"
                    },
                    {
                        "username": "betaev",
                        "content": "[@gadmo](/gadmo) it\\'s longest common subsequence inversed"
                    },
                    {
                        "username": "gadmo",
                        "content": "you don\\'t need to think about subsequence at all to solve this, its almost textbook edit distance."
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Consider this problem as a variation of LCS.\\n"
                    },
                    {
                        "username": "ido.shamir.ido",
                        "content": "I might be missing something here but isn\\'t Example 2 wrong?\\nInput: s1 = \"delete\", s2 = \"leet\"\\nWe can delete \"de\" from s1 and nothing from s2. The strings will be equal (unordered) leet = lete and the sum will be smaller."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@Ido Shamir](/ido.shamir.ido)  This is because the order of the string can\\'t be changed we can only delete elements to make two string equal."
                    },
                    {
                        "username": "prathmesh-jagtap",
                        "content": "[@BlackMamba97](/BlackMamba97)  \\nYes the subsequences are always in contiguous."
                    },
                    {
                        "username": "BlackMamba97",
                        "content": "This is for ordered sequence.\\nRead the definition of subsequence. you will get the answer to your question."
                    },
                    {
                        "username": "paradoxtown",
                        "content": "All of us will become DP masters one day."
                    },
                    {
                        "username": "yurek16II",
                        "content": "Nice example, delete leet == forbidden ;)"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Output 403\\nExpected 403"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Nowadays its seems like DP day😂...everywhere it is present take it whether daily challenge or contest🙂"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "looks like a variation of LCS"
                    },
                    {
                        "username": "panieldark",
                        "content": "Second! Longest Common Subsequence for the win lol"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "# CAN ANYONE TELL ME WHAT AM I DOING WRONG? \\n\\n```\\nclass Solution {\\npublic:\\n    string lcs(string s1, string s2, vector<vector<int>> &dp, int lcslen){\\n        string lcsstring = \"\";\\n        int index = lcslen-1;\\n        for(int i =0; i < lcslen; ++i) lcsstring += \\'#\\';\\n        int i = s1.size(), j = s2.size();\\n        while(i > 0 && j > 0){\\n            if(s1[i-1] == s2[j-1]){\\n                lcsstring[index] = s1[i-1];\\n                index--;\\n                i--;\\n                j--;\\n            }else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    i--;\\n                }else if(dp[i-1][j] < dp[i][j-1]){\\n                    j--;\\n                }else{\\n                    if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return lcsstring;\\n    }\\n    int populatedp(string s1, string s2, vector<vector<int>> &dp) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        for(int i = 0; i <= n1; ++i) dp[i][0] = 0;\\n        for(int i = 0; i <= n2; ++i) dp[0][i] = 0;\\n        for(int ind1 = 1; ind1 <= n1; ++ind1){\\n            for(int ind2 = 1; ind2 <= n2; ++ind2){\\n                if(s1[ind1-1] == s2[ind2-1]){\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                }else if(s1[ind1-1] != s2[ind2-1]){\\n                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int ret = 0, n1 = s1.size(), n2 = s2.size();\\n        for(auto& x: s1) ret += x;\\n        for(auto &x: s2 ) ret += x;\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        int lcslen = populatedp(s1,s2,dp);\\n        for(int i = 0; i <= n1; ++i){\\n            for(int j = 0; j <= n2; ++j){\\n                cout << dp[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        string s = lcs(s1,s2,dp,lcslen);\\n        for(int i = 0; i < 2; ++i) for(auto &x: s) ret -= x;\\n        return ret;\\n    }\\n};\\n\\n```\\nInput\\ns1 =\\n\"delete\"\\ns2 =\\n\"leet\"\\nStdout\\n0 0 0 0 0 \\n0 0 0 0 0 \\n0 0 1 1 1 \\n0 1 1 1 1 \\n0 1 2 2 2 \\n0 1 2 2 3 \\n0 1 2 3 3 \\nOutput\\n433\\nExpected\\n403"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Finding out the LCS having the maximum ASCII sum should be the task , but while backtracking and forming LCS , getting maximum ASCII sum one requires us to check for all LCS strings and then compare from it.\\n\\nAnd also in case of else {\\n      s1[i-1] < s2[j-1]\\n     Should be compared not s1[i] and s2[j].\\n}"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "[@shreejaraj026](/shreejaraj026) if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }But I used this snippet in lcs function.. as per the logic it should pick let instead of lee"
                    },
                    {
                        "username": "shreejaraj026",
                        "content": "In this testcase it\\'s picking up the \"lee\" as subsequence that\\'s why we getting result value as 433, if it would have picked up \"let\" as substring then we get 403."
                    }
                ]
            },
            {
                "id": 1994104,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem, but much easier than the one on yesterday! Like the longest common subsequence problem! A substring must be a subsequence, but a subsequence may be not a substring! One more hint: Use the following formula\n$$\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2* asciiSum(LCS)\n$$\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840645/c-several-recursiveiterative-dplcs-beats-9462/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) You can simplify your program by replacing  the line ```if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)``` in lcs(i, j) by ``` if s[i-1] == t[j-1]: dp[i][j] = ord(s[i-1])+lcs(i-1,j-1)```. At final, ``` return res-2*lcs(n, m)``` Everything goes OK!"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@_aka5h](/_aka5h) Now got the point thanks [@Akash Rai](/_aka5h)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) In your case, you can consider \"oo\" to be the LCS with maximum ASCII value. But In general, there is something even more important, that can be overlooked if we use the term LCS, here in this problem we are using LCS pattern and not exactly finding LCS. The idea is to find a subsequence with maximum ASCII value which is common to both given strings and that subsequence doesn't necessarily have to be the LCS of the 2 strings. There might be a case where a subsequence (which is common to both strings and is not LCS) have higher ASSCII sum than the actual LCS of the 2 strings."
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) \n```\nclass Solution:\n    def minimumDeleteSum(self, s: str, t: str) -> int:\n        # finding the lcs\n        def lcs(i,j):\n            if i == 0 or j == 0: return 0\n            if dp[i][j] != -1: return dp[i][j]\n            if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)\n            else: dp[i][j] = max(lcs(i-1,j), lcs(i,j-1))\n            return dp[i][j]\n        n,m = len(s),len(t)\n        dp = [[-1]*(m+1) for _ in range(n+1)]\n        lcs(n,m)\n        res = 0\n        # getting the actual string\n        i,j = n,m\n        string = ''\n        while i>0 and j>0:\n            if s[i-1] == t[j-1]: \n                string = s[i-1]+string\n                i,j = i-1,j-1\n            else:\n                if dp[i-1][j] > dp[i][j-1]: i -= 1\n                elif dp[i-1][j] < dp[i][j-1]: j -= 1\n                else:\n                    if ord(s[i-1]) > ord(t[j-1]): j -= 1\n                    else: i -= 1\n        for i in s: res += ord(i)\n        for i in t: res += ord(i)\n        for i in string: res -= ord(i)*2\n        return res\n```"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) Could you check the below code once..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) I\\'ve tried my 3 solutions. All outputs are 2255"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can you explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. asciiSum(s1) = 1620 asciiSum(s2) = 1079 and asciiSum(lcs) = 217 and according to your formula also it should be 2265 but expected output is 2255"
                    },
                    {
                        "username": "Yaswanth017",
                        "content": "The problem statement never mentioned anything about subsequence. Who else finds this misleading? Leetcode expects us to figure it out by looking at example 2🤷‍♂️🤦‍♂️"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "[@gadmo](/gadmo) Yeah but I\\'m new and when trying to come up with a solution I was confused why you couldn\\'t just delete \"de\" from delete to get lete and leet which are both equal ascvii wise. It never mentions sub sequence just sum which is the same no matter which order they are in. "
                    },
                    {
                        "username": "Princesah999",
                        "content": "I was doing this \\n\\n// delete => deeelt\\n// leet   => eelt"
                    },
                    {
                        "username": "betaev",
                        "content": "[@gadmo](/gadmo) it\\'s longest common subsequence inversed"
                    },
                    {
                        "username": "gadmo",
                        "content": "you don\\'t need to think about subsequence at all to solve this, its almost textbook edit distance."
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Consider this problem as a variation of LCS.\\n"
                    },
                    {
                        "username": "ido.shamir.ido",
                        "content": "I might be missing something here but isn\\'t Example 2 wrong?\\nInput: s1 = \"delete\", s2 = \"leet\"\\nWe can delete \"de\" from s1 and nothing from s2. The strings will be equal (unordered) leet = lete and the sum will be smaller."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@Ido Shamir](/ido.shamir.ido)  This is because the order of the string can\\'t be changed we can only delete elements to make two string equal."
                    },
                    {
                        "username": "prathmesh-jagtap",
                        "content": "[@BlackMamba97](/BlackMamba97)  \\nYes the subsequences are always in contiguous."
                    },
                    {
                        "username": "BlackMamba97",
                        "content": "This is for ordered sequence.\\nRead the definition of subsequence. you will get the answer to your question."
                    },
                    {
                        "username": "paradoxtown",
                        "content": "All of us will become DP masters one day."
                    },
                    {
                        "username": "yurek16II",
                        "content": "Nice example, delete leet == forbidden ;)"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Output 403\\nExpected 403"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Nowadays its seems like DP day😂...everywhere it is present take it whether daily challenge or contest🙂"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "looks like a variation of LCS"
                    },
                    {
                        "username": "panieldark",
                        "content": "Second! Longest Common Subsequence for the win lol"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "# CAN ANYONE TELL ME WHAT AM I DOING WRONG? \\n\\n```\\nclass Solution {\\npublic:\\n    string lcs(string s1, string s2, vector<vector<int>> &dp, int lcslen){\\n        string lcsstring = \"\";\\n        int index = lcslen-1;\\n        for(int i =0; i < lcslen; ++i) lcsstring += \\'#\\';\\n        int i = s1.size(), j = s2.size();\\n        while(i > 0 && j > 0){\\n            if(s1[i-1] == s2[j-1]){\\n                lcsstring[index] = s1[i-1];\\n                index--;\\n                i--;\\n                j--;\\n            }else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    i--;\\n                }else if(dp[i-1][j] < dp[i][j-1]){\\n                    j--;\\n                }else{\\n                    if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return lcsstring;\\n    }\\n    int populatedp(string s1, string s2, vector<vector<int>> &dp) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        for(int i = 0; i <= n1; ++i) dp[i][0] = 0;\\n        for(int i = 0; i <= n2; ++i) dp[0][i] = 0;\\n        for(int ind1 = 1; ind1 <= n1; ++ind1){\\n            for(int ind2 = 1; ind2 <= n2; ++ind2){\\n                if(s1[ind1-1] == s2[ind2-1]){\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                }else if(s1[ind1-1] != s2[ind2-1]){\\n                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int ret = 0, n1 = s1.size(), n2 = s2.size();\\n        for(auto& x: s1) ret += x;\\n        for(auto &x: s2 ) ret += x;\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        int lcslen = populatedp(s1,s2,dp);\\n        for(int i = 0; i <= n1; ++i){\\n            for(int j = 0; j <= n2; ++j){\\n                cout << dp[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        string s = lcs(s1,s2,dp,lcslen);\\n        for(int i = 0; i < 2; ++i) for(auto &x: s) ret -= x;\\n        return ret;\\n    }\\n};\\n\\n```\\nInput\\ns1 =\\n\"delete\"\\ns2 =\\n\"leet\"\\nStdout\\n0 0 0 0 0 \\n0 0 0 0 0 \\n0 0 1 1 1 \\n0 1 1 1 1 \\n0 1 2 2 2 \\n0 1 2 2 3 \\n0 1 2 3 3 \\nOutput\\n433\\nExpected\\n403"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Finding out the LCS having the maximum ASCII sum should be the task , but while backtracking and forming LCS , getting maximum ASCII sum one requires us to check for all LCS strings and then compare from it.\\n\\nAnd also in case of else {\\n      s1[i-1] < s2[j-1]\\n     Should be compared not s1[i] and s2[j].\\n}"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "[@shreejaraj026](/shreejaraj026) if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }But I used this snippet in lcs function.. as per the logic it should pick let instead of lee"
                    },
                    {
                        "username": "shreejaraj026",
                        "content": "In this testcase it\\'s picking up the \"lee\" as subsequence that\\'s why we getting result value as 433, if it would have picked up \"let\" as substring then we get 403."
                    }
                ]
            },
            {
                "id": 1993732,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem, but much easier than the one on yesterday! Like the longest common subsequence problem! A substring must be a subsequence, but a subsequence may be not a substring! One more hint: Use the following formula\n$$\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2* asciiSum(LCS)\n$$\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840645/c-several-recursiveiterative-dplcs-beats-9462/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) You can simplify your program by replacing  the line ```if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)``` in lcs(i, j) by ``` if s[i-1] == t[j-1]: dp[i][j] = ord(s[i-1])+lcs(i-1,j-1)```. At final, ``` return res-2*lcs(n, m)``` Everything goes OK!"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@_aka5h](/_aka5h) Now got the point thanks [@Akash Rai](/_aka5h)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) In your case, you can consider \"oo\" to be the LCS with maximum ASCII value. But In general, there is something even more important, that can be overlooked if we use the term LCS, here in this problem we are using LCS pattern and not exactly finding LCS. The idea is to find a subsequence with maximum ASCII value which is common to both given strings and that subsequence doesn't necessarily have to be the LCS of the 2 strings. There might be a case where a subsequence (which is common to both strings and is not LCS) have higher ASSCII sum than the actual LCS of the 2 strings."
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) \n```\nclass Solution:\n    def minimumDeleteSum(self, s: str, t: str) -> int:\n        # finding the lcs\n        def lcs(i,j):\n            if i == 0 or j == 0: return 0\n            if dp[i][j] != -1: return dp[i][j]\n            if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)\n            else: dp[i][j] = max(lcs(i-1,j), lcs(i,j-1))\n            return dp[i][j]\n        n,m = len(s),len(t)\n        dp = [[-1]*(m+1) for _ in range(n+1)]\n        lcs(n,m)\n        res = 0\n        # getting the actual string\n        i,j = n,m\n        string = ''\n        while i>0 and j>0:\n            if s[i-1] == t[j-1]: \n                string = s[i-1]+string\n                i,j = i-1,j-1\n            else:\n                if dp[i-1][j] > dp[i][j-1]: i -= 1\n                elif dp[i-1][j] < dp[i][j-1]: j -= 1\n                else:\n                    if ord(s[i-1]) > ord(t[j-1]): j -= 1\n                    else: i -= 1\n        for i in s: res += ord(i)\n        for i in t: res += ord(i)\n        for i in string: res -= ord(i)*2\n        return res\n```"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) Could you check the below code once..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) I\\'ve tried my 3 solutions. All outputs are 2255"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can you explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. asciiSum(s1) = 1620 asciiSum(s2) = 1079 and asciiSum(lcs) = 217 and according to your formula also it should be 2265 but expected output is 2255"
                    },
                    {
                        "username": "Yaswanth017",
                        "content": "The problem statement never mentioned anything about subsequence. Who else finds this misleading? Leetcode expects us to figure it out by looking at example 2🤷‍♂️🤦‍♂️"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "[@gadmo](/gadmo) Yeah but I\\'m new and when trying to come up with a solution I was confused why you couldn\\'t just delete \"de\" from delete to get lete and leet which are both equal ascvii wise. It never mentions sub sequence just sum which is the same no matter which order they are in. "
                    },
                    {
                        "username": "Princesah999",
                        "content": "I was doing this \\n\\n// delete => deeelt\\n// leet   => eelt"
                    },
                    {
                        "username": "betaev",
                        "content": "[@gadmo](/gadmo) it\\'s longest common subsequence inversed"
                    },
                    {
                        "username": "gadmo",
                        "content": "you don\\'t need to think about subsequence at all to solve this, its almost textbook edit distance."
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Consider this problem as a variation of LCS.\\n"
                    },
                    {
                        "username": "ido.shamir.ido",
                        "content": "I might be missing something here but isn\\'t Example 2 wrong?\\nInput: s1 = \"delete\", s2 = \"leet\"\\nWe can delete \"de\" from s1 and nothing from s2. The strings will be equal (unordered) leet = lete and the sum will be smaller."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@Ido Shamir](/ido.shamir.ido)  This is because the order of the string can\\'t be changed we can only delete elements to make two string equal."
                    },
                    {
                        "username": "prathmesh-jagtap",
                        "content": "[@BlackMamba97](/BlackMamba97)  \\nYes the subsequences are always in contiguous."
                    },
                    {
                        "username": "BlackMamba97",
                        "content": "This is for ordered sequence.\\nRead the definition of subsequence. you will get the answer to your question."
                    },
                    {
                        "username": "paradoxtown",
                        "content": "All of us will become DP masters one day."
                    },
                    {
                        "username": "yurek16II",
                        "content": "Nice example, delete leet == forbidden ;)"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Output 403\\nExpected 403"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Nowadays its seems like DP day😂...everywhere it is present take it whether daily challenge or contest🙂"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "looks like a variation of LCS"
                    },
                    {
                        "username": "panieldark",
                        "content": "Second! Longest Common Subsequence for the win lol"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "# CAN ANYONE TELL ME WHAT AM I DOING WRONG? \\n\\n```\\nclass Solution {\\npublic:\\n    string lcs(string s1, string s2, vector<vector<int>> &dp, int lcslen){\\n        string lcsstring = \"\";\\n        int index = lcslen-1;\\n        for(int i =0; i < lcslen; ++i) lcsstring += \\'#\\';\\n        int i = s1.size(), j = s2.size();\\n        while(i > 0 && j > 0){\\n            if(s1[i-1] == s2[j-1]){\\n                lcsstring[index] = s1[i-1];\\n                index--;\\n                i--;\\n                j--;\\n            }else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    i--;\\n                }else if(dp[i-1][j] < dp[i][j-1]){\\n                    j--;\\n                }else{\\n                    if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return lcsstring;\\n    }\\n    int populatedp(string s1, string s2, vector<vector<int>> &dp) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        for(int i = 0; i <= n1; ++i) dp[i][0] = 0;\\n        for(int i = 0; i <= n2; ++i) dp[0][i] = 0;\\n        for(int ind1 = 1; ind1 <= n1; ++ind1){\\n            for(int ind2 = 1; ind2 <= n2; ++ind2){\\n                if(s1[ind1-1] == s2[ind2-1]){\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                }else if(s1[ind1-1] != s2[ind2-1]){\\n                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int ret = 0, n1 = s1.size(), n2 = s2.size();\\n        for(auto& x: s1) ret += x;\\n        for(auto &x: s2 ) ret += x;\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        int lcslen = populatedp(s1,s2,dp);\\n        for(int i = 0; i <= n1; ++i){\\n            for(int j = 0; j <= n2; ++j){\\n                cout << dp[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        string s = lcs(s1,s2,dp,lcslen);\\n        for(int i = 0; i < 2; ++i) for(auto &x: s) ret -= x;\\n        return ret;\\n    }\\n};\\n\\n```\\nInput\\ns1 =\\n\"delete\"\\ns2 =\\n\"leet\"\\nStdout\\n0 0 0 0 0 \\n0 0 0 0 0 \\n0 0 1 1 1 \\n0 1 1 1 1 \\n0 1 2 2 2 \\n0 1 2 2 3 \\n0 1 2 3 3 \\nOutput\\n433\\nExpected\\n403"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Finding out the LCS having the maximum ASCII sum should be the task , but while backtracking and forming LCS , getting maximum ASCII sum one requires us to check for all LCS strings and then compare from it.\\n\\nAnd also in case of else {\\n      s1[i-1] < s2[j-1]\\n     Should be compared not s1[i] and s2[j].\\n}"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "[@shreejaraj026](/shreejaraj026) if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }But I used this snippet in lcs function.. as per the logic it should pick let instead of lee"
                    },
                    {
                        "username": "shreejaraj026",
                        "content": "In this testcase it\\'s picking up the \"lee\" as subsequence that\\'s why we getting result value as 433, if it would have picked up \"let\" as substring then we get 403."
                    }
                ]
            },
            {
                "id": 1993768,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem, but much easier than the one on yesterday! Like the longest common subsequence problem! A substring must be a subsequence, but a subsequence may be not a substring! One more hint: Use the following formula\n$$\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2* asciiSum(LCS)\n$$\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840645/c-several-recursiveiterative-dplcs-beats-9462/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) You can simplify your program by replacing  the line ```if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)``` in lcs(i, j) by ``` if s[i-1] == t[j-1]: dp[i][j] = ord(s[i-1])+lcs(i-1,j-1)```. At final, ``` return res-2*lcs(n, m)``` Everything goes OK!"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@_aka5h](/_aka5h) Now got the point thanks [@Akash Rai](/_aka5h)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) In your case, you can consider \"oo\" to be the LCS with maximum ASCII value. But In general, there is something even more important, that can be overlooked if we use the term LCS, here in this problem we are using LCS pattern and not exactly finding LCS. The idea is to find a subsequence with maximum ASCII value which is common to both given strings and that subsequence doesn't necessarily have to be the LCS of the 2 strings. There might be a case where a subsequence (which is common to both strings and is not LCS) have higher ASSCII sum than the actual LCS of the 2 strings."
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) \n```\nclass Solution:\n    def minimumDeleteSum(self, s: str, t: str) -> int:\n        # finding the lcs\n        def lcs(i,j):\n            if i == 0 or j == 0: return 0\n            if dp[i][j] != -1: return dp[i][j]\n            if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)\n            else: dp[i][j] = max(lcs(i-1,j), lcs(i,j-1))\n            return dp[i][j]\n        n,m = len(s),len(t)\n        dp = [[-1]*(m+1) for _ in range(n+1)]\n        lcs(n,m)\n        res = 0\n        # getting the actual string\n        i,j = n,m\n        string = ''\n        while i>0 and j>0:\n            if s[i-1] == t[j-1]: \n                string = s[i-1]+string\n                i,j = i-1,j-1\n            else:\n                if dp[i-1][j] > dp[i][j-1]: i -= 1\n                elif dp[i-1][j] < dp[i][j-1]: j -= 1\n                else:\n                    if ord(s[i-1]) > ord(t[j-1]): j -= 1\n                    else: i -= 1\n        for i in s: res += ord(i)\n        for i in t: res += ord(i)\n        for i in string: res -= ord(i)*2\n        return res\n```"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) Could you check the below code once..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) I\\'ve tried my 3 solutions. All outputs are 2255"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can you explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. asciiSum(s1) = 1620 asciiSum(s2) = 1079 and asciiSum(lcs) = 217 and according to your formula also it should be 2265 but expected output is 2255"
                    },
                    {
                        "username": "Yaswanth017",
                        "content": "The problem statement never mentioned anything about subsequence. Who else finds this misleading? Leetcode expects us to figure it out by looking at example 2🤷‍♂️🤦‍♂️"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "[@gadmo](/gadmo) Yeah but I\\'m new and when trying to come up with a solution I was confused why you couldn\\'t just delete \"de\" from delete to get lete and leet which are both equal ascvii wise. It never mentions sub sequence just sum which is the same no matter which order they are in. "
                    },
                    {
                        "username": "Princesah999",
                        "content": "I was doing this \\n\\n// delete => deeelt\\n// leet   => eelt"
                    },
                    {
                        "username": "betaev",
                        "content": "[@gadmo](/gadmo) it\\'s longest common subsequence inversed"
                    },
                    {
                        "username": "gadmo",
                        "content": "you don\\'t need to think about subsequence at all to solve this, its almost textbook edit distance."
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Consider this problem as a variation of LCS.\\n"
                    },
                    {
                        "username": "ido.shamir.ido",
                        "content": "I might be missing something here but isn\\'t Example 2 wrong?\\nInput: s1 = \"delete\", s2 = \"leet\"\\nWe can delete \"de\" from s1 and nothing from s2. The strings will be equal (unordered) leet = lete and the sum will be smaller."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@Ido Shamir](/ido.shamir.ido)  This is because the order of the string can\\'t be changed we can only delete elements to make two string equal."
                    },
                    {
                        "username": "prathmesh-jagtap",
                        "content": "[@BlackMamba97](/BlackMamba97)  \\nYes the subsequences are always in contiguous."
                    },
                    {
                        "username": "BlackMamba97",
                        "content": "This is for ordered sequence.\\nRead the definition of subsequence. you will get the answer to your question."
                    },
                    {
                        "username": "paradoxtown",
                        "content": "All of us will become DP masters one day."
                    },
                    {
                        "username": "yurek16II",
                        "content": "Nice example, delete leet == forbidden ;)"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Output 403\\nExpected 403"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Nowadays its seems like DP day😂...everywhere it is present take it whether daily challenge or contest🙂"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "looks like a variation of LCS"
                    },
                    {
                        "username": "panieldark",
                        "content": "Second! Longest Common Subsequence for the win lol"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "# CAN ANYONE TELL ME WHAT AM I DOING WRONG? \\n\\n```\\nclass Solution {\\npublic:\\n    string lcs(string s1, string s2, vector<vector<int>> &dp, int lcslen){\\n        string lcsstring = \"\";\\n        int index = lcslen-1;\\n        for(int i =0; i < lcslen; ++i) lcsstring += \\'#\\';\\n        int i = s1.size(), j = s2.size();\\n        while(i > 0 && j > 0){\\n            if(s1[i-1] == s2[j-1]){\\n                lcsstring[index] = s1[i-1];\\n                index--;\\n                i--;\\n                j--;\\n            }else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    i--;\\n                }else if(dp[i-1][j] < dp[i][j-1]){\\n                    j--;\\n                }else{\\n                    if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return lcsstring;\\n    }\\n    int populatedp(string s1, string s2, vector<vector<int>> &dp) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        for(int i = 0; i <= n1; ++i) dp[i][0] = 0;\\n        for(int i = 0; i <= n2; ++i) dp[0][i] = 0;\\n        for(int ind1 = 1; ind1 <= n1; ++ind1){\\n            for(int ind2 = 1; ind2 <= n2; ++ind2){\\n                if(s1[ind1-1] == s2[ind2-1]){\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                }else if(s1[ind1-1] != s2[ind2-1]){\\n                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int ret = 0, n1 = s1.size(), n2 = s2.size();\\n        for(auto& x: s1) ret += x;\\n        for(auto &x: s2 ) ret += x;\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        int lcslen = populatedp(s1,s2,dp);\\n        for(int i = 0; i <= n1; ++i){\\n            for(int j = 0; j <= n2; ++j){\\n                cout << dp[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        string s = lcs(s1,s2,dp,lcslen);\\n        for(int i = 0; i < 2; ++i) for(auto &x: s) ret -= x;\\n        return ret;\\n    }\\n};\\n\\n```\\nInput\\ns1 =\\n\"delete\"\\ns2 =\\n\"leet\"\\nStdout\\n0 0 0 0 0 \\n0 0 0 0 0 \\n0 0 1 1 1 \\n0 1 1 1 1 \\n0 1 2 2 2 \\n0 1 2 2 3 \\n0 1 2 3 3 \\nOutput\\n433\\nExpected\\n403"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Finding out the LCS having the maximum ASCII sum should be the task , but while backtracking and forming LCS , getting maximum ASCII sum one requires us to check for all LCS strings and then compare from it.\\n\\nAnd also in case of else {\\n      s1[i-1] < s2[j-1]\\n     Should be compared not s1[i] and s2[j].\\n}"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "[@shreejaraj026](/shreejaraj026) if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }But I used this snippet in lcs function.. as per the logic it should pick let instead of lee"
                    },
                    {
                        "username": "shreejaraj026",
                        "content": "In this testcase it\\'s picking up the \"lee\" as subsequence that\\'s why we getting result value as 433, if it would have picked up \"let\" as substring then we get 403."
                    }
                ]
            },
            {
                "id": 1712535,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem, but much easier than the one on yesterday! Like the longest common subsequence problem! A substring must be a subsequence, but a subsequence may be not a substring! One more hint: Use the following formula\n$$\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2* asciiSum(LCS)\n$$\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840645/c-several-recursiveiterative-dplcs-beats-9462/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) You can simplify your program by replacing  the line ```if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)``` in lcs(i, j) by ``` if s[i-1] == t[j-1]: dp[i][j] = ord(s[i-1])+lcs(i-1,j-1)```. At final, ``` return res-2*lcs(n, m)``` Everything goes OK!"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@_aka5h](/_aka5h) Now got the point thanks [@Akash Rai](/_aka5h)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) In your case, you can consider \"oo\" to be the LCS with maximum ASCII value. But In general, there is something even more important, that can be overlooked if we use the term LCS, here in this problem we are using LCS pattern and not exactly finding LCS. The idea is to find a subsequence with maximum ASCII value which is common to both given strings and that subsequence doesn't necessarily have to be the LCS of the 2 strings. There might be a case where a subsequence (which is common to both strings and is not LCS) have higher ASSCII sum than the actual LCS of the 2 strings."
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) \n```\nclass Solution:\n    def minimumDeleteSum(self, s: str, t: str) -> int:\n        # finding the lcs\n        def lcs(i,j):\n            if i == 0 or j == 0: return 0\n            if dp[i][j] != -1: return dp[i][j]\n            if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)\n            else: dp[i][j] = max(lcs(i-1,j), lcs(i,j-1))\n            return dp[i][j]\n        n,m = len(s),len(t)\n        dp = [[-1]*(m+1) for _ in range(n+1)]\n        lcs(n,m)\n        res = 0\n        # getting the actual string\n        i,j = n,m\n        string = ''\n        while i>0 and j>0:\n            if s[i-1] == t[j-1]: \n                string = s[i-1]+string\n                i,j = i-1,j-1\n            else:\n                if dp[i-1][j] > dp[i][j-1]: i -= 1\n                elif dp[i-1][j] < dp[i][j-1]: j -= 1\n                else:\n                    if ord(s[i-1]) > ord(t[j-1]): j -= 1\n                    else: i -= 1\n        for i in s: res += ord(i)\n        for i in t: res += ord(i)\n        for i in string: res -= ord(i)*2\n        return res\n```"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) Could you check the below code once..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) I\\'ve tried my 3 solutions. All outputs are 2255"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can you explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. asciiSum(s1) = 1620 asciiSum(s2) = 1079 and asciiSum(lcs) = 217 and according to your formula also it should be 2265 but expected output is 2255"
                    },
                    {
                        "username": "Yaswanth017",
                        "content": "The problem statement never mentioned anything about subsequence. Who else finds this misleading? Leetcode expects us to figure it out by looking at example 2🤷‍♂️🤦‍♂️"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "[@gadmo](/gadmo) Yeah but I\\'m new and when trying to come up with a solution I was confused why you couldn\\'t just delete \"de\" from delete to get lete and leet which are both equal ascvii wise. It never mentions sub sequence just sum which is the same no matter which order they are in. "
                    },
                    {
                        "username": "Princesah999",
                        "content": "I was doing this \\n\\n// delete => deeelt\\n// leet   => eelt"
                    },
                    {
                        "username": "betaev",
                        "content": "[@gadmo](/gadmo) it\\'s longest common subsequence inversed"
                    },
                    {
                        "username": "gadmo",
                        "content": "you don\\'t need to think about subsequence at all to solve this, its almost textbook edit distance."
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Consider this problem as a variation of LCS.\\n"
                    },
                    {
                        "username": "ido.shamir.ido",
                        "content": "I might be missing something here but isn\\'t Example 2 wrong?\\nInput: s1 = \"delete\", s2 = \"leet\"\\nWe can delete \"de\" from s1 and nothing from s2. The strings will be equal (unordered) leet = lete and the sum will be smaller."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@Ido Shamir](/ido.shamir.ido)  This is because the order of the string can\\'t be changed we can only delete elements to make two string equal."
                    },
                    {
                        "username": "prathmesh-jagtap",
                        "content": "[@BlackMamba97](/BlackMamba97)  \\nYes the subsequences are always in contiguous."
                    },
                    {
                        "username": "BlackMamba97",
                        "content": "This is for ordered sequence.\\nRead the definition of subsequence. you will get the answer to your question."
                    },
                    {
                        "username": "paradoxtown",
                        "content": "All of us will become DP masters one day."
                    },
                    {
                        "username": "yurek16II",
                        "content": "Nice example, delete leet == forbidden ;)"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Output 403\\nExpected 403"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Nowadays its seems like DP day😂...everywhere it is present take it whether daily challenge or contest🙂"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "looks like a variation of LCS"
                    },
                    {
                        "username": "panieldark",
                        "content": "Second! Longest Common Subsequence for the win lol"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "# CAN ANYONE TELL ME WHAT AM I DOING WRONG? \\n\\n```\\nclass Solution {\\npublic:\\n    string lcs(string s1, string s2, vector<vector<int>> &dp, int lcslen){\\n        string lcsstring = \"\";\\n        int index = lcslen-1;\\n        for(int i =0; i < lcslen; ++i) lcsstring += \\'#\\';\\n        int i = s1.size(), j = s2.size();\\n        while(i > 0 && j > 0){\\n            if(s1[i-1] == s2[j-1]){\\n                lcsstring[index] = s1[i-1];\\n                index--;\\n                i--;\\n                j--;\\n            }else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    i--;\\n                }else if(dp[i-1][j] < dp[i][j-1]){\\n                    j--;\\n                }else{\\n                    if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return lcsstring;\\n    }\\n    int populatedp(string s1, string s2, vector<vector<int>> &dp) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        for(int i = 0; i <= n1; ++i) dp[i][0] = 0;\\n        for(int i = 0; i <= n2; ++i) dp[0][i] = 0;\\n        for(int ind1 = 1; ind1 <= n1; ++ind1){\\n            for(int ind2 = 1; ind2 <= n2; ++ind2){\\n                if(s1[ind1-1] == s2[ind2-1]){\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                }else if(s1[ind1-1] != s2[ind2-1]){\\n                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int ret = 0, n1 = s1.size(), n2 = s2.size();\\n        for(auto& x: s1) ret += x;\\n        for(auto &x: s2 ) ret += x;\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        int lcslen = populatedp(s1,s2,dp);\\n        for(int i = 0; i <= n1; ++i){\\n            for(int j = 0; j <= n2; ++j){\\n                cout << dp[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        string s = lcs(s1,s2,dp,lcslen);\\n        for(int i = 0; i < 2; ++i) for(auto &x: s) ret -= x;\\n        return ret;\\n    }\\n};\\n\\n```\\nInput\\ns1 =\\n\"delete\"\\ns2 =\\n\"leet\"\\nStdout\\n0 0 0 0 0 \\n0 0 0 0 0 \\n0 0 1 1 1 \\n0 1 1 1 1 \\n0 1 2 2 2 \\n0 1 2 2 3 \\n0 1 2 3 3 \\nOutput\\n433\\nExpected\\n403"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Finding out the LCS having the maximum ASCII sum should be the task , but while backtracking and forming LCS , getting maximum ASCII sum one requires us to check for all LCS strings and then compare from it.\\n\\nAnd also in case of else {\\n      s1[i-1] < s2[j-1]\\n     Should be compared not s1[i] and s2[j].\\n}"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "[@shreejaraj026](/shreejaraj026) if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }But I used this snippet in lcs function.. as per the logic it should pick let instead of lee"
                    },
                    {
                        "username": "shreejaraj026",
                        "content": "In this testcase it\\'s picking up the \"lee\" as subsequence that\\'s why we getting result value as 433, if it would have picked up \"let\" as substring then we get 403."
                    }
                ]
            },
            {
                "id": 1994265,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem, but much easier than the one on yesterday! Like the longest common subsequence problem! A substring must be a subsequence, but a subsequence may be not a substring! One more hint: Use the following formula\n$$\nminimumDeleteSum=asciiSum(s1)+asciiSum(s2)-2* asciiSum(LCS)\n$$\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840645/c-several-recursiveiterative-dplcs-beats-9462/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) You can simplify your program by replacing  the line ```if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)``` in lcs(i, j) by ``` if s[i-1] == t[j-1]: dp[i][j] = ord(s[i-1])+lcs(i-1,j-1)```. At final, ``` return res-2*lcs(n, m)``` Everything goes OK!"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@_aka5h](/_aka5h) Now got the point thanks [@Akash Rai](/_aka5h)"
                    },
                    {
                        "username": "_aka5h",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) In your case, you can consider \"oo\" to be the LCS with maximum ASCII value. But In general, there is something even more important, that can be overlooked if we use the term LCS, here in this problem we are using LCS pattern and not exactly finding LCS. The idea is to find a subsequence with maximum ASCII value which is common to both given strings and that subsequence doesn't necessarily have to be the LCS of the 2 strings. There might be a case where a subsequence (which is common to both strings and is not LCS) have higher ASSCII sum than the actual LCS of the 2 strings."
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) \n```\nclass Solution:\n    def minimumDeleteSum(self, s: str, t: str) -> int:\n        # finding the lcs\n        def lcs(i,j):\n            if i == 0 or j == 0: return 0\n            if dp[i][j] != -1: return dp[i][j]\n            if s[i-1] == t[j-1]: dp[i][j] = 1+lcs(i-1,j-1)\n            else: dp[i][j] = max(lcs(i-1,j), lcs(i,j-1))\n            return dp[i][j]\n        n,m = len(s),len(t)\n        dp = [[-1]*(m+1) for _ in range(n+1)]\n        lcs(n,m)\n        res = 0\n        # getting the actual string\n        i,j = n,m\n        string = ''\n        while i>0 and j>0:\n            if s[i-1] == t[j-1]: \n                string = s[i-1]+string\n                i,j = i-1,j-1\n            else:\n                if dp[i-1][j] > dp[i][j-1]: i -= 1\n                elif dp[i-1][j] < dp[i][j-1]: j -= 1\n                else:\n                    if ord(s[i-1]) > ord(t[j-1]): j -= 1\n                    else: i -= 1\n        for i in s: res += ord(i)\n        for i in t: res += ord(i)\n        for i in string: res -= ord(i)*2\n        return res\n```"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "[@anwendeng](/anwendeng) Could you check the below code once..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hardik_kushwaha](/hardik_kushwaha) I\\'ve tried my 3 solutions. All outputs are 2255"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can you explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. asciiSum(s1) = 1620 asciiSum(s2) = 1079 and asciiSum(lcs) = 217 and according to your formula also it should be 2265 but expected output is 2255"
                    },
                    {
                        "username": "Yaswanth017",
                        "content": "The problem statement never mentioned anything about subsequence. Who else finds this misleading? Leetcode expects us to figure it out by looking at example 2🤷‍♂️🤦‍♂️"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "[@gadmo](/gadmo) Yeah but I\\'m new and when trying to come up with a solution I was confused why you couldn\\'t just delete \"de\" from delete to get lete and leet which are both equal ascvii wise. It never mentions sub sequence just sum which is the same no matter which order they are in. "
                    },
                    {
                        "username": "Princesah999",
                        "content": "I was doing this \\n\\n// delete => deeelt\\n// leet   => eelt"
                    },
                    {
                        "username": "betaev",
                        "content": "[@gadmo](/gadmo) it\\'s longest common subsequence inversed"
                    },
                    {
                        "username": "gadmo",
                        "content": "you don\\'t need to think about subsequence at all to solve this, its almost textbook edit distance."
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Consider this problem as a variation of LCS.\\n"
                    },
                    {
                        "username": "ido.shamir.ido",
                        "content": "I might be missing something here but isn\\'t Example 2 wrong?\\nInput: s1 = \"delete\", s2 = \"leet\"\\nWe can delete \"de\" from s1 and nothing from s2. The strings will be equal (unordered) leet = lete and the sum will be smaller."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@Ido Shamir](/ido.shamir.ido)  This is because the order of the string can\\'t be changed we can only delete elements to make two string equal."
                    },
                    {
                        "username": "prathmesh-jagtap",
                        "content": "[@BlackMamba97](/BlackMamba97)  \\nYes the subsequences are always in contiguous."
                    },
                    {
                        "username": "BlackMamba97",
                        "content": "This is for ordered sequence.\\nRead the definition of subsequence. you will get the answer to your question."
                    },
                    {
                        "username": "paradoxtown",
                        "content": "All of us will become DP masters one day."
                    },
                    {
                        "username": "yurek16II",
                        "content": "Nice example, delete leet == forbidden ;)"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Output 403\\nExpected 403"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Nowadays its seems like DP day😂...everywhere it is present take it whether daily challenge or contest🙂"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "looks like a variation of LCS"
                    },
                    {
                        "username": "panieldark",
                        "content": "Second! Longest Common Subsequence for the win lol"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "# CAN ANYONE TELL ME WHAT AM I DOING WRONG? \\n\\n```\\nclass Solution {\\npublic:\\n    string lcs(string s1, string s2, vector<vector<int>> &dp, int lcslen){\\n        string lcsstring = \"\";\\n        int index = lcslen-1;\\n        for(int i =0; i < lcslen; ++i) lcsstring += \\'#\\';\\n        int i = s1.size(), j = s2.size();\\n        while(i > 0 && j > 0){\\n            if(s1[i-1] == s2[j-1]){\\n                lcsstring[index] = s1[i-1];\\n                index--;\\n                i--;\\n                j--;\\n            }else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    i--;\\n                }else if(dp[i-1][j] < dp[i][j-1]){\\n                    j--;\\n                }else{\\n                    if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return lcsstring;\\n    }\\n    int populatedp(string s1, string s2, vector<vector<int>> &dp) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        for(int i = 0; i <= n1; ++i) dp[i][0] = 0;\\n        for(int i = 0; i <= n2; ++i) dp[0][i] = 0;\\n        for(int ind1 = 1; ind1 <= n1; ++ind1){\\n            for(int ind2 = 1; ind2 <= n2; ++ind2){\\n                if(s1[ind1-1] == s2[ind2-1]){\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                }else if(s1[ind1-1] != s2[ind2-1]){\\n                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int ret = 0, n1 = s1.size(), n2 = s2.size();\\n        for(auto& x: s1) ret += x;\\n        for(auto &x: s2 ) ret += x;\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));\\n        int lcslen = populatedp(s1,s2,dp);\\n        for(int i = 0; i <= n1; ++i){\\n            for(int j = 0; j <= n2; ++j){\\n                cout << dp[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        string s = lcs(s1,s2,dp,lcslen);\\n        for(int i = 0; i < 2; ++i) for(auto &x: s) ret -= x;\\n        return ret;\\n    }\\n};\\n\\n```\\nInput\\ns1 =\\n\"delete\"\\ns2 =\\n\"leet\"\\nStdout\\n0 0 0 0 0 \\n0 0 0 0 0 \\n0 0 1 1 1 \\n0 1 1 1 1 \\n0 1 2 2 2 \\n0 1 2 2 3 \\n0 1 2 3 3 \\nOutput\\n433\\nExpected\\n403"
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Finding out the LCS having the maximum ASCII sum should be the task , but while backtracking and forming LCS , getting maximum ASCII sum one requires us to check for all LCS strings and then compare from it.\\n\\nAnd also in case of else {\\n      s1[i-1] < s2[j-1]\\n     Should be compared not s1[i] and s2[j].\\n}"
                    },
                    {
                        "username": "jn-shriyansh",
                        "content": "[@shreejaraj026](/shreejaraj026) if(s1[i] < s2[j]){\\n                        i--;\\n                    }else{\\n                        j--;\\n                    }But I used this snippet in lcs function.. as per the logic it should pick let instead of lee"
                    },
                    {
                        "username": "shreejaraj026",
                        "content": "In this testcase it\\'s picking up the \"lee\" as subsequence that\\'s why we getting result value as 433, if it would have picked up \"let\" as substring then we get 403."
                    }
                ]
            },
            {
                "id": 1993863,
                "content": [
                    {
                        "username": "rsingh2003",
                        "content": "Am I the only one who is gettling memory limit exceeded on top-down DP."
                    },
                    {
                        "username": "maurice2n97",
                        "content": "I get heap overflow for some reason when building bottom up DP in C++"
                    },
                    {
                        "username": "lcs2021047_iiitl",
                        "content": "I was getting the same, i was not passing strings by reference."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@destiny30](/destiny30) I use the recursive dp code of lcs and get TLE but after using bottom-up Dp my solution got accepted."
                    },
                    {
                        "username": "w7089",
                        "content": "if you use below solution:\\n\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        cost, _ = self.m_d_s(s1,s2)\\n        return cost\\n\\n    @cache\\n    def m_d_s(self,s1,s2):\\n        if s1 == s2:\\n            return 0, True\\n        if s1 and not s2:\\n            return -1, False\\n        if s2 and not s1:\\n            return -1, False\\n        costs = list()\\n        for i in range(len(s1)):\\n            rem = s1[i+1:] if i < len(s1) - 1 else \"\"\\n            cost, eq = self.m_d_s(s1[:i] + rem,s2)\\n            if eq:\\n                cost += ord(s1[i])\\n                costs.append(cost)\\n            cost = 0\\n        for i in range(len(s2)):\\n            rem = s2[i+1:] if i < len(s2) - 1 else \"\"\\n            cost, eq = self.m_d_s(s1, s2[:i] + rem)\\n            if eq:\\n                cost += ord(s2[i])\\n                costs.append(cost)\\n            cost = 0\\n        if costs:\\n            return min(costs), True\\n        return -1, False\\n```\\n\\nyou\\'ll get TLE"
                    },
                    {
                        "username": "nerdstv",
                        "content": "Bro use LCS here."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I didn\\'t get it."
                    },
                    {
                        "username": "sahsan73",
                        "content": "This problem is very similar to DP problem Edit Distance problem:  https://leetcode.com/problems/edit-distance/"
                    },
                    {
                        "username": "isusel",
                        "content": "I was struggling with this problem at first, but then I applied recursion to find a way to use DP here:\n1. I revisited https://leetcode.com/problems/longest-common-subsequence/ (that I haven't done before) and spent some time to come up with the perfect solution there.\n2. After returning here, it took me 5 minutes to write the solution, which achieved 99.66% in time and 92.5% in memory on the first try. It feels so satisfying. :)"
                    },
                    {
                        "username": "devC_B",
                        "content": "Those who are getting  **memory limit exceeded** in memoization approch, for them one tip:-\\n**pass the string to recursive function by reference not by value.**\\n\\n**Reason**:- *When you pass a string by value to a recursive function, the entire string needs to be copied onto the stack for each recursive call. This creates additional memory overhead as the same data is duplicated multiple times, leading to increased memory consumption.*"
                    },
                    {
                        "username": "Under_developed",
                        "content": "So this month started with dp again ended with dp \\uD83D\\uDC80"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Finally completed one month streak, still a long way for 11 \\n more months."
                    },
                    {
                        "username": "shivam-727",
                        "content": "Dp problems are \\u2764"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And I thought Monday was supposed to be for easy problems lol :P"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "Trust your instinct and faith in your recursion. You can take help from your understandings of LCS.\\nNot tough. Plus it will brush your DP skills. \\nBelieve!!!!!!!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "s1=\"xnbteodleejrzeo\"\\ns2=\"gaouojqkkk\"\\nusing LCS approach my output is 2265, but correct is 2255.\\nCan anyone explain the error."
                    },
                    {
                        "username": "dash_dash",
                        "content": "checkout my code \\n```\\nclass Solution\\n{\\npublic:\\n    int f(string s1, int n, string s2, int m, vector<vector<int>> &dp)\\n    {\\n        // base case\\n        if (n < 0 && m < 0)\\n            return 0;\\n\\n        //  if one of the string is empty we will delete all the characters of the other string\\n        if (n < 0)\\n            return f(s1, n, s2, m - 1, dp) + s2[m];\\n        //  if one of the string is empty we will delete all the characters of the other string\\n        if (m < 0)\\n            return f(s1, n - 1, s2, m, dp) + s1[n];\\n\\n        // memo : if the value is already calculated we will return it\\n        if (dp[n][m] != -1)\\n            return dp[n][m];\\n\\n        // if the characters are same we will not delete any character\\n        if (s1[n] == s2[m])\\n            return dp[n][m] = f(s1, n - 1, s2, m - 1, dp);\\n        else\\n        {\\n            // if the characters are not same we will delete the character which will give us the minimum sum\\n            return dp[n][m] = min(f(s1, n - 1, s2, m, dp) + s1[n], f(s1, n, s2, m - 1, dp) + s2[m]);\\n        }\\n\\n        return 0;\\n    }\\n    int minimumDeleteSum(string s1, string s2)\\n    {\\n        int n = s1.size() - 1;\\n        int m = s2.size() - 1;\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));\\n        return f(s1, n, s2, m, dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    void findLCS(string &s1, string &s2, int i, int j, string s, int &minAns, long long int &sum1, long long int &sum2, int &maxLen) {\\n        if(i == s1.size() || j == s2.size()) {\\n            // cout << s << endl;\\n            int size = s.size();\\n            if(size == 0) return;\\n            else if(size >= maxLen)\\n            {\\n                long long int sum = 0;\\n                for(char ch : s) sum += ch;\\n                // cout << sum << endl;\\n                sum = (sum1 + sum2 - 2 * sum);\\n                if(minAns > sum) minAns = sum;\\n                maxLen = s.size();\\n            }\\n            return;\\n        }\\n\\n        if(s1[i] == s2[j]) findLCS(s1, s2, i + 1, j + 1, s + s1[i], minAns, sum1, sum2, maxLen);\\n        else {\\n            findLCS(s1, s2, i + 1, j, s, minAns, sum1, sum2, maxLen);\\n            findLCS(s1, s2, i, j + 1, s, minAns, sum1, sum2, maxLen);\\n        }\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int minAns = INT_MAX;\\n        long long int sum1 = 0, sum2 = 0;\\n        for(char c : s1) {\\n            sum1 += c;\\n        }\\n        for(char c : s2) {\\n            sum2 += c;\\n        }\\n        // cout << sum1 << sum2 << endl;\\n        int maxLen = INT_MIN;\\n        findLCS(s1, s2, 0, 0, \"\", minAns, sum1, sum2, maxLen);\\n        if(minAns == INT_MAX) return sum1 + sum2;\\n        return minAns;\\n    }\\n};\\n\\nThis will pass the Testcase\\ns1=\"xnbteodleejrzeo\"\\ns2=\"gaouojqkkk\"\\nBut it will give TLE after Testcase 63 because I don\\'t know the concept of dp"
                    }
                ]
            },
            {
                "id": 1993805,
                "content": [
                    {
                        "username": "rsingh2003",
                        "content": "Am I the only one who is gettling memory limit exceeded on top-down DP."
                    },
                    {
                        "username": "maurice2n97",
                        "content": "I get heap overflow for some reason when building bottom up DP in C++"
                    },
                    {
                        "username": "lcs2021047_iiitl",
                        "content": "I was getting the same, i was not passing strings by reference."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@destiny30](/destiny30) I use the recursive dp code of lcs and get TLE but after using bottom-up Dp my solution got accepted."
                    },
                    {
                        "username": "w7089",
                        "content": "if you use below solution:\\n\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        cost, _ = self.m_d_s(s1,s2)\\n        return cost\\n\\n    @cache\\n    def m_d_s(self,s1,s2):\\n        if s1 == s2:\\n            return 0, True\\n        if s1 and not s2:\\n            return -1, False\\n        if s2 and not s1:\\n            return -1, False\\n        costs = list()\\n        for i in range(len(s1)):\\n            rem = s1[i+1:] if i < len(s1) - 1 else \"\"\\n            cost, eq = self.m_d_s(s1[:i] + rem,s2)\\n            if eq:\\n                cost += ord(s1[i])\\n                costs.append(cost)\\n            cost = 0\\n        for i in range(len(s2)):\\n            rem = s2[i+1:] if i < len(s2) - 1 else \"\"\\n            cost, eq = self.m_d_s(s1, s2[:i] + rem)\\n            if eq:\\n                cost += ord(s2[i])\\n                costs.append(cost)\\n            cost = 0\\n        if costs:\\n            return min(costs), True\\n        return -1, False\\n```\\n\\nyou\\'ll get TLE"
                    },
                    {
                        "username": "nerdstv",
                        "content": "Bro use LCS here."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I didn\\'t get it."
                    },
                    {
                        "username": "sahsan73",
                        "content": "This problem is very similar to DP problem Edit Distance problem:  https://leetcode.com/problems/edit-distance/"
                    },
                    {
                        "username": "isusel",
                        "content": "I was struggling with this problem at first, but then I applied recursion to find a way to use DP here:\n1. I revisited https://leetcode.com/problems/longest-common-subsequence/ (that I haven't done before) and spent some time to come up with the perfect solution there.\n2. After returning here, it took me 5 minutes to write the solution, which achieved 99.66% in time and 92.5% in memory on the first try. It feels so satisfying. :)"
                    },
                    {
                        "username": "devC_B",
                        "content": "Those who are getting  **memory limit exceeded** in memoization approch, for them one tip:-\\n**pass the string to recursive function by reference not by value.**\\n\\n**Reason**:- *When you pass a string by value to a recursive function, the entire string needs to be copied onto the stack for each recursive call. This creates additional memory overhead as the same data is duplicated multiple times, leading to increased memory consumption.*"
                    },
                    {
                        "username": "Under_developed",
                        "content": "So this month started with dp again ended with dp \\uD83D\\uDC80"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Finally completed one month streak, still a long way for 11 \\n more months."
                    },
                    {
                        "username": "shivam-727",
                        "content": "Dp problems are \\u2764"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And I thought Monday was supposed to be for easy problems lol :P"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "Trust your instinct and faith in your recursion. You can take help from your understandings of LCS.\\nNot tough. Plus it will brush your DP skills. \\nBelieve!!!!!!!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "s1=\"xnbteodleejrzeo\"\\ns2=\"gaouojqkkk\"\\nusing LCS approach my output is 2265, but correct is 2255.\\nCan anyone explain the error."
                    },
                    {
                        "username": "dash_dash",
                        "content": "checkout my code \\n```\\nclass Solution\\n{\\npublic:\\n    int f(string s1, int n, string s2, int m, vector<vector<int>> &dp)\\n    {\\n        // base case\\n        if (n < 0 && m < 0)\\n            return 0;\\n\\n        //  if one of the string is empty we will delete all the characters of the other string\\n        if (n < 0)\\n            return f(s1, n, s2, m - 1, dp) + s2[m];\\n        //  if one of the string is empty we will delete all the characters of the other string\\n        if (m < 0)\\n            return f(s1, n - 1, s2, m, dp) + s1[n];\\n\\n        // memo : if the value is already calculated we will return it\\n        if (dp[n][m] != -1)\\n            return dp[n][m];\\n\\n        // if the characters are same we will not delete any character\\n        if (s1[n] == s2[m])\\n            return dp[n][m] = f(s1, n - 1, s2, m - 1, dp);\\n        else\\n        {\\n            // if the characters are not same we will delete the character which will give us the minimum sum\\n            return dp[n][m] = min(f(s1, n - 1, s2, m, dp) + s1[n], f(s1, n, s2, m - 1, dp) + s2[m]);\\n        }\\n\\n        return 0;\\n    }\\n    int minimumDeleteSum(string s1, string s2)\\n    {\\n        int n = s1.size() - 1;\\n        int m = s2.size() - 1;\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));\\n        return f(s1, n, s2, m, dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    void findLCS(string &s1, string &s2, int i, int j, string s, int &minAns, long long int &sum1, long long int &sum2, int &maxLen) {\\n        if(i == s1.size() || j == s2.size()) {\\n            // cout << s << endl;\\n            int size = s.size();\\n            if(size == 0) return;\\n            else if(size >= maxLen)\\n            {\\n                long long int sum = 0;\\n                for(char ch : s) sum += ch;\\n                // cout << sum << endl;\\n                sum = (sum1 + sum2 - 2 * sum);\\n                if(minAns > sum) minAns = sum;\\n                maxLen = s.size();\\n            }\\n            return;\\n        }\\n\\n        if(s1[i] == s2[j]) findLCS(s1, s2, i + 1, j + 1, s + s1[i], minAns, sum1, sum2, maxLen);\\n        else {\\n            findLCS(s1, s2, i + 1, j, s, minAns, sum1, sum2, maxLen);\\n            findLCS(s1, s2, i, j + 1, s, minAns, sum1, sum2, maxLen);\\n        }\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int minAns = INT_MAX;\\n        long long int sum1 = 0, sum2 = 0;\\n        for(char c : s1) {\\n            sum1 += c;\\n        }\\n        for(char c : s2) {\\n            sum2 += c;\\n        }\\n        // cout << sum1 << sum2 << endl;\\n        int maxLen = INT_MIN;\\n        findLCS(s1, s2, 0, 0, \"\", minAns, sum1, sum2, maxLen);\\n        if(minAns == INT_MAX) return sum1 + sum2;\\n        return minAns;\\n    }\\n};\\n\\nThis will pass the Testcase\\ns1=\"xnbteodleejrzeo\"\\ns2=\"gaouojqkkk\"\\nBut it will give TLE after Testcase 63 because I don\\'t know the concept of dp"
                    }
                ]
            },
            {
                "id": 1995091,
                "content": [
                    {
                        "username": "rsingh2003",
                        "content": "Am I the only one who is gettling memory limit exceeded on top-down DP."
                    },
                    {
                        "username": "maurice2n97",
                        "content": "I get heap overflow for some reason when building bottom up DP in C++"
                    },
                    {
                        "username": "lcs2021047_iiitl",
                        "content": "I was getting the same, i was not passing strings by reference."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@destiny30](/destiny30) I use the recursive dp code of lcs and get TLE but after using bottom-up Dp my solution got accepted."
                    },
                    {
                        "username": "w7089",
                        "content": "if you use below solution:\\n\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        cost, _ = self.m_d_s(s1,s2)\\n        return cost\\n\\n    @cache\\n    def m_d_s(self,s1,s2):\\n        if s1 == s2:\\n            return 0, True\\n        if s1 and not s2:\\n            return -1, False\\n        if s2 and not s1:\\n            return -1, False\\n        costs = list()\\n        for i in range(len(s1)):\\n            rem = s1[i+1:] if i < len(s1) - 1 else \"\"\\n            cost, eq = self.m_d_s(s1[:i] + rem,s2)\\n            if eq:\\n                cost += ord(s1[i])\\n                costs.append(cost)\\n            cost = 0\\n        for i in range(len(s2)):\\n            rem = s2[i+1:] if i < len(s2) - 1 else \"\"\\n            cost, eq = self.m_d_s(s1, s2[:i] + rem)\\n            if eq:\\n                cost += ord(s2[i])\\n                costs.append(cost)\\n            cost = 0\\n        if costs:\\n            return min(costs), True\\n        return -1, False\\n```\\n\\nyou\\'ll get TLE"
                    },
                    {
                        "username": "nerdstv",
                        "content": "Bro use LCS here."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I didn\\'t get it."
                    },
                    {
                        "username": "sahsan73",
                        "content": "This problem is very similar to DP problem Edit Distance problem:  https://leetcode.com/problems/edit-distance/"
                    },
                    {
                        "username": "isusel",
                        "content": "I was struggling with this problem at first, but then I applied recursion to find a way to use DP here:\n1. I revisited https://leetcode.com/problems/longest-common-subsequence/ (that I haven't done before) and spent some time to come up with the perfect solution there.\n2. After returning here, it took me 5 minutes to write the solution, which achieved 99.66% in time and 92.5% in memory on the first try. It feels so satisfying. :)"
                    },
                    {
                        "username": "devC_B",
                        "content": "Those who are getting  **memory limit exceeded** in memoization approch, for them one tip:-\\n**pass the string to recursive function by reference not by value.**\\n\\n**Reason**:- *When you pass a string by value to a recursive function, the entire string needs to be copied onto the stack for each recursive call. This creates additional memory overhead as the same data is duplicated multiple times, leading to increased memory consumption.*"
                    },
                    {
                        "username": "Under_developed",
                        "content": "So this month started with dp again ended with dp \\uD83D\\uDC80"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Finally completed one month streak, still a long way for 11 \\n more months."
                    },
                    {
                        "username": "shivam-727",
                        "content": "Dp problems are \\u2764"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And I thought Monday was supposed to be for easy problems lol :P"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "Trust your instinct and faith in your recursion. You can take help from your understandings of LCS.\\nNot tough. Plus it will brush your DP skills. \\nBelieve!!!!!!!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "s1=\"xnbteodleejrzeo\"\\ns2=\"gaouojqkkk\"\\nusing LCS approach my output is 2265, but correct is 2255.\\nCan anyone explain the error."
                    },
                    {
                        "username": "dash_dash",
                        "content": "checkout my code \\n```\\nclass Solution\\n{\\npublic:\\n    int f(string s1, int n, string s2, int m, vector<vector<int>> &dp)\\n    {\\n        // base case\\n        if (n < 0 && m < 0)\\n            return 0;\\n\\n        //  if one of the string is empty we will delete all the characters of the other string\\n        if (n < 0)\\n            return f(s1, n, s2, m - 1, dp) + s2[m];\\n        //  if one of the string is empty we will delete all the characters of the other string\\n        if (m < 0)\\n            return f(s1, n - 1, s2, m, dp) + s1[n];\\n\\n        // memo : if the value is already calculated we will return it\\n        if (dp[n][m] != -1)\\n            return dp[n][m];\\n\\n        // if the characters are same we will not delete any character\\n        if (s1[n] == s2[m])\\n            return dp[n][m] = f(s1, n - 1, s2, m - 1, dp);\\n        else\\n        {\\n            // if the characters are not same we will delete the character which will give us the minimum sum\\n            return dp[n][m] = min(f(s1, n - 1, s2, m, dp) + s1[n], f(s1, n, s2, m - 1, dp) + s2[m]);\\n        }\\n\\n        return 0;\\n    }\\n    int minimumDeleteSum(string s1, string s2)\\n    {\\n        int n = s1.size() - 1;\\n        int m = s2.size() - 1;\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));\\n        return f(s1, n, s2, m, dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    void findLCS(string &s1, string &s2, int i, int j, string s, int &minAns, long long int &sum1, long long int &sum2, int &maxLen) {\\n        if(i == s1.size() || j == s2.size()) {\\n            // cout << s << endl;\\n            int size = s.size();\\n            if(size == 0) return;\\n            else if(size >= maxLen)\\n            {\\n                long long int sum = 0;\\n                for(char ch : s) sum += ch;\\n                // cout << sum << endl;\\n                sum = (sum1 + sum2 - 2 * sum);\\n                if(minAns > sum) minAns = sum;\\n                maxLen = s.size();\\n            }\\n            return;\\n        }\\n\\n        if(s1[i] == s2[j]) findLCS(s1, s2, i + 1, j + 1, s + s1[i], minAns, sum1, sum2, maxLen);\\n        else {\\n            findLCS(s1, s2, i + 1, j, s, minAns, sum1, sum2, maxLen);\\n            findLCS(s1, s2, i, j + 1, s, minAns, sum1, sum2, maxLen);\\n        }\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int minAns = INT_MAX;\\n        long long int sum1 = 0, sum2 = 0;\\n        for(char c : s1) {\\n            sum1 += c;\\n        }\\n        for(char c : s2) {\\n            sum2 += c;\\n        }\\n        // cout << sum1 << sum2 << endl;\\n        int maxLen = INT_MIN;\\n        findLCS(s1, s2, 0, 0, \"\", minAns, sum1, sum2, maxLen);\\n        if(minAns == INT_MAX) return sum1 + sum2;\\n        return minAns;\\n    }\\n};\\n\\nThis will pass the Testcase\\ns1=\"xnbteodleejrzeo\"\\ns2=\"gaouojqkkk\"\\nBut it will give TLE after Testcase 63 because I don\\'t know the concept of dp"
                    }
                ]
            },
            {
                "id": 1994470,
                "content": [
                    {
                        "username": "rsingh2003",
                        "content": "Am I the only one who is gettling memory limit exceeded on top-down DP."
                    },
                    {
                        "username": "maurice2n97",
                        "content": "I get heap overflow for some reason when building bottom up DP in C++"
                    },
                    {
                        "username": "lcs2021047_iiitl",
                        "content": "I was getting the same, i was not passing strings by reference."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@destiny30](/destiny30) I use the recursive dp code of lcs and get TLE but after using bottom-up Dp my solution got accepted."
                    },
                    {
                        "username": "w7089",
                        "content": "if you use below solution:\\n\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        cost, _ = self.m_d_s(s1,s2)\\n        return cost\\n\\n    @cache\\n    def m_d_s(self,s1,s2):\\n        if s1 == s2:\\n            return 0, True\\n        if s1 and not s2:\\n            return -1, False\\n        if s2 and not s1:\\n            return -1, False\\n        costs = list()\\n        for i in range(len(s1)):\\n            rem = s1[i+1:] if i < len(s1) - 1 else \"\"\\n            cost, eq = self.m_d_s(s1[:i] + rem,s2)\\n            if eq:\\n                cost += ord(s1[i])\\n                costs.append(cost)\\n            cost = 0\\n        for i in range(len(s2)):\\n            rem = s2[i+1:] if i < len(s2) - 1 else \"\"\\n            cost, eq = self.m_d_s(s1, s2[:i] + rem)\\n            if eq:\\n                cost += ord(s2[i])\\n                costs.append(cost)\\n            cost = 0\\n        if costs:\\n            return min(costs), True\\n        return -1, False\\n```\\n\\nyou\\'ll get TLE"
                    },
                    {
                        "username": "nerdstv",
                        "content": "Bro use LCS here."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I didn\\'t get it."
                    },
                    {
                        "username": "sahsan73",
                        "content": "This problem is very similar to DP problem Edit Distance problem:  https://leetcode.com/problems/edit-distance/"
                    },
                    {
                        "username": "isusel",
                        "content": "I was struggling with this problem at first, but then I applied recursion to find a way to use DP here:\n1. I revisited https://leetcode.com/problems/longest-common-subsequence/ (that I haven't done before) and spent some time to come up with the perfect solution there.\n2. After returning here, it took me 5 minutes to write the solution, which achieved 99.66% in time and 92.5% in memory on the first try. It feels so satisfying. :)"
                    },
                    {
                        "username": "devC_B",
                        "content": "Those who are getting  **memory limit exceeded** in memoization approch, for them one tip:-\\n**pass the string to recursive function by reference not by value.**\\n\\n**Reason**:- *When you pass a string by value to a recursive function, the entire string needs to be copied onto the stack for each recursive call. This creates additional memory overhead as the same data is duplicated multiple times, leading to increased memory consumption.*"
                    },
                    {
                        "username": "Under_developed",
                        "content": "So this month started with dp again ended with dp \\uD83D\\uDC80"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Finally completed one month streak, still a long way for 11 \\n more months."
                    },
                    {
                        "username": "shivam-727",
                        "content": "Dp problems are \\u2764"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And I thought Monday was supposed to be for easy problems lol :P"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "Trust your instinct and faith in your recursion. You can take help from your understandings of LCS.\\nNot tough. Plus it will brush your DP skills. \\nBelieve!!!!!!!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "s1=\"xnbteodleejrzeo\"\\ns2=\"gaouojqkkk\"\\nusing LCS approach my output is 2265, but correct is 2255.\\nCan anyone explain the error."
                    },
                    {
                        "username": "dash_dash",
                        "content": "checkout my code \\n```\\nclass Solution\\n{\\npublic:\\n    int f(string s1, int n, string s2, int m, vector<vector<int>> &dp)\\n    {\\n        // base case\\n        if (n < 0 && m < 0)\\n            return 0;\\n\\n        //  if one of the string is empty we will delete all the characters of the other string\\n        if (n < 0)\\n            return f(s1, n, s2, m - 1, dp) + s2[m];\\n        //  if one of the string is empty we will delete all the characters of the other string\\n        if (m < 0)\\n            return f(s1, n - 1, s2, m, dp) + s1[n];\\n\\n        // memo : if the value is already calculated we will return it\\n        if (dp[n][m] != -1)\\n            return dp[n][m];\\n\\n        // if the characters are same we will not delete any character\\n        if (s1[n] == s2[m])\\n            return dp[n][m] = f(s1, n - 1, s2, m - 1, dp);\\n        else\\n        {\\n            // if the characters are not same we will delete the character which will give us the minimum sum\\n            return dp[n][m] = min(f(s1, n - 1, s2, m, dp) + s1[n], f(s1, n, s2, m - 1, dp) + s2[m]);\\n        }\\n\\n        return 0;\\n    }\\n    int minimumDeleteSum(string s1, string s2)\\n    {\\n        int n = s1.size() - 1;\\n        int m = s2.size() - 1;\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));\\n        return f(s1, n, s2, m, dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    void findLCS(string &s1, string &s2, int i, int j, string s, int &minAns, long long int &sum1, long long int &sum2, int &maxLen) {\\n        if(i == s1.size() || j == s2.size()) {\\n            // cout << s << endl;\\n            int size = s.size();\\n            if(size == 0) return;\\n            else if(size >= maxLen)\\n            {\\n                long long int sum = 0;\\n                for(char ch : s) sum += ch;\\n                // cout << sum << endl;\\n                sum = (sum1 + sum2 - 2 * sum);\\n                if(minAns > sum) minAns = sum;\\n                maxLen = s.size();\\n            }\\n            return;\\n        }\\n\\n        if(s1[i] == s2[j]) findLCS(s1, s2, i + 1, j + 1, s + s1[i], minAns, sum1, sum2, maxLen);\\n        else {\\n            findLCS(s1, s2, i + 1, j, s, minAns, sum1, sum2, maxLen);\\n            findLCS(s1, s2, i, j + 1, s, minAns, sum1, sum2, maxLen);\\n        }\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int minAns = INT_MAX;\\n        long long int sum1 = 0, sum2 = 0;\\n        for(char c : s1) {\\n            sum1 += c;\\n        }\\n        for(char c : s2) {\\n            sum2 += c;\\n        }\\n        // cout << sum1 << sum2 << endl;\\n        int maxLen = INT_MIN;\\n        findLCS(s1, s2, 0, 0, \"\", minAns, sum1, sum2, maxLen);\\n        if(minAns == INT_MAX) return sum1 + sum2;\\n        return minAns;\\n    }\\n};\\n\\nThis will pass the Testcase\\ns1=\"xnbteodleejrzeo\"\\ns2=\"gaouojqkkk\"\\nBut it will give TLE after Testcase 63 because I don\\'t know the concept of dp"
                    }
                ]
            },
            {
                "id": 1994370,
                "content": [
                    {
                        "username": "rsingh2003",
                        "content": "Am I the only one who is gettling memory limit exceeded on top-down DP."
                    },
                    {
                        "username": "maurice2n97",
                        "content": "I get heap overflow for some reason when building bottom up DP in C++"
                    },
                    {
                        "username": "lcs2021047_iiitl",
                        "content": "I was getting the same, i was not passing strings by reference."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@destiny30](/destiny30) I use the recursive dp code of lcs and get TLE but after using bottom-up Dp my solution got accepted."
                    },
                    {
                        "username": "w7089",
                        "content": "if you use below solution:\\n\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        cost, _ = self.m_d_s(s1,s2)\\n        return cost\\n\\n    @cache\\n    def m_d_s(self,s1,s2):\\n        if s1 == s2:\\n            return 0, True\\n        if s1 and not s2:\\n            return -1, False\\n        if s2 and not s1:\\n            return -1, False\\n        costs = list()\\n        for i in range(len(s1)):\\n            rem = s1[i+1:] if i < len(s1) - 1 else \"\"\\n            cost, eq = self.m_d_s(s1[:i] + rem,s2)\\n            if eq:\\n                cost += ord(s1[i])\\n                costs.append(cost)\\n            cost = 0\\n        for i in range(len(s2)):\\n            rem = s2[i+1:] if i < len(s2) - 1 else \"\"\\n            cost, eq = self.m_d_s(s1, s2[:i] + rem)\\n            if eq:\\n                cost += ord(s2[i])\\n                costs.append(cost)\\n            cost = 0\\n        if costs:\\n            return min(costs), True\\n        return -1, False\\n```\\n\\nyou\\'ll get TLE"
                    },
                    {
                        "username": "nerdstv",
                        "content": "Bro use LCS here."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I didn\\'t get it."
                    },
                    {
                        "username": "sahsan73",
                        "content": "This problem is very similar to DP problem Edit Distance problem:  https://leetcode.com/problems/edit-distance/"
                    },
                    {
                        "username": "isusel",
                        "content": "I was struggling with this problem at first, but then I applied recursion to find a way to use DP here:\n1. I revisited https://leetcode.com/problems/longest-common-subsequence/ (that I haven't done before) and spent some time to come up with the perfect solution there.\n2. After returning here, it took me 5 minutes to write the solution, which achieved 99.66% in time and 92.5% in memory on the first try. It feels so satisfying. :)"
                    },
                    {
                        "username": "devC_B",
                        "content": "Those who are getting  **memory limit exceeded** in memoization approch, for them one tip:-\\n**pass the string to recursive function by reference not by value.**\\n\\n**Reason**:- *When you pass a string by value to a recursive function, the entire string needs to be copied onto the stack for each recursive call. This creates additional memory overhead as the same data is duplicated multiple times, leading to increased memory consumption.*"
                    },
                    {
                        "username": "Under_developed",
                        "content": "So this month started with dp again ended with dp \\uD83D\\uDC80"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Finally completed one month streak, still a long way for 11 \\n more months."
                    },
                    {
                        "username": "shivam-727",
                        "content": "Dp problems are \\u2764"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And I thought Monday was supposed to be for easy problems lol :P"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "Trust your instinct and faith in your recursion. You can take help from your understandings of LCS.\\nNot tough. Plus it will brush your DP skills. \\nBelieve!!!!!!!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "s1=\"xnbteodleejrzeo\"\\ns2=\"gaouojqkkk\"\\nusing LCS approach my output is 2265, but correct is 2255.\\nCan anyone explain the error."
                    },
                    {
                        "username": "dash_dash",
                        "content": "checkout my code \\n```\\nclass Solution\\n{\\npublic:\\n    int f(string s1, int n, string s2, int m, vector<vector<int>> &dp)\\n    {\\n        // base case\\n        if (n < 0 && m < 0)\\n            return 0;\\n\\n        //  if one of the string is empty we will delete all the characters of the other string\\n        if (n < 0)\\n            return f(s1, n, s2, m - 1, dp) + s2[m];\\n        //  if one of the string is empty we will delete all the characters of the other string\\n        if (m < 0)\\n            return f(s1, n - 1, s2, m, dp) + s1[n];\\n\\n        // memo : if the value is already calculated we will return it\\n        if (dp[n][m] != -1)\\n            return dp[n][m];\\n\\n        // if the characters are same we will not delete any character\\n        if (s1[n] == s2[m])\\n            return dp[n][m] = f(s1, n - 1, s2, m - 1, dp);\\n        else\\n        {\\n            // if the characters are not same we will delete the character which will give us the minimum sum\\n            return dp[n][m] = min(f(s1, n - 1, s2, m, dp) + s1[n], f(s1, n, s2, m - 1, dp) + s2[m]);\\n        }\\n\\n        return 0;\\n    }\\n    int minimumDeleteSum(string s1, string s2)\\n    {\\n        int n = s1.size() - 1;\\n        int m = s2.size() - 1;\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));\\n        return f(s1, n, s2, m, dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    void findLCS(string &s1, string &s2, int i, int j, string s, int &minAns, long long int &sum1, long long int &sum2, int &maxLen) {\\n        if(i == s1.size() || j == s2.size()) {\\n            // cout << s << endl;\\n            int size = s.size();\\n            if(size == 0) return;\\n            else if(size >= maxLen)\\n            {\\n                long long int sum = 0;\\n                for(char ch : s) sum += ch;\\n                // cout << sum << endl;\\n                sum = (sum1 + sum2 - 2 * sum);\\n                if(minAns > sum) minAns = sum;\\n                maxLen = s.size();\\n            }\\n            return;\\n        }\\n\\n        if(s1[i] == s2[j]) findLCS(s1, s2, i + 1, j + 1, s + s1[i], minAns, sum1, sum2, maxLen);\\n        else {\\n            findLCS(s1, s2, i + 1, j, s, minAns, sum1, sum2, maxLen);\\n            findLCS(s1, s2, i, j + 1, s, minAns, sum1, sum2, maxLen);\\n        }\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int minAns = INT_MAX;\\n        long long int sum1 = 0, sum2 = 0;\\n        for(char c : s1) {\\n            sum1 += c;\\n        }\\n        for(char c : s2) {\\n            sum2 += c;\\n        }\\n        // cout << sum1 << sum2 << endl;\\n        int maxLen = INT_MIN;\\n        findLCS(s1, s2, 0, 0, \"\", minAns, sum1, sum2, maxLen);\\n        if(minAns == INT_MAX) return sum1 + sum2;\\n        return minAns;\\n    }\\n};\\n\\nThis will pass the Testcase\\ns1=\"xnbteodleejrzeo\"\\ns2=\"gaouojqkkk\"\\nBut it will give TLE after Testcase 63 because I don\\'t know the concept of dp"
                    }
                ]
            },
            {
                "id": 1994092,
                "content": [
                    {
                        "username": "rsingh2003",
                        "content": "Am I the only one who is gettling memory limit exceeded on top-down DP."
                    },
                    {
                        "username": "maurice2n97",
                        "content": "I get heap overflow for some reason when building bottom up DP in C++"
                    },
                    {
                        "username": "lcs2021047_iiitl",
                        "content": "I was getting the same, i was not passing strings by reference."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@destiny30](/destiny30) I use the recursive dp code of lcs and get TLE but after using bottom-up Dp my solution got accepted."
                    },
                    {
                        "username": "w7089",
                        "content": "if you use below solution:\\n\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        cost, _ = self.m_d_s(s1,s2)\\n        return cost\\n\\n    @cache\\n    def m_d_s(self,s1,s2):\\n        if s1 == s2:\\n            return 0, True\\n        if s1 and not s2:\\n            return -1, False\\n        if s2 and not s1:\\n            return -1, False\\n        costs = list()\\n        for i in range(len(s1)):\\n            rem = s1[i+1:] if i < len(s1) - 1 else \"\"\\n            cost, eq = self.m_d_s(s1[:i] + rem,s2)\\n            if eq:\\n                cost += ord(s1[i])\\n                costs.append(cost)\\n            cost = 0\\n        for i in range(len(s2)):\\n            rem = s2[i+1:] if i < len(s2) - 1 else \"\"\\n            cost, eq = self.m_d_s(s1, s2[:i] + rem)\\n            if eq:\\n                cost += ord(s2[i])\\n                costs.append(cost)\\n            cost = 0\\n        if costs:\\n            return min(costs), True\\n        return -1, False\\n```\\n\\nyou\\'ll get TLE"
                    },
                    {
                        "username": "nerdstv",
                        "content": "Bro use LCS here."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I didn\\'t get it."
                    },
                    {
                        "username": "sahsan73",
                        "content": "This problem is very similar to DP problem Edit Distance problem:  https://leetcode.com/problems/edit-distance/"
                    },
                    {
                        "username": "isusel",
                        "content": "I was struggling with this problem at first, but then I applied recursion to find a way to use DP here:\n1. I revisited https://leetcode.com/problems/longest-common-subsequence/ (that I haven't done before) and spent some time to come up with the perfect solution there.\n2. After returning here, it took me 5 minutes to write the solution, which achieved 99.66% in time and 92.5% in memory on the first try. It feels so satisfying. :)"
                    },
                    {
                        "username": "devC_B",
                        "content": "Those who are getting  **memory limit exceeded** in memoization approch, for them one tip:-\\n**pass the string to recursive function by reference not by value.**\\n\\n**Reason**:- *When you pass a string by value to a recursive function, the entire string needs to be copied onto the stack for each recursive call. This creates additional memory overhead as the same data is duplicated multiple times, leading to increased memory consumption.*"
                    },
                    {
                        "username": "Under_developed",
                        "content": "So this month started with dp again ended with dp \\uD83D\\uDC80"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Finally completed one month streak, still a long way for 11 \\n more months."
                    },
                    {
                        "username": "shivam-727",
                        "content": "Dp problems are \\u2764"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And I thought Monday was supposed to be for easy problems lol :P"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "Trust your instinct and faith in your recursion. You can take help from your understandings of LCS.\\nNot tough. Plus it will brush your DP skills. \\nBelieve!!!!!!!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "s1=\"xnbteodleejrzeo\"\\ns2=\"gaouojqkkk\"\\nusing LCS approach my output is 2265, but correct is 2255.\\nCan anyone explain the error."
                    },
                    {
                        "username": "dash_dash",
                        "content": "checkout my code \\n```\\nclass Solution\\n{\\npublic:\\n    int f(string s1, int n, string s2, int m, vector<vector<int>> &dp)\\n    {\\n        // base case\\n        if (n < 0 && m < 0)\\n            return 0;\\n\\n        //  if one of the string is empty we will delete all the characters of the other string\\n        if (n < 0)\\n            return f(s1, n, s2, m - 1, dp) + s2[m];\\n        //  if one of the string is empty we will delete all the characters of the other string\\n        if (m < 0)\\n            return f(s1, n - 1, s2, m, dp) + s1[n];\\n\\n        // memo : if the value is already calculated we will return it\\n        if (dp[n][m] != -1)\\n            return dp[n][m];\\n\\n        // if the characters are same we will not delete any character\\n        if (s1[n] == s2[m])\\n            return dp[n][m] = f(s1, n - 1, s2, m - 1, dp);\\n        else\\n        {\\n            // if the characters are not same we will delete the character which will give us the minimum sum\\n            return dp[n][m] = min(f(s1, n - 1, s2, m, dp) + s1[n], f(s1, n, s2, m - 1, dp) + s2[m]);\\n        }\\n\\n        return 0;\\n    }\\n    int minimumDeleteSum(string s1, string s2)\\n    {\\n        int n = s1.size() - 1;\\n        int m = s2.size() - 1;\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));\\n        return f(s1, n, s2, m, dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    void findLCS(string &s1, string &s2, int i, int j, string s, int &minAns, long long int &sum1, long long int &sum2, int &maxLen) {\\n        if(i == s1.size() || j == s2.size()) {\\n            // cout << s << endl;\\n            int size = s.size();\\n            if(size == 0) return;\\n            else if(size >= maxLen)\\n            {\\n                long long int sum = 0;\\n                for(char ch : s) sum += ch;\\n                // cout << sum << endl;\\n                sum = (sum1 + sum2 - 2 * sum);\\n                if(minAns > sum) minAns = sum;\\n                maxLen = s.size();\\n            }\\n            return;\\n        }\\n\\n        if(s1[i] == s2[j]) findLCS(s1, s2, i + 1, j + 1, s + s1[i], minAns, sum1, sum2, maxLen);\\n        else {\\n            findLCS(s1, s2, i + 1, j, s, minAns, sum1, sum2, maxLen);\\n            findLCS(s1, s2, i, j + 1, s, minAns, sum1, sum2, maxLen);\\n        }\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int minAns = INT_MAX;\\n        long long int sum1 = 0, sum2 = 0;\\n        for(char c : s1) {\\n            sum1 += c;\\n        }\\n        for(char c : s2) {\\n            sum2 += c;\\n        }\\n        // cout << sum1 << sum2 << endl;\\n        int maxLen = INT_MIN;\\n        findLCS(s1, s2, 0, 0, \"\", minAns, sum1, sum2, maxLen);\\n        if(minAns == INT_MAX) return sum1 + sum2;\\n        return minAns;\\n    }\\n};\\n\\nThis will pass the Testcase\\ns1=\"xnbteodleejrzeo\"\\ns2=\"gaouojqkkk\"\\nBut it will give TLE after Testcase 63 because I don\\'t know the concept of dp"
                    }
                ]
            },
            {
                "id": 1993991,
                "content": [
                    {
                        "username": "rsingh2003",
                        "content": "Am I the only one who is gettling memory limit exceeded on top-down DP."
                    },
                    {
                        "username": "maurice2n97",
                        "content": "I get heap overflow for some reason when building bottom up DP in C++"
                    },
                    {
                        "username": "lcs2021047_iiitl",
                        "content": "I was getting the same, i was not passing strings by reference."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@destiny30](/destiny30) I use the recursive dp code of lcs and get TLE but after using bottom-up Dp my solution got accepted."
                    },
                    {
                        "username": "w7089",
                        "content": "if you use below solution:\\n\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        cost, _ = self.m_d_s(s1,s2)\\n        return cost\\n\\n    @cache\\n    def m_d_s(self,s1,s2):\\n        if s1 == s2:\\n            return 0, True\\n        if s1 and not s2:\\n            return -1, False\\n        if s2 and not s1:\\n            return -1, False\\n        costs = list()\\n        for i in range(len(s1)):\\n            rem = s1[i+1:] if i < len(s1) - 1 else \"\"\\n            cost, eq = self.m_d_s(s1[:i] + rem,s2)\\n            if eq:\\n                cost += ord(s1[i])\\n                costs.append(cost)\\n            cost = 0\\n        for i in range(len(s2)):\\n            rem = s2[i+1:] if i < len(s2) - 1 else \"\"\\n            cost, eq = self.m_d_s(s1, s2[:i] + rem)\\n            if eq:\\n                cost += ord(s2[i])\\n                costs.append(cost)\\n            cost = 0\\n        if costs:\\n            return min(costs), True\\n        return -1, False\\n```\\n\\nyou\\'ll get TLE"
                    },
                    {
                        "username": "nerdstv",
                        "content": "Bro use LCS here."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I didn\\'t get it."
                    },
                    {
                        "username": "sahsan73",
                        "content": "This problem is very similar to DP problem Edit Distance problem:  https://leetcode.com/problems/edit-distance/"
                    },
                    {
                        "username": "isusel",
                        "content": "I was struggling with this problem at first, but then I applied recursion to find a way to use DP here:\n1. I revisited https://leetcode.com/problems/longest-common-subsequence/ (that I haven't done before) and spent some time to come up with the perfect solution there.\n2. After returning here, it took me 5 minutes to write the solution, which achieved 99.66% in time and 92.5% in memory on the first try. It feels so satisfying. :)"
                    },
                    {
                        "username": "devC_B",
                        "content": "Those who are getting  **memory limit exceeded** in memoization approch, for them one tip:-\\n**pass the string to recursive function by reference not by value.**\\n\\n**Reason**:- *When you pass a string by value to a recursive function, the entire string needs to be copied onto the stack for each recursive call. This creates additional memory overhead as the same data is duplicated multiple times, leading to increased memory consumption.*"
                    },
                    {
                        "username": "Under_developed",
                        "content": "So this month started with dp again ended with dp \\uD83D\\uDC80"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Finally completed one month streak, still a long way for 11 \\n more months."
                    },
                    {
                        "username": "shivam-727",
                        "content": "Dp problems are \\u2764"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And I thought Monday was supposed to be for easy problems lol :P"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "Trust your instinct and faith in your recursion. You can take help from your understandings of LCS.\\nNot tough. Plus it will brush your DP skills. \\nBelieve!!!!!!!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "s1=\"xnbteodleejrzeo\"\\ns2=\"gaouojqkkk\"\\nusing LCS approach my output is 2265, but correct is 2255.\\nCan anyone explain the error."
                    },
                    {
                        "username": "dash_dash",
                        "content": "checkout my code \\n```\\nclass Solution\\n{\\npublic:\\n    int f(string s1, int n, string s2, int m, vector<vector<int>> &dp)\\n    {\\n        // base case\\n        if (n < 0 && m < 0)\\n            return 0;\\n\\n        //  if one of the string is empty we will delete all the characters of the other string\\n        if (n < 0)\\n            return f(s1, n, s2, m - 1, dp) + s2[m];\\n        //  if one of the string is empty we will delete all the characters of the other string\\n        if (m < 0)\\n            return f(s1, n - 1, s2, m, dp) + s1[n];\\n\\n        // memo : if the value is already calculated we will return it\\n        if (dp[n][m] != -1)\\n            return dp[n][m];\\n\\n        // if the characters are same we will not delete any character\\n        if (s1[n] == s2[m])\\n            return dp[n][m] = f(s1, n - 1, s2, m - 1, dp);\\n        else\\n        {\\n            // if the characters are not same we will delete the character which will give us the minimum sum\\n            return dp[n][m] = min(f(s1, n - 1, s2, m, dp) + s1[n], f(s1, n, s2, m - 1, dp) + s2[m]);\\n        }\\n\\n        return 0;\\n    }\\n    int minimumDeleteSum(string s1, string s2)\\n    {\\n        int n = s1.size() - 1;\\n        int m = s2.size() - 1;\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));\\n        return f(s1, n, s2, m, dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    void findLCS(string &s1, string &s2, int i, int j, string s, int &minAns, long long int &sum1, long long int &sum2, int &maxLen) {\\n        if(i == s1.size() || j == s2.size()) {\\n            // cout << s << endl;\\n            int size = s.size();\\n            if(size == 0) return;\\n            else if(size >= maxLen)\\n            {\\n                long long int sum = 0;\\n                for(char ch : s) sum += ch;\\n                // cout << sum << endl;\\n                sum = (sum1 + sum2 - 2 * sum);\\n                if(minAns > sum) minAns = sum;\\n                maxLen = s.size();\\n            }\\n            return;\\n        }\\n\\n        if(s1[i] == s2[j]) findLCS(s1, s2, i + 1, j + 1, s + s1[i], minAns, sum1, sum2, maxLen);\\n        else {\\n            findLCS(s1, s2, i + 1, j, s, minAns, sum1, sum2, maxLen);\\n            findLCS(s1, s2, i, j + 1, s, minAns, sum1, sum2, maxLen);\\n        }\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int minAns = INT_MAX;\\n        long long int sum1 = 0, sum2 = 0;\\n        for(char c : s1) {\\n            sum1 += c;\\n        }\\n        for(char c : s2) {\\n            sum2 += c;\\n        }\\n        // cout << sum1 << sum2 << endl;\\n        int maxLen = INT_MIN;\\n        findLCS(s1, s2, 0, 0, \"\", minAns, sum1, sum2, maxLen);\\n        if(minAns == INT_MAX) return sum1 + sum2;\\n        return minAns;\\n    }\\n};\\n\\nThis will pass the Testcase\\ns1=\"xnbteodleejrzeo\"\\ns2=\"gaouojqkkk\"\\nBut it will give TLE after Testcase 63 because I don\\'t know the concept of dp"
                    }
                ]
            },
            {
                "id": 1993956,
                "content": [
                    {
                        "username": "rsingh2003",
                        "content": "Am I the only one who is gettling memory limit exceeded on top-down DP."
                    },
                    {
                        "username": "maurice2n97",
                        "content": "I get heap overflow for some reason when building bottom up DP in C++"
                    },
                    {
                        "username": "lcs2021047_iiitl",
                        "content": "I was getting the same, i was not passing strings by reference."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@destiny30](/destiny30) I use the recursive dp code of lcs and get TLE but after using bottom-up Dp my solution got accepted."
                    },
                    {
                        "username": "w7089",
                        "content": "if you use below solution:\\n\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        cost, _ = self.m_d_s(s1,s2)\\n        return cost\\n\\n    @cache\\n    def m_d_s(self,s1,s2):\\n        if s1 == s2:\\n            return 0, True\\n        if s1 and not s2:\\n            return -1, False\\n        if s2 and not s1:\\n            return -1, False\\n        costs = list()\\n        for i in range(len(s1)):\\n            rem = s1[i+1:] if i < len(s1) - 1 else \"\"\\n            cost, eq = self.m_d_s(s1[:i] + rem,s2)\\n            if eq:\\n                cost += ord(s1[i])\\n                costs.append(cost)\\n            cost = 0\\n        for i in range(len(s2)):\\n            rem = s2[i+1:] if i < len(s2) - 1 else \"\"\\n            cost, eq = self.m_d_s(s1, s2[:i] + rem)\\n            if eq:\\n                cost += ord(s2[i])\\n                costs.append(cost)\\n            cost = 0\\n        if costs:\\n            return min(costs), True\\n        return -1, False\\n```\\n\\nyou\\'ll get TLE"
                    },
                    {
                        "username": "nerdstv",
                        "content": "Bro use LCS here."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I didn\\'t get it."
                    },
                    {
                        "username": "sahsan73",
                        "content": "This problem is very similar to DP problem Edit Distance problem:  https://leetcode.com/problems/edit-distance/"
                    },
                    {
                        "username": "isusel",
                        "content": "I was struggling with this problem at first, but then I applied recursion to find a way to use DP here:\n1. I revisited https://leetcode.com/problems/longest-common-subsequence/ (that I haven't done before) and spent some time to come up with the perfect solution there.\n2. After returning here, it took me 5 minutes to write the solution, which achieved 99.66% in time and 92.5% in memory on the first try. It feels so satisfying. :)"
                    },
                    {
                        "username": "devC_B",
                        "content": "Those who are getting  **memory limit exceeded** in memoization approch, for them one tip:-\\n**pass the string to recursive function by reference not by value.**\\n\\n**Reason**:- *When you pass a string by value to a recursive function, the entire string needs to be copied onto the stack for each recursive call. This creates additional memory overhead as the same data is duplicated multiple times, leading to increased memory consumption.*"
                    },
                    {
                        "username": "Under_developed",
                        "content": "So this month started with dp again ended with dp \\uD83D\\uDC80"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Finally completed one month streak, still a long way for 11 \\n more months."
                    },
                    {
                        "username": "shivam-727",
                        "content": "Dp problems are \\u2764"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And I thought Monday was supposed to be for easy problems lol :P"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "Trust your instinct and faith in your recursion. You can take help from your understandings of LCS.\\nNot tough. Plus it will brush your DP skills. \\nBelieve!!!!!!!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "s1=\"xnbteodleejrzeo\"\\ns2=\"gaouojqkkk\"\\nusing LCS approach my output is 2265, but correct is 2255.\\nCan anyone explain the error."
                    },
                    {
                        "username": "dash_dash",
                        "content": "checkout my code \\n```\\nclass Solution\\n{\\npublic:\\n    int f(string s1, int n, string s2, int m, vector<vector<int>> &dp)\\n    {\\n        // base case\\n        if (n < 0 && m < 0)\\n            return 0;\\n\\n        //  if one of the string is empty we will delete all the characters of the other string\\n        if (n < 0)\\n            return f(s1, n, s2, m - 1, dp) + s2[m];\\n        //  if one of the string is empty we will delete all the characters of the other string\\n        if (m < 0)\\n            return f(s1, n - 1, s2, m, dp) + s1[n];\\n\\n        // memo : if the value is already calculated we will return it\\n        if (dp[n][m] != -1)\\n            return dp[n][m];\\n\\n        // if the characters are same we will not delete any character\\n        if (s1[n] == s2[m])\\n            return dp[n][m] = f(s1, n - 1, s2, m - 1, dp);\\n        else\\n        {\\n            // if the characters are not same we will delete the character which will give us the minimum sum\\n            return dp[n][m] = min(f(s1, n - 1, s2, m, dp) + s1[n], f(s1, n, s2, m - 1, dp) + s2[m]);\\n        }\\n\\n        return 0;\\n    }\\n    int minimumDeleteSum(string s1, string s2)\\n    {\\n        int n = s1.size() - 1;\\n        int m = s2.size() - 1;\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));\\n        return f(s1, n, s2, m, dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    void findLCS(string &s1, string &s2, int i, int j, string s, int &minAns, long long int &sum1, long long int &sum2, int &maxLen) {\\n        if(i == s1.size() || j == s2.size()) {\\n            // cout << s << endl;\\n            int size = s.size();\\n            if(size == 0) return;\\n            else if(size >= maxLen)\\n            {\\n                long long int sum = 0;\\n                for(char ch : s) sum += ch;\\n                // cout << sum << endl;\\n                sum = (sum1 + sum2 - 2 * sum);\\n                if(minAns > sum) minAns = sum;\\n                maxLen = s.size();\\n            }\\n            return;\\n        }\\n\\n        if(s1[i] == s2[j]) findLCS(s1, s2, i + 1, j + 1, s + s1[i], minAns, sum1, sum2, maxLen);\\n        else {\\n            findLCS(s1, s2, i + 1, j, s, minAns, sum1, sum2, maxLen);\\n            findLCS(s1, s2, i, j + 1, s, minAns, sum1, sum2, maxLen);\\n        }\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int minAns = INT_MAX;\\n        long long int sum1 = 0, sum2 = 0;\\n        for(char c : s1) {\\n            sum1 += c;\\n        }\\n        for(char c : s2) {\\n            sum2 += c;\\n        }\\n        // cout << sum1 << sum2 << endl;\\n        int maxLen = INT_MIN;\\n        findLCS(s1, s2, 0, 0, \"\", minAns, sum1, sum2, maxLen);\\n        if(minAns == INT_MAX) return sum1 + sum2;\\n        return minAns;\\n    }\\n};\\n\\nThis will pass the Testcase\\ns1=\"xnbteodleejrzeo\"\\ns2=\"gaouojqkkk\"\\nBut it will give TLE after Testcase 63 because I don\\'t know the concept of dp"
                    }
                ]
            },
            {
                "id": 1993949,
                "content": [
                    {
                        "username": "rsingh2003",
                        "content": "Am I the only one who is gettling memory limit exceeded on top-down DP."
                    },
                    {
                        "username": "maurice2n97",
                        "content": "I get heap overflow for some reason when building bottom up DP in C++"
                    },
                    {
                        "username": "lcs2021047_iiitl",
                        "content": "I was getting the same, i was not passing strings by reference."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@destiny30](/destiny30) I use the recursive dp code of lcs and get TLE but after using bottom-up Dp my solution got accepted."
                    },
                    {
                        "username": "w7089",
                        "content": "if you use below solution:\\n\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        cost, _ = self.m_d_s(s1,s2)\\n        return cost\\n\\n    @cache\\n    def m_d_s(self,s1,s2):\\n        if s1 == s2:\\n            return 0, True\\n        if s1 and not s2:\\n            return -1, False\\n        if s2 and not s1:\\n            return -1, False\\n        costs = list()\\n        for i in range(len(s1)):\\n            rem = s1[i+1:] if i < len(s1) - 1 else \"\"\\n            cost, eq = self.m_d_s(s1[:i] + rem,s2)\\n            if eq:\\n                cost += ord(s1[i])\\n                costs.append(cost)\\n            cost = 0\\n        for i in range(len(s2)):\\n            rem = s2[i+1:] if i < len(s2) - 1 else \"\"\\n            cost, eq = self.m_d_s(s1, s2[:i] + rem)\\n            if eq:\\n                cost += ord(s2[i])\\n                costs.append(cost)\\n            cost = 0\\n        if costs:\\n            return min(costs), True\\n        return -1, False\\n```\\n\\nyou\\'ll get TLE"
                    },
                    {
                        "username": "nerdstv",
                        "content": "Bro use LCS here."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I didn\\'t get it."
                    },
                    {
                        "username": "sahsan73",
                        "content": "This problem is very similar to DP problem Edit Distance problem:  https://leetcode.com/problems/edit-distance/"
                    },
                    {
                        "username": "isusel",
                        "content": "I was struggling with this problem at first, but then I applied recursion to find a way to use DP here:\n1. I revisited https://leetcode.com/problems/longest-common-subsequence/ (that I haven't done before) and spent some time to come up with the perfect solution there.\n2. After returning here, it took me 5 minutes to write the solution, which achieved 99.66% in time and 92.5% in memory on the first try. It feels so satisfying. :)"
                    },
                    {
                        "username": "devC_B",
                        "content": "Those who are getting  **memory limit exceeded** in memoization approch, for them one tip:-\\n**pass the string to recursive function by reference not by value.**\\n\\n**Reason**:- *When you pass a string by value to a recursive function, the entire string needs to be copied onto the stack for each recursive call. This creates additional memory overhead as the same data is duplicated multiple times, leading to increased memory consumption.*"
                    },
                    {
                        "username": "Under_developed",
                        "content": "So this month started with dp again ended with dp \\uD83D\\uDC80"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Finally completed one month streak, still a long way for 11 \\n more months."
                    },
                    {
                        "username": "shivam-727",
                        "content": "Dp problems are \\u2764"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And I thought Monday was supposed to be for easy problems lol :P"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "Trust your instinct and faith in your recursion. You can take help from your understandings of LCS.\\nNot tough. Plus it will brush your DP skills. \\nBelieve!!!!!!!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "s1=\"xnbteodleejrzeo\"\\ns2=\"gaouojqkkk\"\\nusing LCS approach my output is 2265, but correct is 2255.\\nCan anyone explain the error."
                    },
                    {
                        "username": "dash_dash",
                        "content": "checkout my code \\n```\\nclass Solution\\n{\\npublic:\\n    int f(string s1, int n, string s2, int m, vector<vector<int>> &dp)\\n    {\\n        // base case\\n        if (n < 0 && m < 0)\\n            return 0;\\n\\n        //  if one of the string is empty we will delete all the characters of the other string\\n        if (n < 0)\\n            return f(s1, n, s2, m - 1, dp) + s2[m];\\n        //  if one of the string is empty we will delete all the characters of the other string\\n        if (m < 0)\\n            return f(s1, n - 1, s2, m, dp) + s1[n];\\n\\n        // memo : if the value is already calculated we will return it\\n        if (dp[n][m] != -1)\\n            return dp[n][m];\\n\\n        // if the characters are same we will not delete any character\\n        if (s1[n] == s2[m])\\n            return dp[n][m] = f(s1, n - 1, s2, m - 1, dp);\\n        else\\n        {\\n            // if the characters are not same we will delete the character which will give us the minimum sum\\n            return dp[n][m] = min(f(s1, n - 1, s2, m, dp) + s1[n], f(s1, n, s2, m - 1, dp) + s2[m]);\\n        }\\n\\n        return 0;\\n    }\\n    int minimumDeleteSum(string s1, string s2)\\n    {\\n        int n = s1.size() - 1;\\n        int m = s2.size() - 1;\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));\\n        return f(s1, n, s2, m, dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    void findLCS(string &s1, string &s2, int i, int j, string s, int &minAns, long long int &sum1, long long int &sum2, int &maxLen) {\\n        if(i == s1.size() || j == s2.size()) {\\n            // cout << s << endl;\\n            int size = s.size();\\n            if(size == 0) return;\\n            else if(size >= maxLen)\\n            {\\n                long long int sum = 0;\\n                for(char ch : s) sum += ch;\\n                // cout << sum << endl;\\n                sum = (sum1 + sum2 - 2 * sum);\\n                if(minAns > sum) minAns = sum;\\n                maxLen = s.size();\\n            }\\n            return;\\n        }\\n\\n        if(s1[i] == s2[j]) findLCS(s1, s2, i + 1, j + 1, s + s1[i], minAns, sum1, sum2, maxLen);\\n        else {\\n            findLCS(s1, s2, i + 1, j, s, minAns, sum1, sum2, maxLen);\\n            findLCS(s1, s2, i, j + 1, s, minAns, sum1, sum2, maxLen);\\n        }\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int minAns = INT_MAX;\\n        long long int sum1 = 0, sum2 = 0;\\n        for(char c : s1) {\\n            sum1 += c;\\n        }\\n        for(char c : s2) {\\n            sum2 += c;\\n        }\\n        // cout << sum1 << sum2 << endl;\\n        int maxLen = INT_MIN;\\n        findLCS(s1, s2, 0, 0, \"\", minAns, sum1, sum2, maxLen);\\n        if(minAns == INT_MAX) return sum1 + sum2;\\n        return minAns;\\n    }\\n};\\n\\nThis will pass the Testcase\\ns1=\"xnbteodleejrzeo\"\\ns2=\"gaouojqkkk\"\\nBut it will give TLE after Testcase 63 because I don\\'t know the concept of dp"
                    }
                ]
            },
            {
                "id": 1993896,
                "content": [
                    {
                        "username": "rsingh2003",
                        "content": "Am I the only one who is gettling memory limit exceeded on top-down DP."
                    },
                    {
                        "username": "maurice2n97",
                        "content": "I get heap overflow for some reason when building bottom up DP in C++"
                    },
                    {
                        "username": "lcs2021047_iiitl",
                        "content": "I was getting the same, i was not passing strings by reference."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@destiny30](/destiny30) I use the recursive dp code of lcs and get TLE but after using bottom-up Dp my solution got accepted."
                    },
                    {
                        "username": "w7089",
                        "content": "if you use below solution:\\n\\n```\\nclass Solution:\\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        cost, _ = self.m_d_s(s1,s2)\\n        return cost\\n\\n    @cache\\n    def m_d_s(self,s1,s2):\\n        if s1 == s2:\\n            return 0, True\\n        if s1 and not s2:\\n            return -1, False\\n        if s2 and not s1:\\n            return -1, False\\n        costs = list()\\n        for i in range(len(s1)):\\n            rem = s1[i+1:] if i < len(s1) - 1 else \"\"\\n            cost, eq = self.m_d_s(s1[:i] + rem,s2)\\n            if eq:\\n                cost += ord(s1[i])\\n                costs.append(cost)\\n            cost = 0\\n        for i in range(len(s2)):\\n            rem = s2[i+1:] if i < len(s2) - 1 else \"\"\\n            cost, eq = self.m_d_s(s1, s2[:i] + rem)\\n            if eq:\\n                cost += ord(s2[i])\\n                costs.append(cost)\\n            cost = 0\\n        if costs:\\n            return min(costs), True\\n        return -1, False\\n```\\n\\nyou\\'ll get TLE"
                    },
                    {
                        "username": "nerdstv",
                        "content": "Bro use LCS here."
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I didn\\'t get it."
                    },
                    {
                        "username": "sahsan73",
                        "content": "This problem is very similar to DP problem Edit Distance problem:  https://leetcode.com/problems/edit-distance/"
                    },
                    {
                        "username": "isusel",
                        "content": "I was struggling with this problem at first, but then I applied recursion to find a way to use DP here:\n1. I revisited https://leetcode.com/problems/longest-common-subsequence/ (that I haven't done before) and spent some time to come up with the perfect solution there.\n2. After returning here, it took me 5 minutes to write the solution, which achieved 99.66% in time and 92.5% in memory on the first try. It feels so satisfying. :)"
                    },
                    {
                        "username": "devC_B",
                        "content": "Those who are getting  **memory limit exceeded** in memoization approch, for them one tip:-\\n**pass the string to recursive function by reference not by value.**\\n\\n**Reason**:- *When you pass a string by value to a recursive function, the entire string needs to be copied onto the stack for each recursive call. This creates additional memory overhead as the same data is duplicated multiple times, leading to increased memory consumption.*"
                    },
                    {
                        "username": "Under_developed",
                        "content": "So this month started with dp again ended with dp \\uD83D\\uDC80"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Finally completed one month streak, still a long way for 11 \\n more months."
                    },
                    {
                        "username": "shivam-727",
                        "content": "Dp problems are \\u2764"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And I thought Monday was supposed to be for easy problems lol :P"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "Trust your instinct and faith in your recursion. You can take help from your understandings of LCS.\\nNot tough. Plus it will brush your DP skills. \\nBelieve!!!!!!!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "s1=\"xnbteodleejrzeo\"\\ns2=\"gaouojqkkk\"\\nusing LCS approach my output is 2265, but correct is 2255.\\nCan anyone explain the error."
                    },
                    {
                        "username": "dash_dash",
                        "content": "checkout my code \\n```\\nclass Solution\\n{\\npublic:\\n    int f(string s1, int n, string s2, int m, vector<vector<int>> &dp)\\n    {\\n        // base case\\n        if (n < 0 && m < 0)\\n            return 0;\\n\\n        //  if one of the string is empty we will delete all the characters of the other string\\n        if (n < 0)\\n            return f(s1, n, s2, m - 1, dp) + s2[m];\\n        //  if one of the string is empty we will delete all the characters of the other string\\n        if (m < 0)\\n            return f(s1, n - 1, s2, m, dp) + s1[n];\\n\\n        // memo : if the value is already calculated we will return it\\n        if (dp[n][m] != -1)\\n            return dp[n][m];\\n\\n        // if the characters are same we will not delete any character\\n        if (s1[n] == s2[m])\\n            return dp[n][m] = f(s1, n - 1, s2, m - 1, dp);\\n        else\\n        {\\n            // if the characters are not same we will delete the character which will give us the minimum sum\\n            return dp[n][m] = min(f(s1, n - 1, s2, m, dp) + s1[n], f(s1, n, s2, m - 1, dp) + s2[m]);\\n        }\\n\\n        return 0;\\n    }\\n    int minimumDeleteSum(string s1, string s2)\\n    {\\n        int n = s1.size() - 1;\\n        int m = s2.size() - 1;\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));\\n        return f(s1, n, s2, m, dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    void findLCS(string &s1, string &s2, int i, int j, string s, int &minAns, long long int &sum1, long long int &sum2, int &maxLen) {\\n        if(i == s1.size() || j == s2.size()) {\\n            // cout << s << endl;\\n            int size = s.size();\\n            if(size == 0) return;\\n            else if(size >= maxLen)\\n            {\\n                long long int sum = 0;\\n                for(char ch : s) sum += ch;\\n                // cout << sum << endl;\\n                sum = (sum1 + sum2 - 2 * sum);\\n                if(minAns > sum) minAns = sum;\\n                maxLen = s.size();\\n            }\\n            return;\\n        }\\n\\n        if(s1[i] == s2[j]) findLCS(s1, s2, i + 1, j + 1, s + s1[i], minAns, sum1, sum2, maxLen);\\n        else {\\n            findLCS(s1, s2, i + 1, j, s, minAns, sum1, sum2, maxLen);\\n            findLCS(s1, s2, i, j + 1, s, minAns, sum1, sum2, maxLen);\\n        }\\n    }\\n    int minimumDeleteSum(string s1, string s2) {\\n        int minAns = INT_MAX;\\n        long long int sum1 = 0, sum2 = 0;\\n        for(char c : s1) {\\n            sum1 += c;\\n        }\\n        for(char c : s2) {\\n            sum2 += c;\\n        }\\n        // cout << sum1 << sum2 << endl;\\n        int maxLen = INT_MIN;\\n        findLCS(s1, s2, 0, 0, \"\", minAns, sum1, sum2, maxLen);\\n        if(minAns == INT_MAX) return sum1 + sum2;\\n        return minAns;\\n    }\\n};\\n\\nThis will pass the Testcase\\ns1=\"xnbteodleejrzeo\"\\ns2=\"gaouojqkkk\"\\nBut it will give TLE after Testcase 63 because I don\\'t know the concept of dp"
                    }
                ]
            },
            {
                "id": 2052550,
                "content": [
                    {
                        "username": "SeineAle",
                        "content": "it\\'s easy if you\\'ve done LCS !"
                    },
                    {
                        "username": "gujarathikrish",
                        "content": "why this code giving run time error ?\\n\\nclass Solution {\\nprivate:\\n    int solve(string &s1,string &s2,int i,int j,vector<vector<int>> &dp){\\n        if(i==s1.size() && j==s2.size()) return 0;\\n        else if(j!=s2.size() && i==s1.size())\\n        {\\n            int ans=0;\\n            for(int x=j;x<s2.size();x++) ans+=s2[x];\\n            return ans;\\n        }\\n        else if(i!=s1.size() && j==s2.size())\\n        {\\n            int ans=0;\\n            for(int x=i;x<s1.size();x++) ans+=s1[x];\\n            return ans;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        if(s1[i]==s2[j])\\n        {\\n            return dp[i][j]=solve(s1,s2,i+1,j+1,dp);\\n        }\\n        int ans1=s1[i]+solve(s1,s2,i+1,j,dp);\\n        int ans2=s2[j]+solve(s1,s2,i,j+1,dp);\\n        return dp[i][j]=min(ans1,ans2);\\n    }\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.size(),m=s1.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(s1,s2,0,0,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It\\'s basically a Longest Common Subsequence but instead of keeping track of 1 + Math.min(fs(i-1), fs(j-1)) use the ascii code of s1[i] or s2[j].\\nI found the explanations quite clunky so I just used a trimmed version of Levenshtein Distance.  I recommend to study Levenshtein distance (https://leetcode.com/problems/edit-distance/description/ ) as this is a bit more complicated and includes cases for addition, removal and replacement of characters."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me, this problem simulates real-world problems like text comparison and editing, which is widely used in features like auto-correct, spell-check, text matching, etc"
                    },
                    {
                        "username": "omkar098",
                        "content": "I love this daily coding challenge its like re- defining the solution to the critical problem, and on the other side , it motivates and creates enthusiasm well."
                    },
                    {
                        "username": "sangameshMath",
                        "content": "While most of them are getting TLEs, I got MLE for this problem. \\nCan anyone tell me where it is consuming more memory?\\n\\nclass Solution {\\nprivate:\\n    void helper(string s, int i, string sub, int charSum, map<string, int> &mp)\\n    {\\n        if(i >= s.length())\\n        {\\n            mp[sub] = charSum;\\n            return;\\n        }\\n        sub += s[i];\\n        charSum += s[i];\\n        helper(s, i + 1, sub, charSum, mp);\\n        charSum -= s[i];\\n        sub.pop_back();\\n        helper(s, i + 1, sub, charSum, mp);\\n    }\\n\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int sum1 = 0, sum2 = 0;\\n        for(int i = 0; i < s1.length(); i++)\\n        {\\n            sum1 += s1[i];\\n\\n        }\\n        for(int i = 0; i < s2.length(); i++)\\n        {\\n            sum2 += s2[i];\\n        }\\n    map<string, int> mp1, mp2;\\n\\n    helper(s1, 0, \"\", 0, mp1);\\n    helper(s2, 0, \"\", 0, mp2);\\n    int mini = INT_MAX;\\n    for(auto it: mp1)\\n    {\\n       if(mp2[it.first] > 0)\\n       {\\n           mini = min((sum1 - it.second + sum2 - mp2[it.first]), mini);\\n       }\\n    }\\n    if(mini == INT_MAX)\\n        return sum1 + sum2;\\n    return mini;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "Pass strings in helper function by reference."
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "Chumma Editorial Explanation !!!"
                    },
                    {
                        "username": "happygamer123",
                        "content": "saw one of the best and most easy-to-understand editorials on leetcode... amazing one"
                    },
                    {
                        "username": "p4puniya",
                        "content": "I'm just loving this question. Before starting it I had no idea on how to solve the Subsequence DP problems. But as I keep solving it and running into memory limit/tle I came to know about how memoization works, how we use DP from memoised code, learned it and now it works! It just feels so good. 10/10 for the problem."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "for the input  S1= delete and S2=leet . I traced the lcs as \"eet\" but ig it requires \"let\" !!"
                    }
                ]
            },
            {
                "id": 2051671,
                "content": [
                    {
                        "username": "SeineAle",
                        "content": "it\\'s easy if you\\'ve done LCS !"
                    },
                    {
                        "username": "gujarathikrish",
                        "content": "why this code giving run time error ?\\n\\nclass Solution {\\nprivate:\\n    int solve(string &s1,string &s2,int i,int j,vector<vector<int>> &dp){\\n        if(i==s1.size() && j==s2.size()) return 0;\\n        else if(j!=s2.size() && i==s1.size())\\n        {\\n            int ans=0;\\n            for(int x=j;x<s2.size();x++) ans+=s2[x];\\n            return ans;\\n        }\\n        else if(i!=s1.size() && j==s2.size())\\n        {\\n            int ans=0;\\n            for(int x=i;x<s1.size();x++) ans+=s1[x];\\n            return ans;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        if(s1[i]==s2[j])\\n        {\\n            return dp[i][j]=solve(s1,s2,i+1,j+1,dp);\\n        }\\n        int ans1=s1[i]+solve(s1,s2,i+1,j,dp);\\n        int ans2=s2[j]+solve(s1,s2,i,j+1,dp);\\n        return dp[i][j]=min(ans1,ans2);\\n    }\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.size(),m=s1.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(s1,s2,0,0,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It\\'s basically a Longest Common Subsequence but instead of keeping track of 1 + Math.min(fs(i-1), fs(j-1)) use the ascii code of s1[i] or s2[j].\\nI found the explanations quite clunky so I just used a trimmed version of Levenshtein Distance.  I recommend to study Levenshtein distance (https://leetcode.com/problems/edit-distance/description/ ) as this is a bit more complicated and includes cases for addition, removal and replacement of characters."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me, this problem simulates real-world problems like text comparison and editing, which is widely used in features like auto-correct, spell-check, text matching, etc"
                    },
                    {
                        "username": "omkar098",
                        "content": "I love this daily coding challenge its like re- defining the solution to the critical problem, and on the other side , it motivates and creates enthusiasm well."
                    },
                    {
                        "username": "sangameshMath",
                        "content": "While most of them are getting TLEs, I got MLE for this problem. \\nCan anyone tell me where it is consuming more memory?\\n\\nclass Solution {\\nprivate:\\n    void helper(string s, int i, string sub, int charSum, map<string, int> &mp)\\n    {\\n        if(i >= s.length())\\n        {\\n            mp[sub] = charSum;\\n            return;\\n        }\\n        sub += s[i];\\n        charSum += s[i];\\n        helper(s, i + 1, sub, charSum, mp);\\n        charSum -= s[i];\\n        sub.pop_back();\\n        helper(s, i + 1, sub, charSum, mp);\\n    }\\n\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int sum1 = 0, sum2 = 0;\\n        for(int i = 0; i < s1.length(); i++)\\n        {\\n            sum1 += s1[i];\\n\\n        }\\n        for(int i = 0; i < s2.length(); i++)\\n        {\\n            sum2 += s2[i];\\n        }\\n    map<string, int> mp1, mp2;\\n\\n    helper(s1, 0, \"\", 0, mp1);\\n    helper(s2, 0, \"\", 0, mp2);\\n    int mini = INT_MAX;\\n    for(auto it: mp1)\\n    {\\n       if(mp2[it.first] > 0)\\n       {\\n           mini = min((sum1 - it.second + sum2 - mp2[it.first]), mini);\\n       }\\n    }\\n    if(mini == INT_MAX)\\n        return sum1 + sum2;\\n    return mini;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "Pass strings in helper function by reference."
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "Chumma Editorial Explanation !!!"
                    },
                    {
                        "username": "happygamer123",
                        "content": "saw one of the best and most easy-to-understand editorials on leetcode... amazing one"
                    },
                    {
                        "username": "p4puniya",
                        "content": "I'm just loving this question. Before starting it I had no idea on how to solve the Subsequence DP problems. But as I keep solving it and running into memory limit/tle I came to know about how memoization works, how we use DP from memoised code, learned it and now it works! It just feels so good. 10/10 for the problem."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "for the input  S1= delete and S2=leet . I traced the lcs as \"eet\" but ig it requires \"let\" !!"
                    }
                ]
            },
            {
                "id": 1995028,
                "content": [
                    {
                        "username": "SeineAle",
                        "content": "it\\'s easy if you\\'ve done LCS !"
                    },
                    {
                        "username": "gujarathikrish",
                        "content": "why this code giving run time error ?\\n\\nclass Solution {\\nprivate:\\n    int solve(string &s1,string &s2,int i,int j,vector<vector<int>> &dp){\\n        if(i==s1.size() && j==s2.size()) return 0;\\n        else if(j!=s2.size() && i==s1.size())\\n        {\\n            int ans=0;\\n            for(int x=j;x<s2.size();x++) ans+=s2[x];\\n            return ans;\\n        }\\n        else if(i!=s1.size() && j==s2.size())\\n        {\\n            int ans=0;\\n            for(int x=i;x<s1.size();x++) ans+=s1[x];\\n            return ans;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        if(s1[i]==s2[j])\\n        {\\n            return dp[i][j]=solve(s1,s2,i+1,j+1,dp);\\n        }\\n        int ans1=s1[i]+solve(s1,s2,i+1,j,dp);\\n        int ans2=s2[j]+solve(s1,s2,i,j+1,dp);\\n        return dp[i][j]=min(ans1,ans2);\\n    }\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.size(),m=s1.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(s1,s2,0,0,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It\\'s basically a Longest Common Subsequence but instead of keeping track of 1 + Math.min(fs(i-1), fs(j-1)) use the ascii code of s1[i] or s2[j].\\nI found the explanations quite clunky so I just used a trimmed version of Levenshtein Distance.  I recommend to study Levenshtein distance (https://leetcode.com/problems/edit-distance/description/ ) as this is a bit more complicated and includes cases for addition, removal and replacement of characters."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me, this problem simulates real-world problems like text comparison and editing, which is widely used in features like auto-correct, spell-check, text matching, etc"
                    },
                    {
                        "username": "omkar098",
                        "content": "I love this daily coding challenge its like re- defining the solution to the critical problem, and on the other side , it motivates and creates enthusiasm well."
                    },
                    {
                        "username": "sangameshMath",
                        "content": "While most of them are getting TLEs, I got MLE for this problem. \\nCan anyone tell me where it is consuming more memory?\\n\\nclass Solution {\\nprivate:\\n    void helper(string s, int i, string sub, int charSum, map<string, int> &mp)\\n    {\\n        if(i >= s.length())\\n        {\\n            mp[sub] = charSum;\\n            return;\\n        }\\n        sub += s[i];\\n        charSum += s[i];\\n        helper(s, i + 1, sub, charSum, mp);\\n        charSum -= s[i];\\n        sub.pop_back();\\n        helper(s, i + 1, sub, charSum, mp);\\n    }\\n\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int sum1 = 0, sum2 = 0;\\n        for(int i = 0; i < s1.length(); i++)\\n        {\\n            sum1 += s1[i];\\n\\n        }\\n        for(int i = 0; i < s2.length(); i++)\\n        {\\n            sum2 += s2[i];\\n        }\\n    map<string, int> mp1, mp2;\\n\\n    helper(s1, 0, \"\", 0, mp1);\\n    helper(s2, 0, \"\", 0, mp2);\\n    int mini = INT_MAX;\\n    for(auto it: mp1)\\n    {\\n       if(mp2[it.first] > 0)\\n       {\\n           mini = min((sum1 - it.second + sum2 - mp2[it.first]), mini);\\n       }\\n    }\\n    if(mini == INT_MAX)\\n        return sum1 + sum2;\\n    return mini;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "Pass strings in helper function by reference."
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "Chumma Editorial Explanation !!!"
                    },
                    {
                        "username": "happygamer123",
                        "content": "saw one of the best and most easy-to-understand editorials on leetcode... amazing one"
                    },
                    {
                        "username": "p4puniya",
                        "content": "I'm just loving this question. Before starting it I had no idea on how to solve the Subsequence DP problems. But as I keep solving it and running into memory limit/tle I came to know about how memoization works, how we use DP from memoised code, learned it and now it works! It just feels so good. 10/10 for the problem."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "for the input  S1= delete and S2=leet . I traced the lcs as \"eet\" but ig it requires \"let\" !!"
                    }
                ]
            },
            {
                "id": 1994953,
                "content": [
                    {
                        "username": "SeineAle",
                        "content": "it\\'s easy if you\\'ve done LCS !"
                    },
                    {
                        "username": "gujarathikrish",
                        "content": "why this code giving run time error ?\\n\\nclass Solution {\\nprivate:\\n    int solve(string &s1,string &s2,int i,int j,vector<vector<int>> &dp){\\n        if(i==s1.size() && j==s2.size()) return 0;\\n        else if(j!=s2.size() && i==s1.size())\\n        {\\n            int ans=0;\\n            for(int x=j;x<s2.size();x++) ans+=s2[x];\\n            return ans;\\n        }\\n        else if(i!=s1.size() && j==s2.size())\\n        {\\n            int ans=0;\\n            for(int x=i;x<s1.size();x++) ans+=s1[x];\\n            return ans;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        if(s1[i]==s2[j])\\n        {\\n            return dp[i][j]=solve(s1,s2,i+1,j+1,dp);\\n        }\\n        int ans1=s1[i]+solve(s1,s2,i+1,j,dp);\\n        int ans2=s2[j]+solve(s1,s2,i,j+1,dp);\\n        return dp[i][j]=min(ans1,ans2);\\n    }\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.size(),m=s1.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(s1,s2,0,0,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It\\'s basically a Longest Common Subsequence but instead of keeping track of 1 + Math.min(fs(i-1), fs(j-1)) use the ascii code of s1[i] or s2[j].\\nI found the explanations quite clunky so I just used a trimmed version of Levenshtein Distance.  I recommend to study Levenshtein distance (https://leetcode.com/problems/edit-distance/description/ ) as this is a bit more complicated and includes cases for addition, removal and replacement of characters."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me, this problem simulates real-world problems like text comparison and editing, which is widely used in features like auto-correct, spell-check, text matching, etc"
                    },
                    {
                        "username": "omkar098",
                        "content": "I love this daily coding challenge its like re- defining the solution to the critical problem, and on the other side , it motivates and creates enthusiasm well."
                    },
                    {
                        "username": "sangameshMath",
                        "content": "While most of them are getting TLEs, I got MLE for this problem. \\nCan anyone tell me where it is consuming more memory?\\n\\nclass Solution {\\nprivate:\\n    void helper(string s, int i, string sub, int charSum, map<string, int> &mp)\\n    {\\n        if(i >= s.length())\\n        {\\n            mp[sub] = charSum;\\n            return;\\n        }\\n        sub += s[i];\\n        charSum += s[i];\\n        helper(s, i + 1, sub, charSum, mp);\\n        charSum -= s[i];\\n        sub.pop_back();\\n        helper(s, i + 1, sub, charSum, mp);\\n    }\\n\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int sum1 = 0, sum2 = 0;\\n        for(int i = 0; i < s1.length(); i++)\\n        {\\n            sum1 += s1[i];\\n\\n        }\\n        for(int i = 0; i < s2.length(); i++)\\n        {\\n            sum2 += s2[i];\\n        }\\n    map<string, int> mp1, mp2;\\n\\n    helper(s1, 0, \"\", 0, mp1);\\n    helper(s2, 0, \"\", 0, mp2);\\n    int mini = INT_MAX;\\n    for(auto it: mp1)\\n    {\\n       if(mp2[it.first] > 0)\\n       {\\n           mini = min((sum1 - it.second + sum2 - mp2[it.first]), mini);\\n       }\\n    }\\n    if(mini == INT_MAX)\\n        return sum1 + sum2;\\n    return mini;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "Pass strings in helper function by reference."
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "Chumma Editorial Explanation !!!"
                    },
                    {
                        "username": "happygamer123",
                        "content": "saw one of the best and most easy-to-understand editorials on leetcode... amazing one"
                    },
                    {
                        "username": "p4puniya",
                        "content": "I'm just loving this question. Before starting it I had no idea on how to solve the Subsequence DP problems. But as I keep solving it and running into memory limit/tle I came to know about how memoization works, how we use DP from memoised code, learned it and now it works! It just feels so good. 10/10 for the problem."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "for the input  S1= delete and S2=leet . I traced the lcs as \"eet\" but ig it requires \"let\" !!"
                    }
                ]
            },
            {
                "id": 1994861,
                "content": [
                    {
                        "username": "SeineAle",
                        "content": "it\\'s easy if you\\'ve done LCS !"
                    },
                    {
                        "username": "gujarathikrish",
                        "content": "why this code giving run time error ?\\n\\nclass Solution {\\nprivate:\\n    int solve(string &s1,string &s2,int i,int j,vector<vector<int>> &dp){\\n        if(i==s1.size() && j==s2.size()) return 0;\\n        else if(j!=s2.size() && i==s1.size())\\n        {\\n            int ans=0;\\n            for(int x=j;x<s2.size();x++) ans+=s2[x];\\n            return ans;\\n        }\\n        else if(i!=s1.size() && j==s2.size())\\n        {\\n            int ans=0;\\n            for(int x=i;x<s1.size();x++) ans+=s1[x];\\n            return ans;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        if(s1[i]==s2[j])\\n        {\\n            return dp[i][j]=solve(s1,s2,i+1,j+1,dp);\\n        }\\n        int ans1=s1[i]+solve(s1,s2,i+1,j,dp);\\n        int ans2=s2[j]+solve(s1,s2,i,j+1,dp);\\n        return dp[i][j]=min(ans1,ans2);\\n    }\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.size(),m=s1.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(s1,s2,0,0,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It\\'s basically a Longest Common Subsequence but instead of keeping track of 1 + Math.min(fs(i-1), fs(j-1)) use the ascii code of s1[i] or s2[j].\\nI found the explanations quite clunky so I just used a trimmed version of Levenshtein Distance.  I recommend to study Levenshtein distance (https://leetcode.com/problems/edit-distance/description/ ) as this is a bit more complicated and includes cases for addition, removal and replacement of characters."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me, this problem simulates real-world problems like text comparison and editing, which is widely used in features like auto-correct, spell-check, text matching, etc"
                    },
                    {
                        "username": "omkar098",
                        "content": "I love this daily coding challenge its like re- defining the solution to the critical problem, and on the other side , it motivates and creates enthusiasm well."
                    },
                    {
                        "username": "sangameshMath",
                        "content": "While most of them are getting TLEs, I got MLE for this problem. \\nCan anyone tell me where it is consuming more memory?\\n\\nclass Solution {\\nprivate:\\n    void helper(string s, int i, string sub, int charSum, map<string, int> &mp)\\n    {\\n        if(i >= s.length())\\n        {\\n            mp[sub] = charSum;\\n            return;\\n        }\\n        sub += s[i];\\n        charSum += s[i];\\n        helper(s, i + 1, sub, charSum, mp);\\n        charSum -= s[i];\\n        sub.pop_back();\\n        helper(s, i + 1, sub, charSum, mp);\\n    }\\n\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int sum1 = 0, sum2 = 0;\\n        for(int i = 0; i < s1.length(); i++)\\n        {\\n            sum1 += s1[i];\\n\\n        }\\n        for(int i = 0; i < s2.length(); i++)\\n        {\\n            sum2 += s2[i];\\n        }\\n    map<string, int> mp1, mp2;\\n\\n    helper(s1, 0, \"\", 0, mp1);\\n    helper(s2, 0, \"\", 0, mp2);\\n    int mini = INT_MAX;\\n    for(auto it: mp1)\\n    {\\n       if(mp2[it.first] > 0)\\n       {\\n           mini = min((sum1 - it.second + sum2 - mp2[it.first]), mini);\\n       }\\n    }\\n    if(mini == INT_MAX)\\n        return sum1 + sum2;\\n    return mini;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "Pass strings in helper function by reference."
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "Chumma Editorial Explanation !!!"
                    },
                    {
                        "username": "happygamer123",
                        "content": "saw one of the best and most easy-to-understand editorials on leetcode... amazing one"
                    },
                    {
                        "username": "p4puniya",
                        "content": "I'm just loving this question. Before starting it I had no idea on how to solve the Subsequence DP problems. But as I keep solving it and running into memory limit/tle I came to know about how memoization works, how we use DP from memoised code, learned it and now it works! It just feels so good. 10/10 for the problem."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "for the input  S1= delete and S2=leet . I traced the lcs as \"eet\" but ig it requires \"let\" !!"
                    }
                ]
            },
            {
                "id": 1994806,
                "content": [
                    {
                        "username": "SeineAle",
                        "content": "it\\'s easy if you\\'ve done LCS !"
                    },
                    {
                        "username": "gujarathikrish",
                        "content": "why this code giving run time error ?\\n\\nclass Solution {\\nprivate:\\n    int solve(string &s1,string &s2,int i,int j,vector<vector<int>> &dp){\\n        if(i==s1.size() && j==s2.size()) return 0;\\n        else if(j!=s2.size() && i==s1.size())\\n        {\\n            int ans=0;\\n            for(int x=j;x<s2.size();x++) ans+=s2[x];\\n            return ans;\\n        }\\n        else if(i!=s1.size() && j==s2.size())\\n        {\\n            int ans=0;\\n            for(int x=i;x<s1.size();x++) ans+=s1[x];\\n            return ans;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        if(s1[i]==s2[j])\\n        {\\n            return dp[i][j]=solve(s1,s2,i+1,j+1,dp);\\n        }\\n        int ans1=s1[i]+solve(s1,s2,i+1,j,dp);\\n        int ans2=s2[j]+solve(s1,s2,i,j+1,dp);\\n        return dp[i][j]=min(ans1,ans2);\\n    }\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.size(),m=s1.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(s1,s2,0,0,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It\\'s basically a Longest Common Subsequence but instead of keeping track of 1 + Math.min(fs(i-1), fs(j-1)) use the ascii code of s1[i] or s2[j].\\nI found the explanations quite clunky so I just used a trimmed version of Levenshtein Distance.  I recommend to study Levenshtein distance (https://leetcode.com/problems/edit-distance/description/ ) as this is a bit more complicated and includes cases for addition, removal and replacement of characters."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me, this problem simulates real-world problems like text comparison and editing, which is widely used in features like auto-correct, spell-check, text matching, etc"
                    },
                    {
                        "username": "omkar098",
                        "content": "I love this daily coding challenge its like re- defining the solution to the critical problem, and on the other side , it motivates and creates enthusiasm well."
                    },
                    {
                        "username": "sangameshMath",
                        "content": "While most of them are getting TLEs, I got MLE for this problem. \\nCan anyone tell me where it is consuming more memory?\\n\\nclass Solution {\\nprivate:\\n    void helper(string s, int i, string sub, int charSum, map<string, int> &mp)\\n    {\\n        if(i >= s.length())\\n        {\\n            mp[sub] = charSum;\\n            return;\\n        }\\n        sub += s[i];\\n        charSum += s[i];\\n        helper(s, i + 1, sub, charSum, mp);\\n        charSum -= s[i];\\n        sub.pop_back();\\n        helper(s, i + 1, sub, charSum, mp);\\n    }\\n\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int sum1 = 0, sum2 = 0;\\n        for(int i = 0; i < s1.length(); i++)\\n        {\\n            sum1 += s1[i];\\n\\n        }\\n        for(int i = 0; i < s2.length(); i++)\\n        {\\n            sum2 += s2[i];\\n        }\\n    map<string, int> mp1, mp2;\\n\\n    helper(s1, 0, \"\", 0, mp1);\\n    helper(s2, 0, \"\", 0, mp2);\\n    int mini = INT_MAX;\\n    for(auto it: mp1)\\n    {\\n       if(mp2[it.first] > 0)\\n       {\\n           mini = min((sum1 - it.second + sum2 - mp2[it.first]), mini);\\n       }\\n    }\\n    if(mini == INT_MAX)\\n        return sum1 + sum2;\\n    return mini;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "Pass strings in helper function by reference."
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "Chumma Editorial Explanation !!!"
                    },
                    {
                        "username": "happygamer123",
                        "content": "saw one of the best and most easy-to-understand editorials on leetcode... amazing one"
                    },
                    {
                        "username": "p4puniya",
                        "content": "I'm just loving this question. Before starting it I had no idea on how to solve the Subsequence DP problems. But as I keep solving it and running into memory limit/tle I came to know about how memoization works, how we use DP from memoised code, learned it and now it works! It just feels so good. 10/10 for the problem."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "for the input  S1= delete and S2=leet . I traced the lcs as \"eet\" but ig it requires \"let\" !!"
                    }
                ]
            },
            {
                "id": 1994804,
                "content": [
                    {
                        "username": "SeineAle",
                        "content": "it\\'s easy if you\\'ve done LCS !"
                    },
                    {
                        "username": "gujarathikrish",
                        "content": "why this code giving run time error ?\\n\\nclass Solution {\\nprivate:\\n    int solve(string &s1,string &s2,int i,int j,vector<vector<int>> &dp){\\n        if(i==s1.size() && j==s2.size()) return 0;\\n        else if(j!=s2.size() && i==s1.size())\\n        {\\n            int ans=0;\\n            for(int x=j;x<s2.size();x++) ans+=s2[x];\\n            return ans;\\n        }\\n        else if(i!=s1.size() && j==s2.size())\\n        {\\n            int ans=0;\\n            for(int x=i;x<s1.size();x++) ans+=s1[x];\\n            return ans;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        if(s1[i]==s2[j])\\n        {\\n            return dp[i][j]=solve(s1,s2,i+1,j+1,dp);\\n        }\\n        int ans1=s1[i]+solve(s1,s2,i+1,j,dp);\\n        int ans2=s2[j]+solve(s1,s2,i,j+1,dp);\\n        return dp[i][j]=min(ans1,ans2);\\n    }\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.size(),m=s1.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(s1,s2,0,0,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It\\'s basically a Longest Common Subsequence but instead of keeping track of 1 + Math.min(fs(i-1), fs(j-1)) use the ascii code of s1[i] or s2[j].\\nI found the explanations quite clunky so I just used a trimmed version of Levenshtein Distance.  I recommend to study Levenshtein distance (https://leetcode.com/problems/edit-distance/description/ ) as this is a bit more complicated and includes cases for addition, removal and replacement of characters."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me, this problem simulates real-world problems like text comparison and editing, which is widely used in features like auto-correct, spell-check, text matching, etc"
                    },
                    {
                        "username": "omkar098",
                        "content": "I love this daily coding challenge its like re- defining the solution to the critical problem, and on the other side , it motivates and creates enthusiasm well."
                    },
                    {
                        "username": "sangameshMath",
                        "content": "While most of them are getting TLEs, I got MLE for this problem. \\nCan anyone tell me where it is consuming more memory?\\n\\nclass Solution {\\nprivate:\\n    void helper(string s, int i, string sub, int charSum, map<string, int> &mp)\\n    {\\n        if(i >= s.length())\\n        {\\n            mp[sub] = charSum;\\n            return;\\n        }\\n        sub += s[i];\\n        charSum += s[i];\\n        helper(s, i + 1, sub, charSum, mp);\\n        charSum -= s[i];\\n        sub.pop_back();\\n        helper(s, i + 1, sub, charSum, mp);\\n    }\\n\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int sum1 = 0, sum2 = 0;\\n        for(int i = 0; i < s1.length(); i++)\\n        {\\n            sum1 += s1[i];\\n\\n        }\\n        for(int i = 0; i < s2.length(); i++)\\n        {\\n            sum2 += s2[i];\\n        }\\n    map<string, int> mp1, mp2;\\n\\n    helper(s1, 0, \"\", 0, mp1);\\n    helper(s2, 0, \"\", 0, mp2);\\n    int mini = INT_MAX;\\n    for(auto it: mp1)\\n    {\\n       if(mp2[it.first] > 0)\\n       {\\n           mini = min((sum1 - it.second + sum2 - mp2[it.first]), mini);\\n       }\\n    }\\n    if(mini == INT_MAX)\\n        return sum1 + sum2;\\n    return mini;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "Pass strings in helper function by reference."
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "Chumma Editorial Explanation !!!"
                    },
                    {
                        "username": "happygamer123",
                        "content": "saw one of the best and most easy-to-understand editorials on leetcode... amazing one"
                    },
                    {
                        "username": "p4puniya",
                        "content": "I'm just loving this question. Before starting it I had no idea on how to solve the Subsequence DP problems. But as I keep solving it and running into memory limit/tle I came to know about how memoization works, how we use DP from memoised code, learned it and now it works! It just feels so good. 10/10 for the problem."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "for the input  S1= delete and S2=leet . I traced the lcs as \"eet\" but ig it requires \"let\" !!"
                    }
                ]
            },
            {
                "id": 1994687,
                "content": [
                    {
                        "username": "SeineAle",
                        "content": "it\\'s easy if you\\'ve done LCS !"
                    },
                    {
                        "username": "gujarathikrish",
                        "content": "why this code giving run time error ?\\n\\nclass Solution {\\nprivate:\\n    int solve(string &s1,string &s2,int i,int j,vector<vector<int>> &dp){\\n        if(i==s1.size() && j==s2.size()) return 0;\\n        else if(j!=s2.size() && i==s1.size())\\n        {\\n            int ans=0;\\n            for(int x=j;x<s2.size();x++) ans+=s2[x];\\n            return ans;\\n        }\\n        else if(i!=s1.size() && j==s2.size())\\n        {\\n            int ans=0;\\n            for(int x=i;x<s1.size();x++) ans+=s1[x];\\n            return ans;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        if(s1[i]==s2[j])\\n        {\\n            return dp[i][j]=solve(s1,s2,i+1,j+1,dp);\\n        }\\n        int ans1=s1[i]+solve(s1,s2,i+1,j,dp);\\n        int ans2=s2[j]+solve(s1,s2,i,j+1,dp);\\n        return dp[i][j]=min(ans1,ans2);\\n    }\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.size(),m=s1.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(s1,s2,0,0,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It\\'s basically a Longest Common Subsequence but instead of keeping track of 1 + Math.min(fs(i-1), fs(j-1)) use the ascii code of s1[i] or s2[j].\\nI found the explanations quite clunky so I just used a trimmed version of Levenshtein Distance.  I recommend to study Levenshtein distance (https://leetcode.com/problems/edit-distance/description/ ) as this is a bit more complicated and includes cases for addition, removal and replacement of characters."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me, this problem simulates real-world problems like text comparison and editing, which is widely used in features like auto-correct, spell-check, text matching, etc"
                    },
                    {
                        "username": "omkar098",
                        "content": "I love this daily coding challenge its like re- defining the solution to the critical problem, and on the other side , it motivates and creates enthusiasm well."
                    },
                    {
                        "username": "sangameshMath",
                        "content": "While most of them are getting TLEs, I got MLE for this problem. \\nCan anyone tell me where it is consuming more memory?\\n\\nclass Solution {\\nprivate:\\n    void helper(string s, int i, string sub, int charSum, map<string, int> &mp)\\n    {\\n        if(i >= s.length())\\n        {\\n            mp[sub] = charSum;\\n            return;\\n        }\\n        sub += s[i];\\n        charSum += s[i];\\n        helper(s, i + 1, sub, charSum, mp);\\n        charSum -= s[i];\\n        sub.pop_back();\\n        helper(s, i + 1, sub, charSum, mp);\\n    }\\n\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int sum1 = 0, sum2 = 0;\\n        for(int i = 0; i < s1.length(); i++)\\n        {\\n            sum1 += s1[i];\\n\\n        }\\n        for(int i = 0; i < s2.length(); i++)\\n        {\\n            sum2 += s2[i];\\n        }\\n    map<string, int> mp1, mp2;\\n\\n    helper(s1, 0, \"\", 0, mp1);\\n    helper(s2, 0, \"\", 0, mp2);\\n    int mini = INT_MAX;\\n    for(auto it: mp1)\\n    {\\n       if(mp2[it.first] > 0)\\n       {\\n           mini = min((sum1 - it.second + sum2 - mp2[it.first]), mini);\\n       }\\n    }\\n    if(mini == INT_MAX)\\n        return sum1 + sum2;\\n    return mini;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "Pass strings in helper function by reference."
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "Chumma Editorial Explanation !!!"
                    },
                    {
                        "username": "happygamer123",
                        "content": "saw one of the best and most easy-to-understand editorials on leetcode... amazing one"
                    },
                    {
                        "username": "p4puniya",
                        "content": "I'm just loving this question. Before starting it I had no idea on how to solve the Subsequence DP problems. But as I keep solving it and running into memory limit/tle I came to know about how memoization works, how we use DP from memoised code, learned it and now it works! It just feels so good. 10/10 for the problem."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "for the input  S1= delete and S2=leet . I traced the lcs as \"eet\" but ig it requires \"let\" !!"
                    }
                ]
            },
            {
                "id": 1994582,
                "content": [
                    {
                        "username": "SeineAle",
                        "content": "it\\'s easy if you\\'ve done LCS !"
                    },
                    {
                        "username": "gujarathikrish",
                        "content": "why this code giving run time error ?\\n\\nclass Solution {\\nprivate:\\n    int solve(string &s1,string &s2,int i,int j,vector<vector<int>> &dp){\\n        if(i==s1.size() && j==s2.size()) return 0;\\n        else if(j!=s2.size() && i==s1.size())\\n        {\\n            int ans=0;\\n            for(int x=j;x<s2.size();x++) ans+=s2[x];\\n            return ans;\\n        }\\n        else if(i!=s1.size() && j==s2.size())\\n        {\\n            int ans=0;\\n            for(int x=i;x<s1.size();x++) ans+=s1[x];\\n            return ans;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        if(s1[i]==s2[j])\\n        {\\n            return dp[i][j]=solve(s1,s2,i+1,j+1,dp);\\n        }\\n        int ans1=s1[i]+solve(s1,s2,i+1,j,dp);\\n        int ans2=s2[j]+solve(s1,s2,i,j+1,dp);\\n        return dp[i][j]=min(ans1,ans2);\\n    }\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.size(),m=s1.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(s1,s2,0,0,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It\\'s basically a Longest Common Subsequence but instead of keeping track of 1 + Math.min(fs(i-1), fs(j-1)) use the ascii code of s1[i] or s2[j].\\nI found the explanations quite clunky so I just used a trimmed version of Levenshtein Distance.  I recommend to study Levenshtein distance (https://leetcode.com/problems/edit-distance/description/ ) as this is a bit more complicated and includes cases for addition, removal and replacement of characters."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me, this problem simulates real-world problems like text comparison and editing, which is widely used in features like auto-correct, spell-check, text matching, etc"
                    },
                    {
                        "username": "omkar098",
                        "content": "I love this daily coding challenge its like re- defining the solution to the critical problem, and on the other side , it motivates and creates enthusiasm well."
                    },
                    {
                        "username": "sangameshMath",
                        "content": "While most of them are getting TLEs, I got MLE for this problem. \\nCan anyone tell me where it is consuming more memory?\\n\\nclass Solution {\\nprivate:\\n    void helper(string s, int i, string sub, int charSum, map<string, int> &mp)\\n    {\\n        if(i >= s.length())\\n        {\\n            mp[sub] = charSum;\\n            return;\\n        }\\n        sub += s[i];\\n        charSum += s[i];\\n        helper(s, i + 1, sub, charSum, mp);\\n        charSum -= s[i];\\n        sub.pop_back();\\n        helper(s, i + 1, sub, charSum, mp);\\n    }\\n\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int sum1 = 0, sum2 = 0;\\n        for(int i = 0; i < s1.length(); i++)\\n        {\\n            sum1 += s1[i];\\n\\n        }\\n        for(int i = 0; i < s2.length(); i++)\\n        {\\n            sum2 += s2[i];\\n        }\\n    map<string, int> mp1, mp2;\\n\\n    helper(s1, 0, \"\", 0, mp1);\\n    helper(s2, 0, \"\", 0, mp2);\\n    int mini = INT_MAX;\\n    for(auto it: mp1)\\n    {\\n       if(mp2[it.first] > 0)\\n       {\\n           mini = min((sum1 - it.second + sum2 - mp2[it.first]), mini);\\n       }\\n    }\\n    if(mini == INT_MAX)\\n        return sum1 + sum2;\\n    return mini;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "Pass strings in helper function by reference."
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "Chumma Editorial Explanation !!!"
                    },
                    {
                        "username": "happygamer123",
                        "content": "saw one of the best and most easy-to-understand editorials on leetcode... amazing one"
                    },
                    {
                        "username": "p4puniya",
                        "content": "I'm just loving this question. Before starting it I had no idea on how to solve the Subsequence DP problems. But as I keep solving it and running into memory limit/tle I came to know about how memoization works, how we use DP from memoised code, learned it and now it works! It just feels so good. 10/10 for the problem."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "for the input  S1= delete and S2=leet . I traced the lcs as \"eet\" but ig it requires \"let\" !!"
                    }
                ]
            },
            {
                "id": 1994569,
                "content": [
                    {
                        "username": "SeineAle",
                        "content": "it\\'s easy if you\\'ve done LCS !"
                    },
                    {
                        "username": "gujarathikrish",
                        "content": "why this code giving run time error ?\\n\\nclass Solution {\\nprivate:\\n    int solve(string &s1,string &s2,int i,int j,vector<vector<int>> &dp){\\n        if(i==s1.size() && j==s2.size()) return 0;\\n        else if(j!=s2.size() && i==s1.size())\\n        {\\n            int ans=0;\\n            for(int x=j;x<s2.size();x++) ans+=s2[x];\\n            return ans;\\n        }\\n        else if(i!=s1.size() && j==s2.size())\\n        {\\n            int ans=0;\\n            for(int x=i;x<s1.size();x++) ans+=s1[x];\\n            return ans;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        if(s1[i]==s2[j])\\n        {\\n            return dp[i][j]=solve(s1,s2,i+1,j+1,dp);\\n        }\\n        int ans1=s1[i]+solve(s1,s2,i+1,j,dp);\\n        int ans2=s2[j]+solve(s1,s2,i,j+1,dp);\\n        return dp[i][j]=min(ans1,ans2);\\n    }\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int n=s1.size(),m=s1.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(s1,s2,0,0,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It\\'s basically a Longest Common Subsequence but instead of keeping track of 1 + Math.min(fs(i-1), fs(j-1)) use the ascii code of s1[i] or s2[j].\\nI found the explanations quite clunky so I just used a trimmed version of Levenshtein Distance.  I recommend to study Levenshtein distance (https://leetcode.com/problems/edit-distance/description/ ) as this is a bit more complicated and includes cases for addition, removal and replacement of characters."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me, this problem simulates real-world problems like text comparison and editing, which is widely used in features like auto-correct, spell-check, text matching, etc"
                    },
                    {
                        "username": "omkar098",
                        "content": "I love this daily coding challenge its like re- defining the solution to the critical problem, and on the other side , it motivates and creates enthusiasm well."
                    },
                    {
                        "username": "sangameshMath",
                        "content": "While most of them are getting TLEs, I got MLE for this problem. \\nCan anyone tell me where it is consuming more memory?\\n\\nclass Solution {\\nprivate:\\n    void helper(string s, int i, string sub, int charSum, map<string, int> &mp)\\n    {\\n        if(i >= s.length())\\n        {\\n            mp[sub] = charSum;\\n            return;\\n        }\\n        sub += s[i];\\n        charSum += s[i];\\n        helper(s, i + 1, sub, charSum, mp);\\n        charSum -= s[i];\\n        sub.pop_back();\\n        helper(s, i + 1, sub, charSum, mp);\\n    }\\n\\npublic:\\n    int minimumDeleteSum(string s1, string s2) {\\n        int sum1 = 0, sum2 = 0;\\n        for(int i = 0; i < s1.length(); i++)\\n        {\\n            sum1 += s1[i];\\n\\n        }\\n        for(int i = 0; i < s2.length(); i++)\\n        {\\n            sum2 += s2[i];\\n        }\\n    map<string, int> mp1, mp2;\\n\\n    helper(s1, 0, \"\", 0, mp1);\\n    helper(s2, 0, \"\", 0, mp2);\\n    int mini = INT_MAX;\\n    for(auto it: mp1)\\n    {\\n       if(mp2[it.first] > 0)\\n       {\\n           mini = min((sum1 - it.second + sum2 - mp2[it.first]), mini);\\n       }\\n    }\\n    if(mini == INT_MAX)\\n        return sum1 + sum2;\\n    return mini;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "Pass strings in helper function by reference."
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "Chumma Editorial Explanation !!!"
                    },
                    {
                        "username": "happygamer123",
                        "content": "saw one of the best and most easy-to-understand editorials on leetcode... amazing one"
                    },
                    {
                        "username": "p4puniya",
                        "content": "I'm just loving this question. Before starting it I had no idea on how to solve the Subsequence DP problems. But as I keep solving it and running into memory limit/tle I came to know about how memoization works, how we use DP from memoised code, learned it and now it works! It just feels so good. 10/10 for the problem."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "for the input  S1= delete and S2=leet . I traced the lcs as \"eet\" but ig it requires \"let\" !!"
                    }
                ]
            },
            {
                "id": 1994559,
                "content": [
                    {
                        "username": "sunny8080",
                        "content": "Problem is solved, when you see the Constraints \\n`1 <= s1.length, s2.length <= 1000`"
                    },
                    {
                        "username": "vamsikumili",
                        "content": "The lowest ASCII sum of deleted characters to make two strings equal is similar to ASCII sum of s1 plus ASCII sum of s2 string minus 2 times the Longest Common Subsequence between two strings.\\n\\nhttps://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3843259/very-easy-to-understand-approach/"
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "It\\'s just an application of Longest Common Subsequent."
                    },
                    {
                        "username": "aryaman123_",
                        "content": "int minimumDeleteSum(string s1, string s2) {\\n        \\n        int n1 = s1.length();\\n        int n2 = s2.length();\\n\\n        // Dp table to store the minimum ASCII \\n\\n        vector<vector<int>>dp(n1+1, vector<int>(n2+1, 0));\\n\\n        // Fill the dp table using of the BFS Approach \\n\\n        for(int i = 1; i<=n1; i++){\\n\\n            dp[i][0] = dp[i-1][0] + s1[i-1];\\n        }\\n\\n        for(int j = 1; j<=n2; j++){\\n\\n            dp[0][j] = dp[0][j-1] + s2[j-1];\\n        }\\n\\n        for(int i = 1; i<=n1; i++){\\n\\n            for(int j = 1; j<=n2; j++){\\n\\n                if(s1[i-1]==s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=min(dp[i-1][j]+s1[i-1], dp[i][j-1]+s2[j-1]);\\n                }\\n            }\\n        }\\n\\n        return dp[n1][n2];\\n    }\\n\\nSimple and Beginner Level code"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can anyone explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. I dry run the testcase and answer should be 2265 not 2255 can anyone explain this?"
                    },
                    {
                        "username": "anshul_a_1",
                        "content": "lcs should be oo in this case\ni also got this issue"
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "Anyone Please Explain this problem."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "longest common subsequence variant"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Tip: It\\'s a Variation of LCS where u perform string matching. if it matches,u do something and if it does not then u have two options.(\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After solving `100+ DP problems` on LeetCode, I feel this is easiest problem on DP."
                    },
                    {
                        "username": "VMAtm",
                        "content": "[Levenstein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance) with `ASCII` weights"
                    }
                ]
            },
            {
                "id": 1994555,
                "content": [
                    {
                        "username": "sunny8080",
                        "content": "Problem is solved, when you see the Constraints \\n`1 <= s1.length, s2.length <= 1000`"
                    },
                    {
                        "username": "vamsikumili",
                        "content": "The lowest ASCII sum of deleted characters to make two strings equal is similar to ASCII sum of s1 plus ASCII sum of s2 string minus 2 times the Longest Common Subsequence between two strings.\\n\\nhttps://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3843259/very-easy-to-understand-approach/"
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "It\\'s just an application of Longest Common Subsequent."
                    },
                    {
                        "username": "aryaman123_",
                        "content": "int minimumDeleteSum(string s1, string s2) {\\n        \\n        int n1 = s1.length();\\n        int n2 = s2.length();\\n\\n        // Dp table to store the minimum ASCII \\n\\n        vector<vector<int>>dp(n1+1, vector<int>(n2+1, 0));\\n\\n        // Fill the dp table using of the BFS Approach \\n\\n        for(int i = 1; i<=n1; i++){\\n\\n            dp[i][0] = dp[i-1][0] + s1[i-1];\\n        }\\n\\n        for(int j = 1; j<=n2; j++){\\n\\n            dp[0][j] = dp[0][j-1] + s2[j-1];\\n        }\\n\\n        for(int i = 1; i<=n1; i++){\\n\\n            for(int j = 1; j<=n2; j++){\\n\\n                if(s1[i-1]==s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=min(dp[i-1][j]+s1[i-1], dp[i][j-1]+s2[j-1]);\\n                }\\n            }\\n        }\\n\\n        return dp[n1][n2];\\n    }\\n\\nSimple and Beginner Level code"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can anyone explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. I dry run the testcase and answer should be 2265 not 2255 can anyone explain this?"
                    },
                    {
                        "username": "anshul_a_1",
                        "content": "lcs should be oo in this case\ni also got this issue"
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "Anyone Please Explain this problem."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "longest common subsequence variant"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Tip: It\\'s a Variation of LCS where u perform string matching. if it matches,u do something and if it does not then u have two options.(\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After solving `100+ DP problems` on LeetCode, I feel this is easiest problem on DP."
                    },
                    {
                        "username": "VMAtm",
                        "content": "[Levenstein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance) with `ASCII` weights"
                    }
                ]
            },
            {
                "id": 1994520,
                "content": [
                    {
                        "username": "sunny8080",
                        "content": "Problem is solved, when you see the Constraints \\n`1 <= s1.length, s2.length <= 1000`"
                    },
                    {
                        "username": "vamsikumili",
                        "content": "The lowest ASCII sum of deleted characters to make two strings equal is similar to ASCII sum of s1 plus ASCII sum of s2 string minus 2 times the Longest Common Subsequence between two strings.\\n\\nhttps://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3843259/very-easy-to-understand-approach/"
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "It\\'s just an application of Longest Common Subsequent."
                    },
                    {
                        "username": "aryaman123_",
                        "content": "int minimumDeleteSum(string s1, string s2) {\\n        \\n        int n1 = s1.length();\\n        int n2 = s2.length();\\n\\n        // Dp table to store the minimum ASCII \\n\\n        vector<vector<int>>dp(n1+1, vector<int>(n2+1, 0));\\n\\n        // Fill the dp table using of the BFS Approach \\n\\n        for(int i = 1; i<=n1; i++){\\n\\n            dp[i][0] = dp[i-1][0] + s1[i-1];\\n        }\\n\\n        for(int j = 1; j<=n2; j++){\\n\\n            dp[0][j] = dp[0][j-1] + s2[j-1];\\n        }\\n\\n        for(int i = 1; i<=n1; i++){\\n\\n            for(int j = 1; j<=n2; j++){\\n\\n                if(s1[i-1]==s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=min(dp[i-1][j]+s1[i-1], dp[i][j-1]+s2[j-1]);\\n                }\\n            }\\n        }\\n\\n        return dp[n1][n2];\\n    }\\n\\nSimple and Beginner Level code"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can anyone explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. I dry run the testcase and answer should be 2265 not 2255 can anyone explain this?"
                    },
                    {
                        "username": "anshul_a_1",
                        "content": "lcs should be oo in this case\ni also got this issue"
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "Anyone Please Explain this problem."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "longest common subsequence variant"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Tip: It\\'s a Variation of LCS where u perform string matching. if it matches,u do something and if it does not then u have two options.(\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After solving `100+ DP problems` on LeetCode, I feel this is easiest problem on DP."
                    },
                    {
                        "username": "VMAtm",
                        "content": "[Levenstein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance) with `ASCII` weights"
                    }
                ]
            },
            {
                "id": 1994466,
                "content": [
                    {
                        "username": "sunny8080",
                        "content": "Problem is solved, when you see the Constraints \\n`1 <= s1.length, s2.length <= 1000`"
                    },
                    {
                        "username": "vamsikumili",
                        "content": "The lowest ASCII sum of deleted characters to make two strings equal is similar to ASCII sum of s1 plus ASCII sum of s2 string minus 2 times the Longest Common Subsequence between two strings.\\n\\nhttps://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3843259/very-easy-to-understand-approach/"
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "It\\'s just an application of Longest Common Subsequent."
                    },
                    {
                        "username": "aryaman123_",
                        "content": "int minimumDeleteSum(string s1, string s2) {\\n        \\n        int n1 = s1.length();\\n        int n2 = s2.length();\\n\\n        // Dp table to store the minimum ASCII \\n\\n        vector<vector<int>>dp(n1+1, vector<int>(n2+1, 0));\\n\\n        // Fill the dp table using of the BFS Approach \\n\\n        for(int i = 1; i<=n1; i++){\\n\\n            dp[i][0] = dp[i-1][0] + s1[i-1];\\n        }\\n\\n        for(int j = 1; j<=n2; j++){\\n\\n            dp[0][j] = dp[0][j-1] + s2[j-1];\\n        }\\n\\n        for(int i = 1; i<=n1; i++){\\n\\n            for(int j = 1; j<=n2; j++){\\n\\n                if(s1[i-1]==s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=min(dp[i-1][j]+s1[i-1], dp[i][j-1]+s2[j-1]);\\n                }\\n            }\\n        }\\n\\n        return dp[n1][n2];\\n    }\\n\\nSimple and Beginner Level code"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can anyone explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. I dry run the testcase and answer should be 2265 not 2255 can anyone explain this?"
                    },
                    {
                        "username": "anshul_a_1",
                        "content": "lcs should be oo in this case\ni also got this issue"
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "Anyone Please Explain this problem."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "longest common subsequence variant"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Tip: It\\'s a Variation of LCS where u perform string matching. if it matches,u do something and if it does not then u have two options.(\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After solving `100+ DP problems` on LeetCode, I feel this is easiest problem on DP."
                    },
                    {
                        "username": "VMAtm",
                        "content": "[Levenstein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance) with `ASCII` weights"
                    }
                ]
            },
            {
                "id": 1994443,
                "content": [
                    {
                        "username": "sunny8080",
                        "content": "Problem is solved, when you see the Constraints \\n`1 <= s1.length, s2.length <= 1000`"
                    },
                    {
                        "username": "vamsikumili",
                        "content": "The lowest ASCII sum of deleted characters to make two strings equal is similar to ASCII sum of s1 plus ASCII sum of s2 string minus 2 times the Longest Common Subsequence between two strings.\\n\\nhttps://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3843259/very-easy-to-understand-approach/"
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "It\\'s just an application of Longest Common Subsequent."
                    },
                    {
                        "username": "aryaman123_",
                        "content": "int minimumDeleteSum(string s1, string s2) {\\n        \\n        int n1 = s1.length();\\n        int n2 = s2.length();\\n\\n        // Dp table to store the minimum ASCII \\n\\n        vector<vector<int>>dp(n1+1, vector<int>(n2+1, 0));\\n\\n        // Fill the dp table using of the BFS Approach \\n\\n        for(int i = 1; i<=n1; i++){\\n\\n            dp[i][0] = dp[i-1][0] + s1[i-1];\\n        }\\n\\n        for(int j = 1; j<=n2; j++){\\n\\n            dp[0][j] = dp[0][j-1] + s2[j-1];\\n        }\\n\\n        for(int i = 1; i<=n1; i++){\\n\\n            for(int j = 1; j<=n2; j++){\\n\\n                if(s1[i-1]==s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=min(dp[i-1][j]+s1[i-1], dp[i][j-1]+s2[j-1]);\\n                }\\n            }\\n        }\\n\\n        return dp[n1][n2];\\n    }\\n\\nSimple and Beginner Level code"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can anyone explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. I dry run the testcase and answer should be 2265 not 2255 can anyone explain this?"
                    },
                    {
                        "username": "anshul_a_1",
                        "content": "lcs should be oo in this case\ni also got this issue"
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "Anyone Please Explain this problem."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "longest common subsequence variant"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Tip: It\\'s a Variation of LCS where u perform string matching. if it matches,u do something and if it does not then u have two options.(\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After solving `100+ DP problems` on LeetCode, I feel this is easiest problem on DP."
                    },
                    {
                        "username": "VMAtm",
                        "content": "[Levenstein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance) with `ASCII` weights"
                    }
                ]
            },
            {
                "id": 1994426,
                "content": [
                    {
                        "username": "sunny8080",
                        "content": "Problem is solved, when you see the Constraints \\n`1 <= s1.length, s2.length <= 1000`"
                    },
                    {
                        "username": "vamsikumili",
                        "content": "The lowest ASCII sum of deleted characters to make two strings equal is similar to ASCII sum of s1 plus ASCII sum of s2 string minus 2 times the Longest Common Subsequence between two strings.\\n\\nhttps://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3843259/very-easy-to-understand-approach/"
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "It\\'s just an application of Longest Common Subsequent."
                    },
                    {
                        "username": "aryaman123_",
                        "content": "int minimumDeleteSum(string s1, string s2) {\\n        \\n        int n1 = s1.length();\\n        int n2 = s2.length();\\n\\n        // Dp table to store the minimum ASCII \\n\\n        vector<vector<int>>dp(n1+1, vector<int>(n2+1, 0));\\n\\n        // Fill the dp table using of the BFS Approach \\n\\n        for(int i = 1; i<=n1; i++){\\n\\n            dp[i][0] = dp[i-1][0] + s1[i-1];\\n        }\\n\\n        for(int j = 1; j<=n2; j++){\\n\\n            dp[0][j] = dp[0][j-1] + s2[j-1];\\n        }\\n\\n        for(int i = 1; i<=n1; i++){\\n\\n            for(int j = 1; j<=n2; j++){\\n\\n                if(s1[i-1]==s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=min(dp[i-1][j]+s1[i-1], dp[i][j-1]+s2[j-1]);\\n                }\\n            }\\n        }\\n\\n        return dp[n1][n2];\\n    }\\n\\nSimple and Beginner Level code"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can anyone explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. I dry run the testcase and answer should be 2265 not 2255 can anyone explain this?"
                    },
                    {
                        "username": "anshul_a_1",
                        "content": "lcs should be oo in this case\ni also got this issue"
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "Anyone Please Explain this problem."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "longest common subsequence variant"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Tip: It\\'s a Variation of LCS where u perform string matching. if it matches,u do something and if it does not then u have two options.(\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After solving `100+ DP problems` on LeetCode, I feel this is easiest problem on DP."
                    },
                    {
                        "username": "VMAtm",
                        "content": "[Levenstein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance) with `ASCII` weights"
                    }
                ]
            },
            {
                "id": 1994345,
                "content": [
                    {
                        "username": "sunny8080",
                        "content": "Problem is solved, when you see the Constraints \\n`1 <= s1.length, s2.length <= 1000`"
                    },
                    {
                        "username": "vamsikumili",
                        "content": "The lowest ASCII sum of deleted characters to make two strings equal is similar to ASCII sum of s1 plus ASCII sum of s2 string minus 2 times the Longest Common Subsequence between two strings.\\n\\nhttps://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3843259/very-easy-to-understand-approach/"
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "It\\'s just an application of Longest Common Subsequent."
                    },
                    {
                        "username": "aryaman123_",
                        "content": "int minimumDeleteSum(string s1, string s2) {\\n        \\n        int n1 = s1.length();\\n        int n2 = s2.length();\\n\\n        // Dp table to store the minimum ASCII \\n\\n        vector<vector<int>>dp(n1+1, vector<int>(n2+1, 0));\\n\\n        // Fill the dp table using of the BFS Approach \\n\\n        for(int i = 1; i<=n1; i++){\\n\\n            dp[i][0] = dp[i-1][0] + s1[i-1];\\n        }\\n\\n        for(int j = 1; j<=n2; j++){\\n\\n            dp[0][j] = dp[0][j-1] + s2[j-1];\\n        }\\n\\n        for(int i = 1; i<=n1; i++){\\n\\n            for(int j = 1; j<=n2; j++){\\n\\n                if(s1[i-1]==s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=min(dp[i-1][j]+s1[i-1], dp[i][j-1]+s2[j-1]);\\n                }\\n            }\\n        }\\n\\n        return dp[n1][n2];\\n    }\\n\\nSimple and Beginner Level code"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can anyone explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. I dry run the testcase and answer should be 2265 not 2255 can anyone explain this?"
                    },
                    {
                        "username": "anshul_a_1",
                        "content": "lcs should be oo in this case\ni also got this issue"
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "Anyone Please Explain this problem."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "longest common subsequence variant"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Tip: It\\'s a Variation of LCS where u perform string matching. if it matches,u do something and if it does not then u have two options.(\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After solving `100+ DP problems` on LeetCode, I feel this is easiest problem on DP."
                    },
                    {
                        "username": "VMAtm",
                        "content": "[Levenstein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance) with `ASCII` weights"
                    }
                ]
            },
            {
                "id": 1994302,
                "content": [
                    {
                        "username": "sunny8080",
                        "content": "Problem is solved, when you see the Constraints \\n`1 <= s1.length, s2.length <= 1000`"
                    },
                    {
                        "username": "vamsikumili",
                        "content": "The lowest ASCII sum of deleted characters to make two strings equal is similar to ASCII sum of s1 plus ASCII sum of s2 string minus 2 times the Longest Common Subsequence between two strings.\\n\\nhttps://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3843259/very-easy-to-understand-approach/"
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "It\\'s just an application of Longest Common Subsequent."
                    },
                    {
                        "username": "aryaman123_",
                        "content": "int minimumDeleteSum(string s1, string s2) {\\n        \\n        int n1 = s1.length();\\n        int n2 = s2.length();\\n\\n        // Dp table to store the minimum ASCII \\n\\n        vector<vector<int>>dp(n1+1, vector<int>(n2+1, 0));\\n\\n        // Fill the dp table using of the BFS Approach \\n\\n        for(int i = 1; i<=n1; i++){\\n\\n            dp[i][0] = dp[i-1][0] + s1[i-1];\\n        }\\n\\n        for(int j = 1; j<=n2; j++){\\n\\n            dp[0][j] = dp[0][j-1] + s2[j-1];\\n        }\\n\\n        for(int i = 1; i<=n1; i++){\\n\\n            for(int j = 1; j<=n2; j++){\\n\\n                if(s1[i-1]==s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=min(dp[i-1][j]+s1[i-1], dp[i][j-1]+s2[j-1]);\\n                }\\n            }\\n        }\\n\\n        return dp[n1][n2];\\n    }\\n\\nSimple and Beginner Level code"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can anyone explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. I dry run the testcase and answer should be 2265 not 2255 can anyone explain this?"
                    },
                    {
                        "username": "anshul_a_1",
                        "content": "lcs should be oo in this case\ni also got this issue"
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "Anyone Please Explain this problem."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "longest common subsequence variant"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Tip: It\\'s a Variation of LCS where u perform string matching. if it matches,u do something and if it does not then u have two options.(\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After solving `100+ DP problems` on LeetCode, I feel this is easiest problem on DP."
                    },
                    {
                        "username": "VMAtm",
                        "content": "[Levenstein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance) with `ASCII` weights"
                    }
                ]
            },
            {
                "id": 1994294,
                "content": [
                    {
                        "username": "sunny8080",
                        "content": "Problem is solved, when you see the Constraints \\n`1 <= s1.length, s2.length <= 1000`"
                    },
                    {
                        "username": "vamsikumili",
                        "content": "The lowest ASCII sum of deleted characters to make two strings equal is similar to ASCII sum of s1 plus ASCII sum of s2 string minus 2 times the Longest Common Subsequence between two strings.\\n\\nhttps://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3843259/very-easy-to-understand-approach/"
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "It\\'s just an application of Longest Common Subsequent."
                    },
                    {
                        "username": "aryaman123_",
                        "content": "int minimumDeleteSum(string s1, string s2) {\\n        \\n        int n1 = s1.length();\\n        int n2 = s2.length();\\n\\n        // Dp table to store the minimum ASCII \\n\\n        vector<vector<int>>dp(n1+1, vector<int>(n2+1, 0));\\n\\n        // Fill the dp table using of the BFS Approach \\n\\n        for(int i = 1; i<=n1; i++){\\n\\n            dp[i][0] = dp[i-1][0] + s1[i-1];\\n        }\\n\\n        for(int j = 1; j<=n2; j++){\\n\\n            dp[0][j] = dp[0][j-1] + s2[j-1];\\n        }\\n\\n        for(int i = 1; i<=n1; i++){\\n\\n            for(int j = 1; j<=n2; j++){\\n\\n                if(s1[i-1]==s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=min(dp[i-1][j]+s1[i-1], dp[i][j-1]+s2[j-1]);\\n                }\\n            }\\n        }\\n\\n        return dp[n1][n2];\\n    }\\n\\nSimple and Beginner Level code"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can anyone explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. I dry run the testcase and answer should be 2265 not 2255 can anyone explain this?"
                    },
                    {
                        "username": "anshul_a_1",
                        "content": "lcs should be oo in this case\ni also got this issue"
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "Anyone Please Explain this problem."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "longest common subsequence variant"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Tip: It\\'s a Variation of LCS where u perform string matching. if it matches,u do something and if it does not then u have two options.(\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After solving `100+ DP problems` on LeetCode, I feel this is easiest problem on DP."
                    },
                    {
                        "username": "VMAtm",
                        "content": "[Levenstein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance) with `ASCII` weights"
                    }
                ]
            },
            {
                "id": 1994264,
                "content": [
                    {
                        "username": "sunny8080",
                        "content": "Problem is solved, when you see the Constraints \\n`1 <= s1.length, s2.length <= 1000`"
                    },
                    {
                        "username": "vamsikumili",
                        "content": "The lowest ASCII sum of deleted characters to make two strings equal is similar to ASCII sum of s1 plus ASCII sum of s2 string minus 2 times the Longest Common Subsequence between two strings.\\n\\nhttps://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3843259/very-easy-to-understand-approach/"
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "It\\'s just an application of Longest Common Subsequent."
                    },
                    {
                        "username": "aryaman123_",
                        "content": "int minimumDeleteSum(string s1, string s2) {\\n        \\n        int n1 = s1.length();\\n        int n2 = s2.length();\\n\\n        // Dp table to store the minimum ASCII \\n\\n        vector<vector<int>>dp(n1+1, vector<int>(n2+1, 0));\\n\\n        // Fill the dp table using of the BFS Approach \\n\\n        for(int i = 1; i<=n1; i++){\\n\\n            dp[i][0] = dp[i-1][0] + s1[i-1];\\n        }\\n\\n        for(int j = 1; j<=n2; j++){\\n\\n            dp[0][j] = dp[0][j-1] + s2[j-1];\\n        }\\n\\n        for(int i = 1; i<=n1; i++){\\n\\n            for(int j = 1; j<=n2; j++){\\n\\n                if(s1[i-1]==s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=min(dp[i-1][j]+s1[i-1], dp[i][j-1]+s2[j-1]);\\n                }\\n            }\\n        }\\n\\n        return dp[n1][n2];\\n    }\\n\\nSimple and Beginner Level code"
                    },
                    {
                        "username": "hardik_kushwaha",
                        "content": "Can anyone explain this testcase s1=\"xnbteodleejrzeo\" s2=\"gaouojqkkk\" for this one the lcs will be \"oj\" and the expected output is 2255 but my output is 2265. I dry run the testcase and answer should be 2265 not 2255 can anyone explain this?"
                    },
                    {
                        "username": "anshul_a_1",
                        "content": "lcs should be oo in this case\ni also got this issue"
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "Anyone Please Explain this problem."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "longest common subsequence variant"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Tip: It\\'s a Variation of LCS where u perform string matching. if it matches,u do something and if it does not then u have two options.(\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "sunny8080",
                        "content": "After solving `100+ DP problems` on LeetCode, I feel this is easiest problem on DP."
                    },
                    {
                        "username": "VMAtm",
                        "content": "[Levenstein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance) with `ASCII` weights"
                    }
                ]
            },
            {
                "id": 1994205,
                "content": [
                    {
                        "username": "sarthakvyadav",
                        "content": "This one is a standard Dp on strings problem which uses the concept of longest common subsequence."
                    },
                    {
                        "username": "dash_dash",
                        "content": "this is not that hard , dont give up "
                    },
                    {
                        "username": "kenzgf",
                        "content": "ez dp"
                    },
                    {
                        "username": "quanqx",
                        "content": "Longest common subsequence + a sum array to track maximum ASCII sum of LCS "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "classic problem: edit distance"
                    },
                    {
                        "username": "rohit252320",
                        "content": "in Example 2 if we remove only \\'De\\' from Delete than String s1 and s2 are \"leet\" and sum of deleting is 100[d] + 101[e] = 201 instead of 403. Anyone can suggest me, am i right or not"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "if you are deleting \\'De\\' then it\\'ll become \\'lete\\' and not \\'leet\\'. In other words, you cannot jumble the characters."
                    },
                    {
                        "username": "ajv97",
                        "content": "Last challenge of the month. Let\\'s do this thing. "
                    },
                    {
                        "username": "tanny0303",
                        "content": "\\nMY CODE IS GIVING MEMORY LIMIT EXCEEDED PLZ HELP\\n\\n    int val(string s,int ind)\\n    {\\n        int sum=0;\\n        for(int i=0;i<=ind;i++)\\n        {\\n            sum+=s[i];\\n        }\\n        return sum;\\n    }\\n\\n    int md(int fs,int ss,string s1,string s2,vector<vector<int>> &dp)\\n    {\\n        int m;\\n        if(fs<0 && ss<0)\\n        {\\n            return 0;\\n        }\\n        else if(fs<0 && ss>=0)\\n        {\\n            // m= s2[ss] + md(fs,ss-1,s1,s2,dp);\\n            return val(s2,ss);\\n        }\\n        else if(ss<0 && fs>=0)\\n        {\\n            // m= s1[fs] + md(fs-1,ss,s1,s2,dp);\\n            return val(s1,fs);\\n        }\\n        else if(dp[fs][ss]!=-1)\\n        {\\n            return dp[fs][ss];\\n        }\\n        else if(s1[fs]==s2[ss])\\n        {\\n            m= md(fs-1,ss-1,s1,s2,dp);\\n        }\\n        else{\\n            m= min( int(s1[fs]) + md(fs-1,ss,s1,s2,dp) , int(s2[ss]) +md(fs,ss-1,s1,s2,dp) );\\n        }\\n       \\n        return dp[fs][ss]=m;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        \\n        int fs=s1.size();\\n        int ss=s2.size();\\n\\n        vector<vector<int>> dp(fs,vector<int>(ss,-1));\\n\\n        int val=md(fs-1,ss-1,s1,s2,dp);\\n        return val;\\n    }"
                    },
                    {
                        "username": "pri1311",
                        "content": "pass strings by reference to the functions not by value"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Try to do it other way around like first calculating lcs with highest ascii value and then subtract it from the total value of two strings. It goes like...ascii(s1) + ascii(s2) - 2*ascii(lcs(s1,s2)) where ascii represents the ascii values of strings in the argument."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "Convert it into bottom-up DP"
                    },
                    {
                        "username": "psionl0",
                        "content": "My first monthly badge!\\n\\nEven though this is a Monday problem, LeetCode wasn\\'t about to just hand the badge over. I originally thought that it was a case of reducing each string to its longest common sub sequence and made sure that I could solve ``1143. Longest Common Subsequence`` first. \\n\\nHowever, there could be several LCSs of the same length. It turns out that the LCS problem is a bit of a red herring. This problem is way more difficult."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Don't do this mistake\n- Find ***Longest Common Subsequence***. \n- If multiple LCS found, choose one with the ***Minimum ASCII Delete Sum***.\n\nSadly, this approach fails on :\n `s1` = _\"aaaaazzzz\"_ & `s2` = _\"zzzzaaaaa\"_\n\nHere we can make the two strings equal by either keeping _\"aaaaa\"_ (removing _\"zzzz\"_) or by keeping _\"zzzz\"_ (removing _\"aaaaa\"_) from both the strings.\n\nkeeping the larger subsequence (_\"aaaaa\"_) and removing _\"zzzz\"_ costs ***484 ASCII points***, while\nkeeping the smaller subsequence (_\"zzzz\"_) and removing _\"aaaaa\"_ costs ***480 ASCII points***.\n\nWhich means keeping _\"aaaaa\"_ costs more than keeping _\"zzzz\"_. So the concept of ***Longest Common Subsequence*** doesn't apply in this case since the ***Longest Common Subsequence*** is costing more than a ***Smaller Common Subsequence***.\n\nUpvote if you found this useful."
                    }
                ]
            },
            {
                "id": 1994193,
                "content": [
                    {
                        "username": "sarthakvyadav",
                        "content": "This one is a standard Dp on strings problem which uses the concept of longest common subsequence."
                    },
                    {
                        "username": "dash_dash",
                        "content": "this is not that hard , dont give up "
                    },
                    {
                        "username": "kenzgf",
                        "content": "ez dp"
                    },
                    {
                        "username": "quanqx",
                        "content": "Longest common subsequence + a sum array to track maximum ASCII sum of LCS "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "classic problem: edit distance"
                    },
                    {
                        "username": "rohit252320",
                        "content": "in Example 2 if we remove only \\'De\\' from Delete than String s1 and s2 are \"leet\" and sum of deleting is 100[d] + 101[e] = 201 instead of 403. Anyone can suggest me, am i right or not"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "if you are deleting \\'De\\' then it\\'ll become \\'lete\\' and not \\'leet\\'. In other words, you cannot jumble the characters."
                    },
                    {
                        "username": "ajv97",
                        "content": "Last challenge of the month. Let\\'s do this thing. "
                    },
                    {
                        "username": "tanny0303",
                        "content": "\\nMY CODE IS GIVING MEMORY LIMIT EXCEEDED PLZ HELP\\n\\n    int val(string s,int ind)\\n    {\\n        int sum=0;\\n        for(int i=0;i<=ind;i++)\\n        {\\n            sum+=s[i];\\n        }\\n        return sum;\\n    }\\n\\n    int md(int fs,int ss,string s1,string s2,vector<vector<int>> &dp)\\n    {\\n        int m;\\n        if(fs<0 && ss<0)\\n        {\\n            return 0;\\n        }\\n        else if(fs<0 && ss>=0)\\n        {\\n            // m= s2[ss] + md(fs,ss-1,s1,s2,dp);\\n            return val(s2,ss);\\n        }\\n        else if(ss<0 && fs>=0)\\n        {\\n            // m= s1[fs] + md(fs-1,ss,s1,s2,dp);\\n            return val(s1,fs);\\n        }\\n        else if(dp[fs][ss]!=-1)\\n        {\\n            return dp[fs][ss];\\n        }\\n        else if(s1[fs]==s2[ss])\\n        {\\n            m= md(fs-1,ss-1,s1,s2,dp);\\n        }\\n        else{\\n            m= min( int(s1[fs]) + md(fs-1,ss,s1,s2,dp) , int(s2[ss]) +md(fs,ss-1,s1,s2,dp) );\\n        }\\n       \\n        return dp[fs][ss]=m;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        \\n        int fs=s1.size();\\n        int ss=s2.size();\\n\\n        vector<vector<int>> dp(fs,vector<int>(ss,-1));\\n\\n        int val=md(fs-1,ss-1,s1,s2,dp);\\n        return val;\\n    }"
                    },
                    {
                        "username": "pri1311",
                        "content": "pass strings by reference to the functions not by value"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Try to do it other way around like first calculating lcs with highest ascii value and then subtract it from the total value of two strings. It goes like...ascii(s1) + ascii(s2) - 2*ascii(lcs(s1,s2)) where ascii represents the ascii values of strings in the argument."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "Convert it into bottom-up DP"
                    },
                    {
                        "username": "psionl0",
                        "content": "My first monthly badge!\\n\\nEven though this is a Monday problem, LeetCode wasn\\'t about to just hand the badge over. I originally thought that it was a case of reducing each string to its longest common sub sequence and made sure that I could solve ``1143. Longest Common Subsequence`` first. \\n\\nHowever, there could be several LCSs of the same length. It turns out that the LCS problem is a bit of a red herring. This problem is way more difficult."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Don't do this mistake\n- Find ***Longest Common Subsequence***. \n- If multiple LCS found, choose one with the ***Minimum ASCII Delete Sum***.\n\nSadly, this approach fails on :\n `s1` = _\"aaaaazzzz\"_ & `s2` = _\"zzzzaaaaa\"_\n\nHere we can make the two strings equal by either keeping _\"aaaaa\"_ (removing _\"zzzz\"_) or by keeping _\"zzzz\"_ (removing _\"aaaaa\"_) from both the strings.\n\nkeeping the larger subsequence (_\"aaaaa\"_) and removing _\"zzzz\"_ costs ***484 ASCII points***, while\nkeeping the smaller subsequence (_\"zzzz\"_) and removing _\"aaaaa\"_ costs ***480 ASCII points***.\n\nWhich means keeping _\"aaaaa\"_ costs more than keeping _\"zzzz\"_. So the concept of ***Longest Common Subsequence*** doesn't apply in this case since the ***Longest Common Subsequence*** is costing more than a ***Smaller Common Subsequence***.\n\nUpvote if you found this useful."
                    }
                ]
            },
            {
                "id": 1994133,
                "content": [
                    {
                        "username": "sarthakvyadav",
                        "content": "This one is a standard Dp on strings problem which uses the concept of longest common subsequence."
                    },
                    {
                        "username": "dash_dash",
                        "content": "this is not that hard , dont give up "
                    },
                    {
                        "username": "kenzgf",
                        "content": "ez dp"
                    },
                    {
                        "username": "quanqx",
                        "content": "Longest common subsequence + a sum array to track maximum ASCII sum of LCS "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "classic problem: edit distance"
                    },
                    {
                        "username": "rohit252320",
                        "content": "in Example 2 if we remove only \\'De\\' from Delete than String s1 and s2 are \"leet\" and sum of deleting is 100[d] + 101[e] = 201 instead of 403. Anyone can suggest me, am i right or not"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "if you are deleting \\'De\\' then it\\'ll become \\'lete\\' and not \\'leet\\'. In other words, you cannot jumble the characters."
                    },
                    {
                        "username": "ajv97",
                        "content": "Last challenge of the month. Let\\'s do this thing. "
                    },
                    {
                        "username": "tanny0303",
                        "content": "\\nMY CODE IS GIVING MEMORY LIMIT EXCEEDED PLZ HELP\\n\\n    int val(string s,int ind)\\n    {\\n        int sum=0;\\n        for(int i=0;i<=ind;i++)\\n        {\\n            sum+=s[i];\\n        }\\n        return sum;\\n    }\\n\\n    int md(int fs,int ss,string s1,string s2,vector<vector<int>> &dp)\\n    {\\n        int m;\\n        if(fs<0 && ss<0)\\n        {\\n            return 0;\\n        }\\n        else if(fs<0 && ss>=0)\\n        {\\n            // m= s2[ss] + md(fs,ss-1,s1,s2,dp);\\n            return val(s2,ss);\\n        }\\n        else if(ss<0 && fs>=0)\\n        {\\n            // m= s1[fs] + md(fs-1,ss,s1,s2,dp);\\n            return val(s1,fs);\\n        }\\n        else if(dp[fs][ss]!=-1)\\n        {\\n            return dp[fs][ss];\\n        }\\n        else if(s1[fs]==s2[ss])\\n        {\\n            m= md(fs-1,ss-1,s1,s2,dp);\\n        }\\n        else{\\n            m= min( int(s1[fs]) + md(fs-1,ss,s1,s2,dp) , int(s2[ss]) +md(fs,ss-1,s1,s2,dp) );\\n        }\\n       \\n        return dp[fs][ss]=m;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        \\n        int fs=s1.size();\\n        int ss=s2.size();\\n\\n        vector<vector<int>> dp(fs,vector<int>(ss,-1));\\n\\n        int val=md(fs-1,ss-1,s1,s2,dp);\\n        return val;\\n    }"
                    },
                    {
                        "username": "pri1311",
                        "content": "pass strings by reference to the functions not by value"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Try to do it other way around like first calculating lcs with highest ascii value and then subtract it from the total value of two strings. It goes like...ascii(s1) + ascii(s2) - 2*ascii(lcs(s1,s2)) where ascii represents the ascii values of strings in the argument."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "Convert it into bottom-up DP"
                    },
                    {
                        "username": "psionl0",
                        "content": "My first monthly badge!\\n\\nEven though this is a Monday problem, LeetCode wasn\\'t about to just hand the badge over. I originally thought that it was a case of reducing each string to its longest common sub sequence and made sure that I could solve ``1143. Longest Common Subsequence`` first. \\n\\nHowever, there could be several LCSs of the same length. It turns out that the LCS problem is a bit of a red herring. This problem is way more difficult."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Don't do this mistake\n- Find ***Longest Common Subsequence***. \n- If multiple LCS found, choose one with the ***Minimum ASCII Delete Sum***.\n\nSadly, this approach fails on :\n `s1` = _\"aaaaazzzz\"_ & `s2` = _\"zzzzaaaaa\"_\n\nHere we can make the two strings equal by either keeping _\"aaaaa\"_ (removing _\"zzzz\"_) or by keeping _\"zzzz\"_ (removing _\"aaaaa\"_) from both the strings.\n\nkeeping the larger subsequence (_\"aaaaa\"_) and removing _\"zzzz\"_ costs ***484 ASCII points***, while\nkeeping the smaller subsequence (_\"zzzz\"_) and removing _\"aaaaa\"_ costs ***480 ASCII points***.\n\nWhich means keeping _\"aaaaa\"_ costs more than keeping _\"zzzz\"_. So the concept of ***Longest Common Subsequence*** doesn't apply in this case since the ***Longest Common Subsequence*** is costing more than a ***Smaller Common Subsequence***.\n\nUpvote if you found this useful."
                    }
                ]
            },
            {
                "id": 1994113,
                "content": [
                    {
                        "username": "sarthakvyadav",
                        "content": "This one is a standard Dp on strings problem which uses the concept of longest common subsequence."
                    },
                    {
                        "username": "dash_dash",
                        "content": "this is not that hard , dont give up "
                    },
                    {
                        "username": "kenzgf",
                        "content": "ez dp"
                    },
                    {
                        "username": "quanqx",
                        "content": "Longest common subsequence + a sum array to track maximum ASCII sum of LCS "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "classic problem: edit distance"
                    },
                    {
                        "username": "rohit252320",
                        "content": "in Example 2 if we remove only \\'De\\' from Delete than String s1 and s2 are \"leet\" and sum of deleting is 100[d] + 101[e] = 201 instead of 403. Anyone can suggest me, am i right or not"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "if you are deleting \\'De\\' then it\\'ll become \\'lete\\' and not \\'leet\\'. In other words, you cannot jumble the characters."
                    },
                    {
                        "username": "ajv97",
                        "content": "Last challenge of the month. Let\\'s do this thing. "
                    },
                    {
                        "username": "tanny0303",
                        "content": "\\nMY CODE IS GIVING MEMORY LIMIT EXCEEDED PLZ HELP\\n\\n    int val(string s,int ind)\\n    {\\n        int sum=0;\\n        for(int i=0;i<=ind;i++)\\n        {\\n            sum+=s[i];\\n        }\\n        return sum;\\n    }\\n\\n    int md(int fs,int ss,string s1,string s2,vector<vector<int>> &dp)\\n    {\\n        int m;\\n        if(fs<0 && ss<0)\\n        {\\n            return 0;\\n        }\\n        else if(fs<0 && ss>=0)\\n        {\\n            // m= s2[ss] + md(fs,ss-1,s1,s2,dp);\\n            return val(s2,ss);\\n        }\\n        else if(ss<0 && fs>=0)\\n        {\\n            // m= s1[fs] + md(fs-1,ss,s1,s2,dp);\\n            return val(s1,fs);\\n        }\\n        else if(dp[fs][ss]!=-1)\\n        {\\n            return dp[fs][ss];\\n        }\\n        else if(s1[fs]==s2[ss])\\n        {\\n            m= md(fs-1,ss-1,s1,s2,dp);\\n        }\\n        else{\\n            m= min( int(s1[fs]) + md(fs-1,ss,s1,s2,dp) , int(s2[ss]) +md(fs,ss-1,s1,s2,dp) );\\n        }\\n       \\n        return dp[fs][ss]=m;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        \\n        int fs=s1.size();\\n        int ss=s2.size();\\n\\n        vector<vector<int>> dp(fs,vector<int>(ss,-1));\\n\\n        int val=md(fs-1,ss-1,s1,s2,dp);\\n        return val;\\n    }"
                    },
                    {
                        "username": "pri1311",
                        "content": "pass strings by reference to the functions not by value"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Try to do it other way around like first calculating lcs with highest ascii value and then subtract it from the total value of two strings. It goes like...ascii(s1) + ascii(s2) - 2*ascii(lcs(s1,s2)) where ascii represents the ascii values of strings in the argument."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "Convert it into bottom-up DP"
                    },
                    {
                        "username": "psionl0",
                        "content": "My first monthly badge!\\n\\nEven though this is a Monday problem, LeetCode wasn\\'t about to just hand the badge over. I originally thought that it was a case of reducing each string to its longest common sub sequence and made sure that I could solve ``1143. Longest Common Subsequence`` first. \\n\\nHowever, there could be several LCSs of the same length. It turns out that the LCS problem is a bit of a red herring. This problem is way more difficult."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Don't do this mistake\n- Find ***Longest Common Subsequence***. \n- If multiple LCS found, choose one with the ***Minimum ASCII Delete Sum***.\n\nSadly, this approach fails on :\n `s1` = _\"aaaaazzzz\"_ & `s2` = _\"zzzzaaaaa\"_\n\nHere we can make the two strings equal by either keeping _\"aaaaa\"_ (removing _\"zzzz\"_) or by keeping _\"zzzz\"_ (removing _\"aaaaa\"_) from both the strings.\n\nkeeping the larger subsequence (_\"aaaaa\"_) and removing _\"zzzz\"_ costs ***484 ASCII points***, while\nkeeping the smaller subsequence (_\"zzzz\"_) and removing _\"aaaaa\"_ costs ***480 ASCII points***.\n\nWhich means keeping _\"aaaaa\"_ costs more than keeping _\"zzzz\"_. So the concept of ***Longest Common Subsequence*** doesn't apply in this case since the ***Longest Common Subsequence*** is costing more than a ***Smaller Common Subsequence***.\n\nUpvote if you found this useful."
                    }
                ]
            },
            {
                "id": 1994027,
                "content": [
                    {
                        "username": "sarthakvyadav",
                        "content": "This one is a standard Dp on strings problem which uses the concept of longest common subsequence."
                    },
                    {
                        "username": "dash_dash",
                        "content": "this is not that hard , dont give up "
                    },
                    {
                        "username": "kenzgf",
                        "content": "ez dp"
                    },
                    {
                        "username": "quanqx",
                        "content": "Longest common subsequence + a sum array to track maximum ASCII sum of LCS "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "classic problem: edit distance"
                    },
                    {
                        "username": "rohit252320",
                        "content": "in Example 2 if we remove only \\'De\\' from Delete than String s1 and s2 are \"leet\" and sum of deleting is 100[d] + 101[e] = 201 instead of 403. Anyone can suggest me, am i right or not"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "if you are deleting \\'De\\' then it\\'ll become \\'lete\\' and not \\'leet\\'. In other words, you cannot jumble the characters."
                    },
                    {
                        "username": "ajv97",
                        "content": "Last challenge of the month. Let\\'s do this thing. "
                    },
                    {
                        "username": "tanny0303",
                        "content": "\\nMY CODE IS GIVING MEMORY LIMIT EXCEEDED PLZ HELP\\n\\n    int val(string s,int ind)\\n    {\\n        int sum=0;\\n        for(int i=0;i<=ind;i++)\\n        {\\n            sum+=s[i];\\n        }\\n        return sum;\\n    }\\n\\n    int md(int fs,int ss,string s1,string s2,vector<vector<int>> &dp)\\n    {\\n        int m;\\n        if(fs<0 && ss<0)\\n        {\\n            return 0;\\n        }\\n        else if(fs<0 && ss>=0)\\n        {\\n            // m= s2[ss] + md(fs,ss-1,s1,s2,dp);\\n            return val(s2,ss);\\n        }\\n        else if(ss<0 && fs>=0)\\n        {\\n            // m= s1[fs] + md(fs-1,ss,s1,s2,dp);\\n            return val(s1,fs);\\n        }\\n        else if(dp[fs][ss]!=-1)\\n        {\\n            return dp[fs][ss];\\n        }\\n        else if(s1[fs]==s2[ss])\\n        {\\n            m= md(fs-1,ss-1,s1,s2,dp);\\n        }\\n        else{\\n            m= min( int(s1[fs]) + md(fs-1,ss,s1,s2,dp) , int(s2[ss]) +md(fs,ss-1,s1,s2,dp) );\\n        }\\n       \\n        return dp[fs][ss]=m;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        \\n        int fs=s1.size();\\n        int ss=s2.size();\\n\\n        vector<vector<int>> dp(fs,vector<int>(ss,-1));\\n\\n        int val=md(fs-1,ss-1,s1,s2,dp);\\n        return val;\\n    }"
                    },
                    {
                        "username": "pri1311",
                        "content": "pass strings by reference to the functions not by value"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Try to do it other way around like first calculating lcs with highest ascii value and then subtract it from the total value of two strings. It goes like...ascii(s1) + ascii(s2) - 2*ascii(lcs(s1,s2)) where ascii represents the ascii values of strings in the argument."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "Convert it into bottom-up DP"
                    },
                    {
                        "username": "psionl0",
                        "content": "My first monthly badge!\\n\\nEven though this is a Monday problem, LeetCode wasn\\'t about to just hand the badge over. I originally thought that it was a case of reducing each string to its longest common sub sequence and made sure that I could solve ``1143. Longest Common Subsequence`` first. \\n\\nHowever, there could be several LCSs of the same length. It turns out that the LCS problem is a bit of a red herring. This problem is way more difficult."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Don't do this mistake\n- Find ***Longest Common Subsequence***. \n- If multiple LCS found, choose one with the ***Minimum ASCII Delete Sum***.\n\nSadly, this approach fails on :\n `s1` = _\"aaaaazzzz\"_ & `s2` = _\"zzzzaaaaa\"_\n\nHere we can make the two strings equal by either keeping _\"aaaaa\"_ (removing _\"zzzz\"_) or by keeping _\"zzzz\"_ (removing _\"aaaaa\"_) from both the strings.\n\nkeeping the larger subsequence (_\"aaaaa\"_) and removing _\"zzzz\"_ costs ***484 ASCII points***, while\nkeeping the smaller subsequence (_\"zzzz\"_) and removing _\"aaaaa\"_ costs ***480 ASCII points***.\n\nWhich means keeping _\"aaaaa\"_ costs more than keeping _\"zzzz\"_. So the concept of ***Longest Common Subsequence*** doesn't apply in this case since the ***Longest Common Subsequence*** is costing more than a ***Smaller Common Subsequence***.\n\nUpvote if you found this useful."
                    }
                ]
            },
            {
                "id": 1993952,
                "content": [
                    {
                        "username": "sarthakvyadav",
                        "content": "This one is a standard Dp on strings problem which uses the concept of longest common subsequence."
                    },
                    {
                        "username": "dash_dash",
                        "content": "this is not that hard , dont give up "
                    },
                    {
                        "username": "kenzgf",
                        "content": "ez dp"
                    },
                    {
                        "username": "quanqx",
                        "content": "Longest common subsequence + a sum array to track maximum ASCII sum of LCS "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "classic problem: edit distance"
                    },
                    {
                        "username": "rohit252320",
                        "content": "in Example 2 if we remove only \\'De\\' from Delete than String s1 and s2 are \"leet\" and sum of deleting is 100[d] + 101[e] = 201 instead of 403. Anyone can suggest me, am i right or not"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "if you are deleting \\'De\\' then it\\'ll become \\'lete\\' and not \\'leet\\'. In other words, you cannot jumble the characters."
                    },
                    {
                        "username": "ajv97",
                        "content": "Last challenge of the month. Let\\'s do this thing. "
                    },
                    {
                        "username": "tanny0303",
                        "content": "\\nMY CODE IS GIVING MEMORY LIMIT EXCEEDED PLZ HELP\\n\\n    int val(string s,int ind)\\n    {\\n        int sum=0;\\n        for(int i=0;i<=ind;i++)\\n        {\\n            sum+=s[i];\\n        }\\n        return sum;\\n    }\\n\\n    int md(int fs,int ss,string s1,string s2,vector<vector<int>> &dp)\\n    {\\n        int m;\\n        if(fs<0 && ss<0)\\n        {\\n            return 0;\\n        }\\n        else if(fs<0 && ss>=0)\\n        {\\n            // m= s2[ss] + md(fs,ss-1,s1,s2,dp);\\n            return val(s2,ss);\\n        }\\n        else if(ss<0 && fs>=0)\\n        {\\n            // m= s1[fs] + md(fs-1,ss,s1,s2,dp);\\n            return val(s1,fs);\\n        }\\n        else if(dp[fs][ss]!=-1)\\n        {\\n            return dp[fs][ss];\\n        }\\n        else if(s1[fs]==s2[ss])\\n        {\\n            m= md(fs-1,ss-1,s1,s2,dp);\\n        }\\n        else{\\n            m= min( int(s1[fs]) + md(fs-1,ss,s1,s2,dp) , int(s2[ss]) +md(fs,ss-1,s1,s2,dp) );\\n        }\\n       \\n        return dp[fs][ss]=m;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        \\n        int fs=s1.size();\\n        int ss=s2.size();\\n\\n        vector<vector<int>> dp(fs,vector<int>(ss,-1));\\n\\n        int val=md(fs-1,ss-1,s1,s2,dp);\\n        return val;\\n    }"
                    },
                    {
                        "username": "pri1311",
                        "content": "pass strings by reference to the functions not by value"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Try to do it other way around like first calculating lcs with highest ascii value and then subtract it from the total value of two strings. It goes like...ascii(s1) + ascii(s2) - 2*ascii(lcs(s1,s2)) where ascii represents the ascii values of strings in the argument."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "Convert it into bottom-up DP"
                    },
                    {
                        "username": "psionl0",
                        "content": "My first monthly badge!\\n\\nEven though this is a Monday problem, LeetCode wasn\\'t about to just hand the badge over. I originally thought that it was a case of reducing each string to its longest common sub sequence and made sure that I could solve ``1143. Longest Common Subsequence`` first. \\n\\nHowever, there could be several LCSs of the same length. It turns out that the LCS problem is a bit of a red herring. This problem is way more difficult."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Don't do this mistake\n- Find ***Longest Common Subsequence***. \n- If multiple LCS found, choose one with the ***Minimum ASCII Delete Sum***.\n\nSadly, this approach fails on :\n `s1` = _\"aaaaazzzz\"_ & `s2` = _\"zzzzaaaaa\"_\n\nHere we can make the two strings equal by either keeping _\"aaaaa\"_ (removing _\"zzzz\"_) or by keeping _\"zzzz\"_ (removing _\"aaaaa\"_) from both the strings.\n\nkeeping the larger subsequence (_\"aaaaa\"_) and removing _\"zzzz\"_ costs ***484 ASCII points***, while\nkeeping the smaller subsequence (_\"zzzz\"_) and removing _\"aaaaa\"_ costs ***480 ASCII points***.\n\nWhich means keeping _\"aaaaa\"_ costs more than keeping _\"zzzz\"_. So the concept of ***Longest Common Subsequence*** doesn't apply in this case since the ***Longest Common Subsequence*** is costing more than a ***Smaller Common Subsequence***.\n\nUpvote if you found this useful."
                    }
                ]
            },
            {
                "id": 1993903,
                "content": [
                    {
                        "username": "sarthakvyadav",
                        "content": "This one is a standard Dp on strings problem which uses the concept of longest common subsequence."
                    },
                    {
                        "username": "dash_dash",
                        "content": "this is not that hard , dont give up "
                    },
                    {
                        "username": "kenzgf",
                        "content": "ez dp"
                    },
                    {
                        "username": "quanqx",
                        "content": "Longest common subsequence + a sum array to track maximum ASCII sum of LCS "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "classic problem: edit distance"
                    },
                    {
                        "username": "rohit252320",
                        "content": "in Example 2 if we remove only \\'De\\' from Delete than String s1 and s2 are \"leet\" and sum of deleting is 100[d] + 101[e] = 201 instead of 403. Anyone can suggest me, am i right or not"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "if you are deleting \\'De\\' then it\\'ll become \\'lete\\' and not \\'leet\\'. In other words, you cannot jumble the characters."
                    },
                    {
                        "username": "ajv97",
                        "content": "Last challenge of the month. Let\\'s do this thing. "
                    },
                    {
                        "username": "tanny0303",
                        "content": "\\nMY CODE IS GIVING MEMORY LIMIT EXCEEDED PLZ HELP\\n\\n    int val(string s,int ind)\\n    {\\n        int sum=0;\\n        for(int i=0;i<=ind;i++)\\n        {\\n            sum+=s[i];\\n        }\\n        return sum;\\n    }\\n\\n    int md(int fs,int ss,string s1,string s2,vector<vector<int>> &dp)\\n    {\\n        int m;\\n        if(fs<0 && ss<0)\\n        {\\n            return 0;\\n        }\\n        else if(fs<0 && ss>=0)\\n        {\\n            // m= s2[ss] + md(fs,ss-1,s1,s2,dp);\\n            return val(s2,ss);\\n        }\\n        else if(ss<0 && fs>=0)\\n        {\\n            // m= s1[fs] + md(fs-1,ss,s1,s2,dp);\\n            return val(s1,fs);\\n        }\\n        else if(dp[fs][ss]!=-1)\\n        {\\n            return dp[fs][ss];\\n        }\\n        else if(s1[fs]==s2[ss])\\n        {\\n            m= md(fs-1,ss-1,s1,s2,dp);\\n        }\\n        else{\\n            m= min( int(s1[fs]) + md(fs-1,ss,s1,s2,dp) , int(s2[ss]) +md(fs,ss-1,s1,s2,dp) );\\n        }\\n       \\n        return dp[fs][ss]=m;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        \\n        int fs=s1.size();\\n        int ss=s2.size();\\n\\n        vector<vector<int>> dp(fs,vector<int>(ss,-1));\\n\\n        int val=md(fs-1,ss-1,s1,s2,dp);\\n        return val;\\n    }"
                    },
                    {
                        "username": "pri1311",
                        "content": "pass strings by reference to the functions not by value"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Try to do it other way around like first calculating lcs with highest ascii value and then subtract it from the total value of two strings. It goes like...ascii(s1) + ascii(s2) - 2*ascii(lcs(s1,s2)) where ascii represents the ascii values of strings in the argument."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "Convert it into bottom-up DP"
                    },
                    {
                        "username": "psionl0",
                        "content": "My first monthly badge!\\n\\nEven though this is a Monday problem, LeetCode wasn\\'t about to just hand the badge over. I originally thought that it was a case of reducing each string to its longest common sub sequence and made sure that I could solve ``1143. Longest Common Subsequence`` first. \\n\\nHowever, there could be several LCSs of the same length. It turns out that the LCS problem is a bit of a red herring. This problem is way more difficult."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Don't do this mistake\n- Find ***Longest Common Subsequence***. \n- If multiple LCS found, choose one with the ***Minimum ASCII Delete Sum***.\n\nSadly, this approach fails on :\n `s1` = _\"aaaaazzzz\"_ & `s2` = _\"zzzzaaaaa\"_\n\nHere we can make the two strings equal by either keeping _\"aaaaa\"_ (removing _\"zzzz\"_) or by keeping _\"zzzz\"_ (removing _\"aaaaa\"_) from both the strings.\n\nkeeping the larger subsequence (_\"aaaaa\"_) and removing _\"zzzz\"_ costs ***484 ASCII points***, while\nkeeping the smaller subsequence (_\"zzzz\"_) and removing _\"aaaaa\"_ costs ***480 ASCII points***.\n\nWhich means keeping _\"aaaaa\"_ costs more than keeping _\"zzzz\"_. So the concept of ***Longest Common Subsequence*** doesn't apply in this case since the ***Longest Common Subsequence*** is costing more than a ***Smaller Common Subsequence***.\n\nUpvote if you found this useful."
                    }
                ]
            },
            {
                "id": 1993852,
                "content": [
                    {
                        "username": "sarthakvyadav",
                        "content": "This one is a standard Dp on strings problem which uses the concept of longest common subsequence."
                    },
                    {
                        "username": "dash_dash",
                        "content": "this is not that hard , dont give up "
                    },
                    {
                        "username": "kenzgf",
                        "content": "ez dp"
                    },
                    {
                        "username": "quanqx",
                        "content": "Longest common subsequence + a sum array to track maximum ASCII sum of LCS "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "classic problem: edit distance"
                    },
                    {
                        "username": "rohit252320",
                        "content": "in Example 2 if we remove only \\'De\\' from Delete than String s1 and s2 are \"leet\" and sum of deleting is 100[d] + 101[e] = 201 instead of 403. Anyone can suggest me, am i right or not"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "if you are deleting \\'De\\' then it\\'ll become \\'lete\\' and not \\'leet\\'. In other words, you cannot jumble the characters."
                    },
                    {
                        "username": "ajv97",
                        "content": "Last challenge of the month. Let\\'s do this thing. "
                    },
                    {
                        "username": "tanny0303",
                        "content": "\\nMY CODE IS GIVING MEMORY LIMIT EXCEEDED PLZ HELP\\n\\n    int val(string s,int ind)\\n    {\\n        int sum=0;\\n        for(int i=0;i<=ind;i++)\\n        {\\n            sum+=s[i];\\n        }\\n        return sum;\\n    }\\n\\n    int md(int fs,int ss,string s1,string s2,vector<vector<int>> &dp)\\n    {\\n        int m;\\n        if(fs<0 && ss<0)\\n        {\\n            return 0;\\n        }\\n        else if(fs<0 && ss>=0)\\n        {\\n            // m= s2[ss] + md(fs,ss-1,s1,s2,dp);\\n            return val(s2,ss);\\n        }\\n        else if(ss<0 && fs>=0)\\n        {\\n            // m= s1[fs] + md(fs-1,ss,s1,s2,dp);\\n            return val(s1,fs);\\n        }\\n        else if(dp[fs][ss]!=-1)\\n        {\\n            return dp[fs][ss];\\n        }\\n        else if(s1[fs]==s2[ss])\\n        {\\n            m= md(fs-1,ss-1,s1,s2,dp);\\n        }\\n        else{\\n            m= min( int(s1[fs]) + md(fs-1,ss,s1,s2,dp) , int(s2[ss]) +md(fs,ss-1,s1,s2,dp) );\\n        }\\n       \\n        return dp[fs][ss]=m;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        \\n        int fs=s1.size();\\n        int ss=s2.size();\\n\\n        vector<vector<int>> dp(fs,vector<int>(ss,-1));\\n\\n        int val=md(fs-1,ss-1,s1,s2,dp);\\n        return val;\\n    }"
                    },
                    {
                        "username": "pri1311",
                        "content": "pass strings by reference to the functions not by value"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Try to do it other way around like first calculating lcs with highest ascii value and then subtract it from the total value of two strings. It goes like...ascii(s1) + ascii(s2) - 2*ascii(lcs(s1,s2)) where ascii represents the ascii values of strings in the argument."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "Convert it into bottom-up DP"
                    },
                    {
                        "username": "psionl0",
                        "content": "My first monthly badge!\\n\\nEven though this is a Monday problem, LeetCode wasn\\'t about to just hand the badge over. I originally thought that it was a case of reducing each string to its longest common sub sequence and made sure that I could solve ``1143. Longest Common Subsequence`` first. \\n\\nHowever, there could be several LCSs of the same length. It turns out that the LCS problem is a bit of a red herring. This problem is way more difficult."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Don't do this mistake\n- Find ***Longest Common Subsequence***. \n- If multiple LCS found, choose one with the ***Minimum ASCII Delete Sum***.\n\nSadly, this approach fails on :\n `s1` = _\"aaaaazzzz\"_ & `s2` = _\"zzzzaaaaa\"_\n\nHere we can make the two strings equal by either keeping _\"aaaaa\"_ (removing _\"zzzz\"_) or by keeping _\"zzzz\"_ (removing _\"aaaaa\"_) from both the strings.\n\nkeeping the larger subsequence (_\"aaaaa\"_) and removing _\"zzzz\"_ costs ***484 ASCII points***, while\nkeeping the smaller subsequence (_\"zzzz\"_) and removing _\"aaaaa\"_ costs ***480 ASCII points***.\n\nWhich means keeping _\"aaaaa\"_ costs more than keeping _\"zzzz\"_. So the concept of ***Longest Common Subsequence*** doesn't apply in this case since the ***Longest Common Subsequence*** is costing more than a ***Smaller Common Subsequence***.\n\nUpvote if you found this useful."
                    }
                ]
            },
            {
                "id": 1993826,
                "content": [
                    {
                        "username": "sarthakvyadav",
                        "content": "This one is a standard Dp on strings problem which uses the concept of longest common subsequence."
                    },
                    {
                        "username": "dash_dash",
                        "content": "this is not that hard , dont give up "
                    },
                    {
                        "username": "kenzgf",
                        "content": "ez dp"
                    },
                    {
                        "username": "quanqx",
                        "content": "Longest common subsequence + a sum array to track maximum ASCII sum of LCS "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "classic problem: edit distance"
                    },
                    {
                        "username": "rohit252320",
                        "content": "in Example 2 if we remove only \\'De\\' from Delete than String s1 and s2 are \"leet\" and sum of deleting is 100[d] + 101[e] = 201 instead of 403. Anyone can suggest me, am i right or not"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "if you are deleting \\'De\\' then it\\'ll become \\'lete\\' and not \\'leet\\'. In other words, you cannot jumble the characters."
                    },
                    {
                        "username": "ajv97",
                        "content": "Last challenge of the month. Let\\'s do this thing. "
                    },
                    {
                        "username": "tanny0303",
                        "content": "\\nMY CODE IS GIVING MEMORY LIMIT EXCEEDED PLZ HELP\\n\\n    int val(string s,int ind)\\n    {\\n        int sum=0;\\n        for(int i=0;i<=ind;i++)\\n        {\\n            sum+=s[i];\\n        }\\n        return sum;\\n    }\\n\\n    int md(int fs,int ss,string s1,string s2,vector<vector<int>> &dp)\\n    {\\n        int m;\\n        if(fs<0 && ss<0)\\n        {\\n            return 0;\\n        }\\n        else if(fs<0 && ss>=0)\\n        {\\n            // m= s2[ss] + md(fs,ss-1,s1,s2,dp);\\n            return val(s2,ss);\\n        }\\n        else if(ss<0 && fs>=0)\\n        {\\n            // m= s1[fs] + md(fs-1,ss,s1,s2,dp);\\n            return val(s1,fs);\\n        }\\n        else if(dp[fs][ss]!=-1)\\n        {\\n            return dp[fs][ss];\\n        }\\n        else if(s1[fs]==s2[ss])\\n        {\\n            m= md(fs-1,ss-1,s1,s2,dp);\\n        }\\n        else{\\n            m= min( int(s1[fs]) + md(fs-1,ss,s1,s2,dp) , int(s2[ss]) +md(fs,ss-1,s1,s2,dp) );\\n        }\\n       \\n        return dp[fs][ss]=m;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        \\n        int fs=s1.size();\\n        int ss=s2.size();\\n\\n        vector<vector<int>> dp(fs,vector<int>(ss,-1));\\n\\n        int val=md(fs-1,ss-1,s1,s2,dp);\\n        return val;\\n    }"
                    },
                    {
                        "username": "pri1311",
                        "content": "pass strings by reference to the functions not by value"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Try to do it other way around like first calculating lcs with highest ascii value and then subtract it from the total value of two strings. It goes like...ascii(s1) + ascii(s2) - 2*ascii(lcs(s1,s2)) where ascii represents the ascii values of strings in the argument."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "Convert it into bottom-up DP"
                    },
                    {
                        "username": "psionl0",
                        "content": "My first monthly badge!\\n\\nEven though this is a Monday problem, LeetCode wasn\\'t about to just hand the badge over. I originally thought that it was a case of reducing each string to its longest common sub sequence and made sure that I could solve ``1143. Longest Common Subsequence`` first. \\n\\nHowever, there could be several LCSs of the same length. It turns out that the LCS problem is a bit of a red herring. This problem is way more difficult."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Don't do this mistake\n- Find ***Longest Common Subsequence***. \n- If multiple LCS found, choose one with the ***Minimum ASCII Delete Sum***.\n\nSadly, this approach fails on :\n `s1` = _\"aaaaazzzz\"_ & `s2` = _\"zzzzaaaaa\"_\n\nHere we can make the two strings equal by either keeping _\"aaaaa\"_ (removing _\"zzzz\"_) or by keeping _\"zzzz\"_ (removing _\"aaaaa\"_) from both the strings.\n\nkeeping the larger subsequence (_\"aaaaa\"_) and removing _\"zzzz\"_ costs ***484 ASCII points***, while\nkeeping the smaller subsequence (_\"zzzz\"_) and removing _\"aaaaa\"_ costs ***480 ASCII points***.\n\nWhich means keeping _\"aaaaa\"_ costs more than keeping _\"zzzz\"_. So the concept of ***Longest Common Subsequence*** doesn't apply in this case since the ***Longest Common Subsequence*** is costing more than a ***Smaller Common Subsequence***.\n\nUpvote if you found this useful."
                    }
                ]
            },
            {
                "id": 1993786,
                "content": [
                    {
                        "username": "sarthakvyadav",
                        "content": "This one is a standard Dp on strings problem which uses the concept of longest common subsequence."
                    },
                    {
                        "username": "dash_dash",
                        "content": "this is not that hard , dont give up "
                    },
                    {
                        "username": "kenzgf",
                        "content": "ez dp"
                    },
                    {
                        "username": "quanqx",
                        "content": "Longest common subsequence + a sum array to track maximum ASCII sum of LCS "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "classic problem: edit distance"
                    },
                    {
                        "username": "rohit252320",
                        "content": "in Example 2 if we remove only \\'De\\' from Delete than String s1 and s2 are \"leet\" and sum of deleting is 100[d] + 101[e] = 201 instead of 403. Anyone can suggest me, am i right or not"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "if you are deleting \\'De\\' then it\\'ll become \\'lete\\' and not \\'leet\\'. In other words, you cannot jumble the characters."
                    },
                    {
                        "username": "ajv97",
                        "content": "Last challenge of the month. Let\\'s do this thing. "
                    },
                    {
                        "username": "tanny0303",
                        "content": "\\nMY CODE IS GIVING MEMORY LIMIT EXCEEDED PLZ HELP\\n\\n    int val(string s,int ind)\\n    {\\n        int sum=0;\\n        for(int i=0;i<=ind;i++)\\n        {\\n            sum+=s[i];\\n        }\\n        return sum;\\n    }\\n\\n    int md(int fs,int ss,string s1,string s2,vector<vector<int>> &dp)\\n    {\\n        int m;\\n        if(fs<0 && ss<0)\\n        {\\n            return 0;\\n        }\\n        else if(fs<0 && ss>=0)\\n        {\\n            // m= s2[ss] + md(fs,ss-1,s1,s2,dp);\\n            return val(s2,ss);\\n        }\\n        else if(ss<0 && fs>=0)\\n        {\\n            // m= s1[fs] + md(fs-1,ss,s1,s2,dp);\\n            return val(s1,fs);\\n        }\\n        else if(dp[fs][ss]!=-1)\\n        {\\n            return dp[fs][ss];\\n        }\\n        else if(s1[fs]==s2[ss])\\n        {\\n            m= md(fs-1,ss-1,s1,s2,dp);\\n        }\\n        else{\\n            m= min( int(s1[fs]) + md(fs-1,ss,s1,s2,dp) , int(s2[ss]) +md(fs,ss-1,s1,s2,dp) );\\n        }\\n       \\n        return dp[fs][ss]=m;\\n    }\\n\\n    int minimumDeleteSum(string s1, string s2) {\\n        \\n        int fs=s1.size();\\n        int ss=s2.size();\\n\\n        vector<vector<int>> dp(fs,vector<int>(ss,-1));\\n\\n        int val=md(fs-1,ss-1,s1,s2,dp);\\n        return val;\\n    }"
                    },
                    {
                        "username": "pri1311",
                        "content": "pass strings by reference to the functions not by value"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "Try to do it other way around like first calculating lcs with highest ascii value and then subtract it from the total value of two strings. It goes like...ascii(s1) + ascii(s2) - 2*ascii(lcs(s1,s2)) where ascii represents the ascii values of strings in the argument."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "Convert it into bottom-up DP"
                    },
                    {
                        "username": "psionl0",
                        "content": "My first monthly badge!\\n\\nEven though this is a Monday problem, LeetCode wasn\\'t about to just hand the badge over. I originally thought that it was a case of reducing each string to its longest common sub sequence and made sure that I could solve ``1143. Longest Common Subsequence`` first. \\n\\nHowever, there could be several LCSs of the same length. It turns out that the LCS problem is a bit of a red herring. This problem is way more difficult."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Don't do this mistake\n- Find ***Longest Common Subsequence***. \n- If multiple LCS found, choose one with the ***Minimum ASCII Delete Sum***.\n\nSadly, this approach fails on :\n `s1` = _\"aaaaazzzz\"_ & `s2` = _\"zzzzaaaaa\"_\n\nHere we can make the two strings equal by either keeping _\"aaaaa\"_ (removing _\"zzzz\"_) or by keeping _\"zzzz\"_ (removing _\"aaaaa\"_) from both the strings.\n\nkeeping the larger subsequence (_\"aaaaa\"_) and removing _\"zzzz\"_ costs ***484 ASCII points***, while\nkeeping the smaller subsequence (_\"zzzz\"_) and removing _\"aaaaa\"_ costs ***480 ASCII points***.\n\nWhich means keeping _\"aaaaa\"_ costs more than keeping _\"zzzz\"_. So the concept of ***Longest Common Subsequence*** doesn't apply in this case since the ***Longest Common Subsequence*** is costing more than a ***Smaller Common Subsequence***.\n\nUpvote if you found this useful."
                    }
                ]
            }
        ]
    }
]